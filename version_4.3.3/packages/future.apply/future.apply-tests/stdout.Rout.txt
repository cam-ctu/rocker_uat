
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:31:36.158] plan(): Setting new future strategy stack:
[10:31:36.159] List of future strategies:
[10:31:36.159] 1. sequential:
[10:31:36.159]    - args: function (..., envir = parent.frame())
[10:31:36.159]    - tweaked: FALSE
[10:31:36.159]    - call: future::plan("sequential")
[10:31:36.173] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[10:31:36.206] plan(): Setting new future strategy stack:
[10:31:36.206] List of future strategies:
[10:31:36.206] 1. sequential:
[10:31:36.206]    - args: function (..., envir = parent.frame())
[10:31:36.206]    - tweaked: FALSE
[10:31:36.206]    - call: plan(strategy)
[10:31:36.216] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:31:36.217] future_lapply() ...
[10:31:36.221] Number of chunks: 1
[10:31:36.221] getGlobalsAndPackagesXApply() ...
[10:31:36.221]  - future.globals: TRUE
[10:31:36.222] getGlobalsAndPackages() ...
[10:31:36.222] Searching for globals...
[10:31:36.225] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:36.225] Searching for globals ... DONE
[10:31:36.225] Resolving globals: FALSE
[10:31:36.226] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:36.227] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:36.227] - globals: [1] ‘FUN’
[10:31:36.227] 
[10:31:36.227] getGlobalsAndPackages() ... DONE
[10:31:36.227]  - globals found/used: [n=1] ‘FUN’
[10:31:36.227]  - needed namespaces: [n=0] 
[10:31:36.227] Finding globals ... DONE
[10:31:36.227]  - use_args: TRUE
[10:31:36.227]  - Getting '...' globals ...
[10:31:36.228] resolve() on list ...
[10:31:36.228]  recursive: 0
[10:31:36.229]  length: 1
[10:31:36.229]  elements: ‘...’
[10:31:36.229]  length: 0 (resolved future 1)
[10:31:36.229] resolve() on list ... DONE
[10:31:36.229]    - '...' content: [n=0] 
[10:31:36.229] List of 1
[10:31:36.229]  $ ...: list()
[10:31:36.229]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:36.229]  - attr(*, "where")=List of 1
[10:31:36.229]   ..$ ...:<environment: 0x564ff3f31620> 
[10:31:36.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:36.229]  - attr(*, "resolved")= logi TRUE
[10:31:36.229]  - attr(*, "total_size")= num NA
[10:31:36.236]  - Getting '...' globals ... DONE
[10:31:36.236] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:36.236] List of 2
[10:31:36.236]  $ ...future.FUN:function (x)  
[10:31:36.236]  $ ...          : list()
[10:31:36.236]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:36.236]  - attr(*, "where")=List of 2
[10:31:36.236]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:36.236]   ..$ ...          :<environment: 0x564ff3f31620> 
[10:31:36.236]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:36.236]  - attr(*, "resolved")= logi FALSE
[10:31:36.236]  - attr(*, "total_size")= num 4720
[10:31:36.239] Packages to be attached in all futures: [n=0] 
[10:31:36.239] getGlobalsAndPackagesXApply() ... DONE
[10:31:36.239] Number of futures (= number of chunks): 1
[10:31:36.239] Launching 1 futures (chunks) ...
[10:31:36.239] Chunk #1 of 1 ...
[10:31:36.240]  - Finding globals in 'X' for chunk #1 ...
[10:31:36.240] getGlobalsAndPackages() ...
[10:31:36.240] Searching for globals...
[10:31:36.240] 
[10:31:36.240] Searching for globals ... DONE
[10:31:36.240] - globals: [0] <none>
[10:31:36.240] getGlobalsAndPackages() ... DONE
[10:31:36.240]    + additional globals found: [n=0] 
[10:31:36.240]    + additional namespaces needed: [n=0] 
[10:31:36.241]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:36.241]  - seeds: <none>
[10:31:36.241]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:36.241] getGlobalsAndPackages() ...
[10:31:36.241] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:36.241] Resolving globals: FALSE
[10:31:36.241] Tweak future expression to call with '...' arguments ...
[10:31:36.241] {
[10:31:36.241]     do.call(function(...) {
[10:31:36.241]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:36.241]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:36.241]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:36.241]             on.exit(options(oopts), add = TRUE)
[10:31:36.241]         }
[10:31:36.241]         {
[10:31:36.241]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:36.241]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:36.241]                 ...future.FUN(...future.X_jj, ...)
[10:31:36.241]             })
[10:31:36.241]         }
[10:31:36.241]     }, args = future.call.arguments)
[10:31:36.241] }
[10:31:36.242] Tweak future expression to call with '...' arguments ... DONE
[10:31:36.242] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:36.242] 
[10:31:36.242] getGlobalsAndPackages() ... DONE
[10:31:36.243] run() for ‘Future’ ...
[10:31:36.243] - state: ‘created’
[10:31:36.243] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:36.244] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:36.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:36.244]   - Field: ‘label’
[10:31:36.244]   - Field: ‘local’
[10:31:36.244]   - Field: ‘owner’
[10:31:36.244]   - Field: ‘envir’
[10:31:36.244]   - Field: ‘packages’
[10:31:36.244]   - Field: ‘gc’
[10:31:36.244]   - Field: ‘conditions’
[10:31:36.244]   - Field: ‘expr’
[10:31:36.244]   - Field: ‘uuid’
[10:31:36.245]   - Field: ‘seed’
[10:31:36.245]   - Field: ‘version’
[10:31:36.245]   - Field: ‘result’
[10:31:36.245]   - Field: ‘asynchronous’
[10:31:36.245]   - Field: ‘calls’
[10:31:36.245]   - Field: ‘globals’
[10:31:36.245]   - Field: ‘stdout’
[10:31:36.245]   - Field: ‘earlySignal’
[10:31:36.245]   - Field: ‘lazy’
[10:31:36.245]   - Field: ‘state’
[10:31:36.245] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:36.246] - Launch lazy future ...
[10:31:36.246] Packages needed by the future expression (n = 0): <none>
[10:31:36.246] Packages needed by future strategies (n = 0): <none>
[10:31:36.247] {
[10:31:36.247]     {
[10:31:36.247]         {
[10:31:36.247]             ...future.startTime <- base::Sys.time()
[10:31:36.247]             {
[10:31:36.247]                 {
[10:31:36.247]                   {
[10:31:36.247]                     base::local({
[10:31:36.247]                       has_future <- base::requireNamespace("future", 
[10:31:36.247]                         quietly = TRUE)
[10:31:36.247]                       if (has_future) {
[10:31:36.247]                         ns <- base::getNamespace("future")
[10:31:36.247]                         version <- ns[[".package"]][["version"]]
[10:31:36.247]                         if (is.null(version)) 
[10:31:36.247]                           version <- utils::packageVersion("future")
[10:31:36.247]                       }
[10:31:36.247]                       else {
[10:31:36.247]                         version <- NULL
[10:31:36.247]                       }
[10:31:36.247]                       if (!has_future || version < "1.8.0") {
[10:31:36.247]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:36.247]                           "", base::R.version$version.string), 
[10:31:36.247]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:36.247]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:36.247]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:36.247]                             "release", "version")], collapse = " "), 
[10:31:36.247]                           hostname = base::Sys.info()[["nodename"]])
[10:31:36.247]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:36.247]                           info)
[10:31:36.247]                         info <- base::paste(info, collapse = "; ")
[10:31:36.247]                         if (!has_future) {
[10:31:36.247]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:36.247]                             info)
[10:31:36.247]                         }
[10:31:36.247]                         else {
[10:31:36.247]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:36.247]                             info, version)
[10:31:36.247]                         }
[10:31:36.247]                         base::stop(msg)
[10:31:36.247]                       }
[10:31:36.247]                     })
[10:31:36.247]                   }
[10:31:36.247]                   ...future.strategy.old <- future::plan("list")
[10:31:36.247]                   options(future.plan = NULL)
[10:31:36.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:36.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:36.247]                 }
[10:31:36.247]                 ...future.workdir <- getwd()
[10:31:36.247]             }
[10:31:36.247]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:36.247]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:36.247]         }
[10:31:36.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:36.247]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:36.247]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:36.247]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:36.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:36.247]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:36.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:36.247]             base::names(...future.oldOptions))
[10:31:36.247]     }
[10:31:36.247]     if (FALSE) {
[10:31:36.247]     }
[10:31:36.247]     else {
[10:31:36.247]         if (FALSE) {
[10:31:36.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:36.247]                 open = "w")
[10:31:36.247]         }
[10:31:36.247]         else {
[10:31:36.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:36.247]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:36.247]         }
[10:31:36.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:36.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:36.247]             base::sink(type = "output", split = FALSE)
[10:31:36.247]             base::close(...future.stdout)
[10:31:36.247]         }, add = TRUE)
[10:31:36.247]     }
[10:31:36.247]     ...future.frame <- base::sys.nframe()
[10:31:36.247]     ...future.conditions <- base::list()
[10:31:36.247]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:36.247]     if (FALSE) {
[10:31:36.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:36.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:36.247]     }
[10:31:36.247]     ...future.result <- base::tryCatch({
[10:31:36.247]         base::withCallingHandlers({
[10:31:36.247]             ...future.value <- base::withVisible(base::local({
[10:31:36.247]                 do.call(function(...) {
[10:31:36.247]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:36.247]                   if (!identical(...future.globals.maxSize.org, 
[10:31:36.247]                     ...future.globals.maxSize)) {
[10:31:36.247]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:36.247]                     on.exit(options(oopts), add = TRUE)
[10:31:36.247]                   }
[10:31:36.247]                   {
[10:31:36.247]                     lapply(seq_along(...future.elements_ii), 
[10:31:36.247]                       FUN = function(jj) {
[10:31:36.247]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:36.247]                         ...future.FUN(...future.X_jj, ...)
[10:31:36.247]                       })
[10:31:36.247]                   }
[10:31:36.247]                 }, args = future.call.arguments)
[10:31:36.247]             }))
[10:31:36.247]             future::FutureResult(value = ...future.value$value, 
[10:31:36.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:36.247]                   ...future.rng), globalenv = if (FALSE) 
[10:31:36.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:36.247]                     ...future.globalenv.names))
[10:31:36.247]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:36.247]         }, condition = base::local({
[10:31:36.247]             c <- base::c
[10:31:36.247]             inherits <- base::inherits
[10:31:36.247]             invokeRestart <- base::invokeRestart
[10:31:36.247]             length <- base::length
[10:31:36.247]             list <- base::list
[10:31:36.247]             seq.int <- base::seq.int
[10:31:36.247]             signalCondition <- base::signalCondition
[10:31:36.247]             sys.calls <- base::sys.calls
[10:31:36.247]             `[[` <- base::`[[`
[10:31:36.247]             `+` <- base::`+`
[10:31:36.247]             `<<-` <- base::`<<-`
[10:31:36.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:36.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:36.247]                   3L)]
[10:31:36.247]             }
[10:31:36.247]             function(cond) {
[10:31:36.247]                 is_error <- inherits(cond, "error")
[10:31:36.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:36.247]                   NULL)
[10:31:36.247]                 if (is_error) {
[10:31:36.247]                   sessionInformation <- function() {
[10:31:36.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:36.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:36.247]                       search = base::search(), system = base::Sys.info())
[10:31:36.247]                   }
[10:31:36.247]                   ...future.conditions[[length(...future.conditions) + 
[10:31:36.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:36.247]                     cond$call), session = sessionInformation(), 
[10:31:36.247]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:36.247]                   signalCondition(cond)
[10:31:36.247]                 }
[10:31:36.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:36.247]                 "immediateCondition"))) {
[10:31:36.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:36.247]                   ...future.conditions[[length(...future.conditions) + 
[10:31:36.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:36.247]                   if (TRUE && !signal) {
[10:31:36.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:36.247]                     {
[10:31:36.247]                       inherits <- base::inherits
[10:31:36.247]                       invokeRestart <- base::invokeRestart
[10:31:36.247]                       is.null <- base::is.null
[10:31:36.247]                       muffled <- FALSE
[10:31:36.247]                       if (inherits(cond, "message")) {
[10:31:36.247]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:36.247]                         if (muffled) 
[10:31:36.247]                           invokeRestart("muffleMessage")
[10:31:36.247]                       }
[10:31:36.247]                       else if (inherits(cond, "warning")) {
[10:31:36.247]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:36.247]                         if (muffled) 
[10:31:36.247]                           invokeRestart("muffleWarning")
[10:31:36.247]                       }
[10:31:36.247]                       else if (inherits(cond, "condition")) {
[10:31:36.247]                         if (!is.null(pattern)) {
[10:31:36.247]                           computeRestarts <- base::computeRestarts
[10:31:36.247]                           grepl <- base::grepl
[10:31:36.247]                           restarts <- computeRestarts(cond)
[10:31:36.247]                           for (restart in restarts) {
[10:31:36.247]                             name <- restart$name
[10:31:36.247]                             if (is.null(name)) 
[10:31:36.247]                               next
[10:31:36.247]                             if (!grepl(pattern, name)) 
[10:31:36.247]                               next
[10:31:36.247]                             invokeRestart(restart)
[10:31:36.247]                             muffled <- TRUE
[10:31:36.247]                             break
[10:31:36.247]                           }
[10:31:36.247]                         }
[10:31:36.247]                       }
[10:31:36.247]                       invisible(muffled)
[10:31:36.247]                     }
[10:31:36.247]                     muffleCondition(cond, pattern = "^muffle")
[10:31:36.247]                   }
[10:31:36.247]                 }
[10:31:36.247]                 else {
[10:31:36.247]                   if (TRUE) {
[10:31:36.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:36.247]                     {
[10:31:36.247]                       inherits <- base::inherits
[10:31:36.247]                       invokeRestart <- base::invokeRestart
[10:31:36.247]                       is.null <- base::is.null
[10:31:36.247]                       muffled <- FALSE
[10:31:36.247]                       if (inherits(cond, "message")) {
[10:31:36.247]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:36.247]                         if (muffled) 
[10:31:36.247]                           invokeRestart("muffleMessage")
[10:31:36.247]                       }
[10:31:36.247]                       else if (inherits(cond, "warning")) {
[10:31:36.247]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:36.247]                         if (muffled) 
[10:31:36.247]                           invokeRestart("muffleWarning")
[10:31:36.247]                       }
[10:31:36.247]                       else if (inherits(cond, "condition")) {
[10:31:36.247]                         if (!is.null(pattern)) {
[10:31:36.247]                           computeRestarts <- base::computeRestarts
[10:31:36.247]                           grepl <- base::grepl
[10:31:36.247]                           restarts <- computeRestarts(cond)
[10:31:36.247]                           for (restart in restarts) {
[10:31:36.247]                             name <- restart$name
[10:31:36.247]                             if (is.null(name)) 
[10:31:36.247]                               next
[10:31:36.247]                             if (!grepl(pattern, name)) 
[10:31:36.247]                               next
[10:31:36.247]                             invokeRestart(restart)
[10:31:36.247]                             muffled <- TRUE
[10:31:36.247]                             break
[10:31:36.247]                           }
[10:31:36.247]                         }
[10:31:36.247]                       }
[10:31:36.247]                       invisible(muffled)
[10:31:36.247]                     }
[10:31:36.247]                     muffleCondition(cond, pattern = "^muffle")
[10:31:36.247]                   }
[10:31:36.247]                 }
[10:31:36.247]             }
[10:31:36.247]         }))
[10:31:36.247]     }, error = function(ex) {
[10:31:36.247]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:36.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:36.247]                 ...future.rng), started = ...future.startTime, 
[10:31:36.247]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:36.247]             version = "1.8"), class = "FutureResult")
[10:31:36.247]     }, finally = {
[10:31:36.247]         if (!identical(...future.workdir, getwd())) 
[10:31:36.247]             setwd(...future.workdir)
[10:31:36.247]         {
[10:31:36.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:36.247]                 ...future.oldOptions$nwarnings <- NULL
[10:31:36.247]             }
[10:31:36.247]             base::options(...future.oldOptions)
[10:31:36.247]             if (.Platform$OS.type == "windows") {
[10:31:36.247]                 old_names <- names(...future.oldEnvVars)
[10:31:36.247]                 envs <- base::Sys.getenv()
[10:31:36.247]                 names <- names(envs)
[10:31:36.247]                 common <- intersect(names, old_names)
[10:31:36.247]                 added <- setdiff(names, old_names)
[10:31:36.247]                 removed <- setdiff(old_names, names)
[10:31:36.247]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:36.247]                   envs[common]]
[10:31:36.247]                 NAMES <- toupper(changed)
[10:31:36.247]                 args <- list()
[10:31:36.247]                 for (kk in seq_along(NAMES)) {
[10:31:36.247]                   name <- changed[[kk]]
[10:31:36.247]                   NAME <- NAMES[[kk]]
[10:31:36.247]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:36.247]                     next
[10:31:36.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:36.247]                 }
[10:31:36.247]                 NAMES <- toupper(added)
[10:31:36.247]                 for (kk in seq_along(NAMES)) {
[10:31:36.247]                   name <- added[[kk]]
[10:31:36.247]                   NAME <- NAMES[[kk]]
[10:31:36.247]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:36.247]                     next
[10:31:36.247]                   args[[name]] <- ""
[10:31:36.247]                 }
[10:31:36.247]                 NAMES <- toupper(removed)
[10:31:36.247]                 for (kk in seq_along(NAMES)) {
[10:31:36.247]                   name <- removed[[kk]]
[10:31:36.247]                   NAME <- NAMES[[kk]]
[10:31:36.247]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:36.247]                     next
[10:31:36.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:36.247]                 }
[10:31:36.247]                 if (length(args) > 0) 
[10:31:36.247]                   base::do.call(base::Sys.setenv, args = args)
[10:31:36.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:36.247]             }
[10:31:36.247]             else {
[10:31:36.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:36.247]             }
[10:31:36.247]             {
[10:31:36.247]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:36.247]                   0L) {
[10:31:36.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:36.247]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:36.247]                   base::options(opts)
[10:31:36.247]                 }
[10:31:36.247]                 {
[10:31:36.247]                   {
[10:31:36.247]                     NULL
[10:31:36.247]                     RNGkind("Mersenne-Twister")
[10:31:36.247]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:36.247]                       inherits = FALSE)
[10:31:36.247]                   }
[10:31:36.247]                   options(future.plan = NULL)
[10:31:36.247]                   if (is.na(NA_character_)) 
[10:31:36.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:36.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:36.247]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:36.247]                     .init = FALSE)
[10:31:36.247]                 }
[10:31:36.247]             }
[10:31:36.247]         }
[10:31:36.247]     })
[10:31:36.247]     if (TRUE) {
[10:31:36.247]         base::sink(type = "output", split = FALSE)
[10:31:36.247]         if (FALSE) {
[10:31:36.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:36.247]         }
[10:31:36.247]         else {
[10:31:36.247]             ...future.result["stdout"] <- base::list(NULL)
[10:31:36.247]         }
[10:31:36.247]         base::close(...future.stdout)
[10:31:36.247]         ...future.stdout <- NULL
[10:31:36.247]     }
[10:31:36.247]     ...future.result$conditions <- ...future.conditions
[10:31:36.247]     ...future.result$finished <- base::Sys.time()
[10:31:36.247]     ...future.result
[10:31:36.247] }
[10:31:36.249] assign_globals() ...
[10:31:36.249] List of 5
[10:31:36.249]  $ ...future.FUN            :function (x)  
[10:31:36.249]  $ future.call.arguments    : list()
[10:31:36.249]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:36.249]  $ ...future.elements_ii    :List of 2
[10:31:36.249]   ..$ : int 1
[10:31:36.249]   ..$ : int 0
[10:31:36.249]  $ ...future.seeds_ii       : NULL
[10:31:36.249]  $ ...future.globals.maxSize: NULL
[10:31:36.249]  - attr(*, "where")=List of 5
[10:31:36.249]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:36.249]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:36.249]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:36.249]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:36.249]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:36.249]  - attr(*, "resolved")= logi FALSE
[10:31:36.249]  - attr(*, "total_size")= num 4720
[10:31:36.249]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:36.249]  - attr(*, "already-done")= logi TRUE
[10:31:36.254] - reassign environment for ‘...future.FUN’
[10:31:36.254] - copied ‘...future.FUN’ to environment
[10:31:36.254] - copied ‘future.call.arguments’ to environment
[10:31:36.254] - copied ‘...future.elements_ii’ to environment
[10:31:36.254] - copied ‘...future.seeds_ii’ to environment
[10:31:36.254] - copied ‘...future.globals.maxSize’ to environment
[10:31:36.254] assign_globals() ... done
[10:31:36.255] plan(): Setting new future strategy stack:
[10:31:36.255] List of future strategies:
[10:31:36.255] 1. sequential:
[10:31:36.255]    - args: function (..., envir = parent.frame())
[10:31:36.255]    - tweaked: FALSE
[10:31:36.255]    - call: NULL
[10:31:36.255] plan(): nbrOfWorkers() = 1
[10:31:36.757] plan(): Setting new future strategy stack:
[10:31:36.758] List of future strategies:
[10:31:36.758] 1. sequential:
[10:31:36.758]    - args: function (..., envir = parent.frame())
[10:31:36.758]    - tweaked: FALSE
[10:31:36.758]    - call: plan(strategy)
[10:31:36.758] plan(): nbrOfWorkers() = 1
[10:31:36.758] SequentialFuture started (and completed)
[10:31:36.759] - Launch lazy future ... done
[10:31:36.759] run() for ‘SequentialFuture’ ... done
[10:31:36.759] Created future:
[10:31:36.759] SequentialFuture:
[10:31:36.759] Label: ‘future_lapply-1’
[10:31:36.759] Expression:
[10:31:36.759] {
[10:31:36.759]     do.call(function(...) {
[10:31:36.759]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:36.759]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:36.759]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:36.759]             on.exit(options(oopts), add = TRUE)
[10:31:36.759]         }
[10:31:36.759]         {
[10:31:36.759]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:36.759]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:36.759]                 ...future.FUN(...future.X_jj, ...)
[10:31:36.759]             })
[10:31:36.759]         }
[10:31:36.759]     }, args = future.call.arguments)
[10:31:36.759] }
[10:31:36.759] Lazy evaluation: FALSE
[10:31:36.759] Asynchronous evaluation: FALSE
[10:31:36.759] Local evaluation: TRUE
[10:31:36.759] Environment: R_GlobalEnv
[10:31:36.759] Capture standard output: FALSE
[10:31:36.759] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:36.759] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:36.759] Packages: <none>
[10:31:36.759] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:36.759] Resolved: TRUE
[10:31:36.759] Value: 112 bytes of class ‘list’
[10:31:36.759] Early signaling: FALSE
[10:31:36.759] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:36.759] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:36.761] Chunk #1 of 1 ... DONE
[10:31:36.761] Launching 1 futures (chunks) ... DONE
[10:31:36.761] Resolving 1 futures (chunks) ...
[10:31:36.761] resolve() on list ...
[10:31:36.761]  recursive: 0
[10:31:36.761]  length: 1
[10:31:36.761] 
[10:31:36.762] resolved() for ‘SequentialFuture’ ...
[10:31:36.762] - state: ‘finished’
[10:31:36.762] - run: TRUE
[10:31:36.762] - result: ‘FutureResult’
[10:31:36.762] resolved() for ‘SequentialFuture’ ... done
[10:31:36.762] Future #1
[10:31:36.763] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:36.763] - nx: 1
[10:31:36.763] - relay: TRUE
[10:31:36.763] - stdout: TRUE
[10:31:36.763] - signal: TRUE
[10:31:36.763] - resignal: FALSE
[10:31:36.763] - force: TRUE
[10:31:36.763] - relayed: [n=1] FALSE
[10:31:36.763] - queued futures: [n=1] FALSE
[10:31:36.763]  - until=1
[10:31:36.763]  - relaying element #1
[10:31:36.764] - relayed: [n=1] TRUE
[10:31:36.764] - queued futures: [n=1] TRUE
[10:31:36.764] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:36.764]  length: 0 (resolved future 1)
[10:31:36.766] Relaying remaining futures
[10:31:36.766] signalConditionsASAP(NULL, pos=0) ...
[10:31:36.766] - nx: 1
[10:31:36.766] - relay: TRUE
[10:31:36.766] - stdout: TRUE
[10:31:36.767] - signal: TRUE
[10:31:36.767] - resignal: FALSE
[10:31:36.767] - force: TRUE
[10:31:36.767] - relayed: [n=1] TRUE
[10:31:36.767] - queued futures: [n=1] TRUE
 - flush all
[10:31:36.767] - relayed: [n=1] TRUE
[10:31:36.767] - queued futures: [n=1] TRUE
[10:31:36.767] signalConditionsASAP(NULL, pos=0) ... done
[10:31:36.767] resolve() on list ... DONE
[10:31:36.767]  - Number of value chunks collected: 1
[10:31:36.768] Resolving 1 futures (chunks) ... DONE
[10:31:36.768] Reducing values from 1 chunks ...
[10:31:36.768]  - Number of values collected after concatenation: 2
[10:31:36.768]  - Number of values expected: 2
[10:31:36.768] Reducing values from 1 chunks ... DONE
[10:31:36.768] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:31:36.768] future_lapply() ...
[10:31:36.769] Number of chunks: 1
[10:31:36.769] getGlobalsAndPackagesXApply() ...
[10:31:36.769]  - future.globals: TRUE
[10:31:36.770] getGlobalsAndPackages() ...
[10:31:36.770] Searching for globals...
[10:31:36.771] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:36.771] Searching for globals ... DONE
[10:31:36.771] Resolving globals: FALSE
[10:31:36.772] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:36.772] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:36.772] - globals: [1] ‘FUN’
[10:31:36.772] 
[10:31:36.772] getGlobalsAndPackages() ... DONE
[10:31:36.772]  - globals found/used: [n=1] ‘FUN’
[10:31:36.773]  - needed namespaces: [n=0] 
[10:31:36.773] Finding globals ... DONE
[10:31:36.773]  - use_args: TRUE
[10:31:36.773]  - Getting '...' globals ...
[10:31:36.773] resolve() on list ...
[10:31:36.773]  recursive: 0
[10:31:36.773]  length: 1
[10:31:36.773]  elements: ‘...’
[10:31:36.774]  length: 0 (resolved future 1)
[10:31:36.774] resolve() on list ... DONE
[10:31:36.774]    - '...' content: [n=0] 
[10:31:36.774] List of 1
[10:31:36.774]  $ ...: list()
[10:31:36.774]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:36.774]  - attr(*, "where")=List of 1
[10:31:36.774]   ..$ ...:<environment: 0x564ff29f3410> 
[10:31:36.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:36.774]  - attr(*, "resolved")= logi TRUE
[10:31:36.774]  - attr(*, "total_size")= num NA
[10:31:36.776]  - Getting '...' globals ... DONE
[10:31:36.777] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:36.777] List of 2
[10:31:36.777]  $ ...future.FUN:function (x)  
[10:31:36.777]  $ ...          : list()
[10:31:36.777]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:36.777]  - attr(*, "where")=List of 2
[10:31:36.777]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:36.777]   ..$ ...          :<environment: 0x564ff29f3410> 
[10:31:36.777]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:36.777]  - attr(*, "resolved")= logi FALSE
[10:31:36.777]  - attr(*, "total_size")= num 4720
[10:31:36.779] Packages to be attached in all futures: [n=0] 
[10:31:36.779] getGlobalsAndPackagesXApply() ... DONE
[10:31:36.780] Number of futures (= number of chunks): 1
[10:31:36.780] Launching 1 futures (chunks) ...
[10:31:36.780] Chunk #1 of 1 ...
[10:31:36.780]  - Finding globals in 'X' for chunk #1 ...
[10:31:36.780] getGlobalsAndPackages() ...
[10:31:36.780] Searching for globals...
[10:31:36.780] 
[10:31:36.781] Searching for globals ... DONE
[10:31:36.781] - globals: [0] <none>
[10:31:36.781] getGlobalsAndPackages() ... DONE
[10:31:36.781]    + additional globals found: [n=0] 
[10:31:36.781]    + additional namespaces needed: [n=0] 
[10:31:36.781]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:36.781]  - seeds: <none>
[10:31:36.781]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:36.781] getGlobalsAndPackages() ...
[10:31:36.781] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:36.782] Resolving globals: FALSE
[10:31:36.782] Tweak future expression to call with '...' arguments ...
[10:31:36.782] {
[10:31:36.782]     do.call(function(...) {
[10:31:36.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:36.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:36.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:36.782]             on.exit(options(oopts), add = TRUE)
[10:31:36.782]         }
[10:31:36.782]         {
[10:31:36.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:36.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:36.782]                 ...future.FUN(...future.X_jj, ...)
[10:31:36.782]             })
[10:31:36.782]         }
[10:31:36.782]     }, args = future.call.arguments)
[10:31:36.782] }
[10:31:36.782] Tweak future expression to call with '...' arguments ... DONE
[10:31:36.782] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:36.782] 
[10:31:36.783] getGlobalsAndPackages() ... DONE
[10:31:36.783] run() for ‘Future’ ...
[10:31:36.783] - state: ‘created’
[10:31:36.783] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:36.783] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:36.784] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:36.784]   - Field: ‘label’
[10:31:36.784]   - Field: ‘local’
[10:31:36.784]   - Field: ‘owner’
[10:31:36.784]   - Field: ‘envir’
[10:31:36.784]   - Field: ‘packages’
[10:31:36.784]   - Field: ‘gc’
[10:31:36.784]   - Field: ‘conditions’
[10:31:36.784]   - Field: ‘expr’
[10:31:36.784]   - Field: ‘uuid’
[10:31:36.784]   - Field: ‘seed’
[10:31:36.785]   - Field: ‘version’
[10:31:36.785]   - Field: ‘result’
[10:31:36.785]   - Field: ‘asynchronous’
[10:31:36.785]   - Field: ‘calls’
[10:31:36.785]   - Field: ‘globals’
[10:31:36.785]   - Field: ‘stdout’
[10:31:36.785]   - Field: ‘earlySignal’
[10:31:36.785]   - Field: ‘lazy’
[10:31:36.785]   - Field: ‘state’
[10:31:36.785] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:36.786] - Launch lazy future ...
[10:31:36.786] Packages needed by the future expression (n = 0): <none>
[10:31:36.786] Packages needed by future strategies (n = 0): <none>
[10:31:36.786] {
[10:31:36.786]     {
[10:31:36.786]         {
[10:31:36.786]             ...future.startTime <- base::Sys.time()
[10:31:36.786]             {
[10:31:36.786]                 {
[10:31:36.786]                   {
[10:31:36.786]                     base::local({
[10:31:36.786]                       has_future <- base::requireNamespace("future", 
[10:31:36.786]                         quietly = TRUE)
[10:31:36.786]                       if (has_future) {
[10:31:36.786]                         ns <- base::getNamespace("future")
[10:31:36.786]                         version <- ns[[".package"]][["version"]]
[10:31:36.786]                         if (is.null(version)) 
[10:31:36.786]                           version <- utils::packageVersion("future")
[10:31:36.786]                       }
[10:31:36.786]                       else {
[10:31:36.786]                         version <- NULL
[10:31:36.786]                       }
[10:31:36.786]                       if (!has_future || version < "1.8.0") {
[10:31:36.786]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:36.786]                           "", base::R.version$version.string), 
[10:31:36.786]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:36.786]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:36.786]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:36.786]                             "release", "version")], collapse = " "), 
[10:31:36.786]                           hostname = base::Sys.info()[["nodename"]])
[10:31:36.786]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:36.786]                           info)
[10:31:36.786]                         info <- base::paste(info, collapse = "; ")
[10:31:36.786]                         if (!has_future) {
[10:31:36.786]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:36.786]                             info)
[10:31:36.786]                         }
[10:31:36.786]                         else {
[10:31:36.786]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:36.786]                             info, version)
[10:31:36.786]                         }
[10:31:36.786]                         base::stop(msg)
[10:31:36.786]                       }
[10:31:36.786]                     })
[10:31:36.786]                   }
[10:31:36.786]                   ...future.strategy.old <- future::plan("list")
[10:31:36.786]                   options(future.plan = NULL)
[10:31:36.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:36.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:36.786]                 }
[10:31:36.786]                 ...future.workdir <- getwd()
[10:31:36.786]             }
[10:31:36.786]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:36.786]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:36.786]         }
[10:31:36.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:36.786]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:36.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:36.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:36.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:36.786]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:36.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:36.786]             base::names(...future.oldOptions))
[10:31:36.786]     }
[10:31:36.786]     if (FALSE) {
[10:31:36.786]     }
[10:31:36.786]     else {
[10:31:36.786]         if (TRUE) {
[10:31:36.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:36.786]                 open = "w")
[10:31:36.786]         }
[10:31:36.786]         else {
[10:31:36.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:36.786]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:36.786]         }
[10:31:36.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:36.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:36.786]             base::sink(type = "output", split = FALSE)
[10:31:36.786]             base::close(...future.stdout)
[10:31:36.786]         }, add = TRUE)
[10:31:36.786]     }
[10:31:36.786]     ...future.frame <- base::sys.nframe()
[10:31:36.786]     ...future.conditions <- base::list()
[10:31:36.786]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:36.786]     if (FALSE) {
[10:31:36.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:36.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:36.786]     }
[10:31:36.786]     ...future.result <- base::tryCatch({
[10:31:36.786]         base::withCallingHandlers({
[10:31:36.786]             ...future.value <- base::withVisible(base::local({
[10:31:36.786]                 do.call(function(...) {
[10:31:36.786]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:36.786]                   if (!identical(...future.globals.maxSize.org, 
[10:31:36.786]                     ...future.globals.maxSize)) {
[10:31:36.786]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:36.786]                     on.exit(options(oopts), add = TRUE)
[10:31:36.786]                   }
[10:31:36.786]                   {
[10:31:36.786]                     lapply(seq_along(...future.elements_ii), 
[10:31:36.786]                       FUN = function(jj) {
[10:31:36.786]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:36.786]                         ...future.FUN(...future.X_jj, ...)
[10:31:36.786]                       })
[10:31:36.786]                   }
[10:31:36.786]                 }, args = future.call.arguments)
[10:31:36.786]             }))
[10:31:36.786]             future::FutureResult(value = ...future.value$value, 
[10:31:36.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:36.786]                   ...future.rng), globalenv = if (FALSE) 
[10:31:36.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:36.786]                     ...future.globalenv.names))
[10:31:36.786]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:36.786]         }, condition = base::local({
[10:31:36.786]             c <- base::c
[10:31:36.786]             inherits <- base::inherits
[10:31:36.786]             invokeRestart <- base::invokeRestart
[10:31:36.786]             length <- base::length
[10:31:36.786]             list <- base::list
[10:31:36.786]             seq.int <- base::seq.int
[10:31:36.786]             signalCondition <- base::signalCondition
[10:31:36.786]             sys.calls <- base::sys.calls
[10:31:36.786]             `[[` <- base::`[[`
[10:31:36.786]             `+` <- base::`+`
[10:31:36.786]             `<<-` <- base::`<<-`
[10:31:36.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:36.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:36.786]                   3L)]
[10:31:36.786]             }
[10:31:36.786]             function(cond) {
[10:31:36.786]                 is_error <- inherits(cond, "error")
[10:31:36.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:36.786]                   NULL)
[10:31:36.786]                 if (is_error) {
[10:31:36.786]                   sessionInformation <- function() {
[10:31:36.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:36.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:36.786]                       search = base::search(), system = base::Sys.info())
[10:31:36.786]                   }
[10:31:36.786]                   ...future.conditions[[length(...future.conditions) + 
[10:31:36.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:36.786]                     cond$call), session = sessionInformation(), 
[10:31:36.786]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:36.786]                   signalCondition(cond)
[10:31:36.786]                 }
[10:31:36.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:36.786]                 "immediateCondition"))) {
[10:31:36.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:36.786]                   ...future.conditions[[length(...future.conditions) + 
[10:31:36.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:36.786]                   if (TRUE && !signal) {
[10:31:36.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:36.786]                     {
[10:31:36.786]                       inherits <- base::inherits
[10:31:36.786]                       invokeRestart <- base::invokeRestart
[10:31:36.786]                       is.null <- base::is.null
[10:31:36.786]                       muffled <- FALSE
[10:31:36.786]                       if (inherits(cond, "message")) {
[10:31:36.786]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:36.786]                         if (muffled) 
[10:31:36.786]                           invokeRestart("muffleMessage")
[10:31:36.786]                       }
[10:31:36.786]                       else if (inherits(cond, "warning")) {
[10:31:36.786]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:36.786]                         if (muffled) 
[10:31:36.786]                           invokeRestart("muffleWarning")
[10:31:36.786]                       }
[10:31:36.786]                       else if (inherits(cond, "condition")) {
[10:31:36.786]                         if (!is.null(pattern)) {
[10:31:36.786]                           computeRestarts <- base::computeRestarts
[10:31:36.786]                           grepl <- base::grepl
[10:31:36.786]                           restarts <- computeRestarts(cond)
[10:31:36.786]                           for (restart in restarts) {
[10:31:36.786]                             name <- restart$name
[10:31:36.786]                             if (is.null(name)) 
[10:31:36.786]                               next
[10:31:36.786]                             if (!grepl(pattern, name)) 
[10:31:36.786]                               next
[10:31:36.786]                             invokeRestart(restart)
[10:31:36.786]                             muffled <- TRUE
[10:31:36.786]                             break
[10:31:36.786]                           }
[10:31:36.786]                         }
[10:31:36.786]                       }
[10:31:36.786]                       invisible(muffled)
[10:31:36.786]                     }
[10:31:36.786]                     muffleCondition(cond, pattern = "^muffle")
[10:31:36.786]                   }
[10:31:36.786]                 }
[10:31:36.786]                 else {
[10:31:36.786]                   if (TRUE) {
[10:31:36.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:36.786]                     {
[10:31:36.786]                       inherits <- base::inherits
[10:31:36.786]                       invokeRestart <- base::invokeRestart
[10:31:36.786]                       is.null <- base::is.null
[10:31:36.786]                       muffled <- FALSE
[10:31:36.786]                       if (inherits(cond, "message")) {
[10:31:36.786]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:36.786]                         if (muffled) 
[10:31:36.786]                           invokeRestart("muffleMessage")
[10:31:36.786]                       }
[10:31:36.786]                       else if (inherits(cond, "warning")) {
[10:31:36.786]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:36.786]                         if (muffled) 
[10:31:36.786]                           invokeRestart("muffleWarning")
[10:31:36.786]                       }
[10:31:36.786]                       else if (inherits(cond, "condition")) {
[10:31:36.786]                         if (!is.null(pattern)) {
[10:31:36.786]                           computeRestarts <- base::computeRestarts
[10:31:36.786]                           grepl <- base::grepl
[10:31:36.786]                           restarts <- computeRestarts(cond)
[10:31:36.786]                           for (restart in restarts) {
[10:31:36.786]                             name <- restart$name
[10:31:36.786]                             if (is.null(name)) 
[10:31:36.786]                               next
[10:31:36.786]                             if (!grepl(pattern, name)) 
[10:31:36.786]                               next
[10:31:36.786]                             invokeRestart(restart)
[10:31:36.786]                             muffled <- TRUE
[10:31:36.786]                             break
[10:31:36.786]                           }
[10:31:36.786]                         }
[10:31:36.786]                       }
[10:31:36.786]                       invisible(muffled)
[10:31:36.786]                     }
[10:31:36.786]                     muffleCondition(cond, pattern = "^muffle")
[10:31:36.786]                   }
[10:31:36.786]                 }
[10:31:36.786]             }
[10:31:36.786]         }))
[10:31:36.786]     }, error = function(ex) {
[10:31:36.786]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:36.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:36.786]                 ...future.rng), started = ...future.startTime, 
[10:31:36.786]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:36.786]             version = "1.8"), class = "FutureResult")
[10:31:36.786]     }, finally = {
[10:31:36.786]         if (!identical(...future.workdir, getwd())) 
[10:31:36.786]             setwd(...future.workdir)
[10:31:36.786]         {
[10:31:36.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:36.786]                 ...future.oldOptions$nwarnings <- NULL
[10:31:36.786]             }
[10:31:36.786]             base::options(...future.oldOptions)
[10:31:36.786]             if (.Platform$OS.type == "windows") {
[10:31:36.786]                 old_names <- names(...future.oldEnvVars)
[10:31:36.786]                 envs <- base::Sys.getenv()
[10:31:36.786]                 names <- names(envs)
[10:31:36.786]                 common <- intersect(names, old_names)
[10:31:36.786]                 added <- setdiff(names, old_names)
[10:31:36.786]                 removed <- setdiff(old_names, names)
[10:31:36.786]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:36.786]                   envs[common]]
[10:31:36.786]                 NAMES <- toupper(changed)
[10:31:36.786]                 args <- list()
[10:31:36.786]                 for (kk in seq_along(NAMES)) {
[10:31:36.786]                   name <- changed[[kk]]
[10:31:36.786]                   NAME <- NAMES[[kk]]
[10:31:36.786]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:36.786]                     next
[10:31:36.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:36.786]                 }
[10:31:36.786]                 NAMES <- toupper(added)
[10:31:36.786]                 for (kk in seq_along(NAMES)) {
[10:31:36.786]                   name <- added[[kk]]
[10:31:36.786]                   NAME <- NAMES[[kk]]
[10:31:36.786]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:36.786]                     next
[10:31:36.786]                   args[[name]] <- ""
[10:31:36.786]                 }
[10:31:36.786]                 NAMES <- toupper(removed)
[10:31:36.786]                 for (kk in seq_along(NAMES)) {
[10:31:36.786]                   name <- removed[[kk]]
[10:31:36.786]                   NAME <- NAMES[[kk]]
[10:31:36.786]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:36.786]                     next
[10:31:36.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:36.786]                 }
[10:31:36.786]                 if (length(args) > 0) 
[10:31:36.786]                   base::do.call(base::Sys.setenv, args = args)
[10:31:36.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:36.786]             }
[10:31:36.786]             else {
[10:31:36.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:36.786]             }
[10:31:36.786]             {
[10:31:36.786]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:36.786]                   0L) {
[10:31:36.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:36.786]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:36.786]                   base::options(opts)
[10:31:36.786]                 }
[10:31:36.786]                 {
[10:31:36.786]                   {
[10:31:36.786]                     NULL
[10:31:36.786]                     RNGkind("Mersenne-Twister")
[10:31:36.786]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:36.786]                       inherits = FALSE)
[10:31:36.786]                   }
[10:31:36.786]                   options(future.plan = NULL)
[10:31:36.786]                   if (is.na(NA_character_)) 
[10:31:36.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:36.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:36.786]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:36.786]                     .init = FALSE)
[10:31:36.786]                 }
[10:31:36.786]             }
[10:31:36.786]         }
[10:31:36.786]     })
[10:31:36.786]     if (TRUE) {
[10:31:36.786]         base::sink(type = "output", split = FALSE)
[10:31:36.786]         if (TRUE) {
[10:31:36.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:36.786]         }
[10:31:36.786]         else {
[10:31:36.786]             ...future.result["stdout"] <- base::list(NULL)
[10:31:36.786]         }
[10:31:36.786]         base::close(...future.stdout)
[10:31:36.786]         ...future.stdout <- NULL
[10:31:36.786]     }
[10:31:36.786]     ...future.result$conditions <- ...future.conditions
[10:31:36.786]     ...future.result$finished <- base::Sys.time()
[10:31:36.786]     ...future.result
[10:31:36.786] }
[10:31:36.788] assign_globals() ...
[10:31:36.788] List of 5
[10:31:36.788]  $ ...future.FUN            :function (x)  
[10:31:36.788]  $ future.call.arguments    : list()
[10:31:36.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:36.788]  $ ...future.elements_ii    :List of 2
[10:31:36.788]   ..$ : int 1
[10:31:36.788]   ..$ : int 0
[10:31:36.788]  $ ...future.seeds_ii       : NULL
[10:31:36.788]  $ ...future.globals.maxSize: NULL
[10:31:36.788]  - attr(*, "where")=List of 5
[10:31:36.788]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:36.788]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:36.788]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:36.788]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:36.788]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:36.788]  - attr(*, "resolved")= logi FALSE
[10:31:36.788]  - attr(*, "total_size")= num 4720
[10:31:36.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:36.788]  - attr(*, "already-done")= logi TRUE
[10:31:36.795] - reassign environment for ‘...future.FUN’
[10:31:36.795] - copied ‘...future.FUN’ to environment
[10:31:36.795] - copied ‘future.call.arguments’ to environment
[10:31:36.795] - copied ‘...future.elements_ii’ to environment
[10:31:36.795] - copied ‘...future.seeds_ii’ to environment
[10:31:36.795] - copied ‘...future.globals.maxSize’ to environment
[10:31:36.795] assign_globals() ... done
[10:31:36.796] plan(): Setting new future strategy stack:
[10:31:36.796] List of future strategies:
[10:31:36.796] 1. sequential:
[10:31:36.796]    - args: function (..., envir = parent.frame())
[10:31:36.796]    - tweaked: FALSE
[10:31:36.796]    - call: NULL
[10:31:36.796] plan(): nbrOfWorkers() = 1
[10:31:37.298] plan(): Setting new future strategy stack:
[10:31:37.298] List of future strategies:
[10:31:37.298] 1. sequential:
[10:31:37.298]    - args: function (..., envir = parent.frame())
[10:31:37.298]    - tweaked: FALSE
[10:31:37.298]    - call: plan(strategy)
[10:31:37.299] plan(): nbrOfWorkers() = 1
[10:31:37.299] SequentialFuture started (and completed)
[10:31:37.299] - Launch lazy future ... done
[10:31:37.299] run() for ‘SequentialFuture’ ... done
[10:31:37.299] Created future:
[10:31:37.299] SequentialFuture:
[10:31:37.299] Label: ‘future_lapply-1’
[10:31:37.299] Expression:
[10:31:37.299] {
[10:31:37.299]     do.call(function(...) {
[10:31:37.299]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:37.299]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:37.299]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:37.299]             on.exit(options(oopts), add = TRUE)
[10:31:37.299]         }
[10:31:37.299]         {
[10:31:37.299]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:37.299]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:37.299]                 ...future.FUN(...future.X_jj, ...)
[10:31:37.299]             })
[10:31:37.299]         }
[10:31:37.299]     }, args = future.call.arguments)
[10:31:37.299] }
[10:31:37.299] Lazy evaluation: FALSE
[10:31:37.299] Asynchronous evaluation: FALSE
[10:31:37.299] Local evaluation: TRUE
[10:31:37.299] Environment: R_GlobalEnv
[10:31:37.299] Capture standard output: TRUE
[10:31:37.299] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:37.299] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:37.299] Packages: <none>
[10:31:37.299] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:37.299] Resolved: TRUE
[10:31:37.299] Value: 112 bytes of class ‘list’
[10:31:37.299] Early signaling: FALSE
[10:31:37.299] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:37.299] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:37.300] Chunk #1 of 1 ... DONE
[10:31:37.300] Launching 1 futures (chunks) ... DONE
[10:31:37.300] Resolving 1 futures (chunks) ...
[10:31:37.301] resolve() on list ...
[10:31:37.301]  recursive: 0
[10:31:37.301]  length: 1
[10:31:37.301] 
[10:31:37.301] resolved() for ‘SequentialFuture’ ...
[10:31:37.301] - state: ‘finished’
[10:31:37.301] - run: TRUE
[10:31:37.301] - result: ‘FutureResult’
[10:31:37.301] resolved() for ‘SequentialFuture’ ... done
[10:31:37.302] Future #1
[10:31:37.302] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:37.302] - nx: 1
[10:31:37.302] - relay: TRUE
[10:31:37.302] - stdout: TRUE
[10:31:37.302] - signal: TRUE
[10:31:37.302] - resignal: FALSE
[10:31:37.302] - force: TRUE
[10:31:37.302] - relayed: [n=1] FALSE
[10:31:37.302] - queued futures: [n=1] FALSE
[10:31:37.303]  - until=1
[10:31:37.303]  - relaying element #1
[10:31:37.303] - relayed: [n=1] TRUE
[10:31:37.303] - queued futures: [n=1] TRUE
[10:31:37.303] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:37.303]  length: 0 (resolved future 1)
[10:31:37.303] Relaying remaining futures
[10:31:37.303] signalConditionsASAP(NULL, pos=0) ...
[10:31:37.303] - nx: 1
[10:31:37.303] - relay: TRUE
[10:31:37.304] - stdout: TRUE
[10:31:37.304] - signal: TRUE
[10:31:37.304] - resignal: FALSE
[10:31:37.304] - force: TRUE
[10:31:37.304] - relayed: [n=1] TRUE
[10:31:37.304] - queued futures: [n=1] TRUE
 - flush all
[10:31:37.304] - relayed: [n=1] TRUE
[10:31:37.304] - queued futures: [n=1] TRUE
[10:31:37.304] signalConditionsASAP(NULL, pos=0) ... done
[10:31:37.304] resolve() on list ... DONE
[10:31:37.305]  - Number of value chunks collected: 1
[10:31:37.305] Resolving 1 futures (chunks) ... DONE
[10:31:37.305] Reducing values from 1 chunks ...
[10:31:37.305]  - Number of values collected after concatenation: 2
[10:31:37.305]  - Number of values expected: 2
[10:31:37.305] Reducing values from 1 chunks ... DONE
[10:31:37.305] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:31:37.305] future_lapply() ...
[10:31:37.306] Number of chunks: 1
[10:31:37.306] getGlobalsAndPackagesXApply() ...
[10:31:37.306]  - future.globals: TRUE
[10:31:37.306] getGlobalsAndPackages() ...
[10:31:37.307] Searching for globals...
[10:31:37.308] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:37.308] Searching for globals ... DONE
[10:31:37.308] Resolving globals: FALSE
[10:31:37.308] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:37.309] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:37.309] - globals: [1] ‘FUN’
[10:31:37.309] 
[10:31:37.310] getGlobalsAndPackages() ... DONE
[10:31:37.310]  - globals found/used: [n=1] ‘FUN’
[10:31:37.310]  - needed namespaces: [n=0] 
[10:31:37.310] Finding globals ... DONE
[10:31:37.310]  - use_args: TRUE
[10:31:37.310]  - Getting '...' globals ...
[10:31:37.310] resolve() on list ...
[10:31:37.310]  recursive: 0
[10:31:37.311]  length: 1
[10:31:37.311]  elements: ‘...’
[10:31:37.311]  length: 0 (resolved future 1)
[10:31:37.311] resolve() on list ... DONE
[10:31:37.311]    - '...' content: [n=0] 
[10:31:37.311] List of 1
[10:31:37.311]  $ ...: list()
[10:31:37.311]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:37.311]  - attr(*, "where")=List of 1
[10:31:37.311]   ..$ ...:<environment: 0x564ff37b2240> 
[10:31:37.311]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:37.311]  - attr(*, "resolved")= logi TRUE
[10:31:37.311]  - attr(*, "total_size")= num NA
[10:31:37.314]  - Getting '...' globals ... DONE
[10:31:37.314] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:37.314] List of 2
[10:31:37.314]  $ ...future.FUN:function (x)  
[10:31:37.314]  $ ...          : list()
[10:31:37.314]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:37.314]  - attr(*, "where")=List of 2
[10:31:37.314]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:37.314]   ..$ ...          :<environment: 0x564ff37b2240> 
[10:31:37.314]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:37.314]  - attr(*, "resolved")= logi FALSE
[10:31:37.314]  - attr(*, "total_size")= num 4720
[10:31:37.317] Packages to be attached in all futures: [n=0] 
[10:31:37.317] getGlobalsAndPackagesXApply() ... DONE
[10:31:37.317] Number of futures (= number of chunks): 1
[10:31:37.317] Launching 1 futures (chunks) ...
[10:31:37.317] Chunk #1 of 1 ...
[10:31:37.317]  - Finding globals in 'X' for chunk #1 ...
[10:31:37.319] getGlobalsAndPackages() ...
[10:31:37.319] Searching for globals...
[10:31:37.319] 
[10:31:37.320] Searching for globals ... DONE
[10:31:37.320] - globals: [0] <none>
[10:31:37.320] getGlobalsAndPackages() ... DONE
[10:31:37.320]    + additional globals found: [n=0] 
[10:31:37.320]    + additional namespaces needed: [n=0] 
[10:31:37.320]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:37.320]  - seeds: <none>
[10:31:37.320]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:37.320] getGlobalsAndPackages() ...
[10:31:37.320] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:37.321] Resolving globals: FALSE
[10:31:37.321] Tweak future expression to call with '...' arguments ...
[10:31:37.321] {
[10:31:37.321]     do.call(function(...) {
[10:31:37.321]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:37.321]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:37.321]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:37.321]             on.exit(options(oopts), add = TRUE)
[10:31:37.321]         }
[10:31:37.321]         {
[10:31:37.321]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:37.321]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:37.321]                 ...future.FUN(...future.X_jj, ...)
[10:31:37.321]             })
[10:31:37.321]         }
[10:31:37.321]     }, args = future.call.arguments)
[10:31:37.321] }
[10:31:37.321] Tweak future expression to call with '...' arguments ... DONE
[10:31:37.321] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:37.322] 
[10:31:37.322] getGlobalsAndPackages() ... DONE
[10:31:37.322] run() for ‘Future’ ...
[10:31:37.322] - state: ‘created’
[10:31:37.322] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:37.322] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:37.323] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:37.323]   - Field: ‘label’
[10:31:37.323]   - Field: ‘local’
[10:31:37.323]   - Field: ‘owner’
[10:31:37.323]   - Field: ‘envir’
[10:31:37.323]   - Field: ‘packages’
[10:31:37.323]   - Field: ‘gc’
[10:31:37.323]   - Field: ‘conditions’
[10:31:37.323]   - Field: ‘expr’
[10:31:37.323]   - Field: ‘uuid’
[10:31:37.324]   - Field: ‘seed’
[10:31:37.324]   - Field: ‘version’
[10:31:37.324]   - Field: ‘result’
[10:31:37.324]   - Field: ‘asynchronous’
[10:31:37.324]   - Field: ‘calls’
[10:31:37.324]   - Field: ‘globals’
[10:31:37.324]   - Field: ‘stdout’
[10:31:37.324]   - Field: ‘earlySignal’
[10:31:37.324]   - Field: ‘lazy’
[10:31:37.324]   - Field: ‘state’
[10:31:37.324] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:37.325] - Launch lazy future ...
[10:31:37.325] Packages needed by the future expression (n = 0): <none>
[10:31:37.325] Packages needed by future strategies (n = 0): <none>
[10:31:37.325] {
[10:31:37.325]     {
[10:31:37.325]         {
[10:31:37.325]             ...future.startTime <- base::Sys.time()
[10:31:37.325]             {
[10:31:37.325]                 {
[10:31:37.325]                   {
[10:31:37.325]                     base::local({
[10:31:37.325]                       has_future <- base::requireNamespace("future", 
[10:31:37.325]                         quietly = TRUE)
[10:31:37.325]                       if (has_future) {
[10:31:37.325]                         ns <- base::getNamespace("future")
[10:31:37.325]                         version <- ns[[".package"]][["version"]]
[10:31:37.325]                         if (is.null(version)) 
[10:31:37.325]                           version <- utils::packageVersion("future")
[10:31:37.325]                       }
[10:31:37.325]                       else {
[10:31:37.325]                         version <- NULL
[10:31:37.325]                       }
[10:31:37.325]                       if (!has_future || version < "1.8.0") {
[10:31:37.325]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:37.325]                           "", base::R.version$version.string), 
[10:31:37.325]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:37.325]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:37.325]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:37.325]                             "release", "version")], collapse = " "), 
[10:31:37.325]                           hostname = base::Sys.info()[["nodename"]])
[10:31:37.325]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:37.325]                           info)
[10:31:37.325]                         info <- base::paste(info, collapse = "; ")
[10:31:37.325]                         if (!has_future) {
[10:31:37.325]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:37.325]                             info)
[10:31:37.325]                         }
[10:31:37.325]                         else {
[10:31:37.325]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:37.325]                             info, version)
[10:31:37.325]                         }
[10:31:37.325]                         base::stop(msg)
[10:31:37.325]                       }
[10:31:37.325]                     })
[10:31:37.325]                   }
[10:31:37.325]                   ...future.strategy.old <- future::plan("list")
[10:31:37.325]                   options(future.plan = NULL)
[10:31:37.325]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:37.325]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:37.325]                 }
[10:31:37.325]                 ...future.workdir <- getwd()
[10:31:37.325]             }
[10:31:37.325]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:37.325]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:37.325]         }
[10:31:37.325]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:37.325]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:37.325]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:37.325]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:37.325]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:37.325]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:37.325]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:37.325]             base::names(...future.oldOptions))
[10:31:37.325]     }
[10:31:37.325]     if (TRUE) {
[10:31:37.325]     }
[10:31:37.325]     else {
[10:31:37.325]         if (NA) {
[10:31:37.325]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:37.325]                 open = "w")
[10:31:37.325]         }
[10:31:37.325]         else {
[10:31:37.325]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:37.325]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:37.325]         }
[10:31:37.325]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:37.325]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:37.325]             base::sink(type = "output", split = FALSE)
[10:31:37.325]             base::close(...future.stdout)
[10:31:37.325]         }, add = TRUE)
[10:31:37.325]     }
[10:31:37.325]     ...future.frame <- base::sys.nframe()
[10:31:37.325]     ...future.conditions <- base::list()
[10:31:37.325]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:37.325]     if (FALSE) {
[10:31:37.325]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:37.325]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:37.325]     }
[10:31:37.325]     ...future.result <- base::tryCatch({
[10:31:37.325]         base::withCallingHandlers({
[10:31:37.325]             ...future.value <- base::withVisible(base::local({
[10:31:37.325]                 do.call(function(...) {
[10:31:37.325]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:37.325]                   if (!identical(...future.globals.maxSize.org, 
[10:31:37.325]                     ...future.globals.maxSize)) {
[10:31:37.325]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:37.325]                     on.exit(options(oopts), add = TRUE)
[10:31:37.325]                   }
[10:31:37.325]                   {
[10:31:37.325]                     lapply(seq_along(...future.elements_ii), 
[10:31:37.325]                       FUN = function(jj) {
[10:31:37.325]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:37.325]                         ...future.FUN(...future.X_jj, ...)
[10:31:37.325]                       })
[10:31:37.325]                   }
[10:31:37.325]                 }, args = future.call.arguments)
[10:31:37.325]             }))
[10:31:37.325]             future::FutureResult(value = ...future.value$value, 
[10:31:37.325]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:37.325]                   ...future.rng), globalenv = if (FALSE) 
[10:31:37.325]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:37.325]                     ...future.globalenv.names))
[10:31:37.325]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:37.325]         }, condition = base::local({
[10:31:37.325]             c <- base::c
[10:31:37.325]             inherits <- base::inherits
[10:31:37.325]             invokeRestart <- base::invokeRestart
[10:31:37.325]             length <- base::length
[10:31:37.325]             list <- base::list
[10:31:37.325]             seq.int <- base::seq.int
[10:31:37.325]             signalCondition <- base::signalCondition
[10:31:37.325]             sys.calls <- base::sys.calls
[10:31:37.325]             `[[` <- base::`[[`
[10:31:37.325]             `+` <- base::`+`
[10:31:37.325]             `<<-` <- base::`<<-`
[10:31:37.325]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:37.325]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:37.325]                   3L)]
[10:31:37.325]             }
[10:31:37.325]             function(cond) {
[10:31:37.325]                 is_error <- inherits(cond, "error")
[10:31:37.325]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:37.325]                   NULL)
[10:31:37.325]                 if (is_error) {
[10:31:37.325]                   sessionInformation <- function() {
[10:31:37.325]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:37.325]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:37.325]                       search = base::search(), system = base::Sys.info())
[10:31:37.325]                   }
[10:31:37.325]                   ...future.conditions[[length(...future.conditions) + 
[10:31:37.325]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:37.325]                     cond$call), session = sessionInformation(), 
[10:31:37.325]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:37.325]                   signalCondition(cond)
[10:31:37.325]                 }
[10:31:37.325]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:37.325]                 "immediateCondition"))) {
[10:31:37.325]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:37.325]                   ...future.conditions[[length(...future.conditions) + 
[10:31:37.325]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:37.325]                   if (TRUE && !signal) {
[10:31:37.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:37.325]                     {
[10:31:37.325]                       inherits <- base::inherits
[10:31:37.325]                       invokeRestart <- base::invokeRestart
[10:31:37.325]                       is.null <- base::is.null
[10:31:37.325]                       muffled <- FALSE
[10:31:37.325]                       if (inherits(cond, "message")) {
[10:31:37.325]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:37.325]                         if (muffled) 
[10:31:37.325]                           invokeRestart("muffleMessage")
[10:31:37.325]                       }
[10:31:37.325]                       else if (inherits(cond, "warning")) {
[10:31:37.325]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:37.325]                         if (muffled) 
[10:31:37.325]                           invokeRestart("muffleWarning")
[10:31:37.325]                       }
[10:31:37.325]                       else if (inherits(cond, "condition")) {
[10:31:37.325]                         if (!is.null(pattern)) {
[10:31:37.325]                           computeRestarts <- base::computeRestarts
[10:31:37.325]                           grepl <- base::grepl
[10:31:37.325]                           restarts <- computeRestarts(cond)
[10:31:37.325]                           for (restart in restarts) {
[10:31:37.325]                             name <- restart$name
[10:31:37.325]                             if (is.null(name)) 
[10:31:37.325]                               next
[10:31:37.325]                             if (!grepl(pattern, name)) 
[10:31:37.325]                               next
[10:31:37.325]                             invokeRestart(restart)
[10:31:37.325]                             muffled <- TRUE
[10:31:37.325]                             break
[10:31:37.325]                           }
[10:31:37.325]                         }
[10:31:37.325]                       }
[10:31:37.325]                       invisible(muffled)
[10:31:37.325]                     }
[10:31:37.325]                     muffleCondition(cond, pattern = "^muffle")
[10:31:37.325]                   }
[10:31:37.325]                 }
[10:31:37.325]                 else {
[10:31:37.325]                   if (TRUE) {
[10:31:37.325]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:37.325]                     {
[10:31:37.325]                       inherits <- base::inherits
[10:31:37.325]                       invokeRestart <- base::invokeRestart
[10:31:37.325]                       is.null <- base::is.null
[10:31:37.325]                       muffled <- FALSE
[10:31:37.325]                       if (inherits(cond, "message")) {
[10:31:37.325]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:37.325]                         if (muffled) 
[10:31:37.325]                           invokeRestart("muffleMessage")
[10:31:37.325]                       }
[10:31:37.325]                       else if (inherits(cond, "warning")) {
[10:31:37.325]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:37.325]                         if (muffled) 
[10:31:37.325]                           invokeRestart("muffleWarning")
[10:31:37.325]                       }
[10:31:37.325]                       else if (inherits(cond, "condition")) {
[10:31:37.325]                         if (!is.null(pattern)) {
[10:31:37.325]                           computeRestarts <- base::computeRestarts
[10:31:37.325]                           grepl <- base::grepl
[10:31:37.325]                           restarts <- computeRestarts(cond)
[10:31:37.325]                           for (restart in restarts) {
[10:31:37.325]                             name <- restart$name
[10:31:37.325]                             if (is.null(name)) 
[10:31:37.325]                               next
[10:31:37.325]                             if (!grepl(pattern, name)) 
[10:31:37.325]                               next
[10:31:37.325]                             invokeRestart(restart)
[10:31:37.325]                             muffled <- TRUE
[10:31:37.325]                             break
[10:31:37.325]                           }
[10:31:37.325]                         }
[10:31:37.325]                       }
[10:31:37.325]                       invisible(muffled)
[10:31:37.325]                     }
[10:31:37.325]                     muffleCondition(cond, pattern = "^muffle")
[10:31:37.325]                   }
[10:31:37.325]                 }
[10:31:37.325]             }
[10:31:37.325]         }))
[10:31:37.325]     }, error = function(ex) {
[10:31:37.325]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:37.325]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:37.325]                 ...future.rng), started = ...future.startTime, 
[10:31:37.325]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:37.325]             version = "1.8"), class = "FutureResult")
[10:31:37.325]     }, finally = {
[10:31:37.325]         if (!identical(...future.workdir, getwd())) 
[10:31:37.325]             setwd(...future.workdir)
[10:31:37.325]         {
[10:31:37.325]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:37.325]                 ...future.oldOptions$nwarnings <- NULL
[10:31:37.325]             }
[10:31:37.325]             base::options(...future.oldOptions)
[10:31:37.325]             if (.Platform$OS.type == "windows") {
[10:31:37.325]                 old_names <- names(...future.oldEnvVars)
[10:31:37.325]                 envs <- base::Sys.getenv()
[10:31:37.325]                 names <- names(envs)
[10:31:37.325]                 common <- intersect(names, old_names)
[10:31:37.325]                 added <- setdiff(names, old_names)
[10:31:37.325]                 removed <- setdiff(old_names, names)
[10:31:37.325]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:37.325]                   envs[common]]
[10:31:37.325]                 NAMES <- toupper(changed)
[10:31:37.325]                 args <- list()
[10:31:37.325]                 for (kk in seq_along(NAMES)) {
[10:31:37.325]                   name <- changed[[kk]]
[10:31:37.325]                   NAME <- NAMES[[kk]]
[10:31:37.325]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:37.325]                     next
[10:31:37.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:37.325]                 }
[10:31:37.325]                 NAMES <- toupper(added)
[10:31:37.325]                 for (kk in seq_along(NAMES)) {
[10:31:37.325]                   name <- added[[kk]]
[10:31:37.325]                   NAME <- NAMES[[kk]]
[10:31:37.325]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:37.325]                     next
[10:31:37.325]                   args[[name]] <- ""
[10:31:37.325]                 }
[10:31:37.325]                 NAMES <- toupper(removed)
[10:31:37.325]                 for (kk in seq_along(NAMES)) {
[10:31:37.325]                   name <- removed[[kk]]
[10:31:37.325]                   NAME <- NAMES[[kk]]
[10:31:37.325]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:37.325]                     next
[10:31:37.325]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:37.325]                 }
[10:31:37.325]                 if (length(args) > 0) 
[10:31:37.325]                   base::do.call(base::Sys.setenv, args = args)
[10:31:37.325]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:37.325]             }
[10:31:37.325]             else {
[10:31:37.325]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:37.325]             }
[10:31:37.325]             {
[10:31:37.325]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:37.325]                   0L) {
[10:31:37.325]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:37.325]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:37.325]                   base::options(opts)
[10:31:37.325]                 }
[10:31:37.325]                 {
[10:31:37.325]                   {
[10:31:37.325]                     NULL
[10:31:37.325]                     RNGkind("Mersenne-Twister")
[10:31:37.325]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:37.325]                       inherits = FALSE)
[10:31:37.325]                   }
[10:31:37.325]                   options(future.plan = NULL)
[10:31:37.325]                   if (is.na(NA_character_)) 
[10:31:37.325]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:37.325]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:37.325]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:37.325]                     .init = FALSE)
[10:31:37.325]                 }
[10:31:37.325]             }
[10:31:37.325]         }
[10:31:37.325]     })
[10:31:37.325]     if (FALSE) {
[10:31:37.325]         base::sink(type = "output", split = FALSE)
[10:31:37.325]         if (NA) {
[10:31:37.325]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:37.325]         }
[10:31:37.325]         else {
[10:31:37.325]             ...future.result["stdout"] <- base::list(NULL)
[10:31:37.325]         }
[10:31:37.325]         base::close(...future.stdout)
[10:31:37.325]         ...future.stdout <- NULL
[10:31:37.325]     }
[10:31:37.325]     ...future.result$conditions <- ...future.conditions
[10:31:37.325]     ...future.result$finished <- base::Sys.time()
[10:31:37.325]     ...future.result
[10:31:37.325] }
[10:31:37.327] assign_globals() ...
[10:31:37.327] List of 5
[10:31:37.327]  $ ...future.FUN            :function (x)  
[10:31:37.327]  $ future.call.arguments    : list()
[10:31:37.327]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:37.327]  $ ...future.elements_ii    :List of 2
[10:31:37.327]   ..$ : int 1
[10:31:37.327]   ..$ : int 0
[10:31:37.327]  $ ...future.seeds_ii       : NULL
[10:31:37.327]  $ ...future.globals.maxSize: NULL
[10:31:37.327]  - attr(*, "where")=List of 5
[10:31:37.327]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:37.327]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:37.327]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:37.327]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:37.327]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:37.327]  - attr(*, "resolved")= logi FALSE
[10:31:37.327]  - attr(*, "total_size")= num 4720
[10:31:37.327]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:37.327]  - attr(*, "already-done")= logi TRUE
[10:31:37.332] - reassign environment for ‘...future.FUN’
[10:31:37.332] - copied ‘...future.FUN’ to environment
[10:31:37.332] - copied ‘future.call.arguments’ to environment
[10:31:37.332] - copied ‘...future.elements_ii’ to environment
[10:31:37.332] - copied ‘...future.seeds_ii’ to environment
[10:31:37.333] - copied ‘...future.globals.maxSize’ to environment
[10:31:37.333] assign_globals() ... done
[10:31:37.333] plan(): Setting new future strategy stack:
[10:31:37.333] List of future strategies:
[10:31:37.333] 1. sequential:
[10:31:37.333]    - args: function (..., envir = parent.frame())
[10:31:37.333]    - tweaked: FALSE
[10:31:37.333]    - call: NULL
[10:31:37.333] plan(): nbrOfWorkers() = 1
[10:31:37.835] plan(): Setting new future strategy stack:
[10:31:37.835] List of future strategies:
[10:31:37.835] 1. sequential:
[10:31:37.835]    - args: function (..., envir = parent.frame())
[10:31:37.835]    - tweaked: FALSE
[10:31:37.835]    - call: plan(strategy)
[10:31:37.836] plan(): nbrOfWorkers() = 1
[10:31:37.836] SequentialFuture started (and completed)
[10:31:37.836] - Launch lazy future ... done
[10:31:37.836] run() for ‘SequentialFuture’ ... done
[10:31:37.836] Created future:
[10:31:37.836] SequentialFuture:
[10:31:37.836] Label: ‘future_lapply-1’
[10:31:37.836] Expression:
[10:31:37.836] {
[10:31:37.836]     do.call(function(...) {
[10:31:37.836]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:37.836]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:37.836]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:37.836]             on.exit(options(oopts), add = TRUE)
[10:31:37.836]         }
[10:31:37.836]         {
[10:31:37.836]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:37.836]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:37.836]                 ...future.FUN(...future.X_jj, ...)
[10:31:37.836]             })
[10:31:37.836]         }
[10:31:37.836]     }, args = future.call.arguments)
[10:31:37.836] }
[10:31:37.836] Lazy evaluation: FALSE
[10:31:37.836] Asynchronous evaluation: FALSE
[10:31:37.836] Local evaluation: TRUE
[10:31:37.836] Environment: R_GlobalEnv
[10:31:37.836] Capture standard output: NA
[10:31:37.836] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:37.836] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:37.836] Packages: <none>
[10:31:37.836] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:37.836] Resolved: TRUE
[10:31:37.836] Value: 112 bytes of class ‘list’
[10:31:37.836] Early signaling: FALSE
[10:31:37.836] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:37.836] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:37.838] Chunk #1 of 1 ... DONE
[10:31:37.838] Launching 1 futures (chunks) ... DONE
[10:31:37.838] Resolving 1 futures (chunks) ...
[10:31:37.838] resolve() on list ...
[10:31:37.838]  recursive: 0
[10:31:37.838]  length: 1
[10:31:37.838] 
[10:31:37.838] resolved() for ‘SequentialFuture’ ...
[10:31:37.838] - state: ‘finished’
[10:31:37.838] - run: TRUE
[10:31:37.839] - result: ‘FutureResult’
[10:31:37.839] resolved() for ‘SequentialFuture’ ... done
[10:31:37.839] Future #1
[10:31:37.839] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:37.839] - nx: 1
[10:31:37.839] - relay: TRUE
[10:31:37.839] - stdout: TRUE
[10:31:37.839] - signal: TRUE
[10:31:37.839] - resignal: FALSE
[10:31:37.839] - force: TRUE
[10:31:37.839] - relayed: [n=1] FALSE
[10:31:37.840] - queued futures: [n=1] FALSE
[10:31:37.840]  - until=1
[10:31:37.840]  - relaying element #1
[10:31:37.840] - relayed: [n=1] TRUE
[10:31:37.840] - queued futures: [n=1] TRUE
[10:31:37.840] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:37.840]  length: 0 (resolved future 1)
[10:31:37.840] Relaying remaining futures
[10:31:37.840] signalConditionsASAP(NULL, pos=0) ...
[10:31:37.840] - nx: 1
[10:31:37.841] - relay: TRUE
[10:31:37.841] - stdout: TRUE
[10:31:37.841] - signal: TRUE
[10:31:37.841] - resignal: FALSE
[10:31:37.841] - force: TRUE
[10:31:37.841] - relayed: [n=1] TRUE
[10:31:37.841] - queued futures: [n=1] TRUE
 - flush all
[10:31:37.841] - relayed: [n=1] TRUE
[10:31:37.841] - queued futures: [n=1] TRUE
[10:31:37.841] signalConditionsASAP(NULL, pos=0) ... done
[10:31:37.842] resolve() on list ... DONE
[10:31:37.842]  - Number of value chunks collected: 1
[10:31:37.842] Resolving 1 futures (chunks) ... DONE
[10:31:37.842] Reducing values from 1 chunks ...
[10:31:37.842]  - Number of values collected after concatenation: 2
[10:31:37.842]  - Number of values expected: 2
[10:31:37.842] Reducing values from 1 chunks ... DONE
[10:31:37.842] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:31:37.843] future_mapply() ...
[10:31:37.843] Number of chunks: 1
[10:31:37.843] getGlobalsAndPackagesXApply() ...
[10:31:37.843]  - future.globals: TRUE
[10:31:37.843] getGlobalsAndPackages() ...
[10:31:37.843] Searching for globals...
[10:31:37.845] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:37.845] Searching for globals ... DONE
[10:31:37.845] Resolving globals: FALSE
[10:31:37.847] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:37.847] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:37.847] - globals: [1] ‘FUN’
[10:31:37.848] 
[10:31:37.848] getGlobalsAndPackages() ... DONE
[10:31:37.848]  - globals found/used: [n=1] ‘FUN’
[10:31:37.848]  - needed namespaces: [n=0] 
[10:31:37.848] Finding globals ... DONE
[10:31:37.848] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:37.848] List of 2
[10:31:37.848]  $ ...future.FUN:function (x, y)  
[10:31:37.848]  $ MoreArgs     : NULL
[10:31:37.848]  - attr(*, "where")=List of 2
[10:31:37.848]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:37.848]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:37.848]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:37.848]  - attr(*, "resolved")= logi FALSE
[10:31:37.848]  - attr(*, "total_size")= num NA
[10:31:37.851] Packages to be attached in all futures: [n=0] 
[10:31:37.851] getGlobalsAndPackagesXApply() ... DONE
[10:31:37.851] Number of futures (= number of chunks): 1
[10:31:37.851] Launching 1 futures (chunks) ...
[10:31:37.851] Chunk #1 of 1 ...
[10:31:37.851]  - Finding globals in '...' for chunk #1 ...
[10:31:37.852] getGlobalsAndPackages() ...
[10:31:37.852] Searching for globals...
[10:31:37.852] 
[10:31:37.852] Searching for globals ... DONE
[10:31:37.852] - globals: [0] <none>
[10:31:37.852] getGlobalsAndPackages() ... DONE
[10:31:37.852]    + additional globals found: [n=0] 
[10:31:37.852]    + additional namespaces needed: [n=0] 
[10:31:37.852]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:37.853]  - seeds: <none>
[10:31:37.853]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:37.853] getGlobalsAndPackages() ...
[10:31:37.853] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:37.853] Resolving globals: FALSE
[10:31:37.853] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:31:37.854] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:37.854] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:37.854] 
[10:31:37.854] getGlobalsAndPackages() ... DONE
[10:31:37.855] run() for ‘Future’ ...
[10:31:37.855] - state: ‘created’
[10:31:37.855] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:37.855] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:37.855] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:37.855]   - Field: ‘label’
[10:31:37.855]   - Field: ‘local’
[10:31:37.855]   - Field: ‘owner’
[10:31:37.856]   - Field: ‘envir’
[10:31:37.856]   - Field: ‘packages’
[10:31:37.856]   - Field: ‘gc’
[10:31:37.856]   - Field: ‘conditions’
[10:31:37.856]   - Field: ‘expr’
[10:31:37.856]   - Field: ‘uuid’
[10:31:37.856]   - Field: ‘seed’
[10:31:37.856]   - Field: ‘version’
[10:31:37.856]   - Field: ‘result’
[10:31:37.856]   - Field: ‘asynchronous’
[10:31:37.856]   - Field: ‘calls’
[10:31:37.857]   - Field: ‘globals’
[10:31:37.857]   - Field: ‘stdout’
[10:31:37.857]   - Field: ‘earlySignal’
[10:31:37.857]   - Field: ‘lazy’
[10:31:37.857]   - Field: ‘state’
[10:31:37.857] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:37.857] - Launch lazy future ...
[10:31:37.857] Packages needed by the future expression (n = 0): <none>
[10:31:37.857] Packages needed by future strategies (n = 0): <none>
[10:31:37.858] {
[10:31:37.858]     {
[10:31:37.858]         {
[10:31:37.858]             ...future.startTime <- base::Sys.time()
[10:31:37.858]             {
[10:31:37.858]                 {
[10:31:37.858]                   {
[10:31:37.858]                     base::local({
[10:31:37.858]                       has_future <- base::requireNamespace("future", 
[10:31:37.858]                         quietly = TRUE)
[10:31:37.858]                       if (has_future) {
[10:31:37.858]                         ns <- base::getNamespace("future")
[10:31:37.858]                         version <- ns[[".package"]][["version"]]
[10:31:37.858]                         if (is.null(version)) 
[10:31:37.858]                           version <- utils::packageVersion("future")
[10:31:37.858]                       }
[10:31:37.858]                       else {
[10:31:37.858]                         version <- NULL
[10:31:37.858]                       }
[10:31:37.858]                       if (!has_future || version < "1.8.0") {
[10:31:37.858]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:37.858]                           "", base::R.version$version.string), 
[10:31:37.858]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:37.858]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:37.858]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:37.858]                             "release", "version")], collapse = " "), 
[10:31:37.858]                           hostname = base::Sys.info()[["nodename"]])
[10:31:37.858]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:37.858]                           info)
[10:31:37.858]                         info <- base::paste(info, collapse = "; ")
[10:31:37.858]                         if (!has_future) {
[10:31:37.858]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:37.858]                             info)
[10:31:37.858]                         }
[10:31:37.858]                         else {
[10:31:37.858]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:37.858]                             info, version)
[10:31:37.858]                         }
[10:31:37.858]                         base::stop(msg)
[10:31:37.858]                       }
[10:31:37.858]                     })
[10:31:37.858]                   }
[10:31:37.858]                   ...future.strategy.old <- future::plan("list")
[10:31:37.858]                   options(future.plan = NULL)
[10:31:37.858]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:37.858]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:37.858]                 }
[10:31:37.858]                 ...future.workdir <- getwd()
[10:31:37.858]             }
[10:31:37.858]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:37.858]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:37.858]         }
[10:31:37.858]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:37.858]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:37.858]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:37.858]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:37.858]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:37.858]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:37.858]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:37.858]             base::names(...future.oldOptions))
[10:31:37.858]     }
[10:31:37.858]     if (FALSE) {
[10:31:37.858]     }
[10:31:37.858]     else {
[10:31:37.858]         if (FALSE) {
[10:31:37.858]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:37.858]                 open = "w")
[10:31:37.858]         }
[10:31:37.858]         else {
[10:31:37.858]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:37.858]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:37.858]         }
[10:31:37.858]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:37.858]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:37.858]             base::sink(type = "output", split = FALSE)
[10:31:37.858]             base::close(...future.stdout)
[10:31:37.858]         }, add = TRUE)
[10:31:37.858]     }
[10:31:37.858]     ...future.frame <- base::sys.nframe()
[10:31:37.858]     ...future.conditions <- base::list()
[10:31:37.858]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:37.858]     if (FALSE) {
[10:31:37.858]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:37.858]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:37.858]     }
[10:31:37.858]     ...future.result <- base::tryCatch({
[10:31:37.858]         base::withCallingHandlers({
[10:31:37.858]             ...future.value <- base::withVisible(base::local({
[10:31:37.858]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:37.858]                 if (!identical(...future.globals.maxSize.org, 
[10:31:37.858]                   ...future.globals.maxSize)) {
[10:31:37.858]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:37.858]                   on.exit(options(oopts), add = TRUE)
[10:31:37.858]                 }
[10:31:37.858]                 {
[10:31:37.858]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:37.858]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:37.858]                     USE.NAMES = FALSE)
[10:31:37.858]                   do.call(mapply, args = args)
[10:31:37.858]                 }
[10:31:37.858]             }))
[10:31:37.858]             future::FutureResult(value = ...future.value$value, 
[10:31:37.858]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:37.858]                   ...future.rng), globalenv = if (FALSE) 
[10:31:37.858]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:37.858]                     ...future.globalenv.names))
[10:31:37.858]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:37.858]         }, condition = base::local({
[10:31:37.858]             c <- base::c
[10:31:37.858]             inherits <- base::inherits
[10:31:37.858]             invokeRestart <- base::invokeRestart
[10:31:37.858]             length <- base::length
[10:31:37.858]             list <- base::list
[10:31:37.858]             seq.int <- base::seq.int
[10:31:37.858]             signalCondition <- base::signalCondition
[10:31:37.858]             sys.calls <- base::sys.calls
[10:31:37.858]             `[[` <- base::`[[`
[10:31:37.858]             `+` <- base::`+`
[10:31:37.858]             `<<-` <- base::`<<-`
[10:31:37.858]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:37.858]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:37.858]                   3L)]
[10:31:37.858]             }
[10:31:37.858]             function(cond) {
[10:31:37.858]                 is_error <- inherits(cond, "error")
[10:31:37.858]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:37.858]                   NULL)
[10:31:37.858]                 if (is_error) {
[10:31:37.858]                   sessionInformation <- function() {
[10:31:37.858]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:37.858]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:37.858]                       search = base::search(), system = base::Sys.info())
[10:31:37.858]                   }
[10:31:37.858]                   ...future.conditions[[length(...future.conditions) + 
[10:31:37.858]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:37.858]                     cond$call), session = sessionInformation(), 
[10:31:37.858]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:37.858]                   signalCondition(cond)
[10:31:37.858]                 }
[10:31:37.858]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:37.858]                 "immediateCondition"))) {
[10:31:37.858]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:37.858]                   ...future.conditions[[length(...future.conditions) + 
[10:31:37.858]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:37.858]                   if (TRUE && !signal) {
[10:31:37.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:37.858]                     {
[10:31:37.858]                       inherits <- base::inherits
[10:31:37.858]                       invokeRestart <- base::invokeRestart
[10:31:37.858]                       is.null <- base::is.null
[10:31:37.858]                       muffled <- FALSE
[10:31:37.858]                       if (inherits(cond, "message")) {
[10:31:37.858]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:37.858]                         if (muffled) 
[10:31:37.858]                           invokeRestart("muffleMessage")
[10:31:37.858]                       }
[10:31:37.858]                       else if (inherits(cond, "warning")) {
[10:31:37.858]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:37.858]                         if (muffled) 
[10:31:37.858]                           invokeRestart("muffleWarning")
[10:31:37.858]                       }
[10:31:37.858]                       else if (inherits(cond, "condition")) {
[10:31:37.858]                         if (!is.null(pattern)) {
[10:31:37.858]                           computeRestarts <- base::computeRestarts
[10:31:37.858]                           grepl <- base::grepl
[10:31:37.858]                           restarts <- computeRestarts(cond)
[10:31:37.858]                           for (restart in restarts) {
[10:31:37.858]                             name <- restart$name
[10:31:37.858]                             if (is.null(name)) 
[10:31:37.858]                               next
[10:31:37.858]                             if (!grepl(pattern, name)) 
[10:31:37.858]                               next
[10:31:37.858]                             invokeRestart(restart)
[10:31:37.858]                             muffled <- TRUE
[10:31:37.858]                             break
[10:31:37.858]                           }
[10:31:37.858]                         }
[10:31:37.858]                       }
[10:31:37.858]                       invisible(muffled)
[10:31:37.858]                     }
[10:31:37.858]                     muffleCondition(cond, pattern = "^muffle")
[10:31:37.858]                   }
[10:31:37.858]                 }
[10:31:37.858]                 else {
[10:31:37.858]                   if (TRUE) {
[10:31:37.858]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:37.858]                     {
[10:31:37.858]                       inherits <- base::inherits
[10:31:37.858]                       invokeRestart <- base::invokeRestart
[10:31:37.858]                       is.null <- base::is.null
[10:31:37.858]                       muffled <- FALSE
[10:31:37.858]                       if (inherits(cond, "message")) {
[10:31:37.858]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:37.858]                         if (muffled) 
[10:31:37.858]                           invokeRestart("muffleMessage")
[10:31:37.858]                       }
[10:31:37.858]                       else if (inherits(cond, "warning")) {
[10:31:37.858]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:37.858]                         if (muffled) 
[10:31:37.858]                           invokeRestart("muffleWarning")
[10:31:37.858]                       }
[10:31:37.858]                       else if (inherits(cond, "condition")) {
[10:31:37.858]                         if (!is.null(pattern)) {
[10:31:37.858]                           computeRestarts <- base::computeRestarts
[10:31:37.858]                           grepl <- base::grepl
[10:31:37.858]                           restarts <- computeRestarts(cond)
[10:31:37.858]                           for (restart in restarts) {
[10:31:37.858]                             name <- restart$name
[10:31:37.858]                             if (is.null(name)) 
[10:31:37.858]                               next
[10:31:37.858]                             if (!grepl(pattern, name)) 
[10:31:37.858]                               next
[10:31:37.858]                             invokeRestart(restart)
[10:31:37.858]                             muffled <- TRUE
[10:31:37.858]                             break
[10:31:37.858]                           }
[10:31:37.858]                         }
[10:31:37.858]                       }
[10:31:37.858]                       invisible(muffled)
[10:31:37.858]                     }
[10:31:37.858]                     muffleCondition(cond, pattern = "^muffle")
[10:31:37.858]                   }
[10:31:37.858]                 }
[10:31:37.858]             }
[10:31:37.858]         }))
[10:31:37.858]     }, error = function(ex) {
[10:31:37.858]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:37.858]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:37.858]                 ...future.rng), started = ...future.startTime, 
[10:31:37.858]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:37.858]             version = "1.8"), class = "FutureResult")
[10:31:37.858]     }, finally = {
[10:31:37.858]         if (!identical(...future.workdir, getwd())) 
[10:31:37.858]             setwd(...future.workdir)
[10:31:37.858]         {
[10:31:37.858]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:37.858]                 ...future.oldOptions$nwarnings <- NULL
[10:31:37.858]             }
[10:31:37.858]             base::options(...future.oldOptions)
[10:31:37.858]             if (.Platform$OS.type == "windows") {
[10:31:37.858]                 old_names <- names(...future.oldEnvVars)
[10:31:37.858]                 envs <- base::Sys.getenv()
[10:31:37.858]                 names <- names(envs)
[10:31:37.858]                 common <- intersect(names, old_names)
[10:31:37.858]                 added <- setdiff(names, old_names)
[10:31:37.858]                 removed <- setdiff(old_names, names)
[10:31:37.858]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:37.858]                   envs[common]]
[10:31:37.858]                 NAMES <- toupper(changed)
[10:31:37.858]                 args <- list()
[10:31:37.858]                 for (kk in seq_along(NAMES)) {
[10:31:37.858]                   name <- changed[[kk]]
[10:31:37.858]                   NAME <- NAMES[[kk]]
[10:31:37.858]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:37.858]                     next
[10:31:37.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:37.858]                 }
[10:31:37.858]                 NAMES <- toupper(added)
[10:31:37.858]                 for (kk in seq_along(NAMES)) {
[10:31:37.858]                   name <- added[[kk]]
[10:31:37.858]                   NAME <- NAMES[[kk]]
[10:31:37.858]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:37.858]                     next
[10:31:37.858]                   args[[name]] <- ""
[10:31:37.858]                 }
[10:31:37.858]                 NAMES <- toupper(removed)
[10:31:37.858]                 for (kk in seq_along(NAMES)) {
[10:31:37.858]                   name <- removed[[kk]]
[10:31:37.858]                   NAME <- NAMES[[kk]]
[10:31:37.858]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:37.858]                     next
[10:31:37.858]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:37.858]                 }
[10:31:37.858]                 if (length(args) > 0) 
[10:31:37.858]                   base::do.call(base::Sys.setenv, args = args)
[10:31:37.858]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:37.858]             }
[10:31:37.858]             else {
[10:31:37.858]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:37.858]             }
[10:31:37.858]             {
[10:31:37.858]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:37.858]                   0L) {
[10:31:37.858]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:37.858]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:37.858]                   base::options(opts)
[10:31:37.858]                 }
[10:31:37.858]                 {
[10:31:37.858]                   {
[10:31:37.858]                     NULL
[10:31:37.858]                     RNGkind("Mersenne-Twister")
[10:31:37.858]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:37.858]                       inherits = FALSE)
[10:31:37.858]                   }
[10:31:37.858]                   options(future.plan = NULL)
[10:31:37.858]                   if (is.na(NA_character_)) 
[10:31:37.858]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:37.858]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:37.858]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:37.858]                     .init = FALSE)
[10:31:37.858]                 }
[10:31:37.858]             }
[10:31:37.858]         }
[10:31:37.858]     })
[10:31:37.858]     if (TRUE) {
[10:31:37.858]         base::sink(type = "output", split = FALSE)
[10:31:37.858]         if (FALSE) {
[10:31:37.858]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:37.858]         }
[10:31:37.858]         else {
[10:31:37.858]             ...future.result["stdout"] <- base::list(NULL)
[10:31:37.858]         }
[10:31:37.858]         base::close(...future.stdout)
[10:31:37.858]         ...future.stdout <- NULL
[10:31:37.858]     }
[10:31:37.858]     ...future.result$conditions <- ...future.conditions
[10:31:37.858]     ...future.result$finished <- base::Sys.time()
[10:31:37.858]     ...future.result
[10:31:37.858] }
[10:31:37.860] assign_globals() ...
[10:31:37.860] List of 5
[10:31:37.860]  $ ...future.FUN            :function (x, y)  
[10:31:37.860]  $ MoreArgs                 : NULL
[10:31:37.860]  $ ...future.elements_ii    :List of 2
[10:31:37.860]   ..$ :List of 2
[10:31:37.860]   .. ..$ : int 1
[10:31:37.860]   .. ..$ : int 0
[10:31:37.860]   ..$ :List of 2
[10:31:37.860]   .. ..$ : int 0
[10:31:37.860]   .. ..$ : int 1
[10:31:37.860]  $ ...future.seeds_ii       : NULL
[10:31:37.860]  $ ...future.globals.maxSize: NULL
[10:31:37.860]  - attr(*, "where")=List of 5
[10:31:37.860]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:37.860]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:37.860]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:37.860]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:37.860]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:37.860]  - attr(*, "resolved")= logi FALSE
[10:31:37.860]  - attr(*, "total_size")= num 6480
[10:31:37.860]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:37.860]  - attr(*, "already-done")= logi TRUE
[10:31:37.865] - reassign environment for ‘...future.FUN’
[10:31:37.865] - copied ‘...future.FUN’ to environment
[10:31:37.865] - copied ‘MoreArgs’ to environment
[10:31:37.866] - copied ‘...future.elements_ii’ to environment
[10:31:37.866] - copied ‘...future.seeds_ii’ to environment
[10:31:37.866] - copied ‘...future.globals.maxSize’ to environment
[10:31:37.866] assign_globals() ... done
[10:31:37.866] plan(): Setting new future strategy stack:
[10:31:37.866] List of future strategies:
[10:31:37.866] 1. sequential:
[10:31:37.866]    - args: function (..., envir = parent.frame())
[10:31:37.866]    - tweaked: FALSE
[10:31:37.866]    - call: NULL
[10:31:37.867] plan(): nbrOfWorkers() = 1
[10:31:38.368] plan(): Setting new future strategy stack:
[10:31:38.368] List of future strategies:
[10:31:38.368] 1. sequential:
[10:31:38.368]    - args: function (..., envir = parent.frame())
[10:31:38.368]    - tweaked: FALSE
[10:31:38.368]    - call: plan(strategy)
[10:31:38.369] plan(): nbrOfWorkers() = 1
[10:31:38.369] SequentialFuture started (and completed)
[10:31:38.369] - Launch lazy future ... done
[10:31:38.369] run() for ‘SequentialFuture’ ... done
[10:31:38.370] Created future:
[10:31:38.370] SequentialFuture:
[10:31:38.370] Label: ‘future_mapply-1’
[10:31:38.370] Expression:
[10:31:38.370] {
[10:31:38.370]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:38.370]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:38.370]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:38.370]         on.exit(options(oopts), add = TRUE)
[10:31:38.370]     }
[10:31:38.370]     {
[10:31:38.370]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:38.370]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:38.370]         do.call(mapply, args = args)
[10:31:38.370]     }
[10:31:38.370] }
[10:31:38.370] Lazy evaluation: FALSE
[10:31:38.370] Asynchronous evaluation: FALSE
[10:31:38.370] Local evaluation: TRUE
[10:31:38.370] Environment: R_GlobalEnv
[10:31:38.370] Capture standard output: FALSE
[10:31:38.370] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:38.370] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:38.370] Packages: <none>
[10:31:38.370] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:38.370] Resolved: TRUE
[10:31:38.370] Value: 224 bytes of class ‘list’
[10:31:38.370] Early signaling: FALSE
[10:31:38.370] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:38.370] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:38.371] Chunk #1 of 1 ... DONE
[10:31:38.371] Launching 1 futures (chunks) ... DONE
[10:31:38.371] Resolving 1 futures (chunks) ...
[10:31:38.371] resolve() on list ...
[10:31:38.371]  recursive: 0
[10:31:38.371]  length: 1
[10:31:38.371] 
[10:31:38.371] resolved() for ‘SequentialFuture’ ...
[10:31:38.371] - state: ‘finished’
[10:31:38.372] - run: TRUE
[10:31:38.372] - result: ‘FutureResult’
[10:31:38.372] resolved() for ‘SequentialFuture’ ... done
[10:31:38.372] Future #1
[10:31:38.372] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:38.372] - nx: 1
[10:31:38.372] - relay: TRUE
[10:31:38.372] - stdout: TRUE
[10:31:38.372] - signal: TRUE
[10:31:38.374] - resignal: FALSE
[10:31:38.374] - force: TRUE
[10:31:38.374] - relayed: [n=1] FALSE
[10:31:38.374] - queued futures: [n=1] FALSE
[10:31:38.375]  - until=1
[10:31:38.375]  - relaying element #1
[10:31:38.375] - relayed: [n=1] TRUE
[10:31:38.375] - queued futures: [n=1] TRUE
[10:31:38.375] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:38.375]  length: 0 (resolved future 1)
[10:31:38.375] Relaying remaining futures
[10:31:38.375] signalConditionsASAP(NULL, pos=0) ...
[10:31:38.375] - nx: 1
[10:31:38.375] - relay: TRUE
[10:31:38.376] - stdout: TRUE
[10:31:38.376] - signal: TRUE
[10:31:38.376] - resignal: FALSE
[10:31:38.376] - force: TRUE
[10:31:38.376] - relayed: [n=1] TRUE
[10:31:38.376] - queued futures: [n=1] TRUE
 - flush all
[10:31:38.376] - relayed: [n=1] TRUE
[10:31:38.376] - queued futures: [n=1] TRUE
[10:31:38.376] signalConditionsASAP(NULL, pos=0) ... done
[10:31:38.376] resolve() on list ... DONE
[10:31:38.377]  - Number of value chunks collected: 1
[10:31:38.377] Resolving 1 futures (chunks) ... DONE
[10:31:38.377] Reducing values from 1 chunks ...
[10:31:38.377]  - Number of values collected after concatenation: 2
[10:31:38.377]  - Number of values expected: 2
[10:31:38.377] Reducing values from 1 chunks ... DONE
[10:31:38.377] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:31:38.378] future_mapply() ...
[10:31:38.378] Number of chunks: 1
[10:31:38.378] getGlobalsAndPackagesXApply() ...
[10:31:38.378]  - future.globals: TRUE
[10:31:38.378] getGlobalsAndPackages() ...
[10:31:38.378] Searching for globals...
[10:31:38.380] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:38.380] Searching for globals ... DONE
[10:31:38.380] Resolving globals: FALSE
[10:31:38.380] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:38.381] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:38.381] - globals: [1] ‘FUN’
[10:31:38.381] 
[10:31:38.381] getGlobalsAndPackages() ... DONE
[10:31:38.381]  - globals found/used: [n=1] ‘FUN’
[10:31:38.381]  - needed namespaces: [n=0] 
[10:31:38.381] Finding globals ... DONE
[10:31:38.381] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:38.382] List of 2
[10:31:38.382]  $ ...future.FUN:function (x, y)  
[10:31:38.382]  $ MoreArgs     : NULL
[10:31:38.382]  - attr(*, "where")=List of 2
[10:31:38.382]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:38.382]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:38.382]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:38.382]  - attr(*, "resolved")= logi FALSE
[10:31:38.382]  - attr(*, "total_size")= num NA
[10:31:38.384] Packages to be attached in all futures: [n=0] 
[10:31:38.384] getGlobalsAndPackagesXApply() ... DONE
[10:31:38.384] Number of futures (= number of chunks): 1
[10:31:38.384] Launching 1 futures (chunks) ...
[10:31:38.385] Chunk #1 of 1 ...
[10:31:38.385]  - Finding globals in '...' for chunk #1 ...
[10:31:38.385] getGlobalsAndPackages() ...
[10:31:38.385] Searching for globals...
[10:31:38.385] 
[10:31:38.385] Searching for globals ... DONE
[10:31:38.385] - globals: [0] <none>
[10:31:38.386] getGlobalsAndPackages() ... DONE
[10:31:38.386]    + additional globals found: [n=0] 
[10:31:38.386]    + additional namespaces needed: [n=0] 
[10:31:38.386]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:38.386]  - seeds: <none>
[10:31:38.386]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:38.386] getGlobalsAndPackages() ...
[10:31:38.386] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:38.386] Resolving globals: FALSE
[10:31:38.387] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:31:38.387] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:38.387] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:38.387] 
[10:31:38.388] getGlobalsAndPackages() ... DONE
[10:31:38.388] run() for ‘Future’ ...
[10:31:38.388] - state: ‘created’
[10:31:38.388] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:38.388] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:38.388] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:38.389]   - Field: ‘label’
[10:31:38.389]   - Field: ‘local’
[10:31:38.389]   - Field: ‘owner’
[10:31:38.389]   - Field: ‘envir’
[10:31:38.389]   - Field: ‘packages’
[10:31:38.389]   - Field: ‘gc’
[10:31:38.389]   - Field: ‘conditions’
[10:31:38.389]   - Field: ‘expr’
[10:31:38.389]   - Field: ‘uuid’
[10:31:38.389]   - Field: ‘seed’
[10:31:38.389]   - Field: ‘version’
[10:31:38.390]   - Field: ‘result’
[10:31:38.390]   - Field: ‘asynchronous’
[10:31:38.390]   - Field: ‘calls’
[10:31:38.390]   - Field: ‘globals’
[10:31:38.390]   - Field: ‘stdout’
[10:31:38.390]   - Field: ‘earlySignal’
[10:31:38.390]   - Field: ‘lazy’
[10:31:38.390]   - Field: ‘state’
[10:31:38.390] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:38.390] - Launch lazy future ...
[10:31:38.391] Packages needed by the future expression (n = 0): <none>
[10:31:38.391] Packages needed by future strategies (n = 0): <none>
[10:31:38.391] {
[10:31:38.391]     {
[10:31:38.391]         {
[10:31:38.391]             ...future.startTime <- base::Sys.time()
[10:31:38.391]             {
[10:31:38.391]                 {
[10:31:38.391]                   {
[10:31:38.391]                     base::local({
[10:31:38.391]                       has_future <- base::requireNamespace("future", 
[10:31:38.391]                         quietly = TRUE)
[10:31:38.391]                       if (has_future) {
[10:31:38.391]                         ns <- base::getNamespace("future")
[10:31:38.391]                         version <- ns[[".package"]][["version"]]
[10:31:38.391]                         if (is.null(version)) 
[10:31:38.391]                           version <- utils::packageVersion("future")
[10:31:38.391]                       }
[10:31:38.391]                       else {
[10:31:38.391]                         version <- NULL
[10:31:38.391]                       }
[10:31:38.391]                       if (!has_future || version < "1.8.0") {
[10:31:38.391]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:38.391]                           "", base::R.version$version.string), 
[10:31:38.391]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:38.391]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:38.391]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:38.391]                             "release", "version")], collapse = " "), 
[10:31:38.391]                           hostname = base::Sys.info()[["nodename"]])
[10:31:38.391]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:38.391]                           info)
[10:31:38.391]                         info <- base::paste(info, collapse = "; ")
[10:31:38.391]                         if (!has_future) {
[10:31:38.391]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:38.391]                             info)
[10:31:38.391]                         }
[10:31:38.391]                         else {
[10:31:38.391]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:38.391]                             info, version)
[10:31:38.391]                         }
[10:31:38.391]                         base::stop(msg)
[10:31:38.391]                       }
[10:31:38.391]                     })
[10:31:38.391]                   }
[10:31:38.391]                   ...future.strategy.old <- future::plan("list")
[10:31:38.391]                   options(future.plan = NULL)
[10:31:38.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:38.391]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:38.391]                 }
[10:31:38.391]                 ...future.workdir <- getwd()
[10:31:38.391]             }
[10:31:38.391]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:38.391]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:38.391]         }
[10:31:38.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:38.391]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:38.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:38.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:38.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:38.391]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:38.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:38.391]             base::names(...future.oldOptions))
[10:31:38.391]     }
[10:31:38.391]     if (FALSE) {
[10:31:38.391]     }
[10:31:38.391]     else {
[10:31:38.391]         if (TRUE) {
[10:31:38.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:38.391]                 open = "w")
[10:31:38.391]         }
[10:31:38.391]         else {
[10:31:38.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:38.391]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:38.391]         }
[10:31:38.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:38.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:38.391]             base::sink(type = "output", split = FALSE)
[10:31:38.391]             base::close(...future.stdout)
[10:31:38.391]         }, add = TRUE)
[10:31:38.391]     }
[10:31:38.391]     ...future.frame <- base::sys.nframe()
[10:31:38.391]     ...future.conditions <- base::list()
[10:31:38.391]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:38.391]     if (FALSE) {
[10:31:38.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:38.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:38.391]     }
[10:31:38.391]     ...future.result <- base::tryCatch({
[10:31:38.391]         base::withCallingHandlers({
[10:31:38.391]             ...future.value <- base::withVisible(base::local({
[10:31:38.391]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:38.391]                 if (!identical(...future.globals.maxSize.org, 
[10:31:38.391]                   ...future.globals.maxSize)) {
[10:31:38.391]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:38.391]                   on.exit(options(oopts), add = TRUE)
[10:31:38.391]                 }
[10:31:38.391]                 {
[10:31:38.391]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:38.391]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:38.391]                     USE.NAMES = FALSE)
[10:31:38.391]                   do.call(mapply, args = args)
[10:31:38.391]                 }
[10:31:38.391]             }))
[10:31:38.391]             future::FutureResult(value = ...future.value$value, 
[10:31:38.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:38.391]                   ...future.rng), globalenv = if (FALSE) 
[10:31:38.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:38.391]                     ...future.globalenv.names))
[10:31:38.391]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:38.391]         }, condition = base::local({
[10:31:38.391]             c <- base::c
[10:31:38.391]             inherits <- base::inherits
[10:31:38.391]             invokeRestart <- base::invokeRestart
[10:31:38.391]             length <- base::length
[10:31:38.391]             list <- base::list
[10:31:38.391]             seq.int <- base::seq.int
[10:31:38.391]             signalCondition <- base::signalCondition
[10:31:38.391]             sys.calls <- base::sys.calls
[10:31:38.391]             `[[` <- base::`[[`
[10:31:38.391]             `+` <- base::`+`
[10:31:38.391]             `<<-` <- base::`<<-`
[10:31:38.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:38.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:38.391]                   3L)]
[10:31:38.391]             }
[10:31:38.391]             function(cond) {
[10:31:38.391]                 is_error <- inherits(cond, "error")
[10:31:38.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:38.391]                   NULL)
[10:31:38.391]                 if (is_error) {
[10:31:38.391]                   sessionInformation <- function() {
[10:31:38.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:38.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:38.391]                       search = base::search(), system = base::Sys.info())
[10:31:38.391]                   }
[10:31:38.391]                   ...future.conditions[[length(...future.conditions) + 
[10:31:38.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:38.391]                     cond$call), session = sessionInformation(), 
[10:31:38.391]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:38.391]                   signalCondition(cond)
[10:31:38.391]                 }
[10:31:38.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:38.391]                 "immediateCondition"))) {
[10:31:38.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:38.391]                   ...future.conditions[[length(...future.conditions) + 
[10:31:38.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:38.391]                   if (TRUE && !signal) {
[10:31:38.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:38.391]                     {
[10:31:38.391]                       inherits <- base::inherits
[10:31:38.391]                       invokeRestart <- base::invokeRestart
[10:31:38.391]                       is.null <- base::is.null
[10:31:38.391]                       muffled <- FALSE
[10:31:38.391]                       if (inherits(cond, "message")) {
[10:31:38.391]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:38.391]                         if (muffled) 
[10:31:38.391]                           invokeRestart("muffleMessage")
[10:31:38.391]                       }
[10:31:38.391]                       else if (inherits(cond, "warning")) {
[10:31:38.391]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:38.391]                         if (muffled) 
[10:31:38.391]                           invokeRestart("muffleWarning")
[10:31:38.391]                       }
[10:31:38.391]                       else if (inherits(cond, "condition")) {
[10:31:38.391]                         if (!is.null(pattern)) {
[10:31:38.391]                           computeRestarts <- base::computeRestarts
[10:31:38.391]                           grepl <- base::grepl
[10:31:38.391]                           restarts <- computeRestarts(cond)
[10:31:38.391]                           for (restart in restarts) {
[10:31:38.391]                             name <- restart$name
[10:31:38.391]                             if (is.null(name)) 
[10:31:38.391]                               next
[10:31:38.391]                             if (!grepl(pattern, name)) 
[10:31:38.391]                               next
[10:31:38.391]                             invokeRestart(restart)
[10:31:38.391]                             muffled <- TRUE
[10:31:38.391]                             break
[10:31:38.391]                           }
[10:31:38.391]                         }
[10:31:38.391]                       }
[10:31:38.391]                       invisible(muffled)
[10:31:38.391]                     }
[10:31:38.391]                     muffleCondition(cond, pattern = "^muffle")
[10:31:38.391]                   }
[10:31:38.391]                 }
[10:31:38.391]                 else {
[10:31:38.391]                   if (TRUE) {
[10:31:38.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:38.391]                     {
[10:31:38.391]                       inherits <- base::inherits
[10:31:38.391]                       invokeRestart <- base::invokeRestart
[10:31:38.391]                       is.null <- base::is.null
[10:31:38.391]                       muffled <- FALSE
[10:31:38.391]                       if (inherits(cond, "message")) {
[10:31:38.391]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:38.391]                         if (muffled) 
[10:31:38.391]                           invokeRestart("muffleMessage")
[10:31:38.391]                       }
[10:31:38.391]                       else if (inherits(cond, "warning")) {
[10:31:38.391]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:38.391]                         if (muffled) 
[10:31:38.391]                           invokeRestart("muffleWarning")
[10:31:38.391]                       }
[10:31:38.391]                       else if (inherits(cond, "condition")) {
[10:31:38.391]                         if (!is.null(pattern)) {
[10:31:38.391]                           computeRestarts <- base::computeRestarts
[10:31:38.391]                           grepl <- base::grepl
[10:31:38.391]                           restarts <- computeRestarts(cond)
[10:31:38.391]                           for (restart in restarts) {
[10:31:38.391]                             name <- restart$name
[10:31:38.391]                             if (is.null(name)) 
[10:31:38.391]                               next
[10:31:38.391]                             if (!grepl(pattern, name)) 
[10:31:38.391]                               next
[10:31:38.391]                             invokeRestart(restart)
[10:31:38.391]                             muffled <- TRUE
[10:31:38.391]                             break
[10:31:38.391]                           }
[10:31:38.391]                         }
[10:31:38.391]                       }
[10:31:38.391]                       invisible(muffled)
[10:31:38.391]                     }
[10:31:38.391]                     muffleCondition(cond, pattern = "^muffle")
[10:31:38.391]                   }
[10:31:38.391]                 }
[10:31:38.391]             }
[10:31:38.391]         }))
[10:31:38.391]     }, error = function(ex) {
[10:31:38.391]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:38.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:38.391]                 ...future.rng), started = ...future.startTime, 
[10:31:38.391]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:38.391]             version = "1.8"), class = "FutureResult")
[10:31:38.391]     }, finally = {
[10:31:38.391]         if (!identical(...future.workdir, getwd())) 
[10:31:38.391]             setwd(...future.workdir)
[10:31:38.391]         {
[10:31:38.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:38.391]                 ...future.oldOptions$nwarnings <- NULL
[10:31:38.391]             }
[10:31:38.391]             base::options(...future.oldOptions)
[10:31:38.391]             if (.Platform$OS.type == "windows") {
[10:31:38.391]                 old_names <- names(...future.oldEnvVars)
[10:31:38.391]                 envs <- base::Sys.getenv()
[10:31:38.391]                 names <- names(envs)
[10:31:38.391]                 common <- intersect(names, old_names)
[10:31:38.391]                 added <- setdiff(names, old_names)
[10:31:38.391]                 removed <- setdiff(old_names, names)
[10:31:38.391]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:38.391]                   envs[common]]
[10:31:38.391]                 NAMES <- toupper(changed)
[10:31:38.391]                 args <- list()
[10:31:38.391]                 for (kk in seq_along(NAMES)) {
[10:31:38.391]                   name <- changed[[kk]]
[10:31:38.391]                   NAME <- NAMES[[kk]]
[10:31:38.391]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:38.391]                     next
[10:31:38.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:38.391]                 }
[10:31:38.391]                 NAMES <- toupper(added)
[10:31:38.391]                 for (kk in seq_along(NAMES)) {
[10:31:38.391]                   name <- added[[kk]]
[10:31:38.391]                   NAME <- NAMES[[kk]]
[10:31:38.391]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:38.391]                     next
[10:31:38.391]                   args[[name]] <- ""
[10:31:38.391]                 }
[10:31:38.391]                 NAMES <- toupper(removed)
[10:31:38.391]                 for (kk in seq_along(NAMES)) {
[10:31:38.391]                   name <- removed[[kk]]
[10:31:38.391]                   NAME <- NAMES[[kk]]
[10:31:38.391]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:38.391]                     next
[10:31:38.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:38.391]                 }
[10:31:38.391]                 if (length(args) > 0) 
[10:31:38.391]                   base::do.call(base::Sys.setenv, args = args)
[10:31:38.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:38.391]             }
[10:31:38.391]             else {
[10:31:38.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:38.391]             }
[10:31:38.391]             {
[10:31:38.391]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:38.391]                   0L) {
[10:31:38.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:38.391]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:38.391]                   base::options(opts)
[10:31:38.391]                 }
[10:31:38.391]                 {
[10:31:38.391]                   {
[10:31:38.391]                     NULL
[10:31:38.391]                     RNGkind("Mersenne-Twister")
[10:31:38.391]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:38.391]                       inherits = FALSE)
[10:31:38.391]                   }
[10:31:38.391]                   options(future.plan = NULL)
[10:31:38.391]                   if (is.na(NA_character_)) 
[10:31:38.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:38.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:38.391]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:38.391]                     .init = FALSE)
[10:31:38.391]                 }
[10:31:38.391]             }
[10:31:38.391]         }
[10:31:38.391]     })
[10:31:38.391]     if (TRUE) {
[10:31:38.391]         base::sink(type = "output", split = FALSE)
[10:31:38.391]         if (TRUE) {
[10:31:38.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:38.391]         }
[10:31:38.391]         else {
[10:31:38.391]             ...future.result["stdout"] <- base::list(NULL)
[10:31:38.391]         }
[10:31:38.391]         base::close(...future.stdout)
[10:31:38.391]         ...future.stdout <- NULL
[10:31:38.391]     }
[10:31:38.391]     ...future.result$conditions <- ...future.conditions
[10:31:38.391]     ...future.result$finished <- base::Sys.time()
[10:31:38.391]     ...future.result
[10:31:38.391] }
[10:31:38.393] assign_globals() ...
[10:31:38.393] List of 5
[10:31:38.393]  $ ...future.FUN            :function (x, y)  
[10:31:38.393]  $ MoreArgs                 : NULL
[10:31:38.393]  $ ...future.elements_ii    :List of 2
[10:31:38.393]   ..$ :List of 2
[10:31:38.393]   .. ..$ : int 1
[10:31:38.393]   .. ..$ : int 0
[10:31:38.393]   ..$ :List of 2
[10:31:38.393]   .. ..$ : int 0
[10:31:38.393]   .. ..$ : int 1
[10:31:38.393]  $ ...future.seeds_ii       : NULL
[10:31:38.393]  $ ...future.globals.maxSize: NULL
[10:31:38.393]  - attr(*, "where")=List of 5
[10:31:38.393]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:38.393]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:38.393]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:38.393]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:38.393]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:38.393]  - attr(*, "resolved")= logi FALSE
[10:31:38.393]  - attr(*, "total_size")= num 6480
[10:31:38.393]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:38.393]  - attr(*, "already-done")= logi TRUE
[10:31:38.400] - reassign environment for ‘...future.FUN’
[10:31:38.400] - copied ‘...future.FUN’ to environment
[10:31:38.400] - copied ‘MoreArgs’ to environment
[10:31:38.401] - copied ‘...future.elements_ii’ to environment
[10:31:38.401] - copied ‘...future.seeds_ii’ to environment
[10:31:38.401] - copied ‘...future.globals.maxSize’ to environment
[10:31:38.401] assign_globals() ... done
[10:31:38.401] plan(): Setting new future strategy stack:
[10:31:38.401] List of future strategies:
[10:31:38.401] 1. sequential:
[10:31:38.401]    - args: function (..., envir = parent.frame())
[10:31:38.401]    - tweaked: FALSE
[10:31:38.401]    - call: NULL
[10:31:38.402] plan(): nbrOfWorkers() = 1
[10:31:38.903] plan(): Setting new future strategy stack:
[10:31:38.903] List of future strategies:
[10:31:38.903] 1. sequential:
[10:31:38.903]    - args: function (..., envir = parent.frame())
[10:31:38.903]    - tweaked: FALSE
[10:31:38.903]    - call: plan(strategy)
[10:31:38.904] plan(): nbrOfWorkers() = 1
[10:31:38.904] SequentialFuture started (and completed)
[10:31:38.904] - Launch lazy future ... done
[10:31:38.904] run() for ‘SequentialFuture’ ... done
[10:31:38.905] Created future:
[10:31:38.905] SequentialFuture:
[10:31:38.905] Label: ‘future_mapply-1’
[10:31:38.905] Expression:
[10:31:38.905] {
[10:31:38.905]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:38.905]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:38.905]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:38.905]         on.exit(options(oopts), add = TRUE)
[10:31:38.905]     }
[10:31:38.905]     {
[10:31:38.905]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:38.905]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:38.905]         do.call(mapply, args = args)
[10:31:38.905]     }
[10:31:38.905] }
[10:31:38.905] Lazy evaluation: FALSE
[10:31:38.905] Asynchronous evaluation: FALSE
[10:31:38.905] Local evaluation: TRUE
[10:31:38.905] Environment: R_GlobalEnv
[10:31:38.905] Capture standard output: TRUE
[10:31:38.905] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:38.905] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:38.905] Packages: <none>
[10:31:38.905] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:38.905] Resolved: TRUE
[10:31:38.905] Value: 224 bytes of class ‘list’
[10:31:38.905] Early signaling: FALSE
[10:31:38.905] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:38.905] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:38.906] Chunk #1 of 1 ... DONE
[10:31:38.906] Launching 1 futures (chunks) ... DONE
[10:31:38.906] Resolving 1 futures (chunks) ...
[10:31:38.906] resolve() on list ...
[10:31:38.906]  recursive: 0
[10:31:38.906]  length: 1
[10:31:38.906] 
[10:31:38.906] resolved() for ‘SequentialFuture’ ...
[10:31:38.906] - state: ‘finished’
[10:31:38.907] - run: TRUE
[10:31:38.907] - result: ‘FutureResult’
[10:31:38.907] resolved() for ‘SequentialFuture’ ... done
[10:31:38.907] Future #1
[10:31:38.907] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:38.907] - nx: 1
[10:31:38.907] - relay: TRUE
[10:31:38.907] - stdout: TRUE
[10:31:38.907] - signal: TRUE
[10:31:38.907] - resignal: FALSE
[10:31:38.907] - force: TRUE
[10:31:38.908] - relayed: [n=1] FALSE
[10:31:38.908] - queued futures: [n=1] FALSE
[10:31:38.908]  - until=1
[10:31:38.908]  - relaying element #1
[10:31:38.908] - relayed: [n=1] TRUE
[10:31:38.908] - queued futures: [n=1] TRUE
[10:31:38.908] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:38.908]  length: 0 (resolved future 1)
[10:31:38.908] Relaying remaining futures
[10:31:38.909] signalConditionsASAP(NULL, pos=0) ...
[10:31:38.909] - nx: 1
[10:31:38.909] - relay: TRUE
[10:31:38.909] - stdout: TRUE
[10:31:38.909] - signal: TRUE
[10:31:38.909] - resignal: FALSE
[10:31:38.909] - force: TRUE
[10:31:38.909] - relayed: [n=1] TRUE
[10:31:38.909] - queued futures: [n=1] TRUE
 - flush all
[10:31:38.909] - relayed: [n=1] TRUE
[10:31:38.909] - queued futures: [n=1] TRUE
[10:31:38.910] signalConditionsASAP(NULL, pos=0) ... done
[10:31:38.910] resolve() on list ... DONE
[10:31:38.910]  - Number of value chunks collected: 1
[10:31:38.910] Resolving 1 futures (chunks) ... DONE
[10:31:38.910] Reducing values from 1 chunks ...
[10:31:38.910]  - Number of values collected after concatenation: 2
[10:31:38.910]  - Number of values expected: 2
[10:31:38.910] Reducing values from 1 chunks ... DONE
[10:31:38.910] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:31:38.911] future_mapply() ...
[10:31:38.911] Number of chunks: 1
[10:31:38.911] getGlobalsAndPackagesXApply() ...
[10:31:38.911]  - future.globals: TRUE
[10:31:38.911] getGlobalsAndPackages() ...
[10:31:38.911] Searching for globals...
[10:31:38.913] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:38.913] Searching for globals ... DONE
[10:31:38.913] Resolving globals: FALSE
[10:31:38.914] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:38.914] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:38.914] - globals: [1] ‘FUN’
[10:31:38.914] 
[10:31:38.914] getGlobalsAndPackages() ... DONE
[10:31:38.914]  - globals found/used: [n=1] ‘FUN’
[10:31:38.914]  - needed namespaces: [n=0] 
[10:31:38.915] Finding globals ... DONE
[10:31:38.915] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:38.915] List of 2
[10:31:38.915]  $ ...future.FUN:function (x, y)  
[10:31:38.915]  $ MoreArgs     : NULL
[10:31:38.915]  - attr(*, "where")=List of 2
[10:31:38.915]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:38.915]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:38.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:38.915]  - attr(*, "resolved")= logi FALSE
[10:31:38.915]  - attr(*, "total_size")= num NA
[10:31:38.917] Packages to be attached in all futures: [n=0] 
[10:31:38.917] getGlobalsAndPackagesXApply() ... DONE
[10:31:38.918] Number of futures (= number of chunks): 1
[10:31:38.918] Launching 1 futures (chunks) ...
[10:31:38.918] Chunk #1 of 1 ...
[10:31:38.918]  - Finding globals in '...' for chunk #1 ...
[10:31:38.918] getGlobalsAndPackages() ...
[10:31:38.918] Searching for globals...
[10:31:38.918] 
[10:31:38.919] Searching for globals ... DONE
[10:31:38.919] - globals: [0] <none>
[10:31:38.919] getGlobalsAndPackages() ... DONE
[10:31:38.919]    + additional globals found: [n=0] 
[10:31:38.919]    + additional namespaces needed: [n=0] 
[10:31:38.919]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:38.919]  - seeds: <none>
[10:31:38.919]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:38.919] getGlobalsAndPackages() ...
[10:31:38.919] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:38.920] Resolving globals: FALSE
[10:31:38.920] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:31:38.920] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:38.921] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:38.921] 
[10:31:38.921] getGlobalsAndPackages() ... DONE
[10:31:38.921] run() for ‘Future’ ...
[10:31:38.921] - state: ‘created’
[10:31:38.921] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:38.922] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:38.922] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:38.922]   - Field: ‘label’
[10:31:38.922]   - Field: ‘local’
[10:31:38.922]   - Field: ‘owner’
[10:31:38.922]   - Field: ‘envir’
[10:31:38.922]   - Field: ‘packages’
[10:31:38.922]   - Field: ‘gc’
[10:31:38.922]   - Field: ‘conditions’
[10:31:38.922]   - Field: ‘expr’
[10:31:38.923]   - Field: ‘uuid’
[10:31:38.923]   - Field: ‘seed’
[10:31:38.923]   - Field: ‘version’
[10:31:38.923]   - Field: ‘result’
[10:31:38.923]   - Field: ‘asynchronous’
[10:31:38.923]   - Field: ‘calls’
[10:31:38.923]   - Field: ‘globals’
[10:31:38.923]   - Field: ‘stdout’
[10:31:38.923]   - Field: ‘earlySignal’
[10:31:38.923]   - Field: ‘lazy’
[10:31:38.924]   - Field: ‘state’
[10:31:38.924] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:38.924] - Launch lazy future ...
[10:31:38.926] Packages needed by the future expression (n = 0): <none>
[10:31:38.926] Packages needed by future strategies (n = 0): <none>
[10:31:38.926] {
[10:31:38.926]     {
[10:31:38.926]         {
[10:31:38.926]             ...future.startTime <- base::Sys.time()
[10:31:38.926]             {
[10:31:38.926]                 {
[10:31:38.926]                   {
[10:31:38.926]                     base::local({
[10:31:38.926]                       has_future <- base::requireNamespace("future", 
[10:31:38.926]                         quietly = TRUE)
[10:31:38.926]                       if (has_future) {
[10:31:38.926]                         ns <- base::getNamespace("future")
[10:31:38.926]                         version <- ns[[".package"]][["version"]]
[10:31:38.926]                         if (is.null(version)) 
[10:31:38.926]                           version <- utils::packageVersion("future")
[10:31:38.926]                       }
[10:31:38.926]                       else {
[10:31:38.926]                         version <- NULL
[10:31:38.926]                       }
[10:31:38.926]                       if (!has_future || version < "1.8.0") {
[10:31:38.926]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:38.926]                           "", base::R.version$version.string), 
[10:31:38.926]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:38.926]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:38.926]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:38.926]                             "release", "version")], collapse = " "), 
[10:31:38.926]                           hostname = base::Sys.info()[["nodename"]])
[10:31:38.926]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:38.926]                           info)
[10:31:38.926]                         info <- base::paste(info, collapse = "; ")
[10:31:38.926]                         if (!has_future) {
[10:31:38.926]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:38.926]                             info)
[10:31:38.926]                         }
[10:31:38.926]                         else {
[10:31:38.926]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:38.926]                             info, version)
[10:31:38.926]                         }
[10:31:38.926]                         base::stop(msg)
[10:31:38.926]                       }
[10:31:38.926]                     })
[10:31:38.926]                   }
[10:31:38.926]                   ...future.strategy.old <- future::plan("list")
[10:31:38.926]                   options(future.plan = NULL)
[10:31:38.926]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:38.926]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:38.926]                 }
[10:31:38.926]                 ...future.workdir <- getwd()
[10:31:38.926]             }
[10:31:38.926]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:38.926]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:38.926]         }
[10:31:38.926]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:38.926]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:38.926]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:38.926]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:38.926]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:38.926]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:38.926]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:38.926]             base::names(...future.oldOptions))
[10:31:38.926]     }
[10:31:38.926]     if (TRUE) {
[10:31:38.926]     }
[10:31:38.926]     else {
[10:31:38.926]         if (NA) {
[10:31:38.926]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:38.926]                 open = "w")
[10:31:38.926]         }
[10:31:38.926]         else {
[10:31:38.926]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:38.926]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:38.926]         }
[10:31:38.926]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:38.926]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:38.926]             base::sink(type = "output", split = FALSE)
[10:31:38.926]             base::close(...future.stdout)
[10:31:38.926]         }, add = TRUE)
[10:31:38.926]     }
[10:31:38.926]     ...future.frame <- base::sys.nframe()
[10:31:38.926]     ...future.conditions <- base::list()
[10:31:38.926]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:38.926]     if (FALSE) {
[10:31:38.926]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:38.926]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:38.926]     }
[10:31:38.926]     ...future.result <- base::tryCatch({
[10:31:38.926]         base::withCallingHandlers({
[10:31:38.926]             ...future.value <- base::withVisible(base::local({
[10:31:38.926]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:38.926]                 if (!identical(...future.globals.maxSize.org, 
[10:31:38.926]                   ...future.globals.maxSize)) {
[10:31:38.926]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:38.926]                   on.exit(options(oopts), add = TRUE)
[10:31:38.926]                 }
[10:31:38.926]                 {
[10:31:38.926]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:38.926]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:38.926]                     USE.NAMES = FALSE)
[10:31:38.926]                   do.call(mapply, args = args)
[10:31:38.926]                 }
[10:31:38.926]             }))
[10:31:38.926]             future::FutureResult(value = ...future.value$value, 
[10:31:38.926]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:38.926]                   ...future.rng), globalenv = if (FALSE) 
[10:31:38.926]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:38.926]                     ...future.globalenv.names))
[10:31:38.926]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:38.926]         }, condition = base::local({
[10:31:38.926]             c <- base::c
[10:31:38.926]             inherits <- base::inherits
[10:31:38.926]             invokeRestart <- base::invokeRestart
[10:31:38.926]             length <- base::length
[10:31:38.926]             list <- base::list
[10:31:38.926]             seq.int <- base::seq.int
[10:31:38.926]             signalCondition <- base::signalCondition
[10:31:38.926]             sys.calls <- base::sys.calls
[10:31:38.926]             `[[` <- base::`[[`
[10:31:38.926]             `+` <- base::`+`
[10:31:38.926]             `<<-` <- base::`<<-`
[10:31:38.926]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:38.926]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:38.926]                   3L)]
[10:31:38.926]             }
[10:31:38.926]             function(cond) {
[10:31:38.926]                 is_error <- inherits(cond, "error")
[10:31:38.926]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:38.926]                   NULL)
[10:31:38.926]                 if (is_error) {
[10:31:38.926]                   sessionInformation <- function() {
[10:31:38.926]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:38.926]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:38.926]                       search = base::search(), system = base::Sys.info())
[10:31:38.926]                   }
[10:31:38.926]                   ...future.conditions[[length(...future.conditions) + 
[10:31:38.926]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:38.926]                     cond$call), session = sessionInformation(), 
[10:31:38.926]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:38.926]                   signalCondition(cond)
[10:31:38.926]                 }
[10:31:38.926]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:38.926]                 "immediateCondition"))) {
[10:31:38.926]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:38.926]                   ...future.conditions[[length(...future.conditions) + 
[10:31:38.926]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:38.926]                   if (TRUE && !signal) {
[10:31:38.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:38.926]                     {
[10:31:38.926]                       inherits <- base::inherits
[10:31:38.926]                       invokeRestart <- base::invokeRestart
[10:31:38.926]                       is.null <- base::is.null
[10:31:38.926]                       muffled <- FALSE
[10:31:38.926]                       if (inherits(cond, "message")) {
[10:31:38.926]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:38.926]                         if (muffled) 
[10:31:38.926]                           invokeRestart("muffleMessage")
[10:31:38.926]                       }
[10:31:38.926]                       else if (inherits(cond, "warning")) {
[10:31:38.926]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:38.926]                         if (muffled) 
[10:31:38.926]                           invokeRestart("muffleWarning")
[10:31:38.926]                       }
[10:31:38.926]                       else if (inherits(cond, "condition")) {
[10:31:38.926]                         if (!is.null(pattern)) {
[10:31:38.926]                           computeRestarts <- base::computeRestarts
[10:31:38.926]                           grepl <- base::grepl
[10:31:38.926]                           restarts <- computeRestarts(cond)
[10:31:38.926]                           for (restart in restarts) {
[10:31:38.926]                             name <- restart$name
[10:31:38.926]                             if (is.null(name)) 
[10:31:38.926]                               next
[10:31:38.926]                             if (!grepl(pattern, name)) 
[10:31:38.926]                               next
[10:31:38.926]                             invokeRestart(restart)
[10:31:38.926]                             muffled <- TRUE
[10:31:38.926]                             break
[10:31:38.926]                           }
[10:31:38.926]                         }
[10:31:38.926]                       }
[10:31:38.926]                       invisible(muffled)
[10:31:38.926]                     }
[10:31:38.926]                     muffleCondition(cond, pattern = "^muffle")
[10:31:38.926]                   }
[10:31:38.926]                 }
[10:31:38.926]                 else {
[10:31:38.926]                   if (TRUE) {
[10:31:38.926]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:38.926]                     {
[10:31:38.926]                       inherits <- base::inherits
[10:31:38.926]                       invokeRestart <- base::invokeRestart
[10:31:38.926]                       is.null <- base::is.null
[10:31:38.926]                       muffled <- FALSE
[10:31:38.926]                       if (inherits(cond, "message")) {
[10:31:38.926]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:38.926]                         if (muffled) 
[10:31:38.926]                           invokeRestart("muffleMessage")
[10:31:38.926]                       }
[10:31:38.926]                       else if (inherits(cond, "warning")) {
[10:31:38.926]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:38.926]                         if (muffled) 
[10:31:38.926]                           invokeRestart("muffleWarning")
[10:31:38.926]                       }
[10:31:38.926]                       else if (inherits(cond, "condition")) {
[10:31:38.926]                         if (!is.null(pattern)) {
[10:31:38.926]                           computeRestarts <- base::computeRestarts
[10:31:38.926]                           grepl <- base::grepl
[10:31:38.926]                           restarts <- computeRestarts(cond)
[10:31:38.926]                           for (restart in restarts) {
[10:31:38.926]                             name <- restart$name
[10:31:38.926]                             if (is.null(name)) 
[10:31:38.926]                               next
[10:31:38.926]                             if (!grepl(pattern, name)) 
[10:31:38.926]                               next
[10:31:38.926]                             invokeRestart(restart)
[10:31:38.926]                             muffled <- TRUE
[10:31:38.926]                             break
[10:31:38.926]                           }
[10:31:38.926]                         }
[10:31:38.926]                       }
[10:31:38.926]                       invisible(muffled)
[10:31:38.926]                     }
[10:31:38.926]                     muffleCondition(cond, pattern = "^muffle")
[10:31:38.926]                   }
[10:31:38.926]                 }
[10:31:38.926]             }
[10:31:38.926]         }))
[10:31:38.926]     }, error = function(ex) {
[10:31:38.926]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:38.926]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:38.926]                 ...future.rng), started = ...future.startTime, 
[10:31:38.926]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:38.926]             version = "1.8"), class = "FutureResult")
[10:31:38.926]     }, finally = {
[10:31:38.926]         if (!identical(...future.workdir, getwd())) 
[10:31:38.926]             setwd(...future.workdir)
[10:31:38.926]         {
[10:31:38.926]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:38.926]                 ...future.oldOptions$nwarnings <- NULL
[10:31:38.926]             }
[10:31:38.926]             base::options(...future.oldOptions)
[10:31:38.926]             if (.Platform$OS.type == "windows") {
[10:31:38.926]                 old_names <- names(...future.oldEnvVars)
[10:31:38.926]                 envs <- base::Sys.getenv()
[10:31:38.926]                 names <- names(envs)
[10:31:38.926]                 common <- intersect(names, old_names)
[10:31:38.926]                 added <- setdiff(names, old_names)
[10:31:38.926]                 removed <- setdiff(old_names, names)
[10:31:38.926]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:38.926]                   envs[common]]
[10:31:38.926]                 NAMES <- toupper(changed)
[10:31:38.926]                 args <- list()
[10:31:38.926]                 for (kk in seq_along(NAMES)) {
[10:31:38.926]                   name <- changed[[kk]]
[10:31:38.926]                   NAME <- NAMES[[kk]]
[10:31:38.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:38.926]                     next
[10:31:38.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:38.926]                 }
[10:31:38.926]                 NAMES <- toupper(added)
[10:31:38.926]                 for (kk in seq_along(NAMES)) {
[10:31:38.926]                   name <- added[[kk]]
[10:31:38.926]                   NAME <- NAMES[[kk]]
[10:31:38.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:38.926]                     next
[10:31:38.926]                   args[[name]] <- ""
[10:31:38.926]                 }
[10:31:38.926]                 NAMES <- toupper(removed)
[10:31:38.926]                 for (kk in seq_along(NAMES)) {
[10:31:38.926]                   name <- removed[[kk]]
[10:31:38.926]                   NAME <- NAMES[[kk]]
[10:31:38.926]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:38.926]                     next
[10:31:38.926]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:38.926]                 }
[10:31:38.926]                 if (length(args) > 0) 
[10:31:38.926]                   base::do.call(base::Sys.setenv, args = args)
[10:31:38.926]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:38.926]             }
[10:31:38.926]             else {
[10:31:38.926]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:38.926]             }
[10:31:38.926]             {
[10:31:38.926]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:38.926]                   0L) {
[10:31:38.926]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:38.926]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:38.926]                   base::options(opts)
[10:31:38.926]                 }
[10:31:38.926]                 {
[10:31:38.926]                   {
[10:31:38.926]                     NULL
[10:31:38.926]                     RNGkind("Mersenne-Twister")
[10:31:38.926]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:38.926]                       inherits = FALSE)
[10:31:38.926]                   }
[10:31:38.926]                   options(future.plan = NULL)
[10:31:38.926]                   if (is.na(NA_character_)) 
[10:31:38.926]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:38.926]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:38.926]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:38.926]                     .init = FALSE)
[10:31:38.926]                 }
[10:31:38.926]             }
[10:31:38.926]         }
[10:31:38.926]     })
[10:31:38.926]     if (FALSE) {
[10:31:38.926]         base::sink(type = "output", split = FALSE)
[10:31:38.926]         if (NA) {
[10:31:38.926]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:38.926]         }
[10:31:38.926]         else {
[10:31:38.926]             ...future.result["stdout"] <- base::list(NULL)
[10:31:38.926]         }
[10:31:38.926]         base::close(...future.stdout)
[10:31:38.926]         ...future.stdout <- NULL
[10:31:38.926]     }
[10:31:38.926]     ...future.result$conditions <- ...future.conditions
[10:31:38.926]     ...future.result$finished <- base::Sys.time()
[10:31:38.926]     ...future.result
[10:31:38.926] }
[10:31:38.928] assign_globals() ...
[10:31:38.928] List of 5
[10:31:38.928]  $ ...future.FUN            :function (x, y)  
[10:31:38.928]  $ MoreArgs                 : NULL
[10:31:38.928]  $ ...future.elements_ii    :List of 2
[10:31:38.928]   ..$ :List of 2
[10:31:38.928]   .. ..$ : int 1
[10:31:38.928]   .. ..$ : int 0
[10:31:38.928]   ..$ :List of 2
[10:31:38.928]   .. ..$ : int 0
[10:31:38.928]   .. ..$ : int 1
[10:31:38.928]  $ ...future.seeds_ii       : NULL
[10:31:38.928]  $ ...future.globals.maxSize: NULL
[10:31:38.928]  - attr(*, "where")=List of 5
[10:31:38.928]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:38.928]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:38.928]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:38.928]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:38.928]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:38.928]  - attr(*, "resolved")= logi FALSE
[10:31:38.928]  - attr(*, "total_size")= num 6480
[10:31:38.928]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:38.928]  - attr(*, "already-done")= logi TRUE
[10:31:38.934] - reassign environment for ‘...future.FUN’
[10:31:38.934] - copied ‘...future.FUN’ to environment
[10:31:38.934] - copied ‘MoreArgs’ to environment
[10:31:38.934] - copied ‘...future.elements_ii’ to environment
[10:31:38.934] - copied ‘...future.seeds_ii’ to environment
[10:31:38.934] - copied ‘...future.globals.maxSize’ to environment
[10:31:38.934] assign_globals() ... done
[10:31:38.935] plan(): Setting new future strategy stack:
[10:31:38.935] List of future strategies:
[10:31:38.935] 1. sequential:
[10:31:38.935]    - args: function (..., envir = parent.frame())
[10:31:38.935]    - tweaked: FALSE
[10:31:38.935]    - call: NULL
[10:31:38.935] plan(): nbrOfWorkers() = 1
[10:31:39.437] plan(): Setting new future strategy stack:
[10:31:39.437] List of future strategies:
[10:31:39.437] 1. sequential:
[10:31:39.437]    - args: function (..., envir = parent.frame())
[10:31:39.437]    - tweaked: FALSE
[10:31:39.437]    - call: plan(strategy)
[10:31:39.438] plan(): nbrOfWorkers() = 1
[10:31:39.438] SequentialFuture started (and completed)
[10:31:39.438] - Launch lazy future ... done
[10:31:39.438] run() for ‘SequentialFuture’ ... done
[10:31:39.438] Created future:
[10:31:39.438] SequentialFuture:
[10:31:39.438] Label: ‘future_mapply-1’
[10:31:39.438] Expression:
[10:31:39.438] {
[10:31:39.438]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:39.438]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:39.438]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:39.438]         on.exit(options(oopts), add = TRUE)
[10:31:39.438]     }
[10:31:39.438]     {
[10:31:39.438]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:39.438]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:39.438]         do.call(mapply, args = args)
[10:31:39.438]     }
[10:31:39.438] }
[10:31:39.438] Lazy evaluation: FALSE
[10:31:39.438] Asynchronous evaluation: FALSE
[10:31:39.438] Local evaluation: TRUE
[10:31:39.438] Environment: R_GlobalEnv
[10:31:39.438] Capture standard output: NA
[10:31:39.438] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:39.438] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:39.438] Packages: <none>
[10:31:39.438] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:39.438] Resolved: TRUE
[10:31:39.438] Value: 224 bytes of class ‘list’
[10:31:39.438] Early signaling: FALSE
[10:31:39.438] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:39.438] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:39.439] Chunk #1 of 1 ... DONE
[10:31:39.439] Launching 1 futures (chunks) ... DONE
[10:31:39.439] Resolving 1 futures (chunks) ...
[10:31:39.440] resolve() on list ...
[10:31:39.440]  recursive: 0
[10:31:39.440]  length: 1
[10:31:39.440] 
[10:31:39.440] resolved() for ‘SequentialFuture’ ...
[10:31:39.440] - state: ‘finished’
[10:31:39.440] - run: TRUE
[10:31:39.440] - result: ‘FutureResult’
[10:31:39.440] resolved() for ‘SequentialFuture’ ... done
[10:31:39.440] Future #1
[10:31:39.441] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:39.441] - nx: 1
[10:31:39.441] - relay: TRUE
[10:31:39.441] - stdout: TRUE
[10:31:39.441] - signal: TRUE
[10:31:39.441] - resignal: FALSE
[10:31:39.441] - force: TRUE
[10:31:39.441] - relayed: [n=1] FALSE
[10:31:39.441] - queued futures: [n=1] FALSE
[10:31:39.441]  - until=1
[10:31:39.441]  - relaying element #1
[10:31:39.442] - relayed: [n=1] TRUE
[10:31:39.442] - queued futures: [n=1] TRUE
[10:31:39.442] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:39.442]  length: 0 (resolved future 1)
[10:31:39.442] Relaying remaining futures
[10:31:39.442] signalConditionsASAP(NULL, pos=0) ...
[10:31:39.442] - nx: 1
[10:31:39.442] - relay: TRUE
[10:31:39.442] - stdout: TRUE
[10:31:39.442] - signal: TRUE
[10:31:39.443] - resignal: FALSE
[10:31:39.443] - force: TRUE
[10:31:39.443] - relayed: [n=1] TRUE
[10:31:39.443] - queued futures: [n=1] TRUE
 - flush all
[10:31:39.443] - relayed: [n=1] TRUE
[10:31:39.443] - queued futures: [n=1] TRUE
[10:31:39.443] signalConditionsASAP(NULL, pos=0) ... done
[10:31:39.443] resolve() on list ... DONE
[10:31:39.443]  - Number of value chunks collected: 1
[10:31:39.443] Resolving 1 futures (chunks) ... DONE
[10:31:39.444] Reducing values from 1 chunks ...
[10:31:39.444]  - Number of values collected after concatenation: 2
[10:31:39.444]  - Number of values expected: 2
[10:31:39.444] Reducing values from 1 chunks ... DONE
[10:31:39.444] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[10:31:39.444] plan(): Setting new future strategy stack:
[10:31:39.445] List of future strategies:
[10:31:39.445] 1. multicore:
[10:31:39.445]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:39.445]    - tweaked: FALSE
[10:31:39.445]    - call: plan(strategy)
[10:31:39.449] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:31:39.449] future_lapply() ...
[10:31:39.453] Number of chunks: 1
[10:31:39.453] getGlobalsAndPackagesXApply() ...
[10:31:39.453]  - future.globals: TRUE
[10:31:39.453] getGlobalsAndPackages() ...
[10:31:39.453] Searching for globals...
[10:31:39.454] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:39.455] Searching for globals ... DONE
[10:31:39.455] Resolving globals: FALSE
[10:31:39.455] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:39.455] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:39.456] - globals: [1] ‘FUN’
[10:31:39.456] 
[10:31:39.456] getGlobalsAndPackages() ... DONE
[10:31:39.458]  - globals found/used: [n=1] ‘FUN’
[10:31:39.458]  - needed namespaces: [n=0] 
[10:31:39.458] Finding globals ... DONE
[10:31:39.458]  - use_args: TRUE
[10:31:39.458]  - Getting '...' globals ...
[10:31:39.458] resolve() on list ...
[10:31:39.458]  recursive: 0
[10:31:39.459]  length: 1
[10:31:39.459]  elements: ‘...’
[10:31:39.459]  length: 0 (resolved future 1)
[10:31:39.459] resolve() on list ... DONE
[10:31:39.459]    - '...' content: [n=0] 
[10:31:39.459] List of 1
[10:31:39.459]  $ ...: list()
[10:31:39.459]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:39.459]  - attr(*, "where")=List of 1
[10:31:39.459]   ..$ ...:<environment: 0x564ff4036a60> 
[10:31:39.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:39.459]  - attr(*, "resolved")= logi TRUE
[10:31:39.459]  - attr(*, "total_size")= num NA
[10:31:39.462]  - Getting '...' globals ... DONE
[10:31:39.462] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:39.462] List of 2
[10:31:39.462]  $ ...future.FUN:function (x)  
[10:31:39.462]  $ ...          : list()
[10:31:39.462]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:39.462]  - attr(*, "where")=List of 2
[10:31:39.462]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:39.462]   ..$ ...          :<environment: 0x564ff4036a60> 
[10:31:39.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:39.462]  - attr(*, "resolved")= logi FALSE
[10:31:39.462]  - attr(*, "total_size")= num 4720
[10:31:39.465] Packages to be attached in all futures: [n=0] 
[10:31:39.465] getGlobalsAndPackagesXApply() ... DONE
[10:31:39.465] Number of futures (= number of chunks): 1
[10:31:39.465] Launching 1 futures (chunks) ...
[10:31:39.465] Chunk #1 of 1 ...
[10:31:39.465]  - Finding globals in 'X' for chunk #1 ...
[10:31:39.465] getGlobalsAndPackages() ...
[10:31:39.465] Searching for globals...
[10:31:39.466] 
[10:31:39.466] Searching for globals ... DONE
[10:31:39.466] - globals: [0] <none>
[10:31:39.466] getGlobalsAndPackages() ... DONE
[10:31:39.466]    + additional globals found: [n=0] 
[10:31:39.466]    + additional namespaces needed: [n=0] 
[10:31:39.466]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:39.466]  - seeds: <none>
[10:31:39.466]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:39.467] getGlobalsAndPackages() ...
[10:31:39.467] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:39.467] Resolving globals: FALSE
[10:31:39.467] Tweak future expression to call with '...' arguments ...
[10:31:39.467] {
[10:31:39.467]     do.call(function(...) {
[10:31:39.467]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:39.467]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:39.467]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:39.467]             on.exit(options(oopts), add = TRUE)
[10:31:39.467]         }
[10:31:39.467]         {
[10:31:39.467]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:39.467]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:39.467]                 ...future.FUN(...future.X_jj, ...)
[10:31:39.467]             })
[10:31:39.467]         }
[10:31:39.467]     }, args = future.call.arguments)
[10:31:39.467] }
[10:31:39.467] Tweak future expression to call with '...' arguments ... DONE
[10:31:39.468] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:39.468] 
[10:31:39.468] getGlobalsAndPackages() ... DONE
[10:31:39.468] run() for ‘Future’ ...
[10:31:39.468] - state: ‘created’
[10:31:39.468] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:39.472] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:39.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:39.472]   - Field: ‘label’
[10:31:39.472]   - Field: ‘local’
[10:31:39.472]   - Field: ‘owner’
[10:31:39.472]   - Field: ‘envir’
[10:31:39.473]   - Field: ‘packages’
[10:31:39.473]   - Field: ‘gc’
[10:31:39.473]   - Field: ‘conditions’
[10:31:39.473]   - Field: ‘expr’
[10:31:39.473]   - Field: ‘uuid’
[10:31:39.473]   - Field: ‘seed’
[10:31:39.473]   - Field: ‘version’
[10:31:39.473]   - Field: ‘result’
[10:31:39.473]   - Field: ‘asynchronous’
[10:31:39.473]   - Field: ‘calls’
[10:31:39.474]   - Field: ‘globals’
[10:31:39.474]   - Field: ‘stdout’
[10:31:39.474]   - Field: ‘earlySignal’
[10:31:39.474]   - Field: ‘lazy’
[10:31:39.474]   - Field: ‘state’
[10:31:39.474] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:39.474] - Launch lazy future ...
[10:31:39.474] Packages needed by the future expression (n = 0): <none>
[10:31:39.474] Packages needed by future strategies (n = 0): <none>
[10:31:39.475] {
[10:31:39.475]     {
[10:31:39.475]         {
[10:31:39.475]             ...future.startTime <- base::Sys.time()
[10:31:39.475]             {
[10:31:39.475]                 {
[10:31:39.475]                   {
[10:31:39.475]                     base::local({
[10:31:39.475]                       has_future <- base::requireNamespace("future", 
[10:31:39.475]                         quietly = TRUE)
[10:31:39.475]                       if (has_future) {
[10:31:39.475]                         ns <- base::getNamespace("future")
[10:31:39.475]                         version <- ns[[".package"]][["version"]]
[10:31:39.475]                         if (is.null(version)) 
[10:31:39.475]                           version <- utils::packageVersion("future")
[10:31:39.475]                       }
[10:31:39.475]                       else {
[10:31:39.475]                         version <- NULL
[10:31:39.475]                       }
[10:31:39.475]                       if (!has_future || version < "1.8.0") {
[10:31:39.475]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:39.475]                           "", base::R.version$version.string), 
[10:31:39.475]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:39.475]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:39.475]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:39.475]                             "release", "version")], collapse = " "), 
[10:31:39.475]                           hostname = base::Sys.info()[["nodename"]])
[10:31:39.475]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:39.475]                           info)
[10:31:39.475]                         info <- base::paste(info, collapse = "; ")
[10:31:39.475]                         if (!has_future) {
[10:31:39.475]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:39.475]                             info)
[10:31:39.475]                         }
[10:31:39.475]                         else {
[10:31:39.475]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:39.475]                             info, version)
[10:31:39.475]                         }
[10:31:39.475]                         base::stop(msg)
[10:31:39.475]                       }
[10:31:39.475]                     })
[10:31:39.475]                   }
[10:31:39.475]                   ...future.strategy.old <- future::plan("list")
[10:31:39.475]                   options(future.plan = NULL)
[10:31:39.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:39.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:39.475]                 }
[10:31:39.475]                 ...future.workdir <- getwd()
[10:31:39.475]             }
[10:31:39.475]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:39.475]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:39.475]         }
[10:31:39.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:39.475]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:39.475]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:39.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:39.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:39.475]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:39.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:39.475]             base::names(...future.oldOptions))
[10:31:39.475]     }
[10:31:39.475]     if (FALSE) {
[10:31:39.475]     }
[10:31:39.475]     else {
[10:31:39.475]         if (FALSE) {
[10:31:39.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:39.475]                 open = "w")
[10:31:39.475]         }
[10:31:39.475]         else {
[10:31:39.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:39.475]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:39.475]         }
[10:31:39.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:39.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:39.475]             base::sink(type = "output", split = FALSE)
[10:31:39.475]             base::close(...future.stdout)
[10:31:39.475]         }, add = TRUE)
[10:31:39.475]     }
[10:31:39.475]     ...future.frame <- base::sys.nframe()
[10:31:39.475]     ...future.conditions <- base::list()
[10:31:39.475]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:39.475]     if (FALSE) {
[10:31:39.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:39.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:39.475]     }
[10:31:39.475]     ...future.result <- base::tryCatch({
[10:31:39.475]         base::withCallingHandlers({
[10:31:39.475]             ...future.value <- base::withVisible(base::local({
[10:31:39.475]                 do.call(function(...) {
[10:31:39.475]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:39.475]                   if (!identical(...future.globals.maxSize.org, 
[10:31:39.475]                     ...future.globals.maxSize)) {
[10:31:39.475]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:39.475]                     on.exit(options(oopts), add = TRUE)
[10:31:39.475]                   }
[10:31:39.475]                   {
[10:31:39.475]                     lapply(seq_along(...future.elements_ii), 
[10:31:39.475]                       FUN = function(jj) {
[10:31:39.475]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:39.475]                         ...future.FUN(...future.X_jj, ...)
[10:31:39.475]                       })
[10:31:39.475]                   }
[10:31:39.475]                 }, args = future.call.arguments)
[10:31:39.475]             }))
[10:31:39.475]             future::FutureResult(value = ...future.value$value, 
[10:31:39.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:39.475]                   ...future.rng), globalenv = if (FALSE) 
[10:31:39.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:39.475]                     ...future.globalenv.names))
[10:31:39.475]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:39.475]         }, condition = base::local({
[10:31:39.475]             c <- base::c
[10:31:39.475]             inherits <- base::inherits
[10:31:39.475]             invokeRestart <- base::invokeRestart
[10:31:39.475]             length <- base::length
[10:31:39.475]             list <- base::list
[10:31:39.475]             seq.int <- base::seq.int
[10:31:39.475]             signalCondition <- base::signalCondition
[10:31:39.475]             sys.calls <- base::sys.calls
[10:31:39.475]             `[[` <- base::`[[`
[10:31:39.475]             `+` <- base::`+`
[10:31:39.475]             `<<-` <- base::`<<-`
[10:31:39.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:39.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:39.475]                   3L)]
[10:31:39.475]             }
[10:31:39.475]             function(cond) {
[10:31:39.475]                 is_error <- inherits(cond, "error")
[10:31:39.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:39.475]                   NULL)
[10:31:39.475]                 if (is_error) {
[10:31:39.475]                   sessionInformation <- function() {
[10:31:39.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:39.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:39.475]                       search = base::search(), system = base::Sys.info())
[10:31:39.475]                   }
[10:31:39.475]                   ...future.conditions[[length(...future.conditions) + 
[10:31:39.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:39.475]                     cond$call), session = sessionInformation(), 
[10:31:39.475]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:39.475]                   signalCondition(cond)
[10:31:39.475]                 }
[10:31:39.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:39.475]                 "immediateCondition"))) {
[10:31:39.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:39.475]                   ...future.conditions[[length(...future.conditions) + 
[10:31:39.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:39.475]                   if (TRUE && !signal) {
[10:31:39.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:39.475]                     {
[10:31:39.475]                       inherits <- base::inherits
[10:31:39.475]                       invokeRestart <- base::invokeRestart
[10:31:39.475]                       is.null <- base::is.null
[10:31:39.475]                       muffled <- FALSE
[10:31:39.475]                       if (inherits(cond, "message")) {
[10:31:39.475]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:39.475]                         if (muffled) 
[10:31:39.475]                           invokeRestart("muffleMessage")
[10:31:39.475]                       }
[10:31:39.475]                       else if (inherits(cond, "warning")) {
[10:31:39.475]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:39.475]                         if (muffled) 
[10:31:39.475]                           invokeRestart("muffleWarning")
[10:31:39.475]                       }
[10:31:39.475]                       else if (inherits(cond, "condition")) {
[10:31:39.475]                         if (!is.null(pattern)) {
[10:31:39.475]                           computeRestarts <- base::computeRestarts
[10:31:39.475]                           grepl <- base::grepl
[10:31:39.475]                           restarts <- computeRestarts(cond)
[10:31:39.475]                           for (restart in restarts) {
[10:31:39.475]                             name <- restart$name
[10:31:39.475]                             if (is.null(name)) 
[10:31:39.475]                               next
[10:31:39.475]                             if (!grepl(pattern, name)) 
[10:31:39.475]                               next
[10:31:39.475]                             invokeRestart(restart)
[10:31:39.475]                             muffled <- TRUE
[10:31:39.475]                             break
[10:31:39.475]                           }
[10:31:39.475]                         }
[10:31:39.475]                       }
[10:31:39.475]                       invisible(muffled)
[10:31:39.475]                     }
[10:31:39.475]                     muffleCondition(cond, pattern = "^muffle")
[10:31:39.475]                   }
[10:31:39.475]                 }
[10:31:39.475]                 else {
[10:31:39.475]                   if (TRUE) {
[10:31:39.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:39.475]                     {
[10:31:39.475]                       inherits <- base::inherits
[10:31:39.475]                       invokeRestart <- base::invokeRestart
[10:31:39.475]                       is.null <- base::is.null
[10:31:39.475]                       muffled <- FALSE
[10:31:39.475]                       if (inherits(cond, "message")) {
[10:31:39.475]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:39.475]                         if (muffled) 
[10:31:39.475]                           invokeRestart("muffleMessage")
[10:31:39.475]                       }
[10:31:39.475]                       else if (inherits(cond, "warning")) {
[10:31:39.475]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:39.475]                         if (muffled) 
[10:31:39.475]                           invokeRestart("muffleWarning")
[10:31:39.475]                       }
[10:31:39.475]                       else if (inherits(cond, "condition")) {
[10:31:39.475]                         if (!is.null(pattern)) {
[10:31:39.475]                           computeRestarts <- base::computeRestarts
[10:31:39.475]                           grepl <- base::grepl
[10:31:39.475]                           restarts <- computeRestarts(cond)
[10:31:39.475]                           for (restart in restarts) {
[10:31:39.475]                             name <- restart$name
[10:31:39.475]                             if (is.null(name)) 
[10:31:39.475]                               next
[10:31:39.475]                             if (!grepl(pattern, name)) 
[10:31:39.475]                               next
[10:31:39.475]                             invokeRestart(restart)
[10:31:39.475]                             muffled <- TRUE
[10:31:39.475]                             break
[10:31:39.475]                           }
[10:31:39.475]                         }
[10:31:39.475]                       }
[10:31:39.475]                       invisible(muffled)
[10:31:39.475]                     }
[10:31:39.475]                     muffleCondition(cond, pattern = "^muffle")
[10:31:39.475]                   }
[10:31:39.475]                 }
[10:31:39.475]             }
[10:31:39.475]         }))
[10:31:39.475]     }, error = function(ex) {
[10:31:39.475]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:39.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:39.475]                 ...future.rng), started = ...future.startTime, 
[10:31:39.475]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:39.475]             version = "1.8"), class = "FutureResult")
[10:31:39.475]     }, finally = {
[10:31:39.475]         if (!identical(...future.workdir, getwd())) 
[10:31:39.475]             setwd(...future.workdir)
[10:31:39.475]         {
[10:31:39.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:39.475]                 ...future.oldOptions$nwarnings <- NULL
[10:31:39.475]             }
[10:31:39.475]             base::options(...future.oldOptions)
[10:31:39.475]             if (.Platform$OS.type == "windows") {
[10:31:39.475]                 old_names <- names(...future.oldEnvVars)
[10:31:39.475]                 envs <- base::Sys.getenv()
[10:31:39.475]                 names <- names(envs)
[10:31:39.475]                 common <- intersect(names, old_names)
[10:31:39.475]                 added <- setdiff(names, old_names)
[10:31:39.475]                 removed <- setdiff(old_names, names)
[10:31:39.475]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:39.475]                   envs[common]]
[10:31:39.475]                 NAMES <- toupper(changed)
[10:31:39.475]                 args <- list()
[10:31:39.475]                 for (kk in seq_along(NAMES)) {
[10:31:39.475]                   name <- changed[[kk]]
[10:31:39.475]                   NAME <- NAMES[[kk]]
[10:31:39.475]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:39.475]                     next
[10:31:39.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:39.475]                 }
[10:31:39.475]                 NAMES <- toupper(added)
[10:31:39.475]                 for (kk in seq_along(NAMES)) {
[10:31:39.475]                   name <- added[[kk]]
[10:31:39.475]                   NAME <- NAMES[[kk]]
[10:31:39.475]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:39.475]                     next
[10:31:39.475]                   args[[name]] <- ""
[10:31:39.475]                 }
[10:31:39.475]                 NAMES <- toupper(removed)
[10:31:39.475]                 for (kk in seq_along(NAMES)) {
[10:31:39.475]                   name <- removed[[kk]]
[10:31:39.475]                   NAME <- NAMES[[kk]]
[10:31:39.475]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:39.475]                     next
[10:31:39.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:39.475]                 }
[10:31:39.475]                 if (length(args) > 0) 
[10:31:39.475]                   base::do.call(base::Sys.setenv, args = args)
[10:31:39.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:39.475]             }
[10:31:39.475]             else {
[10:31:39.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:39.475]             }
[10:31:39.475]             {
[10:31:39.475]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:39.475]                   0L) {
[10:31:39.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:39.475]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:39.475]                   base::options(opts)
[10:31:39.475]                 }
[10:31:39.475]                 {
[10:31:39.475]                   {
[10:31:39.475]                     NULL
[10:31:39.475]                     RNGkind("Mersenne-Twister")
[10:31:39.475]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:39.475]                       inherits = FALSE)
[10:31:39.475]                   }
[10:31:39.475]                   options(future.plan = NULL)
[10:31:39.475]                   if (is.na(NA_character_)) 
[10:31:39.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:39.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:39.475]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:39.475]                     .init = FALSE)
[10:31:39.475]                 }
[10:31:39.475]             }
[10:31:39.475]         }
[10:31:39.475]     })
[10:31:39.475]     if (TRUE) {
[10:31:39.475]         base::sink(type = "output", split = FALSE)
[10:31:39.475]         if (FALSE) {
[10:31:39.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:39.475]         }
[10:31:39.475]         else {
[10:31:39.475]             ...future.result["stdout"] <- base::list(NULL)
[10:31:39.475]         }
[10:31:39.475]         base::close(...future.stdout)
[10:31:39.475]         ...future.stdout <- NULL
[10:31:39.475]     }
[10:31:39.475]     ...future.result$conditions <- ...future.conditions
[10:31:39.475]     ...future.result$finished <- base::Sys.time()
[10:31:39.475]     ...future.result
[10:31:39.475] }
[10:31:39.477] assign_globals() ...
[10:31:39.477] List of 5
[10:31:39.477]  $ ...future.FUN            :function (x)  
[10:31:39.477]  $ future.call.arguments    : list()
[10:31:39.477]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:39.477]  $ ...future.elements_ii    :List of 2
[10:31:39.477]   ..$ : int 1
[10:31:39.477]   ..$ : int 0
[10:31:39.477]  $ ...future.seeds_ii       : NULL
[10:31:39.477]  $ ...future.globals.maxSize: NULL
[10:31:39.477]  - attr(*, "where")=List of 5
[10:31:39.477]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:39.477]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:39.477]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:39.477]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:39.477]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:39.477]  - attr(*, "resolved")= logi FALSE
[10:31:39.477]  - attr(*, "total_size")= num 4720
[10:31:39.477]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:39.477]  - attr(*, "already-done")= logi TRUE
[10:31:39.481] - reassign environment for ‘...future.FUN’
[10:31:39.482] - copied ‘...future.FUN’ to environment
[10:31:39.482] - copied ‘future.call.arguments’ to environment
[10:31:39.482] - copied ‘...future.elements_ii’ to environment
[10:31:39.482] - copied ‘...future.seeds_ii’ to environment
[10:31:39.482] - copied ‘...future.globals.maxSize’ to environment
[10:31:39.482] assign_globals() ... done
[10:31:39.482] plan(): Setting new future strategy stack:
[10:31:39.482] List of future strategies:
[10:31:39.482] 1. sequential:
[10:31:39.482]    - args: function (..., envir = parent.frame())
[10:31:39.482]    - tweaked: FALSE
[10:31:39.482]    - call: NULL
[10:31:39.483] plan(): nbrOfWorkers() = 1
[10:31:39.986] plan(): Setting new future strategy stack:
[10:31:39.986] List of future strategies:
[10:31:39.986] 1. multicore:
[10:31:39.986]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:39.986]    - tweaked: FALSE
[10:31:39.986]    - call: plan(strategy)
[10:31:39.990] plan(): nbrOfWorkers() = 1
[10:31:39.991] SequentialFuture started (and completed)
[10:31:39.991] - Launch lazy future ... done
[10:31:39.991] run() for ‘SequentialFuture’ ... done
[10:31:39.991] Created future:
[10:31:39.991] SequentialFuture:
[10:31:39.991] Label: ‘future_lapply-1’
[10:31:39.991] Expression:
[10:31:39.991] {
[10:31:39.991]     do.call(function(...) {
[10:31:39.991]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:39.991]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:39.991]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:39.991]             on.exit(options(oopts), add = TRUE)
[10:31:39.991]         }
[10:31:39.991]         {
[10:31:39.991]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:39.991]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:39.991]                 ...future.FUN(...future.X_jj, ...)
[10:31:39.991]             })
[10:31:39.991]         }
[10:31:39.991]     }, args = future.call.arguments)
[10:31:39.991] }
[10:31:39.991] Lazy evaluation: FALSE
[10:31:39.991] Asynchronous evaluation: FALSE
[10:31:39.991] Local evaluation: TRUE
[10:31:39.991] Environment: R_GlobalEnv
[10:31:39.991] Capture standard output: FALSE
[10:31:39.991] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:39.991] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:39.991] Packages: <none>
[10:31:39.991] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:39.991] Resolved: TRUE
[10:31:39.991] Value: 112 bytes of class ‘list’
[10:31:39.991] Early signaling: FALSE
[10:31:39.991] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:39.991] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:39.992] Chunk #1 of 1 ... DONE
[10:31:39.992] Launching 1 futures (chunks) ... DONE
[10:31:39.992] Resolving 1 futures (chunks) ...
[10:31:39.993] resolve() on list ...
[10:31:39.993]  recursive: 0
[10:31:39.993]  length: 1
[10:31:39.993] 
[10:31:39.993] resolved() for ‘SequentialFuture’ ...
[10:31:39.993] - state: ‘finished’
[10:31:39.993] - run: TRUE
[10:31:39.993] - result: ‘FutureResult’
[10:31:39.993] resolved() for ‘SequentialFuture’ ... done
[10:31:39.994] Future #1
[10:31:39.994] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:39.994] - nx: 1
[10:31:39.994] - relay: TRUE
[10:31:39.994] - stdout: TRUE
[10:31:39.994] - signal: TRUE
[10:31:39.994] - resignal: FALSE
[10:31:39.994] - force: TRUE
[10:31:39.994] - relayed: [n=1] FALSE
[10:31:39.994] - queued futures: [n=1] FALSE
[10:31:39.995]  - until=1
[10:31:39.995]  - relaying element #1
[10:31:39.995] - relayed: [n=1] TRUE
[10:31:39.995] - queued futures: [n=1] TRUE
[10:31:39.995] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:39.995]  length: 0 (resolved future 1)
[10:31:39.995] Relaying remaining futures
[10:31:39.995] signalConditionsASAP(NULL, pos=0) ...
[10:31:39.995] - nx: 1
[10:31:39.995] - relay: TRUE
[10:31:39.995] - stdout: TRUE
[10:31:39.996] - signal: TRUE
[10:31:39.996] - resignal: FALSE
[10:31:39.996] - force: TRUE
[10:31:39.996] - relayed: [n=1] TRUE
[10:31:39.996] - queued futures: [n=1] TRUE
 - flush all
[10:31:39.996] - relayed: [n=1] TRUE
[10:31:39.996] - queued futures: [n=1] TRUE
[10:31:39.996] signalConditionsASAP(NULL, pos=0) ... done
[10:31:39.996] resolve() on list ... DONE
[10:31:39.996]  - Number of value chunks collected: 1
[10:31:39.997] Resolving 1 futures (chunks) ... DONE
[10:31:39.997] Reducing values from 1 chunks ...
[10:31:39.997]  - Number of values collected after concatenation: 2
[10:31:39.997]  - Number of values expected: 2
[10:31:39.997] Reducing values from 1 chunks ... DONE
[10:31:39.997] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:31:39.997] future_lapply() ...
[10:31:40.002] Number of chunks: 1
[10:31:40.002] getGlobalsAndPackagesXApply() ...
[10:31:40.002]  - future.globals: TRUE
[10:31:40.002] getGlobalsAndPackages() ...
[10:31:40.002] Searching for globals...
[10:31:40.003] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:40.004] Searching for globals ... DONE
[10:31:40.004] Resolving globals: FALSE
[10:31:40.004] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:40.004] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:40.005] - globals: [1] ‘FUN’
[10:31:40.005] 
[10:31:40.005] getGlobalsAndPackages() ... DONE
[10:31:40.005]  - globals found/used: [n=1] ‘FUN’
[10:31:40.005]  - needed namespaces: [n=0] 
[10:31:40.005] Finding globals ... DONE
[10:31:40.005]  - use_args: TRUE
[10:31:40.005]  - Getting '...' globals ...
[10:31:40.006] resolve() on list ...
[10:31:40.006]  recursive: 0
[10:31:40.006]  length: 1
[10:31:40.006]  elements: ‘...’
[10:31:40.006]  length: 0 (resolved future 1)
[10:31:40.006] resolve() on list ... DONE
[10:31:40.006]    - '...' content: [n=0] 
[10:31:40.006] List of 1
[10:31:40.006]  $ ...: list()
[10:31:40.006]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:40.006]  - attr(*, "where")=List of 1
[10:31:40.006]   ..$ ...:<environment: 0x564ff2b5eb98> 
[10:31:40.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:40.006]  - attr(*, "resolved")= logi TRUE
[10:31:40.006]  - attr(*, "total_size")= num NA
[10:31:40.009]  - Getting '...' globals ... DONE
[10:31:40.009] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:40.009] List of 2
[10:31:40.009]  $ ...future.FUN:function (x)  
[10:31:40.009]  $ ...          : list()
[10:31:40.009]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:40.009]  - attr(*, "where")=List of 2
[10:31:40.009]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:40.009]   ..$ ...          :<environment: 0x564ff2b5eb98> 
[10:31:40.009]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:40.009]  - attr(*, "resolved")= logi FALSE
[10:31:40.009]  - attr(*, "total_size")= num 4720
[10:31:40.012] Packages to be attached in all futures: [n=0] 
[10:31:40.012] getGlobalsAndPackagesXApply() ... DONE
[10:31:40.012] Number of futures (= number of chunks): 1
[10:31:40.012] Launching 1 futures (chunks) ...
[10:31:40.012] Chunk #1 of 1 ...
[10:31:40.012]  - Finding globals in 'X' for chunk #1 ...
[10:31:40.013] getGlobalsAndPackages() ...
[10:31:40.013] Searching for globals...
[10:31:40.013] 
[10:31:40.013] Searching for globals ... DONE
[10:31:40.013] - globals: [0] <none>
[10:31:40.013] getGlobalsAndPackages() ... DONE
[10:31:40.013]    + additional globals found: [n=0] 
[10:31:40.013]    + additional namespaces needed: [n=0] 
[10:31:40.013]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:40.014]  - seeds: <none>
[10:31:40.014]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:40.015] getGlobalsAndPackages() ...
[10:31:40.016] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:40.016] Resolving globals: FALSE
[10:31:40.016] Tweak future expression to call with '...' arguments ...
[10:31:40.016] {
[10:31:40.016]     do.call(function(...) {
[10:31:40.016]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:40.016]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:40.016]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:40.016]             on.exit(options(oopts), add = TRUE)
[10:31:40.016]         }
[10:31:40.016]         {
[10:31:40.016]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:40.016]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:40.016]                 ...future.FUN(...future.X_jj, ...)
[10:31:40.016]             })
[10:31:40.016]         }
[10:31:40.016]     }, args = future.call.arguments)
[10:31:40.016] }
[10:31:40.016] Tweak future expression to call with '...' arguments ... DONE
[10:31:40.016] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:40.017] 
[10:31:40.017] getGlobalsAndPackages() ... DONE
[10:31:40.017] run() for ‘Future’ ...
[10:31:40.017] - state: ‘created’
[10:31:40.017] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:40.021] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:40.021] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:40.021]   - Field: ‘label’
[10:31:40.021]   - Field: ‘local’
[10:31:40.021]   - Field: ‘owner’
[10:31:40.021]   - Field: ‘envir’
[10:31:40.022]   - Field: ‘packages’
[10:31:40.022]   - Field: ‘gc’
[10:31:40.022]   - Field: ‘conditions’
[10:31:40.022]   - Field: ‘expr’
[10:31:40.022]   - Field: ‘uuid’
[10:31:40.022]   - Field: ‘seed’
[10:31:40.022]   - Field: ‘version’
[10:31:40.022]   - Field: ‘result’
[10:31:40.022]   - Field: ‘asynchronous’
[10:31:40.022]   - Field: ‘calls’
[10:31:40.022]   - Field: ‘globals’
[10:31:40.023]   - Field: ‘stdout’
[10:31:40.023]   - Field: ‘earlySignal’
[10:31:40.023]   - Field: ‘lazy’
[10:31:40.023]   - Field: ‘state’
[10:31:40.023] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:40.023] - Launch lazy future ...
[10:31:40.023] Packages needed by the future expression (n = 0): <none>
[10:31:40.023] Packages needed by future strategies (n = 0): <none>
[10:31:40.024] {
[10:31:40.024]     {
[10:31:40.024]         {
[10:31:40.024]             ...future.startTime <- base::Sys.time()
[10:31:40.024]             {
[10:31:40.024]                 {
[10:31:40.024]                   {
[10:31:40.024]                     base::local({
[10:31:40.024]                       has_future <- base::requireNamespace("future", 
[10:31:40.024]                         quietly = TRUE)
[10:31:40.024]                       if (has_future) {
[10:31:40.024]                         ns <- base::getNamespace("future")
[10:31:40.024]                         version <- ns[[".package"]][["version"]]
[10:31:40.024]                         if (is.null(version)) 
[10:31:40.024]                           version <- utils::packageVersion("future")
[10:31:40.024]                       }
[10:31:40.024]                       else {
[10:31:40.024]                         version <- NULL
[10:31:40.024]                       }
[10:31:40.024]                       if (!has_future || version < "1.8.0") {
[10:31:40.024]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:40.024]                           "", base::R.version$version.string), 
[10:31:40.024]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:40.024]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:40.024]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:40.024]                             "release", "version")], collapse = " "), 
[10:31:40.024]                           hostname = base::Sys.info()[["nodename"]])
[10:31:40.024]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:40.024]                           info)
[10:31:40.024]                         info <- base::paste(info, collapse = "; ")
[10:31:40.024]                         if (!has_future) {
[10:31:40.024]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:40.024]                             info)
[10:31:40.024]                         }
[10:31:40.024]                         else {
[10:31:40.024]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:40.024]                             info, version)
[10:31:40.024]                         }
[10:31:40.024]                         base::stop(msg)
[10:31:40.024]                       }
[10:31:40.024]                     })
[10:31:40.024]                   }
[10:31:40.024]                   ...future.strategy.old <- future::plan("list")
[10:31:40.024]                   options(future.plan = NULL)
[10:31:40.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:40.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:40.024]                 }
[10:31:40.024]                 ...future.workdir <- getwd()
[10:31:40.024]             }
[10:31:40.024]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:40.024]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:40.024]         }
[10:31:40.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:40.024]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:40.024]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:40.024]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:40.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:40.024]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:40.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:40.024]             base::names(...future.oldOptions))
[10:31:40.024]     }
[10:31:40.024]     if (FALSE) {
[10:31:40.024]     }
[10:31:40.024]     else {
[10:31:40.024]         if (TRUE) {
[10:31:40.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:40.024]                 open = "w")
[10:31:40.024]         }
[10:31:40.024]         else {
[10:31:40.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:40.024]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:40.024]         }
[10:31:40.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:40.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:40.024]             base::sink(type = "output", split = FALSE)
[10:31:40.024]             base::close(...future.stdout)
[10:31:40.024]         }, add = TRUE)
[10:31:40.024]     }
[10:31:40.024]     ...future.frame <- base::sys.nframe()
[10:31:40.024]     ...future.conditions <- base::list()
[10:31:40.024]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:40.024]     if (FALSE) {
[10:31:40.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:40.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:40.024]     }
[10:31:40.024]     ...future.result <- base::tryCatch({
[10:31:40.024]         base::withCallingHandlers({
[10:31:40.024]             ...future.value <- base::withVisible(base::local({
[10:31:40.024]                 do.call(function(...) {
[10:31:40.024]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:40.024]                   if (!identical(...future.globals.maxSize.org, 
[10:31:40.024]                     ...future.globals.maxSize)) {
[10:31:40.024]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:40.024]                     on.exit(options(oopts), add = TRUE)
[10:31:40.024]                   }
[10:31:40.024]                   {
[10:31:40.024]                     lapply(seq_along(...future.elements_ii), 
[10:31:40.024]                       FUN = function(jj) {
[10:31:40.024]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:40.024]                         ...future.FUN(...future.X_jj, ...)
[10:31:40.024]                       })
[10:31:40.024]                   }
[10:31:40.024]                 }, args = future.call.arguments)
[10:31:40.024]             }))
[10:31:40.024]             future::FutureResult(value = ...future.value$value, 
[10:31:40.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:40.024]                   ...future.rng), globalenv = if (FALSE) 
[10:31:40.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:40.024]                     ...future.globalenv.names))
[10:31:40.024]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:40.024]         }, condition = base::local({
[10:31:40.024]             c <- base::c
[10:31:40.024]             inherits <- base::inherits
[10:31:40.024]             invokeRestart <- base::invokeRestart
[10:31:40.024]             length <- base::length
[10:31:40.024]             list <- base::list
[10:31:40.024]             seq.int <- base::seq.int
[10:31:40.024]             signalCondition <- base::signalCondition
[10:31:40.024]             sys.calls <- base::sys.calls
[10:31:40.024]             `[[` <- base::`[[`
[10:31:40.024]             `+` <- base::`+`
[10:31:40.024]             `<<-` <- base::`<<-`
[10:31:40.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:40.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:40.024]                   3L)]
[10:31:40.024]             }
[10:31:40.024]             function(cond) {
[10:31:40.024]                 is_error <- inherits(cond, "error")
[10:31:40.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:40.024]                   NULL)
[10:31:40.024]                 if (is_error) {
[10:31:40.024]                   sessionInformation <- function() {
[10:31:40.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:40.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:40.024]                       search = base::search(), system = base::Sys.info())
[10:31:40.024]                   }
[10:31:40.024]                   ...future.conditions[[length(...future.conditions) + 
[10:31:40.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:40.024]                     cond$call), session = sessionInformation(), 
[10:31:40.024]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:40.024]                   signalCondition(cond)
[10:31:40.024]                 }
[10:31:40.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:40.024]                 "immediateCondition"))) {
[10:31:40.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:40.024]                   ...future.conditions[[length(...future.conditions) + 
[10:31:40.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:40.024]                   if (TRUE && !signal) {
[10:31:40.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:40.024]                     {
[10:31:40.024]                       inherits <- base::inherits
[10:31:40.024]                       invokeRestart <- base::invokeRestart
[10:31:40.024]                       is.null <- base::is.null
[10:31:40.024]                       muffled <- FALSE
[10:31:40.024]                       if (inherits(cond, "message")) {
[10:31:40.024]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:40.024]                         if (muffled) 
[10:31:40.024]                           invokeRestart("muffleMessage")
[10:31:40.024]                       }
[10:31:40.024]                       else if (inherits(cond, "warning")) {
[10:31:40.024]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:40.024]                         if (muffled) 
[10:31:40.024]                           invokeRestart("muffleWarning")
[10:31:40.024]                       }
[10:31:40.024]                       else if (inherits(cond, "condition")) {
[10:31:40.024]                         if (!is.null(pattern)) {
[10:31:40.024]                           computeRestarts <- base::computeRestarts
[10:31:40.024]                           grepl <- base::grepl
[10:31:40.024]                           restarts <- computeRestarts(cond)
[10:31:40.024]                           for (restart in restarts) {
[10:31:40.024]                             name <- restart$name
[10:31:40.024]                             if (is.null(name)) 
[10:31:40.024]                               next
[10:31:40.024]                             if (!grepl(pattern, name)) 
[10:31:40.024]                               next
[10:31:40.024]                             invokeRestart(restart)
[10:31:40.024]                             muffled <- TRUE
[10:31:40.024]                             break
[10:31:40.024]                           }
[10:31:40.024]                         }
[10:31:40.024]                       }
[10:31:40.024]                       invisible(muffled)
[10:31:40.024]                     }
[10:31:40.024]                     muffleCondition(cond, pattern = "^muffle")
[10:31:40.024]                   }
[10:31:40.024]                 }
[10:31:40.024]                 else {
[10:31:40.024]                   if (TRUE) {
[10:31:40.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:40.024]                     {
[10:31:40.024]                       inherits <- base::inherits
[10:31:40.024]                       invokeRestart <- base::invokeRestart
[10:31:40.024]                       is.null <- base::is.null
[10:31:40.024]                       muffled <- FALSE
[10:31:40.024]                       if (inherits(cond, "message")) {
[10:31:40.024]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:40.024]                         if (muffled) 
[10:31:40.024]                           invokeRestart("muffleMessage")
[10:31:40.024]                       }
[10:31:40.024]                       else if (inherits(cond, "warning")) {
[10:31:40.024]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:40.024]                         if (muffled) 
[10:31:40.024]                           invokeRestart("muffleWarning")
[10:31:40.024]                       }
[10:31:40.024]                       else if (inherits(cond, "condition")) {
[10:31:40.024]                         if (!is.null(pattern)) {
[10:31:40.024]                           computeRestarts <- base::computeRestarts
[10:31:40.024]                           grepl <- base::grepl
[10:31:40.024]                           restarts <- computeRestarts(cond)
[10:31:40.024]                           for (restart in restarts) {
[10:31:40.024]                             name <- restart$name
[10:31:40.024]                             if (is.null(name)) 
[10:31:40.024]                               next
[10:31:40.024]                             if (!grepl(pattern, name)) 
[10:31:40.024]                               next
[10:31:40.024]                             invokeRestart(restart)
[10:31:40.024]                             muffled <- TRUE
[10:31:40.024]                             break
[10:31:40.024]                           }
[10:31:40.024]                         }
[10:31:40.024]                       }
[10:31:40.024]                       invisible(muffled)
[10:31:40.024]                     }
[10:31:40.024]                     muffleCondition(cond, pattern = "^muffle")
[10:31:40.024]                   }
[10:31:40.024]                 }
[10:31:40.024]             }
[10:31:40.024]         }))
[10:31:40.024]     }, error = function(ex) {
[10:31:40.024]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:40.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:40.024]                 ...future.rng), started = ...future.startTime, 
[10:31:40.024]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:40.024]             version = "1.8"), class = "FutureResult")
[10:31:40.024]     }, finally = {
[10:31:40.024]         if (!identical(...future.workdir, getwd())) 
[10:31:40.024]             setwd(...future.workdir)
[10:31:40.024]         {
[10:31:40.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:40.024]                 ...future.oldOptions$nwarnings <- NULL
[10:31:40.024]             }
[10:31:40.024]             base::options(...future.oldOptions)
[10:31:40.024]             if (.Platform$OS.type == "windows") {
[10:31:40.024]                 old_names <- names(...future.oldEnvVars)
[10:31:40.024]                 envs <- base::Sys.getenv()
[10:31:40.024]                 names <- names(envs)
[10:31:40.024]                 common <- intersect(names, old_names)
[10:31:40.024]                 added <- setdiff(names, old_names)
[10:31:40.024]                 removed <- setdiff(old_names, names)
[10:31:40.024]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:40.024]                   envs[common]]
[10:31:40.024]                 NAMES <- toupper(changed)
[10:31:40.024]                 args <- list()
[10:31:40.024]                 for (kk in seq_along(NAMES)) {
[10:31:40.024]                   name <- changed[[kk]]
[10:31:40.024]                   NAME <- NAMES[[kk]]
[10:31:40.024]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:40.024]                     next
[10:31:40.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:40.024]                 }
[10:31:40.024]                 NAMES <- toupper(added)
[10:31:40.024]                 for (kk in seq_along(NAMES)) {
[10:31:40.024]                   name <- added[[kk]]
[10:31:40.024]                   NAME <- NAMES[[kk]]
[10:31:40.024]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:40.024]                     next
[10:31:40.024]                   args[[name]] <- ""
[10:31:40.024]                 }
[10:31:40.024]                 NAMES <- toupper(removed)
[10:31:40.024]                 for (kk in seq_along(NAMES)) {
[10:31:40.024]                   name <- removed[[kk]]
[10:31:40.024]                   NAME <- NAMES[[kk]]
[10:31:40.024]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:40.024]                     next
[10:31:40.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:40.024]                 }
[10:31:40.024]                 if (length(args) > 0) 
[10:31:40.024]                   base::do.call(base::Sys.setenv, args = args)
[10:31:40.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:40.024]             }
[10:31:40.024]             else {
[10:31:40.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:40.024]             }
[10:31:40.024]             {
[10:31:40.024]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:40.024]                   0L) {
[10:31:40.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:40.024]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:40.024]                   base::options(opts)
[10:31:40.024]                 }
[10:31:40.024]                 {
[10:31:40.024]                   {
[10:31:40.024]                     NULL
[10:31:40.024]                     RNGkind("Mersenne-Twister")
[10:31:40.024]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:40.024]                       inherits = FALSE)
[10:31:40.024]                   }
[10:31:40.024]                   options(future.plan = NULL)
[10:31:40.024]                   if (is.na(NA_character_)) 
[10:31:40.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:40.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:40.024]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:40.024]                     .init = FALSE)
[10:31:40.024]                 }
[10:31:40.024]             }
[10:31:40.024]         }
[10:31:40.024]     })
[10:31:40.024]     if (TRUE) {
[10:31:40.024]         base::sink(type = "output", split = FALSE)
[10:31:40.024]         if (TRUE) {
[10:31:40.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:40.024]         }
[10:31:40.024]         else {
[10:31:40.024]             ...future.result["stdout"] <- base::list(NULL)
[10:31:40.024]         }
[10:31:40.024]         base::close(...future.stdout)
[10:31:40.024]         ...future.stdout <- NULL
[10:31:40.024]     }
[10:31:40.024]     ...future.result$conditions <- ...future.conditions
[10:31:40.024]     ...future.result$finished <- base::Sys.time()
[10:31:40.024]     ...future.result
[10:31:40.024] }
[10:31:40.025] assign_globals() ...
[10:31:40.026] List of 5
[10:31:40.026]  $ ...future.FUN            :function (x)  
[10:31:40.026]  $ future.call.arguments    : list()
[10:31:40.026]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:40.026]  $ ...future.elements_ii    :List of 2
[10:31:40.026]   ..$ : int 1
[10:31:40.026]   ..$ : int 0
[10:31:40.026]  $ ...future.seeds_ii       : NULL
[10:31:40.026]  $ ...future.globals.maxSize: NULL
[10:31:40.026]  - attr(*, "where")=List of 5
[10:31:40.026]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:40.026]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:40.026]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:40.026]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:40.026]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:40.026]  - attr(*, "resolved")= logi FALSE
[10:31:40.026]  - attr(*, "total_size")= num 4720
[10:31:40.026]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:40.026]  - attr(*, "already-done")= logi TRUE
[10:31:40.030] - reassign environment for ‘...future.FUN’
[10:31:40.030] - copied ‘...future.FUN’ to environment
[10:31:40.031] - copied ‘future.call.arguments’ to environment
[10:31:40.031] - copied ‘...future.elements_ii’ to environment
[10:31:40.031] - copied ‘...future.seeds_ii’ to environment
[10:31:40.031] - copied ‘...future.globals.maxSize’ to environment
[10:31:40.031] assign_globals() ... done
[10:31:40.031] plan(): Setting new future strategy stack:
[10:31:40.031] List of future strategies:
[10:31:40.031] 1. sequential:
[10:31:40.031]    - args: function (..., envir = parent.frame())
[10:31:40.031]    - tweaked: FALSE
[10:31:40.031]    - call: NULL
[10:31:40.032] plan(): nbrOfWorkers() = 1
[10:31:40.533] plan(): Setting new future strategy stack:
[10:31:40.533] List of future strategies:
[10:31:40.533] 1. multicore:
[10:31:40.533]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:40.533]    - tweaked: FALSE
[10:31:40.533]    - call: plan(strategy)
[10:31:40.538] plan(): nbrOfWorkers() = 1
[10:31:40.538] SequentialFuture started (and completed)
[10:31:40.538] - Launch lazy future ... done
[10:31:40.538] run() for ‘SequentialFuture’ ... done
[10:31:40.538] Created future:
[10:31:40.538] SequentialFuture:
[10:31:40.538] Label: ‘future_lapply-1’
[10:31:40.538] Expression:
[10:31:40.538] {
[10:31:40.538]     do.call(function(...) {
[10:31:40.538]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:40.538]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:40.538]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:40.538]             on.exit(options(oopts), add = TRUE)
[10:31:40.538]         }
[10:31:40.538]         {
[10:31:40.538]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:40.538]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:40.538]                 ...future.FUN(...future.X_jj, ...)
[10:31:40.538]             })
[10:31:40.538]         }
[10:31:40.538]     }, args = future.call.arguments)
[10:31:40.538] }
[10:31:40.538] Lazy evaluation: FALSE
[10:31:40.538] Asynchronous evaluation: FALSE
[10:31:40.538] Local evaluation: TRUE
[10:31:40.538] Environment: R_GlobalEnv
[10:31:40.538] Capture standard output: TRUE
[10:31:40.538] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:40.538] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:40.538] Packages: <none>
[10:31:40.538] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:40.538] Resolved: TRUE
[10:31:40.538] Value: 112 bytes of class ‘list’
[10:31:40.538] Early signaling: FALSE
[10:31:40.538] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:40.538] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:40.539] Chunk #1 of 1 ... DONE
[10:31:40.539] Launching 1 futures (chunks) ... DONE
[10:31:40.540] Resolving 1 futures (chunks) ...
[10:31:40.540] resolve() on list ...
[10:31:40.540]  recursive: 0
[10:31:40.540]  length: 1
[10:31:40.540] 
[10:31:40.540] resolved() for ‘SequentialFuture’ ...
[10:31:40.540] - state: ‘finished’
[10:31:40.540] - run: TRUE
[10:31:40.540] - result: ‘FutureResult’
[10:31:40.540] resolved() for ‘SequentialFuture’ ... done
[10:31:40.541] Future #1
[10:31:40.541] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:40.541] - nx: 1
[10:31:40.541] - relay: TRUE
[10:31:40.541] - stdout: TRUE
[10:31:40.541] - signal: TRUE
[10:31:40.541] - resignal: FALSE
[10:31:40.541] - force: TRUE
[10:31:40.541] - relayed: [n=1] FALSE
[10:31:40.541] - queued futures: [n=1] FALSE
[10:31:40.542]  - until=1
[10:31:40.542]  - relaying element #1
[10:31:40.542] - relayed: [n=1] TRUE
[10:31:40.542] - queued futures: [n=1] TRUE
[10:31:40.542] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:40.542]  length: 0 (resolved future 1)
[10:31:40.542] Relaying remaining futures
[10:31:40.542] signalConditionsASAP(NULL, pos=0) ...
[10:31:40.542] - nx: 1
[10:31:40.542] - relay: TRUE
[10:31:40.543] - stdout: TRUE
[10:31:40.543] - signal: TRUE
[10:31:40.543] - resignal: FALSE
[10:31:40.543] - force: TRUE
[10:31:40.543] - relayed: [n=1] TRUE
[10:31:40.543] - queued futures: [n=1] TRUE
 - flush all
[10:31:40.543] - relayed: [n=1] TRUE
[10:31:40.543] - queued futures: [n=1] TRUE
[10:31:40.543] signalConditionsASAP(NULL, pos=0) ... done
[10:31:40.543] resolve() on list ... DONE
[10:31:40.544]  - Number of value chunks collected: 1
[10:31:40.544] Resolving 1 futures (chunks) ... DONE
[10:31:40.544] Reducing values from 1 chunks ...
[10:31:40.544]  - Number of values collected after concatenation: 2
[10:31:40.544]  - Number of values expected: 2
[10:31:40.544] Reducing values from 1 chunks ... DONE
[10:31:40.544] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:31:40.544] future_lapply() ...
[10:31:40.550] Number of chunks: 1
[10:31:40.550] getGlobalsAndPackagesXApply() ...
[10:31:40.550]  - future.globals: TRUE
[10:31:40.550] getGlobalsAndPackages() ...
[10:31:40.551] Searching for globals...
[10:31:40.552] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:40.552] Searching for globals ... DONE
[10:31:40.552] Resolving globals: FALSE
[10:31:40.553] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:40.553] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:40.553] - globals: [1] ‘FUN’
[10:31:40.553] 
[10:31:40.553] getGlobalsAndPackages() ... DONE
[10:31:40.553]  - globals found/used: [n=1] ‘FUN’
[10:31:40.553]  - needed namespaces: [n=0] 
[10:31:40.554] Finding globals ... DONE
[10:31:40.554]  - use_args: TRUE
[10:31:40.554]  - Getting '...' globals ...
[10:31:40.554] resolve() on list ...
[10:31:40.554]  recursive: 0
[10:31:40.554]  length: 1
[10:31:40.554]  elements: ‘...’
[10:31:40.554]  length: 0 (resolved future 1)
[10:31:40.555] resolve() on list ... DONE
[10:31:40.555]    - '...' content: [n=0] 
[10:31:40.555] List of 1
[10:31:40.555]  $ ...: list()
[10:31:40.555]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:40.555]  - attr(*, "where")=List of 1
[10:31:40.555]   ..$ ...:<environment: 0x564ff4395ef8> 
[10:31:40.555]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:40.555]  - attr(*, "resolved")= logi TRUE
[10:31:40.555]  - attr(*, "total_size")= num NA
[10:31:40.557]  - Getting '...' globals ... DONE
[10:31:40.558] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:40.558] List of 2
[10:31:40.558]  $ ...future.FUN:function (x)  
[10:31:40.558]  $ ...          : list()
[10:31:40.558]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:40.558]  - attr(*, "where")=List of 2
[10:31:40.558]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:40.558]   ..$ ...          :<environment: 0x564ff4395ef8> 
[10:31:40.558]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:40.558]  - attr(*, "resolved")= logi FALSE
[10:31:40.558]  - attr(*, "total_size")= num 4720
[10:31:40.560] Packages to be attached in all futures: [n=0] 
[10:31:40.560] getGlobalsAndPackagesXApply() ... DONE
[10:31:40.561] Number of futures (= number of chunks): 1
[10:31:40.561] Launching 1 futures (chunks) ...
[10:31:40.561] Chunk #1 of 1 ...
[10:31:40.561]  - Finding globals in 'X' for chunk #1 ...
[10:31:40.561] getGlobalsAndPackages() ...
[10:31:40.561] Searching for globals...
[10:31:40.561] 
[10:31:40.561] Searching for globals ... DONE
[10:31:40.562] - globals: [0] <none>
[10:31:40.562] getGlobalsAndPackages() ... DONE
[10:31:40.562]    + additional globals found: [n=0] 
[10:31:40.562]    + additional namespaces needed: [n=0] 
[10:31:40.562]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:40.562]  - seeds: <none>
[10:31:40.562]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:40.562] getGlobalsAndPackages() ...
[10:31:40.562] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:40.562] Resolving globals: FALSE
[10:31:40.563] Tweak future expression to call with '...' arguments ...
[10:31:40.563] {
[10:31:40.563]     do.call(function(...) {
[10:31:40.563]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:40.563]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:40.563]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:40.563]             on.exit(options(oopts), add = TRUE)
[10:31:40.563]         }
[10:31:40.563]         {
[10:31:40.563]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:40.563]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:40.563]                 ...future.FUN(...future.X_jj, ...)
[10:31:40.563]             })
[10:31:40.563]         }
[10:31:40.563]     }, args = future.call.arguments)
[10:31:40.563] }
[10:31:40.563] Tweak future expression to call with '...' arguments ... DONE
[10:31:40.563] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:40.563] 
[10:31:40.563] getGlobalsAndPackages() ... DONE
[10:31:40.564] run() for ‘Future’ ...
[10:31:40.564] - state: ‘created’
[10:31:40.564] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:40.568] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:40.568] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:40.568]   - Field: ‘label’
[10:31:40.568]   - Field: ‘local’
[10:31:40.568]   - Field: ‘owner’
[10:31:40.569]   - Field: ‘envir’
[10:31:40.569]   - Field: ‘packages’
[10:31:40.569]   - Field: ‘gc’
[10:31:40.569]   - Field: ‘conditions’
[10:31:40.569]   - Field: ‘expr’
[10:31:40.569]   - Field: ‘uuid’
[10:31:40.569]   - Field: ‘seed’
[10:31:40.569]   - Field: ‘version’
[10:31:40.570]   - Field: ‘result’
[10:31:40.570]   - Field: ‘asynchronous’
[10:31:40.570]   - Field: ‘calls’
[10:31:40.570]   - Field: ‘globals’
[10:31:40.570]   - Field: ‘stdout’
[10:31:40.570]   - Field: ‘earlySignal’
[10:31:40.570]   - Field: ‘lazy’
[10:31:40.570]   - Field: ‘state’
[10:31:40.570] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:40.571] - Launch lazy future ...
[10:31:40.571] Packages needed by the future expression (n = 0): <none>
[10:31:40.571] Packages needed by future strategies (n = 0): <none>
[10:31:40.571] {
[10:31:40.571]     {
[10:31:40.571]         {
[10:31:40.571]             ...future.startTime <- base::Sys.time()
[10:31:40.571]             {
[10:31:40.571]                 {
[10:31:40.571]                   {
[10:31:40.571]                     base::local({
[10:31:40.571]                       has_future <- base::requireNamespace("future", 
[10:31:40.571]                         quietly = TRUE)
[10:31:40.571]                       if (has_future) {
[10:31:40.571]                         ns <- base::getNamespace("future")
[10:31:40.571]                         version <- ns[[".package"]][["version"]]
[10:31:40.571]                         if (is.null(version)) 
[10:31:40.571]                           version <- utils::packageVersion("future")
[10:31:40.571]                       }
[10:31:40.571]                       else {
[10:31:40.571]                         version <- NULL
[10:31:40.571]                       }
[10:31:40.571]                       if (!has_future || version < "1.8.0") {
[10:31:40.571]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:40.571]                           "", base::R.version$version.string), 
[10:31:40.571]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:40.571]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:40.571]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:40.571]                             "release", "version")], collapse = " "), 
[10:31:40.571]                           hostname = base::Sys.info()[["nodename"]])
[10:31:40.571]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:40.571]                           info)
[10:31:40.571]                         info <- base::paste(info, collapse = "; ")
[10:31:40.571]                         if (!has_future) {
[10:31:40.571]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:40.571]                             info)
[10:31:40.571]                         }
[10:31:40.571]                         else {
[10:31:40.571]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:40.571]                             info, version)
[10:31:40.571]                         }
[10:31:40.571]                         base::stop(msg)
[10:31:40.571]                       }
[10:31:40.571]                     })
[10:31:40.571]                   }
[10:31:40.571]                   ...future.strategy.old <- future::plan("list")
[10:31:40.571]                   options(future.plan = NULL)
[10:31:40.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:40.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:40.571]                 }
[10:31:40.571]                 ...future.workdir <- getwd()
[10:31:40.571]             }
[10:31:40.571]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:40.571]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:40.571]         }
[10:31:40.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:40.571]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:40.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:40.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:40.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:40.571]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:40.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:40.571]             base::names(...future.oldOptions))
[10:31:40.571]     }
[10:31:40.571]     if (TRUE) {
[10:31:40.571]     }
[10:31:40.571]     else {
[10:31:40.571]         if (NA) {
[10:31:40.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:40.571]                 open = "w")
[10:31:40.571]         }
[10:31:40.571]         else {
[10:31:40.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:40.571]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:40.571]         }
[10:31:40.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:40.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:40.571]             base::sink(type = "output", split = FALSE)
[10:31:40.571]             base::close(...future.stdout)
[10:31:40.571]         }, add = TRUE)
[10:31:40.571]     }
[10:31:40.571]     ...future.frame <- base::sys.nframe()
[10:31:40.571]     ...future.conditions <- base::list()
[10:31:40.571]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:40.571]     if (FALSE) {
[10:31:40.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:40.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:40.571]     }
[10:31:40.571]     ...future.result <- base::tryCatch({
[10:31:40.571]         base::withCallingHandlers({
[10:31:40.571]             ...future.value <- base::withVisible(base::local({
[10:31:40.571]                 do.call(function(...) {
[10:31:40.571]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:40.571]                   if (!identical(...future.globals.maxSize.org, 
[10:31:40.571]                     ...future.globals.maxSize)) {
[10:31:40.571]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:40.571]                     on.exit(options(oopts), add = TRUE)
[10:31:40.571]                   }
[10:31:40.571]                   {
[10:31:40.571]                     lapply(seq_along(...future.elements_ii), 
[10:31:40.571]                       FUN = function(jj) {
[10:31:40.571]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:40.571]                         ...future.FUN(...future.X_jj, ...)
[10:31:40.571]                       })
[10:31:40.571]                   }
[10:31:40.571]                 }, args = future.call.arguments)
[10:31:40.571]             }))
[10:31:40.571]             future::FutureResult(value = ...future.value$value, 
[10:31:40.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:40.571]                   ...future.rng), globalenv = if (FALSE) 
[10:31:40.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:40.571]                     ...future.globalenv.names))
[10:31:40.571]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:40.571]         }, condition = base::local({
[10:31:40.571]             c <- base::c
[10:31:40.571]             inherits <- base::inherits
[10:31:40.571]             invokeRestart <- base::invokeRestart
[10:31:40.571]             length <- base::length
[10:31:40.571]             list <- base::list
[10:31:40.571]             seq.int <- base::seq.int
[10:31:40.571]             signalCondition <- base::signalCondition
[10:31:40.571]             sys.calls <- base::sys.calls
[10:31:40.571]             `[[` <- base::`[[`
[10:31:40.571]             `+` <- base::`+`
[10:31:40.571]             `<<-` <- base::`<<-`
[10:31:40.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:40.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:40.571]                   3L)]
[10:31:40.571]             }
[10:31:40.571]             function(cond) {
[10:31:40.571]                 is_error <- inherits(cond, "error")
[10:31:40.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:40.571]                   NULL)
[10:31:40.571]                 if (is_error) {
[10:31:40.571]                   sessionInformation <- function() {
[10:31:40.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:40.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:40.571]                       search = base::search(), system = base::Sys.info())
[10:31:40.571]                   }
[10:31:40.571]                   ...future.conditions[[length(...future.conditions) + 
[10:31:40.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:40.571]                     cond$call), session = sessionInformation(), 
[10:31:40.571]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:40.571]                   signalCondition(cond)
[10:31:40.571]                 }
[10:31:40.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:40.571]                 "immediateCondition"))) {
[10:31:40.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:40.571]                   ...future.conditions[[length(...future.conditions) + 
[10:31:40.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:40.571]                   if (TRUE && !signal) {
[10:31:40.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:40.571]                     {
[10:31:40.571]                       inherits <- base::inherits
[10:31:40.571]                       invokeRestart <- base::invokeRestart
[10:31:40.571]                       is.null <- base::is.null
[10:31:40.571]                       muffled <- FALSE
[10:31:40.571]                       if (inherits(cond, "message")) {
[10:31:40.571]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:40.571]                         if (muffled) 
[10:31:40.571]                           invokeRestart("muffleMessage")
[10:31:40.571]                       }
[10:31:40.571]                       else if (inherits(cond, "warning")) {
[10:31:40.571]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:40.571]                         if (muffled) 
[10:31:40.571]                           invokeRestart("muffleWarning")
[10:31:40.571]                       }
[10:31:40.571]                       else if (inherits(cond, "condition")) {
[10:31:40.571]                         if (!is.null(pattern)) {
[10:31:40.571]                           computeRestarts <- base::computeRestarts
[10:31:40.571]                           grepl <- base::grepl
[10:31:40.571]                           restarts <- computeRestarts(cond)
[10:31:40.571]                           for (restart in restarts) {
[10:31:40.571]                             name <- restart$name
[10:31:40.571]                             if (is.null(name)) 
[10:31:40.571]                               next
[10:31:40.571]                             if (!grepl(pattern, name)) 
[10:31:40.571]                               next
[10:31:40.571]                             invokeRestart(restart)
[10:31:40.571]                             muffled <- TRUE
[10:31:40.571]                             break
[10:31:40.571]                           }
[10:31:40.571]                         }
[10:31:40.571]                       }
[10:31:40.571]                       invisible(muffled)
[10:31:40.571]                     }
[10:31:40.571]                     muffleCondition(cond, pattern = "^muffle")
[10:31:40.571]                   }
[10:31:40.571]                 }
[10:31:40.571]                 else {
[10:31:40.571]                   if (TRUE) {
[10:31:40.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:40.571]                     {
[10:31:40.571]                       inherits <- base::inherits
[10:31:40.571]                       invokeRestart <- base::invokeRestart
[10:31:40.571]                       is.null <- base::is.null
[10:31:40.571]                       muffled <- FALSE
[10:31:40.571]                       if (inherits(cond, "message")) {
[10:31:40.571]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:40.571]                         if (muffled) 
[10:31:40.571]                           invokeRestart("muffleMessage")
[10:31:40.571]                       }
[10:31:40.571]                       else if (inherits(cond, "warning")) {
[10:31:40.571]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:40.571]                         if (muffled) 
[10:31:40.571]                           invokeRestart("muffleWarning")
[10:31:40.571]                       }
[10:31:40.571]                       else if (inherits(cond, "condition")) {
[10:31:40.571]                         if (!is.null(pattern)) {
[10:31:40.571]                           computeRestarts <- base::computeRestarts
[10:31:40.571]                           grepl <- base::grepl
[10:31:40.571]                           restarts <- computeRestarts(cond)
[10:31:40.571]                           for (restart in restarts) {
[10:31:40.571]                             name <- restart$name
[10:31:40.571]                             if (is.null(name)) 
[10:31:40.571]                               next
[10:31:40.571]                             if (!grepl(pattern, name)) 
[10:31:40.571]                               next
[10:31:40.571]                             invokeRestart(restart)
[10:31:40.571]                             muffled <- TRUE
[10:31:40.571]                             break
[10:31:40.571]                           }
[10:31:40.571]                         }
[10:31:40.571]                       }
[10:31:40.571]                       invisible(muffled)
[10:31:40.571]                     }
[10:31:40.571]                     muffleCondition(cond, pattern = "^muffle")
[10:31:40.571]                   }
[10:31:40.571]                 }
[10:31:40.571]             }
[10:31:40.571]         }))
[10:31:40.571]     }, error = function(ex) {
[10:31:40.571]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:40.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:40.571]                 ...future.rng), started = ...future.startTime, 
[10:31:40.571]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:40.571]             version = "1.8"), class = "FutureResult")
[10:31:40.571]     }, finally = {
[10:31:40.571]         if (!identical(...future.workdir, getwd())) 
[10:31:40.571]             setwd(...future.workdir)
[10:31:40.571]         {
[10:31:40.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:40.571]                 ...future.oldOptions$nwarnings <- NULL
[10:31:40.571]             }
[10:31:40.571]             base::options(...future.oldOptions)
[10:31:40.571]             if (.Platform$OS.type == "windows") {
[10:31:40.571]                 old_names <- names(...future.oldEnvVars)
[10:31:40.571]                 envs <- base::Sys.getenv()
[10:31:40.571]                 names <- names(envs)
[10:31:40.571]                 common <- intersect(names, old_names)
[10:31:40.571]                 added <- setdiff(names, old_names)
[10:31:40.571]                 removed <- setdiff(old_names, names)
[10:31:40.571]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:40.571]                   envs[common]]
[10:31:40.571]                 NAMES <- toupper(changed)
[10:31:40.571]                 args <- list()
[10:31:40.571]                 for (kk in seq_along(NAMES)) {
[10:31:40.571]                   name <- changed[[kk]]
[10:31:40.571]                   NAME <- NAMES[[kk]]
[10:31:40.571]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:40.571]                     next
[10:31:40.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:40.571]                 }
[10:31:40.571]                 NAMES <- toupper(added)
[10:31:40.571]                 for (kk in seq_along(NAMES)) {
[10:31:40.571]                   name <- added[[kk]]
[10:31:40.571]                   NAME <- NAMES[[kk]]
[10:31:40.571]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:40.571]                     next
[10:31:40.571]                   args[[name]] <- ""
[10:31:40.571]                 }
[10:31:40.571]                 NAMES <- toupper(removed)
[10:31:40.571]                 for (kk in seq_along(NAMES)) {
[10:31:40.571]                   name <- removed[[kk]]
[10:31:40.571]                   NAME <- NAMES[[kk]]
[10:31:40.571]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:40.571]                     next
[10:31:40.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:40.571]                 }
[10:31:40.571]                 if (length(args) > 0) 
[10:31:40.571]                   base::do.call(base::Sys.setenv, args = args)
[10:31:40.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:40.571]             }
[10:31:40.571]             else {
[10:31:40.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:40.571]             }
[10:31:40.571]             {
[10:31:40.571]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:40.571]                   0L) {
[10:31:40.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:40.571]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:40.571]                   base::options(opts)
[10:31:40.571]                 }
[10:31:40.571]                 {
[10:31:40.571]                   {
[10:31:40.571]                     NULL
[10:31:40.571]                     RNGkind("Mersenne-Twister")
[10:31:40.571]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:40.571]                       inherits = FALSE)
[10:31:40.571]                   }
[10:31:40.571]                   options(future.plan = NULL)
[10:31:40.571]                   if (is.na(NA_character_)) 
[10:31:40.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:40.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:40.571]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:40.571]                     .init = FALSE)
[10:31:40.571]                 }
[10:31:40.571]             }
[10:31:40.571]         }
[10:31:40.571]     })
[10:31:40.571]     if (FALSE) {
[10:31:40.571]         base::sink(type = "output", split = FALSE)
[10:31:40.571]         if (NA) {
[10:31:40.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:40.571]         }
[10:31:40.571]         else {
[10:31:40.571]             ...future.result["stdout"] <- base::list(NULL)
[10:31:40.571]         }
[10:31:40.571]         base::close(...future.stdout)
[10:31:40.571]         ...future.stdout <- NULL
[10:31:40.571]     }
[10:31:40.571]     ...future.result$conditions <- ...future.conditions
[10:31:40.571]     ...future.result$finished <- base::Sys.time()
[10:31:40.571]     ...future.result
[10:31:40.571] }
[10:31:40.573] assign_globals() ...
[10:31:40.573] List of 5
[10:31:40.573]  $ ...future.FUN            :function (x)  
[10:31:40.573]  $ future.call.arguments    : list()
[10:31:40.573]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:40.573]  $ ...future.elements_ii    :List of 2
[10:31:40.573]   ..$ : int 1
[10:31:40.573]   ..$ : int 0
[10:31:40.573]  $ ...future.seeds_ii       : NULL
[10:31:40.573]  $ ...future.globals.maxSize: NULL
[10:31:40.573]  - attr(*, "where")=List of 5
[10:31:40.573]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:40.573]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:40.573]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:40.573]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:40.573]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:40.573]  - attr(*, "resolved")= logi FALSE
[10:31:40.573]  - attr(*, "total_size")= num 4720
[10:31:40.573]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:40.573]  - attr(*, "already-done")= logi TRUE
[10:31:40.580] - reassign environment for ‘...future.FUN’
[10:31:40.580] - copied ‘...future.FUN’ to environment
[10:31:40.580] - copied ‘future.call.arguments’ to environment
[10:31:40.580] - copied ‘...future.elements_ii’ to environment
[10:31:40.580] - copied ‘...future.seeds_ii’ to environment
[10:31:40.581] - copied ‘...future.globals.maxSize’ to environment
[10:31:40.581] assign_globals() ... done
[10:31:40.581] plan(): Setting new future strategy stack:
[10:31:40.581] List of future strategies:
[10:31:40.581] 1. sequential:
[10:31:40.581]    - args: function (..., envir = parent.frame())
[10:31:40.581]    - tweaked: FALSE
[10:31:40.581]    - call: NULL
[10:31:40.581] plan(): nbrOfWorkers() = 1
[10:31:41.083] plan(): Setting new future strategy stack:
[10:31:41.083] List of future strategies:
[10:31:41.083] 1. multicore:
[10:31:41.083]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:41.083]    - tweaked: FALSE
[10:31:41.083]    - call: plan(strategy)
[10:31:41.087] plan(): nbrOfWorkers() = 1
[10:31:41.088] SequentialFuture started (and completed)
[10:31:41.088] - Launch lazy future ... done
[10:31:41.088] run() for ‘SequentialFuture’ ... done
[10:31:41.088] Created future:
[10:31:41.088] SequentialFuture:
[10:31:41.088] Label: ‘future_lapply-1’
[10:31:41.088] Expression:
[10:31:41.088] {
[10:31:41.088]     do.call(function(...) {
[10:31:41.088]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:41.088]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:41.088]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:41.088]             on.exit(options(oopts), add = TRUE)
[10:31:41.088]         }
[10:31:41.088]         {
[10:31:41.088]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:41.088]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:41.088]                 ...future.FUN(...future.X_jj, ...)
[10:31:41.088]             })
[10:31:41.088]         }
[10:31:41.088]     }, args = future.call.arguments)
[10:31:41.088] }
[10:31:41.088] Lazy evaluation: FALSE
[10:31:41.088] Asynchronous evaluation: FALSE
[10:31:41.088] Local evaluation: TRUE
[10:31:41.088] Environment: R_GlobalEnv
[10:31:41.088] Capture standard output: NA
[10:31:41.088] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:41.088] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:41.088] Packages: <none>
[10:31:41.088] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:41.088] Resolved: TRUE
[10:31:41.088] Value: 112 bytes of class ‘list’
[10:31:41.088] Early signaling: FALSE
[10:31:41.088] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:41.088] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:41.089] Chunk #1 of 1 ... DONE
[10:31:41.089] Launching 1 futures (chunks) ... DONE
[10:31:41.089] Resolving 1 futures (chunks) ...
[10:31:41.089] resolve() on list ...
[10:31:41.090]  recursive: 0
[10:31:41.090]  length: 1
[10:31:41.090] 
[10:31:41.090] resolved() for ‘SequentialFuture’ ...
[10:31:41.090] - state: ‘finished’
[10:31:41.090] - run: TRUE
[10:31:41.090] - result: ‘FutureResult’
[10:31:41.090] resolved() for ‘SequentialFuture’ ... done
[10:31:41.090] Future #1
[10:31:41.090] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:41.091] - nx: 1
[10:31:41.091] - relay: TRUE
[10:31:41.091] - stdout: TRUE
[10:31:41.091] - signal: TRUE
[10:31:41.091] - resignal: FALSE
[10:31:41.091] - force: TRUE
[10:31:41.091] - relayed: [n=1] FALSE
[10:31:41.091] - queued futures: [n=1] FALSE
[10:31:41.091]  - until=1
[10:31:41.091]  - relaying element #1
[10:31:41.091] - relayed: [n=1] TRUE
[10:31:41.092] - queued futures: [n=1] TRUE
[10:31:41.092] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:41.092]  length: 0 (resolved future 1)
[10:31:41.092] Relaying remaining futures
[10:31:41.092] signalConditionsASAP(NULL, pos=0) ...
[10:31:41.092] - nx: 1
[10:31:41.092] - relay: TRUE
[10:31:41.092] - stdout: TRUE
[10:31:41.092] - signal: TRUE
[10:31:41.092] - resignal: FALSE
[10:31:41.092] - force: TRUE
[10:31:41.093] - relayed: [n=1] TRUE
[10:31:41.093] - queued futures: [n=1] TRUE
 - flush all
[10:31:41.093] - relayed: [n=1] TRUE
[10:31:41.093] - queued futures: [n=1] TRUE
[10:31:41.093] signalConditionsASAP(NULL, pos=0) ... done
[10:31:41.093] resolve() on list ... DONE
[10:31:41.093]  - Number of value chunks collected: 1
[10:31:41.093] Resolving 1 futures (chunks) ... DONE
[10:31:41.093] Reducing values from 1 chunks ...
[10:31:41.094]  - Number of values collected after concatenation: 2
[10:31:41.094]  - Number of values expected: 2
[10:31:41.094] Reducing values from 1 chunks ... DONE
[10:31:41.094] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:31:41.094] future_mapply() ...
[10:31:41.098] Number of chunks: 1
[10:31:41.098] getGlobalsAndPackagesXApply() ...
[10:31:41.098]  - future.globals: TRUE
[10:31:41.098] getGlobalsAndPackages() ...
[10:31:41.098] Searching for globals...
[10:31:41.099] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:41.100] Searching for globals ... DONE
[10:31:41.100] Resolving globals: FALSE
[10:31:41.100] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:41.101] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:41.101] - globals: [1] ‘FUN’
[10:31:41.101] 
[10:31:41.101] getGlobalsAndPackages() ... DONE
[10:31:41.101]  - globals found/used: [n=1] ‘FUN’
[10:31:41.101]  - needed namespaces: [n=0] 
[10:31:41.101] Finding globals ... DONE
[10:31:41.101] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:41.102] List of 2
[10:31:41.102]  $ ...future.FUN:function (x, y)  
[10:31:41.102]  $ MoreArgs     : NULL
[10:31:41.102]  - attr(*, "where")=List of 2
[10:31:41.102]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:41.102]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:41.102]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:41.102]  - attr(*, "resolved")= logi FALSE
[10:31:41.102]  - attr(*, "total_size")= num NA
[10:31:41.104] Packages to be attached in all futures: [n=0] 
[10:31:41.104] getGlobalsAndPackagesXApply() ... DONE
[10:31:41.104] Number of futures (= number of chunks): 1
[10:31:41.104] Launching 1 futures (chunks) ...
[10:31:41.105] Chunk #1 of 1 ...
[10:31:41.105]  - Finding globals in '...' for chunk #1 ...
[10:31:41.105] getGlobalsAndPackages() ...
[10:31:41.105] Searching for globals...
[10:31:41.105] 
[10:31:41.105] Searching for globals ... DONE
[10:31:41.105] - globals: [0] <none>
[10:31:41.105] getGlobalsAndPackages() ... DONE
[10:31:41.106]    + additional globals found: [n=0] 
[10:31:41.106]    + additional namespaces needed: [n=0] 
[10:31:41.108]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:41.108]  - seeds: <none>
[10:31:41.108]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:41.108] getGlobalsAndPackages() ...
[10:31:41.108] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:41.108] Resolving globals: FALSE
[10:31:41.109] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:31:41.109] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:41.109] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:41.110] 
[10:31:41.110] getGlobalsAndPackages() ... DONE
[10:31:41.110] run() for ‘Future’ ...
[10:31:41.110] - state: ‘created’
[10:31:41.110] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:41.114] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:41.114] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:41.114]   - Field: ‘label’
[10:31:41.114]   - Field: ‘local’
[10:31:41.114]   - Field: ‘owner’
[10:31:41.114]   - Field: ‘envir’
[10:31:41.115]   - Field: ‘packages’
[10:31:41.115]   - Field: ‘gc’
[10:31:41.115]   - Field: ‘conditions’
[10:31:41.115]   - Field: ‘expr’
[10:31:41.115]   - Field: ‘uuid’
[10:31:41.115]   - Field: ‘seed’
[10:31:41.115]   - Field: ‘version’
[10:31:41.115]   - Field: ‘result’
[10:31:41.115]   - Field: ‘asynchronous’
[10:31:41.115]   - Field: ‘calls’
[10:31:41.116]   - Field: ‘globals’
[10:31:41.116]   - Field: ‘stdout’
[10:31:41.116]   - Field: ‘earlySignal’
[10:31:41.116]   - Field: ‘lazy’
[10:31:41.116]   - Field: ‘state’
[10:31:41.116] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:41.116] - Launch lazy future ...
[10:31:41.116] Packages needed by the future expression (n = 0): <none>
[10:31:41.116] Packages needed by future strategies (n = 0): <none>
[10:31:41.117] {
[10:31:41.117]     {
[10:31:41.117]         {
[10:31:41.117]             ...future.startTime <- base::Sys.time()
[10:31:41.117]             {
[10:31:41.117]                 {
[10:31:41.117]                   {
[10:31:41.117]                     base::local({
[10:31:41.117]                       has_future <- base::requireNamespace("future", 
[10:31:41.117]                         quietly = TRUE)
[10:31:41.117]                       if (has_future) {
[10:31:41.117]                         ns <- base::getNamespace("future")
[10:31:41.117]                         version <- ns[[".package"]][["version"]]
[10:31:41.117]                         if (is.null(version)) 
[10:31:41.117]                           version <- utils::packageVersion("future")
[10:31:41.117]                       }
[10:31:41.117]                       else {
[10:31:41.117]                         version <- NULL
[10:31:41.117]                       }
[10:31:41.117]                       if (!has_future || version < "1.8.0") {
[10:31:41.117]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:41.117]                           "", base::R.version$version.string), 
[10:31:41.117]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:41.117]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:41.117]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:41.117]                             "release", "version")], collapse = " "), 
[10:31:41.117]                           hostname = base::Sys.info()[["nodename"]])
[10:31:41.117]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:41.117]                           info)
[10:31:41.117]                         info <- base::paste(info, collapse = "; ")
[10:31:41.117]                         if (!has_future) {
[10:31:41.117]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:41.117]                             info)
[10:31:41.117]                         }
[10:31:41.117]                         else {
[10:31:41.117]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:41.117]                             info, version)
[10:31:41.117]                         }
[10:31:41.117]                         base::stop(msg)
[10:31:41.117]                       }
[10:31:41.117]                     })
[10:31:41.117]                   }
[10:31:41.117]                   ...future.strategy.old <- future::plan("list")
[10:31:41.117]                   options(future.plan = NULL)
[10:31:41.117]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:41.117]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:41.117]                 }
[10:31:41.117]                 ...future.workdir <- getwd()
[10:31:41.117]             }
[10:31:41.117]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:41.117]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:41.117]         }
[10:31:41.117]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:41.117]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:41.117]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:41.117]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:41.117]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:41.117]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:41.117]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:41.117]             base::names(...future.oldOptions))
[10:31:41.117]     }
[10:31:41.117]     if (FALSE) {
[10:31:41.117]     }
[10:31:41.117]     else {
[10:31:41.117]         if (FALSE) {
[10:31:41.117]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:41.117]                 open = "w")
[10:31:41.117]         }
[10:31:41.117]         else {
[10:31:41.117]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:41.117]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:41.117]         }
[10:31:41.117]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:41.117]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:41.117]             base::sink(type = "output", split = FALSE)
[10:31:41.117]             base::close(...future.stdout)
[10:31:41.117]         }, add = TRUE)
[10:31:41.117]     }
[10:31:41.117]     ...future.frame <- base::sys.nframe()
[10:31:41.117]     ...future.conditions <- base::list()
[10:31:41.117]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:41.117]     if (FALSE) {
[10:31:41.117]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:41.117]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:41.117]     }
[10:31:41.117]     ...future.result <- base::tryCatch({
[10:31:41.117]         base::withCallingHandlers({
[10:31:41.117]             ...future.value <- base::withVisible(base::local({
[10:31:41.117]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:41.117]                 if (!identical(...future.globals.maxSize.org, 
[10:31:41.117]                   ...future.globals.maxSize)) {
[10:31:41.117]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:41.117]                   on.exit(options(oopts), add = TRUE)
[10:31:41.117]                 }
[10:31:41.117]                 {
[10:31:41.117]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:41.117]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:41.117]                     USE.NAMES = FALSE)
[10:31:41.117]                   do.call(mapply, args = args)
[10:31:41.117]                 }
[10:31:41.117]             }))
[10:31:41.117]             future::FutureResult(value = ...future.value$value, 
[10:31:41.117]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:41.117]                   ...future.rng), globalenv = if (FALSE) 
[10:31:41.117]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:41.117]                     ...future.globalenv.names))
[10:31:41.117]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:41.117]         }, condition = base::local({
[10:31:41.117]             c <- base::c
[10:31:41.117]             inherits <- base::inherits
[10:31:41.117]             invokeRestart <- base::invokeRestart
[10:31:41.117]             length <- base::length
[10:31:41.117]             list <- base::list
[10:31:41.117]             seq.int <- base::seq.int
[10:31:41.117]             signalCondition <- base::signalCondition
[10:31:41.117]             sys.calls <- base::sys.calls
[10:31:41.117]             `[[` <- base::`[[`
[10:31:41.117]             `+` <- base::`+`
[10:31:41.117]             `<<-` <- base::`<<-`
[10:31:41.117]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:41.117]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:41.117]                   3L)]
[10:31:41.117]             }
[10:31:41.117]             function(cond) {
[10:31:41.117]                 is_error <- inherits(cond, "error")
[10:31:41.117]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:41.117]                   NULL)
[10:31:41.117]                 if (is_error) {
[10:31:41.117]                   sessionInformation <- function() {
[10:31:41.117]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:41.117]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:41.117]                       search = base::search(), system = base::Sys.info())
[10:31:41.117]                   }
[10:31:41.117]                   ...future.conditions[[length(...future.conditions) + 
[10:31:41.117]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:41.117]                     cond$call), session = sessionInformation(), 
[10:31:41.117]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:41.117]                   signalCondition(cond)
[10:31:41.117]                 }
[10:31:41.117]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:41.117]                 "immediateCondition"))) {
[10:31:41.117]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:41.117]                   ...future.conditions[[length(...future.conditions) + 
[10:31:41.117]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:41.117]                   if (TRUE && !signal) {
[10:31:41.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:41.117]                     {
[10:31:41.117]                       inherits <- base::inherits
[10:31:41.117]                       invokeRestart <- base::invokeRestart
[10:31:41.117]                       is.null <- base::is.null
[10:31:41.117]                       muffled <- FALSE
[10:31:41.117]                       if (inherits(cond, "message")) {
[10:31:41.117]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:41.117]                         if (muffled) 
[10:31:41.117]                           invokeRestart("muffleMessage")
[10:31:41.117]                       }
[10:31:41.117]                       else if (inherits(cond, "warning")) {
[10:31:41.117]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:41.117]                         if (muffled) 
[10:31:41.117]                           invokeRestart("muffleWarning")
[10:31:41.117]                       }
[10:31:41.117]                       else if (inherits(cond, "condition")) {
[10:31:41.117]                         if (!is.null(pattern)) {
[10:31:41.117]                           computeRestarts <- base::computeRestarts
[10:31:41.117]                           grepl <- base::grepl
[10:31:41.117]                           restarts <- computeRestarts(cond)
[10:31:41.117]                           for (restart in restarts) {
[10:31:41.117]                             name <- restart$name
[10:31:41.117]                             if (is.null(name)) 
[10:31:41.117]                               next
[10:31:41.117]                             if (!grepl(pattern, name)) 
[10:31:41.117]                               next
[10:31:41.117]                             invokeRestart(restart)
[10:31:41.117]                             muffled <- TRUE
[10:31:41.117]                             break
[10:31:41.117]                           }
[10:31:41.117]                         }
[10:31:41.117]                       }
[10:31:41.117]                       invisible(muffled)
[10:31:41.117]                     }
[10:31:41.117]                     muffleCondition(cond, pattern = "^muffle")
[10:31:41.117]                   }
[10:31:41.117]                 }
[10:31:41.117]                 else {
[10:31:41.117]                   if (TRUE) {
[10:31:41.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:41.117]                     {
[10:31:41.117]                       inherits <- base::inherits
[10:31:41.117]                       invokeRestart <- base::invokeRestart
[10:31:41.117]                       is.null <- base::is.null
[10:31:41.117]                       muffled <- FALSE
[10:31:41.117]                       if (inherits(cond, "message")) {
[10:31:41.117]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:41.117]                         if (muffled) 
[10:31:41.117]                           invokeRestart("muffleMessage")
[10:31:41.117]                       }
[10:31:41.117]                       else if (inherits(cond, "warning")) {
[10:31:41.117]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:41.117]                         if (muffled) 
[10:31:41.117]                           invokeRestart("muffleWarning")
[10:31:41.117]                       }
[10:31:41.117]                       else if (inherits(cond, "condition")) {
[10:31:41.117]                         if (!is.null(pattern)) {
[10:31:41.117]                           computeRestarts <- base::computeRestarts
[10:31:41.117]                           grepl <- base::grepl
[10:31:41.117]                           restarts <- computeRestarts(cond)
[10:31:41.117]                           for (restart in restarts) {
[10:31:41.117]                             name <- restart$name
[10:31:41.117]                             if (is.null(name)) 
[10:31:41.117]                               next
[10:31:41.117]                             if (!grepl(pattern, name)) 
[10:31:41.117]                               next
[10:31:41.117]                             invokeRestart(restart)
[10:31:41.117]                             muffled <- TRUE
[10:31:41.117]                             break
[10:31:41.117]                           }
[10:31:41.117]                         }
[10:31:41.117]                       }
[10:31:41.117]                       invisible(muffled)
[10:31:41.117]                     }
[10:31:41.117]                     muffleCondition(cond, pattern = "^muffle")
[10:31:41.117]                   }
[10:31:41.117]                 }
[10:31:41.117]             }
[10:31:41.117]         }))
[10:31:41.117]     }, error = function(ex) {
[10:31:41.117]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:41.117]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:41.117]                 ...future.rng), started = ...future.startTime, 
[10:31:41.117]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:41.117]             version = "1.8"), class = "FutureResult")
[10:31:41.117]     }, finally = {
[10:31:41.117]         if (!identical(...future.workdir, getwd())) 
[10:31:41.117]             setwd(...future.workdir)
[10:31:41.117]         {
[10:31:41.117]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:41.117]                 ...future.oldOptions$nwarnings <- NULL
[10:31:41.117]             }
[10:31:41.117]             base::options(...future.oldOptions)
[10:31:41.117]             if (.Platform$OS.type == "windows") {
[10:31:41.117]                 old_names <- names(...future.oldEnvVars)
[10:31:41.117]                 envs <- base::Sys.getenv()
[10:31:41.117]                 names <- names(envs)
[10:31:41.117]                 common <- intersect(names, old_names)
[10:31:41.117]                 added <- setdiff(names, old_names)
[10:31:41.117]                 removed <- setdiff(old_names, names)
[10:31:41.117]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:41.117]                   envs[common]]
[10:31:41.117]                 NAMES <- toupper(changed)
[10:31:41.117]                 args <- list()
[10:31:41.117]                 for (kk in seq_along(NAMES)) {
[10:31:41.117]                   name <- changed[[kk]]
[10:31:41.117]                   NAME <- NAMES[[kk]]
[10:31:41.117]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:41.117]                     next
[10:31:41.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:41.117]                 }
[10:31:41.117]                 NAMES <- toupper(added)
[10:31:41.117]                 for (kk in seq_along(NAMES)) {
[10:31:41.117]                   name <- added[[kk]]
[10:31:41.117]                   NAME <- NAMES[[kk]]
[10:31:41.117]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:41.117]                     next
[10:31:41.117]                   args[[name]] <- ""
[10:31:41.117]                 }
[10:31:41.117]                 NAMES <- toupper(removed)
[10:31:41.117]                 for (kk in seq_along(NAMES)) {
[10:31:41.117]                   name <- removed[[kk]]
[10:31:41.117]                   NAME <- NAMES[[kk]]
[10:31:41.117]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:41.117]                     next
[10:31:41.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:41.117]                 }
[10:31:41.117]                 if (length(args) > 0) 
[10:31:41.117]                   base::do.call(base::Sys.setenv, args = args)
[10:31:41.117]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:41.117]             }
[10:31:41.117]             else {
[10:31:41.117]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:41.117]             }
[10:31:41.117]             {
[10:31:41.117]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:41.117]                   0L) {
[10:31:41.117]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:41.117]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:41.117]                   base::options(opts)
[10:31:41.117]                 }
[10:31:41.117]                 {
[10:31:41.117]                   {
[10:31:41.117]                     NULL
[10:31:41.117]                     RNGkind("Mersenne-Twister")
[10:31:41.117]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:41.117]                       inherits = FALSE)
[10:31:41.117]                   }
[10:31:41.117]                   options(future.plan = NULL)
[10:31:41.117]                   if (is.na(NA_character_)) 
[10:31:41.117]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:41.117]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:41.117]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:41.117]                     .init = FALSE)
[10:31:41.117]                 }
[10:31:41.117]             }
[10:31:41.117]         }
[10:31:41.117]     })
[10:31:41.117]     if (TRUE) {
[10:31:41.117]         base::sink(type = "output", split = FALSE)
[10:31:41.117]         if (FALSE) {
[10:31:41.117]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:41.117]         }
[10:31:41.117]         else {
[10:31:41.117]             ...future.result["stdout"] <- base::list(NULL)
[10:31:41.117]         }
[10:31:41.117]         base::close(...future.stdout)
[10:31:41.117]         ...future.stdout <- NULL
[10:31:41.117]     }
[10:31:41.117]     ...future.result$conditions <- ...future.conditions
[10:31:41.117]     ...future.result$finished <- base::Sys.time()
[10:31:41.117]     ...future.result
[10:31:41.117] }
[10:31:41.119] assign_globals() ...
[10:31:41.119] List of 5
[10:31:41.119]  $ ...future.FUN            :function (x, y)  
[10:31:41.119]  $ MoreArgs                 : NULL
[10:31:41.119]  $ ...future.elements_ii    :List of 2
[10:31:41.119]   ..$ :List of 2
[10:31:41.119]   .. ..$ : int 1
[10:31:41.119]   .. ..$ : int 0
[10:31:41.119]   ..$ :List of 2
[10:31:41.119]   .. ..$ : int 0
[10:31:41.119]   .. ..$ : int 1
[10:31:41.119]  $ ...future.seeds_ii       : NULL
[10:31:41.119]  $ ...future.globals.maxSize: NULL
[10:31:41.119]  - attr(*, "where")=List of 5
[10:31:41.119]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:41.119]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:41.119]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:41.119]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:41.119]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:41.119]  - attr(*, "resolved")= logi FALSE
[10:31:41.119]  - attr(*, "total_size")= num 6480
[10:31:41.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:41.119]  - attr(*, "already-done")= logi TRUE
[10:31:41.124] - reassign environment for ‘...future.FUN’
[10:31:41.124] - copied ‘...future.FUN’ to environment
[10:31:41.125] - copied ‘MoreArgs’ to environment
[10:31:41.125] - copied ‘...future.elements_ii’ to environment
[10:31:41.125] - copied ‘...future.seeds_ii’ to environment
[10:31:41.125] - copied ‘...future.globals.maxSize’ to environment
[10:31:41.125] assign_globals() ... done
[10:31:41.125] plan(): Setting new future strategy stack:
[10:31:41.125] List of future strategies:
[10:31:41.125] 1. sequential:
[10:31:41.125]    - args: function (..., envir = parent.frame())
[10:31:41.125]    - tweaked: FALSE
[10:31:41.125]    - call: NULL
[10:31:41.126] plan(): nbrOfWorkers() = 1
[10:31:41.627] plan(): Setting new future strategy stack:
[10:31:41.628] List of future strategies:
[10:31:41.628] 1. multicore:
[10:31:41.628]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:41.628]    - tweaked: FALSE
[10:31:41.628]    - call: plan(strategy)
[10:31:41.632] plan(): nbrOfWorkers() = 1
[10:31:41.632] SequentialFuture started (and completed)
[10:31:41.632] - Launch lazy future ... done
[10:31:41.633] run() for ‘SequentialFuture’ ... done
[10:31:41.633] Created future:
[10:31:41.633] SequentialFuture:
[10:31:41.633] Label: ‘future_mapply-1’
[10:31:41.633] Expression:
[10:31:41.633] {
[10:31:41.633]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:41.633]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:41.633]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:41.633]         on.exit(options(oopts), add = TRUE)
[10:31:41.633]     }
[10:31:41.633]     {
[10:31:41.633]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:41.633]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:41.633]         do.call(mapply, args = args)
[10:31:41.633]     }
[10:31:41.633] }
[10:31:41.633] Lazy evaluation: FALSE
[10:31:41.633] Asynchronous evaluation: FALSE
[10:31:41.633] Local evaluation: TRUE
[10:31:41.633] Environment: R_GlobalEnv
[10:31:41.633] Capture standard output: FALSE
[10:31:41.633] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:41.633] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:41.633] Packages: <none>
[10:31:41.633] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:41.633] Resolved: TRUE
[10:31:41.633] Value: 224 bytes of class ‘list’
[10:31:41.633] Early signaling: FALSE
[10:31:41.633] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:41.633] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:41.634] Chunk #1 of 1 ... DONE
[10:31:41.634] Launching 1 futures (chunks) ... DONE
[10:31:41.634] Resolving 1 futures (chunks) ...
[10:31:41.635] resolve() on list ...
[10:31:41.635]  recursive: 0
[10:31:41.635]  length: 1
[10:31:41.635] 
[10:31:41.635] resolved() for ‘SequentialFuture’ ...
[10:31:41.635] - state: ‘finished’
[10:31:41.635] - run: TRUE
[10:31:41.635] - result: ‘FutureResult’
[10:31:41.635] resolved() for ‘SequentialFuture’ ... done
[10:31:41.635] Future #1
[10:31:41.636] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:41.636] - nx: 1
[10:31:41.636] - relay: TRUE
[10:31:41.636] - stdout: TRUE
[10:31:41.636] - signal: TRUE
[10:31:41.636] - resignal: FALSE
[10:31:41.636] - force: TRUE
[10:31:41.636] - relayed: [n=1] FALSE
[10:31:41.636] - queued futures: [n=1] FALSE
[10:31:41.636]  - until=1
[10:31:41.637]  - relaying element #1
[10:31:41.637] - relayed: [n=1] TRUE
[10:31:41.637] - queued futures: [n=1] TRUE
[10:31:41.637] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:41.637]  length: 0 (resolved future 1)
[10:31:41.637] Relaying remaining futures
[10:31:41.637] signalConditionsASAP(NULL, pos=0) ...
[10:31:41.637] - nx: 1
[10:31:41.637] - relay: TRUE
[10:31:41.638] - stdout: TRUE
[10:31:41.638] - signal: TRUE
[10:31:41.638] - resignal: FALSE
[10:31:41.638] - force: TRUE
[10:31:41.638] - relayed: [n=1] TRUE
[10:31:41.638] - queued futures: [n=1] TRUE
 - flush all
[10:31:41.638] - relayed: [n=1] TRUE
[10:31:41.638] - queued futures: [n=1] TRUE
[10:31:41.638] signalConditionsASAP(NULL, pos=0) ... done
[10:31:41.638] resolve() on list ... DONE
[10:31:41.639]  - Number of value chunks collected: 1
[10:31:41.641] Resolving 1 futures (chunks) ... DONE
[10:31:41.641] Reducing values from 1 chunks ...
[10:31:41.641]  - Number of values collected after concatenation: 2
[10:31:41.641]  - Number of values expected: 2
[10:31:41.641] Reducing values from 1 chunks ... DONE
[10:31:41.641] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:31:41.641] future_mapply() ...
[10:31:41.645] Number of chunks: 1
[10:31:41.645] getGlobalsAndPackagesXApply() ...
[10:31:41.645]  - future.globals: TRUE
[10:31:41.646] getGlobalsAndPackages() ...
[10:31:41.646] Searching for globals...
[10:31:41.647] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:41.647] Searching for globals ... DONE
[10:31:41.648] Resolving globals: FALSE
[10:31:41.648] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:41.648] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:41.648] - globals: [1] ‘FUN’
[10:31:41.649] 
[10:31:41.649] getGlobalsAndPackages() ... DONE
[10:31:41.649]  - globals found/used: [n=1] ‘FUN’
[10:31:41.649]  - needed namespaces: [n=0] 
[10:31:41.649] Finding globals ... DONE
[10:31:41.649] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:41.649] List of 2
[10:31:41.649]  $ ...future.FUN:function (x, y)  
[10:31:41.649]  $ MoreArgs     : NULL
[10:31:41.649]  - attr(*, "where")=List of 2
[10:31:41.649]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:41.649]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:41.649]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:41.649]  - attr(*, "resolved")= logi FALSE
[10:31:41.649]  - attr(*, "total_size")= num NA
[10:31:41.652] Packages to be attached in all futures: [n=0] 
[10:31:41.652] getGlobalsAndPackagesXApply() ... DONE
[10:31:41.652] Number of futures (= number of chunks): 1
[10:31:41.652] Launching 1 futures (chunks) ...
[10:31:41.652] Chunk #1 of 1 ...
[10:31:41.652]  - Finding globals in '...' for chunk #1 ...
[10:31:41.653] getGlobalsAndPackages() ...
[10:31:41.653] Searching for globals...
[10:31:41.653] 
[10:31:41.653] Searching for globals ... DONE
[10:31:41.653] - globals: [0] <none>
[10:31:41.653] getGlobalsAndPackages() ... DONE
[10:31:41.653]    + additional globals found: [n=0] 
[10:31:41.654]    + additional namespaces needed: [n=0] 
[10:31:41.654]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:41.654]  - seeds: <none>
[10:31:41.654]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:41.654] getGlobalsAndPackages() ...
[10:31:41.654] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:41.654] Resolving globals: FALSE
[10:31:41.655] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:31:41.655] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:41.655] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:41.655] 
[10:31:41.655] getGlobalsAndPackages() ... DONE
[10:31:41.656] run() for ‘Future’ ...
[10:31:41.656] - state: ‘created’
[10:31:41.656] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:41.660] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:41.660] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:41.660]   - Field: ‘label’
[10:31:41.660]   - Field: ‘local’
[10:31:41.660]   - Field: ‘owner’
[10:31:41.660]   - Field: ‘envir’
[10:31:41.660]   - Field: ‘packages’
[10:31:41.661]   - Field: ‘gc’
[10:31:41.661]   - Field: ‘conditions’
[10:31:41.661]   - Field: ‘expr’
[10:31:41.661]   - Field: ‘uuid’
[10:31:41.661]   - Field: ‘seed’
[10:31:41.661]   - Field: ‘version’
[10:31:41.661]   - Field: ‘result’
[10:31:41.661]   - Field: ‘asynchronous’
[10:31:41.661]   - Field: ‘calls’
[10:31:41.661]   - Field: ‘globals’
[10:31:41.662]   - Field: ‘stdout’
[10:31:41.662]   - Field: ‘earlySignal’
[10:31:41.662]   - Field: ‘lazy’
[10:31:41.662]   - Field: ‘state’
[10:31:41.662] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:41.662] - Launch lazy future ...
[10:31:41.662] Packages needed by the future expression (n = 0): <none>
[10:31:41.662] Packages needed by future strategies (n = 0): <none>
[10:31:41.663] {
[10:31:41.663]     {
[10:31:41.663]         {
[10:31:41.663]             ...future.startTime <- base::Sys.time()
[10:31:41.663]             {
[10:31:41.663]                 {
[10:31:41.663]                   {
[10:31:41.663]                     base::local({
[10:31:41.663]                       has_future <- base::requireNamespace("future", 
[10:31:41.663]                         quietly = TRUE)
[10:31:41.663]                       if (has_future) {
[10:31:41.663]                         ns <- base::getNamespace("future")
[10:31:41.663]                         version <- ns[[".package"]][["version"]]
[10:31:41.663]                         if (is.null(version)) 
[10:31:41.663]                           version <- utils::packageVersion("future")
[10:31:41.663]                       }
[10:31:41.663]                       else {
[10:31:41.663]                         version <- NULL
[10:31:41.663]                       }
[10:31:41.663]                       if (!has_future || version < "1.8.0") {
[10:31:41.663]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:41.663]                           "", base::R.version$version.string), 
[10:31:41.663]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:41.663]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:41.663]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:41.663]                             "release", "version")], collapse = " "), 
[10:31:41.663]                           hostname = base::Sys.info()[["nodename"]])
[10:31:41.663]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:41.663]                           info)
[10:31:41.663]                         info <- base::paste(info, collapse = "; ")
[10:31:41.663]                         if (!has_future) {
[10:31:41.663]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:41.663]                             info)
[10:31:41.663]                         }
[10:31:41.663]                         else {
[10:31:41.663]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:41.663]                             info, version)
[10:31:41.663]                         }
[10:31:41.663]                         base::stop(msg)
[10:31:41.663]                       }
[10:31:41.663]                     })
[10:31:41.663]                   }
[10:31:41.663]                   ...future.strategy.old <- future::plan("list")
[10:31:41.663]                   options(future.plan = NULL)
[10:31:41.663]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:41.663]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:41.663]                 }
[10:31:41.663]                 ...future.workdir <- getwd()
[10:31:41.663]             }
[10:31:41.663]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:41.663]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:41.663]         }
[10:31:41.663]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:41.663]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:41.663]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:41.663]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:41.663]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:41.663]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:41.663]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:41.663]             base::names(...future.oldOptions))
[10:31:41.663]     }
[10:31:41.663]     if (FALSE) {
[10:31:41.663]     }
[10:31:41.663]     else {
[10:31:41.663]         if (TRUE) {
[10:31:41.663]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:41.663]                 open = "w")
[10:31:41.663]         }
[10:31:41.663]         else {
[10:31:41.663]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:41.663]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:41.663]         }
[10:31:41.663]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:41.663]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:41.663]             base::sink(type = "output", split = FALSE)
[10:31:41.663]             base::close(...future.stdout)
[10:31:41.663]         }, add = TRUE)
[10:31:41.663]     }
[10:31:41.663]     ...future.frame <- base::sys.nframe()
[10:31:41.663]     ...future.conditions <- base::list()
[10:31:41.663]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:41.663]     if (FALSE) {
[10:31:41.663]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:41.663]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:41.663]     }
[10:31:41.663]     ...future.result <- base::tryCatch({
[10:31:41.663]         base::withCallingHandlers({
[10:31:41.663]             ...future.value <- base::withVisible(base::local({
[10:31:41.663]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:41.663]                 if (!identical(...future.globals.maxSize.org, 
[10:31:41.663]                   ...future.globals.maxSize)) {
[10:31:41.663]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:41.663]                   on.exit(options(oopts), add = TRUE)
[10:31:41.663]                 }
[10:31:41.663]                 {
[10:31:41.663]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:41.663]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:41.663]                     USE.NAMES = FALSE)
[10:31:41.663]                   do.call(mapply, args = args)
[10:31:41.663]                 }
[10:31:41.663]             }))
[10:31:41.663]             future::FutureResult(value = ...future.value$value, 
[10:31:41.663]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:41.663]                   ...future.rng), globalenv = if (FALSE) 
[10:31:41.663]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:41.663]                     ...future.globalenv.names))
[10:31:41.663]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:41.663]         }, condition = base::local({
[10:31:41.663]             c <- base::c
[10:31:41.663]             inherits <- base::inherits
[10:31:41.663]             invokeRestart <- base::invokeRestart
[10:31:41.663]             length <- base::length
[10:31:41.663]             list <- base::list
[10:31:41.663]             seq.int <- base::seq.int
[10:31:41.663]             signalCondition <- base::signalCondition
[10:31:41.663]             sys.calls <- base::sys.calls
[10:31:41.663]             `[[` <- base::`[[`
[10:31:41.663]             `+` <- base::`+`
[10:31:41.663]             `<<-` <- base::`<<-`
[10:31:41.663]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:41.663]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:41.663]                   3L)]
[10:31:41.663]             }
[10:31:41.663]             function(cond) {
[10:31:41.663]                 is_error <- inherits(cond, "error")
[10:31:41.663]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:41.663]                   NULL)
[10:31:41.663]                 if (is_error) {
[10:31:41.663]                   sessionInformation <- function() {
[10:31:41.663]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:41.663]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:41.663]                       search = base::search(), system = base::Sys.info())
[10:31:41.663]                   }
[10:31:41.663]                   ...future.conditions[[length(...future.conditions) + 
[10:31:41.663]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:41.663]                     cond$call), session = sessionInformation(), 
[10:31:41.663]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:41.663]                   signalCondition(cond)
[10:31:41.663]                 }
[10:31:41.663]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:41.663]                 "immediateCondition"))) {
[10:31:41.663]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:41.663]                   ...future.conditions[[length(...future.conditions) + 
[10:31:41.663]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:41.663]                   if (TRUE && !signal) {
[10:31:41.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:41.663]                     {
[10:31:41.663]                       inherits <- base::inherits
[10:31:41.663]                       invokeRestart <- base::invokeRestart
[10:31:41.663]                       is.null <- base::is.null
[10:31:41.663]                       muffled <- FALSE
[10:31:41.663]                       if (inherits(cond, "message")) {
[10:31:41.663]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:41.663]                         if (muffled) 
[10:31:41.663]                           invokeRestart("muffleMessage")
[10:31:41.663]                       }
[10:31:41.663]                       else if (inherits(cond, "warning")) {
[10:31:41.663]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:41.663]                         if (muffled) 
[10:31:41.663]                           invokeRestart("muffleWarning")
[10:31:41.663]                       }
[10:31:41.663]                       else if (inherits(cond, "condition")) {
[10:31:41.663]                         if (!is.null(pattern)) {
[10:31:41.663]                           computeRestarts <- base::computeRestarts
[10:31:41.663]                           grepl <- base::grepl
[10:31:41.663]                           restarts <- computeRestarts(cond)
[10:31:41.663]                           for (restart in restarts) {
[10:31:41.663]                             name <- restart$name
[10:31:41.663]                             if (is.null(name)) 
[10:31:41.663]                               next
[10:31:41.663]                             if (!grepl(pattern, name)) 
[10:31:41.663]                               next
[10:31:41.663]                             invokeRestart(restart)
[10:31:41.663]                             muffled <- TRUE
[10:31:41.663]                             break
[10:31:41.663]                           }
[10:31:41.663]                         }
[10:31:41.663]                       }
[10:31:41.663]                       invisible(muffled)
[10:31:41.663]                     }
[10:31:41.663]                     muffleCondition(cond, pattern = "^muffle")
[10:31:41.663]                   }
[10:31:41.663]                 }
[10:31:41.663]                 else {
[10:31:41.663]                   if (TRUE) {
[10:31:41.663]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:41.663]                     {
[10:31:41.663]                       inherits <- base::inherits
[10:31:41.663]                       invokeRestart <- base::invokeRestart
[10:31:41.663]                       is.null <- base::is.null
[10:31:41.663]                       muffled <- FALSE
[10:31:41.663]                       if (inherits(cond, "message")) {
[10:31:41.663]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:41.663]                         if (muffled) 
[10:31:41.663]                           invokeRestart("muffleMessage")
[10:31:41.663]                       }
[10:31:41.663]                       else if (inherits(cond, "warning")) {
[10:31:41.663]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:41.663]                         if (muffled) 
[10:31:41.663]                           invokeRestart("muffleWarning")
[10:31:41.663]                       }
[10:31:41.663]                       else if (inherits(cond, "condition")) {
[10:31:41.663]                         if (!is.null(pattern)) {
[10:31:41.663]                           computeRestarts <- base::computeRestarts
[10:31:41.663]                           grepl <- base::grepl
[10:31:41.663]                           restarts <- computeRestarts(cond)
[10:31:41.663]                           for (restart in restarts) {
[10:31:41.663]                             name <- restart$name
[10:31:41.663]                             if (is.null(name)) 
[10:31:41.663]                               next
[10:31:41.663]                             if (!grepl(pattern, name)) 
[10:31:41.663]                               next
[10:31:41.663]                             invokeRestart(restart)
[10:31:41.663]                             muffled <- TRUE
[10:31:41.663]                             break
[10:31:41.663]                           }
[10:31:41.663]                         }
[10:31:41.663]                       }
[10:31:41.663]                       invisible(muffled)
[10:31:41.663]                     }
[10:31:41.663]                     muffleCondition(cond, pattern = "^muffle")
[10:31:41.663]                   }
[10:31:41.663]                 }
[10:31:41.663]             }
[10:31:41.663]         }))
[10:31:41.663]     }, error = function(ex) {
[10:31:41.663]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:41.663]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:41.663]                 ...future.rng), started = ...future.startTime, 
[10:31:41.663]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:41.663]             version = "1.8"), class = "FutureResult")
[10:31:41.663]     }, finally = {
[10:31:41.663]         if (!identical(...future.workdir, getwd())) 
[10:31:41.663]             setwd(...future.workdir)
[10:31:41.663]         {
[10:31:41.663]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:41.663]                 ...future.oldOptions$nwarnings <- NULL
[10:31:41.663]             }
[10:31:41.663]             base::options(...future.oldOptions)
[10:31:41.663]             if (.Platform$OS.type == "windows") {
[10:31:41.663]                 old_names <- names(...future.oldEnvVars)
[10:31:41.663]                 envs <- base::Sys.getenv()
[10:31:41.663]                 names <- names(envs)
[10:31:41.663]                 common <- intersect(names, old_names)
[10:31:41.663]                 added <- setdiff(names, old_names)
[10:31:41.663]                 removed <- setdiff(old_names, names)
[10:31:41.663]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:41.663]                   envs[common]]
[10:31:41.663]                 NAMES <- toupper(changed)
[10:31:41.663]                 args <- list()
[10:31:41.663]                 for (kk in seq_along(NAMES)) {
[10:31:41.663]                   name <- changed[[kk]]
[10:31:41.663]                   NAME <- NAMES[[kk]]
[10:31:41.663]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:41.663]                     next
[10:31:41.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:41.663]                 }
[10:31:41.663]                 NAMES <- toupper(added)
[10:31:41.663]                 for (kk in seq_along(NAMES)) {
[10:31:41.663]                   name <- added[[kk]]
[10:31:41.663]                   NAME <- NAMES[[kk]]
[10:31:41.663]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:41.663]                     next
[10:31:41.663]                   args[[name]] <- ""
[10:31:41.663]                 }
[10:31:41.663]                 NAMES <- toupper(removed)
[10:31:41.663]                 for (kk in seq_along(NAMES)) {
[10:31:41.663]                   name <- removed[[kk]]
[10:31:41.663]                   NAME <- NAMES[[kk]]
[10:31:41.663]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:41.663]                     next
[10:31:41.663]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:41.663]                 }
[10:31:41.663]                 if (length(args) > 0) 
[10:31:41.663]                   base::do.call(base::Sys.setenv, args = args)
[10:31:41.663]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:41.663]             }
[10:31:41.663]             else {
[10:31:41.663]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:41.663]             }
[10:31:41.663]             {
[10:31:41.663]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:41.663]                   0L) {
[10:31:41.663]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:41.663]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:41.663]                   base::options(opts)
[10:31:41.663]                 }
[10:31:41.663]                 {
[10:31:41.663]                   {
[10:31:41.663]                     NULL
[10:31:41.663]                     RNGkind("Mersenne-Twister")
[10:31:41.663]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:41.663]                       inherits = FALSE)
[10:31:41.663]                   }
[10:31:41.663]                   options(future.plan = NULL)
[10:31:41.663]                   if (is.na(NA_character_)) 
[10:31:41.663]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:41.663]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:41.663]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:41.663]                     .init = FALSE)
[10:31:41.663]                 }
[10:31:41.663]             }
[10:31:41.663]         }
[10:31:41.663]     })
[10:31:41.663]     if (TRUE) {
[10:31:41.663]         base::sink(type = "output", split = FALSE)
[10:31:41.663]         if (TRUE) {
[10:31:41.663]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:41.663]         }
[10:31:41.663]         else {
[10:31:41.663]             ...future.result["stdout"] <- base::list(NULL)
[10:31:41.663]         }
[10:31:41.663]         base::close(...future.stdout)
[10:31:41.663]         ...future.stdout <- NULL
[10:31:41.663]     }
[10:31:41.663]     ...future.result$conditions <- ...future.conditions
[10:31:41.663]     ...future.result$finished <- base::Sys.time()
[10:31:41.663]     ...future.result
[10:31:41.663] }
[10:31:41.665] assign_globals() ...
[10:31:41.665] List of 5
[10:31:41.665]  $ ...future.FUN            :function (x, y)  
[10:31:41.665]  $ MoreArgs                 : NULL
[10:31:41.665]  $ ...future.elements_ii    :List of 2
[10:31:41.665]   ..$ :List of 2
[10:31:41.665]   .. ..$ : int 1
[10:31:41.665]   .. ..$ : int 0
[10:31:41.665]   ..$ :List of 2
[10:31:41.665]   .. ..$ : int 0
[10:31:41.665]   .. ..$ : int 1
[10:31:41.665]  $ ...future.seeds_ii       : NULL
[10:31:41.665]  $ ...future.globals.maxSize: NULL
[10:31:41.665]  - attr(*, "where")=List of 5
[10:31:41.665]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:41.665]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:41.665]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:41.665]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:41.665]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:41.665]  - attr(*, "resolved")= logi FALSE
[10:31:41.665]  - attr(*, "total_size")= num 6480
[10:31:41.665]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:41.665]  - attr(*, "already-done")= logi TRUE
[10:31:41.673] - reassign environment for ‘...future.FUN’
[10:31:41.673] - copied ‘...future.FUN’ to environment
[10:31:41.673] - copied ‘MoreArgs’ to environment
[10:31:41.673] - copied ‘...future.elements_ii’ to environment
[10:31:41.673] - copied ‘...future.seeds_ii’ to environment
[10:31:41.673] - copied ‘...future.globals.maxSize’ to environment
[10:31:41.673] assign_globals() ... done
[10:31:41.674] plan(): Setting new future strategy stack:
[10:31:41.674] List of future strategies:
[10:31:41.674] 1. sequential:
[10:31:41.674]    - args: function (..., envir = parent.frame())
[10:31:41.674]    - tweaked: FALSE
[10:31:41.674]    - call: NULL
[10:31:41.674] plan(): nbrOfWorkers() = 1
[10:31:42.176] plan(): Setting new future strategy stack:
[10:31:42.176] List of future strategies:
[10:31:42.176] 1. multicore:
[10:31:42.176]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:42.176]    - tweaked: FALSE
[10:31:42.176]    - call: plan(strategy)
[10:31:42.180] plan(): nbrOfWorkers() = 1
[10:31:42.180] SequentialFuture started (and completed)
[10:31:42.180] - Launch lazy future ... done
[10:31:42.180] run() for ‘SequentialFuture’ ... done
[10:31:42.181] Created future:
[10:31:42.181] SequentialFuture:
[10:31:42.181] Label: ‘future_mapply-1’
[10:31:42.181] Expression:
[10:31:42.181] {
[10:31:42.181]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:42.181]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:42.181]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:42.181]         on.exit(options(oopts), add = TRUE)
[10:31:42.181]     }
[10:31:42.181]     {
[10:31:42.181]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:42.181]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:42.181]         do.call(mapply, args = args)
[10:31:42.181]     }
[10:31:42.181] }
[10:31:42.181] Lazy evaluation: FALSE
[10:31:42.181] Asynchronous evaluation: FALSE
[10:31:42.181] Local evaluation: TRUE
[10:31:42.181] Environment: R_GlobalEnv
[10:31:42.181] Capture standard output: TRUE
[10:31:42.181] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:42.181] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:42.181] Packages: <none>
[10:31:42.181] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:42.181] Resolved: TRUE
[10:31:42.181] Value: 224 bytes of class ‘list’
[10:31:42.181] Early signaling: FALSE
[10:31:42.181] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:42.181] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:42.182] Chunk #1 of 1 ... DONE
[10:31:42.182] Launching 1 futures (chunks) ... DONE
[10:31:42.182] Resolving 1 futures (chunks) ...
[10:31:42.182] resolve() on list ...
[10:31:42.182]  recursive: 0
[10:31:42.182]  length: 1
[10:31:42.182] 
[10:31:42.182] resolved() for ‘SequentialFuture’ ...
[10:31:42.183] - state: ‘finished’
[10:31:42.183] - run: TRUE
[10:31:42.183] - result: ‘FutureResult’
[10:31:42.183] resolved() for ‘SequentialFuture’ ... done
[10:31:42.183] Future #1
[10:31:42.183] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:42.183] - nx: 1
[10:31:42.183] - relay: TRUE
[10:31:42.183] - stdout: TRUE
[10:31:42.183] - signal: TRUE
[10:31:42.183] - resignal: FALSE
[10:31:42.184] - force: TRUE
[10:31:42.184] - relayed: [n=1] FALSE
[10:31:42.184] - queued futures: [n=1] FALSE
[10:31:42.184]  - until=1
[10:31:42.184]  - relaying element #1
[10:31:42.184] - relayed: [n=1] TRUE
[10:31:42.184] - queued futures: [n=1] TRUE
[10:31:42.184] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:42.184]  length: 0 (resolved future 1)
[10:31:42.185] Relaying remaining futures
[10:31:42.185] signalConditionsASAP(NULL, pos=0) ...
[10:31:42.185] - nx: 1
[10:31:42.185] - relay: TRUE
[10:31:42.185] - stdout: TRUE
[10:31:42.185] - signal: TRUE
[10:31:42.185] - resignal: FALSE
[10:31:42.185] - force: TRUE
[10:31:42.185] - relayed: [n=1] TRUE
[10:31:42.185] - queued futures: [n=1] TRUE
 - flush all
[10:31:42.186] - relayed: [n=1] TRUE
[10:31:42.186] - queued futures: [n=1] TRUE
[10:31:42.186] signalConditionsASAP(NULL, pos=0) ... done
[10:31:42.186] resolve() on list ... DONE
[10:31:42.186]  - Number of value chunks collected: 1
[10:31:42.186] Resolving 1 futures (chunks) ... DONE
[10:31:42.186] Reducing values from 1 chunks ...
[10:31:42.186]  - Number of values collected after concatenation: 2
[10:31:42.186]  - Number of values expected: 2
[10:31:42.186] Reducing values from 1 chunks ... DONE
[10:31:42.187] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:31:42.187] future_mapply() ...
[10:31:42.190] Number of chunks: 1
[10:31:42.190] getGlobalsAndPackagesXApply() ...
[10:31:42.191]  - future.globals: TRUE
[10:31:42.191] getGlobalsAndPackages() ...
[10:31:42.191] Searching for globals...
[10:31:42.192] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:42.192] Searching for globals ... DONE
[10:31:42.192] Resolving globals: FALSE
[10:31:42.193] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:42.193] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:42.193] - globals: [1] ‘FUN’
[10:31:42.194] 
[10:31:42.194] getGlobalsAndPackages() ... DONE
[10:31:42.194]  - globals found/used: [n=1] ‘FUN’
[10:31:42.194]  - needed namespaces: [n=0] 
[10:31:42.194] Finding globals ... DONE
[10:31:42.194] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:42.194] List of 2
[10:31:42.194]  $ ...future.FUN:function (x, y)  
[10:31:42.194]  $ MoreArgs     : NULL
[10:31:42.194]  - attr(*, "where")=List of 2
[10:31:42.194]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:42.194]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:42.194]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:42.194]  - attr(*, "resolved")= logi FALSE
[10:31:42.194]  - attr(*, "total_size")= num NA
[10:31:42.197] Packages to be attached in all futures: [n=0] 
[10:31:42.197] getGlobalsAndPackagesXApply() ... DONE
[10:31:42.197] Number of futures (= number of chunks): 1
[10:31:42.197] Launching 1 futures (chunks) ...
[10:31:42.197] Chunk #1 of 1 ...
[10:31:42.197]  - Finding globals in '...' for chunk #1 ...
[10:31:42.197] getGlobalsAndPackages() ...
[10:31:42.198] Searching for globals...
[10:31:42.198] 
[10:31:42.198] Searching for globals ... DONE
[10:31:42.198] - globals: [0] <none>
[10:31:42.198] getGlobalsAndPackages() ... DONE
[10:31:42.198]    + additional globals found: [n=0] 
[10:31:42.198]    + additional namespaces needed: [n=0] 
[10:31:42.198]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:42.198]  - seeds: <none>
[10:31:42.199]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:42.199] getGlobalsAndPackages() ...
[10:31:42.199] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:42.199] Resolving globals: FALSE
[10:31:42.201] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:31:42.202] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:42.202] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:42.202] 
[10:31:42.202] getGlobalsAndPackages() ... DONE
[10:31:42.202] run() for ‘Future’ ...
[10:31:42.202] - state: ‘created’
[10:31:42.202] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:42.206] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:42.206] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:42.206]   - Field: ‘label’
[10:31:42.206]   - Field: ‘local’
[10:31:42.206]   - Field: ‘owner’
[10:31:42.206]   - Field: ‘envir’
[10:31:42.207]   - Field: ‘packages’
[10:31:42.207]   - Field: ‘gc’
[10:31:42.207]   - Field: ‘conditions’
[10:31:42.207]   - Field: ‘expr’
[10:31:42.207]   - Field: ‘uuid’
[10:31:42.207]   - Field: ‘seed’
[10:31:42.207]   - Field: ‘version’
[10:31:42.207]   - Field: ‘result’
[10:31:42.207]   - Field: ‘asynchronous’
[10:31:42.207]   - Field: ‘calls’
[10:31:42.208]   - Field: ‘globals’
[10:31:42.208]   - Field: ‘stdout’
[10:31:42.208]   - Field: ‘earlySignal’
[10:31:42.208]   - Field: ‘lazy’
[10:31:42.208]   - Field: ‘state’
[10:31:42.208] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:42.208] - Launch lazy future ...
[10:31:42.208] Packages needed by the future expression (n = 0): <none>
[10:31:42.208] Packages needed by future strategies (n = 0): <none>
[10:31:42.209] {
[10:31:42.209]     {
[10:31:42.209]         {
[10:31:42.209]             ...future.startTime <- base::Sys.time()
[10:31:42.209]             {
[10:31:42.209]                 {
[10:31:42.209]                   {
[10:31:42.209]                     base::local({
[10:31:42.209]                       has_future <- base::requireNamespace("future", 
[10:31:42.209]                         quietly = TRUE)
[10:31:42.209]                       if (has_future) {
[10:31:42.209]                         ns <- base::getNamespace("future")
[10:31:42.209]                         version <- ns[[".package"]][["version"]]
[10:31:42.209]                         if (is.null(version)) 
[10:31:42.209]                           version <- utils::packageVersion("future")
[10:31:42.209]                       }
[10:31:42.209]                       else {
[10:31:42.209]                         version <- NULL
[10:31:42.209]                       }
[10:31:42.209]                       if (!has_future || version < "1.8.0") {
[10:31:42.209]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:42.209]                           "", base::R.version$version.string), 
[10:31:42.209]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:42.209]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:42.209]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:42.209]                             "release", "version")], collapse = " "), 
[10:31:42.209]                           hostname = base::Sys.info()[["nodename"]])
[10:31:42.209]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:42.209]                           info)
[10:31:42.209]                         info <- base::paste(info, collapse = "; ")
[10:31:42.209]                         if (!has_future) {
[10:31:42.209]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:42.209]                             info)
[10:31:42.209]                         }
[10:31:42.209]                         else {
[10:31:42.209]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:42.209]                             info, version)
[10:31:42.209]                         }
[10:31:42.209]                         base::stop(msg)
[10:31:42.209]                       }
[10:31:42.209]                     })
[10:31:42.209]                   }
[10:31:42.209]                   ...future.strategy.old <- future::plan("list")
[10:31:42.209]                   options(future.plan = NULL)
[10:31:42.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:42.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:42.209]                 }
[10:31:42.209]                 ...future.workdir <- getwd()
[10:31:42.209]             }
[10:31:42.209]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:42.209]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:42.209]         }
[10:31:42.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:42.209]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:42.209]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:42.209]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:42.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:42.209]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:42.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:42.209]             base::names(...future.oldOptions))
[10:31:42.209]     }
[10:31:42.209]     if (TRUE) {
[10:31:42.209]     }
[10:31:42.209]     else {
[10:31:42.209]         if (NA) {
[10:31:42.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:42.209]                 open = "w")
[10:31:42.209]         }
[10:31:42.209]         else {
[10:31:42.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:42.209]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:42.209]         }
[10:31:42.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:42.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:42.209]             base::sink(type = "output", split = FALSE)
[10:31:42.209]             base::close(...future.stdout)
[10:31:42.209]         }, add = TRUE)
[10:31:42.209]     }
[10:31:42.209]     ...future.frame <- base::sys.nframe()
[10:31:42.209]     ...future.conditions <- base::list()
[10:31:42.209]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:42.209]     if (FALSE) {
[10:31:42.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:42.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:42.209]     }
[10:31:42.209]     ...future.result <- base::tryCatch({
[10:31:42.209]         base::withCallingHandlers({
[10:31:42.209]             ...future.value <- base::withVisible(base::local({
[10:31:42.209]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:42.209]                 if (!identical(...future.globals.maxSize.org, 
[10:31:42.209]                   ...future.globals.maxSize)) {
[10:31:42.209]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:42.209]                   on.exit(options(oopts), add = TRUE)
[10:31:42.209]                 }
[10:31:42.209]                 {
[10:31:42.209]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:42.209]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:42.209]                     USE.NAMES = FALSE)
[10:31:42.209]                   do.call(mapply, args = args)
[10:31:42.209]                 }
[10:31:42.209]             }))
[10:31:42.209]             future::FutureResult(value = ...future.value$value, 
[10:31:42.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:42.209]                   ...future.rng), globalenv = if (FALSE) 
[10:31:42.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:42.209]                     ...future.globalenv.names))
[10:31:42.209]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:42.209]         }, condition = base::local({
[10:31:42.209]             c <- base::c
[10:31:42.209]             inherits <- base::inherits
[10:31:42.209]             invokeRestart <- base::invokeRestart
[10:31:42.209]             length <- base::length
[10:31:42.209]             list <- base::list
[10:31:42.209]             seq.int <- base::seq.int
[10:31:42.209]             signalCondition <- base::signalCondition
[10:31:42.209]             sys.calls <- base::sys.calls
[10:31:42.209]             `[[` <- base::`[[`
[10:31:42.209]             `+` <- base::`+`
[10:31:42.209]             `<<-` <- base::`<<-`
[10:31:42.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:42.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:42.209]                   3L)]
[10:31:42.209]             }
[10:31:42.209]             function(cond) {
[10:31:42.209]                 is_error <- inherits(cond, "error")
[10:31:42.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:42.209]                   NULL)
[10:31:42.209]                 if (is_error) {
[10:31:42.209]                   sessionInformation <- function() {
[10:31:42.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:42.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:42.209]                       search = base::search(), system = base::Sys.info())
[10:31:42.209]                   }
[10:31:42.209]                   ...future.conditions[[length(...future.conditions) + 
[10:31:42.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:42.209]                     cond$call), session = sessionInformation(), 
[10:31:42.209]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:42.209]                   signalCondition(cond)
[10:31:42.209]                 }
[10:31:42.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:42.209]                 "immediateCondition"))) {
[10:31:42.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:42.209]                   ...future.conditions[[length(...future.conditions) + 
[10:31:42.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:42.209]                   if (TRUE && !signal) {
[10:31:42.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:42.209]                     {
[10:31:42.209]                       inherits <- base::inherits
[10:31:42.209]                       invokeRestart <- base::invokeRestart
[10:31:42.209]                       is.null <- base::is.null
[10:31:42.209]                       muffled <- FALSE
[10:31:42.209]                       if (inherits(cond, "message")) {
[10:31:42.209]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:42.209]                         if (muffled) 
[10:31:42.209]                           invokeRestart("muffleMessage")
[10:31:42.209]                       }
[10:31:42.209]                       else if (inherits(cond, "warning")) {
[10:31:42.209]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:42.209]                         if (muffled) 
[10:31:42.209]                           invokeRestart("muffleWarning")
[10:31:42.209]                       }
[10:31:42.209]                       else if (inherits(cond, "condition")) {
[10:31:42.209]                         if (!is.null(pattern)) {
[10:31:42.209]                           computeRestarts <- base::computeRestarts
[10:31:42.209]                           grepl <- base::grepl
[10:31:42.209]                           restarts <- computeRestarts(cond)
[10:31:42.209]                           for (restart in restarts) {
[10:31:42.209]                             name <- restart$name
[10:31:42.209]                             if (is.null(name)) 
[10:31:42.209]                               next
[10:31:42.209]                             if (!grepl(pattern, name)) 
[10:31:42.209]                               next
[10:31:42.209]                             invokeRestart(restart)
[10:31:42.209]                             muffled <- TRUE
[10:31:42.209]                             break
[10:31:42.209]                           }
[10:31:42.209]                         }
[10:31:42.209]                       }
[10:31:42.209]                       invisible(muffled)
[10:31:42.209]                     }
[10:31:42.209]                     muffleCondition(cond, pattern = "^muffle")
[10:31:42.209]                   }
[10:31:42.209]                 }
[10:31:42.209]                 else {
[10:31:42.209]                   if (TRUE) {
[10:31:42.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:42.209]                     {
[10:31:42.209]                       inherits <- base::inherits
[10:31:42.209]                       invokeRestart <- base::invokeRestart
[10:31:42.209]                       is.null <- base::is.null
[10:31:42.209]                       muffled <- FALSE
[10:31:42.209]                       if (inherits(cond, "message")) {
[10:31:42.209]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:42.209]                         if (muffled) 
[10:31:42.209]                           invokeRestart("muffleMessage")
[10:31:42.209]                       }
[10:31:42.209]                       else if (inherits(cond, "warning")) {
[10:31:42.209]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:42.209]                         if (muffled) 
[10:31:42.209]                           invokeRestart("muffleWarning")
[10:31:42.209]                       }
[10:31:42.209]                       else if (inherits(cond, "condition")) {
[10:31:42.209]                         if (!is.null(pattern)) {
[10:31:42.209]                           computeRestarts <- base::computeRestarts
[10:31:42.209]                           grepl <- base::grepl
[10:31:42.209]                           restarts <- computeRestarts(cond)
[10:31:42.209]                           for (restart in restarts) {
[10:31:42.209]                             name <- restart$name
[10:31:42.209]                             if (is.null(name)) 
[10:31:42.209]                               next
[10:31:42.209]                             if (!grepl(pattern, name)) 
[10:31:42.209]                               next
[10:31:42.209]                             invokeRestart(restart)
[10:31:42.209]                             muffled <- TRUE
[10:31:42.209]                             break
[10:31:42.209]                           }
[10:31:42.209]                         }
[10:31:42.209]                       }
[10:31:42.209]                       invisible(muffled)
[10:31:42.209]                     }
[10:31:42.209]                     muffleCondition(cond, pattern = "^muffle")
[10:31:42.209]                   }
[10:31:42.209]                 }
[10:31:42.209]             }
[10:31:42.209]         }))
[10:31:42.209]     }, error = function(ex) {
[10:31:42.209]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:42.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:42.209]                 ...future.rng), started = ...future.startTime, 
[10:31:42.209]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:42.209]             version = "1.8"), class = "FutureResult")
[10:31:42.209]     }, finally = {
[10:31:42.209]         if (!identical(...future.workdir, getwd())) 
[10:31:42.209]             setwd(...future.workdir)
[10:31:42.209]         {
[10:31:42.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:42.209]                 ...future.oldOptions$nwarnings <- NULL
[10:31:42.209]             }
[10:31:42.209]             base::options(...future.oldOptions)
[10:31:42.209]             if (.Platform$OS.type == "windows") {
[10:31:42.209]                 old_names <- names(...future.oldEnvVars)
[10:31:42.209]                 envs <- base::Sys.getenv()
[10:31:42.209]                 names <- names(envs)
[10:31:42.209]                 common <- intersect(names, old_names)
[10:31:42.209]                 added <- setdiff(names, old_names)
[10:31:42.209]                 removed <- setdiff(old_names, names)
[10:31:42.209]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:42.209]                   envs[common]]
[10:31:42.209]                 NAMES <- toupper(changed)
[10:31:42.209]                 args <- list()
[10:31:42.209]                 for (kk in seq_along(NAMES)) {
[10:31:42.209]                   name <- changed[[kk]]
[10:31:42.209]                   NAME <- NAMES[[kk]]
[10:31:42.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:42.209]                     next
[10:31:42.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:42.209]                 }
[10:31:42.209]                 NAMES <- toupper(added)
[10:31:42.209]                 for (kk in seq_along(NAMES)) {
[10:31:42.209]                   name <- added[[kk]]
[10:31:42.209]                   NAME <- NAMES[[kk]]
[10:31:42.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:42.209]                     next
[10:31:42.209]                   args[[name]] <- ""
[10:31:42.209]                 }
[10:31:42.209]                 NAMES <- toupper(removed)
[10:31:42.209]                 for (kk in seq_along(NAMES)) {
[10:31:42.209]                   name <- removed[[kk]]
[10:31:42.209]                   NAME <- NAMES[[kk]]
[10:31:42.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:42.209]                     next
[10:31:42.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:42.209]                 }
[10:31:42.209]                 if (length(args) > 0) 
[10:31:42.209]                   base::do.call(base::Sys.setenv, args = args)
[10:31:42.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:42.209]             }
[10:31:42.209]             else {
[10:31:42.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:42.209]             }
[10:31:42.209]             {
[10:31:42.209]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:42.209]                   0L) {
[10:31:42.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:42.209]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:42.209]                   base::options(opts)
[10:31:42.209]                 }
[10:31:42.209]                 {
[10:31:42.209]                   {
[10:31:42.209]                     NULL
[10:31:42.209]                     RNGkind("Mersenne-Twister")
[10:31:42.209]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:42.209]                       inherits = FALSE)
[10:31:42.209]                   }
[10:31:42.209]                   options(future.plan = NULL)
[10:31:42.209]                   if (is.na(NA_character_)) 
[10:31:42.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:42.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:42.209]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:42.209]                     .init = FALSE)
[10:31:42.209]                 }
[10:31:42.209]             }
[10:31:42.209]         }
[10:31:42.209]     })
[10:31:42.209]     if (FALSE) {
[10:31:42.209]         base::sink(type = "output", split = FALSE)
[10:31:42.209]         if (NA) {
[10:31:42.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:42.209]         }
[10:31:42.209]         else {
[10:31:42.209]             ...future.result["stdout"] <- base::list(NULL)
[10:31:42.209]         }
[10:31:42.209]         base::close(...future.stdout)
[10:31:42.209]         ...future.stdout <- NULL
[10:31:42.209]     }
[10:31:42.209]     ...future.result$conditions <- ...future.conditions
[10:31:42.209]     ...future.result$finished <- base::Sys.time()
[10:31:42.209]     ...future.result
[10:31:42.209] }
[10:31:42.210] assign_globals() ...
[10:31:42.211] List of 5
[10:31:42.211]  $ ...future.FUN            :function (x, y)  
[10:31:42.211]  $ MoreArgs                 : NULL
[10:31:42.211]  $ ...future.elements_ii    :List of 2
[10:31:42.211]   ..$ :List of 2
[10:31:42.211]   .. ..$ : int 1
[10:31:42.211]   .. ..$ : int 0
[10:31:42.211]   ..$ :List of 2
[10:31:42.211]   .. ..$ : int 0
[10:31:42.211]   .. ..$ : int 1
[10:31:42.211]  $ ...future.seeds_ii       : NULL
[10:31:42.211]  $ ...future.globals.maxSize: NULL
[10:31:42.211]  - attr(*, "where")=List of 5
[10:31:42.211]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:42.211]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:42.211]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:42.211]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:42.211]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:42.211]  - attr(*, "resolved")= logi FALSE
[10:31:42.211]  - attr(*, "total_size")= num 6480
[10:31:42.211]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:42.211]  - attr(*, "already-done")= logi TRUE
[10:31:42.216] - reassign environment for ‘...future.FUN’
[10:31:42.216] - copied ‘...future.FUN’ to environment
[10:31:42.216] - copied ‘MoreArgs’ to environment
[10:31:42.216] - copied ‘...future.elements_ii’ to environment
[10:31:42.217] - copied ‘...future.seeds_ii’ to environment
[10:31:42.217] - copied ‘...future.globals.maxSize’ to environment
[10:31:42.217] assign_globals() ... done
[10:31:42.217] plan(): Setting new future strategy stack:
[10:31:42.217] List of future strategies:
[10:31:42.217] 1. sequential:
[10:31:42.217]    - args: function (..., envir = parent.frame())
[10:31:42.217]    - tweaked: FALSE
[10:31:42.217]    - call: NULL
[10:31:42.218] plan(): nbrOfWorkers() = 1
[10:31:42.719] plan(): Setting new future strategy stack:
[10:31:42.719] List of future strategies:
[10:31:42.719] 1. multicore:
[10:31:42.719]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:42.719]    - tweaked: FALSE
[10:31:42.719]    - call: plan(strategy)
[10:31:42.723] plan(): nbrOfWorkers() = 1
[10:31:42.724] SequentialFuture started (and completed)
[10:31:42.724] - Launch lazy future ... done
[10:31:42.724] run() for ‘SequentialFuture’ ... done
[10:31:42.724] Created future:
[10:31:42.724] SequentialFuture:
[10:31:42.724] Label: ‘future_mapply-1’
[10:31:42.724] Expression:
[10:31:42.724] {
[10:31:42.724]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:42.724]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:42.724]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:42.724]         on.exit(options(oopts), add = TRUE)
[10:31:42.724]     }
[10:31:42.724]     {
[10:31:42.724]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:42.724]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:42.724]         do.call(mapply, args = args)
[10:31:42.724]     }
[10:31:42.724] }
[10:31:42.724] Lazy evaluation: FALSE
[10:31:42.724] Asynchronous evaluation: FALSE
[10:31:42.724] Local evaluation: TRUE
[10:31:42.724] Environment: R_GlobalEnv
[10:31:42.724] Capture standard output: NA
[10:31:42.724] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:42.724] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:42.724] Packages: <none>
[10:31:42.724] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:42.724] Resolved: TRUE
[10:31:42.724] Value: 224 bytes of class ‘list’
[10:31:42.724] Early signaling: FALSE
[10:31:42.724] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:42.724] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:42.725] Chunk #1 of 1 ... DONE
[10:31:42.726] Launching 1 futures (chunks) ... DONE
[10:31:42.726] Resolving 1 futures (chunks) ...
[10:31:42.726] resolve() on list ...
[10:31:42.726]  recursive: 0
[10:31:42.726]  length: 1
[10:31:42.726] 
[10:31:42.726] resolved() for ‘SequentialFuture’ ...
[10:31:42.726] - state: ‘finished’
[10:31:42.726] - run: TRUE
[10:31:42.726] - result: ‘FutureResult’
[10:31:42.727] resolved() for ‘SequentialFuture’ ... done
[10:31:42.727] Future #1
[10:31:42.727] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:42.727] - nx: 1
[10:31:42.727] - relay: TRUE
[10:31:42.727] - stdout: TRUE
[10:31:42.727] - signal: TRUE
[10:31:42.727] - resignal: FALSE
[10:31:42.727] - force: TRUE
[10:31:42.727] - relayed: [n=1] FALSE
[10:31:42.727] - queued futures: [n=1] FALSE
[10:31:42.728]  - until=1
[10:31:42.728]  - relaying element #1
[10:31:42.728] - relayed: [n=1] TRUE
[10:31:42.728] - queued futures: [n=1] TRUE
[10:31:42.728] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:42.728]  length: 0 (resolved future 1)
[10:31:42.728] Relaying remaining futures
[10:31:42.728] signalConditionsASAP(NULL, pos=0) ...
[10:31:42.728] - nx: 1
[10:31:42.729] - relay: TRUE
[10:31:42.729] - stdout: TRUE
[10:31:42.729] - signal: TRUE
[10:31:42.729] - resignal: FALSE
[10:31:42.729] - force: TRUE
[10:31:42.729] - relayed: [n=1] TRUE
[10:31:42.729] - queued futures: [n=1] TRUE
 - flush all
[10:31:42.729] - relayed: [n=1] TRUE
[10:31:42.729] - queued futures: [n=1] TRUE
[10:31:42.729] signalConditionsASAP(NULL, pos=0) ... done
[10:31:42.729] resolve() on list ... DONE
[10:31:42.730]  - Number of value chunks collected: 1
[10:31:42.730] Resolving 1 futures (chunks) ... DONE
[10:31:42.730] Reducing values from 1 chunks ...
[10:31:42.730]  - Number of values collected after concatenation: 2
[10:31:42.730]  - Number of values expected: 2
[10:31:42.730] Reducing values from 1 chunks ... DONE
[10:31:42.758] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[10:31:42.759] plan(): Setting new future strategy stack:
[10:31:42.759] List of future strategies:
[10:31:42.759] 1. multisession:
[10:31:42.759]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:42.759]    - tweaked: FALSE
[10:31:42.759]    - call: plan(strategy)
[10:31:42.760] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:31:42.760] multisession:
[10:31:42.760] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:42.760] - tweaked: FALSE
[10:31:42.760] - call: plan(strategy)
[10:31:42.764] getGlobalsAndPackages() ...
[10:31:42.764] Not searching for globals
[10:31:42.764] - globals: [0] <none>
[10:31:42.764] getGlobalsAndPackages() ... DONE
[10:31:42.765] Packages needed by the future expression (n = 0): <none>
[10:31:42.765] Packages needed by future strategies (n = 0): <none>
[10:31:42.765] {
[10:31:42.765]     {
[10:31:42.765]         {
[10:31:42.765]             ...future.startTime <- base::Sys.time()
[10:31:42.765]             {
[10:31:42.765]                 {
[10:31:42.765]                   {
[10:31:42.765]                     base::local({
[10:31:42.765]                       has_future <- base::requireNamespace("future", 
[10:31:42.765]                         quietly = TRUE)
[10:31:42.765]                       if (has_future) {
[10:31:42.765]                         ns <- base::getNamespace("future")
[10:31:42.765]                         version <- ns[[".package"]][["version"]]
[10:31:42.765]                         if (is.null(version)) 
[10:31:42.765]                           version <- utils::packageVersion("future")
[10:31:42.765]                       }
[10:31:42.765]                       else {
[10:31:42.765]                         version <- NULL
[10:31:42.765]                       }
[10:31:42.765]                       if (!has_future || version < "1.8.0") {
[10:31:42.765]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:42.765]                           "", base::R.version$version.string), 
[10:31:42.765]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:42.765]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:42.765]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:42.765]                             "release", "version")], collapse = " "), 
[10:31:42.765]                           hostname = base::Sys.info()[["nodename"]])
[10:31:42.765]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:42.765]                           info)
[10:31:42.765]                         info <- base::paste(info, collapse = "; ")
[10:31:42.765]                         if (!has_future) {
[10:31:42.765]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:42.765]                             info)
[10:31:42.765]                         }
[10:31:42.765]                         else {
[10:31:42.765]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:42.765]                             info, version)
[10:31:42.765]                         }
[10:31:42.765]                         base::stop(msg)
[10:31:42.765]                       }
[10:31:42.765]                     })
[10:31:42.765]                   }
[10:31:42.765]                   ...future.strategy.old <- future::plan("list")
[10:31:42.765]                   options(future.plan = NULL)
[10:31:42.765]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:42.765]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:42.765]                 }
[10:31:42.765]                 ...future.workdir <- getwd()
[10:31:42.765]             }
[10:31:42.765]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:42.765]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:42.765]         }
[10:31:42.765]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:42.765]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:42.765]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:42.765]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:42.765]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:42.765]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:42.765]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:42.765]             base::names(...future.oldOptions))
[10:31:42.765]     }
[10:31:42.765]     if (FALSE) {
[10:31:42.765]     }
[10:31:42.765]     else {
[10:31:42.765]         if (TRUE) {
[10:31:42.765]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:42.765]                 open = "w")
[10:31:42.765]         }
[10:31:42.765]         else {
[10:31:42.765]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:42.765]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:42.765]         }
[10:31:42.765]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:42.765]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:42.765]             base::sink(type = "output", split = FALSE)
[10:31:42.765]             base::close(...future.stdout)
[10:31:42.765]         }, add = TRUE)
[10:31:42.765]     }
[10:31:42.765]     ...future.frame <- base::sys.nframe()
[10:31:42.765]     ...future.conditions <- base::list()
[10:31:42.765]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:42.765]     if (FALSE) {
[10:31:42.765]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:42.765]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:42.765]     }
[10:31:42.765]     ...future.result <- base::tryCatch({
[10:31:42.765]         base::withCallingHandlers({
[10:31:42.765]             ...future.value <- base::withVisible(base::local(NA))
[10:31:42.765]             future::FutureResult(value = ...future.value$value, 
[10:31:42.765]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:42.765]                   ...future.rng), globalenv = if (FALSE) 
[10:31:42.765]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:42.765]                     ...future.globalenv.names))
[10:31:42.765]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:42.765]         }, condition = base::local({
[10:31:42.765]             c <- base::c
[10:31:42.765]             inherits <- base::inherits
[10:31:42.765]             invokeRestart <- base::invokeRestart
[10:31:42.765]             length <- base::length
[10:31:42.765]             list <- base::list
[10:31:42.765]             seq.int <- base::seq.int
[10:31:42.765]             signalCondition <- base::signalCondition
[10:31:42.765]             sys.calls <- base::sys.calls
[10:31:42.765]             `[[` <- base::`[[`
[10:31:42.765]             `+` <- base::`+`
[10:31:42.765]             `<<-` <- base::`<<-`
[10:31:42.765]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:42.765]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:42.765]                   3L)]
[10:31:42.765]             }
[10:31:42.765]             function(cond) {
[10:31:42.765]                 is_error <- inherits(cond, "error")
[10:31:42.765]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:42.765]                   NULL)
[10:31:42.765]                 if (is_error) {
[10:31:42.765]                   sessionInformation <- function() {
[10:31:42.765]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:42.765]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:42.765]                       search = base::search(), system = base::Sys.info())
[10:31:42.765]                   }
[10:31:42.765]                   ...future.conditions[[length(...future.conditions) + 
[10:31:42.765]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:42.765]                     cond$call), session = sessionInformation(), 
[10:31:42.765]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:42.765]                   signalCondition(cond)
[10:31:42.765]                 }
[10:31:42.765]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:42.765]                 "immediateCondition"))) {
[10:31:42.765]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:42.765]                   ...future.conditions[[length(...future.conditions) + 
[10:31:42.765]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:42.765]                   if (TRUE && !signal) {
[10:31:42.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:42.765]                     {
[10:31:42.765]                       inherits <- base::inherits
[10:31:42.765]                       invokeRestart <- base::invokeRestart
[10:31:42.765]                       is.null <- base::is.null
[10:31:42.765]                       muffled <- FALSE
[10:31:42.765]                       if (inherits(cond, "message")) {
[10:31:42.765]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:42.765]                         if (muffled) 
[10:31:42.765]                           invokeRestart("muffleMessage")
[10:31:42.765]                       }
[10:31:42.765]                       else if (inherits(cond, "warning")) {
[10:31:42.765]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:42.765]                         if (muffled) 
[10:31:42.765]                           invokeRestart("muffleWarning")
[10:31:42.765]                       }
[10:31:42.765]                       else if (inherits(cond, "condition")) {
[10:31:42.765]                         if (!is.null(pattern)) {
[10:31:42.765]                           computeRestarts <- base::computeRestarts
[10:31:42.765]                           grepl <- base::grepl
[10:31:42.765]                           restarts <- computeRestarts(cond)
[10:31:42.765]                           for (restart in restarts) {
[10:31:42.765]                             name <- restart$name
[10:31:42.765]                             if (is.null(name)) 
[10:31:42.765]                               next
[10:31:42.765]                             if (!grepl(pattern, name)) 
[10:31:42.765]                               next
[10:31:42.765]                             invokeRestart(restart)
[10:31:42.765]                             muffled <- TRUE
[10:31:42.765]                             break
[10:31:42.765]                           }
[10:31:42.765]                         }
[10:31:42.765]                       }
[10:31:42.765]                       invisible(muffled)
[10:31:42.765]                     }
[10:31:42.765]                     muffleCondition(cond, pattern = "^muffle")
[10:31:42.765]                   }
[10:31:42.765]                 }
[10:31:42.765]                 else {
[10:31:42.765]                   if (TRUE) {
[10:31:42.765]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:42.765]                     {
[10:31:42.765]                       inherits <- base::inherits
[10:31:42.765]                       invokeRestart <- base::invokeRestart
[10:31:42.765]                       is.null <- base::is.null
[10:31:42.765]                       muffled <- FALSE
[10:31:42.765]                       if (inherits(cond, "message")) {
[10:31:42.765]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:42.765]                         if (muffled) 
[10:31:42.765]                           invokeRestart("muffleMessage")
[10:31:42.765]                       }
[10:31:42.765]                       else if (inherits(cond, "warning")) {
[10:31:42.765]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:42.765]                         if (muffled) 
[10:31:42.765]                           invokeRestart("muffleWarning")
[10:31:42.765]                       }
[10:31:42.765]                       else if (inherits(cond, "condition")) {
[10:31:42.765]                         if (!is.null(pattern)) {
[10:31:42.765]                           computeRestarts <- base::computeRestarts
[10:31:42.765]                           grepl <- base::grepl
[10:31:42.765]                           restarts <- computeRestarts(cond)
[10:31:42.765]                           for (restart in restarts) {
[10:31:42.765]                             name <- restart$name
[10:31:42.765]                             if (is.null(name)) 
[10:31:42.765]                               next
[10:31:42.765]                             if (!grepl(pattern, name)) 
[10:31:42.765]                               next
[10:31:42.765]                             invokeRestart(restart)
[10:31:42.765]                             muffled <- TRUE
[10:31:42.765]                             break
[10:31:42.765]                           }
[10:31:42.765]                         }
[10:31:42.765]                       }
[10:31:42.765]                       invisible(muffled)
[10:31:42.765]                     }
[10:31:42.765]                     muffleCondition(cond, pattern = "^muffle")
[10:31:42.765]                   }
[10:31:42.765]                 }
[10:31:42.765]             }
[10:31:42.765]         }))
[10:31:42.765]     }, error = function(ex) {
[10:31:42.765]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:42.765]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:42.765]                 ...future.rng), started = ...future.startTime, 
[10:31:42.765]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:42.765]             version = "1.8"), class = "FutureResult")
[10:31:42.765]     }, finally = {
[10:31:42.765]         if (!identical(...future.workdir, getwd())) 
[10:31:42.765]             setwd(...future.workdir)
[10:31:42.765]         {
[10:31:42.765]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:42.765]                 ...future.oldOptions$nwarnings <- NULL
[10:31:42.765]             }
[10:31:42.765]             base::options(...future.oldOptions)
[10:31:42.765]             if (.Platform$OS.type == "windows") {
[10:31:42.765]                 old_names <- names(...future.oldEnvVars)
[10:31:42.765]                 envs <- base::Sys.getenv()
[10:31:42.765]                 names <- names(envs)
[10:31:42.765]                 common <- intersect(names, old_names)
[10:31:42.765]                 added <- setdiff(names, old_names)
[10:31:42.765]                 removed <- setdiff(old_names, names)
[10:31:42.765]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:42.765]                   envs[common]]
[10:31:42.765]                 NAMES <- toupper(changed)
[10:31:42.765]                 args <- list()
[10:31:42.765]                 for (kk in seq_along(NAMES)) {
[10:31:42.765]                   name <- changed[[kk]]
[10:31:42.765]                   NAME <- NAMES[[kk]]
[10:31:42.765]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:42.765]                     next
[10:31:42.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:42.765]                 }
[10:31:42.765]                 NAMES <- toupper(added)
[10:31:42.765]                 for (kk in seq_along(NAMES)) {
[10:31:42.765]                   name <- added[[kk]]
[10:31:42.765]                   NAME <- NAMES[[kk]]
[10:31:42.765]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:42.765]                     next
[10:31:42.765]                   args[[name]] <- ""
[10:31:42.765]                 }
[10:31:42.765]                 NAMES <- toupper(removed)
[10:31:42.765]                 for (kk in seq_along(NAMES)) {
[10:31:42.765]                   name <- removed[[kk]]
[10:31:42.765]                   NAME <- NAMES[[kk]]
[10:31:42.765]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:42.765]                     next
[10:31:42.765]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:42.765]                 }
[10:31:42.765]                 if (length(args) > 0) 
[10:31:42.765]                   base::do.call(base::Sys.setenv, args = args)
[10:31:42.765]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:42.765]             }
[10:31:42.765]             else {
[10:31:42.765]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:42.765]             }
[10:31:42.765]             {
[10:31:42.765]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:42.765]                   0L) {
[10:31:42.765]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:42.765]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:42.765]                   base::options(opts)
[10:31:42.765]                 }
[10:31:42.765]                 {
[10:31:42.765]                   {
[10:31:42.765]                     NULL
[10:31:42.765]                     RNGkind("Mersenne-Twister")
[10:31:42.765]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:42.765]                       inherits = FALSE)
[10:31:42.765]                   }
[10:31:42.765]                   options(future.plan = NULL)
[10:31:42.765]                   if (is.na(NA_character_)) 
[10:31:42.765]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:42.765]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:42.765]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:42.765]                     .init = FALSE)
[10:31:42.765]                 }
[10:31:42.765]             }
[10:31:42.765]         }
[10:31:42.765]     })
[10:31:42.765]     if (TRUE) {
[10:31:42.765]         base::sink(type = "output", split = FALSE)
[10:31:42.765]         if (TRUE) {
[10:31:42.765]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:42.765]         }
[10:31:42.765]         else {
[10:31:42.765]             ...future.result["stdout"] <- base::list(NULL)
[10:31:42.765]         }
[10:31:42.765]         base::close(...future.stdout)
[10:31:42.765]         ...future.stdout <- NULL
[10:31:42.765]     }
[10:31:42.765]     ...future.result$conditions <- ...future.conditions
[10:31:42.765]     ...future.result$finished <- base::Sys.time()
[10:31:42.765]     ...future.result
[10:31:42.765] }
[10:31:42.767] plan(): Setting new future strategy stack:
[10:31:42.767] List of future strategies:
[10:31:42.767] 1. sequential:
[10:31:42.767]    - args: function (..., envir = parent.frame())
[10:31:42.767]    - tweaked: FALSE
[10:31:42.767]    - call: NULL
[10:31:42.767] plan(): nbrOfWorkers() = 1
[10:31:42.768] plan(): Setting new future strategy stack:
[10:31:42.768] List of future strategies:
[10:31:42.768] 1. multisession:
[10:31:42.768]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:42.768]    - tweaked: FALSE
[10:31:42.768]    - call: plan(strategy)
[10:31:42.772] plan(): nbrOfWorkers() = 1
[10:31:42.772] SequentialFuture started (and completed)
[10:31:42.772] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:31:42.775] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:31:42.775] future_lapply() ...
[10:31:42.779] Number of chunks: 1
[10:31:42.779] getGlobalsAndPackagesXApply() ...
[10:31:42.779]  - future.globals: TRUE
[10:31:42.780] getGlobalsAndPackages() ...
[10:31:42.780] Searching for globals...
[10:31:42.781] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:42.781] Searching for globals ... DONE
[10:31:42.781] Resolving globals: FALSE
[10:31:42.782] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:42.782] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:42.782] - globals: [1] ‘FUN’
[10:31:42.782] 
[10:31:42.782] getGlobalsAndPackages() ... DONE
[10:31:42.782]  - globals found/used: [n=1] ‘FUN’
[10:31:42.783]  - needed namespaces: [n=0] 
[10:31:42.783] Finding globals ... DONE
[10:31:42.783]  - use_args: TRUE
[10:31:42.783]  - Getting '...' globals ...
[10:31:42.783] resolve() on list ...
[10:31:42.783]  recursive: 0
[10:31:42.783]  length: 1
[10:31:42.783]  elements: ‘...’
[10:31:42.784]  length: 0 (resolved future 1)
[10:31:42.784] resolve() on list ... DONE
[10:31:42.784]    - '...' content: [n=0] 
[10:31:42.784] List of 1
[10:31:42.784]  $ ...: list()
[10:31:42.784]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:42.784]  - attr(*, "where")=List of 1
[10:31:42.784]   ..$ ...:<environment: 0x564ff1d59968> 
[10:31:42.784]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:42.784]  - attr(*, "resolved")= logi TRUE
[10:31:42.784]  - attr(*, "total_size")= num NA
[10:31:42.787]  - Getting '...' globals ... DONE
[10:31:42.787] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:42.787] List of 2
[10:31:42.787]  $ ...future.FUN:function (x)  
[10:31:42.787]  $ ...          : list()
[10:31:42.787]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:42.787]  - attr(*, "where")=List of 2
[10:31:42.787]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:42.787]   ..$ ...          :<environment: 0x564ff1d59968> 
[10:31:42.787]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:42.787]  - attr(*, "resolved")= logi FALSE
[10:31:42.787]  - attr(*, "total_size")= num 4720
[10:31:42.790] Packages to be attached in all futures: [n=0] 
[10:31:42.790] getGlobalsAndPackagesXApply() ... DONE
[10:31:42.790] Number of futures (= number of chunks): 1
[10:31:42.790] Launching 1 futures (chunks) ...
[10:31:42.790] Chunk #1 of 1 ...
[10:31:42.790]  - Finding globals in 'X' for chunk #1 ...
[10:31:42.790] getGlobalsAndPackages() ...
[10:31:42.790] Searching for globals...
[10:31:42.791] 
[10:31:42.791] Searching for globals ... DONE
[10:31:42.791] - globals: [0] <none>
[10:31:42.791] getGlobalsAndPackages() ... DONE
[10:31:42.791]    + additional globals found: [n=0] 
[10:31:42.791]    + additional namespaces needed: [n=0] 
[10:31:42.791]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:42.791]  - seeds: <none>
[10:31:42.791]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:42.792] getGlobalsAndPackages() ...
[10:31:42.792] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:42.792] Resolving globals: FALSE
[10:31:42.792] Tweak future expression to call with '...' arguments ...
[10:31:42.792] {
[10:31:42.792]     do.call(function(...) {
[10:31:42.792]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:42.792]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:42.792]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:42.792]             on.exit(options(oopts), add = TRUE)
[10:31:42.792]         }
[10:31:42.792]         {
[10:31:42.792]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:42.792]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:42.792]                 ...future.FUN(...future.X_jj, ...)
[10:31:42.792]             })
[10:31:42.792]         }
[10:31:42.792]     }, args = future.call.arguments)
[10:31:42.792] }
[10:31:42.792] Tweak future expression to call with '...' arguments ... DONE
[10:31:42.793] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:42.793] 
[10:31:42.793] getGlobalsAndPackages() ... DONE
[10:31:42.793] run() for ‘Future’ ...
[10:31:42.793] - state: ‘created’
[10:31:42.793] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:42.797] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:42.797] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:42.799]   - Field: ‘label’
[10:31:42.799]   - Field: ‘local’
[10:31:42.799]   - Field: ‘owner’
[10:31:42.799]   - Field: ‘envir’
[10:31:42.800]   - Field: ‘packages’
[10:31:42.800]   - Field: ‘gc’
[10:31:42.800]   - Field: ‘conditions’
[10:31:42.800]   - Field: ‘expr’
[10:31:42.800]   - Field: ‘uuid’
[10:31:42.800]   - Field: ‘seed’
[10:31:42.800]   - Field: ‘version’
[10:31:42.800]   - Field: ‘result’
[10:31:42.801]   - Field: ‘asynchronous’
[10:31:42.801]   - Field: ‘calls’
[10:31:42.801]   - Field: ‘globals’
[10:31:42.801]   - Field: ‘stdout’
[10:31:42.801]   - Field: ‘earlySignal’
[10:31:42.801]   - Field: ‘lazy’
[10:31:42.801]   - Field: ‘state’
[10:31:42.801] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:42.802] - Launch lazy future ...
[10:31:42.802] Packages needed by the future expression (n = 0): <none>
[10:31:42.802] Packages needed by future strategies (n = 0): <none>
[10:31:42.802] {
[10:31:42.802]     {
[10:31:42.802]         {
[10:31:42.802]             ...future.startTime <- base::Sys.time()
[10:31:42.802]             {
[10:31:42.802]                 {
[10:31:42.802]                   {
[10:31:42.802]                     base::local({
[10:31:42.802]                       has_future <- base::requireNamespace("future", 
[10:31:42.802]                         quietly = TRUE)
[10:31:42.802]                       if (has_future) {
[10:31:42.802]                         ns <- base::getNamespace("future")
[10:31:42.802]                         version <- ns[[".package"]][["version"]]
[10:31:42.802]                         if (is.null(version)) 
[10:31:42.802]                           version <- utils::packageVersion("future")
[10:31:42.802]                       }
[10:31:42.802]                       else {
[10:31:42.802]                         version <- NULL
[10:31:42.802]                       }
[10:31:42.802]                       if (!has_future || version < "1.8.0") {
[10:31:42.802]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:42.802]                           "", base::R.version$version.string), 
[10:31:42.802]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:42.802]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:42.802]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:42.802]                             "release", "version")], collapse = " "), 
[10:31:42.802]                           hostname = base::Sys.info()[["nodename"]])
[10:31:42.802]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:42.802]                           info)
[10:31:42.802]                         info <- base::paste(info, collapse = "; ")
[10:31:42.802]                         if (!has_future) {
[10:31:42.802]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:42.802]                             info)
[10:31:42.802]                         }
[10:31:42.802]                         else {
[10:31:42.802]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:42.802]                             info, version)
[10:31:42.802]                         }
[10:31:42.802]                         base::stop(msg)
[10:31:42.802]                       }
[10:31:42.802]                     })
[10:31:42.802]                   }
[10:31:42.802]                   ...future.strategy.old <- future::plan("list")
[10:31:42.802]                   options(future.plan = NULL)
[10:31:42.802]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:42.802]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:42.802]                 }
[10:31:42.802]                 ...future.workdir <- getwd()
[10:31:42.802]             }
[10:31:42.802]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:42.802]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:42.802]         }
[10:31:42.802]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:42.802]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:42.802]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:42.802]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:42.802]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:42.802]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:42.802]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:42.802]             base::names(...future.oldOptions))
[10:31:42.802]     }
[10:31:42.802]     if (FALSE) {
[10:31:42.802]     }
[10:31:42.802]     else {
[10:31:42.802]         if (FALSE) {
[10:31:42.802]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:42.802]                 open = "w")
[10:31:42.802]         }
[10:31:42.802]         else {
[10:31:42.802]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:42.802]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:42.802]         }
[10:31:42.802]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:42.802]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:42.802]             base::sink(type = "output", split = FALSE)
[10:31:42.802]             base::close(...future.stdout)
[10:31:42.802]         }, add = TRUE)
[10:31:42.802]     }
[10:31:42.802]     ...future.frame <- base::sys.nframe()
[10:31:42.802]     ...future.conditions <- base::list()
[10:31:42.802]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:42.802]     if (FALSE) {
[10:31:42.802]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:42.802]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:42.802]     }
[10:31:42.802]     ...future.result <- base::tryCatch({
[10:31:42.802]         base::withCallingHandlers({
[10:31:42.802]             ...future.value <- base::withVisible(base::local({
[10:31:42.802]                 do.call(function(...) {
[10:31:42.802]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:42.802]                   if (!identical(...future.globals.maxSize.org, 
[10:31:42.802]                     ...future.globals.maxSize)) {
[10:31:42.802]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:42.802]                     on.exit(options(oopts), add = TRUE)
[10:31:42.802]                   }
[10:31:42.802]                   {
[10:31:42.802]                     lapply(seq_along(...future.elements_ii), 
[10:31:42.802]                       FUN = function(jj) {
[10:31:42.802]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:42.802]                         ...future.FUN(...future.X_jj, ...)
[10:31:42.802]                       })
[10:31:42.802]                   }
[10:31:42.802]                 }, args = future.call.arguments)
[10:31:42.802]             }))
[10:31:42.802]             future::FutureResult(value = ...future.value$value, 
[10:31:42.802]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:42.802]                   ...future.rng), globalenv = if (FALSE) 
[10:31:42.802]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:42.802]                     ...future.globalenv.names))
[10:31:42.802]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:42.802]         }, condition = base::local({
[10:31:42.802]             c <- base::c
[10:31:42.802]             inherits <- base::inherits
[10:31:42.802]             invokeRestart <- base::invokeRestart
[10:31:42.802]             length <- base::length
[10:31:42.802]             list <- base::list
[10:31:42.802]             seq.int <- base::seq.int
[10:31:42.802]             signalCondition <- base::signalCondition
[10:31:42.802]             sys.calls <- base::sys.calls
[10:31:42.802]             `[[` <- base::`[[`
[10:31:42.802]             `+` <- base::`+`
[10:31:42.802]             `<<-` <- base::`<<-`
[10:31:42.802]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:42.802]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:42.802]                   3L)]
[10:31:42.802]             }
[10:31:42.802]             function(cond) {
[10:31:42.802]                 is_error <- inherits(cond, "error")
[10:31:42.802]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:42.802]                   NULL)
[10:31:42.802]                 if (is_error) {
[10:31:42.802]                   sessionInformation <- function() {
[10:31:42.802]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:42.802]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:42.802]                       search = base::search(), system = base::Sys.info())
[10:31:42.802]                   }
[10:31:42.802]                   ...future.conditions[[length(...future.conditions) + 
[10:31:42.802]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:42.802]                     cond$call), session = sessionInformation(), 
[10:31:42.802]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:42.802]                   signalCondition(cond)
[10:31:42.802]                 }
[10:31:42.802]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:42.802]                 "immediateCondition"))) {
[10:31:42.802]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:42.802]                   ...future.conditions[[length(...future.conditions) + 
[10:31:42.802]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:42.802]                   if (TRUE && !signal) {
[10:31:42.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:42.802]                     {
[10:31:42.802]                       inherits <- base::inherits
[10:31:42.802]                       invokeRestart <- base::invokeRestart
[10:31:42.802]                       is.null <- base::is.null
[10:31:42.802]                       muffled <- FALSE
[10:31:42.802]                       if (inherits(cond, "message")) {
[10:31:42.802]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:42.802]                         if (muffled) 
[10:31:42.802]                           invokeRestart("muffleMessage")
[10:31:42.802]                       }
[10:31:42.802]                       else if (inherits(cond, "warning")) {
[10:31:42.802]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:42.802]                         if (muffled) 
[10:31:42.802]                           invokeRestart("muffleWarning")
[10:31:42.802]                       }
[10:31:42.802]                       else if (inherits(cond, "condition")) {
[10:31:42.802]                         if (!is.null(pattern)) {
[10:31:42.802]                           computeRestarts <- base::computeRestarts
[10:31:42.802]                           grepl <- base::grepl
[10:31:42.802]                           restarts <- computeRestarts(cond)
[10:31:42.802]                           for (restart in restarts) {
[10:31:42.802]                             name <- restart$name
[10:31:42.802]                             if (is.null(name)) 
[10:31:42.802]                               next
[10:31:42.802]                             if (!grepl(pattern, name)) 
[10:31:42.802]                               next
[10:31:42.802]                             invokeRestart(restart)
[10:31:42.802]                             muffled <- TRUE
[10:31:42.802]                             break
[10:31:42.802]                           }
[10:31:42.802]                         }
[10:31:42.802]                       }
[10:31:42.802]                       invisible(muffled)
[10:31:42.802]                     }
[10:31:42.802]                     muffleCondition(cond, pattern = "^muffle")
[10:31:42.802]                   }
[10:31:42.802]                 }
[10:31:42.802]                 else {
[10:31:42.802]                   if (TRUE) {
[10:31:42.802]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:42.802]                     {
[10:31:42.802]                       inherits <- base::inherits
[10:31:42.802]                       invokeRestart <- base::invokeRestart
[10:31:42.802]                       is.null <- base::is.null
[10:31:42.802]                       muffled <- FALSE
[10:31:42.802]                       if (inherits(cond, "message")) {
[10:31:42.802]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:42.802]                         if (muffled) 
[10:31:42.802]                           invokeRestart("muffleMessage")
[10:31:42.802]                       }
[10:31:42.802]                       else if (inherits(cond, "warning")) {
[10:31:42.802]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:42.802]                         if (muffled) 
[10:31:42.802]                           invokeRestart("muffleWarning")
[10:31:42.802]                       }
[10:31:42.802]                       else if (inherits(cond, "condition")) {
[10:31:42.802]                         if (!is.null(pattern)) {
[10:31:42.802]                           computeRestarts <- base::computeRestarts
[10:31:42.802]                           grepl <- base::grepl
[10:31:42.802]                           restarts <- computeRestarts(cond)
[10:31:42.802]                           for (restart in restarts) {
[10:31:42.802]                             name <- restart$name
[10:31:42.802]                             if (is.null(name)) 
[10:31:42.802]                               next
[10:31:42.802]                             if (!grepl(pattern, name)) 
[10:31:42.802]                               next
[10:31:42.802]                             invokeRestart(restart)
[10:31:42.802]                             muffled <- TRUE
[10:31:42.802]                             break
[10:31:42.802]                           }
[10:31:42.802]                         }
[10:31:42.802]                       }
[10:31:42.802]                       invisible(muffled)
[10:31:42.802]                     }
[10:31:42.802]                     muffleCondition(cond, pattern = "^muffle")
[10:31:42.802]                   }
[10:31:42.802]                 }
[10:31:42.802]             }
[10:31:42.802]         }))
[10:31:42.802]     }, error = function(ex) {
[10:31:42.802]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:42.802]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:42.802]                 ...future.rng), started = ...future.startTime, 
[10:31:42.802]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:42.802]             version = "1.8"), class = "FutureResult")
[10:31:42.802]     }, finally = {
[10:31:42.802]         if (!identical(...future.workdir, getwd())) 
[10:31:42.802]             setwd(...future.workdir)
[10:31:42.802]         {
[10:31:42.802]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:42.802]                 ...future.oldOptions$nwarnings <- NULL
[10:31:42.802]             }
[10:31:42.802]             base::options(...future.oldOptions)
[10:31:42.802]             if (.Platform$OS.type == "windows") {
[10:31:42.802]                 old_names <- names(...future.oldEnvVars)
[10:31:42.802]                 envs <- base::Sys.getenv()
[10:31:42.802]                 names <- names(envs)
[10:31:42.802]                 common <- intersect(names, old_names)
[10:31:42.802]                 added <- setdiff(names, old_names)
[10:31:42.802]                 removed <- setdiff(old_names, names)
[10:31:42.802]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:42.802]                   envs[common]]
[10:31:42.802]                 NAMES <- toupper(changed)
[10:31:42.802]                 args <- list()
[10:31:42.802]                 for (kk in seq_along(NAMES)) {
[10:31:42.802]                   name <- changed[[kk]]
[10:31:42.802]                   NAME <- NAMES[[kk]]
[10:31:42.802]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:42.802]                     next
[10:31:42.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:42.802]                 }
[10:31:42.802]                 NAMES <- toupper(added)
[10:31:42.802]                 for (kk in seq_along(NAMES)) {
[10:31:42.802]                   name <- added[[kk]]
[10:31:42.802]                   NAME <- NAMES[[kk]]
[10:31:42.802]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:42.802]                     next
[10:31:42.802]                   args[[name]] <- ""
[10:31:42.802]                 }
[10:31:42.802]                 NAMES <- toupper(removed)
[10:31:42.802]                 for (kk in seq_along(NAMES)) {
[10:31:42.802]                   name <- removed[[kk]]
[10:31:42.802]                   NAME <- NAMES[[kk]]
[10:31:42.802]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:42.802]                     next
[10:31:42.802]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:42.802]                 }
[10:31:42.802]                 if (length(args) > 0) 
[10:31:42.802]                   base::do.call(base::Sys.setenv, args = args)
[10:31:42.802]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:42.802]             }
[10:31:42.802]             else {
[10:31:42.802]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:42.802]             }
[10:31:42.802]             {
[10:31:42.802]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:42.802]                   0L) {
[10:31:42.802]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:42.802]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:42.802]                   base::options(opts)
[10:31:42.802]                 }
[10:31:42.802]                 {
[10:31:42.802]                   {
[10:31:42.802]                     NULL
[10:31:42.802]                     RNGkind("Mersenne-Twister")
[10:31:42.802]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:42.802]                       inherits = FALSE)
[10:31:42.802]                   }
[10:31:42.802]                   options(future.plan = NULL)
[10:31:42.802]                   if (is.na(NA_character_)) 
[10:31:42.802]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:42.802]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:42.802]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:42.802]                     .init = FALSE)
[10:31:42.802]                 }
[10:31:42.802]             }
[10:31:42.802]         }
[10:31:42.802]     })
[10:31:42.802]     if (TRUE) {
[10:31:42.802]         base::sink(type = "output", split = FALSE)
[10:31:42.802]         if (FALSE) {
[10:31:42.802]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:42.802]         }
[10:31:42.802]         else {
[10:31:42.802]             ...future.result["stdout"] <- base::list(NULL)
[10:31:42.802]         }
[10:31:42.802]         base::close(...future.stdout)
[10:31:42.802]         ...future.stdout <- NULL
[10:31:42.802]     }
[10:31:42.802]     ...future.result$conditions <- ...future.conditions
[10:31:42.802]     ...future.result$finished <- base::Sys.time()
[10:31:42.802]     ...future.result
[10:31:42.802] }
[10:31:42.804] assign_globals() ...
[10:31:42.804] List of 5
[10:31:42.804]  $ ...future.FUN            :function (x)  
[10:31:42.804]  $ future.call.arguments    : list()
[10:31:42.804]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:42.804]  $ ...future.elements_ii    :List of 2
[10:31:42.804]   ..$ : int 1
[10:31:42.804]   ..$ : int 0
[10:31:42.804]  $ ...future.seeds_ii       : NULL
[10:31:42.804]  $ ...future.globals.maxSize: NULL
[10:31:42.804]  - attr(*, "where")=List of 5
[10:31:42.804]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:42.804]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:42.804]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:42.804]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:42.804]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:42.804]  - attr(*, "resolved")= logi FALSE
[10:31:42.804]  - attr(*, "total_size")= num 4720
[10:31:42.804]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:42.804]  - attr(*, "already-done")= logi TRUE
[10:31:42.809] - reassign environment for ‘...future.FUN’
[10:31:42.809] - copied ‘...future.FUN’ to environment
[10:31:42.810] - copied ‘future.call.arguments’ to environment
[10:31:42.810] - copied ‘...future.elements_ii’ to environment
[10:31:42.810] - copied ‘...future.seeds_ii’ to environment
[10:31:42.810] - copied ‘...future.globals.maxSize’ to environment
[10:31:42.810] assign_globals() ... done
[10:31:42.810] plan(): Setting new future strategy stack:
[10:31:42.810] List of future strategies:
[10:31:42.810] 1. sequential:
[10:31:42.810]    - args: function (..., envir = parent.frame())
[10:31:42.810]    - tweaked: FALSE
[10:31:42.810]    - call: NULL
[10:31:42.811] plan(): nbrOfWorkers() = 1
[10:31:43.312] plan(): Setting new future strategy stack:
[10:31:43.313] List of future strategies:
[10:31:43.313] 1. multisession:
[10:31:43.313]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:43.313]    - tweaked: FALSE
[10:31:43.313]    - call: plan(strategy)
[10:31:43.317] plan(): nbrOfWorkers() = 1
[10:31:43.317] SequentialFuture started (and completed)
[10:31:43.317] - Launch lazy future ... done
[10:31:43.317] run() for ‘SequentialFuture’ ... done
[10:31:43.317] Created future:
[10:31:43.317] SequentialFuture:
[10:31:43.317] Label: ‘future_lapply-1’
[10:31:43.317] Expression:
[10:31:43.317] {
[10:31:43.317]     do.call(function(...) {
[10:31:43.317]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:43.317]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:43.317]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:43.317]             on.exit(options(oopts), add = TRUE)
[10:31:43.317]         }
[10:31:43.317]         {
[10:31:43.317]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:43.317]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:43.317]                 ...future.FUN(...future.X_jj, ...)
[10:31:43.317]             })
[10:31:43.317]         }
[10:31:43.317]     }, args = future.call.arguments)
[10:31:43.317] }
[10:31:43.317] Lazy evaluation: FALSE
[10:31:43.317] Asynchronous evaluation: FALSE
[10:31:43.317] Local evaluation: TRUE
[10:31:43.317] Environment: R_GlobalEnv
[10:31:43.317] Capture standard output: FALSE
[10:31:43.317] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:43.317] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:43.317] Packages: <none>
[10:31:43.317] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:43.317] Resolved: TRUE
[10:31:43.317] Value: 112 bytes of class ‘list’
[10:31:43.317] Early signaling: FALSE
[10:31:43.317] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:43.317] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:43.318] Chunk #1 of 1 ... DONE
[10:31:43.319] Launching 1 futures (chunks) ... DONE
[10:31:43.319] Resolving 1 futures (chunks) ...
[10:31:43.319] resolve() on list ...
[10:31:43.319]  recursive: 0
[10:31:43.319]  length: 1
[10:31:43.319] 
[10:31:43.319] resolved() for ‘SequentialFuture’ ...
[10:31:43.319] - state: ‘finished’
[10:31:43.319] - run: TRUE
[10:31:43.319] - result: ‘FutureResult’
[10:31:43.320] resolved() for ‘SequentialFuture’ ... done
[10:31:43.320] Future #1
[10:31:43.320] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:43.320] - nx: 1
[10:31:43.320] - relay: TRUE
[10:31:43.320] - stdout: TRUE
[10:31:43.320] - signal: TRUE
[10:31:43.320] - resignal: FALSE
[10:31:43.320] - force: TRUE
[10:31:43.320] - relayed: [n=1] FALSE
[10:31:43.320] - queued futures: [n=1] FALSE
[10:31:43.321]  - until=1
[10:31:43.321]  - relaying element #1
[10:31:43.321] - relayed: [n=1] TRUE
[10:31:43.321] - queued futures: [n=1] TRUE
[10:31:43.321] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:43.321]  length: 0 (resolved future 1)
[10:31:43.321] Relaying remaining futures
[10:31:43.321] signalConditionsASAP(NULL, pos=0) ...
[10:31:43.321] - nx: 1
[10:31:43.322] - relay: TRUE
[10:31:43.322] - stdout: TRUE
[10:31:43.322] - signal: TRUE
[10:31:43.322] - resignal: FALSE
[10:31:43.322] - force: TRUE
[10:31:43.322] - relayed: [n=1] TRUE
[10:31:43.322] - queued futures: [n=1] TRUE
 - flush all
[10:31:43.322] - relayed: [n=1] TRUE
[10:31:43.322] - queued futures: [n=1] TRUE
[10:31:43.322] signalConditionsASAP(NULL, pos=0) ... done
[10:31:43.322] resolve() on list ... DONE
[10:31:43.323]  - Number of value chunks collected: 1
[10:31:43.323] Resolving 1 futures (chunks) ... DONE
[10:31:43.323] Reducing values from 1 chunks ...
[10:31:43.323]  - Number of values collected after concatenation: 2
[10:31:43.323]  - Number of values expected: 2
[10:31:43.323] Reducing values from 1 chunks ... DONE
[10:31:43.323] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:31:43.324] future_lapply() ...
[10:31:43.328] Number of chunks: 1
[10:31:43.328] getGlobalsAndPackagesXApply() ...
[10:31:43.328]  - future.globals: TRUE
[10:31:43.328] getGlobalsAndPackages() ...
[10:31:43.328] Searching for globals...
[10:31:43.330] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:43.330] Searching for globals ... DONE
[10:31:43.330] Resolving globals: FALSE
[10:31:43.331] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:43.331] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:43.331] - globals: [1] ‘FUN’
[10:31:43.331] 
[10:31:43.331] getGlobalsAndPackages() ... DONE
[10:31:43.332]  - globals found/used: [n=1] ‘FUN’
[10:31:43.332]  - needed namespaces: [n=0] 
[10:31:43.332] Finding globals ... DONE
[10:31:43.332]  - use_args: TRUE
[10:31:43.332]  - Getting '...' globals ...
[10:31:43.332] resolve() on list ...
[10:31:43.332]  recursive: 0
[10:31:43.332]  length: 1
[10:31:43.333]  elements: ‘...’
[10:31:43.333]  length: 0 (resolved future 1)
[10:31:43.335] resolve() on list ... DONE
[10:31:43.335]    - '...' content: [n=0] 
[10:31:43.335] List of 1
[10:31:43.335]  $ ...: list()
[10:31:43.335]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:43.335]  - attr(*, "where")=List of 1
[10:31:43.335]   ..$ ...:<environment: 0x564ff3ecf890> 
[10:31:43.335]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:43.335]  - attr(*, "resolved")= logi TRUE
[10:31:43.335]  - attr(*, "total_size")= num NA
[10:31:43.338]  - Getting '...' globals ... DONE
[10:31:43.338] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:43.338] List of 2
[10:31:43.338]  $ ...future.FUN:function (x)  
[10:31:43.338]  $ ...          : list()
[10:31:43.338]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:43.338]  - attr(*, "where")=List of 2
[10:31:43.338]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:43.338]   ..$ ...          :<environment: 0x564ff3ecf890> 
[10:31:43.338]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:43.338]  - attr(*, "resolved")= logi FALSE
[10:31:43.338]  - attr(*, "total_size")= num 4720
[10:31:43.341] Packages to be attached in all futures: [n=0] 
[10:31:43.341] getGlobalsAndPackagesXApply() ... DONE
[10:31:43.341] Number of futures (= number of chunks): 1
[10:31:43.341] Launching 1 futures (chunks) ...
[10:31:43.341] Chunk #1 of 1 ...
[10:31:43.342]  - Finding globals in 'X' for chunk #1 ...
[10:31:43.342] getGlobalsAndPackages() ...
[10:31:43.342] Searching for globals...
[10:31:43.342] 
[10:31:43.342] Searching for globals ... DONE
[10:31:43.342] - globals: [0] <none>
[10:31:43.342] getGlobalsAndPackages() ... DONE
[10:31:43.342]    + additional globals found: [n=0] 
[10:31:43.343]    + additional namespaces needed: [n=0] 
[10:31:43.343]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:43.343]  - seeds: <none>
[10:31:43.343]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:43.343] getGlobalsAndPackages() ...
[10:31:43.343] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:43.343] Resolving globals: FALSE
[10:31:43.343] Tweak future expression to call with '...' arguments ...
[10:31:43.343] {
[10:31:43.343]     do.call(function(...) {
[10:31:43.343]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:43.343]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:43.343]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:43.343]             on.exit(options(oopts), add = TRUE)
[10:31:43.343]         }
[10:31:43.343]         {
[10:31:43.343]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:43.343]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:43.343]                 ...future.FUN(...future.X_jj, ...)
[10:31:43.343]             })
[10:31:43.343]         }
[10:31:43.343]     }, args = future.call.arguments)
[10:31:43.343] }
[10:31:43.344] Tweak future expression to call with '...' arguments ... DONE
[10:31:43.344] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:43.344] 
[10:31:43.344] getGlobalsAndPackages() ... DONE
[10:31:43.345] run() for ‘Future’ ...
[10:31:43.345] - state: ‘created’
[10:31:43.345] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:43.348] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:43.348] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:43.349]   - Field: ‘label’
[10:31:43.349]   - Field: ‘local’
[10:31:43.349]   - Field: ‘owner’
[10:31:43.349]   - Field: ‘envir’
[10:31:43.349]   - Field: ‘packages’
[10:31:43.349]   - Field: ‘gc’
[10:31:43.349]   - Field: ‘conditions’
[10:31:43.349]   - Field: ‘expr’
[10:31:43.349]   - Field: ‘uuid’
[10:31:43.350]   - Field: ‘seed’
[10:31:43.350]   - Field: ‘version’
[10:31:43.350]   - Field: ‘result’
[10:31:43.350]   - Field: ‘asynchronous’
[10:31:43.350]   - Field: ‘calls’
[10:31:43.350]   - Field: ‘globals’
[10:31:43.350]   - Field: ‘stdout’
[10:31:43.350]   - Field: ‘earlySignal’
[10:31:43.350]   - Field: ‘lazy’
[10:31:43.350]   - Field: ‘state’
[10:31:43.350] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:43.351] - Launch lazy future ...
[10:31:43.351] Packages needed by the future expression (n = 0): <none>
[10:31:43.351] Packages needed by future strategies (n = 0): <none>
[10:31:43.351] {
[10:31:43.351]     {
[10:31:43.351]         {
[10:31:43.351]             ...future.startTime <- base::Sys.time()
[10:31:43.351]             {
[10:31:43.351]                 {
[10:31:43.351]                   {
[10:31:43.351]                     base::local({
[10:31:43.351]                       has_future <- base::requireNamespace("future", 
[10:31:43.351]                         quietly = TRUE)
[10:31:43.351]                       if (has_future) {
[10:31:43.351]                         ns <- base::getNamespace("future")
[10:31:43.351]                         version <- ns[[".package"]][["version"]]
[10:31:43.351]                         if (is.null(version)) 
[10:31:43.351]                           version <- utils::packageVersion("future")
[10:31:43.351]                       }
[10:31:43.351]                       else {
[10:31:43.351]                         version <- NULL
[10:31:43.351]                       }
[10:31:43.351]                       if (!has_future || version < "1.8.0") {
[10:31:43.351]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:43.351]                           "", base::R.version$version.string), 
[10:31:43.351]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:43.351]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:43.351]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:43.351]                             "release", "version")], collapse = " "), 
[10:31:43.351]                           hostname = base::Sys.info()[["nodename"]])
[10:31:43.351]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:43.351]                           info)
[10:31:43.351]                         info <- base::paste(info, collapse = "; ")
[10:31:43.351]                         if (!has_future) {
[10:31:43.351]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:43.351]                             info)
[10:31:43.351]                         }
[10:31:43.351]                         else {
[10:31:43.351]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:43.351]                             info, version)
[10:31:43.351]                         }
[10:31:43.351]                         base::stop(msg)
[10:31:43.351]                       }
[10:31:43.351]                     })
[10:31:43.351]                   }
[10:31:43.351]                   ...future.strategy.old <- future::plan("list")
[10:31:43.351]                   options(future.plan = NULL)
[10:31:43.351]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:43.351]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:43.351]                 }
[10:31:43.351]                 ...future.workdir <- getwd()
[10:31:43.351]             }
[10:31:43.351]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:43.351]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:43.351]         }
[10:31:43.351]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:43.351]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:43.351]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:43.351]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:43.351]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:43.351]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:43.351]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:43.351]             base::names(...future.oldOptions))
[10:31:43.351]     }
[10:31:43.351]     if (FALSE) {
[10:31:43.351]     }
[10:31:43.351]     else {
[10:31:43.351]         if (TRUE) {
[10:31:43.351]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:43.351]                 open = "w")
[10:31:43.351]         }
[10:31:43.351]         else {
[10:31:43.351]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:43.351]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:43.351]         }
[10:31:43.351]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:43.351]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:43.351]             base::sink(type = "output", split = FALSE)
[10:31:43.351]             base::close(...future.stdout)
[10:31:43.351]         }, add = TRUE)
[10:31:43.351]     }
[10:31:43.351]     ...future.frame <- base::sys.nframe()
[10:31:43.351]     ...future.conditions <- base::list()
[10:31:43.351]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:43.351]     if (FALSE) {
[10:31:43.351]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:43.351]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:43.351]     }
[10:31:43.351]     ...future.result <- base::tryCatch({
[10:31:43.351]         base::withCallingHandlers({
[10:31:43.351]             ...future.value <- base::withVisible(base::local({
[10:31:43.351]                 do.call(function(...) {
[10:31:43.351]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:43.351]                   if (!identical(...future.globals.maxSize.org, 
[10:31:43.351]                     ...future.globals.maxSize)) {
[10:31:43.351]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:43.351]                     on.exit(options(oopts), add = TRUE)
[10:31:43.351]                   }
[10:31:43.351]                   {
[10:31:43.351]                     lapply(seq_along(...future.elements_ii), 
[10:31:43.351]                       FUN = function(jj) {
[10:31:43.351]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:43.351]                         ...future.FUN(...future.X_jj, ...)
[10:31:43.351]                       })
[10:31:43.351]                   }
[10:31:43.351]                 }, args = future.call.arguments)
[10:31:43.351]             }))
[10:31:43.351]             future::FutureResult(value = ...future.value$value, 
[10:31:43.351]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:43.351]                   ...future.rng), globalenv = if (FALSE) 
[10:31:43.351]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:43.351]                     ...future.globalenv.names))
[10:31:43.351]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:43.351]         }, condition = base::local({
[10:31:43.351]             c <- base::c
[10:31:43.351]             inherits <- base::inherits
[10:31:43.351]             invokeRestart <- base::invokeRestart
[10:31:43.351]             length <- base::length
[10:31:43.351]             list <- base::list
[10:31:43.351]             seq.int <- base::seq.int
[10:31:43.351]             signalCondition <- base::signalCondition
[10:31:43.351]             sys.calls <- base::sys.calls
[10:31:43.351]             `[[` <- base::`[[`
[10:31:43.351]             `+` <- base::`+`
[10:31:43.351]             `<<-` <- base::`<<-`
[10:31:43.351]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:43.351]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:43.351]                   3L)]
[10:31:43.351]             }
[10:31:43.351]             function(cond) {
[10:31:43.351]                 is_error <- inherits(cond, "error")
[10:31:43.351]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:43.351]                   NULL)
[10:31:43.351]                 if (is_error) {
[10:31:43.351]                   sessionInformation <- function() {
[10:31:43.351]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:43.351]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:43.351]                       search = base::search(), system = base::Sys.info())
[10:31:43.351]                   }
[10:31:43.351]                   ...future.conditions[[length(...future.conditions) + 
[10:31:43.351]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:43.351]                     cond$call), session = sessionInformation(), 
[10:31:43.351]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:43.351]                   signalCondition(cond)
[10:31:43.351]                 }
[10:31:43.351]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:43.351]                 "immediateCondition"))) {
[10:31:43.351]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:43.351]                   ...future.conditions[[length(...future.conditions) + 
[10:31:43.351]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:43.351]                   if (TRUE && !signal) {
[10:31:43.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:43.351]                     {
[10:31:43.351]                       inherits <- base::inherits
[10:31:43.351]                       invokeRestart <- base::invokeRestart
[10:31:43.351]                       is.null <- base::is.null
[10:31:43.351]                       muffled <- FALSE
[10:31:43.351]                       if (inherits(cond, "message")) {
[10:31:43.351]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:43.351]                         if (muffled) 
[10:31:43.351]                           invokeRestart("muffleMessage")
[10:31:43.351]                       }
[10:31:43.351]                       else if (inherits(cond, "warning")) {
[10:31:43.351]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:43.351]                         if (muffled) 
[10:31:43.351]                           invokeRestart("muffleWarning")
[10:31:43.351]                       }
[10:31:43.351]                       else if (inherits(cond, "condition")) {
[10:31:43.351]                         if (!is.null(pattern)) {
[10:31:43.351]                           computeRestarts <- base::computeRestarts
[10:31:43.351]                           grepl <- base::grepl
[10:31:43.351]                           restarts <- computeRestarts(cond)
[10:31:43.351]                           for (restart in restarts) {
[10:31:43.351]                             name <- restart$name
[10:31:43.351]                             if (is.null(name)) 
[10:31:43.351]                               next
[10:31:43.351]                             if (!grepl(pattern, name)) 
[10:31:43.351]                               next
[10:31:43.351]                             invokeRestart(restart)
[10:31:43.351]                             muffled <- TRUE
[10:31:43.351]                             break
[10:31:43.351]                           }
[10:31:43.351]                         }
[10:31:43.351]                       }
[10:31:43.351]                       invisible(muffled)
[10:31:43.351]                     }
[10:31:43.351]                     muffleCondition(cond, pattern = "^muffle")
[10:31:43.351]                   }
[10:31:43.351]                 }
[10:31:43.351]                 else {
[10:31:43.351]                   if (TRUE) {
[10:31:43.351]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:43.351]                     {
[10:31:43.351]                       inherits <- base::inherits
[10:31:43.351]                       invokeRestart <- base::invokeRestart
[10:31:43.351]                       is.null <- base::is.null
[10:31:43.351]                       muffled <- FALSE
[10:31:43.351]                       if (inherits(cond, "message")) {
[10:31:43.351]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:43.351]                         if (muffled) 
[10:31:43.351]                           invokeRestart("muffleMessage")
[10:31:43.351]                       }
[10:31:43.351]                       else if (inherits(cond, "warning")) {
[10:31:43.351]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:43.351]                         if (muffled) 
[10:31:43.351]                           invokeRestart("muffleWarning")
[10:31:43.351]                       }
[10:31:43.351]                       else if (inherits(cond, "condition")) {
[10:31:43.351]                         if (!is.null(pattern)) {
[10:31:43.351]                           computeRestarts <- base::computeRestarts
[10:31:43.351]                           grepl <- base::grepl
[10:31:43.351]                           restarts <- computeRestarts(cond)
[10:31:43.351]                           for (restart in restarts) {
[10:31:43.351]                             name <- restart$name
[10:31:43.351]                             if (is.null(name)) 
[10:31:43.351]                               next
[10:31:43.351]                             if (!grepl(pattern, name)) 
[10:31:43.351]                               next
[10:31:43.351]                             invokeRestart(restart)
[10:31:43.351]                             muffled <- TRUE
[10:31:43.351]                             break
[10:31:43.351]                           }
[10:31:43.351]                         }
[10:31:43.351]                       }
[10:31:43.351]                       invisible(muffled)
[10:31:43.351]                     }
[10:31:43.351]                     muffleCondition(cond, pattern = "^muffle")
[10:31:43.351]                   }
[10:31:43.351]                 }
[10:31:43.351]             }
[10:31:43.351]         }))
[10:31:43.351]     }, error = function(ex) {
[10:31:43.351]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:43.351]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:43.351]                 ...future.rng), started = ...future.startTime, 
[10:31:43.351]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:43.351]             version = "1.8"), class = "FutureResult")
[10:31:43.351]     }, finally = {
[10:31:43.351]         if (!identical(...future.workdir, getwd())) 
[10:31:43.351]             setwd(...future.workdir)
[10:31:43.351]         {
[10:31:43.351]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:43.351]                 ...future.oldOptions$nwarnings <- NULL
[10:31:43.351]             }
[10:31:43.351]             base::options(...future.oldOptions)
[10:31:43.351]             if (.Platform$OS.type == "windows") {
[10:31:43.351]                 old_names <- names(...future.oldEnvVars)
[10:31:43.351]                 envs <- base::Sys.getenv()
[10:31:43.351]                 names <- names(envs)
[10:31:43.351]                 common <- intersect(names, old_names)
[10:31:43.351]                 added <- setdiff(names, old_names)
[10:31:43.351]                 removed <- setdiff(old_names, names)
[10:31:43.351]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:43.351]                   envs[common]]
[10:31:43.351]                 NAMES <- toupper(changed)
[10:31:43.351]                 args <- list()
[10:31:43.351]                 for (kk in seq_along(NAMES)) {
[10:31:43.351]                   name <- changed[[kk]]
[10:31:43.351]                   NAME <- NAMES[[kk]]
[10:31:43.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:43.351]                     next
[10:31:43.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:43.351]                 }
[10:31:43.351]                 NAMES <- toupper(added)
[10:31:43.351]                 for (kk in seq_along(NAMES)) {
[10:31:43.351]                   name <- added[[kk]]
[10:31:43.351]                   NAME <- NAMES[[kk]]
[10:31:43.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:43.351]                     next
[10:31:43.351]                   args[[name]] <- ""
[10:31:43.351]                 }
[10:31:43.351]                 NAMES <- toupper(removed)
[10:31:43.351]                 for (kk in seq_along(NAMES)) {
[10:31:43.351]                   name <- removed[[kk]]
[10:31:43.351]                   NAME <- NAMES[[kk]]
[10:31:43.351]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:43.351]                     next
[10:31:43.351]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:43.351]                 }
[10:31:43.351]                 if (length(args) > 0) 
[10:31:43.351]                   base::do.call(base::Sys.setenv, args = args)
[10:31:43.351]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:43.351]             }
[10:31:43.351]             else {
[10:31:43.351]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:43.351]             }
[10:31:43.351]             {
[10:31:43.351]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:43.351]                   0L) {
[10:31:43.351]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:43.351]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:43.351]                   base::options(opts)
[10:31:43.351]                 }
[10:31:43.351]                 {
[10:31:43.351]                   {
[10:31:43.351]                     NULL
[10:31:43.351]                     RNGkind("Mersenne-Twister")
[10:31:43.351]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:43.351]                       inherits = FALSE)
[10:31:43.351]                   }
[10:31:43.351]                   options(future.plan = NULL)
[10:31:43.351]                   if (is.na(NA_character_)) 
[10:31:43.351]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:43.351]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:43.351]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:43.351]                     .init = FALSE)
[10:31:43.351]                 }
[10:31:43.351]             }
[10:31:43.351]         }
[10:31:43.351]     })
[10:31:43.351]     if (TRUE) {
[10:31:43.351]         base::sink(type = "output", split = FALSE)
[10:31:43.351]         if (TRUE) {
[10:31:43.351]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:43.351]         }
[10:31:43.351]         else {
[10:31:43.351]             ...future.result["stdout"] <- base::list(NULL)
[10:31:43.351]         }
[10:31:43.351]         base::close(...future.stdout)
[10:31:43.351]         ...future.stdout <- NULL
[10:31:43.351]     }
[10:31:43.351]     ...future.result$conditions <- ...future.conditions
[10:31:43.351]     ...future.result$finished <- base::Sys.time()
[10:31:43.351]     ...future.result
[10:31:43.351] }
[10:31:43.353] assign_globals() ...
[10:31:43.353] List of 5
[10:31:43.353]  $ ...future.FUN            :function (x)  
[10:31:43.353]  $ future.call.arguments    : list()
[10:31:43.353]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:43.353]  $ ...future.elements_ii    :List of 2
[10:31:43.353]   ..$ : int 1
[10:31:43.353]   ..$ : int 0
[10:31:43.353]  $ ...future.seeds_ii       : NULL
[10:31:43.353]  $ ...future.globals.maxSize: NULL
[10:31:43.353]  - attr(*, "where")=List of 5
[10:31:43.353]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:43.353]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:43.353]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:43.353]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:43.353]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:43.353]  - attr(*, "resolved")= logi FALSE
[10:31:43.353]  - attr(*, "total_size")= num 4720
[10:31:43.353]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:43.353]  - attr(*, "already-done")= logi TRUE
[10:31:43.358] - reassign environment for ‘...future.FUN’
[10:31:43.358] - copied ‘...future.FUN’ to environment
[10:31:43.358] - copied ‘future.call.arguments’ to environment
[10:31:43.358] - copied ‘...future.elements_ii’ to environment
[10:31:43.359] - copied ‘...future.seeds_ii’ to environment
[10:31:43.359] - copied ‘...future.globals.maxSize’ to environment
[10:31:43.359] assign_globals() ... done
[10:31:43.359] plan(): Setting new future strategy stack:
[10:31:43.359] List of future strategies:
[10:31:43.359] 1. sequential:
[10:31:43.359]    - args: function (..., envir = parent.frame())
[10:31:43.359]    - tweaked: FALSE
[10:31:43.359]    - call: NULL
[10:31:43.359] plan(): nbrOfWorkers() = 1
[10:31:43.861] plan(): Setting new future strategy stack:
[10:31:43.861] List of future strategies:
[10:31:43.861] 1. multisession:
[10:31:43.861]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:43.861]    - tweaked: FALSE
[10:31:43.861]    - call: plan(strategy)
[10:31:43.866] plan(): nbrOfWorkers() = 1
[10:31:43.866] SequentialFuture started (and completed)
[10:31:43.866] - Launch lazy future ... done
[10:31:43.866] run() for ‘SequentialFuture’ ... done
[10:31:43.866] Created future:
[10:31:43.866] SequentialFuture:
[10:31:43.866] Label: ‘future_lapply-1’
[10:31:43.866] Expression:
[10:31:43.866] {
[10:31:43.866]     do.call(function(...) {
[10:31:43.866]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:43.866]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:43.866]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:43.866]             on.exit(options(oopts), add = TRUE)
[10:31:43.866]         }
[10:31:43.866]         {
[10:31:43.866]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:43.866]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:43.866]                 ...future.FUN(...future.X_jj, ...)
[10:31:43.866]             })
[10:31:43.866]         }
[10:31:43.866]     }, args = future.call.arguments)
[10:31:43.866] }
[10:31:43.866] Lazy evaluation: FALSE
[10:31:43.866] Asynchronous evaluation: FALSE
[10:31:43.866] Local evaluation: TRUE
[10:31:43.866] Environment: R_GlobalEnv
[10:31:43.866] Capture standard output: TRUE
[10:31:43.866] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:43.866] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:43.866] Packages: <none>
[10:31:43.866] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:43.866] Resolved: TRUE
[10:31:43.866] Value: 112 bytes of class ‘list’
[10:31:43.866] Early signaling: FALSE
[10:31:43.866] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:43.866] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:43.867] Chunk #1 of 1 ... DONE
[10:31:43.869] Launching 1 futures (chunks) ... DONE
[10:31:43.869] Resolving 1 futures (chunks) ...
[10:31:43.869] resolve() on list ...
[10:31:43.870]  recursive: 0
[10:31:43.870]  length: 1
[10:31:43.870] 
[10:31:43.870] resolved() for ‘SequentialFuture’ ...
[10:31:43.870] - state: ‘finished’
[10:31:43.870] - run: TRUE
[10:31:43.870] - result: ‘FutureResult’
[10:31:43.870] resolved() for ‘SequentialFuture’ ... done
[10:31:43.871] Future #1
[10:31:43.871] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:43.871] - nx: 1
[10:31:43.871] - relay: TRUE
[10:31:43.871] - stdout: TRUE
[10:31:43.871] - signal: TRUE
[10:31:43.871] - resignal: FALSE
[10:31:43.871] - force: TRUE
[10:31:43.871] - relayed: [n=1] FALSE
[10:31:43.872] - queued futures: [n=1] FALSE
[10:31:43.872]  - until=1
[10:31:43.872]  - relaying element #1
[10:31:43.872] - relayed: [n=1] TRUE
[10:31:43.872] - queued futures: [n=1] TRUE
[10:31:43.872] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:43.872]  length: 0 (resolved future 1)
[10:31:43.872] Relaying remaining futures
[10:31:43.872] signalConditionsASAP(NULL, pos=0) ...
[10:31:43.873] - nx: 1
[10:31:43.873] - relay: TRUE
[10:31:43.873] - stdout: TRUE
[10:31:43.873] - signal: TRUE
[10:31:43.873] - resignal: FALSE
[10:31:43.873] - force: TRUE
[10:31:43.873] - relayed: [n=1] TRUE
[10:31:43.873] - queued futures: [n=1] TRUE
 - flush all
[10:31:43.873] - relayed: [n=1] TRUE
[10:31:43.873] - queued futures: [n=1] TRUE
[10:31:43.874] signalConditionsASAP(NULL, pos=0) ... done
[10:31:43.874] resolve() on list ... DONE
[10:31:43.874]  - Number of value chunks collected: 1
[10:31:43.874] Resolving 1 futures (chunks) ... DONE
[10:31:43.874] Reducing values from 1 chunks ...
[10:31:43.874]  - Number of values collected after concatenation: 2
[10:31:43.874]  - Number of values expected: 2
[10:31:43.874] Reducing values from 1 chunks ... DONE
[10:31:43.874] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:31:43.875] future_lapply() ...
[10:31:43.879] Number of chunks: 1
[10:31:43.879] getGlobalsAndPackagesXApply() ...
[10:31:43.879]  - future.globals: TRUE
[10:31:43.879] getGlobalsAndPackages() ...
[10:31:43.879] Searching for globals...
[10:31:43.881] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:43.881] Searching for globals ... DONE
[10:31:43.881] Resolving globals: FALSE
[10:31:43.881] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:43.882] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:43.882] - globals: [1] ‘FUN’
[10:31:43.882] 
[10:31:43.882] getGlobalsAndPackages() ... DONE
[10:31:43.882]  - globals found/used: [n=1] ‘FUN’
[10:31:43.882]  - needed namespaces: [n=0] 
[10:31:43.882] Finding globals ... DONE
[10:31:43.882]  - use_args: TRUE
[10:31:43.883]  - Getting '...' globals ...
[10:31:43.883] resolve() on list ...
[10:31:43.883]  recursive: 0
[10:31:43.883]  length: 1
[10:31:43.883]  elements: ‘...’
[10:31:43.883]  length: 0 (resolved future 1)
[10:31:43.883] resolve() on list ... DONE
[10:31:43.884]    - '...' content: [n=0] 
[10:31:43.884] List of 1
[10:31:43.884]  $ ...: list()
[10:31:43.884]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:43.884]  - attr(*, "where")=List of 1
[10:31:43.884]   ..$ ...:<environment: 0x564ff27b2fa0> 
[10:31:43.884]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:43.884]  - attr(*, "resolved")= logi TRUE
[10:31:43.884]  - attr(*, "total_size")= num NA
[10:31:43.886]  - Getting '...' globals ... DONE
[10:31:43.886] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:43.887] List of 2
[10:31:43.887]  $ ...future.FUN:function (x)  
[10:31:43.887]  $ ...          : list()
[10:31:43.887]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:43.887]  - attr(*, "where")=List of 2
[10:31:43.887]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:43.887]   ..$ ...          :<environment: 0x564ff27b2fa0> 
[10:31:43.887]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:43.887]  - attr(*, "resolved")= logi FALSE
[10:31:43.887]  - attr(*, "total_size")= num 4720
[10:31:43.889] Packages to be attached in all futures: [n=0] 
[10:31:43.889] getGlobalsAndPackagesXApply() ... DONE
[10:31:43.890] Number of futures (= number of chunks): 1
[10:31:43.890] Launching 1 futures (chunks) ...
[10:31:43.890] Chunk #1 of 1 ...
[10:31:43.890]  - Finding globals in 'X' for chunk #1 ...
[10:31:43.890] getGlobalsAndPackages() ...
[10:31:43.890] Searching for globals...
[10:31:43.890] 
[10:31:43.891] Searching for globals ... DONE
[10:31:43.891] - globals: [0] <none>
[10:31:43.891] getGlobalsAndPackages() ... DONE
[10:31:43.891]    + additional globals found: [n=0] 
[10:31:43.891]    + additional namespaces needed: [n=0] 
[10:31:43.891]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:43.891]  - seeds: <none>
[10:31:43.891]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:43.891] getGlobalsAndPackages() ...
[10:31:43.891] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:43.892] Resolving globals: FALSE
[10:31:43.892] Tweak future expression to call with '...' arguments ...
[10:31:43.892] {
[10:31:43.892]     do.call(function(...) {
[10:31:43.892]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:43.892]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:43.892]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:43.892]             on.exit(options(oopts), add = TRUE)
[10:31:43.892]         }
[10:31:43.892]         {
[10:31:43.892]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:43.892]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:43.892]                 ...future.FUN(...future.X_jj, ...)
[10:31:43.892]             })
[10:31:43.892]         }
[10:31:43.892]     }, args = future.call.arguments)
[10:31:43.892] }
[10:31:43.892] Tweak future expression to call with '...' arguments ... DONE
[10:31:43.892] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:43.893] 
[10:31:43.893] getGlobalsAndPackages() ... DONE
[10:31:43.893] run() for ‘Future’ ...
[10:31:43.893] - state: ‘created’
[10:31:43.893] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:43.897] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:43.897] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:43.897]   - Field: ‘label’
[10:31:43.897]   - Field: ‘local’
[10:31:43.898]   - Field: ‘owner’
[10:31:43.898]   - Field: ‘envir’
[10:31:43.898]   - Field: ‘packages’
[10:31:43.898]   - Field: ‘gc’
[10:31:43.898]   - Field: ‘conditions’
[10:31:43.898]   - Field: ‘expr’
[10:31:43.898]   - Field: ‘uuid’
[10:31:43.898]   - Field: ‘seed’
[10:31:43.898]   - Field: ‘version’
[10:31:43.898]   - Field: ‘result’
[10:31:43.898]   - Field: ‘asynchronous’
[10:31:43.899]   - Field: ‘calls’
[10:31:43.899]   - Field: ‘globals’
[10:31:43.899]   - Field: ‘stdout’
[10:31:43.899]   - Field: ‘earlySignal’
[10:31:43.899]   - Field: ‘lazy’
[10:31:43.899]   - Field: ‘state’
[10:31:43.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:43.901] - Launch lazy future ...
[10:31:43.901] Packages needed by the future expression (n = 0): <none>
[10:31:43.901] Packages needed by future strategies (n = 0): <none>
[10:31:43.902] {
[10:31:43.902]     {
[10:31:43.902]         {
[10:31:43.902]             ...future.startTime <- base::Sys.time()
[10:31:43.902]             {
[10:31:43.902]                 {
[10:31:43.902]                   {
[10:31:43.902]                     base::local({
[10:31:43.902]                       has_future <- base::requireNamespace("future", 
[10:31:43.902]                         quietly = TRUE)
[10:31:43.902]                       if (has_future) {
[10:31:43.902]                         ns <- base::getNamespace("future")
[10:31:43.902]                         version <- ns[[".package"]][["version"]]
[10:31:43.902]                         if (is.null(version)) 
[10:31:43.902]                           version <- utils::packageVersion("future")
[10:31:43.902]                       }
[10:31:43.902]                       else {
[10:31:43.902]                         version <- NULL
[10:31:43.902]                       }
[10:31:43.902]                       if (!has_future || version < "1.8.0") {
[10:31:43.902]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:43.902]                           "", base::R.version$version.string), 
[10:31:43.902]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:43.902]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:43.902]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:43.902]                             "release", "version")], collapse = " "), 
[10:31:43.902]                           hostname = base::Sys.info()[["nodename"]])
[10:31:43.902]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:43.902]                           info)
[10:31:43.902]                         info <- base::paste(info, collapse = "; ")
[10:31:43.902]                         if (!has_future) {
[10:31:43.902]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:43.902]                             info)
[10:31:43.902]                         }
[10:31:43.902]                         else {
[10:31:43.902]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:43.902]                             info, version)
[10:31:43.902]                         }
[10:31:43.902]                         base::stop(msg)
[10:31:43.902]                       }
[10:31:43.902]                     })
[10:31:43.902]                   }
[10:31:43.902]                   ...future.strategy.old <- future::plan("list")
[10:31:43.902]                   options(future.plan = NULL)
[10:31:43.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:43.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:43.902]                 }
[10:31:43.902]                 ...future.workdir <- getwd()
[10:31:43.902]             }
[10:31:43.902]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:43.902]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:43.902]         }
[10:31:43.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:43.902]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:43.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:43.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:43.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:43.902]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:43.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:43.902]             base::names(...future.oldOptions))
[10:31:43.902]     }
[10:31:43.902]     if (TRUE) {
[10:31:43.902]     }
[10:31:43.902]     else {
[10:31:43.902]         if (NA) {
[10:31:43.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:43.902]                 open = "w")
[10:31:43.902]         }
[10:31:43.902]         else {
[10:31:43.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:43.902]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:43.902]         }
[10:31:43.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:43.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:43.902]             base::sink(type = "output", split = FALSE)
[10:31:43.902]             base::close(...future.stdout)
[10:31:43.902]         }, add = TRUE)
[10:31:43.902]     }
[10:31:43.902]     ...future.frame <- base::sys.nframe()
[10:31:43.902]     ...future.conditions <- base::list()
[10:31:43.902]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:43.902]     if (FALSE) {
[10:31:43.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:43.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:43.902]     }
[10:31:43.902]     ...future.result <- base::tryCatch({
[10:31:43.902]         base::withCallingHandlers({
[10:31:43.902]             ...future.value <- base::withVisible(base::local({
[10:31:43.902]                 do.call(function(...) {
[10:31:43.902]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:43.902]                   if (!identical(...future.globals.maxSize.org, 
[10:31:43.902]                     ...future.globals.maxSize)) {
[10:31:43.902]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:43.902]                     on.exit(options(oopts), add = TRUE)
[10:31:43.902]                   }
[10:31:43.902]                   {
[10:31:43.902]                     lapply(seq_along(...future.elements_ii), 
[10:31:43.902]                       FUN = function(jj) {
[10:31:43.902]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:43.902]                         ...future.FUN(...future.X_jj, ...)
[10:31:43.902]                       })
[10:31:43.902]                   }
[10:31:43.902]                 }, args = future.call.arguments)
[10:31:43.902]             }))
[10:31:43.902]             future::FutureResult(value = ...future.value$value, 
[10:31:43.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:43.902]                   ...future.rng), globalenv = if (FALSE) 
[10:31:43.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:43.902]                     ...future.globalenv.names))
[10:31:43.902]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:43.902]         }, condition = base::local({
[10:31:43.902]             c <- base::c
[10:31:43.902]             inherits <- base::inherits
[10:31:43.902]             invokeRestart <- base::invokeRestart
[10:31:43.902]             length <- base::length
[10:31:43.902]             list <- base::list
[10:31:43.902]             seq.int <- base::seq.int
[10:31:43.902]             signalCondition <- base::signalCondition
[10:31:43.902]             sys.calls <- base::sys.calls
[10:31:43.902]             `[[` <- base::`[[`
[10:31:43.902]             `+` <- base::`+`
[10:31:43.902]             `<<-` <- base::`<<-`
[10:31:43.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:43.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:43.902]                   3L)]
[10:31:43.902]             }
[10:31:43.902]             function(cond) {
[10:31:43.902]                 is_error <- inherits(cond, "error")
[10:31:43.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:43.902]                   NULL)
[10:31:43.902]                 if (is_error) {
[10:31:43.902]                   sessionInformation <- function() {
[10:31:43.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:43.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:43.902]                       search = base::search(), system = base::Sys.info())
[10:31:43.902]                   }
[10:31:43.902]                   ...future.conditions[[length(...future.conditions) + 
[10:31:43.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:43.902]                     cond$call), session = sessionInformation(), 
[10:31:43.902]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:43.902]                   signalCondition(cond)
[10:31:43.902]                 }
[10:31:43.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:43.902]                 "immediateCondition"))) {
[10:31:43.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:43.902]                   ...future.conditions[[length(...future.conditions) + 
[10:31:43.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:43.902]                   if (TRUE && !signal) {
[10:31:43.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:43.902]                     {
[10:31:43.902]                       inherits <- base::inherits
[10:31:43.902]                       invokeRestart <- base::invokeRestart
[10:31:43.902]                       is.null <- base::is.null
[10:31:43.902]                       muffled <- FALSE
[10:31:43.902]                       if (inherits(cond, "message")) {
[10:31:43.902]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:43.902]                         if (muffled) 
[10:31:43.902]                           invokeRestart("muffleMessage")
[10:31:43.902]                       }
[10:31:43.902]                       else if (inherits(cond, "warning")) {
[10:31:43.902]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:43.902]                         if (muffled) 
[10:31:43.902]                           invokeRestart("muffleWarning")
[10:31:43.902]                       }
[10:31:43.902]                       else if (inherits(cond, "condition")) {
[10:31:43.902]                         if (!is.null(pattern)) {
[10:31:43.902]                           computeRestarts <- base::computeRestarts
[10:31:43.902]                           grepl <- base::grepl
[10:31:43.902]                           restarts <- computeRestarts(cond)
[10:31:43.902]                           for (restart in restarts) {
[10:31:43.902]                             name <- restart$name
[10:31:43.902]                             if (is.null(name)) 
[10:31:43.902]                               next
[10:31:43.902]                             if (!grepl(pattern, name)) 
[10:31:43.902]                               next
[10:31:43.902]                             invokeRestart(restart)
[10:31:43.902]                             muffled <- TRUE
[10:31:43.902]                             break
[10:31:43.902]                           }
[10:31:43.902]                         }
[10:31:43.902]                       }
[10:31:43.902]                       invisible(muffled)
[10:31:43.902]                     }
[10:31:43.902]                     muffleCondition(cond, pattern = "^muffle")
[10:31:43.902]                   }
[10:31:43.902]                 }
[10:31:43.902]                 else {
[10:31:43.902]                   if (TRUE) {
[10:31:43.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:43.902]                     {
[10:31:43.902]                       inherits <- base::inherits
[10:31:43.902]                       invokeRestart <- base::invokeRestart
[10:31:43.902]                       is.null <- base::is.null
[10:31:43.902]                       muffled <- FALSE
[10:31:43.902]                       if (inherits(cond, "message")) {
[10:31:43.902]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:43.902]                         if (muffled) 
[10:31:43.902]                           invokeRestart("muffleMessage")
[10:31:43.902]                       }
[10:31:43.902]                       else if (inherits(cond, "warning")) {
[10:31:43.902]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:43.902]                         if (muffled) 
[10:31:43.902]                           invokeRestart("muffleWarning")
[10:31:43.902]                       }
[10:31:43.902]                       else if (inherits(cond, "condition")) {
[10:31:43.902]                         if (!is.null(pattern)) {
[10:31:43.902]                           computeRestarts <- base::computeRestarts
[10:31:43.902]                           grepl <- base::grepl
[10:31:43.902]                           restarts <- computeRestarts(cond)
[10:31:43.902]                           for (restart in restarts) {
[10:31:43.902]                             name <- restart$name
[10:31:43.902]                             if (is.null(name)) 
[10:31:43.902]                               next
[10:31:43.902]                             if (!grepl(pattern, name)) 
[10:31:43.902]                               next
[10:31:43.902]                             invokeRestart(restart)
[10:31:43.902]                             muffled <- TRUE
[10:31:43.902]                             break
[10:31:43.902]                           }
[10:31:43.902]                         }
[10:31:43.902]                       }
[10:31:43.902]                       invisible(muffled)
[10:31:43.902]                     }
[10:31:43.902]                     muffleCondition(cond, pattern = "^muffle")
[10:31:43.902]                   }
[10:31:43.902]                 }
[10:31:43.902]             }
[10:31:43.902]         }))
[10:31:43.902]     }, error = function(ex) {
[10:31:43.902]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:43.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:43.902]                 ...future.rng), started = ...future.startTime, 
[10:31:43.902]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:43.902]             version = "1.8"), class = "FutureResult")
[10:31:43.902]     }, finally = {
[10:31:43.902]         if (!identical(...future.workdir, getwd())) 
[10:31:43.902]             setwd(...future.workdir)
[10:31:43.902]         {
[10:31:43.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:43.902]                 ...future.oldOptions$nwarnings <- NULL
[10:31:43.902]             }
[10:31:43.902]             base::options(...future.oldOptions)
[10:31:43.902]             if (.Platform$OS.type == "windows") {
[10:31:43.902]                 old_names <- names(...future.oldEnvVars)
[10:31:43.902]                 envs <- base::Sys.getenv()
[10:31:43.902]                 names <- names(envs)
[10:31:43.902]                 common <- intersect(names, old_names)
[10:31:43.902]                 added <- setdiff(names, old_names)
[10:31:43.902]                 removed <- setdiff(old_names, names)
[10:31:43.902]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:43.902]                   envs[common]]
[10:31:43.902]                 NAMES <- toupper(changed)
[10:31:43.902]                 args <- list()
[10:31:43.902]                 for (kk in seq_along(NAMES)) {
[10:31:43.902]                   name <- changed[[kk]]
[10:31:43.902]                   NAME <- NAMES[[kk]]
[10:31:43.902]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:43.902]                     next
[10:31:43.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:43.902]                 }
[10:31:43.902]                 NAMES <- toupper(added)
[10:31:43.902]                 for (kk in seq_along(NAMES)) {
[10:31:43.902]                   name <- added[[kk]]
[10:31:43.902]                   NAME <- NAMES[[kk]]
[10:31:43.902]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:43.902]                     next
[10:31:43.902]                   args[[name]] <- ""
[10:31:43.902]                 }
[10:31:43.902]                 NAMES <- toupper(removed)
[10:31:43.902]                 for (kk in seq_along(NAMES)) {
[10:31:43.902]                   name <- removed[[kk]]
[10:31:43.902]                   NAME <- NAMES[[kk]]
[10:31:43.902]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:43.902]                     next
[10:31:43.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:43.902]                 }
[10:31:43.902]                 if (length(args) > 0) 
[10:31:43.902]                   base::do.call(base::Sys.setenv, args = args)
[10:31:43.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:43.902]             }
[10:31:43.902]             else {
[10:31:43.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:43.902]             }
[10:31:43.902]             {
[10:31:43.902]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:43.902]                   0L) {
[10:31:43.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:43.902]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:43.902]                   base::options(opts)
[10:31:43.902]                 }
[10:31:43.902]                 {
[10:31:43.902]                   {
[10:31:43.902]                     NULL
[10:31:43.902]                     RNGkind("Mersenne-Twister")
[10:31:43.902]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:43.902]                       inherits = FALSE)
[10:31:43.902]                   }
[10:31:43.902]                   options(future.plan = NULL)
[10:31:43.902]                   if (is.na(NA_character_)) 
[10:31:43.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:43.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:43.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:43.902]                     .init = FALSE)
[10:31:43.902]                 }
[10:31:43.902]             }
[10:31:43.902]         }
[10:31:43.902]     })
[10:31:43.902]     if (FALSE) {
[10:31:43.902]         base::sink(type = "output", split = FALSE)
[10:31:43.902]         if (NA) {
[10:31:43.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:43.902]         }
[10:31:43.902]         else {
[10:31:43.902]             ...future.result["stdout"] <- base::list(NULL)
[10:31:43.902]         }
[10:31:43.902]         base::close(...future.stdout)
[10:31:43.902]         ...future.stdout <- NULL
[10:31:43.902]     }
[10:31:43.902]     ...future.result$conditions <- ...future.conditions
[10:31:43.902]     ...future.result$finished <- base::Sys.time()
[10:31:43.902]     ...future.result
[10:31:43.902] }
[10:31:43.904] assign_globals() ...
[10:31:43.904] List of 5
[10:31:43.904]  $ ...future.FUN            :function (x)  
[10:31:43.904]  $ future.call.arguments    : list()
[10:31:43.904]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:43.904]  $ ...future.elements_ii    :List of 2
[10:31:43.904]   ..$ : int 1
[10:31:43.904]   ..$ : int 0
[10:31:43.904]  $ ...future.seeds_ii       : NULL
[10:31:43.904]  $ ...future.globals.maxSize: NULL
[10:31:43.904]  - attr(*, "where")=List of 5
[10:31:43.904]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:43.904]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:43.904]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:43.904]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:43.904]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:43.904]  - attr(*, "resolved")= logi FALSE
[10:31:43.904]  - attr(*, "total_size")= num 4720
[10:31:43.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:43.904]  - attr(*, "already-done")= logi TRUE
[10:31:43.909] - reassign environment for ‘...future.FUN’
[10:31:43.909] - copied ‘...future.FUN’ to environment
[10:31:43.910] - copied ‘future.call.arguments’ to environment
[10:31:43.910] - copied ‘...future.elements_ii’ to environment
[10:31:43.910] - copied ‘...future.seeds_ii’ to environment
[10:31:43.910] - copied ‘...future.globals.maxSize’ to environment
[10:31:43.910] assign_globals() ... done
[10:31:43.910] plan(): Setting new future strategy stack:
[10:31:43.910] List of future strategies:
[10:31:43.910] 1. sequential:
[10:31:43.910]    - args: function (..., envir = parent.frame())
[10:31:43.910]    - tweaked: FALSE
[10:31:43.910]    - call: NULL
[10:31:43.911] plan(): nbrOfWorkers() = 1
[10:31:44.412] plan(): Setting new future strategy stack:
[10:31:44.412] List of future strategies:
[10:31:44.412] 1. multisession:
[10:31:44.412]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:44.412]    - tweaked: FALSE
[10:31:44.412]    - call: plan(strategy)
[10:31:44.416] plan(): nbrOfWorkers() = 1
[10:31:44.416] SequentialFuture started (and completed)
[10:31:44.417] - Launch lazy future ... done
[10:31:44.417] run() for ‘SequentialFuture’ ... done
[10:31:44.417] Created future:
[10:31:44.417] SequentialFuture:
[10:31:44.417] Label: ‘future_lapply-1’
[10:31:44.417] Expression:
[10:31:44.417] {
[10:31:44.417]     do.call(function(...) {
[10:31:44.417]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:44.417]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:44.417]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:44.417]             on.exit(options(oopts), add = TRUE)
[10:31:44.417]         }
[10:31:44.417]         {
[10:31:44.417]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:44.417]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:44.417]                 ...future.FUN(...future.X_jj, ...)
[10:31:44.417]             })
[10:31:44.417]         }
[10:31:44.417]     }, args = future.call.arguments)
[10:31:44.417] }
[10:31:44.417] Lazy evaluation: FALSE
[10:31:44.417] Asynchronous evaluation: FALSE
[10:31:44.417] Local evaluation: TRUE
[10:31:44.417] Environment: R_GlobalEnv
[10:31:44.417] Capture standard output: NA
[10:31:44.417] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:44.417] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:44.417] Packages: <none>
[10:31:44.417] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:44.417] Resolved: TRUE
[10:31:44.417] Value: 112 bytes of class ‘list’
[10:31:44.417] Early signaling: FALSE
[10:31:44.417] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:44.417] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:44.418] Chunk #1 of 1 ... DONE
[10:31:44.418] Launching 1 futures (chunks) ... DONE
[10:31:44.418] Resolving 1 futures (chunks) ...
[10:31:44.418] resolve() on list ...
[10:31:44.418]  recursive: 0
[10:31:44.419]  length: 1
[10:31:44.419] 
[10:31:44.419] resolved() for ‘SequentialFuture’ ...
[10:31:44.419] - state: ‘finished’
[10:31:44.419] - run: TRUE
[10:31:44.419] - result: ‘FutureResult’
[10:31:44.419] resolved() for ‘SequentialFuture’ ... done
[10:31:44.419] Future #1
[10:31:44.419] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:44.420] - nx: 1
[10:31:44.420] - relay: TRUE
[10:31:44.420] - stdout: TRUE
[10:31:44.420] - signal: TRUE
[10:31:44.420] - resignal: FALSE
[10:31:44.420] - force: TRUE
[10:31:44.420] - relayed: [n=1] FALSE
[10:31:44.420] - queued futures: [n=1] FALSE
[10:31:44.420]  - until=1
[10:31:44.420]  - relaying element #1
[10:31:44.420] - relayed: [n=1] TRUE
[10:31:44.421] - queued futures: [n=1] TRUE
[10:31:44.421] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:44.421]  length: 0 (resolved future 1)
[10:31:44.421] Relaying remaining futures
[10:31:44.421] signalConditionsASAP(NULL, pos=0) ...
[10:31:44.421] - nx: 1
[10:31:44.421] - relay: TRUE
[10:31:44.421] - stdout: TRUE
[10:31:44.421] - signal: TRUE
[10:31:44.421] - resignal: FALSE
[10:31:44.421] - force: TRUE
[10:31:44.422] - relayed: [n=1] TRUE
[10:31:44.422] - queued futures: [n=1] TRUE
 - flush all
[10:31:44.422] - relayed: [n=1] TRUE
[10:31:44.422] - queued futures: [n=1] TRUE
[10:31:44.422] signalConditionsASAP(NULL, pos=0) ... done
[10:31:44.422] resolve() on list ... DONE
[10:31:44.422]  - Number of value chunks collected: 1
[10:31:44.422] Resolving 1 futures (chunks) ... DONE
[10:31:44.422] Reducing values from 1 chunks ...
[10:31:44.422]  - Number of values collected after concatenation: 2
[10:31:44.423]  - Number of values expected: 2
[10:31:44.423] Reducing values from 1 chunks ... DONE
[10:31:44.423] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:31:44.423] future_mapply() ...
[10:31:44.426] Number of chunks: 1
[10:31:44.427] getGlobalsAndPackagesXApply() ...
[10:31:44.427]  - future.globals: TRUE
[10:31:44.427] getGlobalsAndPackages() ...
[10:31:44.427] Searching for globals...
[10:31:44.428] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:44.429] Searching for globals ... DONE
[10:31:44.429] Resolving globals: FALSE
[10:31:44.429] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:44.429] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:44.430] - globals: [1] ‘FUN’
[10:31:44.430] 
[10:31:44.430] getGlobalsAndPackages() ... DONE
[10:31:44.430]  - globals found/used: [n=1] ‘FUN’
[10:31:44.430]  - needed namespaces: [n=0] 
[10:31:44.430] Finding globals ... DONE
[10:31:44.430] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:44.430] List of 2
[10:31:44.430]  $ ...future.FUN:function (x, y)  
[10:31:44.430]  $ MoreArgs     : NULL
[10:31:44.430]  - attr(*, "where")=List of 2
[10:31:44.430]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:44.430]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:44.430]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:44.430]  - attr(*, "resolved")= logi FALSE
[10:31:44.430]  - attr(*, "total_size")= num NA
[10:31:44.433] Packages to be attached in all futures: [n=0] 
[10:31:44.435] getGlobalsAndPackagesXApply() ... DONE
[10:31:44.435] Number of futures (= number of chunks): 1
[10:31:44.435] Launching 1 futures (chunks) ...
[10:31:44.435] Chunk #1 of 1 ...
[10:31:44.435]  - Finding globals in '...' for chunk #1 ...
[10:31:44.435] getGlobalsAndPackages() ...
[10:31:44.436] Searching for globals...
[10:31:44.436] 
[10:31:44.436] Searching for globals ... DONE
[10:31:44.436] - globals: [0] <none>
[10:31:44.436] getGlobalsAndPackages() ... DONE
[10:31:44.436]    + additional globals found: [n=0] 
[10:31:44.437]    + additional namespaces needed: [n=0] 
[10:31:44.437]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:44.437]  - seeds: <none>
[10:31:44.437]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:44.437] getGlobalsAndPackages() ...
[10:31:44.437] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:44.437] Resolving globals: FALSE
[10:31:44.438] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:31:44.438] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:44.438] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:44.439] 
[10:31:44.439] getGlobalsAndPackages() ... DONE
[10:31:44.439] run() for ‘Future’ ...
[10:31:44.439] - state: ‘created’
[10:31:44.439] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:44.443] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:44.443] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:44.443]   - Field: ‘label’
[10:31:44.443]   - Field: ‘local’
[10:31:44.443]   - Field: ‘owner’
[10:31:44.443]   - Field: ‘envir’
[10:31:44.443]   - Field: ‘packages’
[10:31:44.444]   - Field: ‘gc’
[10:31:44.444]   - Field: ‘conditions’
[10:31:44.444]   - Field: ‘expr’
[10:31:44.444]   - Field: ‘uuid’
[10:31:44.444]   - Field: ‘seed’
[10:31:44.444]   - Field: ‘version’
[10:31:44.444]   - Field: ‘result’
[10:31:44.444]   - Field: ‘asynchronous’
[10:31:44.444]   - Field: ‘calls’
[10:31:44.444]   - Field: ‘globals’
[10:31:44.444]   - Field: ‘stdout’
[10:31:44.445]   - Field: ‘earlySignal’
[10:31:44.445]   - Field: ‘lazy’
[10:31:44.445]   - Field: ‘state’
[10:31:44.445] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:44.445] - Launch lazy future ...
[10:31:44.445] Packages needed by the future expression (n = 0): <none>
[10:31:44.445] Packages needed by future strategies (n = 0): <none>
[10:31:44.446] {
[10:31:44.446]     {
[10:31:44.446]         {
[10:31:44.446]             ...future.startTime <- base::Sys.time()
[10:31:44.446]             {
[10:31:44.446]                 {
[10:31:44.446]                   {
[10:31:44.446]                     base::local({
[10:31:44.446]                       has_future <- base::requireNamespace("future", 
[10:31:44.446]                         quietly = TRUE)
[10:31:44.446]                       if (has_future) {
[10:31:44.446]                         ns <- base::getNamespace("future")
[10:31:44.446]                         version <- ns[[".package"]][["version"]]
[10:31:44.446]                         if (is.null(version)) 
[10:31:44.446]                           version <- utils::packageVersion("future")
[10:31:44.446]                       }
[10:31:44.446]                       else {
[10:31:44.446]                         version <- NULL
[10:31:44.446]                       }
[10:31:44.446]                       if (!has_future || version < "1.8.0") {
[10:31:44.446]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:44.446]                           "", base::R.version$version.string), 
[10:31:44.446]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:44.446]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:44.446]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:44.446]                             "release", "version")], collapse = " "), 
[10:31:44.446]                           hostname = base::Sys.info()[["nodename"]])
[10:31:44.446]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:44.446]                           info)
[10:31:44.446]                         info <- base::paste(info, collapse = "; ")
[10:31:44.446]                         if (!has_future) {
[10:31:44.446]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:44.446]                             info)
[10:31:44.446]                         }
[10:31:44.446]                         else {
[10:31:44.446]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:44.446]                             info, version)
[10:31:44.446]                         }
[10:31:44.446]                         base::stop(msg)
[10:31:44.446]                       }
[10:31:44.446]                     })
[10:31:44.446]                   }
[10:31:44.446]                   ...future.strategy.old <- future::plan("list")
[10:31:44.446]                   options(future.plan = NULL)
[10:31:44.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:44.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:44.446]                 }
[10:31:44.446]                 ...future.workdir <- getwd()
[10:31:44.446]             }
[10:31:44.446]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:44.446]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:44.446]         }
[10:31:44.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:44.446]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:44.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:44.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:44.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:44.446]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:44.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:44.446]             base::names(...future.oldOptions))
[10:31:44.446]     }
[10:31:44.446]     if (FALSE) {
[10:31:44.446]     }
[10:31:44.446]     else {
[10:31:44.446]         if (FALSE) {
[10:31:44.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:44.446]                 open = "w")
[10:31:44.446]         }
[10:31:44.446]         else {
[10:31:44.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:44.446]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:44.446]         }
[10:31:44.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:44.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:44.446]             base::sink(type = "output", split = FALSE)
[10:31:44.446]             base::close(...future.stdout)
[10:31:44.446]         }, add = TRUE)
[10:31:44.446]     }
[10:31:44.446]     ...future.frame <- base::sys.nframe()
[10:31:44.446]     ...future.conditions <- base::list()
[10:31:44.446]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:44.446]     if (FALSE) {
[10:31:44.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:44.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:44.446]     }
[10:31:44.446]     ...future.result <- base::tryCatch({
[10:31:44.446]         base::withCallingHandlers({
[10:31:44.446]             ...future.value <- base::withVisible(base::local({
[10:31:44.446]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:44.446]                 if (!identical(...future.globals.maxSize.org, 
[10:31:44.446]                   ...future.globals.maxSize)) {
[10:31:44.446]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:44.446]                   on.exit(options(oopts), add = TRUE)
[10:31:44.446]                 }
[10:31:44.446]                 {
[10:31:44.446]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:44.446]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:44.446]                     USE.NAMES = FALSE)
[10:31:44.446]                   do.call(mapply, args = args)
[10:31:44.446]                 }
[10:31:44.446]             }))
[10:31:44.446]             future::FutureResult(value = ...future.value$value, 
[10:31:44.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:44.446]                   ...future.rng), globalenv = if (FALSE) 
[10:31:44.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:44.446]                     ...future.globalenv.names))
[10:31:44.446]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:44.446]         }, condition = base::local({
[10:31:44.446]             c <- base::c
[10:31:44.446]             inherits <- base::inherits
[10:31:44.446]             invokeRestart <- base::invokeRestart
[10:31:44.446]             length <- base::length
[10:31:44.446]             list <- base::list
[10:31:44.446]             seq.int <- base::seq.int
[10:31:44.446]             signalCondition <- base::signalCondition
[10:31:44.446]             sys.calls <- base::sys.calls
[10:31:44.446]             `[[` <- base::`[[`
[10:31:44.446]             `+` <- base::`+`
[10:31:44.446]             `<<-` <- base::`<<-`
[10:31:44.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:44.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:44.446]                   3L)]
[10:31:44.446]             }
[10:31:44.446]             function(cond) {
[10:31:44.446]                 is_error <- inherits(cond, "error")
[10:31:44.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:44.446]                   NULL)
[10:31:44.446]                 if (is_error) {
[10:31:44.446]                   sessionInformation <- function() {
[10:31:44.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:44.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:44.446]                       search = base::search(), system = base::Sys.info())
[10:31:44.446]                   }
[10:31:44.446]                   ...future.conditions[[length(...future.conditions) + 
[10:31:44.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:44.446]                     cond$call), session = sessionInformation(), 
[10:31:44.446]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:44.446]                   signalCondition(cond)
[10:31:44.446]                 }
[10:31:44.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:44.446]                 "immediateCondition"))) {
[10:31:44.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:44.446]                   ...future.conditions[[length(...future.conditions) + 
[10:31:44.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:44.446]                   if (TRUE && !signal) {
[10:31:44.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:44.446]                     {
[10:31:44.446]                       inherits <- base::inherits
[10:31:44.446]                       invokeRestart <- base::invokeRestart
[10:31:44.446]                       is.null <- base::is.null
[10:31:44.446]                       muffled <- FALSE
[10:31:44.446]                       if (inherits(cond, "message")) {
[10:31:44.446]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:44.446]                         if (muffled) 
[10:31:44.446]                           invokeRestart("muffleMessage")
[10:31:44.446]                       }
[10:31:44.446]                       else if (inherits(cond, "warning")) {
[10:31:44.446]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:44.446]                         if (muffled) 
[10:31:44.446]                           invokeRestart("muffleWarning")
[10:31:44.446]                       }
[10:31:44.446]                       else if (inherits(cond, "condition")) {
[10:31:44.446]                         if (!is.null(pattern)) {
[10:31:44.446]                           computeRestarts <- base::computeRestarts
[10:31:44.446]                           grepl <- base::grepl
[10:31:44.446]                           restarts <- computeRestarts(cond)
[10:31:44.446]                           for (restart in restarts) {
[10:31:44.446]                             name <- restart$name
[10:31:44.446]                             if (is.null(name)) 
[10:31:44.446]                               next
[10:31:44.446]                             if (!grepl(pattern, name)) 
[10:31:44.446]                               next
[10:31:44.446]                             invokeRestart(restart)
[10:31:44.446]                             muffled <- TRUE
[10:31:44.446]                             break
[10:31:44.446]                           }
[10:31:44.446]                         }
[10:31:44.446]                       }
[10:31:44.446]                       invisible(muffled)
[10:31:44.446]                     }
[10:31:44.446]                     muffleCondition(cond, pattern = "^muffle")
[10:31:44.446]                   }
[10:31:44.446]                 }
[10:31:44.446]                 else {
[10:31:44.446]                   if (TRUE) {
[10:31:44.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:44.446]                     {
[10:31:44.446]                       inherits <- base::inherits
[10:31:44.446]                       invokeRestart <- base::invokeRestart
[10:31:44.446]                       is.null <- base::is.null
[10:31:44.446]                       muffled <- FALSE
[10:31:44.446]                       if (inherits(cond, "message")) {
[10:31:44.446]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:44.446]                         if (muffled) 
[10:31:44.446]                           invokeRestart("muffleMessage")
[10:31:44.446]                       }
[10:31:44.446]                       else if (inherits(cond, "warning")) {
[10:31:44.446]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:44.446]                         if (muffled) 
[10:31:44.446]                           invokeRestart("muffleWarning")
[10:31:44.446]                       }
[10:31:44.446]                       else if (inherits(cond, "condition")) {
[10:31:44.446]                         if (!is.null(pattern)) {
[10:31:44.446]                           computeRestarts <- base::computeRestarts
[10:31:44.446]                           grepl <- base::grepl
[10:31:44.446]                           restarts <- computeRestarts(cond)
[10:31:44.446]                           for (restart in restarts) {
[10:31:44.446]                             name <- restart$name
[10:31:44.446]                             if (is.null(name)) 
[10:31:44.446]                               next
[10:31:44.446]                             if (!grepl(pattern, name)) 
[10:31:44.446]                               next
[10:31:44.446]                             invokeRestart(restart)
[10:31:44.446]                             muffled <- TRUE
[10:31:44.446]                             break
[10:31:44.446]                           }
[10:31:44.446]                         }
[10:31:44.446]                       }
[10:31:44.446]                       invisible(muffled)
[10:31:44.446]                     }
[10:31:44.446]                     muffleCondition(cond, pattern = "^muffle")
[10:31:44.446]                   }
[10:31:44.446]                 }
[10:31:44.446]             }
[10:31:44.446]         }))
[10:31:44.446]     }, error = function(ex) {
[10:31:44.446]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:44.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:44.446]                 ...future.rng), started = ...future.startTime, 
[10:31:44.446]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:44.446]             version = "1.8"), class = "FutureResult")
[10:31:44.446]     }, finally = {
[10:31:44.446]         if (!identical(...future.workdir, getwd())) 
[10:31:44.446]             setwd(...future.workdir)
[10:31:44.446]         {
[10:31:44.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:44.446]                 ...future.oldOptions$nwarnings <- NULL
[10:31:44.446]             }
[10:31:44.446]             base::options(...future.oldOptions)
[10:31:44.446]             if (.Platform$OS.type == "windows") {
[10:31:44.446]                 old_names <- names(...future.oldEnvVars)
[10:31:44.446]                 envs <- base::Sys.getenv()
[10:31:44.446]                 names <- names(envs)
[10:31:44.446]                 common <- intersect(names, old_names)
[10:31:44.446]                 added <- setdiff(names, old_names)
[10:31:44.446]                 removed <- setdiff(old_names, names)
[10:31:44.446]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:44.446]                   envs[common]]
[10:31:44.446]                 NAMES <- toupper(changed)
[10:31:44.446]                 args <- list()
[10:31:44.446]                 for (kk in seq_along(NAMES)) {
[10:31:44.446]                   name <- changed[[kk]]
[10:31:44.446]                   NAME <- NAMES[[kk]]
[10:31:44.446]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:44.446]                     next
[10:31:44.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:44.446]                 }
[10:31:44.446]                 NAMES <- toupper(added)
[10:31:44.446]                 for (kk in seq_along(NAMES)) {
[10:31:44.446]                   name <- added[[kk]]
[10:31:44.446]                   NAME <- NAMES[[kk]]
[10:31:44.446]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:44.446]                     next
[10:31:44.446]                   args[[name]] <- ""
[10:31:44.446]                 }
[10:31:44.446]                 NAMES <- toupper(removed)
[10:31:44.446]                 for (kk in seq_along(NAMES)) {
[10:31:44.446]                   name <- removed[[kk]]
[10:31:44.446]                   NAME <- NAMES[[kk]]
[10:31:44.446]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:44.446]                     next
[10:31:44.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:44.446]                 }
[10:31:44.446]                 if (length(args) > 0) 
[10:31:44.446]                   base::do.call(base::Sys.setenv, args = args)
[10:31:44.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:44.446]             }
[10:31:44.446]             else {
[10:31:44.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:44.446]             }
[10:31:44.446]             {
[10:31:44.446]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:44.446]                   0L) {
[10:31:44.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:44.446]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:44.446]                   base::options(opts)
[10:31:44.446]                 }
[10:31:44.446]                 {
[10:31:44.446]                   {
[10:31:44.446]                     NULL
[10:31:44.446]                     RNGkind("Mersenne-Twister")
[10:31:44.446]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:44.446]                       inherits = FALSE)
[10:31:44.446]                   }
[10:31:44.446]                   options(future.plan = NULL)
[10:31:44.446]                   if (is.na(NA_character_)) 
[10:31:44.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:44.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:44.446]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:44.446]                     .init = FALSE)
[10:31:44.446]                 }
[10:31:44.446]             }
[10:31:44.446]         }
[10:31:44.446]     })
[10:31:44.446]     if (TRUE) {
[10:31:44.446]         base::sink(type = "output", split = FALSE)
[10:31:44.446]         if (FALSE) {
[10:31:44.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:44.446]         }
[10:31:44.446]         else {
[10:31:44.446]             ...future.result["stdout"] <- base::list(NULL)
[10:31:44.446]         }
[10:31:44.446]         base::close(...future.stdout)
[10:31:44.446]         ...future.stdout <- NULL
[10:31:44.446]     }
[10:31:44.446]     ...future.result$conditions <- ...future.conditions
[10:31:44.446]     ...future.result$finished <- base::Sys.time()
[10:31:44.446]     ...future.result
[10:31:44.446] }
[10:31:44.447] assign_globals() ...
[10:31:44.448] List of 5
[10:31:44.448]  $ ...future.FUN            :function (x, y)  
[10:31:44.448]  $ MoreArgs                 : NULL
[10:31:44.448]  $ ...future.elements_ii    :List of 2
[10:31:44.448]   ..$ :List of 2
[10:31:44.448]   .. ..$ : int 1
[10:31:44.448]   .. ..$ : int 0
[10:31:44.448]   ..$ :List of 2
[10:31:44.448]   .. ..$ : int 0
[10:31:44.448]   .. ..$ : int 1
[10:31:44.448]  $ ...future.seeds_ii       : NULL
[10:31:44.448]  $ ...future.globals.maxSize: NULL
[10:31:44.448]  - attr(*, "where")=List of 5
[10:31:44.448]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:44.448]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:44.448]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:44.448]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:44.448]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:44.448]  - attr(*, "resolved")= logi FALSE
[10:31:44.448]  - attr(*, "total_size")= num 6480
[10:31:44.448]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:44.448]  - attr(*, "already-done")= logi TRUE
[10:31:44.453] - reassign environment for ‘...future.FUN’
[10:31:44.453] - copied ‘...future.FUN’ to environment
[10:31:44.453] - copied ‘MoreArgs’ to environment
[10:31:44.454] - copied ‘...future.elements_ii’ to environment
[10:31:44.454] - copied ‘...future.seeds_ii’ to environment
[10:31:44.454] - copied ‘...future.globals.maxSize’ to environment
[10:31:44.454] assign_globals() ... done
[10:31:44.454] plan(): Setting new future strategy stack:
[10:31:44.454] List of future strategies:
[10:31:44.454] 1. sequential:
[10:31:44.454]    - args: function (..., envir = parent.frame())
[10:31:44.454]    - tweaked: FALSE
[10:31:44.454]    - call: NULL
[10:31:44.455] plan(): nbrOfWorkers() = 1
[10:31:44.956] plan(): Setting new future strategy stack:
[10:31:44.956] List of future strategies:
[10:31:44.956] 1. multisession:
[10:31:44.956]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:44.956]    - tweaked: FALSE
[10:31:44.956]    - call: plan(strategy)
[10:31:44.961] plan(): nbrOfWorkers() = 1
[10:31:44.961] SequentialFuture started (and completed)
[10:31:44.961] - Launch lazy future ... done
[10:31:44.961] run() for ‘SequentialFuture’ ... done
[10:31:44.961] Created future:
[10:31:44.961] SequentialFuture:
[10:31:44.961] Label: ‘future_mapply-1’
[10:31:44.961] Expression:
[10:31:44.961] {
[10:31:44.961]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:44.961]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:44.961]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:44.961]         on.exit(options(oopts), add = TRUE)
[10:31:44.961]     }
[10:31:44.961]     {
[10:31:44.961]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:44.961]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:44.961]         do.call(mapply, args = args)
[10:31:44.961]     }
[10:31:44.961] }
[10:31:44.961] Lazy evaluation: FALSE
[10:31:44.961] Asynchronous evaluation: FALSE
[10:31:44.961] Local evaluation: TRUE
[10:31:44.961] Environment: R_GlobalEnv
[10:31:44.961] Capture standard output: FALSE
[10:31:44.961] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:44.961] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:44.961] Packages: <none>
[10:31:44.961] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:44.961] Resolved: TRUE
[10:31:44.961] Value: 224 bytes of class ‘list’
[10:31:44.961] Early signaling: FALSE
[10:31:44.961] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:44.961] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:44.962] Chunk #1 of 1 ... DONE
[10:31:44.962] Launching 1 futures (chunks) ... DONE
[10:31:44.962] Resolving 1 futures (chunks) ...
[10:31:44.963] resolve() on list ...
[10:31:44.963]  recursive: 0
[10:31:44.963]  length: 1
[10:31:44.963] 
[10:31:44.963] resolved() for ‘SequentialFuture’ ...
[10:31:44.963] - state: ‘finished’
[10:31:44.963] - run: TRUE
[10:31:44.963] - result: ‘FutureResult’
[10:31:44.963] resolved() for ‘SequentialFuture’ ... done
[10:31:44.964] Future #1
[10:31:44.964] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:44.964] - nx: 1
[10:31:44.964] - relay: TRUE
[10:31:44.964] - stdout: TRUE
[10:31:44.964] - signal: TRUE
[10:31:44.964] - resignal: FALSE
[10:31:44.964] - force: TRUE
[10:31:44.964] - relayed: [n=1] FALSE
[10:31:44.964] - queued futures: [n=1] FALSE
[10:31:44.964]  - until=1
[10:31:44.965]  - relaying element #1
[10:31:44.965] - relayed: [n=1] TRUE
[10:31:44.965] - queued futures: [n=1] TRUE
[10:31:44.965] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:44.965]  length: 0 (resolved future 1)
[10:31:44.965] Relaying remaining futures
[10:31:44.965] signalConditionsASAP(NULL, pos=0) ...
[10:31:44.965] - nx: 1
[10:31:44.965] - relay: TRUE
[10:31:44.966] - stdout: TRUE
[10:31:44.966] - signal: TRUE
[10:31:44.966] - resignal: FALSE
[10:31:44.966] - force: TRUE
[10:31:44.966] - relayed: [n=1] TRUE
[10:31:44.966] - queued futures: [n=1] TRUE
 - flush all
[10:31:44.966] - relayed: [n=1] TRUE
[10:31:44.966] - queued futures: [n=1] TRUE
[10:31:44.966] signalConditionsASAP(NULL, pos=0) ... done
[10:31:44.966] resolve() on list ... DONE
[10:31:44.967]  - Number of value chunks collected: 1
[10:31:44.967] Resolving 1 futures (chunks) ... DONE
[10:31:44.967] Reducing values from 1 chunks ...
[10:31:44.967]  - Number of values collected after concatenation: 2
[10:31:44.967]  - Number of values expected: 2
[10:31:44.967] Reducing values from 1 chunks ... DONE
[10:31:44.969] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:31:44.969] future_mapply() ...
[10:31:44.973] Number of chunks: 1
[10:31:44.973] getGlobalsAndPackagesXApply() ...
[10:31:44.973]  - future.globals: TRUE
[10:31:44.973] getGlobalsAndPackages() ...
[10:31:44.974] Searching for globals...
[10:31:44.975] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:44.975] Searching for globals ... DONE
[10:31:44.976] Resolving globals: FALSE
[10:31:44.976] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:44.976] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:44.977] - globals: [1] ‘FUN’
[10:31:44.977] 
[10:31:44.977] getGlobalsAndPackages() ... DONE
[10:31:44.977]  - globals found/used: [n=1] ‘FUN’
[10:31:44.977]  - needed namespaces: [n=0] 
[10:31:44.977] Finding globals ... DONE
[10:31:44.977] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:44.977] List of 2
[10:31:44.977]  $ ...future.FUN:function (x, y)  
[10:31:44.977]  $ MoreArgs     : NULL
[10:31:44.977]  - attr(*, "where")=List of 2
[10:31:44.977]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:44.977]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:44.977]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:44.977]  - attr(*, "resolved")= logi FALSE
[10:31:44.977]  - attr(*, "total_size")= num NA
[10:31:44.980] Packages to be attached in all futures: [n=0] 
[10:31:44.980] getGlobalsAndPackagesXApply() ... DONE
[10:31:44.980] Number of futures (= number of chunks): 1
[10:31:44.980] Launching 1 futures (chunks) ...
[10:31:44.980] Chunk #1 of 1 ...
[10:31:44.981]  - Finding globals in '...' for chunk #1 ...
[10:31:44.981] getGlobalsAndPackages() ...
[10:31:44.981] Searching for globals...
[10:31:44.981] 
[10:31:44.981] Searching for globals ... DONE
[10:31:44.981] - globals: [0] <none>
[10:31:44.981] getGlobalsAndPackages() ... DONE
[10:31:44.982]    + additional globals found: [n=0] 
[10:31:44.982]    + additional namespaces needed: [n=0] 
[10:31:44.982]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:44.982]  - seeds: <none>
[10:31:44.982]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:44.982] getGlobalsAndPackages() ...
[10:31:44.982] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:44.982] Resolving globals: FALSE
[10:31:44.983] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:31:44.983] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:44.983] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:44.983] 
[10:31:44.983] getGlobalsAndPackages() ... DONE
[10:31:44.984] run() for ‘Future’ ...
[10:31:44.984] - state: ‘created’
[10:31:44.984] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:44.988] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:44.988] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:44.988]   - Field: ‘label’
[10:31:44.988]   - Field: ‘local’
[10:31:44.988]   - Field: ‘owner’
[10:31:44.988]   - Field: ‘envir’
[10:31:44.988]   - Field: ‘packages’
[10:31:44.988]   - Field: ‘gc’
[10:31:44.988]   - Field: ‘conditions’
[10:31:44.989]   - Field: ‘expr’
[10:31:44.989]   - Field: ‘uuid’
[10:31:44.989]   - Field: ‘seed’
[10:31:44.989]   - Field: ‘version’
[10:31:44.989]   - Field: ‘result’
[10:31:44.989]   - Field: ‘asynchronous’
[10:31:44.989]   - Field: ‘calls’
[10:31:44.989]   - Field: ‘globals’
[10:31:44.989]   - Field: ‘stdout’
[10:31:44.989]   - Field: ‘earlySignal’
[10:31:44.990]   - Field: ‘lazy’
[10:31:44.990]   - Field: ‘state’
[10:31:44.990] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:44.990] - Launch lazy future ...
[10:31:44.990] Packages needed by the future expression (n = 0): <none>
[10:31:44.990] Packages needed by future strategies (n = 0): <none>
[10:31:44.991] {
[10:31:44.991]     {
[10:31:44.991]         {
[10:31:44.991]             ...future.startTime <- base::Sys.time()
[10:31:44.991]             {
[10:31:44.991]                 {
[10:31:44.991]                   {
[10:31:44.991]                     base::local({
[10:31:44.991]                       has_future <- base::requireNamespace("future", 
[10:31:44.991]                         quietly = TRUE)
[10:31:44.991]                       if (has_future) {
[10:31:44.991]                         ns <- base::getNamespace("future")
[10:31:44.991]                         version <- ns[[".package"]][["version"]]
[10:31:44.991]                         if (is.null(version)) 
[10:31:44.991]                           version <- utils::packageVersion("future")
[10:31:44.991]                       }
[10:31:44.991]                       else {
[10:31:44.991]                         version <- NULL
[10:31:44.991]                       }
[10:31:44.991]                       if (!has_future || version < "1.8.0") {
[10:31:44.991]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:44.991]                           "", base::R.version$version.string), 
[10:31:44.991]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:44.991]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:44.991]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:44.991]                             "release", "version")], collapse = " "), 
[10:31:44.991]                           hostname = base::Sys.info()[["nodename"]])
[10:31:44.991]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:44.991]                           info)
[10:31:44.991]                         info <- base::paste(info, collapse = "; ")
[10:31:44.991]                         if (!has_future) {
[10:31:44.991]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:44.991]                             info)
[10:31:44.991]                         }
[10:31:44.991]                         else {
[10:31:44.991]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:44.991]                             info, version)
[10:31:44.991]                         }
[10:31:44.991]                         base::stop(msg)
[10:31:44.991]                       }
[10:31:44.991]                     })
[10:31:44.991]                   }
[10:31:44.991]                   ...future.strategy.old <- future::plan("list")
[10:31:44.991]                   options(future.plan = NULL)
[10:31:44.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:44.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:44.991]                 }
[10:31:44.991]                 ...future.workdir <- getwd()
[10:31:44.991]             }
[10:31:44.991]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:44.991]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:44.991]         }
[10:31:44.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:44.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:44.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:44.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:44.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:44.991]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:44.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:44.991]             base::names(...future.oldOptions))
[10:31:44.991]     }
[10:31:44.991]     if (FALSE) {
[10:31:44.991]     }
[10:31:44.991]     else {
[10:31:44.991]         if (TRUE) {
[10:31:44.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:44.991]                 open = "w")
[10:31:44.991]         }
[10:31:44.991]         else {
[10:31:44.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:44.991]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:44.991]         }
[10:31:44.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:44.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:44.991]             base::sink(type = "output", split = FALSE)
[10:31:44.991]             base::close(...future.stdout)
[10:31:44.991]         }, add = TRUE)
[10:31:44.991]     }
[10:31:44.991]     ...future.frame <- base::sys.nframe()
[10:31:44.991]     ...future.conditions <- base::list()
[10:31:44.991]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:44.991]     if (FALSE) {
[10:31:44.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:44.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:44.991]     }
[10:31:44.991]     ...future.result <- base::tryCatch({
[10:31:44.991]         base::withCallingHandlers({
[10:31:44.991]             ...future.value <- base::withVisible(base::local({
[10:31:44.991]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:44.991]                 if (!identical(...future.globals.maxSize.org, 
[10:31:44.991]                   ...future.globals.maxSize)) {
[10:31:44.991]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:44.991]                   on.exit(options(oopts), add = TRUE)
[10:31:44.991]                 }
[10:31:44.991]                 {
[10:31:44.991]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:44.991]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:44.991]                     USE.NAMES = FALSE)
[10:31:44.991]                   do.call(mapply, args = args)
[10:31:44.991]                 }
[10:31:44.991]             }))
[10:31:44.991]             future::FutureResult(value = ...future.value$value, 
[10:31:44.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:44.991]                   ...future.rng), globalenv = if (FALSE) 
[10:31:44.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:44.991]                     ...future.globalenv.names))
[10:31:44.991]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:44.991]         }, condition = base::local({
[10:31:44.991]             c <- base::c
[10:31:44.991]             inherits <- base::inherits
[10:31:44.991]             invokeRestart <- base::invokeRestart
[10:31:44.991]             length <- base::length
[10:31:44.991]             list <- base::list
[10:31:44.991]             seq.int <- base::seq.int
[10:31:44.991]             signalCondition <- base::signalCondition
[10:31:44.991]             sys.calls <- base::sys.calls
[10:31:44.991]             `[[` <- base::`[[`
[10:31:44.991]             `+` <- base::`+`
[10:31:44.991]             `<<-` <- base::`<<-`
[10:31:44.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:44.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:44.991]                   3L)]
[10:31:44.991]             }
[10:31:44.991]             function(cond) {
[10:31:44.991]                 is_error <- inherits(cond, "error")
[10:31:44.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:44.991]                   NULL)
[10:31:44.991]                 if (is_error) {
[10:31:44.991]                   sessionInformation <- function() {
[10:31:44.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:44.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:44.991]                       search = base::search(), system = base::Sys.info())
[10:31:44.991]                   }
[10:31:44.991]                   ...future.conditions[[length(...future.conditions) + 
[10:31:44.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:44.991]                     cond$call), session = sessionInformation(), 
[10:31:44.991]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:44.991]                   signalCondition(cond)
[10:31:44.991]                 }
[10:31:44.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:44.991]                 "immediateCondition"))) {
[10:31:44.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:44.991]                   ...future.conditions[[length(...future.conditions) + 
[10:31:44.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:44.991]                   if (TRUE && !signal) {
[10:31:44.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:44.991]                     {
[10:31:44.991]                       inherits <- base::inherits
[10:31:44.991]                       invokeRestart <- base::invokeRestart
[10:31:44.991]                       is.null <- base::is.null
[10:31:44.991]                       muffled <- FALSE
[10:31:44.991]                       if (inherits(cond, "message")) {
[10:31:44.991]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:44.991]                         if (muffled) 
[10:31:44.991]                           invokeRestart("muffleMessage")
[10:31:44.991]                       }
[10:31:44.991]                       else if (inherits(cond, "warning")) {
[10:31:44.991]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:44.991]                         if (muffled) 
[10:31:44.991]                           invokeRestart("muffleWarning")
[10:31:44.991]                       }
[10:31:44.991]                       else if (inherits(cond, "condition")) {
[10:31:44.991]                         if (!is.null(pattern)) {
[10:31:44.991]                           computeRestarts <- base::computeRestarts
[10:31:44.991]                           grepl <- base::grepl
[10:31:44.991]                           restarts <- computeRestarts(cond)
[10:31:44.991]                           for (restart in restarts) {
[10:31:44.991]                             name <- restart$name
[10:31:44.991]                             if (is.null(name)) 
[10:31:44.991]                               next
[10:31:44.991]                             if (!grepl(pattern, name)) 
[10:31:44.991]                               next
[10:31:44.991]                             invokeRestart(restart)
[10:31:44.991]                             muffled <- TRUE
[10:31:44.991]                             break
[10:31:44.991]                           }
[10:31:44.991]                         }
[10:31:44.991]                       }
[10:31:44.991]                       invisible(muffled)
[10:31:44.991]                     }
[10:31:44.991]                     muffleCondition(cond, pattern = "^muffle")
[10:31:44.991]                   }
[10:31:44.991]                 }
[10:31:44.991]                 else {
[10:31:44.991]                   if (TRUE) {
[10:31:44.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:44.991]                     {
[10:31:44.991]                       inherits <- base::inherits
[10:31:44.991]                       invokeRestart <- base::invokeRestart
[10:31:44.991]                       is.null <- base::is.null
[10:31:44.991]                       muffled <- FALSE
[10:31:44.991]                       if (inherits(cond, "message")) {
[10:31:44.991]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:44.991]                         if (muffled) 
[10:31:44.991]                           invokeRestart("muffleMessage")
[10:31:44.991]                       }
[10:31:44.991]                       else if (inherits(cond, "warning")) {
[10:31:44.991]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:44.991]                         if (muffled) 
[10:31:44.991]                           invokeRestart("muffleWarning")
[10:31:44.991]                       }
[10:31:44.991]                       else if (inherits(cond, "condition")) {
[10:31:44.991]                         if (!is.null(pattern)) {
[10:31:44.991]                           computeRestarts <- base::computeRestarts
[10:31:44.991]                           grepl <- base::grepl
[10:31:44.991]                           restarts <- computeRestarts(cond)
[10:31:44.991]                           for (restart in restarts) {
[10:31:44.991]                             name <- restart$name
[10:31:44.991]                             if (is.null(name)) 
[10:31:44.991]                               next
[10:31:44.991]                             if (!grepl(pattern, name)) 
[10:31:44.991]                               next
[10:31:44.991]                             invokeRestart(restart)
[10:31:44.991]                             muffled <- TRUE
[10:31:44.991]                             break
[10:31:44.991]                           }
[10:31:44.991]                         }
[10:31:44.991]                       }
[10:31:44.991]                       invisible(muffled)
[10:31:44.991]                     }
[10:31:44.991]                     muffleCondition(cond, pattern = "^muffle")
[10:31:44.991]                   }
[10:31:44.991]                 }
[10:31:44.991]             }
[10:31:44.991]         }))
[10:31:44.991]     }, error = function(ex) {
[10:31:44.991]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:44.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:44.991]                 ...future.rng), started = ...future.startTime, 
[10:31:44.991]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:44.991]             version = "1.8"), class = "FutureResult")
[10:31:44.991]     }, finally = {
[10:31:44.991]         if (!identical(...future.workdir, getwd())) 
[10:31:44.991]             setwd(...future.workdir)
[10:31:44.991]         {
[10:31:44.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:44.991]                 ...future.oldOptions$nwarnings <- NULL
[10:31:44.991]             }
[10:31:44.991]             base::options(...future.oldOptions)
[10:31:44.991]             if (.Platform$OS.type == "windows") {
[10:31:44.991]                 old_names <- names(...future.oldEnvVars)
[10:31:44.991]                 envs <- base::Sys.getenv()
[10:31:44.991]                 names <- names(envs)
[10:31:44.991]                 common <- intersect(names, old_names)
[10:31:44.991]                 added <- setdiff(names, old_names)
[10:31:44.991]                 removed <- setdiff(old_names, names)
[10:31:44.991]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:44.991]                   envs[common]]
[10:31:44.991]                 NAMES <- toupper(changed)
[10:31:44.991]                 args <- list()
[10:31:44.991]                 for (kk in seq_along(NAMES)) {
[10:31:44.991]                   name <- changed[[kk]]
[10:31:44.991]                   NAME <- NAMES[[kk]]
[10:31:44.991]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:44.991]                     next
[10:31:44.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:44.991]                 }
[10:31:44.991]                 NAMES <- toupper(added)
[10:31:44.991]                 for (kk in seq_along(NAMES)) {
[10:31:44.991]                   name <- added[[kk]]
[10:31:44.991]                   NAME <- NAMES[[kk]]
[10:31:44.991]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:44.991]                     next
[10:31:44.991]                   args[[name]] <- ""
[10:31:44.991]                 }
[10:31:44.991]                 NAMES <- toupper(removed)
[10:31:44.991]                 for (kk in seq_along(NAMES)) {
[10:31:44.991]                   name <- removed[[kk]]
[10:31:44.991]                   NAME <- NAMES[[kk]]
[10:31:44.991]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:44.991]                     next
[10:31:44.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:44.991]                 }
[10:31:44.991]                 if (length(args) > 0) 
[10:31:44.991]                   base::do.call(base::Sys.setenv, args = args)
[10:31:44.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:44.991]             }
[10:31:44.991]             else {
[10:31:44.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:44.991]             }
[10:31:44.991]             {
[10:31:44.991]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:44.991]                   0L) {
[10:31:44.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:44.991]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:44.991]                   base::options(opts)
[10:31:44.991]                 }
[10:31:44.991]                 {
[10:31:44.991]                   {
[10:31:44.991]                     NULL
[10:31:44.991]                     RNGkind("Mersenne-Twister")
[10:31:44.991]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:44.991]                       inherits = FALSE)
[10:31:44.991]                   }
[10:31:44.991]                   options(future.plan = NULL)
[10:31:44.991]                   if (is.na(NA_character_)) 
[10:31:44.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:44.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:44.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:44.991]                     .init = FALSE)
[10:31:44.991]                 }
[10:31:44.991]             }
[10:31:44.991]         }
[10:31:44.991]     })
[10:31:44.991]     if (TRUE) {
[10:31:44.991]         base::sink(type = "output", split = FALSE)
[10:31:44.991]         if (TRUE) {
[10:31:44.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:44.991]         }
[10:31:44.991]         else {
[10:31:44.991]             ...future.result["stdout"] <- base::list(NULL)
[10:31:44.991]         }
[10:31:44.991]         base::close(...future.stdout)
[10:31:44.991]         ...future.stdout <- NULL
[10:31:44.991]     }
[10:31:44.991]     ...future.result$conditions <- ...future.conditions
[10:31:44.991]     ...future.result$finished <- base::Sys.time()
[10:31:44.991]     ...future.result
[10:31:44.991] }
[10:31:44.992] assign_globals() ...
[10:31:44.992] List of 5
[10:31:44.992]  $ ...future.FUN            :function (x, y)  
[10:31:44.992]  $ MoreArgs                 : NULL
[10:31:44.992]  $ ...future.elements_ii    :List of 2
[10:31:44.992]   ..$ :List of 2
[10:31:44.992]   .. ..$ : int 1
[10:31:44.992]   .. ..$ : int 0
[10:31:44.992]   ..$ :List of 2
[10:31:44.992]   .. ..$ : int 0
[10:31:44.992]   .. ..$ : int 1
[10:31:44.992]  $ ...future.seeds_ii       : NULL
[10:31:44.992]  $ ...future.globals.maxSize: NULL
[10:31:44.992]  - attr(*, "where")=List of 5
[10:31:44.992]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:44.992]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:44.992]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:44.992]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:44.992]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:44.992]  - attr(*, "resolved")= logi FALSE
[10:31:44.992]  - attr(*, "total_size")= num 6480
[10:31:44.992]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:44.992]  - attr(*, "already-done")= logi TRUE
[10:31:44.998] - reassign environment for ‘...future.FUN’
[10:31:44.998] - copied ‘...future.FUN’ to environment
[10:31:44.998] - copied ‘MoreArgs’ to environment
[10:31:44.999] - copied ‘...future.elements_ii’ to environment
[10:31:44.999] - copied ‘...future.seeds_ii’ to environment
[10:31:44.999] - copied ‘...future.globals.maxSize’ to environment
[10:31:44.999] assign_globals() ... done
[10:31:44.999] plan(): Setting new future strategy stack:
[10:31:44.999] List of future strategies:
[10:31:44.999] 1. sequential:
[10:31:44.999]    - args: function (..., envir = parent.frame())
[10:31:44.999]    - tweaked: FALSE
[10:31:44.999]    - call: NULL
[10:31:45.001] plan(): nbrOfWorkers() = 1
[10:31:45.503] plan(): Setting new future strategy stack:
[10:31:45.504] List of future strategies:
[10:31:45.504] 1. multisession:
[10:31:45.504]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:45.504]    - tweaked: FALSE
[10:31:45.504]    - call: plan(strategy)
[10:31:45.508] plan(): nbrOfWorkers() = 1
[10:31:45.508] SequentialFuture started (and completed)
[10:31:45.508] - Launch lazy future ... done
[10:31:45.508] run() for ‘SequentialFuture’ ... done
[10:31:45.509] Created future:
[10:31:45.509] SequentialFuture:
[10:31:45.509] Label: ‘future_mapply-1’
[10:31:45.509] Expression:
[10:31:45.509] {
[10:31:45.509]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:45.509]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:45.509]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:45.509]         on.exit(options(oopts), add = TRUE)
[10:31:45.509]     }
[10:31:45.509]     {
[10:31:45.509]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:45.509]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:45.509]         do.call(mapply, args = args)
[10:31:45.509]     }
[10:31:45.509] }
[10:31:45.509] Lazy evaluation: FALSE
[10:31:45.509] Asynchronous evaluation: FALSE
[10:31:45.509] Local evaluation: TRUE
[10:31:45.509] Environment: R_GlobalEnv
[10:31:45.509] Capture standard output: TRUE
[10:31:45.509] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:45.509] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:45.509] Packages: <none>
[10:31:45.509] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:45.509] Resolved: TRUE
[10:31:45.509] Value: 224 bytes of class ‘list’
[10:31:45.509] Early signaling: FALSE
[10:31:45.509] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:45.509] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:45.510] Chunk #1 of 1 ... DONE
[10:31:45.510] Launching 1 futures (chunks) ... DONE
[10:31:45.510] Resolving 1 futures (chunks) ...
[10:31:45.510] resolve() on list ...
[10:31:45.510]  recursive: 0
[10:31:45.510]  length: 1
[10:31:45.510] 
[10:31:45.510] resolved() for ‘SequentialFuture’ ...
[10:31:45.510] - state: ‘finished’
[10:31:45.511] - run: TRUE
[10:31:45.511] - result: ‘FutureResult’
[10:31:45.511] resolved() for ‘SequentialFuture’ ... done
[10:31:45.511] Future #1
[10:31:45.511] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:45.511] - nx: 1
[10:31:45.511] - relay: TRUE
[10:31:45.511] - stdout: TRUE
[10:31:45.511] - signal: TRUE
[10:31:45.511] - resignal: FALSE
[10:31:45.512] - force: TRUE
[10:31:45.512] - relayed: [n=1] FALSE
[10:31:45.512] - queued futures: [n=1] FALSE
[10:31:45.512]  - until=1
[10:31:45.512]  - relaying element #1
[10:31:45.512] - relayed: [n=1] TRUE
[10:31:45.512] - queued futures: [n=1] TRUE
[10:31:45.512] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:45.512]  length: 0 (resolved future 1)
[10:31:45.513] Relaying remaining futures
[10:31:45.513] signalConditionsASAP(NULL, pos=0) ...
[10:31:45.513] - nx: 1
[10:31:45.513] - relay: TRUE
[10:31:45.513] - stdout: TRUE
[10:31:45.513] - signal: TRUE
[10:31:45.513] - resignal: FALSE
[10:31:45.513] - force: TRUE
[10:31:45.513] - relayed: [n=1] TRUE
[10:31:45.513] - queued futures: [n=1] TRUE
 - flush all
[10:31:45.514] - relayed: [n=1] TRUE
[10:31:45.514] - queued futures: [n=1] TRUE
[10:31:45.514] signalConditionsASAP(NULL, pos=0) ... done
[10:31:45.514] resolve() on list ... DONE
[10:31:45.514]  - Number of value chunks collected: 1
[10:31:45.514] Resolving 1 futures (chunks) ... DONE
[10:31:45.514] Reducing values from 1 chunks ...
[10:31:45.514]  - Number of values collected after concatenation: 2
[10:31:45.514]  - Number of values expected: 2
[10:31:45.514] Reducing values from 1 chunks ... DONE
[10:31:45.515] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:31:45.515] future_mapply() ...
[10:31:45.518] Number of chunks: 1
[10:31:45.518] getGlobalsAndPackagesXApply() ...
[10:31:45.518]  - future.globals: TRUE
[10:31:45.519] getGlobalsAndPackages() ...
[10:31:45.519] Searching for globals...
[10:31:45.520] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:45.520] Searching for globals ... DONE
[10:31:45.520] Resolving globals: FALSE
[10:31:45.521] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:45.521] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:45.521] - globals: [1] ‘FUN’
[10:31:45.522] 
[10:31:45.522] getGlobalsAndPackages() ... DONE
[10:31:45.522]  - globals found/used: [n=1] ‘FUN’
[10:31:45.522]  - needed namespaces: [n=0] 
[10:31:45.522] Finding globals ... DONE
[10:31:45.522] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:45.522] List of 2
[10:31:45.522]  $ ...future.FUN:function (x, y)  
[10:31:45.522]  $ MoreArgs     : NULL
[10:31:45.522]  - attr(*, "where")=List of 2
[10:31:45.522]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:45.522]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:45.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:45.522]  - attr(*, "resolved")= logi FALSE
[10:31:45.522]  - attr(*, "total_size")= num NA
[10:31:45.525] Packages to be attached in all futures: [n=0] 
[10:31:45.525] getGlobalsAndPackagesXApply() ... DONE
[10:31:45.525] Number of futures (= number of chunks): 1
[10:31:45.525] Launching 1 futures (chunks) ...
[10:31:45.525] Chunk #1 of 1 ...
[10:31:45.525]  - Finding globals in '...' for chunk #1 ...
[10:31:45.526] getGlobalsAndPackages() ...
[10:31:45.526] Searching for globals...
[10:31:45.526] 
[10:31:45.526] Searching for globals ... DONE
[10:31:45.526] - globals: [0] <none>
[10:31:45.526] getGlobalsAndPackages() ... DONE
[10:31:45.526]    + additional globals found: [n=0] 
[10:31:45.526]    + additional namespaces needed: [n=0] 
[10:31:45.527]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:45.527]  - seeds: <none>
[10:31:45.527]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:45.527] getGlobalsAndPackages() ...
[10:31:45.527] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:45.527] Resolving globals: FALSE
[10:31:45.527] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[10:31:45.528] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:45.528] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:45.528] 
[10:31:45.528] getGlobalsAndPackages() ... DONE
[10:31:45.529] run() for ‘Future’ ...
[10:31:45.529] - state: ‘created’
[10:31:45.529] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:45.532] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:45.532] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:45.533]   - Field: ‘label’
[10:31:45.533]   - Field: ‘local’
[10:31:45.533]   - Field: ‘owner’
[10:31:45.533]   - Field: ‘envir’
[10:31:45.533]   - Field: ‘packages’
[10:31:45.533]   - Field: ‘gc’
[10:31:45.533]   - Field: ‘conditions’
[10:31:45.533]   - Field: ‘expr’
[10:31:45.533]   - Field: ‘uuid’
[10:31:45.534]   - Field: ‘seed’
[10:31:45.534]   - Field: ‘version’
[10:31:45.534]   - Field: ‘result’
[10:31:45.534]   - Field: ‘asynchronous’
[10:31:45.534]   - Field: ‘calls’
[10:31:45.534]   - Field: ‘globals’
[10:31:45.534]   - Field: ‘stdout’
[10:31:45.534]   - Field: ‘earlySignal’
[10:31:45.534]   - Field: ‘lazy’
[10:31:45.534]   - Field: ‘state’
[10:31:45.534] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:45.535] - Launch lazy future ...
[10:31:45.535] Packages needed by the future expression (n = 0): <none>
[10:31:45.536] Packages needed by future strategies (n = 0): <none>
[10:31:45.537] {
[10:31:45.537]     {
[10:31:45.537]         {
[10:31:45.537]             ...future.startTime <- base::Sys.time()
[10:31:45.537]             {
[10:31:45.537]                 {
[10:31:45.537]                   {
[10:31:45.537]                     base::local({
[10:31:45.537]                       has_future <- base::requireNamespace("future", 
[10:31:45.537]                         quietly = TRUE)
[10:31:45.537]                       if (has_future) {
[10:31:45.537]                         ns <- base::getNamespace("future")
[10:31:45.537]                         version <- ns[[".package"]][["version"]]
[10:31:45.537]                         if (is.null(version)) 
[10:31:45.537]                           version <- utils::packageVersion("future")
[10:31:45.537]                       }
[10:31:45.537]                       else {
[10:31:45.537]                         version <- NULL
[10:31:45.537]                       }
[10:31:45.537]                       if (!has_future || version < "1.8.0") {
[10:31:45.537]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:45.537]                           "", base::R.version$version.string), 
[10:31:45.537]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:45.537]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:45.537]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:45.537]                             "release", "version")], collapse = " "), 
[10:31:45.537]                           hostname = base::Sys.info()[["nodename"]])
[10:31:45.537]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:45.537]                           info)
[10:31:45.537]                         info <- base::paste(info, collapse = "; ")
[10:31:45.537]                         if (!has_future) {
[10:31:45.537]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:45.537]                             info)
[10:31:45.537]                         }
[10:31:45.537]                         else {
[10:31:45.537]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:45.537]                             info, version)
[10:31:45.537]                         }
[10:31:45.537]                         base::stop(msg)
[10:31:45.537]                       }
[10:31:45.537]                     })
[10:31:45.537]                   }
[10:31:45.537]                   ...future.strategy.old <- future::plan("list")
[10:31:45.537]                   options(future.plan = NULL)
[10:31:45.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:45.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:45.537]                 }
[10:31:45.537]                 ...future.workdir <- getwd()
[10:31:45.537]             }
[10:31:45.537]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:45.537]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:45.537]         }
[10:31:45.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:45.537]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:45.537]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:45.537]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:45.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:45.537]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:45.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:45.537]             base::names(...future.oldOptions))
[10:31:45.537]     }
[10:31:45.537]     if (TRUE) {
[10:31:45.537]     }
[10:31:45.537]     else {
[10:31:45.537]         if (NA) {
[10:31:45.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:45.537]                 open = "w")
[10:31:45.537]         }
[10:31:45.537]         else {
[10:31:45.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:45.537]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:45.537]         }
[10:31:45.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:45.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:45.537]             base::sink(type = "output", split = FALSE)
[10:31:45.537]             base::close(...future.stdout)
[10:31:45.537]         }, add = TRUE)
[10:31:45.537]     }
[10:31:45.537]     ...future.frame <- base::sys.nframe()
[10:31:45.537]     ...future.conditions <- base::list()
[10:31:45.537]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:45.537]     if (FALSE) {
[10:31:45.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:45.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:45.537]     }
[10:31:45.537]     ...future.result <- base::tryCatch({
[10:31:45.537]         base::withCallingHandlers({
[10:31:45.537]             ...future.value <- base::withVisible(base::local({
[10:31:45.537]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:45.537]                 if (!identical(...future.globals.maxSize.org, 
[10:31:45.537]                   ...future.globals.maxSize)) {
[10:31:45.537]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:45.537]                   on.exit(options(oopts), add = TRUE)
[10:31:45.537]                 }
[10:31:45.537]                 {
[10:31:45.537]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:45.537]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:45.537]                     USE.NAMES = FALSE)
[10:31:45.537]                   do.call(mapply, args = args)
[10:31:45.537]                 }
[10:31:45.537]             }))
[10:31:45.537]             future::FutureResult(value = ...future.value$value, 
[10:31:45.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:45.537]                   ...future.rng), globalenv = if (FALSE) 
[10:31:45.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:45.537]                     ...future.globalenv.names))
[10:31:45.537]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:45.537]         }, condition = base::local({
[10:31:45.537]             c <- base::c
[10:31:45.537]             inherits <- base::inherits
[10:31:45.537]             invokeRestart <- base::invokeRestart
[10:31:45.537]             length <- base::length
[10:31:45.537]             list <- base::list
[10:31:45.537]             seq.int <- base::seq.int
[10:31:45.537]             signalCondition <- base::signalCondition
[10:31:45.537]             sys.calls <- base::sys.calls
[10:31:45.537]             `[[` <- base::`[[`
[10:31:45.537]             `+` <- base::`+`
[10:31:45.537]             `<<-` <- base::`<<-`
[10:31:45.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:45.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:45.537]                   3L)]
[10:31:45.537]             }
[10:31:45.537]             function(cond) {
[10:31:45.537]                 is_error <- inherits(cond, "error")
[10:31:45.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:45.537]                   NULL)
[10:31:45.537]                 if (is_error) {
[10:31:45.537]                   sessionInformation <- function() {
[10:31:45.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:45.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:45.537]                       search = base::search(), system = base::Sys.info())
[10:31:45.537]                   }
[10:31:45.537]                   ...future.conditions[[length(...future.conditions) + 
[10:31:45.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:45.537]                     cond$call), session = sessionInformation(), 
[10:31:45.537]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:45.537]                   signalCondition(cond)
[10:31:45.537]                 }
[10:31:45.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:45.537]                 "immediateCondition"))) {
[10:31:45.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:45.537]                   ...future.conditions[[length(...future.conditions) + 
[10:31:45.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:45.537]                   if (TRUE && !signal) {
[10:31:45.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:45.537]                     {
[10:31:45.537]                       inherits <- base::inherits
[10:31:45.537]                       invokeRestart <- base::invokeRestart
[10:31:45.537]                       is.null <- base::is.null
[10:31:45.537]                       muffled <- FALSE
[10:31:45.537]                       if (inherits(cond, "message")) {
[10:31:45.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:45.537]                         if (muffled) 
[10:31:45.537]                           invokeRestart("muffleMessage")
[10:31:45.537]                       }
[10:31:45.537]                       else if (inherits(cond, "warning")) {
[10:31:45.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:45.537]                         if (muffled) 
[10:31:45.537]                           invokeRestart("muffleWarning")
[10:31:45.537]                       }
[10:31:45.537]                       else if (inherits(cond, "condition")) {
[10:31:45.537]                         if (!is.null(pattern)) {
[10:31:45.537]                           computeRestarts <- base::computeRestarts
[10:31:45.537]                           grepl <- base::grepl
[10:31:45.537]                           restarts <- computeRestarts(cond)
[10:31:45.537]                           for (restart in restarts) {
[10:31:45.537]                             name <- restart$name
[10:31:45.537]                             if (is.null(name)) 
[10:31:45.537]                               next
[10:31:45.537]                             if (!grepl(pattern, name)) 
[10:31:45.537]                               next
[10:31:45.537]                             invokeRestart(restart)
[10:31:45.537]                             muffled <- TRUE
[10:31:45.537]                             break
[10:31:45.537]                           }
[10:31:45.537]                         }
[10:31:45.537]                       }
[10:31:45.537]                       invisible(muffled)
[10:31:45.537]                     }
[10:31:45.537]                     muffleCondition(cond, pattern = "^muffle")
[10:31:45.537]                   }
[10:31:45.537]                 }
[10:31:45.537]                 else {
[10:31:45.537]                   if (TRUE) {
[10:31:45.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:45.537]                     {
[10:31:45.537]                       inherits <- base::inherits
[10:31:45.537]                       invokeRestart <- base::invokeRestart
[10:31:45.537]                       is.null <- base::is.null
[10:31:45.537]                       muffled <- FALSE
[10:31:45.537]                       if (inherits(cond, "message")) {
[10:31:45.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:45.537]                         if (muffled) 
[10:31:45.537]                           invokeRestart("muffleMessage")
[10:31:45.537]                       }
[10:31:45.537]                       else if (inherits(cond, "warning")) {
[10:31:45.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:45.537]                         if (muffled) 
[10:31:45.537]                           invokeRestart("muffleWarning")
[10:31:45.537]                       }
[10:31:45.537]                       else if (inherits(cond, "condition")) {
[10:31:45.537]                         if (!is.null(pattern)) {
[10:31:45.537]                           computeRestarts <- base::computeRestarts
[10:31:45.537]                           grepl <- base::grepl
[10:31:45.537]                           restarts <- computeRestarts(cond)
[10:31:45.537]                           for (restart in restarts) {
[10:31:45.537]                             name <- restart$name
[10:31:45.537]                             if (is.null(name)) 
[10:31:45.537]                               next
[10:31:45.537]                             if (!grepl(pattern, name)) 
[10:31:45.537]                               next
[10:31:45.537]                             invokeRestart(restart)
[10:31:45.537]                             muffled <- TRUE
[10:31:45.537]                             break
[10:31:45.537]                           }
[10:31:45.537]                         }
[10:31:45.537]                       }
[10:31:45.537]                       invisible(muffled)
[10:31:45.537]                     }
[10:31:45.537]                     muffleCondition(cond, pattern = "^muffle")
[10:31:45.537]                   }
[10:31:45.537]                 }
[10:31:45.537]             }
[10:31:45.537]         }))
[10:31:45.537]     }, error = function(ex) {
[10:31:45.537]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:45.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:45.537]                 ...future.rng), started = ...future.startTime, 
[10:31:45.537]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:45.537]             version = "1.8"), class = "FutureResult")
[10:31:45.537]     }, finally = {
[10:31:45.537]         if (!identical(...future.workdir, getwd())) 
[10:31:45.537]             setwd(...future.workdir)
[10:31:45.537]         {
[10:31:45.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:45.537]                 ...future.oldOptions$nwarnings <- NULL
[10:31:45.537]             }
[10:31:45.537]             base::options(...future.oldOptions)
[10:31:45.537]             if (.Platform$OS.type == "windows") {
[10:31:45.537]                 old_names <- names(...future.oldEnvVars)
[10:31:45.537]                 envs <- base::Sys.getenv()
[10:31:45.537]                 names <- names(envs)
[10:31:45.537]                 common <- intersect(names, old_names)
[10:31:45.537]                 added <- setdiff(names, old_names)
[10:31:45.537]                 removed <- setdiff(old_names, names)
[10:31:45.537]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:45.537]                   envs[common]]
[10:31:45.537]                 NAMES <- toupper(changed)
[10:31:45.537]                 args <- list()
[10:31:45.537]                 for (kk in seq_along(NAMES)) {
[10:31:45.537]                   name <- changed[[kk]]
[10:31:45.537]                   NAME <- NAMES[[kk]]
[10:31:45.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:45.537]                     next
[10:31:45.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:45.537]                 }
[10:31:45.537]                 NAMES <- toupper(added)
[10:31:45.537]                 for (kk in seq_along(NAMES)) {
[10:31:45.537]                   name <- added[[kk]]
[10:31:45.537]                   NAME <- NAMES[[kk]]
[10:31:45.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:45.537]                     next
[10:31:45.537]                   args[[name]] <- ""
[10:31:45.537]                 }
[10:31:45.537]                 NAMES <- toupper(removed)
[10:31:45.537]                 for (kk in seq_along(NAMES)) {
[10:31:45.537]                   name <- removed[[kk]]
[10:31:45.537]                   NAME <- NAMES[[kk]]
[10:31:45.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:45.537]                     next
[10:31:45.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:45.537]                 }
[10:31:45.537]                 if (length(args) > 0) 
[10:31:45.537]                   base::do.call(base::Sys.setenv, args = args)
[10:31:45.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:45.537]             }
[10:31:45.537]             else {
[10:31:45.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:45.537]             }
[10:31:45.537]             {
[10:31:45.537]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:45.537]                   0L) {
[10:31:45.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:45.537]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:45.537]                   base::options(opts)
[10:31:45.537]                 }
[10:31:45.537]                 {
[10:31:45.537]                   {
[10:31:45.537]                     NULL
[10:31:45.537]                     RNGkind("Mersenne-Twister")
[10:31:45.537]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:45.537]                       inherits = FALSE)
[10:31:45.537]                   }
[10:31:45.537]                   options(future.plan = NULL)
[10:31:45.537]                   if (is.na(NA_character_)) 
[10:31:45.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:45.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:45.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:45.537]                     .init = FALSE)
[10:31:45.537]                 }
[10:31:45.537]             }
[10:31:45.537]         }
[10:31:45.537]     })
[10:31:45.537]     if (FALSE) {
[10:31:45.537]         base::sink(type = "output", split = FALSE)
[10:31:45.537]         if (NA) {
[10:31:45.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:45.537]         }
[10:31:45.537]         else {
[10:31:45.537]             ...future.result["stdout"] <- base::list(NULL)
[10:31:45.537]         }
[10:31:45.537]         base::close(...future.stdout)
[10:31:45.537]         ...future.stdout <- NULL
[10:31:45.537]     }
[10:31:45.537]     ...future.result$conditions <- ...future.conditions
[10:31:45.537]     ...future.result$finished <- base::Sys.time()
[10:31:45.537]     ...future.result
[10:31:45.537] }
[10:31:45.539] assign_globals() ...
[10:31:45.539] List of 5
[10:31:45.539]  $ ...future.FUN            :function (x, y)  
[10:31:45.539]  $ MoreArgs                 : NULL
[10:31:45.539]  $ ...future.elements_ii    :List of 2
[10:31:45.539]   ..$ :List of 2
[10:31:45.539]   .. ..$ : int 1
[10:31:45.539]   .. ..$ : int 0
[10:31:45.539]   ..$ :List of 2
[10:31:45.539]   .. ..$ : int 0
[10:31:45.539]   .. ..$ : int 1
[10:31:45.539]  $ ...future.seeds_ii       : NULL
[10:31:45.539]  $ ...future.globals.maxSize: NULL
[10:31:45.539]  - attr(*, "where")=List of 5
[10:31:45.539]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:45.539]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:45.539]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:45.539]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:45.539]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:45.539]  - attr(*, "resolved")= logi FALSE
[10:31:45.539]  - attr(*, "total_size")= num 6480
[10:31:45.539]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:45.539]  - attr(*, "already-done")= logi TRUE
[10:31:45.545] - reassign environment for ‘...future.FUN’
[10:31:45.545] - copied ‘...future.FUN’ to environment
[10:31:45.545] - copied ‘MoreArgs’ to environment
[10:31:45.545] - copied ‘...future.elements_ii’ to environment
[10:31:45.546] - copied ‘...future.seeds_ii’ to environment
[10:31:45.546] - copied ‘...future.globals.maxSize’ to environment
[10:31:45.546] assign_globals() ... done
[10:31:45.546] plan(): Setting new future strategy stack:
[10:31:45.546] List of future strategies:
[10:31:45.546] 1. sequential:
[10:31:45.546]    - args: function (..., envir = parent.frame())
[10:31:45.546]    - tweaked: FALSE
[10:31:45.546]    - call: NULL
[10:31:45.547] plan(): nbrOfWorkers() = 1
[10:31:46.048] plan(): Setting new future strategy stack:
[10:31:46.048] List of future strategies:
[10:31:46.048] 1. multisession:
[10:31:46.048]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:46.048]    - tweaked: FALSE
[10:31:46.048]    - call: plan(strategy)
[10:31:46.052] plan(): nbrOfWorkers() = 1
[10:31:46.053] SequentialFuture started (and completed)
[10:31:46.053] - Launch lazy future ... done
[10:31:46.053] run() for ‘SequentialFuture’ ... done
[10:31:46.053] Created future:
[10:31:46.053] SequentialFuture:
[10:31:46.053] Label: ‘future_mapply-1’
[10:31:46.053] Expression:
[10:31:46.053] {
[10:31:46.053]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.053]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:46.053]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.053]         on.exit(options(oopts), add = TRUE)
[10:31:46.053]     }
[10:31:46.053]     {
[10:31:46.053]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:46.053]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:46.053]         do.call(mapply, args = args)
[10:31:46.053]     }
[10:31:46.053] }
[10:31:46.053] Lazy evaluation: FALSE
[10:31:46.053] Asynchronous evaluation: FALSE
[10:31:46.053] Local evaluation: TRUE
[10:31:46.053] Environment: R_GlobalEnv
[10:31:46.053] Capture standard output: NA
[10:31:46.053] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:46.053] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:46.053] Packages: <none>
[10:31:46.053] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:46.053] Resolved: TRUE
[10:31:46.053] Value: 224 bytes of class ‘list’
[10:31:46.053] Early signaling: FALSE
[10:31:46.053] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:46.053] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:46.054] Chunk #1 of 1 ... DONE
[10:31:46.054] Launching 1 futures (chunks) ... DONE
[10:31:46.054] Resolving 1 futures (chunks) ...
[10:31:46.054] resolve() on list ...
[10:31:46.054]  recursive: 0
[10:31:46.055]  length: 1
[10:31:46.055] 
[10:31:46.055] resolved() for ‘SequentialFuture’ ...
[10:31:46.055] - state: ‘finished’
[10:31:46.055] - run: TRUE
[10:31:46.055] - result: ‘FutureResult’
[10:31:46.055] resolved() for ‘SequentialFuture’ ... done
[10:31:46.055] Future #1
[10:31:46.055] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:46.056] - nx: 1
[10:31:46.056] - relay: TRUE
[10:31:46.056] - stdout: TRUE
[10:31:46.056] - signal: TRUE
[10:31:46.056] - resignal: FALSE
[10:31:46.056] - force: TRUE
[10:31:46.056] - relayed: [n=1] FALSE
[10:31:46.056] - queued futures: [n=1] FALSE
[10:31:46.056]  - until=1
[10:31:46.056]  - relaying element #1
[10:31:46.057] - relayed: [n=1] TRUE
[10:31:46.057] - queued futures: [n=1] TRUE
[10:31:46.057] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:46.057]  length: 0 (resolved future 1)
[10:31:46.057] Relaying remaining futures
[10:31:46.057] signalConditionsASAP(NULL, pos=0) ...
[10:31:46.057] - nx: 1
[10:31:46.057] - relay: TRUE
[10:31:46.057] - stdout: TRUE
[10:31:46.057] - signal: TRUE
[10:31:46.058] - resignal: FALSE
[10:31:46.058] - force: TRUE
[10:31:46.058] - relayed: [n=1] TRUE
[10:31:46.058] - queued futures: [n=1] TRUE
 - flush all
[10:31:46.058] - relayed: [n=1] TRUE
[10:31:46.058] - queued futures: [n=1] TRUE
[10:31:46.058] signalConditionsASAP(NULL, pos=0) ... done
[10:31:46.058] resolve() on list ... DONE
[10:31:46.058]  - Number of value chunks collected: 1
[10:31:46.058] Resolving 1 futures (chunks) ... DONE
[10:31:46.059] Reducing values from 1 chunks ...
[10:31:46.059]  - Number of values collected after concatenation: 2
[10:31:46.059]  - Number of values expected: 2
[10:31:46.059] Reducing values from 1 chunks ... DONE
[10:31:46.059] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[10:31:46.063] plan(): Setting new future strategy stack:
[10:31:46.063] List of future strategies:
[10:31:46.063] 1. multicore:
[10:31:46.063]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:46.063]    - tweaked: FALSE
[10:31:46.063]    - call: plan(strategy)
[10:31:46.067] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:31:46.067] future_lapply() ...
[10:31:46.075] Number of chunks: 2
[10:31:46.075] getGlobalsAndPackagesXApply() ...
[10:31:46.075]  - future.globals: TRUE
[10:31:46.076] getGlobalsAndPackages() ...
[10:31:46.076] Searching for globals...
[10:31:46.077] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:46.077] Searching for globals ... DONE
[10:31:46.077] Resolving globals: FALSE
[10:31:46.078] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:46.078] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:46.078] - globals: [1] ‘FUN’
[10:31:46.078] 
[10:31:46.078] getGlobalsAndPackages() ... DONE
[10:31:46.079]  - globals found/used: [n=1] ‘FUN’
[10:31:46.079]  - needed namespaces: [n=0] 
[10:31:46.079] Finding globals ... DONE
[10:31:46.079]  - use_args: TRUE
[10:31:46.079]  - Getting '...' globals ...
[10:31:46.079] resolve() on list ...
[10:31:46.079]  recursive: 0
[10:31:46.079]  length: 1
[10:31:46.079]  elements: ‘...’
[10:31:46.080]  length: 0 (resolved future 1)
[10:31:46.080] resolve() on list ... DONE
[10:31:46.080]    - '...' content: [n=0] 
[10:31:46.080] List of 1
[10:31:46.080]  $ ...: list()
[10:31:46.080]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:46.080]  - attr(*, "where")=List of 1
[10:31:46.080]   ..$ ...:<environment: 0x564ff43a8fe0> 
[10:31:46.080]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:46.080]  - attr(*, "resolved")= logi TRUE
[10:31:46.080]  - attr(*, "total_size")= num NA
[10:31:46.083]  - Getting '...' globals ... DONE
[10:31:46.083] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:46.083] List of 2
[10:31:46.083]  $ ...future.FUN:function (x)  
[10:31:46.083]  $ ...          : list()
[10:31:46.083]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:46.083]  - attr(*, "where")=List of 2
[10:31:46.083]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:46.083]   ..$ ...          :<environment: 0x564ff43a8fe0> 
[10:31:46.083]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:46.083]  - attr(*, "resolved")= logi FALSE
[10:31:46.083]  - attr(*, "total_size")= num 4720
[10:31:46.086] Packages to be attached in all futures: [n=0] 
[10:31:46.086] getGlobalsAndPackagesXApply() ... DONE
[10:31:46.086] Number of futures (= number of chunks): 2
[10:31:46.086] Launching 2 futures (chunks) ...
[10:31:46.086] Chunk #1 of 2 ...
[10:31:46.086]  - Finding globals in 'X' for chunk #1 ...
[10:31:46.086] getGlobalsAndPackages() ...
[10:31:46.086] Searching for globals...
[10:31:46.087] 
[10:31:46.087] Searching for globals ... DONE
[10:31:46.087] - globals: [0] <none>
[10:31:46.087] getGlobalsAndPackages() ... DONE
[10:31:46.087]    + additional globals found: [n=0] 
[10:31:46.087]    + additional namespaces needed: [n=0] 
[10:31:46.087]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:46.087]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:46.087]  - seeds: <none>
[10:31:46.088]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:46.088] getGlobalsAndPackages() ...
[10:31:46.088] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:46.088] Resolving globals: FALSE
[10:31:46.088] Tweak future expression to call with '...' arguments ...
[10:31:46.088] {
[10:31:46.088]     do.call(function(...) {
[10:31:46.088]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.088]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:46.088]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.088]             on.exit(options(oopts), add = TRUE)
[10:31:46.088]         }
[10:31:46.088]         {
[10:31:46.088]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:46.088]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:46.088]                 ...future.FUN(...future.X_jj, ...)
[10:31:46.088]             })
[10:31:46.088]         }
[10:31:46.088]     }, args = future.call.arguments)
[10:31:46.088] }
[10:31:46.088] Tweak future expression to call with '...' arguments ... DONE
[10:31:46.089] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:46.089] 
[10:31:46.089] getGlobalsAndPackages() ... DONE
[10:31:46.089] run() for ‘Future’ ...
[10:31:46.089] - state: ‘created’
[10:31:46.090] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:46.093] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:46.093] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:46.093]   - Field: ‘label’
[10:31:46.094]   - Field: ‘local’
[10:31:46.094]   - Field: ‘owner’
[10:31:46.094]   - Field: ‘envir’
[10:31:46.094]   - Field: ‘workers’
[10:31:46.094]   - Field: ‘packages’
[10:31:46.094]   - Field: ‘gc’
[10:31:46.094]   - Field: ‘job’
[10:31:46.094]   - Field: ‘conditions’
[10:31:46.094]   - Field: ‘expr’
[10:31:46.094]   - Field: ‘uuid’
[10:31:46.095]   - Field: ‘seed’
[10:31:46.095]   - Field: ‘version’
[10:31:46.095]   - Field: ‘result’
[10:31:46.095]   - Field: ‘asynchronous’
[10:31:46.095]   - Field: ‘calls’
[10:31:46.095]   - Field: ‘globals’
[10:31:46.095]   - Field: ‘stdout’
[10:31:46.095]   - Field: ‘earlySignal’
[10:31:46.095]   - Field: ‘lazy’
[10:31:46.095]   - Field: ‘state’
[10:31:46.095] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:46.096] - Launch lazy future ...
[10:31:46.097] Packages needed by the future expression (n = 0): <none>
[10:31:46.097] Packages needed by future strategies (n = 0): <none>
[10:31:46.097] {
[10:31:46.097]     {
[10:31:46.097]         {
[10:31:46.097]             ...future.startTime <- base::Sys.time()
[10:31:46.097]             {
[10:31:46.097]                 {
[10:31:46.097]                   {
[10:31:46.097]                     {
[10:31:46.097]                       base::local({
[10:31:46.097]                         has_future <- base::requireNamespace("future", 
[10:31:46.097]                           quietly = TRUE)
[10:31:46.097]                         if (has_future) {
[10:31:46.097]                           ns <- base::getNamespace("future")
[10:31:46.097]                           version <- ns[[".package"]][["version"]]
[10:31:46.097]                           if (is.null(version)) 
[10:31:46.097]                             version <- utils::packageVersion("future")
[10:31:46.097]                         }
[10:31:46.097]                         else {
[10:31:46.097]                           version <- NULL
[10:31:46.097]                         }
[10:31:46.097]                         if (!has_future || version < "1.8.0") {
[10:31:46.097]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:46.097]                             "", base::R.version$version.string), 
[10:31:46.097]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:46.097]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:46.097]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:46.097]                               "release", "version")], collapse = " "), 
[10:31:46.097]                             hostname = base::Sys.info()[["nodename"]])
[10:31:46.097]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:46.097]                             info)
[10:31:46.097]                           info <- base::paste(info, collapse = "; ")
[10:31:46.097]                           if (!has_future) {
[10:31:46.097]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:46.097]                               info)
[10:31:46.097]                           }
[10:31:46.097]                           else {
[10:31:46.097]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:46.097]                               info, version)
[10:31:46.097]                           }
[10:31:46.097]                           base::stop(msg)
[10:31:46.097]                         }
[10:31:46.097]                       })
[10:31:46.097]                     }
[10:31:46.097]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:46.097]                     base::options(mc.cores = 1L)
[10:31:46.097]                   }
[10:31:46.097]                   ...future.strategy.old <- future::plan("list")
[10:31:46.097]                   options(future.plan = NULL)
[10:31:46.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:46.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:46.097]                 }
[10:31:46.097]                 ...future.workdir <- getwd()
[10:31:46.097]             }
[10:31:46.097]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:46.097]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:46.097]         }
[10:31:46.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:46.097]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:46.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:46.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:46.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:46.097]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:46.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:46.097]             base::names(...future.oldOptions))
[10:31:46.097]     }
[10:31:46.097]     if (FALSE) {
[10:31:46.097]     }
[10:31:46.097]     else {
[10:31:46.097]         if (FALSE) {
[10:31:46.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:46.097]                 open = "w")
[10:31:46.097]         }
[10:31:46.097]         else {
[10:31:46.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:46.097]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:46.097]         }
[10:31:46.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:46.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:46.097]             base::sink(type = "output", split = FALSE)
[10:31:46.097]             base::close(...future.stdout)
[10:31:46.097]         }, add = TRUE)
[10:31:46.097]     }
[10:31:46.097]     ...future.frame <- base::sys.nframe()
[10:31:46.097]     ...future.conditions <- base::list()
[10:31:46.097]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:46.097]     if (FALSE) {
[10:31:46.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:46.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:46.097]     }
[10:31:46.097]     ...future.result <- base::tryCatch({
[10:31:46.097]         base::withCallingHandlers({
[10:31:46.097]             ...future.value <- base::withVisible(base::local({
[10:31:46.097]                 withCallingHandlers({
[10:31:46.097]                   {
[10:31:46.097]                     do.call(function(...) {
[10:31:46.097]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.097]                       if (!identical(...future.globals.maxSize.org, 
[10:31:46.097]                         ...future.globals.maxSize)) {
[10:31:46.097]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.097]                         on.exit(options(oopts), add = TRUE)
[10:31:46.097]                       }
[10:31:46.097]                       {
[10:31:46.097]                         lapply(seq_along(...future.elements_ii), 
[10:31:46.097]                           FUN = function(jj) {
[10:31:46.097]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:46.097]                             ...future.FUN(...future.X_jj, ...)
[10:31:46.097]                           })
[10:31:46.097]                       }
[10:31:46.097]                     }, args = future.call.arguments)
[10:31:46.097]                   }
[10:31:46.097]                 }, immediateCondition = function(cond) {
[10:31:46.097]                   save_rds <- function (object, pathname, ...) 
[10:31:46.097]                   {
[10:31:46.097]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:46.097]                     if (file_test("-f", pathname_tmp)) {
[10:31:46.097]                       fi_tmp <- file.info(pathname_tmp)
[10:31:46.097]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:46.097]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:46.097]                         fi_tmp[["mtime"]])
[10:31:46.097]                     }
[10:31:46.097]                     tryCatch({
[10:31:46.097]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:46.097]                     }, error = function(ex) {
[10:31:46.097]                       msg <- conditionMessage(ex)
[10:31:46.097]                       fi_tmp <- file.info(pathname_tmp)
[10:31:46.097]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:46.097]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:46.097]                         fi_tmp[["mtime"]], msg)
[10:31:46.097]                       ex$message <- msg
[10:31:46.097]                       stop(ex)
[10:31:46.097]                     })
[10:31:46.097]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:46.097]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:46.097]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:46.097]                       fi_tmp <- file.info(pathname_tmp)
[10:31:46.097]                       fi <- file.info(pathname)
[10:31:46.097]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:46.097]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:46.097]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:46.097]                         fi[["size"]], fi[["mtime"]])
[10:31:46.097]                       stop(msg)
[10:31:46.097]                     }
[10:31:46.097]                     invisible(pathname)
[10:31:46.097]                   }
[10:31:46.097]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:46.097]                     rootPath = tempdir()) 
[10:31:46.097]                   {
[10:31:46.097]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:46.097]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:46.097]                       tmpdir = path, fileext = ".rds")
[10:31:46.097]                     save_rds(obj, file)
[10:31:46.097]                   }
[10:31:46.097]                   saveImmediateCondition(cond, path = "/tmp/Rtmptsj9Jv/.future/immediateConditions")
[10:31:46.097]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:46.097]                   {
[10:31:46.097]                     inherits <- base::inherits
[10:31:46.097]                     invokeRestart <- base::invokeRestart
[10:31:46.097]                     is.null <- base::is.null
[10:31:46.097]                     muffled <- FALSE
[10:31:46.097]                     if (inherits(cond, "message")) {
[10:31:46.097]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:46.097]                       if (muffled) 
[10:31:46.097]                         invokeRestart("muffleMessage")
[10:31:46.097]                     }
[10:31:46.097]                     else if (inherits(cond, "warning")) {
[10:31:46.097]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:46.097]                       if (muffled) 
[10:31:46.097]                         invokeRestart("muffleWarning")
[10:31:46.097]                     }
[10:31:46.097]                     else if (inherits(cond, "condition")) {
[10:31:46.097]                       if (!is.null(pattern)) {
[10:31:46.097]                         computeRestarts <- base::computeRestarts
[10:31:46.097]                         grepl <- base::grepl
[10:31:46.097]                         restarts <- computeRestarts(cond)
[10:31:46.097]                         for (restart in restarts) {
[10:31:46.097]                           name <- restart$name
[10:31:46.097]                           if (is.null(name)) 
[10:31:46.097]                             next
[10:31:46.097]                           if (!grepl(pattern, name)) 
[10:31:46.097]                             next
[10:31:46.097]                           invokeRestart(restart)
[10:31:46.097]                           muffled <- TRUE
[10:31:46.097]                           break
[10:31:46.097]                         }
[10:31:46.097]                       }
[10:31:46.097]                     }
[10:31:46.097]                     invisible(muffled)
[10:31:46.097]                   }
[10:31:46.097]                   muffleCondition(cond)
[10:31:46.097]                 })
[10:31:46.097]             }))
[10:31:46.097]             future::FutureResult(value = ...future.value$value, 
[10:31:46.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:46.097]                   ...future.rng), globalenv = if (FALSE) 
[10:31:46.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:46.097]                     ...future.globalenv.names))
[10:31:46.097]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:46.097]         }, condition = base::local({
[10:31:46.097]             c <- base::c
[10:31:46.097]             inherits <- base::inherits
[10:31:46.097]             invokeRestart <- base::invokeRestart
[10:31:46.097]             length <- base::length
[10:31:46.097]             list <- base::list
[10:31:46.097]             seq.int <- base::seq.int
[10:31:46.097]             signalCondition <- base::signalCondition
[10:31:46.097]             sys.calls <- base::sys.calls
[10:31:46.097]             `[[` <- base::`[[`
[10:31:46.097]             `+` <- base::`+`
[10:31:46.097]             `<<-` <- base::`<<-`
[10:31:46.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:46.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:46.097]                   3L)]
[10:31:46.097]             }
[10:31:46.097]             function(cond) {
[10:31:46.097]                 is_error <- inherits(cond, "error")
[10:31:46.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:46.097]                   NULL)
[10:31:46.097]                 if (is_error) {
[10:31:46.097]                   sessionInformation <- function() {
[10:31:46.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:46.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:46.097]                       search = base::search(), system = base::Sys.info())
[10:31:46.097]                   }
[10:31:46.097]                   ...future.conditions[[length(...future.conditions) + 
[10:31:46.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:46.097]                     cond$call), session = sessionInformation(), 
[10:31:46.097]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:46.097]                   signalCondition(cond)
[10:31:46.097]                 }
[10:31:46.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:46.097]                 "immediateCondition"))) {
[10:31:46.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:46.097]                   ...future.conditions[[length(...future.conditions) + 
[10:31:46.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:46.097]                   if (TRUE && !signal) {
[10:31:46.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:46.097]                     {
[10:31:46.097]                       inherits <- base::inherits
[10:31:46.097]                       invokeRestart <- base::invokeRestart
[10:31:46.097]                       is.null <- base::is.null
[10:31:46.097]                       muffled <- FALSE
[10:31:46.097]                       if (inherits(cond, "message")) {
[10:31:46.097]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:46.097]                         if (muffled) 
[10:31:46.097]                           invokeRestart("muffleMessage")
[10:31:46.097]                       }
[10:31:46.097]                       else if (inherits(cond, "warning")) {
[10:31:46.097]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:46.097]                         if (muffled) 
[10:31:46.097]                           invokeRestart("muffleWarning")
[10:31:46.097]                       }
[10:31:46.097]                       else if (inherits(cond, "condition")) {
[10:31:46.097]                         if (!is.null(pattern)) {
[10:31:46.097]                           computeRestarts <- base::computeRestarts
[10:31:46.097]                           grepl <- base::grepl
[10:31:46.097]                           restarts <- computeRestarts(cond)
[10:31:46.097]                           for (restart in restarts) {
[10:31:46.097]                             name <- restart$name
[10:31:46.097]                             if (is.null(name)) 
[10:31:46.097]                               next
[10:31:46.097]                             if (!grepl(pattern, name)) 
[10:31:46.097]                               next
[10:31:46.097]                             invokeRestart(restart)
[10:31:46.097]                             muffled <- TRUE
[10:31:46.097]                             break
[10:31:46.097]                           }
[10:31:46.097]                         }
[10:31:46.097]                       }
[10:31:46.097]                       invisible(muffled)
[10:31:46.097]                     }
[10:31:46.097]                     muffleCondition(cond, pattern = "^muffle")
[10:31:46.097]                   }
[10:31:46.097]                 }
[10:31:46.097]                 else {
[10:31:46.097]                   if (TRUE) {
[10:31:46.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:46.097]                     {
[10:31:46.097]                       inherits <- base::inherits
[10:31:46.097]                       invokeRestart <- base::invokeRestart
[10:31:46.097]                       is.null <- base::is.null
[10:31:46.097]                       muffled <- FALSE
[10:31:46.097]                       if (inherits(cond, "message")) {
[10:31:46.097]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:46.097]                         if (muffled) 
[10:31:46.097]                           invokeRestart("muffleMessage")
[10:31:46.097]                       }
[10:31:46.097]                       else if (inherits(cond, "warning")) {
[10:31:46.097]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:46.097]                         if (muffled) 
[10:31:46.097]                           invokeRestart("muffleWarning")
[10:31:46.097]                       }
[10:31:46.097]                       else if (inherits(cond, "condition")) {
[10:31:46.097]                         if (!is.null(pattern)) {
[10:31:46.097]                           computeRestarts <- base::computeRestarts
[10:31:46.097]                           grepl <- base::grepl
[10:31:46.097]                           restarts <- computeRestarts(cond)
[10:31:46.097]                           for (restart in restarts) {
[10:31:46.097]                             name <- restart$name
[10:31:46.097]                             if (is.null(name)) 
[10:31:46.097]                               next
[10:31:46.097]                             if (!grepl(pattern, name)) 
[10:31:46.097]                               next
[10:31:46.097]                             invokeRestart(restart)
[10:31:46.097]                             muffled <- TRUE
[10:31:46.097]                             break
[10:31:46.097]                           }
[10:31:46.097]                         }
[10:31:46.097]                       }
[10:31:46.097]                       invisible(muffled)
[10:31:46.097]                     }
[10:31:46.097]                     muffleCondition(cond, pattern = "^muffle")
[10:31:46.097]                   }
[10:31:46.097]                 }
[10:31:46.097]             }
[10:31:46.097]         }))
[10:31:46.097]     }, error = function(ex) {
[10:31:46.097]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:46.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:46.097]                 ...future.rng), started = ...future.startTime, 
[10:31:46.097]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:46.097]             version = "1.8"), class = "FutureResult")
[10:31:46.097]     }, finally = {
[10:31:46.097]         if (!identical(...future.workdir, getwd())) 
[10:31:46.097]             setwd(...future.workdir)
[10:31:46.097]         {
[10:31:46.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:46.097]                 ...future.oldOptions$nwarnings <- NULL
[10:31:46.097]             }
[10:31:46.097]             base::options(...future.oldOptions)
[10:31:46.097]             if (.Platform$OS.type == "windows") {
[10:31:46.097]                 old_names <- names(...future.oldEnvVars)
[10:31:46.097]                 envs <- base::Sys.getenv()
[10:31:46.097]                 names <- names(envs)
[10:31:46.097]                 common <- intersect(names, old_names)
[10:31:46.097]                 added <- setdiff(names, old_names)
[10:31:46.097]                 removed <- setdiff(old_names, names)
[10:31:46.097]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:46.097]                   envs[common]]
[10:31:46.097]                 NAMES <- toupper(changed)
[10:31:46.097]                 args <- list()
[10:31:46.097]                 for (kk in seq_along(NAMES)) {
[10:31:46.097]                   name <- changed[[kk]]
[10:31:46.097]                   NAME <- NAMES[[kk]]
[10:31:46.097]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:46.097]                     next
[10:31:46.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:46.097]                 }
[10:31:46.097]                 NAMES <- toupper(added)
[10:31:46.097]                 for (kk in seq_along(NAMES)) {
[10:31:46.097]                   name <- added[[kk]]
[10:31:46.097]                   NAME <- NAMES[[kk]]
[10:31:46.097]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:46.097]                     next
[10:31:46.097]                   args[[name]] <- ""
[10:31:46.097]                 }
[10:31:46.097]                 NAMES <- toupper(removed)
[10:31:46.097]                 for (kk in seq_along(NAMES)) {
[10:31:46.097]                   name <- removed[[kk]]
[10:31:46.097]                   NAME <- NAMES[[kk]]
[10:31:46.097]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:46.097]                     next
[10:31:46.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:46.097]                 }
[10:31:46.097]                 if (length(args) > 0) 
[10:31:46.097]                   base::do.call(base::Sys.setenv, args = args)
[10:31:46.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:46.097]             }
[10:31:46.097]             else {
[10:31:46.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:46.097]             }
[10:31:46.097]             {
[10:31:46.097]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:46.097]                   0L) {
[10:31:46.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:46.097]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:46.097]                   base::options(opts)
[10:31:46.097]                 }
[10:31:46.097]                 {
[10:31:46.097]                   {
[10:31:46.097]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:46.097]                     NULL
[10:31:46.097]                   }
[10:31:46.097]                   options(future.plan = NULL)
[10:31:46.097]                   if (is.na(NA_character_)) 
[10:31:46.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:46.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:46.097]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:46.097]                     .init = FALSE)
[10:31:46.097]                 }
[10:31:46.097]             }
[10:31:46.097]         }
[10:31:46.097]     })
[10:31:46.097]     if (TRUE) {
[10:31:46.097]         base::sink(type = "output", split = FALSE)
[10:31:46.097]         if (FALSE) {
[10:31:46.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:46.097]         }
[10:31:46.097]         else {
[10:31:46.097]             ...future.result["stdout"] <- base::list(NULL)
[10:31:46.097]         }
[10:31:46.097]         base::close(...future.stdout)
[10:31:46.097]         ...future.stdout <- NULL
[10:31:46.097]     }
[10:31:46.097]     ...future.result$conditions <- ...future.conditions
[10:31:46.097]     ...future.result$finished <- base::Sys.time()
[10:31:46.097]     ...future.result
[10:31:46.097] }
[10:31:46.100] assign_globals() ...
[10:31:46.100] List of 5
[10:31:46.100]  $ ...future.FUN            :function (x)  
[10:31:46.100]  $ future.call.arguments    : list()
[10:31:46.100]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:46.100]  $ ...future.elements_ii    :List of 1
[10:31:46.100]   ..$ : int 1
[10:31:46.100]  $ ...future.seeds_ii       : NULL
[10:31:46.100]  $ ...future.globals.maxSize: NULL
[10:31:46.100]  - attr(*, "where")=List of 5
[10:31:46.100]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:46.100]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:46.100]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:46.100]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:46.100]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:46.100]  - attr(*, "resolved")= logi FALSE
[10:31:46.100]  - attr(*, "total_size")= num 4720
[10:31:46.100]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:46.100]  - attr(*, "already-done")= logi TRUE
[10:31:46.107] - reassign environment for ‘...future.FUN’
[10:31:46.107] - copied ‘...future.FUN’ to environment
[10:31:46.107] - copied ‘future.call.arguments’ to environment
[10:31:46.107] - copied ‘...future.elements_ii’ to environment
[10:31:46.107] - copied ‘...future.seeds_ii’ to environment
[10:31:46.107] - copied ‘...future.globals.maxSize’ to environment
[10:31:46.108] assign_globals() ... done
[10:31:46.108] requestCore(): workers = 2
[10:31:46.111] MulticoreFuture started
[10:31:46.112] - Launch lazy future ... done
[10:31:46.112] plan(): Setting new future strategy stack:
[10:31:46.112] run() for ‘MulticoreFuture’ ... done
[10:31:46.112] Created future:
[10:31:46.112] List of future strategies:
[10:31:46.112] 1. sequential:
[10:31:46.112]    - args: function (..., envir = parent.frame())
[10:31:46.112]    - tweaked: FALSE
[10:31:46.112]    - call: NULL
[10:31:46.113] plan(): nbrOfWorkers() = 1
[10:31:46.113] MulticoreFuture:
[10:31:46.113] Label: ‘future_lapply-1’
[10:31:46.113] Expression:
[10:31:46.113] {
[10:31:46.113]     do.call(function(...) {
[10:31:46.113]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.113]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:46.113]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.113]             on.exit(options(oopts), add = TRUE)
[10:31:46.113]         }
[10:31:46.113]         {
[10:31:46.113]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:46.113]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:46.113]                 ...future.FUN(...future.X_jj, ...)
[10:31:46.113]             })
[10:31:46.113]         }
[10:31:46.113]     }, args = future.call.arguments)
[10:31:46.113] }
[10:31:46.113] Lazy evaluation: FALSE
[10:31:46.113] Asynchronous evaluation: TRUE
[10:31:46.113] Local evaluation: TRUE
[10:31:46.113] Environment: R_GlobalEnv
[10:31:46.113] Capture standard output: FALSE
[10:31:46.113] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:46.113] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:46.113] Packages: <none>
[10:31:46.113] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:46.113] Resolved: FALSE
[10:31:46.113] Value: <not collected>
[10:31:46.113] Conditions captured: <none>
[10:31:46.113] Early signaling: FALSE
[10:31:46.113] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:46.113] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:46.128] Chunk #1 of 2 ... DONE
[10:31:46.128] Chunk #2 of 2 ...
[10:31:46.128]  - Finding globals in 'X' for chunk #2 ...
[10:31:46.128] getGlobalsAndPackages() ...
[10:31:46.128] Searching for globals...
[10:31:46.129] 
[10:31:46.129] Searching for globals ... DONE
[10:31:46.129] - globals: [0] <none>
[10:31:46.129] getGlobalsAndPackages() ... DONE
[10:31:46.130]    + additional globals found: [n=0] 
[10:31:46.130]    + additional namespaces needed: [n=0] 
[10:31:46.130]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:46.130]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:46.130]  - seeds: <none>
[10:31:46.130]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:46.131] getGlobalsAndPackages() ...
[10:31:46.131] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:46.131] Resolving globals: FALSE
[10:31:46.131] Tweak future expression to call with '...' arguments ...
[10:31:46.131] {
[10:31:46.131]     do.call(function(...) {
[10:31:46.131]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.131]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:46.131]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.131]             on.exit(options(oopts), add = TRUE)
[10:31:46.131]         }
[10:31:46.131]         {
[10:31:46.131]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:46.131]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:46.131]                 ...future.FUN(...future.X_jj, ...)
[10:31:46.131]             })
[10:31:46.131]         }
[10:31:46.131]     }, args = future.call.arguments)
[10:31:46.131] }
[10:31:46.132] Tweak future expression to call with '...' arguments ... DONE
[10:31:46.132] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:46.133] 
[10:31:46.133] getGlobalsAndPackages() ... DONE
[10:31:46.133] run() for ‘Future’ ...
[10:31:46.133] - state: ‘created’
[10:31:46.134] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:46.139] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:46.139] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:46.139]   - Field: ‘label’
[10:31:46.139]   - Field: ‘local’
[10:31:46.139]   - Field: ‘owner’
[10:31:46.139]   - Field: ‘envir’
[10:31:46.140]   - Field: ‘workers’
[10:31:46.140]   - Field: ‘packages’
[10:31:46.140]   - Field: ‘gc’
[10:31:46.140]   - Field: ‘job’
[10:31:46.140]   - Field: ‘conditions’
[10:31:46.140]   - Field: ‘expr’
[10:31:46.141]   - Field: ‘uuid’
[10:31:46.141]   - Field: ‘seed’
[10:31:46.141]   - Field: ‘version’
[10:31:46.141]   - Field: ‘result’
[10:31:46.141]   - Field: ‘asynchronous’
[10:31:46.141]   - Field: ‘calls’
[10:31:46.141]   - Field: ‘globals’
[10:31:46.142]   - Field: ‘stdout’
[10:31:46.142]   - Field: ‘earlySignal’
[10:31:46.142]   - Field: ‘lazy’
[10:31:46.142]   - Field: ‘state’
[10:31:46.142] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:46.142] - Launch lazy future ...
[10:31:46.143] Packages needed by the future expression (n = 0): <none>
[10:31:46.143] Packages needed by future strategies (n = 0): <none>
[10:31:46.144] {
[10:31:46.144]     {
[10:31:46.144]         {
[10:31:46.144]             ...future.startTime <- base::Sys.time()
[10:31:46.144]             {
[10:31:46.144]                 {
[10:31:46.144]                   {
[10:31:46.144]                     {
[10:31:46.144]                       base::local({
[10:31:46.144]                         has_future <- base::requireNamespace("future", 
[10:31:46.144]                           quietly = TRUE)
[10:31:46.144]                         if (has_future) {
[10:31:46.144]                           ns <- base::getNamespace("future")
[10:31:46.144]                           version <- ns[[".package"]][["version"]]
[10:31:46.144]                           if (is.null(version)) 
[10:31:46.144]                             version <- utils::packageVersion("future")
[10:31:46.144]                         }
[10:31:46.144]                         else {
[10:31:46.144]                           version <- NULL
[10:31:46.144]                         }
[10:31:46.144]                         if (!has_future || version < "1.8.0") {
[10:31:46.144]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:46.144]                             "", base::R.version$version.string), 
[10:31:46.144]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:46.144]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:46.144]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:46.144]                               "release", "version")], collapse = " "), 
[10:31:46.144]                             hostname = base::Sys.info()[["nodename"]])
[10:31:46.144]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:46.144]                             info)
[10:31:46.144]                           info <- base::paste(info, collapse = "; ")
[10:31:46.144]                           if (!has_future) {
[10:31:46.144]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:46.144]                               info)
[10:31:46.144]                           }
[10:31:46.144]                           else {
[10:31:46.144]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:46.144]                               info, version)
[10:31:46.144]                           }
[10:31:46.144]                           base::stop(msg)
[10:31:46.144]                         }
[10:31:46.144]                       })
[10:31:46.144]                     }
[10:31:46.144]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:46.144]                     base::options(mc.cores = 1L)
[10:31:46.144]                   }
[10:31:46.144]                   ...future.strategy.old <- future::plan("list")
[10:31:46.144]                   options(future.plan = NULL)
[10:31:46.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:46.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:46.144]                 }
[10:31:46.144]                 ...future.workdir <- getwd()
[10:31:46.144]             }
[10:31:46.144]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:46.144]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:46.144]         }
[10:31:46.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:46.144]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:46.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:46.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:46.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:46.144]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:46.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:46.144]             base::names(...future.oldOptions))
[10:31:46.144]     }
[10:31:46.144]     if (FALSE) {
[10:31:46.144]     }
[10:31:46.144]     else {
[10:31:46.144]         if (FALSE) {
[10:31:46.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:46.144]                 open = "w")
[10:31:46.144]         }
[10:31:46.144]         else {
[10:31:46.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:46.144]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:46.144]         }
[10:31:46.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:46.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:46.144]             base::sink(type = "output", split = FALSE)
[10:31:46.144]             base::close(...future.stdout)
[10:31:46.144]         }, add = TRUE)
[10:31:46.144]     }
[10:31:46.144]     ...future.frame <- base::sys.nframe()
[10:31:46.144]     ...future.conditions <- base::list()
[10:31:46.144]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:46.144]     if (FALSE) {
[10:31:46.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:46.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:46.144]     }
[10:31:46.144]     ...future.result <- base::tryCatch({
[10:31:46.144]         base::withCallingHandlers({
[10:31:46.144]             ...future.value <- base::withVisible(base::local({
[10:31:46.144]                 withCallingHandlers({
[10:31:46.144]                   {
[10:31:46.144]                     do.call(function(...) {
[10:31:46.144]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.144]                       if (!identical(...future.globals.maxSize.org, 
[10:31:46.144]                         ...future.globals.maxSize)) {
[10:31:46.144]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.144]                         on.exit(options(oopts), add = TRUE)
[10:31:46.144]                       }
[10:31:46.144]                       {
[10:31:46.144]                         lapply(seq_along(...future.elements_ii), 
[10:31:46.144]                           FUN = function(jj) {
[10:31:46.144]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:46.144]                             ...future.FUN(...future.X_jj, ...)
[10:31:46.144]                           })
[10:31:46.144]                       }
[10:31:46.144]                     }, args = future.call.arguments)
[10:31:46.144]                   }
[10:31:46.144]                 }, immediateCondition = function(cond) {
[10:31:46.144]                   save_rds <- function (object, pathname, ...) 
[10:31:46.144]                   {
[10:31:46.144]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:46.144]                     if (file_test("-f", pathname_tmp)) {
[10:31:46.144]                       fi_tmp <- file.info(pathname_tmp)
[10:31:46.144]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:46.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:46.144]                         fi_tmp[["mtime"]])
[10:31:46.144]                     }
[10:31:46.144]                     tryCatch({
[10:31:46.144]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:46.144]                     }, error = function(ex) {
[10:31:46.144]                       msg <- conditionMessage(ex)
[10:31:46.144]                       fi_tmp <- file.info(pathname_tmp)
[10:31:46.144]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:46.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:46.144]                         fi_tmp[["mtime"]], msg)
[10:31:46.144]                       ex$message <- msg
[10:31:46.144]                       stop(ex)
[10:31:46.144]                     })
[10:31:46.144]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:46.144]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:46.144]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:46.144]                       fi_tmp <- file.info(pathname_tmp)
[10:31:46.144]                       fi <- file.info(pathname)
[10:31:46.144]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:46.144]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:46.144]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:46.144]                         fi[["size"]], fi[["mtime"]])
[10:31:46.144]                       stop(msg)
[10:31:46.144]                     }
[10:31:46.144]                     invisible(pathname)
[10:31:46.144]                   }
[10:31:46.144]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:46.144]                     rootPath = tempdir()) 
[10:31:46.144]                   {
[10:31:46.144]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:46.144]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:46.144]                       tmpdir = path, fileext = ".rds")
[10:31:46.144]                     save_rds(obj, file)
[10:31:46.144]                   }
[10:31:46.144]                   saveImmediateCondition(cond, path = "/tmp/Rtmptsj9Jv/.future/immediateConditions")
[10:31:46.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:46.144]                   {
[10:31:46.144]                     inherits <- base::inherits
[10:31:46.144]                     invokeRestart <- base::invokeRestart
[10:31:46.144]                     is.null <- base::is.null
[10:31:46.144]                     muffled <- FALSE
[10:31:46.144]                     if (inherits(cond, "message")) {
[10:31:46.144]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:46.144]                       if (muffled) 
[10:31:46.144]                         invokeRestart("muffleMessage")
[10:31:46.144]                     }
[10:31:46.144]                     else if (inherits(cond, "warning")) {
[10:31:46.144]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:46.144]                       if (muffled) 
[10:31:46.144]                         invokeRestart("muffleWarning")
[10:31:46.144]                     }
[10:31:46.144]                     else if (inherits(cond, "condition")) {
[10:31:46.144]                       if (!is.null(pattern)) {
[10:31:46.144]                         computeRestarts <- base::computeRestarts
[10:31:46.144]                         grepl <- base::grepl
[10:31:46.144]                         restarts <- computeRestarts(cond)
[10:31:46.144]                         for (restart in restarts) {
[10:31:46.144]                           name <- restart$name
[10:31:46.144]                           if (is.null(name)) 
[10:31:46.144]                             next
[10:31:46.144]                           if (!grepl(pattern, name)) 
[10:31:46.144]                             next
[10:31:46.144]                           invokeRestart(restart)
[10:31:46.144]                           muffled <- TRUE
[10:31:46.144]                           break
[10:31:46.144]                         }
[10:31:46.144]                       }
[10:31:46.144]                     }
[10:31:46.144]                     invisible(muffled)
[10:31:46.144]                   }
[10:31:46.144]                   muffleCondition(cond)
[10:31:46.144]                 })
[10:31:46.144]             }))
[10:31:46.144]             future::FutureResult(value = ...future.value$value, 
[10:31:46.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:46.144]                   ...future.rng), globalenv = if (FALSE) 
[10:31:46.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:46.144]                     ...future.globalenv.names))
[10:31:46.144]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:46.144]         }, condition = base::local({
[10:31:46.144]             c <- base::c
[10:31:46.144]             inherits <- base::inherits
[10:31:46.144]             invokeRestart <- base::invokeRestart
[10:31:46.144]             length <- base::length
[10:31:46.144]             list <- base::list
[10:31:46.144]             seq.int <- base::seq.int
[10:31:46.144]             signalCondition <- base::signalCondition
[10:31:46.144]             sys.calls <- base::sys.calls
[10:31:46.144]             `[[` <- base::`[[`
[10:31:46.144]             `+` <- base::`+`
[10:31:46.144]             `<<-` <- base::`<<-`
[10:31:46.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:46.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:46.144]                   3L)]
[10:31:46.144]             }
[10:31:46.144]             function(cond) {
[10:31:46.144]                 is_error <- inherits(cond, "error")
[10:31:46.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:46.144]                   NULL)
[10:31:46.144]                 if (is_error) {
[10:31:46.144]                   sessionInformation <- function() {
[10:31:46.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:46.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:46.144]                       search = base::search(), system = base::Sys.info())
[10:31:46.144]                   }
[10:31:46.144]                   ...future.conditions[[length(...future.conditions) + 
[10:31:46.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:46.144]                     cond$call), session = sessionInformation(), 
[10:31:46.144]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:46.144]                   signalCondition(cond)
[10:31:46.144]                 }
[10:31:46.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:46.144]                 "immediateCondition"))) {
[10:31:46.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:46.144]                   ...future.conditions[[length(...future.conditions) + 
[10:31:46.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:46.144]                   if (TRUE && !signal) {
[10:31:46.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:46.144]                     {
[10:31:46.144]                       inherits <- base::inherits
[10:31:46.144]                       invokeRestart <- base::invokeRestart
[10:31:46.144]                       is.null <- base::is.null
[10:31:46.144]                       muffled <- FALSE
[10:31:46.144]                       if (inherits(cond, "message")) {
[10:31:46.144]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:46.144]                         if (muffled) 
[10:31:46.144]                           invokeRestart("muffleMessage")
[10:31:46.144]                       }
[10:31:46.144]                       else if (inherits(cond, "warning")) {
[10:31:46.144]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:46.144]                         if (muffled) 
[10:31:46.144]                           invokeRestart("muffleWarning")
[10:31:46.144]                       }
[10:31:46.144]                       else if (inherits(cond, "condition")) {
[10:31:46.144]                         if (!is.null(pattern)) {
[10:31:46.144]                           computeRestarts <- base::computeRestarts
[10:31:46.144]                           grepl <- base::grepl
[10:31:46.144]                           restarts <- computeRestarts(cond)
[10:31:46.144]                           for (restart in restarts) {
[10:31:46.144]                             name <- restart$name
[10:31:46.144]                             if (is.null(name)) 
[10:31:46.144]                               next
[10:31:46.144]                             if (!grepl(pattern, name)) 
[10:31:46.144]                               next
[10:31:46.144]                             invokeRestart(restart)
[10:31:46.144]                             muffled <- TRUE
[10:31:46.144]                             break
[10:31:46.144]                           }
[10:31:46.144]                         }
[10:31:46.144]                       }
[10:31:46.144]                       invisible(muffled)
[10:31:46.144]                     }
[10:31:46.144]                     muffleCondition(cond, pattern = "^muffle")
[10:31:46.144]                   }
[10:31:46.144]                 }
[10:31:46.144]                 else {
[10:31:46.144]                   if (TRUE) {
[10:31:46.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:46.144]                     {
[10:31:46.144]                       inherits <- base::inherits
[10:31:46.144]                       invokeRestart <- base::invokeRestart
[10:31:46.144]                       is.null <- base::is.null
[10:31:46.144]                       muffled <- FALSE
[10:31:46.144]                       if (inherits(cond, "message")) {
[10:31:46.144]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:46.144]                         if (muffled) 
[10:31:46.144]                           invokeRestart("muffleMessage")
[10:31:46.144]                       }
[10:31:46.144]                       else if (inherits(cond, "warning")) {
[10:31:46.144]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:46.144]                         if (muffled) 
[10:31:46.144]                           invokeRestart("muffleWarning")
[10:31:46.144]                       }
[10:31:46.144]                       else if (inherits(cond, "condition")) {
[10:31:46.144]                         if (!is.null(pattern)) {
[10:31:46.144]                           computeRestarts <- base::computeRestarts
[10:31:46.144]                           grepl <- base::grepl
[10:31:46.144]                           restarts <- computeRestarts(cond)
[10:31:46.144]                           for (restart in restarts) {
[10:31:46.144]                             name <- restart$name
[10:31:46.144]                             if (is.null(name)) 
[10:31:46.144]                               next
[10:31:46.144]                             if (!grepl(pattern, name)) 
[10:31:46.144]                               next
[10:31:46.144]                             invokeRestart(restart)
[10:31:46.144]                             muffled <- TRUE
[10:31:46.144]                             break
[10:31:46.144]                           }
[10:31:46.144]                         }
[10:31:46.144]                       }
[10:31:46.144]                       invisible(muffled)
[10:31:46.144]                     }
[10:31:46.144]                     muffleCondition(cond, pattern = "^muffle")
[10:31:46.144]                   }
[10:31:46.144]                 }
[10:31:46.144]             }
[10:31:46.144]         }))
[10:31:46.144]     }, error = function(ex) {
[10:31:46.144]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:46.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:46.144]                 ...future.rng), started = ...future.startTime, 
[10:31:46.144]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:46.144]             version = "1.8"), class = "FutureResult")
[10:31:46.144]     }, finally = {
[10:31:46.144]         if (!identical(...future.workdir, getwd())) 
[10:31:46.144]             setwd(...future.workdir)
[10:31:46.144]         {
[10:31:46.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:46.144]                 ...future.oldOptions$nwarnings <- NULL
[10:31:46.144]             }
[10:31:46.144]             base::options(...future.oldOptions)
[10:31:46.144]             if (.Platform$OS.type == "windows") {
[10:31:46.144]                 old_names <- names(...future.oldEnvVars)
[10:31:46.144]                 envs <- base::Sys.getenv()
[10:31:46.144]                 names <- names(envs)
[10:31:46.144]                 common <- intersect(names, old_names)
[10:31:46.144]                 added <- setdiff(names, old_names)
[10:31:46.144]                 removed <- setdiff(old_names, names)
[10:31:46.144]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:46.144]                   envs[common]]
[10:31:46.144]                 NAMES <- toupper(changed)
[10:31:46.144]                 args <- list()
[10:31:46.144]                 for (kk in seq_along(NAMES)) {
[10:31:46.144]                   name <- changed[[kk]]
[10:31:46.144]                   NAME <- NAMES[[kk]]
[10:31:46.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:46.144]                     next
[10:31:46.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:46.144]                 }
[10:31:46.144]                 NAMES <- toupper(added)
[10:31:46.144]                 for (kk in seq_along(NAMES)) {
[10:31:46.144]                   name <- added[[kk]]
[10:31:46.144]                   NAME <- NAMES[[kk]]
[10:31:46.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:46.144]                     next
[10:31:46.144]                   args[[name]] <- ""
[10:31:46.144]                 }
[10:31:46.144]                 NAMES <- toupper(removed)
[10:31:46.144]                 for (kk in seq_along(NAMES)) {
[10:31:46.144]                   name <- removed[[kk]]
[10:31:46.144]                   NAME <- NAMES[[kk]]
[10:31:46.144]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:46.144]                     next
[10:31:46.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:46.144]                 }
[10:31:46.144]                 if (length(args) > 0) 
[10:31:46.144]                   base::do.call(base::Sys.setenv, args = args)
[10:31:46.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:46.144]             }
[10:31:46.144]             else {
[10:31:46.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:46.144]             }
[10:31:46.144]             {
[10:31:46.144]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:46.144]                   0L) {
[10:31:46.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:46.144]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:46.144]                   base::options(opts)
[10:31:46.144]                 }
[10:31:46.144]                 {
[10:31:46.144]                   {
[10:31:46.144]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:46.144]                     NULL
[10:31:46.144]                   }
[10:31:46.144]                   options(future.plan = NULL)
[10:31:46.144]                   if (is.na(NA_character_)) 
[10:31:46.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:46.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:46.144]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:46.144]                     .init = FALSE)
[10:31:46.144]                 }
[10:31:46.144]             }
[10:31:46.144]         }
[10:31:46.144]     })
[10:31:46.144]     if (TRUE) {
[10:31:46.144]         base::sink(type = "output", split = FALSE)
[10:31:46.144]         if (FALSE) {
[10:31:46.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:46.144]         }
[10:31:46.144]         else {
[10:31:46.144]             ...future.result["stdout"] <- base::list(NULL)
[10:31:46.144]         }
[10:31:46.144]         base::close(...future.stdout)
[10:31:46.144]         ...future.stdout <- NULL
[10:31:46.144]     }
[10:31:46.144]     ...future.result$conditions <- ...future.conditions
[10:31:46.144]     ...future.result$finished <- base::Sys.time()
[10:31:46.144]     ...future.result
[10:31:46.144] }
[10:31:46.147] assign_globals() ...
[10:31:46.147] List of 5
[10:31:46.147]  $ ...future.FUN            :function (x)  
[10:31:46.147]  $ future.call.arguments    : list()
[10:31:46.147]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:46.147]  $ ...future.elements_ii    :List of 1
[10:31:46.147]   ..$ : int 0
[10:31:46.147]  $ ...future.seeds_ii       : NULL
[10:31:46.147]  $ ...future.globals.maxSize: NULL
[10:31:46.147]  - attr(*, "where")=List of 5
[10:31:46.147]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:46.147]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:46.147]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:46.147]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:46.147]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:46.147]  - attr(*, "resolved")= logi FALSE
[10:31:46.147]  - attr(*, "total_size")= num 4720
[10:31:46.147]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:46.147]  - attr(*, "already-done")= logi TRUE
[10:31:46.155] - reassign environment for ‘...future.FUN’
[10:31:46.155] - copied ‘...future.FUN’ to environment
[10:31:46.155] - copied ‘future.call.arguments’ to environment
[10:31:46.155] - copied ‘...future.elements_ii’ to environment
[10:31:46.155] - copied ‘...future.seeds_ii’ to environment
[10:31:46.155] - copied ‘...future.globals.maxSize’ to environment
[10:31:46.155] assign_globals() ... done
[10:31:46.156] requestCore(): workers = 2
[10:31:46.165] MulticoreFuture started
[10:31:46.166] - Launch lazy future ... done
[10:31:46.167] plan(): Setting new future strategy stack:
[10:31:46.167] run() for ‘MulticoreFuture’ ... done
[10:31:46.167] Created future:
[10:31:46.167] List of future strategies:
[10:31:46.167] 1. sequential:
[10:31:46.167]    - args: function (..., envir = parent.frame())
[10:31:46.167]    - tweaked: FALSE
[10:31:46.167]    - call: NULL
[10:31:46.168] plan(): nbrOfWorkers() = 1
[10:31:46.171] plan(): Setting new future strategy stack:
[10:31:46.171] List of future strategies:
[10:31:46.171] 1. multicore:
[10:31:46.171]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:46.171]    - tweaked: FALSE
[10:31:46.171]    - call: plan(strategy)
[10:31:46.177] plan(): nbrOfWorkers() = 2
[10:31:46.168] MulticoreFuture:
[10:31:46.168] Label: ‘future_lapply-2’
[10:31:46.168] Expression:
[10:31:46.168] {
[10:31:46.168]     do.call(function(...) {
[10:31:46.168]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.168]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:46.168]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.168]             on.exit(options(oopts), add = TRUE)
[10:31:46.168]         }
[10:31:46.168]         {
[10:31:46.168]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:46.168]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:46.168]                 ...future.FUN(...future.X_jj, ...)
[10:31:46.168]             })
[10:31:46.168]         }
[10:31:46.168]     }, args = future.call.arguments)
[10:31:46.168] }
[10:31:46.168] Lazy evaluation: FALSE
[10:31:46.168] Asynchronous evaluation: TRUE
[10:31:46.168] Local evaluation: TRUE
[10:31:46.168] Environment: R_GlobalEnv
[10:31:46.168] Capture standard output: FALSE
[10:31:46.168] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:46.168] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:46.168] Packages: <none>
[10:31:46.168] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:46.168] Resolved: TRUE
[10:31:46.168] Value: <not collected>
[10:31:46.168] Conditions captured: <none>
[10:31:46.168] Early signaling: FALSE
[10:31:46.168] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:46.168] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:46.178] Chunk #2 of 2 ... DONE
[10:31:46.178] Launching 2 futures (chunks) ... DONE
[10:31:46.179] Resolving 2 futures (chunks) ...
[10:31:46.179] resolve() on list ...
[10:31:46.179]  recursive: 0
[10:31:46.179]  length: 2
[10:31:46.179] 
[10:31:46.190] Future #2
[10:31:46.191] result() for MulticoreFuture ...
[10:31:46.193] result() for MulticoreFuture ...
[10:31:46.194] result() for MulticoreFuture ... done
[10:31:46.194] result() for MulticoreFuture ... done
[10:31:46.194] result() for MulticoreFuture ...
[10:31:46.194] result() for MulticoreFuture ... done
[10:31:46.194] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:46.195] - nx: 2
[10:31:46.195] - relay: TRUE
[10:31:46.195] - stdout: TRUE
[10:31:46.195] - signal: TRUE
[10:31:46.195] - resignal: FALSE
[10:31:46.195] - force: TRUE
[10:31:46.195] - relayed: [n=2] FALSE, FALSE
[10:31:46.195] - queued futures: [n=2] FALSE, FALSE
[10:31:46.196]  - until=1
[10:31:46.196]  - relaying element #1
[10:31:46.196] - relayed: [n=2] FALSE, FALSE
[10:31:46.196] - queued futures: [n=2] FALSE, TRUE
[10:31:46.196] signalConditionsASAP(NULL, pos=2) ... done
[10:31:46.196]  length: 1 (resolved future 2)
[10:31:46.616] plan(): Setting new future strategy stack:
[10:31:46.617] List of future strategies:
[10:31:46.617] 1. multicore:
[10:31:46.617]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:46.617]    - tweaked: FALSE
[10:31:46.617]    - call: plan(strategy)
[10:31:46.621] plan(): nbrOfWorkers() = 2
[10:31:46.622] Future #1
[10:31:46.622] result() for MulticoreFuture ...
[10:31:46.623] result() for MulticoreFuture ...
[10:31:46.623] result() for MulticoreFuture ... done
[10:31:46.623] result() for MulticoreFuture ... done
[10:31:46.623] result() for MulticoreFuture ...
[10:31:46.623] result() for MulticoreFuture ... done
[10:31:46.623] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:46.623] - nx: 2
[10:31:46.623] - relay: TRUE
[10:31:46.624] - stdout: TRUE
[10:31:46.624] - signal: TRUE
[10:31:46.624] - resignal: FALSE
[10:31:46.624] - force: TRUE
[10:31:46.624] - relayed: [n=2] FALSE, FALSE
[10:31:46.624] - queued futures: [n=2] FALSE, TRUE
[10:31:46.624]  - until=1
[10:31:46.624]  - relaying element #1
[10:31:46.624] result() for MulticoreFuture ...
[10:31:46.625] result() for MulticoreFuture ... done
[10:31:46.625] result() for MulticoreFuture ...
[10:31:46.625] result() for MulticoreFuture ... done
[10:31:46.625] result() for MulticoreFuture ...
[10:31:46.625] result() for MulticoreFuture ... done
[10:31:46.625] result() for MulticoreFuture ...
[10:31:46.625] result() for MulticoreFuture ... done
[10:31:46.625] - relayed: [n=2] TRUE, FALSE
[10:31:46.625] - queued futures: [n=2] TRUE, TRUE
[10:31:46.626] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:46.626]  length: 0 (resolved future 1)
[10:31:46.626] Relaying remaining futures
[10:31:46.626] signalConditionsASAP(NULL, pos=0) ...
[10:31:46.626] - nx: 2
[10:31:46.626] - relay: TRUE
[10:31:46.626] - stdout: TRUE
[10:31:46.626] - signal: TRUE
[10:31:46.626] - resignal: FALSE
[10:31:46.627] - force: TRUE
[10:31:46.627] - relayed: [n=2] TRUE, FALSE
[10:31:46.627] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:46.627]  - relaying element #2
[10:31:46.627] result() for MulticoreFuture ...
[10:31:46.627] result() for MulticoreFuture ... done
[10:31:46.627] result() for MulticoreFuture ...
[10:31:46.627] result() for MulticoreFuture ... done
[10:31:46.628] result() for MulticoreFuture ...
[10:31:46.628] result() for MulticoreFuture ... done
[10:31:46.628] result() for MulticoreFuture ...
[10:31:46.628] result() for MulticoreFuture ... done
[10:31:46.628] - relayed: [n=2] TRUE, TRUE
[10:31:46.628] - queued futures: [n=2] TRUE, TRUE
[10:31:46.628] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:31:46.628] resolve() on list ... DONE
[10:31:46.628] result() for MulticoreFuture ...
[10:31:46.629] result() for MulticoreFuture ... done
[10:31:46.629] result() for MulticoreFuture ...
[10:31:46.629] result() for MulticoreFuture ... done
[10:31:46.629] result() for MulticoreFuture ...
[10:31:46.629] result() for MulticoreFuture ... done
[10:31:46.629] result() for MulticoreFuture ...
[10:31:46.629] result() for MulticoreFuture ... done
[10:31:46.629]  - Number of value chunks collected: 2
[10:31:46.629] Resolving 2 futures (chunks) ... DONE
[10:31:46.630] Reducing values from 2 chunks ...
[10:31:46.630]  - Number of values collected after concatenation: 2
[10:31:46.630]  - Number of values expected: 2
[10:31:46.630] Reducing values from 2 chunks ... DONE
[10:31:46.630] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:31:46.631] future_lapply() ...
[10:31:46.635] Number of chunks: 2
[10:31:46.636] getGlobalsAndPackagesXApply() ...
[10:31:46.636]  - future.globals: TRUE
[10:31:46.636] getGlobalsAndPackages() ...
[10:31:46.636] Searching for globals...
[10:31:46.638] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:46.638] Searching for globals ... DONE
[10:31:46.638] Resolving globals: FALSE
[10:31:46.638] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:46.639] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:46.639] - globals: [1] ‘FUN’
[10:31:46.639] 
[10:31:46.639] getGlobalsAndPackages() ... DONE
[10:31:46.639]  - globals found/used: [n=1] ‘FUN’
[10:31:46.639]  - needed namespaces: [n=0] 
[10:31:46.640] Finding globals ... DONE
[10:31:46.640]  - use_args: TRUE
[10:31:46.640]  - Getting '...' globals ...
[10:31:46.640] resolve() on list ...
[10:31:46.640]  recursive: 0
[10:31:46.640]  length: 1
[10:31:46.640]  elements: ‘...’
[10:31:46.641]  length: 0 (resolved future 1)
[10:31:46.641] resolve() on list ... DONE
[10:31:46.641]    - '...' content: [n=0] 
[10:31:46.641] List of 1
[10:31:46.641]  $ ...: list()
[10:31:46.641]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:46.641]  - attr(*, "where")=List of 1
[10:31:46.641]   ..$ ...:<environment: 0x564ff3d0edc8> 
[10:31:46.641]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:46.641]  - attr(*, "resolved")= logi TRUE
[10:31:46.641]  - attr(*, "total_size")= num NA
[10:31:46.646]  - Getting '...' globals ... DONE
[10:31:46.646] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:46.646] List of 2
[10:31:46.646]  $ ...future.FUN:function (x)  
[10:31:46.646]  $ ...          : list()
[10:31:46.646]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:46.646]  - attr(*, "where")=List of 2
[10:31:46.646]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:46.646]   ..$ ...          :<environment: 0x564ff3d0edc8> 
[10:31:46.646]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:46.646]  - attr(*, "resolved")= logi FALSE
[10:31:46.646]  - attr(*, "total_size")= num 4720
[10:31:46.649] Packages to be attached in all futures: [n=0] 
[10:31:46.649] getGlobalsAndPackagesXApply() ... DONE
[10:31:46.650] Number of futures (= number of chunks): 2
[10:31:46.650] Launching 2 futures (chunks) ...
[10:31:46.650] Chunk #1 of 2 ...
[10:31:46.650]  - Finding globals in 'X' for chunk #1 ...
[10:31:46.650] getGlobalsAndPackages() ...
[10:31:46.650] Searching for globals...
[10:31:46.650] 
[10:31:46.650] Searching for globals ... DONE
[10:31:46.651] - globals: [0] <none>
[10:31:46.651] getGlobalsAndPackages() ... DONE
[10:31:46.651]    + additional globals found: [n=0] 
[10:31:46.651]    + additional namespaces needed: [n=0] 
[10:31:46.651]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:46.651]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:46.651]  - seeds: <none>
[10:31:46.651]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:46.651] getGlobalsAndPackages() ...
[10:31:46.651] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:46.652] Resolving globals: FALSE
[10:31:46.652] Tweak future expression to call with '...' arguments ...
[10:31:46.652] {
[10:31:46.652]     do.call(function(...) {
[10:31:46.652]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.652]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:46.652]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.652]             on.exit(options(oopts), add = TRUE)
[10:31:46.652]         }
[10:31:46.652]         {
[10:31:46.652]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:46.652]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:46.652]                 ...future.FUN(...future.X_jj, ...)
[10:31:46.652]             })
[10:31:46.652]         }
[10:31:46.652]     }, args = future.call.arguments)
[10:31:46.652] }
[10:31:46.652] Tweak future expression to call with '...' arguments ... DONE
[10:31:46.652] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:46.653] 
[10:31:46.653] getGlobalsAndPackages() ... DONE
[10:31:46.653] run() for ‘Future’ ...
[10:31:46.653] - state: ‘created’
[10:31:46.653] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:46.657] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:46.657] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:46.657]   - Field: ‘label’
[10:31:46.657]   - Field: ‘local’
[10:31:46.658]   - Field: ‘owner’
[10:31:46.658]   - Field: ‘envir’
[10:31:46.658]   - Field: ‘workers’
[10:31:46.658]   - Field: ‘packages’
[10:31:46.658]   - Field: ‘gc’
[10:31:46.658]   - Field: ‘job’
[10:31:46.658]   - Field: ‘conditions’
[10:31:46.658]   - Field: ‘expr’
[10:31:46.658]   - Field: ‘uuid’
[10:31:46.658]   - Field: ‘seed’
[10:31:46.658]   - Field: ‘version’
[10:31:46.659]   - Field: ‘result’
[10:31:46.659]   - Field: ‘asynchronous’
[10:31:46.659]   - Field: ‘calls’
[10:31:46.659]   - Field: ‘globals’
[10:31:46.659]   - Field: ‘stdout’
[10:31:46.659]   - Field: ‘earlySignal’
[10:31:46.659]   - Field: ‘lazy’
[10:31:46.659]   - Field: ‘state’
[10:31:46.659] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:46.659] - Launch lazy future ...
[10:31:46.660] Packages needed by the future expression (n = 0): <none>
[10:31:46.660] Packages needed by future strategies (n = 0): <none>
[10:31:46.660] {
[10:31:46.660]     {
[10:31:46.660]         {
[10:31:46.660]             ...future.startTime <- base::Sys.time()
[10:31:46.660]             {
[10:31:46.660]                 {
[10:31:46.660]                   {
[10:31:46.660]                     {
[10:31:46.660]                       base::local({
[10:31:46.660]                         has_future <- base::requireNamespace("future", 
[10:31:46.660]                           quietly = TRUE)
[10:31:46.660]                         if (has_future) {
[10:31:46.660]                           ns <- base::getNamespace("future")
[10:31:46.660]                           version <- ns[[".package"]][["version"]]
[10:31:46.660]                           if (is.null(version)) 
[10:31:46.660]                             version <- utils::packageVersion("future")
[10:31:46.660]                         }
[10:31:46.660]                         else {
[10:31:46.660]                           version <- NULL
[10:31:46.660]                         }
[10:31:46.660]                         if (!has_future || version < "1.8.0") {
[10:31:46.660]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:46.660]                             "", base::R.version$version.string), 
[10:31:46.660]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:46.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:46.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:46.660]                               "release", "version")], collapse = " "), 
[10:31:46.660]                             hostname = base::Sys.info()[["nodename"]])
[10:31:46.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:46.660]                             info)
[10:31:46.660]                           info <- base::paste(info, collapse = "; ")
[10:31:46.660]                           if (!has_future) {
[10:31:46.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:46.660]                               info)
[10:31:46.660]                           }
[10:31:46.660]                           else {
[10:31:46.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:46.660]                               info, version)
[10:31:46.660]                           }
[10:31:46.660]                           base::stop(msg)
[10:31:46.660]                         }
[10:31:46.660]                       })
[10:31:46.660]                     }
[10:31:46.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:46.660]                     base::options(mc.cores = 1L)
[10:31:46.660]                   }
[10:31:46.660]                   ...future.strategy.old <- future::plan("list")
[10:31:46.660]                   options(future.plan = NULL)
[10:31:46.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:46.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:46.660]                 }
[10:31:46.660]                 ...future.workdir <- getwd()
[10:31:46.660]             }
[10:31:46.660]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:46.660]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:46.660]         }
[10:31:46.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:46.660]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:46.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:46.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:46.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:46.660]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:46.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:46.660]             base::names(...future.oldOptions))
[10:31:46.660]     }
[10:31:46.660]     if (FALSE) {
[10:31:46.660]     }
[10:31:46.660]     else {
[10:31:46.660]         if (TRUE) {
[10:31:46.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:46.660]                 open = "w")
[10:31:46.660]         }
[10:31:46.660]         else {
[10:31:46.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:46.660]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:46.660]         }
[10:31:46.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:46.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:46.660]             base::sink(type = "output", split = FALSE)
[10:31:46.660]             base::close(...future.stdout)
[10:31:46.660]         }, add = TRUE)
[10:31:46.660]     }
[10:31:46.660]     ...future.frame <- base::sys.nframe()
[10:31:46.660]     ...future.conditions <- base::list()
[10:31:46.660]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:46.660]     if (FALSE) {
[10:31:46.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:46.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:46.660]     }
[10:31:46.660]     ...future.result <- base::tryCatch({
[10:31:46.660]         base::withCallingHandlers({
[10:31:46.660]             ...future.value <- base::withVisible(base::local({
[10:31:46.660]                 withCallingHandlers({
[10:31:46.660]                   {
[10:31:46.660]                     do.call(function(...) {
[10:31:46.660]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.660]                       if (!identical(...future.globals.maxSize.org, 
[10:31:46.660]                         ...future.globals.maxSize)) {
[10:31:46.660]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.660]                         on.exit(options(oopts), add = TRUE)
[10:31:46.660]                       }
[10:31:46.660]                       {
[10:31:46.660]                         lapply(seq_along(...future.elements_ii), 
[10:31:46.660]                           FUN = function(jj) {
[10:31:46.660]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:46.660]                             ...future.FUN(...future.X_jj, ...)
[10:31:46.660]                           })
[10:31:46.660]                       }
[10:31:46.660]                     }, args = future.call.arguments)
[10:31:46.660]                   }
[10:31:46.660]                 }, immediateCondition = function(cond) {
[10:31:46.660]                   save_rds <- function (object, pathname, ...) 
[10:31:46.660]                   {
[10:31:46.660]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:46.660]                     if (file_test("-f", pathname_tmp)) {
[10:31:46.660]                       fi_tmp <- file.info(pathname_tmp)
[10:31:46.660]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:46.660]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:46.660]                         fi_tmp[["mtime"]])
[10:31:46.660]                     }
[10:31:46.660]                     tryCatch({
[10:31:46.660]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:46.660]                     }, error = function(ex) {
[10:31:46.660]                       msg <- conditionMessage(ex)
[10:31:46.660]                       fi_tmp <- file.info(pathname_tmp)
[10:31:46.660]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:46.660]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:46.660]                         fi_tmp[["mtime"]], msg)
[10:31:46.660]                       ex$message <- msg
[10:31:46.660]                       stop(ex)
[10:31:46.660]                     })
[10:31:46.660]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:46.660]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:46.660]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:46.660]                       fi_tmp <- file.info(pathname_tmp)
[10:31:46.660]                       fi <- file.info(pathname)
[10:31:46.660]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:46.660]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:46.660]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:46.660]                         fi[["size"]], fi[["mtime"]])
[10:31:46.660]                       stop(msg)
[10:31:46.660]                     }
[10:31:46.660]                     invisible(pathname)
[10:31:46.660]                   }
[10:31:46.660]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:46.660]                     rootPath = tempdir()) 
[10:31:46.660]                   {
[10:31:46.660]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:46.660]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:46.660]                       tmpdir = path, fileext = ".rds")
[10:31:46.660]                     save_rds(obj, file)
[10:31:46.660]                   }
[10:31:46.660]                   saveImmediateCondition(cond, path = "/tmp/Rtmptsj9Jv/.future/immediateConditions")
[10:31:46.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:46.660]                   {
[10:31:46.660]                     inherits <- base::inherits
[10:31:46.660]                     invokeRestart <- base::invokeRestart
[10:31:46.660]                     is.null <- base::is.null
[10:31:46.660]                     muffled <- FALSE
[10:31:46.660]                     if (inherits(cond, "message")) {
[10:31:46.660]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:46.660]                       if (muffled) 
[10:31:46.660]                         invokeRestart("muffleMessage")
[10:31:46.660]                     }
[10:31:46.660]                     else if (inherits(cond, "warning")) {
[10:31:46.660]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:46.660]                       if (muffled) 
[10:31:46.660]                         invokeRestart("muffleWarning")
[10:31:46.660]                     }
[10:31:46.660]                     else if (inherits(cond, "condition")) {
[10:31:46.660]                       if (!is.null(pattern)) {
[10:31:46.660]                         computeRestarts <- base::computeRestarts
[10:31:46.660]                         grepl <- base::grepl
[10:31:46.660]                         restarts <- computeRestarts(cond)
[10:31:46.660]                         for (restart in restarts) {
[10:31:46.660]                           name <- restart$name
[10:31:46.660]                           if (is.null(name)) 
[10:31:46.660]                             next
[10:31:46.660]                           if (!grepl(pattern, name)) 
[10:31:46.660]                             next
[10:31:46.660]                           invokeRestart(restart)
[10:31:46.660]                           muffled <- TRUE
[10:31:46.660]                           break
[10:31:46.660]                         }
[10:31:46.660]                       }
[10:31:46.660]                     }
[10:31:46.660]                     invisible(muffled)
[10:31:46.660]                   }
[10:31:46.660]                   muffleCondition(cond)
[10:31:46.660]                 })
[10:31:46.660]             }))
[10:31:46.660]             future::FutureResult(value = ...future.value$value, 
[10:31:46.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:46.660]                   ...future.rng), globalenv = if (FALSE) 
[10:31:46.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:46.660]                     ...future.globalenv.names))
[10:31:46.660]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:46.660]         }, condition = base::local({
[10:31:46.660]             c <- base::c
[10:31:46.660]             inherits <- base::inherits
[10:31:46.660]             invokeRestart <- base::invokeRestart
[10:31:46.660]             length <- base::length
[10:31:46.660]             list <- base::list
[10:31:46.660]             seq.int <- base::seq.int
[10:31:46.660]             signalCondition <- base::signalCondition
[10:31:46.660]             sys.calls <- base::sys.calls
[10:31:46.660]             `[[` <- base::`[[`
[10:31:46.660]             `+` <- base::`+`
[10:31:46.660]             `<<-` <- base::`<<-`
[10:31:46.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:46.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:46.660]                   3L)]
[10:31:46.660]             }
[10:31:46.660]             function(cond) {
[10:31:46.660]                 is_error <- inherits(cond, "error")
[10:31:46.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:46.660]                   NULL)
[10:31:46.660]                 if (is_error) {
[10:31:46.660]                   sessionInformation <- function() {
[10:31:46.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:46.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:46.660]                       search = base::search(), system = base::Sys.info())
[10:31:46.660]                   }
[10:31:46.660]                   ...future.conditions[[length(...future.conditions) + 
[10:31:46.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:46.660]                     cond$call), session = sessionInformation(), 
[10:31:46.660]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:46.660]                   signalCondition(cond)
[10:31:46.660]                 }
[10:31:46.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:46.660]                 "immediateCondition"))) {
[10:31:46.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:46.660]                   ...future.conditions[[length(...future.conditions) + 
[10:31:46.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:46.660]                   if (TRUE && !signal) {
[10:31:46.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:46.660]                     {
[10:31:46.660]                       inherits <- base::inherits
[10:31:46.660]                       invokeRestart <- base::invokeRestart
[10:31:46.660]                       is.null <- base::is.null
[10:31:46.660]                       muffled <- FALSE
[10:31:46.660]                       if (inherits(cond, "message")) {
[10:31:46.660]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:46.660]                         if (muffled) 
[10:31:46.660]                           invokeRestart("muffleMessage")
[10:31:46.660]                       }
[10:31:46.660]                       else if (inherits(cond, "warning")) {
[10:31:46.660]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:46.660]                         if (muffled) 
[10:31:46.660]                           invokeRestart("muffleWarning")
[10:31:46.660]                       }
[10:31:46.660]                       else if (inherits(cond, "condition")) {
[10:31:46.660]                         if (!is.null(pattern)) {
[10:31:46.660]                           computeRestarts <- base::computeRestarts
[10:31:46.660]                           grepl <- base::grepl
[10:31:46.660]                           restarts <- computeRestarts(cond)
[10:31:46.660]                           for (restart in restarts) {
[10:31:46.660]                             name <- restart$name
[10:31:46.660]                             if (is.null(name)) 
[10:31:46.660]                               next
[10:31:46.660]                             if (!grepl(pattern, name)) 
[10:31:46.660]                               next
[10:31:46.660]                             invokeRestart(restart)
[10:31:46.660]                             muffled <- TRUE
[10:31:46.660]                             break
[10:31:46.660]                           }
[10:31:46.660]                         }
[10:31:46.660]                       }
[10:31:46.660]                       invisible(muffled)
[10:31:46.660]                     }
[10:31:46.660]                     muffleCondition(cond, pattern = "^muffle")
[10:31:46.660]                   }
[10:31:46.660]                 }
[10:31:46.660]                 else {
[10:31:46.660]                   if (TRUE) {
[10:31:46.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:46.660]                     {
[10:31:46.660]                       inherits <- base::inherits
[10:31:46.660]                       invokeRestart <- base::invokeRestart
[10:31:46.660]                       is.null <- base::is.null
[10:31:46.660]                       muffled <- FALSE
[10:31:46.660]                       if (inherits(cond, "message")) {
[10:31:46.660]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:46.660]                         if (muffled) 
[10:31:46.660]                           invokeRestart("muffleMessage")
[10:31:46.660]                       }
[10:31:46.660]                       else if (inherits(cond, "warning")) {
[10:31:46.660]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:46.660]                         if (muffled) 
[10:31:46.660]                           invokeRestart("muffleWarning")
[10:31:46.660]                       }
[10:31:46.660]                       else if (inherits(cond, "condition")) {
[10:31:46.660]                         if (!is.null(pattern)) {
[10:31:46.660]                           computeRestarts <- base::computeRestarts
[10:31:46.660]                           grepl <- base::grepl
[10:31:46.660]                           restarts <- computeRestarts(cond)
[10:31:46.660]                           for (restart in restarts) {
[10:31:46.660]                             name <- restart$name
[10:31:46.660]                             if (is.null(name)) 
[10:31:46.660]                               next
[10:31:46.660]                             if (!grepl(pattern, name)) 
[10:31:46.660]                               next
[10:31:46.660]                             invokeRestart(restart)
[10:31:46.660]                             muffled <- TRUE
[10:31:46.660]                             break
[10:31:46.660]                           }
[10:31:46.660]                         }
[10:31:46.660]                       }
[10:31:46.660]                       invisible(muffled)
[10:31:46.660]                     }
[10:31:46.660]                     muffleCondition(cond, pattern = "^muffle")
[10:31:46.660]                   }
[10:31:46.660]                 }
[10:31:46.660]             }
[10:31:46.660]         }))
[10:31:46.660]     }, error = function(ex) {
[10:31:46.660]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:46.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:46.660]                 ...future.rng), started = ...future.startTime, 
[10:31:46.660]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:46.660]             version = "1.8"), class = "FutureResult")
[10:31:46.660]     }, finally = {
[10:31:46.660]         if (!identical(...future.workdir, getwd())) 
[10:31:46.660]             setwd(...future.workdir)
[10:31:46.660]         {
[10:31:46.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:46.660]                 ...future.oldOptions$nwarnings <- NULL
[10:31:46.660]             }
[10:31:46.660]             base::options(...future.oldOptions)
[10:31:46.660]             if (.Platform$OS.type == "windows") {
[10:31:46.660]                 old_names <- names(...future.oldEnvVars)
[10:31:46.660]                 envs <- base::Sys.getenv()
[10:31:46.660]                 names <- names(envs)
[10:31:46.660]                 common <- intersect(names, old_names)
[10:31:46.660]                 added <- setdiff(names, old_names)
[10:31:46.660]                 removed <- setdiff(old_names, names)
[10:31:46.660]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:46.660]                   envs[common]]
[10:31:46.660]                 NAMES <- toupper(changed)
[10:31:46.660]                 args <- list()
[10:31:46.660]                 for (kk in seq_along(NAMES)) {
[10:31:46.660]                   name <- changed[[kk]]
[10:31:46.660]                   NAME <- NAMES[[kk]]
[10:31:46.660]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:46.660]                     next
[10:31:46.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:46.660]                 }
[10:31:46.660]                 NAMES <- toupper(added)
[10:31:46.660]                 for (kk in seq_along(NAMES)) {
[10:31:46.660]                   name <- added[[kk]]
[10:31:46.660]                   NAME <- NAMES[[kk]]
[10:31:46.660]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:46.660]                     next
[10:31:46.660]                   args[[name]] <- ""
[10:31:46.660]                 }
[10:31:46.660]                 NAMES <- toupper(removed)
[10:31:46.660]                 for (kk in seq_along(NAMES)) {
[10:31:46.660]                   name <- removed[[kk]]
[10:31:46.660]                   NAME <- NAMES[[kk]]
[10:31:46.660]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:46.660]                     next
[10:31:46.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:46.660]                 }
[10:31:46.660]                 if (length(args) > 0) 
[10:31:46.660]                   base::do.call(base::Sys.setenv, args = args)
[10:31:46.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:46.660]             }
[10:31:46.660]             else {
[10:31:46.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:46.660]             }
[10:31:46.660]             {
[10:31:46.660]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:46.660]                   0L) {
[10:31:46.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:46.660]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:46.660]                   base::options(opts)
[10:31:46.660]                 }
[10:31:46.660]                 {
[10:31:46.660]                   {
[10:31:46.660]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:46.660]                     NULL
[10:31:46.660]                   }
[10:31:46.660]                   options(future.plan = NULL)
[10:31:46.660]                   if (is.na(NA_character_)) 
[10:31:46.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:46.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:46.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:46.660]                     .init = FALSE)
[10:31:46.660]                 }
[10:31:46.660]             }
[10:31:46.660]         }
[10:31:46.660]     })
[10:31:46.660]     if (TRUE) {
[10:31:46.660]         base::sink(type = "output", split = FALSE)
[10:31:46.660]         if (TRUE) {
[10:31:46.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:46.660]         }
[10:31:46.660]         else {
[10:31:46.660]             ...future.result["stdout"] <- base::list(NULL)
[10:31:46.660]         }
[10:31:46.660]         base::close(...future.stdout)
[10:31:46.660]         ...future.stdout <- NULL
[10:31:46.660]     }
[10:31:46.660]     ...future.result$conditions <- ...future.conditions
[10:31:46.660]     ...future.result$finished <- base::Sys.time()
[10:31:46.660]     ...future.result
[10:31:46.660] }
[10:31:46.663] assign_globals() ...
[10:31:46.663] List of 5
[10:31:46.663]  $ ...future.FUN            :function (x)  
[10:31:46.663]  $ future.call.arguments    : list()
[10:31:46.663]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:46.663]  $ ...future.elements_ii    :List of 1
[10:31:46.663]   ..$ : int 1
[10:31:46.663]  $ ...future.seeds_ii       : NULL
[10:31:46.663]  $ ...future.globals.maxSize: NULL
[10:31:46.663]  - attr(*, "where")=List of 5
[10:31:46.663]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:46.663]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:46.663]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:46.663]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:46.663]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:46.663]  - attr(*, "resolved")= logi FALSE
[10:31:46.663]  - attr(*, "total_size")= num 4720
[10:31:46.663]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:46.663]  - attr(*, "already-done")= logi TRUE
[10:31:46.668] - reassign environment for ‘...future.FUN’
[10:31:46.668] - copied ‘...future.FUN’ to environment
[10:31:46.668] - copied ‘future.call.arguments’ to environment
[10:31:46.668] - copied ‘...future.elements_ii’ to environment
[10:31:46.668] - copied ‘...future.seeds_ii’ to environment
[10:31:46.668] - copied ‘...future.globals.maxSize’ to environment
[10:31:46.668] assign_globals() ... done
[10:31:46.669] requestCore(): workers = 2
[10:31:46.671] MulticoreFuture started
[10:31:46.671] - Launch lazy future ... done
[10:31:46.671] run() for ‘MulticoreFuture’ ... done
[10:31:46.672] Created future:
[10:31:46.672] plan(): Setting new future strategy stack:
[10:31:46.672] List of future strategies:
[10:31:46.672] 1. sequential:
[10:31:46.672]    - args: function (..., envir = parent.frame())
[10:31:46.672]    - tweaked: FALSE
[10:31:46.672]    - call: NULL
[10:31:46.673] plan(): nbrOfWorkers() = 1
[10:31:46.672] MulticoreFuture:
[10:31:46.672] Label: ‘future_lapply-1’
[10:31:46.672] Expression:
[10:31:46.672] {
[10:31:46.672]     do.call(function(...) {
[10:31:46.672]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.672]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:46.672]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.672]             on.exit(options(oopts), add = TRUE)
[10:31:46.672]         }
[10:31:46.672]         {
[10:31:46.672]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:46.672]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:46.672]                 ...future.FUN(...future.X_jj, ...)
[10:31:46.672]             })
[10:31:46.672]         }
[10:31:46.672]     }, args = future.call.arguments)
[10:31:46.672] }
[10:31:46.672] Lazy evaluation: FALSE
[10:31:46.672] Asynchronous evaluation: TRUE
[10:31:46.672] Local evaluation: TRUE
[10:31:46.672] Environment: R_GlobalEnv
[10:31:46.672] Capture standard output: TRUE
[10:31:46.672] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:46.672] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:46.672] Packages: <none>
[10:31:46.672] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:46.672] Resolved: FALSE
[10:31:46.672] Value: <not collected>
[10:31:46.672] Conditions captured: <none>
[10:31:46.672] Early signaling: FALSE
[10:31:46.672] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:46.672] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:46.689] Chunk #1 of 2 ... DONE
[10:31:46.690] Chunk #2 of 2 ...
[10:31:46.690]  - Finding globals in 'X' for chunk #2 ...
[10:31:46.691] getGlobalsAndPackages() ...
[10:31:46.691] Searching for globals...
[10:31:46.692] 
[10:31:46.693] Searching for globals ... DONE
[10:31:46.693] - globals: [0] <none>
[10:31:46.693] getGlobalsAndPackages() ... DONE
[10:31:46.693]    + additional globals found: [n=0] 
[10:31:46.694]    + additional namespaces needed: [n=0] 
[10:31:46.694]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:46.694]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:46.694]  - seeds: <none>
[10:31:46.694]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:46.695] getGlobalsAndPackages() ...
[10:31:46.695] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:46.695] Resolving globals: FALSE
[10:31:46.695] Tweak future expression to call with '...' arguments ...
[10:31:46.695] {
[10:31:46.695]     do.call(function(...) {
[10:31:46.695]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.695]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:46.695]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.695]             on.exit(options(oopts), add = TRUE)
[10:31:46.695]         }
[10:31:46.695]         {
[10:31:46.695]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:46.695]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:46.695]                 ...future.FUN(...future.X_jj, ...)
[10:31:46.695]             })
[10:31:46.695]         }
[10:31:46.695]     }, args = future.call.arguments)
[10:31:46.695] }
[10:31:46.696] Tweak future expression to call with '...' arguments ... DONE
[10:31:46.697] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:46.697] 
[10:31:46.697] getGlobalsAndPackages() ... DONE
[10:31:46.698] run() for ‘Future’ ...
[10:31:46.698] - state: ‘created’
[10:31:46.698] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:46.703] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:46.703] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:46.703]   - Field: ‘label’
[10:31:46.704]   - Field: ‘local’
[10:31:46.704]   - Field: ‘owner’
[10:31:46.704]   - Field: ‘envir’
[10:31:46.704]   - Field: ‘workers’
[10:31:46.704]   - Field: ‘packages’
[10:31:46.704]   - Field: ‘gc’
[10:31:46.705]   - Field: ‘job’
[10:31:46.705]   - Field: ‘conditions’
[10:31:46.705]   - Field: ‘expr’
[10:31:46.705]   - Field: ‘uuid’
[10:31:46.705]   - Field: ‘seed’
[10:31:46.705]   - Field: ‘version’
[10:31:46.705]   - Field: ‘result’
[10:31:46.706]   - Field: ‘asynchronous’
[10:31:46.706]   - Field: ‘calls’
[10:31:46.706]   - Field: ‘globals’
[10:31:46.706]   - Field: ‘stdout’
[10:31:46.706]   - Field: ‘earlySignal’
[10:31:46.706]   - Field: ‘lazy’
[10:31:46.706]   - Field: ‘state’
[10:31:46.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:46.707] - Launch lazy future ...
[10:31:46.707] Packages needed by the future expression (n = 0): <none>
[10:31:46.707] Packages needed by future strategies (n = 0): <none>
[10:31:46.708] {
[10:31:46.708]     {
[10:31:46.708]         {
[10:31:46.708]             ...future.startTime <- base::Sys.time()
[10:31:46.708]             {
[10:31:46.708]                 {
[10:31:46.708]                   {
[10:31:46.708]                     {
[10:31:46.708]                       base::local({
[10:31:46.708]                         has_future <- base::requireNamespace("future", 
[10:31:46.708]                           quietly = TRUE)
[10:31:46.708]                         if (has_future) {
[10:31:46.708]                           ns <- base::getNamespace("future")
[10:31:46.708]                           version <- ns[[".package"]][["version"]]
[10:31:46.708]                           if (is.null(version)) 
[10:31:46.708]                             version <- utils::packageVersion("future")
[10:31:46.708]                         }
[10:31:46.708]                         else {
[10:31:46.708]                           version <- NULL
[10:31:46.708]                         }
[10:31:46.708]                         if (!has_future || version < "1.8.0") {
[10:31:46.708]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:46.708]                             "", base::R.version$version.string), 
[10:31:46.708]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:46.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:46.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:46.708]                               "release", "version")], collapse = " "), 
[10:31:46.708]                             hostname = base::Sys.info()[["nodename"]])
[10:31:46.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:46.708]                             info)
[10:31:46.708]                           info <- base::paste(info, collapse = "; ")
[10:31:46.708]                           if (!has_future) {
[10:31:46.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:46.708]                               info)
[10:31:46.708]                           }
[10:31:46.708]                           else {
[10:31:46.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:46.708]                               info, version)
[10:31:46.708]                           }
[10:31:46.708]                           base::stop(msg)
[10:31:46.708]                         }
[10:31:46.708]                       })
[10:31:46.708]                     }
[10:31:46.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:46.708]                     base::options(mc.cores = 1L)
[10:31:46.708]                   }
[10:31:46.708]                   ...future.strategy.old <- future::plan("list")
[10:31:46.708]                   options(future.plan = NULL)
[10:31:46.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:46.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:46.708]                 }
[10:31:46.708]                 ...future.workdir <- getwd()
[10:31:46.708]             }
[10:31:46.708]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:46.708]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:46.708]         }
[10:31:46.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:46.708]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:46.708]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:46.708]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:46.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:46.708]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:46.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:46.708]             base::names(...future.oldOptions))
[10:31:46.708]     }
[10:31:46.708]     if (FALSE) {
[10:31:46.708]     }
[10:31:46.708]     else {
[10:31:46.708]         if (TRUE) {
[10:31:46.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:46.708]                 open = "w")
[10:31:46.708]         }
[10:31:46.708]         else {
[10:31:46.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:46.708]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:46.708]         }
[10:31:46.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:46.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:46.708]             base::sink(type = "output", split = FALSE)
[10:31:46.708]             base::close(...future.stdout)
[10:31:46.708]         }, add = TRUE)
[10:31:46.708]     }
[10:31:46.708]     ...future.frame <- base::sys.nframe()
[10:31:46.708]     ...future.conditions <- base::list()
[10:31:46.708]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:46.708]     if (FALSE) {
[10:31:46.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:46.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:46.708]     }
[10:31:46.708]     ...future.result <- base::tryCatch({
[10:31:46.708]         base::withCallingHandlers({
[10:31:46.708]             ...future.value <- base::withVisible(base::local({
[10:31:46.708]                 withCallingHandlers({
[10:31:46.708]                   {
[10:31:46.708]                     do.call(function(...) {
[10:31:46.708]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.708]                       if (!identical(...future.globals.maxSize.org, 
[10:31:46.708]                         ...future.globals.maxSize)) {
[10:31:46.708]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.708]                         on.exit(options(oopts), add = TRUE)
[10:31:46.708]                       }
[10:31:46.708]                       {
[10:31:46.708]                         lapply(seq_along(...future.elements_ii), 
[10:31:46.708]                           FUN = function(jj) {
[10:31:46.708]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:46.708]                             ...future.FUN(...future.X_jj, ...)
[10:31:46.708]                           })
[10:31:46.708]                       }
[10:31:46.708]                     }, args = future.call.arguments)
[10:31:46.708]                   }
[10:31:46.708]                 }, immediateCondition = function(cond) {
[10:31:46.708]                   save_rds <- function (object, pathname, ...) 
[10:31:46.708]                   {
[10:31:46.708]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:46.708]                     if (file_test("-f", pathname_tmp)) {
[10:31:46.708]                       fi_tmp <- file.info(pathname_tmp)
[10:31:46.708]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:46.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:46.708]                         fi_tmp[["mtime"]])
[10:31:46.708]                     }
[10:31:46.708]                     tryCatch({
[10:31:46.708]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:46.708]                     }, error = function(ex) {
[10:31:46.708]                       msg <- conditionMessage(ex)
[10:31:46.708]                       fi_tmp <- file.info(pathname_tmp)
[10:31:46.708]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:46.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:46.708]                         fi_tmp[["mtime"]], msg)
[10:31:46.708]                       ex$message <- msg
[10:31:46.708]                       stop(ex)
[10:31:46.708]                     })
[10:31:46.708]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:46.708]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:46.708]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:46.708]                       fi_tmp <- file.info(pathname_tmp)
[10:31:46.708]                       fi <- file.info(pathname)
[10:31:46.708]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:46.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:46.708]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:46.708]                         fi[["size"]], fi[["mtime"]])
[10:31:46.708]                       stop(msg)
[10:31:46.708]                     }
[10:31:46.708]                     invisible(pathname)
[10:31:46.708]                   }
[10:31:46.708]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:46.708]                     rootPath = tempdir()) 
[10:31:46.708]                   {
[10:31:46.708]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:46.708]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:46.708]                       tmpdir = path, fileext = ".rds")
[10:31:46.708]                     save_rds(obj, file)
[10:31:46.708]                   }
[10:31:46.708]                   saveImmediateCondition(cond, path = "/tmp/Rtmptsj9Jv/.future/immediateConditions")
[10:31:46.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:46.708]                   {
[10:31:46.708]                     inherits <- base::inherits
[10:31:46.708]                     invokeRestart <- base::invokeRestart
[10:31:46.708]                     is.null <- base::is.null
[10:31:46.708]                     muffled <- FALSE
[10:31:46.708]                     if (inherits(cond, "message")) {
[10:31:46.708]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:46.708]                       if (muffled) 
[10:31:46.708]                         invokeRestart("muffleMessage")
[10:31:46.708]                     }
[10:31:46.708]                     else if (inherits(cond, "warning")) {
[10:31:46.708]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:46.708]                       if (muffled) 
[10:31:46.708]                         invokeRestart("muffleWarning")
[10:31:46.708]                     }
[10:31:46.708]                     else if (inherits(cond, "condition")) {
[10:31:46.708]                       if (!is.null(pattern)) {
[10:31:46.708]                         computeRestarts <- base::computeRestarts
[10:31:46.708]                         grepl <- base::grepl
[10:31:46.708]                         restarts <- computeRestarts(cond)
[10:31:46.708]                         for (restart in restarts) {
[10:31:46.708]                           name <- restart$name
[10:31:46.708]                           if (is.null(name)) 
[10:31:46.708]                             next
[10:31:46.708]                           if (!grepl(pattern, name)) 
[10:31:46.708]                             next
[10:31:46.708]                           invokeRestart(restart)
[10:31:46.708]                           muffled <- TRUE
[10:31:46.708]                           break
[10:31:46.708]                         }
[10:31:46.708]                       }
[10:31:46.708]                     }
[10:31:46.708]                     invisible(muffled)
[10:31:46.708]                   }
[10:31:46.708]                   muffleCondition(cond)
[10:31:46.708]                 })
[10:31:46.708]             }))
[10:31:46.708]             future::FutureResult(value = ...future.value$value, 
[10:31:46.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:46.708]                   ...future.rng), globalenv = if (FALSE) 
[10:31:46.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:46.708]                     ...future.globalenv.names))
[10:31:46.708]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:46.708]         }, condition = base::local({
[10:31:46.708]             c <- base::c
[10:31:46.708]             inherits <- base::inherits
[10:31:46.708]             invokeRestart <- base::invokeRestart
[10:31:46.708]             length <- base::length
[10:31:46.708]             list <- base::list
[10:31:46.708]             seq.int <- base::seq.int
[10:31:46.708]             signalCondition <- base::signalCondition
[10:31:46.708]             sys.calls <- base::sys.calls
[10:31:46.708]             `[[` <- base::`[[`
[10:31:46.708]             `+` <- base::`+`
[10:31:46.708]             `<<-` <- base::`<<-`
[10:31:46.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:46.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:46.708]                   3L)]
[10:31:46.708]             }
[10:31:46.708]             function(cond) {
[10:31:46.708]                 is_error <- inherits(cond, "error")
[10:31:46.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:46.708]                   NULL)
[10:31:46.708]                 if (is_error) {
[10:31:46.708]                   sessionInformation <- function() {
[10:31:46.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:46.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:46.708]                       search = base::search(), system = base::Sys.info())
[10:31:46.708]                   }
[10:31:46.708]                   ...future.conditions[[length(...future.conditions) + 
[10:31:46.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:46.708]                     cond$call), session = sessionInformation(), 
[10:31:46.708]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:46.708]                   signalCondition(cond)
[10:31:46.708]                 }
[10:31:46.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:46.708]                 "immediateCondition"))) {
[10:31:46.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:46.708]                   ...future.conditions[[length(...future.conditions) + 
[10:31:46.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:46.708]                   if (TRUE && !signal) {
[10:31:46.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:46.708]                     {
[10:31:46.708]                       inherits <- base::inherits
[10:31:46.708]                       invokeRestart <- base::invokeRestart
[10:31:46.708]                       is.null <- base::is.null
[10:31:46.708]                       muffled <- FALSE
[10:31:46.708]                       if (inherits(cond, "message")) {
[10:31:46.708]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:46.708]                         if (muffled) 
[10:31:46.708]                           invokeRestart("muffleMessage")
[10:31:46.708]                       }
[10:31:46.708]                       else if (inherits(cond, "warning")) {
[10:31:46.708]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:46.708]                         if (muffled) 
[10:31:46.708]                           invokeRestart("muffleWarning")
[10:31:46.708]                       }
[10:31:46.708]                       else if (inherits(cond, "condition")) {
[10:31:46.708]                         if (!is.null(pattern)) {
[10:31:46.708]                           computeRestarts <- base::computeRestarts
[10:31:46.708]                           grepl <- base::grepl
[10:31:46.708]                           restarts <- computeRestarts(cond)
[10:31:46.708]                           for (restart in restarts) {
[10:31:46.708]                             name <- restart$name
[10:31:46.708]                             if (is.null(name)) 
[10:31:46.708]                               next
[10:31:46.708]                             if (!grepl(pattern, name)) 
[10:31:46.708]                               next
[10:31:46.708]                             invokeRestart(restart)
[10:31:46.708]                             muffled <- TRUE
[10:31:46.708]                             break
[10:31:46.708]                           }
[10:31:46.708]                         }
[10:31:46.708]                       }
[10:31:46.708]                       invisible(muffled)
[10:31:46.708]                     }
[10:31:46.708]                     muffleCondition(cond, pattern = "^muffle")
[10:31:46.708]                   }
[10:31:46.708]                 }
[10:31:46.708]                 else {
[10:31:46.708]                   if (TRUE) {
[10:31:46.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:46.708]                     {
[10:31:46.708]                       inherits <- base::inherits
[10:31:46.708]                       invokeRestart <- base::invokeRestart
[10:31:46.708]                       is.null <- base::is.null
[10:31:46.708]                       muffled <- FALSE
[10:31:46.708]                       if (inherits(cond, "message")) {
[10:31:46.708]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:46.708]                         if (muffled) 
[10:31:46.708]                           invokeRestart("muffleMessage")
[10:31:46.708]                       }
[10:31:46.708]                       else if (inherits(cond, "warning")) {
[10:31:46.708]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:46.708]                         if (muffled) 
[10:31:46.708]                           invokeRestart("muffleWarning")
[10:31:46.708]                       }
[10:31:46.708]                       else if (inherits(cond, "condition")) {
[10:31:46.708]                         if (!is.null(pattern)) {
[10:31:46.708]                           computeRestarts <- base::computeRestarts
[10:31:46.708]                           grepl <- base::grepl
[10:31:46.708]                           restarts <- computeRestarts(cond)
[10:31:46.708]                           for (restart in restarts) {
[10:31:46.708]                             name <- restart$name
[10:31:46.708]                             if (is.null(name)) 
[10:31:46.708]                               next
[10:31:46.708]                             if (!grepl(pattern, name)) 
[10:31:46.708]                               next
[10:31:46.708]                             invokeRestart(restart)
[10:31:46.708]                             muffled <- TRUE
[10:31:46.708]                             break
[10:31:46.708]                           }
[10:31:46.708]                         }
[10:31:46.708]                       }
[10:31:46.708]                       invisible(muffled)
[10:31:46.708]                     }
[10:31:46.708]                     muffleCondition(cond, pattern = "^muffle")
[10:31:46.708]                   }
[10:31:46.708]                 }
[10:31:46.708]             }
[10:31:46.708]         }))
[10:31:46.708]     }, error = function(ex) {
[10:31:46.708]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:46.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:46.708]                 ...future.rng), started = ...future.startTime, 
[10:31:46.708]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:46.708]             version = "1.8"), class = "FutureResult")
[10:31:46.708]     }, finally = {
[10:31:46.708]         if (!identical(...future.workdir, getwd())) 
[10:31:46.708]             setwd(...future.workdir)
[10:31:46.708]         {
[10:31:46.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:46.708]                 ...future.oldOptions$nwarnings <- NULL
[10:31:46.708]             }
[10:31:46.708]             base::options(...future.oldOptions)
[10:31:46.708]             if (.Platform$OS.type == "windows") {
[10:31:46.708]                 old_names <- names(...future.oldEnvVars)
[10:31:46.708]                 envs <- base::Sys.getenv()
[10:31:46.708]                 names <- names(envs)
[10:31:46.708]                 common <- intersect(names, old_names)
[10:31:46.708]                 added <- setdiff(names, old_names)
[10:31:46.708]                 removed <- setdiff(old_names, names)
[10:31:46.708]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:46.708]                   envs[common]]
[10:31:46.708]                 NAMES <- toupper(changed)
[10:31:46.708]                 args <- list()
[10:31:46.708]                 for (kk in seq_along(NAMES)) {
[10:31:46.708]                   name <- changed[[kk]]
[10:31:46.708]                   NAME <- NAMES[[kk]]
[10:31:46.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:46.708]                     next
[10:31:46.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:46.708]                 }
[10:31:46.708]                 NAMES <- toupper(added)
[10:31:46.708]                 for (kk in seq_along(NAMES)) {
[10:31:46.708]                   name <- added[[kk]]
[10:31:46.708]                   NAME <- NAMES[[kk]]
[10:31:46.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:46.708]                     next
[10:31:46.708]                   args[[name]] <- ""
[10:31:46.708]                 }
[10:31:46.708]                 NAMES <- toupper(removed)
[10:31:46.708]                 for (kk in seq_along(NAMES)) {
[10:31:46.708]                   name <- removed[[kk]]
[10:31:46.708]                   NAME <- NAMES[[kk]]
[10:31:46.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:46.708]                     next
[10:31:46.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:46.708]                 }
[10:31:46.708]                 if (length(args) > 0) 
[10:31:46.708]                   base::do.call(base::Sys.setenv, args = args)
[10:31:46.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:46.708]             }
[10:31:46.708]             else {
[10:31:46.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:46.708]             }
[10:31:46.708]             {
[10:31:46.708]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:46.708]                   0L) {
[10:31:46.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:46.708]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:46.708]                   base::options(opts)
[10:31:46.708]                 }
[10:31:46.708]                 {
[10:31:46.708]                   {
[10:31:46.708]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:46.708]                     NULL
[10:31:46.708]                   }
[10:31:46.708]                   options(future.plan = NULL)
[10:31:46.708]                   if (is.na(NA_character_)) 
[10:31:46.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:46.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:46.708]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:46.708]                     .init = FALSE)
[10:31:46.708]                 }
[10:31:46.708]             }
[10:31:46.708]         }
[10:31:46.708]     })
[10:31:46.708]     if (TRUE) {
[10:31:46.708]         base::sink(type = "output", split = FALSE)
[10:31:46.708]         if (TRUE) {
[10:31:46.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:46.708]         }
[10:31:46.708]         else {
[10:31:46.708]             ...future.result["stdout"] <- base::list(NULL)
[10:31:46.708]         }
[10:31:46.708]         base::close(...future.stdout)
[10:31:46.708]         ...future.stdout <- NULL
[10:31:46.708]     }
[10:31:46.708]     ...future.result$conditions <- ...future.conditions
[10:31:46.708]     ...future.result$finished <- base::Sys.time()
[10:31:46.708]     ...future.result
[10:31:46.708] }
[10:31:46.711] assign_globals() ...
[10:31:46.711] List of 5
[10:31:46.711]  $ ...future.FUN            :function (x)  
[10:31:46.711]  $ future.call.arguments    : list()
[10:31:46.711]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:46.711]  $ ...future.elements_ii    :List of 1
[10:31:46.711]   ..$ : int 0
[10:31:46.711]  $ ...future.seeds_ii       : NULL
[10:31:46.711]  $ ...future.globals.maxSize: NULL
[10:31:46.711]  - attr(*, "where")=List of 5
[10:31:46.711]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:46.711]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:46.711]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:46.711]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:46.711]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:46.711]  - attr(*, "resolved")= logi FALSE
[10:31:46.711]  - attr(*, "total_size")= num 4720
[10:31:46.711]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:46.711]  - attr(*, "already-done")= logi TRUE
[10:31:46.717] - reassign environment for ‘...future.FUN’
[10:31:46.718] - copied ‘...future.FUN’ to environment
[10:31:46.718] - copied ‘future.call.arguments’ to environment
[10:31:46.718] - copied ‘...future.elements_ii’ to environment
[10:31:46.718] - copied ‘...future.seeds_ii’ to environment
[10:31:46.718] - copied ‘...future.globals.maxSize’ to environment
[10:31:46.718] assign_globals() ... done
[10:31:46.718] requestCore(): workers = 2
[10:31:46.721] MulticoreFuture started
[10:31:46.721] - Launch lazy future ... done
[10:31:46.722] run() for ‘MulticoreFuture’ ... done
[10:31:46.722] Created future:
[10:31:46.722] plan(): Setting new future strategy stack:
[10:31:46.722] List of future strategies:
[10:31:46.722] 1. sequential:
[10:31:46.722]    - args: function (..., envir = parent.frame())
[10:31:46.722]    - tweaked: FALSE
[10:31:46.722]    - call: NULL
[10:31:46.723] plan(): nbrOfWorkers() = 1
[10:31:46.725] plan(): Setting new future strategy stack:
[10:31:46.726] List of future strategies:
[10:31:46.726] 1. multicore:
[10:31:46.726]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:46.726]    - tweaked: FALSE
[10:31:46.726]    - call: plan(strategy)
[10:31:46.731] plan(): nbrOfWorkers() = 2
[10:31:46.722] MulticoreFuture:
[10:31:46.722] Label: ‘future_lapply-2’
[10:31:46.722] Expression:
[10:31:46.722] {
[10:31:46.722]     do.call(function(...) {
[10:31:46.722]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:46.722]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:46.722]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:46.722]             on.exit(options(oopts), add = TRUE)
[10:31:46.722]         }
[10:31:46.722]         {
[10:31:46.722]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:46.722]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:46.722]                 ...future.FUN(...future.X_jj, ...)
[10:31:46.722]             })
[10:31:46.722]         }
[10:31:46.722]     }, args = future.call.arguments)
[10:31:46.722] }
[10:31:46.722] Lazy evaluation: FALSE
[10:31:46.722] Asynchronous evaluation: TRUE
[10:31:46.722] Local evaluation: TRUE
[10:31:46.722] Environment: R_GlobalEnv
[10:31:46.722] Capture standard output: TRUE
[10:31:46.722] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:46.722] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:46.722] Packages: <none>
[10:31:46.722] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:46.722] Resolved: TRUE
[10:31:46.722] Value: <not collected>
[10:31:46.722] Conditions captured: <none>
[10:31:46.722] Early signaling: FALSE
[10:31:46.722] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:46.722] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:46.732] Chunk #2 of 2 ... DONE
[10:31:46.732] Launching 2 futures (chunks) ... DONE
[10:31:46.732] Resolving 2 futures (chunks) ...
[10:31:46.732] resolve() on list ...
[10:31:46.733]  recursive: 0
[10:31:46.733]  length: 2
[10:31:46.733] 
[10:31:46.744] Future #2
[10:31:46.744] result() for MulticoreFuture ...
[10:31:46.745] result() for MulticoreFuture ...
[10:31:46.745] result() for MulticoreFuture ... done
[10:31:46.745] result() for MulticoreFuture ... done
[10:31:46.745] result() for MulticoreFuture ...
[10:31:46.745] result() for MulticoreFuture ... done
[10:31:46.746] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:46.746] - nx: 2
[10:31:46.746] - relay: TRUE
[10:31:46.746] - stdout: TRUE
[10:31:46.746] - signal: TRUE
[10:31:46.746] - resignal: FALSE
[10:31:46.747] - force: TRUE
[10:31:46.747] - relayed: [n=2] FALSE, FALSE
[10:31:46.747] - queued futures: [n=2] FALSE, FALSE
[10:31:46.747]  - until=1
[10:31:46.747]  - relaying element #1
[10:31:46.747] - relayed: [n=2] FALSE, FALSE
[10:31:46.747] - queued futures: [n=2] FALSE, TRUE
[10:31:46.748] signalConditionsASAP(NULL, pos=2) ... done
[10:31:46.748]  length: 1 (resolved future 2)
[10:31:47.179] plan(): Setting new future strategy stack:
[10:31:47.179] List of future strategies:
[10:31:47.179] 1. multicore:
[10:31:47.179]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:47.179]    - tweaked: FALSE
[10:31:47.179]    - call: plan(strategy)
[10:31:47.185] plan(): nbrOfWorkers() = 2
[10:31:47.188] Future #1
[10:31:47.189] result() for MulticoreFuture ...
[10:31:47.189] result() for MulticoreFuture ...
[10:31:47.193] result() for MulticoreFuture ... done
[10:31:47.193] result() for MulticoreFuture ... done
[10:31:47.193] result() for MulticoreFuture ...
[10:31:47.193] result() for MulticoreFuture ... done
[10:31:47.194] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:47.194] - nx: 2
[10:31:47.194] - relay: TRUE
[10:31:47.194] - stdout: TRUE
[10:31:47.194] - signal: TRUE
[10:31:47.195] - resignal: FALSE
[10:31:47.195] - force: TRUE
[10:31:47.195] - relayed: [n=2] FALSE, FALSE
[10:31:47.195] - queued futures: [n=2] FALSE, TRUE
[10:31:47.195]  - until=1
[10:31:47.195]  - relaying element #1
[10:31:47.196] result() for MulticoreFuture ...
[10:31:47.196] result() for MulticoreFuture ... done
[10:31:47.196] result() for MulticoreFuture ...
[10:31:47.196] result() for MulticoreFuture ... done
[10:31:47.196] result() for MulticoreFuture ...
[10:31:47.196] result() for MulticoreFuture ... done
[10:31:47.196] result() for MulticoreFuture ...
[10:31:47.196] result() for MulticoreFuture ... done
[10:31:47.197] - relayed: [n=2] TRUE, FALSE
[10:31:47.197] - queued futures: [n=2] TRUE, TRUE
[10:31:47.197] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:47.197]  length: 0 (resolved future 1)
[10:31:47.197] Relaying remaining futures
[10:31:47.197] signalConditionsASAP(NULL, pos=0) ...
[10:31:47.197] - nx: 2
[10:31:47.198] - relay: TRUE
[10:31:47.198] - stdout: TRUE
[10:31:47.198] - signal: TRUE
[10:31:47.198] - resignal: FALSE
[10:31:47.198] - force: TRUE
[10:31:47.198] - relayed: [n=2] TRUE, FALSE
[10:31:47.198] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:47.198]  - relaying element #2
[10:31:47.199] result() for MulticoreFuture ...
[10:31:47.199] result() for MulticoreFuture ... done
[10:31:47.199] result() for MulticoreFuture ...
[10:31:47.199] result() for MulticoreFuture ... done
[10:31:47.199] result() for MulticoreFuture ...
[10:31:47.199] result() for MulticoreFuture ... done
[10:31:47.199] result() for MulticoreFuture ...
[10:31:47.199] result() for MulticoreFuture ... done
[10:31:47.200] - relayed: [n=2] TRUE, TRUE
[10:31:47.200] - queued futures: [n=2] TRUE, TRUE
[10:31:47.200] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:31:47.200] resolve() on list ... DONE
[10:31:47.200] result() for MulticoreFuture ...
[10:31:47.200] result() for MulticoreFuture ... done
[10:31:47.200] result() for MulticoreFuture ...
[10:31:47.200] result() for MulticoreFuture ... done
[10:31:47.200] result() for MulticoreFuture ...
[10:31:47.201] result() for MulticoreFuture ... done
[10:31:47.201] result() for MulticoreFuture ...
[10:31:47.201] result() for MulticoreFuture ... done
[10:31:47.201]  - Number of value chunks collected: 2
[10:31:47.201] Resolving 2 futures (chunks) ... DONE
[10:31:47.201] Reducing values from 2 chunks ...
[10:31:47.201]  - Number of values collected after concatenation: 2
[10:31:47.201]  - Number of values expected: 2
[10:31:47.202] Reducing values from 2 chunks ... DONE
[10:31:47.202] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:31:47.202] future_lapply() ...
[10:31:47.207] Number of chunks: 2
[10:31:47.207] getGlobalsAndPackagesXApply() ...
[10:31:47.207]  - future.globals: TRUE
[10:31:47.207] getGlobalsAndPackages() ...
[10:31:47.208] Searching for globals...
[10:31:47.209] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:47.209] Searching for globals ... DONE
[10:31:47.210] Resolving globals: FALSE
[10:31:47.210] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:47.210] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:47.211] - globals: [1] ‘FUN’
[10:31:47.211] 
[10:31:47.211] getGlobalsAndPackages() ... DONE
[10:31:47.211]  - globals found/used: [n=1] ‘FUN’
[10:31:47.211]  - needed namespaces: [n=0] 
[10:31:47.211] Finding globals ... DONE
[10:31:47.211]  - use_args: TRUE
[10:31:47.211]  - Getting '...' globals ...
[10:31:47.212] resolve() on list ...
[10:31:47.212]  recursive: 0
[10:31:47.212]  length: 1
[10:31:47.212]  elements: ‘...’
[10:31:47.212]  length: 0 (resolved future 1)
[10:31:47.212] resolve() on list ... DONE
[10:31:47.212]    - '...' content: [n=0] 
[10:31:47.213] List of 1
[10:31:47.213]  $ ...: list()
[10:31:47.213]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:47.213]  - attr(*, "where")=List of 1
[10:31:47.213]   ..$ ...:<environment: 0x564ff3479a38> 
[10:31:47.213]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:47.213]  - attr(*, "resolved")= logi TRUE
[10:31:47.213]  - attr(*, "total_size")= num NA
[10:31:47.215]  - Getting '...' globals ... DONE
[10:31:47.216] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:47.216] List of 2
[10:31:47.216]  $ ...future.FUN:function (x)  
[10:31:47.216]  $ ...          : list()
[10:31:47.216]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:47.216]  - attr(*, "where")=List of 2
[10:31:47.216]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:47.216]   ..$ ...          :<environment: 0x564ff3479a38> 
[10:31:47.216]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:47.216]  - attr(*, "resolved")= logi FALSE
[10:31:47.216]  - attr(*, "total_size")= num 4720
[10:31:47.218] Packages to be attached in all futures: [n=0] 
[10:31:47.219] getGlobalsAndPackagesXApply() ... DONE
[10:31:47.219] Number of futures (= number of chunks): 2
[10:31:47.219] Launching 2 futures (chunks) ...
[10:31:47.219] Chunk #1 of 2 ...
[10:31:47.219]  - Finding globals in 'X' for chunk #1 ...
[10:31:47.219] getGlobalsAndPackages() ...
[10:31:47.219] Searching for globals...
[10:31:47.220] 
[10:31:47.220] Searching for globals ... DONE
[10:31:47.220] - globals: [0] <none>
[10:31:47.220] getGlobalsAndPackages() ... DONE
[10:31:47.220]    + additional globals found: [n=0] 
[10:31:47.222]    + additional namespaces needed: [n=0] 
[10:31:47.222]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:47.222]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:47.222]  - seeds: <none>
[10:31:47.222]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:47.223] getGlobalsAndPackages() ...
[10:31:47.223] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:47.223] Resolving globals: FALSE
[10:31:47.223] Tweak future expression to call with '...' arguments ...
[10:31:47.223] {
[10:31:47.223]     do.call(function(...) {
[10:31:47.223]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:47.223]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:47.223]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:47.223]             on.exit(options(oopts), add = TRUE)
[10:31:47.223]         }
[10:31:47.223]         {
[10:31:47.223]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:47.223]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:47.223]                 ...future.FUN(...future.X_jj, ...)
[10:31:47.223]             })
[10:31:47.223]         }
[10:31:47.223]     }, args = future.call.arguments)
[10:31:47.223] }
[10:31:47.223] Tweak future expression to call with '...' arguments ... DONE
[10:31:47.224] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:47.224] 
[10:31:47.224] getGlobalsAndPackages() ... DONE
[10:31:47.224] run() for ‘Future’ ...
[10:31:47.224] - state: ‘created’
[10:31:47.225] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:47.228] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:47.229] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:47.229]   - Field: ‘label’
[10:31:47.229]   - Field: ‘local’
[10:31:47.229]   - Field: ‘owner’
[10:31:47.229]   - Field: ‘envir’
[10:31:47.229]   - Field: ‘workers’
[10:31:47.229]   - Field: ‘packages’
[10:31:47.229]   - Field: ‘gc’
[10:31:47.229]   - Field: ‘job’
[10:31:47.230]   - Field: ‘conditions’
[10:31:47.230]   - Field: ‘expr’
[10:31:47.230]   - Field: ‘uuid’
[10:31:47.230]   - Field: ‘seed’
[10:31:47.230]   - Field: ‘version’
[10:31:47.230]   - Field: ‘result’
[10:31:47.230]   - Field: ‘asynchronous’
[10:31:47.230]   - Field: ‘calls’
[10:31:47.230]   - Field: ‘globals’
[10:31:47.230]   - Field: ‘stdout’
[10:31:47.230]   - Field: ‘earlySignal’
[10:31:47.231]   - Field: ‘lazy’
[10:31:47.231]   - Field: ‘state’
[10:31:47.231] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:47.231] - Launch lazy future ...
[10:31:47.231] Packages needed by the future expression (n = 0): <none>
[10:31:47.231] Packages needed by future strategies (n = 0): <none>
[10:31:47.232] {
[10:31:47.232]     {
[10:31:47.232]         {
[10:31:47.232]             ...future.startTime <- base::Sys.time()
[10:31:47.232]             {
[10:31:47.232]                 {
[10:31:47.232]                   {
[10:31:47.232]                     {
[10:31:47.232]                       base::local({
[10:31:47.232]                         has_future <- base::requireNamespace("future", 
[10:31:47.232]                           quietly = TRUE)
[10:31:47.232]                         if (has_future) {
[10:31:47.232]                           ns <- base::getNamespace("future")
[10:31:47.232]                           version <- ns[[".package"]][["version"]]
[10:31:47.232]                           if (is.null(version)) 
[10:31:47.232]                             version <- utils::packageVersion("future")
[10:31:47.232]                         }
[10:31:47.232]                         else {
[10:31:47.232]                           version <- NULL
[10:31:47.232]                         }
[10:31:47.232]                         if (!has_future || version < "1.8.0") {
[10:31:47.232]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:47.232]                             "", base::R.version$version.string), 
[10:31:47.232]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:47.232]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:47.232]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:47.232]                               "release", "version")], collapse = " "), 
[10:31:47.232]                             hostname = base::Sys.info()[["nodename"]])
[10:31:47.232]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:47.232]                             info)
[10:31:47.232]                           info <- base::paste(info, collapse = "; ")
[10:31:47.232]                           if (!has_future) {
[10:31:47.232]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:47.232]                               info)
[10:31:47.232]                           }
[10:31:47.232]                           else {
[10:31:47.232]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:47.232]                               info, version)
[10:31:47.232]                           }
[10:31:47.232]                           base::stop(msg)
[10:31:47.232]                         }
[10:31:47.232]                       })
[10:31:47.232]                     }
[10:31:47.232]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:47.232]                     base::options(mc.cores = 1L)
[10:31:47.232]                   }
[10:31:47.232]                   ...future.strategy.old <- future::plan("list")
[10:31:47.232]                   options(future.plan = NULL)
[10:31:47.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:47.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:47.232]                 }
[10:31:47.232]                 ...future.workdir <- getwd()
[10:31:47.232]             }
[10:31:47.232]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:47.232]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:47.232]         }
[10:31:47.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:47.232]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:47.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:47.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:47.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:47.232]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:47.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:47.232]             base::names(...future.oldOptions))
[10:31:47.232]     }
[10:31:47.232]     if (TRUE) {
[10:31:47.232]     }
[10:31:47.232]     else {
[10:31:47.232]         if (NA) {
[10:31:47.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:47.232]                 open = "w")
[10:31:47.232]         }
[10:31:47.232]         else {
[10:31:47.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:47.232]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:47.232]         }
[10:31:47.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:47.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:47.232]             base::sink(type = "output", split = FALSE)
[10:31:47.232]             base::close(...future.stdout)
[10:31:47.232]         }, add = TRUE)
[10:31:47.232]     }
[10:31:47.232]     ...future.frame <- base::sys.nframe()
[10:31:47.232]     ...future.conditions <- base::list()
[10:31:47.232]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:47.232]     if (FALSE) {
[10:31:47.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:47.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:47.232]     }
[10:31:47.232]     ...future.result <- base::tryCatch({
[10:31:47.232]         base::withCallingHandlers({
[10:31:47.232]             ...future.value <- base::withVisible(base::local({
[10:31:47.232]                 withCallingHandlers({
[10:31:47.232]                   {
[10:31:47.232]                     do.call(function(...) {
[10:31:47.232]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:47.232]                       if (!identical(...future.globals.maxSize.org, 
[10:31:47.232]                         ...future.globals.maxSize)) {
[10:31:47.232]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:47.232]                         on.exit(options(oopts), add = TRUE)
[10:31:47.232]                       }
[10:31:47.232]                       {
[10:31:47.232]                         lapply(seq_along(...future.elements_ii), 
[10:31:47.232]                           FUN = function(jj) {
[10:31:47.232]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:47.232]                             ...future.FUN(...future.X_jj, ...)
[10:31:47.232]                           })
[10:31:47.232]                       }
[10:31:47.232]                     }, args = future.call.arguments)
[10:31:47.232]                   }
[10:31:47.232]                 }, immediateCondition = function(cond) {
[10:31:47.232]                   save_rds <- function (object, pathname, ...) 
[10:31:47.232]                   {
[10:31:47.232]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:47.232]                     if (file_test("-f", pathname_tmp)) {
[10:31:47.232]                       fi_tmp <- file.info(pathname_tmp)
[10:31:47.232]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:47.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:47.232]                         fi_tmp[["mtime"]])
[10:31:47.232]                     }
[10:31:47.232]                     tryCatch({
[10:31:47.232]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:47.232]                     }, error = function(ex) {
[10:31:47.232]                       msg <- conditionMessage(ex)
[10:31:47.232]                       fi_tmp <- file.info(pathname_tmp)
[10:31:47.232]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:47.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:47.232]                         fi_tmp[["mtime"]], msg)
[10:31:47.232]                       ex$message <- msg
[10:31:47.232]                       stop(ex)
[10:31:47.232]                     })
[10:31:47.232]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:47.232]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:47.232]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:47.232]                       fi_tmp <- file.info(pathname_tmp)
[10:31:47.232]                       fi <- file.info(pathname)
[10:31:47.232]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:47.232]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:47.232]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:47.232]                         fi[["size"]], fi[["mtime"]])
[10:31:47.232]                       stop(msg)
[10:31:47.232]                     }
[10:31:47.232]                     invisible(pathname)
[10:31:47.232]                   }
[10:31:47.232]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:47.232]                     rootPath = tempdir()) 
[10:31:47.232]                   {
[10:31:47.232]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:47.232]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:47.232]                       tmpdir = path, fileext = ".rds")
[10:31:47.232]                     save_rds(obj, file)
[10:31:47.232]                   }
[10:31:47.232]                   saveImmediateCondition(cond, path = "/tmp/Rtmptsj9Jv/.future/immediateConditions")
[10:31:47.232]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:47.232]                   {
[10:31:47.232]                     inherits <- base::inherits
[10:31:47.232]                     invokeRestart <- base::invokeRestart
[10:31:47.232]                     is.null <- base::is.null
[10:31:47.232]                     muffled <- FALSE
[10:31:47.232]                     if (inherits(cond, "message")) {
[10:31:47.232]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:47.232]                       if (muffled) 
[10:31:47.232]                         invokeRestart("muffleMessage")
[10:31:47.232]                     }
[10:31:47.232]                     else if (inherits(cond, "warning")) {
[10:31:47.232]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:47.232]                       if (muffled) 
[10:31:47.232]                         invokeRestart("muffleWarning")
[10:31:47.232]                     }
[10:31:47.232]                     else if (inherits(cond, "condition")) {
[10:31:47.232]                       if (!is.null(pattern)) {
[10:31:47.232]                         computeRestarts <- base::computeRestarts
[10:31:47.232]                         grepl <- base::grepl
[10:31:47.232]                         restarts <- computeRestarts(cond)
[10:31:47.232]                         for (restart in restarts) {
[10:31:47.232]                           name <- restart$name
[10:31:47.232]                           if (is.null(name)) 
[10:31:47.232]                             next
[10:31:47.232]                           if (!grepl(pattern, name)) 
[10:31:47.232]                             next
[10:31:47.232]                           invokeRestart(restart)
[10:31:47.232]                           muffled <- TRUE
[10:31:47.232]                           break
[10:31:47.232]                         }
[10:31:47.232]                       }
[10:31:47.232]                     }
[10:31:47.232]                     invisible(muffled)
[10:31:47.232]                   }
[10:31:47.232]                   muffleCondition(cond)
[10:31:47.232]                 })
[10:31:47.232]             }))
[10:31:47.232]             future::FutureResult(value = ...future.value$value, 
[10:31:47.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:47.232]                   ...future.rng), globalenv = if (FALSE) 
[10:31:47.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:47.232]                     ...future.globalenv.names))
[10:31:47.232]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:47.232]         }, condition = base::local({
[10:31:47.232]             c <- base::c
[10:31:47.232]             inherits <- base::inherits
[10:31:47.232]             invokeRestart <- base::invokeRestart
[10:31:47.232]             length <- base::length
[10:31:47.232]             list <- base::list
[10:31:47.232]             seq.int <- base::seq.int
[10:31:47.232]             signalCondition <- base::signalCondition
[10:31:47.232]             sys.calls <- base::sys.calls
[10:31:47.232]             `[[` <- base::`[[`
[10:31:47.232]             `+` <- base::`+`
[10:31:47.232]             `<<-` <- base::`<<-`
[10:31:47.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:47.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:47.232]                   3L)]
[10:31:47.232]             }
[10:31:47.232]             function(cond) {
[10:31:47.232]                 is_error <- inherits(cond, "error")
[10:31:47.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:47.232]                   NULL)
[10:31:47.232]                 if (is_error) {
[10:31:47.232]                   sessionInformation <- function() {
[10:31:47.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:47.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:47.232]                       search = base::search(), system = base::Sys.info())
[10:31:47.232]                   }
[10:31:47.232]                   ...future.conditions[[length(...future.conditions) + 
[10:31:47.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:47.232]                     cond$call), session = sessionInformation(), 
[10:31:47.232]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:47.232]                   signalCondition(cond)
[10:31:47.232]                 }
[10:31:47.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:47.232]                 "immediateCondition"))) {
[10:31:47.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:47.232]                   ...future.conditions[[length(...future.conditions) + 
[10:31:47.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:47.232]                   if (TRUE && !signal) {
[10:31:47.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:47.232]                     {
[10:31:47.232]                       inherits <- base::inherits
[10:31:47.232]                       invokeRestart <- base::invokeRestart
[10:31:47.232]                       is.null <- base::is.null
[10:31:47.232]                       muffled <- FALSE
[10:31:47.232]                       if (inherits(cond, "message")) {
[10:31:47.232]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:47.232]                         if (muffled) 
[10:31:47.232]                           invokeRestart("muffleMessage")
[10:31:47.232]                       }
[10:31:47.232]                       else if (inherits(cond, "warning")) {
[10:31:47.232]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:47.232]                         if (muffled) 
[10:31:47.232]                           invokeRestart("muffleWarning")
[10:31:47.232]                       }
[10:31:47.232]                       else if (inherits(cond, "condition")) {
[10:31:47.232]                         if (!is.null(pattern)) {
[10:31:47.232]                           computeRestarts <- base::computeRestarts
[10:31:47.232]                           grepl <- base::grepl
[10:31:47.232]                           restarts <- computeRestarts(cond)
[10:31:47.232]                           for (restart in restarts) {
[10:31:47.232]                             name <- restart$name
[10:31:47.232]                             if (is.null(name)) 
[10:31:47.232]                               next
[10:31:47.232]                             if (!grepl(pattern, name)) 
[10:31:47.232]                               next
[10:31:47.232]                             invokeRestart(restart)
[10:31:47.232]                             muffled <- TRUE
[10:31:47.232]                             break
[10:31:47.232]                           }
[10:31:47.232]                         }
[10:31:47.232]                       }
[10:31:47.232]                       invisible(muffled)
[10:31:47.232]                     }
[10:31:47.232]                     muffleCondition(cond, pattern = "^muffle")
[10:31:47.232]                   }
[10:31:47.232]                 }
[10:31:47.232]                 else {
[10:31:47.232]                   if (TRUE) {
[10:31:47.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:47.232]                     {
[10:31:47.232]                       inherits <- base::inherits
[10:31:47.232]                       invokeRestart <- base::invokeRestart
[10:31:47.232]                       is.null <- base::is.null
[10:31:47.232]                       muffled <- FALSE
[10:31:47.232]                       if (inherits(cond, "message")) {
[10:31:47.232]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:47.232]                         if (muffled) 
[10:31:47.232]                           invokeRestart("muffleMessage")
[10:31:47.232]                       }
[10:31:47.232]                       else if (inherits(cond, "warning")) {
[10:31:47.232]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:47.232]                         if (muffled) 
[10:31:47.232]                           invokeRestart("muffleWarning")
[10:31:47.232]                       }
[10:31:47.232]                       else if (inherits(cond, "condition")) {
[10:31:47.232]                         if (!is.null(pattern)) {
[10:31:47.232]                           computeRestarts <- base::computeRestarts
[10:31:47.232]                           grepl <- base::grepl
[10:31:47.232]                           restarts <- computeRestarts(cond)
[10:31:47.232]                           for (restart in restarts) {
[10:31:47.232]                             name <- restart$name
[10:31:47.232]                             if (is.null(name)) 
[10:31:47.232]                               next
[10:31:47.232]                             if (!grepl(pattern, name)) 
[10:31:47.232]                               next
[10:31:47.232]                             invokeRestart(restart)
[10:31:47.232]                             muffled <- TRUE
[10:31:47.232]                             break
[10:31:47.232]                           }
[10:31:47.232]                         }
[10:31:47.232]                       }
[10:31:47.232]                       invisible(muffled)
[10:31:47.232]                     }
[10:31:47.232]                     muffleCondition(cond, pattern = "^muffle")
[10:31:47.232]                   }
[10:31:47.232]                 }
[10:31:47.232]             }
[10:31:47.232]         }))
[10:31:47.232]     }, error = function(ex) {
[10:31:47.232]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:47.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:47.232]                 ...future.rng), started = ...future.startTime, 
[10:31:47.232]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:47.232]             version = "1.8"), class = "FutureResult")
[10:31:47.232]     }, finally = {
[10:31:47.232]         if (!identical(...future.workdir, getwd())) 
[10:31:47.232]             setwd(...future.workdir)
[10:31:47.232]         {
[10:31:47.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:47.232]                 ...future.oldOptions$nwarnings <- NULL
[10:31:47.232]             }
[10:31:47.232]             base::options(...future.oldOptions)
[10:31:47.232]             if (.Platform$OS.type == "windows") {
[10:31:47.232]                 old_names <- names(...future.oldEnvVars)
[10:31:47.232]                 envs <- base::Sys.getenv()
[10:31:47.232]                 names <- names(envs)
[10:31:47.232]                 common <- intersect(names, old_names)
[10:31:47.232]                 added <- setdiff(names, old_names)
[10:31:47.232]                 removed <- setdiff(old_names, names)
[10:31:47.232]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:47.232]                   envs[common]]
[10:31:47.232]                 NAMES <- toupper(changed)
[10:31:47.232]                 args <- list()
[10:31:47.232]                 for (kk in seq_along(NAMES)) {
[10:31:47.232]                   name <- changed[[kk]]
[10:31:47.232]                   NAME <- NAMES[[kk]]
[10:31:47.232]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:47.232]                     next
[10:31:47.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:47.232]                 }
[10:31:47.232]                 NAMES <- toupper(added)
[10:31:47.232]                 for (kk in seq_along(NAMES)) {
[10:31:47.232]                   name <- added[[kk]]
[10:31:47.232]                   NAME <- NAMES[[kk]]
[10:31:47.232]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:47.232]                     next
[10:31:47.232]                   args[[name]] <- ""
[10:31:47.232]                 }
[10:31:47.232]                 NAMES <- toupper(removed)
[10:31:47.232]                 for (kk in seq_along(NAMES)) {
[10:31:47.232]                   name <- removed[[kk]]
[10:31:47.232]                   NAME <- NAMES[[kk]]
[10:31:47.232]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:47.232]                     next
[10:31:47.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:47.232]                 }
[10:31:47.232]                 if (length(args) > 0) 
[10:31:47.232]                   base::do.call(base::Sys.setenv, args = args)
[10:31:47.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:47.232]             }
[10:31:47.232]             else {
[10:31:47.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:47.232]             }
[10:31:47.232]             {
[10:31:47.232]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:47.232]                   0L) {
[10:31:47.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:47.232]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:47.232]                   base::options(opts)
[10:31:47.232]                 }
[10:31:47.232]                 {
[10:31:47.232]                   {
[10:31:47.232]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:47.232]                     NULL
[10:31:47.232]                   }
[10:31:47.232]                   options(future.plan = NULL)
[10:31:47.232]                   if (is.na(NA_character_)) 
[10:31:47.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:47.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:47.232]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:47.232]                     .init = FALSE)
[10:31:47.232]                 }
[10:31:47.232]             }
[10:31:47.232]         }
[10:31:47.232]     })
[10:31:47.232]     if (FALSE) {
[10:31:47.232]         base::sink(type = "output", split = FALSE)
[10:31:47.232]         if (NA) {
[10:31:47.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:47.232]         }
[10:31:47.232]         else {
[10:31:47.232]             ...future.result["stdout"] <- base::list(NULL)
[10:31:47.232]         }
[10:31:47.232]         base::close(...future.stdout)
[10:31:47.232]         ...future.stdout <- NULL
[10:31:47.232]     }
[10:31:47.232]     ...future.result$conditions <- ...future.conditions
[10:31:47.232]     ...future.result$finished <- base::Sys.time()
[10:31:47.232]     ...future.result
[10:31:47.232] }
[10:31:47.234] assign_globals() ...
[10:31:47.234] List of 5
[10:31:47.234]  $ ...future.FUN            :function (x)  
[10:31:47.234]  $ future.call.arguments    : list()
[10:31:47.234]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:47.234]  $ ...future.elements_ii    :List of 1
[10:31:47.234]   ..$ : int 1
[10:31:47.234]  $ ...future.seeds_ii       : NULL
[10:31:47.234]  $ ...future.globals.maxSize: NULL
[10:31:47.234]  - attr(*, "where")=List of 5
[10:31:47.234]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:47.234]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:47.234]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:47.234]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:47.234]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:47.234]  - attr(*, "resolved")= logi FALSE
[10:31:47.234]  - attr(*, "total_size")= num 4720
[10:31:47.234]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:47.234]  - attr(*, "already-done")= logi TRUE
[10:31:47.239] - reassign environment for ‘...future.FUN’
[10:31:47.239] - copied ‘...future.FUN’ to environment
[10:31:47.239] - copied ‘future.call.arguments’ to environment
[10:31:47.239] - copied ‘...future.elements_ii’ to environment
[10:31:47.239] - copied ‘...future.seeds_ii’ to environment
[10:31:47.239] - copied ‘...future.globals.maxSize’ to environment
[10:31:47.240] assign_globals() ... done
[10:31:47.240] requestCore(): workers = 2
[10:31:47.242] MulticoreFuture started
[10:31:47.242] - Launch lazy future ... done
[10:31:47.243] run() for ‘MulticoreFuture’ ... done
[10:31:47.243] Created future:
[10:31:47.243] plan(): Setting new future strategy stack:
[10:31:47.243] List of future strategies:
[10:31:47.243] 1. sequential:
[10:31:47.243]    - args: function (..., envir = parent.frame())
[10:31:47.243]    - tweaked: FALSE
[10:31:47.243]    - call: NULL
[10:31:47.244] plan(): nbrOfWorkers() = 1
[10:31:47.243] MulticoreFuture:
[10:31:47.243] Label: ‘future_lapply-1’
[10:31:47.243] Expression:
[10:31:47.243] {
[10:31:47.243]     do.call(function(...) {
[10:31:47.243]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:47.243]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:47.243]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:47.243]             on.exit(options(oopts), add = TRUE)
[10:31:47.243]         }
[10:31:47.243]         {
[10:31:47.243]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:47.243]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:47.243]                 ...future.FUN(...future.X_jj, ...)
[10:31:47.243]             })
[10:31:47.243]         }
[10:31:47.243]     }, args = future.call.arguments)
[10:31:47.243] }
[10:31:47.243] Lazy evaluation: FALSE
[10:31:47.243] Asynchronous evaluation: TRUE
[10:31:47.243] Local evaluation: TRUE
[10:31:47.243] Environment: R_GlobalEnv
[10:31:47.243] Capture standard output: NA
[10:31:47.243] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:47.243] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:47.243] Packages: <none>
[10:31:47.243] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:47.243] Resolved: FALSE
[10:31:47.243] Value: <not collected>
[10:31:47.243] Conditions captured: <none>
[10:31:47.243] Early signaling: FALSE
[10:31:47.243] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:47.243] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:47.256] Chunk #1 of 2 ... DONE
[10:31:47.256] Chunk #2 of 2 ...
[10:31:47.256]  - Finding globals in 'X' for chunk #2 ...
[10:31:47.257] getGlobalsAndPackages() ...
[10:31:47.257] Searching for globals...
[10:31:47.257] 
[10:31:47.258] Searching for globals ... DONE
[10:31:47.258] - globals: [0] <none>
[10:31:47.258] getGlobalsAndPackages() ... DONE
[10:31:47.258]    + additional globals found: [n=0] 
[10:31:47.258]    + additional namespaces needed: [n=0] 
[10:31:47.258]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:47.258]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:47.259]  - seeds: <none>
[10:31:47.259]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:47.259] getGlobalsAndPackages() ...
[10:31:47.259] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:47.259] Resolving globals: FALSE
[10:31:47.259] Tweak future expression to call with '...' arguments ...
[10:31:47.260] {
[10:31:47.260]     do.call(function(...) {
[10:31:47.260]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:47.260]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:47.260]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:47.260]             on.exit(options(oopts), add = TRUE)
[10:31:47.260]         }
[10:31:47.260]         {
[10:31:47.260]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:47.260]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:47.260]                 ...future.FUN(...future.X_jj, ...)
[10:31:47.260]             })
[10:31:47.260]         }
[10:31:47.260]     }, args = future.call.arguments)
[10:31:47.260] }
[10:31:47.260] Tweak future expression to call with '...' arguments ... DONE
[10:31:47.261] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:47.261] 
[10:31:47.261] getGlobalsAndPackages() ... DONE
[10:31:47.262] run() for ‘Future’ ...
[10:31:47.262] - state: ‘created’
[10:31:47.262] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:47.267] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:47.268] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:47.268]   - Field: ‘label’
[10:31:47.268]   - Field: ‘local’
[10:31:47.268]   - Field: ‘owner’
[10:31:47.268]   - Field: ‘envir’
[10:31:47.268]   - Field: ‘workers’
[10:31:47.269]   - Field: ‘packages’
[10:31:47.269]   - Field: ‘gc’
[10:31:47.269]   - Field: ‘job’
[10:31:47.269]   - Field: ‘conditions’
[10:31:47.269]   - Field: ‘expr’
[10:31:47.269]   - Field: ‘uuid’
[10:31:47.269]   - Field: ‘seed’
[10:31:47.270]   - Field: ‘version’
[10:31:47.270]   - Field: ‘result’
[10:31:47.270]   - Field: ‘asynchronous’
[10:31:47.270]   - Field: ‘calls’
[10:31:47.274]   - Field: ‘globals’
[10:31:47.274]   - Field: ‘stdout’
[10:31:47.274]   - Field: ‘earlySignal’
[10:31:47.275]   - Field: ‘lazy’
[10:31:47.275]   - Field: ‘state’
[10:31:47.275] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:47.276] - Launch lazy future ...
[10:31:47.276] Packages needed by the future expression (n = 0): <none>
[10:31:47.277] Packages needed by future strategies (n = 0): <none>
[10:31:47.278] {
[10:31:47.278]     {
[10:31:47.278]         {
[10:31:47.278]             ...future.startTime <- base::Sys.time()
[10:31:47.278]             {
[10:31:47.278]                 {
[10:31:47.278]                   {
[10:31:47.278]                     {
[10:31:47.278]                       base::local({
[10:31:47.278]                         has_future <- base::requireNamespace("future", 
[10:31:47.278]                           quietly = TRUE)
[10:31:47.278]                         if (has_future) {
[10:31:47.278]                           ns <- base::getNamespace("future")
[10:31:47.278]                           version <- ns[[".package"]][["version"]]
[10:31:47.278]                           if (is.null(version)) 
[10:31:47.278]                             version <- utils::packageVersion("future")
[10:31:47.278]                         }
[10:31:47.278]                         else {
[10:31:47.278]                           version <- NULL
[10:31:47.278]                         }
[10:31:47.278]                         if (!has_future || version < "1.8.0") {
[10:31:47.278]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:47.278]                             "", base::R.version$version.string), 
[10:31:47.278]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:47.278]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:47.278]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:47.278]                               "release", "version")], collapse = " "), 
[10:31:47.278]                             hostname = base::Sys.info()[["nodename"]])
[10:31:47.278]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:47.278]                             info)
[10:31:47.278]                           info <- base::paste(info, collapse = "; ")
[10:31:47.278]                           if (!has_future) {
[10:31:47.278]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:47.278]                               info)
[10:31:47.278]                           }
[10:31:47.278]                           else {
[10:31:47.278]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:47.278]                               info, version)
[10:31:47.278]                           }
[10:31:47.278]                           base::stop(msg)
[10:31:47.278]                         }
[10:31:47.278]                       })
[10:31:47.278]                     }
[10:31:47.278]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:47.278]                     base::options(mc.cores = 1L)
[10:31:47.278]                   }
[10:31:47.278]                   ...future.strategy.old <- future::plan("list")
[10:31:47.278]                   options(future.plan = NULL)
[10:31:47.278]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:47.278]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:47.278]                 }
[10:31:47.278]                 ...future.workdir <- getwd()
[10:31:47.278]             }
[10:31:47.278]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:47.278]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:47.278]         }
[10:31:47.278]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:47.278]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:47.278]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:47.278]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:47.278]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:47.278]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:47.278]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:47.278]             base::names(...future.oldOptions))
[10:31:47.278]     }
[10:31:47.278]     if (TRUE) {
[10:31:47.278]     }
[10:31:47.278]     else {
[10:31:47.278]         if (NA) {
[10:31:47.278]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:47.278]                 open = "w")
[10:31:47.278]         }
[10:31:47.278]         else {
[10:31:47.278]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:47.278]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:47.278]         }
[10:31:47.278]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:47.278]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:47.278]             base::sink(type = "output", split = FALSE)
[10:31:47.278]             base::close(...future.stdout)
[10:31:47.278]         }, add = TRUE)
[10:31:47.278]     }
[10:31:47.278]     ...future.frame <- base::sys.nframe()
[10:31:47.278]     ...future.conditions <- base::list()
[10:31:47.278]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:47.278]     if (FALSE) {
[10:31:47.278]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:47.278]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:47.278]     }
[10:31:47.278]     ...future.result <- base::tryCatch({
[10:31:47.278]         base::withCallingHandlers({
[10:31:47.278]             ...future.value <- base::withVisible(base::local({
[10:31:47.278]                 withCallingHandlers({
[10:31:47.278]                   {
[10:31:47.278]                     do.call(function(...) {
[10:31:47.278]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:47.278]                       if (!identical(...future.globals.maxSize.org, 
[10:31:47.278]                         ...future.globals.maxSize)) {
[10:31:47.278]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:47.278]                         on.exit(options(oopts), add = TRUE)
[10:31:47.278]                       }
[10:31:47.278]                       {
[10:31:47.278]                         lapply(seq_along(...future.elements_ii), 
[10:31:47.278]                           FUN = function(jj) {
[10:31:47.278]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:47.278]                             ...future.FUN(...future.X_jj, ...)
[10:31:47.278]                           })
[10:31:47.278]                       }
[10:31:47.278]                     }, args = future.call.arguments)
[10:31:47.278]                   }
[10:31:47.278]                 }, immediateCondition = function(cond) {
[10:31:47.278]                   save_rds <- function (object, pathname, ...) 
[10:31:47.278]                   {
[10:31:47.278]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:47.278]                     if (file_test("-f", pathname_tmp)) {
[10:31:47.278]                       fi_tmp <- file.info(pathname_tmp)
[10:31:47.278]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:47.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:47.278]                         fi_tmp[["mtime"]])
[10:31:47.278]                     }
[10:31:47.278]                     tryCatch({
[10:31:47.278]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:47.278]                     }, error = function(ex) {
[10:31:47.278]                       msg <- conditionMessage(ex)
[10:31:47.278]                       fi_tmp <- file.info(pathname_tmp)
[10:31:47.278]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:47.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:47.278]                         fi_tmp[["mtime"]], msg)
[10:31:47.278]                       ex$message <- msg
[10:31:47.278]                       stop(ex)
[10:31:47.278]                     })
[10:31:47.278]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:47.278]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:47.278]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:47.278]                       fi_tmp <- file.info(pathname_tmp)
[10:31:47.278]                       fi <- file.info(pathname)
[10:31:47.278]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:47.278]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:47.278]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:47.278]                         fi[["size"]], fi[["mtime"]])
[10:31:47.278]                       stop(msg)
[10:31:47.278]                     }
[10:31:47.278]                     invisible(pathname)
[10:31:47.278]                   }
[10:31:47.278]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:47.278]                     rootPath = tempdir()) 
[10:31:47.278]                   {
[10:31:47.278]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:47.278]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:47.278]                       tmpdir = path, fileext = ".rds")
[10:31:47.278]                     save_rds(obj, file)
[10:31:47.278]                   }
[10:31:47.278]                   saveImmediateCondition(cond, path = "/tmp/Rtmptsj9Jv/.future/immediateConditions")
[10:31:47.278]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:47.278]                   {
[10:31:47.278]                     inherits <- base::inherits
[10:31:47.278]                     invokeRestart <- base::invokeRestart
[10:31:47.278]                     is.null <- base::is.null
[10:31:47.278]                     muffled <- FALSE
[10:31:47.278]                     if (inherits(cond, "message")) {
[10:31:47.278]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:47.278]                       if (muffled) 
[10:31:47.278]                         invokeRestart("muffleMessage")
[10:31:47.278]                     }
[10:31:47.278]                     else if (inherits(cond, "warning")) {
[10:31:47.278]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:47.278]                       if (muffled) 
[10:31:47.278]                         invokeRestart("muffleWarning")
[10:31:47.278]                     }
[10:31:47.278]                     else if (inherits(cond, "condition")) {
[10:31:47.278]                       if (!is.null(pattern)) {
[10:31:47.278]                         computeRestarts <- base::computeRestarts
[10:31:47.278]                         grepl <- base::grepl
[10:31:47.278]                         restarts <- computeRestarts(cond)
[10:31:47.278]                         for (restart in restarts) {
[10:31:47.278]                           name <- restart$name
[10:31:47.278]                           if (is.null(name)) 
[10:31:47.278]                             next
[10:31:47.278]                           if (!grepl(pattern, name)) 
[10:31:47.278]                             next
[10:31:47.278]                           invokeRestart(restart)
[10:31:47.278]                           muffled <- TRUE
[10:31:47.278]                           break
[10:31:47.278]                         }
[10:31:47.278]                       }
[10:31:47.278]                     }
[10:31:47.278]                     invisible(muffled)
[10:31:47.278]                   }
[10:31:47.278]                   muffleCondition(cond)
[10:31:47.278]                 })
[10:31:47.278]             }))
[10:31:47.278]             future::FutureResult(value = ...future.value$value, 
[10:31:47.278]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:47.278]                   ...future.rng), globalenv = if (FALSE) 
[10:31:47.278]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:47.278]                     ...future.globalenv.names))
[10:31:47.278]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:47.278]         }, condition = base::local({
[10:31:47.278]             c <- base::c
[10:31:47.278]             inherits <- base::inherits
[10:31:47.278]             invokeRestart <- base::invokeRestart
[10:31:47.278]             length <- base::length
[10:31:47.278]             list <- base::list
[10:31:47.278]             seq.int <- base::seq.int
[10:31:47.278]             signalCondition <- base::signalCondition
[10:31:47.278]             sys.calls <- base::sys.calls
[10:31:47.278]             `[[` <- base::`[[`
[10:31:47.278]             `+` <- base::`+`
[10:31:47.278]             `<<-` <- base::`<<-`
[10:31:47.278]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:47.278]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:47.278]                   3L)]
[10:31:47.278]             }
[10:31:47.278]             function(cond) {
[10:31:47.278]                 is_error <- inherits(cond, "error")
[10:31:47.278]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:47.278]                   NULL)
[10:31:47.278]                 if (is_error) {
[10:31:47.278]                   sessionInformation <- function() {
[10:31:47.278]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:47.278]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:47.278]                       search = base::search(), system = base::Sys.info())
[10:31:47.278]                   }
[10:31:47.278]                   ...future.conditions[[length(...future.conditions) + 
[10:31:47.278]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:47.278]                     cond$call), session = sessionInformation(), 
[10:31:47.278]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:47.278]                   signalCondition(cond)
[10:31:47.278]                 }
[10:31:47.278]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:47.278]                 "immediateCondition"))) {
[10:31:47.278]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:47.278]                   ...future.conditions[[length(...future.conditions) + 
[10:31:47.278]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:47.278]                   if (TRUE && !signal) {
[10:31:47.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:47.278]                     {
[10:31:47.278]                       inherits <- base::inherits
[10:31:47.278]                       invokeRestart <- base::invokeRestart
[10:31:47.278]                       is.null <- base::is.null
[10:31:47.278]                       muffled <- FALSE
[10:31:47.278]                       if (inherits(cond, "message")) {
[10:31:47.278]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:47.278]                         if (muffled) 
[10:31:47.278]                           invokeRestart("muffleMessage")
[10:31:47.278]                       }
[10:31:47.278]                       else if (inherits(cond, "warning")) {
[10:31:47.278]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:47.278]                         if (muffled) 
[10:31:47.278]                           invokeRestart("muffleWarning")
[10:31:47.278]                       }
[10:31:47.278]                       else if (inherits(cond, "condition")) {
[10:31:47.278]                         if (!is.null(pattern)) {
[10:31:47.278]                           computeRestarts <- base::computeRestarts
[10:31:47.278]                           grepl <- base::grepl
[10:31:47.278]                           restarts <- computeRestarts(cond)
[10:31:47.278]                           for (restart in restarts) {
[10:31:47.278]                             name <- restart$name
[10:31:47.278]                             if (is.null(name)) 
[10:31:47.278]                               next
[10:31:47.278]                             if (!grepl(pattern, name)) 
[10:31:47.278]                               next
[10:31:47.278]                             invokeRestart(restart)
[10:31:47.278]                             muffled <- TRUE
[10:31:47.278]                             break
[10:31:47.278]                           }
[10:31:47.278]                         }
[10:31:47.278]                       }
[10:31:47.278]                       invisible(muffled)
[10:31:47.278]                     }
[10:31:47.278]                     muffleCondition(cond, pattern = "^muffle")
[10:31:47.278]                   }
[10:31:47.278]                 }
[10:31:47.278]                 else {
[10:31:47.278]                   if (TRUE) {
[10:31:47.278]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:47.278]                     {
[10:31:47.278]                       inherits <- base::inherits
[10:31:47.278]                       invokeRestart <- base::invokeRestart
[10:31:47.278]                       is.null <- base::is.null
[10:31:47.278]                       muffled <- FALSE
[10:31:47.278]                       if (inherits(cond, "message")) {
[10:31:47.278]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:47.278]                         if (muffled) 
[10:31:47.278]                           invokeRestart("muffleMessage")
[10:31:47.278]                       }
[10:31:47.278]                       else if (inherits(cond, "warning")) {
[10:31:47.278]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:47.278]                         if (muffled) 
[10:31:47.278]                           invokeRestart("muffleWarning")
[10:31:47.278]                       }
[10:31:47.278]                       else if (inherits(cond, "condition")) {
[10:31:47.278]                         if (!is.null(pattern)) {
[10:31:47.278]                           computeRestarts <- base::computeRestarts
[10:31:47.278]                           grepl <- base::grepl
[10:31:47.278]                           restarts <- computeRestarts(cond)
[10:31:47.278]                           for (restart in restarts) {
[10:31:47.278]                             name <- restart$name
[10:31:47.278]                             if (is.null(name)) 
[10:31:47.278]                               next
[10:31:47.278]                             if (!grepl(pattern, name)) 
[10:31:47.278]                               next
[10:31:47.278]                             invokeRestart(restart)
[10:31:47.278]                             muffled <- TRUE
[10:31:47.278]                             break
[10:31:47.278]                           }
[10:31:47.278]                         }
[10:31:47.278]                       }
[10:31:47.278]                       invisible(muffled)
[10:31:47.278]                     }
[10:31:47.278]                     muffleCondition(cond, pattern = "^muffle")
[10:31:47.278]                   }
[10:31:47.278]                 }
[10:31:47.278]             }
[10:31:47.278]         }))
[10:31:47.278]     }, error = function(ex) {
[10:31:47.278]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:47.278]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:47.278]                 ...future.rng), started = ...future.startTime, 
[10:31:47.278]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:47.278]             version = "1.8"), class = "FutureResult")
[10:31:47.278]     }, finally = {
[10:31:47.278]         if (!identical(...future.workdir, getwd())) 
[10:31:47.278]             setwd(...future.workdir)
[10:31:47.278]         {
[10:31:47.278]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:47.278]                 ...future.oldOptions$nwarnings <- NULL
[10:31:47.278]             }
[10:31:47.278]             base::options(...future.oldOptions)
[10:31:47.278]             if (.Platform$OS.type == "windows") {
[10:31:47.278]                 old_names <- names(...future.oldEnvVars)
[10:31:47.278]                 envs <- base::Sys.getenv()
[10:31:47.278]                 names <- names(envs)
[10:31:47.278]                 common <- intersect(names, old_names)
[10:31:47.278]                 added <- setdiff(names, old_names)
[10:31:47.278]                 removed <- setdiff(old_names, names)
[10:31:47.278]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:47.278]                   envs[common]]
[10:31:47.278]                 NAMES <- toupper(changed)
[10:31:47.278]                 args <- list()
[10:31:47.278]                 for (kk in seq_along(NAMES)) {
[10:31:47.278]                   name <- changed[[kk]]
[10:31:47.278]                   NAME <- NAMES[[kk]]
[10:31:47.278]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:47.278]                     next
[10:31:47.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:47.278]                 }
[10:31:47.278]                 NAMES <- toupper(added)
[10:31:47.278]                 for (kk in seq_along(NAMES)) {
[10:31:47.278]                   name <- added[[kk]]
[10:31:47.278]                   NAME <- NAMES[[kk]]
[10:31:47.278]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:47.278]                     next
[10:31:47.278]                   args[[name]] <- ""
[10:31:47.278]                 }
[10:31:47.278]                 NAMES <- toupper(removed)
[10:31:47.278]                 for (kk in seq_along(NAMES)) {
[10:31:47.278]                   name <- removed[[kk]]
[10:31:47.278]                   NAME <- NAMES[[kk]]
[10:31:47.278]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:47.278]                     next
[10:31:47.278]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:47.278]                 }
[10:31:47.278]                 if (length(args) > 0) 
[10:31:47.278]                   base::do.call(base::Sys.setenv, args = args)
[10:31:47.278]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:47.278]             }
[10:31:47.278]             else {
[10:31:47.278]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:47.278]             }
[10:31:47.278]             {
[10:31:47.278]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:47.278]                   0L) {
[10:31:47.278]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:47.278]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:47.278]                   base::options(opts)
[10:31:47.278]                 }
[10:31:47.278]                 {
[10:31:47.278]                   {
[10:31:47.278]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:47.278]                     NULL
[10:31:47.278]                   }
[10:31:47.278]                   options(future.plan = NULL)
[10:31:47.278]                   if (is.na(NA_character_)) 
[10:31:47.278]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:47.278]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:47.278]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:47.278]                     .init = FALSE)
[10:31:47.278]                 }
[10:31:47.278]             }
[10:31:47.278]         }
[10:31:47.278]     })
[10:31:47.278]     if (FALSE) {
[10:31:47.278]         base::sink(type = "output", split = FALSE)
[10:31:47.278]         if (NA) {
[10:31:47.278]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:47.278]         }
[10:31:47.278]         else {
[10:31:47.278]             ...future.result["stdout"] <- base::list(NULL)
[10:31:47.278]         }
[10:31:47.278]         base::close(...future.stdout)
[10:31:47.278]         ...future.stdout <- NULL
[10:31:47.278]     }
[10:31:47.278]     ...future.result$conditions <- ...future.conditions
[10:31:47.278]     ...future.result$finished <- base::Sys.time()
[10:31:47.278]     ...future.result
[10:31:47.278] }
[10:31:47.281] assign_globals() ...
[10:31:47.281] List of 5
[10:31:47.281]  $ ...future.FUN            :function (x)  
[10:31:47.281]  $ future.call.arguments    : list()
[10:31:47.281]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:47.281]  $ ...future.elements_ii    :List of 1
[10:31:47.281]   ..$ : int 0
[10:31:47.281]  $ ...future.seeds_ii       : NULL
[10:31:47.281]  $ ...future.globals.maxSize: NULL
[10:31:47.281]  - attr(*, "where")=List of 5
[10:31:47.281]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:47.281]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:47.281]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:47.281]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:47.281]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:47.281]  - attr(*, "resolved")= logi FALSE
[10:31:47.281]  - attr(*, "total_size")= num 4720
[10:31:47.281]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:47.281]  - attr(*, "already-done")= logi TRUE
[10:31:47.289] - reassign environment for ‘...future.FUN’
[10:31:47.289] - copied ‘...future.FUN’ to environment
[10:31:47.289] - copied ‘future.call.arguments’ to environment
[10:31:47.290] - copied ‘...future.elements_ii’ to environment
[10:31:47.290] - copied ‘...future.seeds_ii’ to environment
[10:31:47.290] - copied ‘...future.globals.maxSize’ to environment
[10:31:47.290] assign_globals() ... done
[10:31:47.290] requestCore(): workers = 2
[10:31:47.293] MulticoreFuture started
[10:31:47.293] - Launch lazy future ... done
[10:31:47.293] run() for ‘MulticoreFuture’ ... done
[10:31:47.293] Created future:
[10:31:47.294] plan(): Setting new future strategy stack:
[10:31:47.294] List of future strategies:
[10:31:47.294] 1. sequential:
[10:31:47.294]    - args: function (..., envir = parent.frame())
[10:31:47.294]    - tweaked: FALSE
[10:31:47.294]    - call: NULL
[10:31:47.295] plan(): nbrOfWorkers() = 1
[10:31:47.297] plan(): Setting new future strategy stack:
[10:31:47.297] List of future strategies:
[10:31:47.297] 1. multicore:
[10:31:47.297]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:47.297]    - tweaked: FALSE
[10:31:47.297]    - call: plan(strategy)
[10:31:47.302] plan(): nbrOfWorkers() = 2
[10:31:47.294] MulticoreFuture:
[10:31:47.294] Label: ‘future_lapply-2’
[10:31:47.294] Expression:
[10:31:47.294] {
[10:31:47.294]     do.call(function(...) {
[10:31:47.294]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:47.294]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:47.294]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:47.294]             on.exit(options(oopts), add = TRUE)
[10:31:47.294]         }
[10:31:47.294]         {
[10:31:47.294]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:47.294]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:47.294]                 ...future.FUN(...future.X_jj, ...)
[10:31:47.294]             })
[10:31:47.294]         }
[10:31:47.294]     }, args = future.call.arguments)
[10:31:47.294] }
[10:31:47.294] Lazy evaluation: FALSE
[10:31:47.294] Asynchronous evaluation: TRUE
[10:31:47.294] Local evaluation: TRUE
[10:31:47.294] Environment: R_GlobalEnv
[10:31:47.294] Capture standard output: NA
[10:31:47.294] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:47.294] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:47.294] Packages: <none>
[10:31:47.294] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:47.294] Resolved: TRUE
[10:31:47.294] Value: <not collected>
[10:31:47.294] Conditions captured: <none>
[10:31:47.294] Early signaling: FALSE
[10:31:47.294] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:47.294] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:47.304] Chunk #2 of 2 ... DONE
[10:31:47.304] Launching 2 futures (chunks) ... DONE
[10:31:47.304] Resolving 2 futures (chunks) ...
[10:31:47.304] resolve() on list ...
[10:31:47.304]  recursive: 0
[10:31:47.304]  length: 2
[10:31:47.304] 
[10:31:47.315] Future #2
[10:31:47.315] result() for MulticoreFuture ...
[10:31:47.316] result() for MulticoreFuture ...
[10:31:47.316] result() for MulticoreFuture ... done
[10:31:47.317] result() for MulticoreFuture ... done
[10:31:47.317] result() for MulticoreFuture ...
[10:31:47.317] result() for MulticoreFuture ... done
[10:31:47.317] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:47.317] - nx: 2
[10:31:47.317] - relay: TRUE
[10:31:47.318] - stdout: TRUE
[10:31:47.318] - signal: TRUE
[10:31:47.318] - resignal: FALSE
[10:31:47.318] - force: TRUE
[10:31:47.318] - relayed: [n=2] FALSE, FALSE
[10:31:47.318] - queued futures: [n=2] FALSE, FALSE
[10:31:47.319]  - until=1
[10:31:47.319]  - relaying element #1
[10:31:47.319] - relayed: [n=2] FALSE, FALSE
[10:31:47.319] - queued futures: [n=2] FALSE, TRUE
[10:31:47.319] signalConditionsASAP(NULL, pos=2) ... done
[10:31:47.319]  length: 1 (resolved future 2)
[10:31:47.747] plan(): Setting new future strategy stack:
[10:31:47.747] List of future strategies:
[10:31:47.747] 1. multicore:
[10:31:47.747]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:47.747]    - tweaked: FALSE
[10:31:47.747]    - call: plan(strategy)
[10:31:47.752] plan(): nbrOfWorkers() = 2
[10:31:47.759] Future #1
[10:31:47.760] result() for MulticoreFuture ...
[10:31:47.760] result() for MulticoreFuture ...
[10:31:47.760] result() for MulticoreFuture ... done
[10:31:47.761] result() for MulticoreFuture ... done
[10:31:47.761] result() for MulticoreFuture ...
[10:31:47.761] result() for MulticoreFuture ... done
[10:31:47.761] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:47.761] - nx: 2
[10:31:47.761] - relay: TRUE
[10:31:47.761] - stdout: TRUE
[10:31:47.761] - signal: TRUE
[10:31:47.762] - resignal: FALSE
[10:31:47.762] - force: TRUE
[10:31:47.762] - relayed: [n=2] FALSE, FALSE
[10:31:47.762] - queued futures: [n=2] FALSE, TRUE
[10:31:47.762]  - until=1
[10:31:47.762]  - relaying element #1
[10:31:47.762] result() for MulticoreFuture ...
[10:31:47.762] result() for MulticoreFuture ... done
[10:31:47.762] result() for MulticoreFuture ...
[10:31:47.763] result() for MulticoreFuture ... done
[10:31:47.763] result() for MulticoreFuture ...
[10:31:47.763] result() for MulticoreFuture ... done
[10:31:47.763] result() for MulticoreFuture ...
[10:31:47.763] result() for MulticoreFuture ... done
[10:31:47.763] - relayed: [n=2] TRUE, FALSE
[10:31:47.763] - queued futures: [n=2] TRUE, TRUE
[10:31:47.763] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:47.764]  length: 0 (resolved future 1)
[10:31:47.764] Relaying remaining futures
[10:31:47.764] signalConditionsASAP(NULL, pos=0) ...
[10:31:47.764] - nx: 2
[10:31:47.764] - relay: TRUE
[10:31:47.764] - stdout: TRUE
[10:31:47.764] - signal: TRUE
[10:31:47.764] - resignal: FALSE
[10:31:47.765] - force: TRUE
[10:31:47.765] - relayed: [n=2] TRUE, FALSE
[10:31:47.765] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:47.765]  - relaying element #2
[10:31:47.765] result() for MulticoreFuture ...
[10:31:47.765] result() for MulticoreFuture ... done
[10:31:47.765] result() for MulticoreFuture ...
[10:31:47.765] result() for MulticoreFuture ... done
[10:31:47.766] result() for MulticoreFuture ...
[10:31:47.766] result() for MulticoreFuture ... done
[10:31:47.766] result() for MulticoreFuture ...
[10:31:47.766] result() for MulticoreFuture ... done
[10:31:47.766] - relayed: [n=2] TRUE, TRUE
[10:31:47.766] - queued futures: [n=2] TRUE, TRUE
[10:31:47.766] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:31:47.766] resolve() on list ... DONE
[10:31:47.767] result() for MulticoreFuture ...
[10:31:47.767] result() for MulticoreFuture ... done
[10:31:47.767] result() for MulticoreFuture ...
[10:31:47.767] result() for MulticoreFuture ... done
[10:31:47.767] result() for MulticoreFuture ...
[10:31:47.767] result() for MulticoreFuture ... done
[10:31:47.767] result() for MulticoreFuture ...
[10:31:47.767] result() for MulticoreFuture ... done
[10:31:47.768]  - Number of value chunks collected: 2
[10:31:47.768] Resolving 2 futures (chunks) ... DONE
[10:31:47.768] Reducing values from 2 chunks ...
[10:31:47.768]  - Number of values collected after concatenation: 2
[10:31:47.770]  - Number of values expected: 2
[10:31:47.770] Reducing values from 2 chunks ... DONE
[10:31:47.771] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:31:47.771] future_mapply() ...
[10:31:47.776] Number of chunks: 2
[10:31:47.776] getGlobalsAndPackagesXApply() ...
[10:31:47.776]  - future.globals: TRUE
[10:31:47.777] getGlobalsAndPackages() ...
[10:31:47.777] Searching for globals...
[10:31:47.779] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:47.779] Searching for globals ... DONE
[10:31:47.779] Resolving globals: FALSE
[10:31:47.780] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:47.780] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:47.781] - globals: [1] ‘FUN’
[10:31:47.781] 
[10:31:47.781] getGlobalsAndPackages() ... DONE
[10:31:47.781]  - globals found/used: [n=1] ‘FUN’
[10:31:47.781]  - needed namespaces: [n=0] 
[10:31:47.781] Finding globals ... DONE
[10:31:47.781] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:47.782] List of 2
[10:31:47.782]  $ ...future.FUN:function (x, y)  
[10:31:47.782]  $ MoreArgs     : NULL
[10:31:47.782]  - attr(*, "where")=List of 2
[10:31:47.782]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:47.782]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:47.782]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:47.782]  - attr(*, "resolved")= logi FALSE
[10:31:47.782]  - attr(*, "total_size")= num NA
[10:31:47.785] Packages to be attached in all futures: [n=0] 
[10:31:47.785] getGlobalsAndPackagesXApply() ... DONE
[10:31:47.785] Number of futures (= number of chunks): 2
[10:31:47.785] Launching 2 futures (chunks) ...
[10:31:47.785] Chunk #1 of 2 ...
[10:31:47.785]  - Finding globals in '...' for chunk #1 ...
[10:31:47.785] getGlobalsAndPackages() ...
[10:31:47.785] Searching for globals...
[10:31:47.786] 
[10:31:47.786] Searching for globals ... DONE
[10:31:47.786] - globals: [0] <none>
[10:31:47.786] getGlobalsAndPackages() ... DONE
[10:31:47.786]    + additional globals found: [n=0] 
[10:31:47.786]    + additional namespaces needed: [n=0] 
[10:31:47.786]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:47.786]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:47.787]  - seeds: <none>
[10:31:47.787]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:47.787] getGlobalsAndPackages() ...
[10:31:47.787] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:47.787] Resolving globals: FALSE
[10:31:47.787] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:31:47.788] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:47.788] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:47.788] 
[10:31:47.788] getGlobalsAndPackages() ... DONE
[10:31:47.789] run() for ‘Future’ ...
[10:31:47.789] - state: ‘created’
[10:31:47.789] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:47.793] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:47.793] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:47.793]   - Field: ‘label’
[10:31:47.793]   - Field: ‘local’
[10:31:47.794]   - Field: ‘owner’
[10:31:47.794]   - Field: ‘envir’
[10:31:47.794]   - Field: ‘workers’
[10:31:47.794]   - Field: ‘packages’
[10:31:47.794]   - Field: ‘gc’
[10:31:47.794]   - Field: ‘job’
[10:31:47.794]   - Field: ‘conditions’
[10:31:47.794]   - Field: ‘expr’
[10:31:47.795]   - Field: ‘uuid’
[10:31:47.795]   - Field: ‘seed’
[10:31:47.795]   - Field: ‘version’
[10:31:47.795]   - Field: ‘result’
[10:31:47.795]   - Field: ‘asynchronous’
[10:31:47.795]   - Field: ‘calls’
[10:31:47.795]   - Field: ‘globals’
[10:31:47.795]   - Field: ‘stdout’
[10:31:47.795]   - Field: ‘earlySignal’
[10:31:47.795]   - Field: ‘lazy’
[10:31:47.795]   - Field: ‘state’
[10:31:47.796] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:47.796] - Launch lazy future ...
[10:31:47.796] Packages needed by the future expression (n = 0): <none>
[10:31:47.796] Packages needed by future strategies (n = 0): <none>
[10:31:47.797] {
[10:31:47.797]     {
[10:31:47.797]         {
[10:31:47.797]             ...future.startTime <- base::Sys.time()
[10:31:47.797]             {
[10:31:47.797]                 {
[10:31:47.797]                   {
[10:31:47.797]                     {
[10:31:47.797]                       base::local({
[10:31:47.797]                         has_future <- base::requireNamespace("future", 
[10:31:47.797]                           quietly = TRUE)
[10:31:47.797]                         if (has_future) {
[10:31:47.797]                           ns <- base::getNamespace("future")
[10:31:47.797]                           version <- ns[[".package"]][["version"]]
[10:31:47.797]                           if (is.null(version)) 
[10:31:47.797]                             version <- utils::packageVersion("future")
[10:31:47.797]                         }
[10:31:47.797]                         else {
[10:31:47.797]                           version <- NULL
[10:31:47.797]                         }
[10:31:47.797]                         if (!has_future || version < "1.8.0") {
[10:31:47.797]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:47.797]                             "", base::R.version$version.string), 
[10:31:47.797]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:47.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:47.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:47.797]                               "release", "version")], collapse = " "), 
[10:31:47.797]                             hostname = base::Sys.info()[["nodename"]])
[10:31:47.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:47.797]                             info)
[10:31:47.797]                           info <- base::paste(info, collapse = "; ")
[10:31:47.797]                           if (!has_future) {
[10:31:47.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:47.797]                               info)
[10:31:47.797]                           }
[10:31:47.797]                           else {
[10:31:47.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:47.797]                               info, version)
[10:31:47.797]                           }
[10:31:47.797]                           base::stop(msg)
[10:31:47.797]                         }
[10:31:47.797]                       })
[10:31:47.797]                     }
[10:31:47.797]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:47.797]                     base::options(mc.cores = 1L)
[10:31:47.797]                   }
[10:31:47.797]                   ...future.strategy.old <- future::plan("list")
[10:31:47.797]                   options(future.plan = NULL)
[10:31:47.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:47.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:47.797]                 }
[10:31:47.797]                 ...future.workdir <- getwd()
[10:31:47.797]             }
[10:31:47.797]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:47.797]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:47.797]         }
[10:31:47.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:47.797]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:47.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:47.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:47.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:47.797]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:47.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:47.797]             base::names(...future.oldOptions))
[10:31:47.797]     }
[10:31:47.797]     if (FALSE) {
[10:31:47.797]     }
[10:31:47.797]     else {
[10:31:47.797]         if (FALSE) {
[10:31:47.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:47.797]                 open = "w")
[10:31:47.797]         }
[10:31:47.797]         else {
[10:31:47.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:47.797]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:47.797]         }
[10:31:47.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:47.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:47.797]             base::sink(type = "output", split = FALSE)
[10:31:47.797]             base::close(...future.stdout)
[10:31:47.797]         }, add = TRUE)
[10:31:47.797]     }
[10:31:47.797]     ...future.frame <- base::sys.nframe()
[10:31:47.797]     ...future.conditions <- base::list()
[10:31:47.797]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:47.797]     if (FALSE) {
[10:31:47.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:47.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:47.797]     }
[10:31:47.797]     ...future.result <- base::tryCatch({
[10:31:47.797]         base::withCallingHandlers({
[10:31:47.797]             ...future.value <- base::withVisible(base::local({
[10:31:47.797]                 withCallingHandlers({
[10:31:47.797]                   {
[10:31:47.797]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:47.797]                     if (!identical(...future.globals.maxSize.org, 
[10:31:47.797]                       ...future.globals.maxSize)) {
[10:31:47.797]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:47.797]                       on.exit(options(oopts), add = TRUE)
[10:31:47.797]                     }
[10:31:47.797]                     {
[10:31:47.797]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:47.797]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:47.797]                         USE.NAMES = FALSE)
[10:31:47.797]                       do.call(mapply, args = args)
[10:31:47.797]                     }
[10:31:47.797]                   }
[10:31:47.797]                 }, immediateCondition = function(cond) {
[10:31:47.797]                   save_rds <- function (object, pathname, ...) 
[10:31:47.797]                   {
[10:31:47.797]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:47.797]                     if (file_test("-f", pathname_tmp)) {
[10:31:47.797]                       fi_tmp <- file.info(pathname_tmp)
[10:31:47.797]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:47.797]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:47.797]                         fi_tmp[["mtime"]])
[10:31:47.797]                     }
[10:31:47.797]                     tryCatch({
[10:31:47.797]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:47.797]                     }, error = function(ex) {
[10:31:47.797]                       msg <- conditionMessage(ex)
[10:31:47.797]                       fi_tmp <- file.info(pathname_tmp)
[10:31:47.797]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:47.797]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:47.797]                         fi_tmp[["mtime"]], msg)
[10:31:47.797]                       ex$message <- msg
[10:31:47.797]                       stop(ex)
[10:31:47.797]                     })
[10:31:47.797]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:47.797]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:47.797]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:47.797]                       fi_tmp <- file.info(pathname_tmp)
[10:31:47.797]                       fi <- file.info(pathname)
[10:31:47.797]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:47.797]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:47.797]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:47.797]                         fi[["size"]], fi[["mtime"]])
[10:31:47.797]                       stop(msg)
[10:31:47.797]                     }
[10:31:47.797]                     invisible(pathname)
[10:31:47.797]                   }
[10:31:47.797]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:47.797]                     rootPath = tempdir()) 
[10:31:47.797]                   {
[10:31:47.797]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:47.797]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:47.797]                       tmpdir = path, fileext = ".rds")
[10:31:47.797]                     save_rds(obj, file)
[10:31:47.797]                   }
[10:31:47.797]                   saveImmediateCondition(cond, path = "/tmp/Rtmptsj9Jv/.future/immediateConditions")
[10:31:47.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:47.797]                   {
[10:31:47.797]                     inherits <- base::inherits
[10:31:47.797]                     invokeRestart <- base::invokeRestart
[10:31:47.797]                     is.null <- base::is.null
[10:31:47.797]                     muffled <- FALSE
[10:31:47.797]                     if (inherits(cond, "message")) {
[10:31:47.797]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:47.797]                       if (muffled) 
[10:31:47.797]                         invokeRestart("muffleMessage")
[10:31:47.797]                     }
[10:31:47.797]                     else if (inherits(cond, "warning")) {
[10:31:47.797]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:47.797]                       if (muffled) 
[10:31:47.797]                         invokeRestart("muffleWarning")
[10:31:47.797]                     }
[10:31:47.797]                     else if (inherits(cond, "condition")) {
[10:31:47.797]                       if (!is.null(pattern)) {
[10:31:47.797]                         computeRestarts <- base::computeRestarts
[10:31:47.797]                         grepl <- base::grepl
[10:31:47.797]                         restarts <- computeRestarts(cond)
[10:31:47.797]                         for (restart in restarts) {
[10:31:47.797]                           name <- restart$name
[10:31:47.797]                           if (is.null(name)) 
[10:31:47.797]                             next
[10:31:47.797]                           if (!grepl(pattern, name)) 
[10:31:47.797]                             next
[10:31:47.797]                           invokeRestart(restart)
[10:31:47.797]                           muffled <- TRUE
[10:31:47.797]                           break
[10:31:47.797]                         }
[10:31:47.797]                       }
[10:31:47.797]                     }
[10:31:47.797]                     invisible(muffled)
[10:31:47.797]                   }
[10:31:47.797]                   muffleCondition(cond)
[10:31:47.797]                 })
[10:31:47.797]             }))
[10:31:47.797]             future::FutureResult(value = ...future.value$value, 
[10:31:47.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:47.797]                   ...future.rng), globalenv = if (FALSE) 
[10:31:47.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:47.797]                     ...future.globalenv.names))
[10:31:47.797]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:47.797]         }, condition = base::local({
[10:31:47.797]             c <- base::c
[10:31:47.797]             inherits <- base::inherits
[10:31:47.797]             invokeRestart <- base::invokeRestart
[10:31:47.797]             length <- base::length
[10:31:47.797]             list <- base::list
[10:31:47.797]             seq.int <- base::seq.int
[10:31:47.797]             signalCondition <- base::signalCondition
[10:31:47.797]             sys.calls <- base::sys.calls
[10:31:47.797]             `[[` <- base::`[[`
[10:31:47.797]             `+` <- base::`+`
[10:31:47.797]             `<<-` <- base::`<<-`
[10:31:47.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:47.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:47.797]                   3L)]
[10:31:47.797]             }
[10:31:47.797]             function(cond) {
[10:31:47.797]                 is_error <- inherits(cond, "error")
[10:31:47.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:47.797]                   NULL)
[10:31:47.797]                 if (is_error) {
[10:31:47.797]                   sessionInformation <- function() {
[10:31:47.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:47.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:47.797]                       search = base::search(), system = base::Sys.info())
[10:31:47.797]                   }
[10:31:47.797]                   ...future.conditions[[length(...future.conditions) + 
[10:31:47.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:47.797]                     cond$call), session = sessionInformation(), 
[10:31:47.797]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:47.797]                   signalCondition(cond)
[10:31:47.797]                 }
[10:31:47.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:47.797]                 "immediateCondition"))) {
[10:31:47.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:47.797]                   ...future.conditions[[length(...future.conditions) + 
[10:31:47.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:47.797]                   if (TRUE && !signal) {
[10:31:47.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:47.797]                     {
[10:31:47.797]                       inherits <- base::inherits
[10:31:47.797]                       invokeRestart <- base::invokeRestart
[10:31:47.797]                       is.null <- base::is.null
[10:31:47.797]                       muffled <- FALSE
[10:31:47.797]                       if (inherits(cond, "message")) {
[10:31:47.797]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:47.797]                         if (muffled) 
[10:31:47.797]                           invokeRestart("muffleMessage")
[10:31:47.797]                       }
[10:31:47.797]                       else if (inherits(cond, "warning")) {
[10:31:47.797]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:47.797]                         if (muffled) 
[10:31:47.797]                           invokeRestart("muffleWarning")
[10:31:47.797]                       }
[10:31:47.797]                       else if (inherits(cond, "condition")) {
[10:31:47.797]                         if (!is.null(pattern)) {
[10:31:47.797]                           computeRestarts <- base::computeRestarts
[10:31:47.797]                           grepl <- base::grepl
[10:31:47.797]                           restarts <- computeRestarts(cond)
[10:31:47.797]                           for (restart in restarts) {
[10:31:47.797]                             name <- restart$name
[10:31:47.797]                             if (is.null(name)) 
[10:31:47.797]                               next
[10:31:47.797]                             if (!grepl(pattern, name)) 
[10:31:47.797]                               next
[10:31:47.797]                             invokeRestart(restart)
[10:31:47.797]                             muffled <- TRUE
[10:31:47.797]                             break
[10:31:47.797]                           }
[10:31:47.797]                         }
[10:31:47.797]                       }
[10:31:47.797]                       invisible(muffled)
[10:31:47.797]                     }
[10:31:47.797]                     muffleCondition(cond, pattern = "^muffle")
[10:31:47.797]                   }
[10:31:47.797]                 }
[10:31:47.797]                 else {
[10:31:47.797]                   if (TRUE) {
[10:31:47.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:47.797]                     {
[10:31:47.797]                       inherits <- base::inherits
[10:31:47.797]                       invokeRestart <- base::invokeRestart
[10:31:47.797]                       is.null <- base::is.null
[10:31:47.797]                       muffled <- FALSE
[10:31:47.797]                       if (inherits(cond, "message")) {
[10:31:47.797]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:47.797]                         if (muffled) 
[10:31:47.797]                           invokeRestart("muffleMessage")
[10:31:47.797]                       }
[10:31:47.797]                       else if (inherits(cond, "warning")) {
[10:31:47.797]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:47.797]                         if (muffled) 
[10:31:47.797]                           invokeRestart("muffleWarning")
[10:31:47.797]                       }
[10:31:47.797]                       else if (inherits(cond, "condition")) {
[10:31:47.797]                         if (!is.null(pattern)) {
[10:31:47.797]                           computeRestarts <- base::computeRestarts
[10:31:47.797]                           grepl <- base::grepl
[10:31:47.797]                           restarts <- computeRestarts(cond)
[10:31:47.797]                           for (restart in restarts) {
[10:31:47.797]                             name <- restart$name
[10:31:47.797]                             if (is.null(name)) 
[10:31:47.797]                               next
[10:31:47.797]                             if (!grepl(pattern, name)) 
[10:31:47.797]                               next
[10:31:47.797]                             invokeRestart(restart)
[10:31:47.797]                             muffled <- TRUE
[10:31:47.797]                             break
[10:31:47.797]                           }
[10:31:47.797]                         }
[10:31:47.797]                       }
[10:31:47.797]                       invisible(muffled)
[10:31:47.797]                     }
[10:31:47.797]                     muffleCondition(cond, pattern = "^muffle")
[10:31:47.797]                   }
[10:31:47.797]                 }
[10:31:47.797]             }
[10:31:47.797]         }))
[10:31:47.797]     }, error = function(ex) {
[10:31:47.797]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:47.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:47.797]                 ...future.rng), started = ...future.startTime, 
[10:31:47.797]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:47.797]             version = "1.8"), class = "FutureResult")
[10:31:47.797]     }, finally = {
[10:31:47.797]         if (!identical(...future.workdir, getwd())) 
[10:31:47.797]             setwd(...future.workdir)
[10:31:47.797]         {
[10:31:47.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:47.797]                 ...future.oldOptions$nwarnings <- NULL
[10:31:47.797]             }
[10:31:47.797]             base::options(...future.oldOptions)
[10:31:47.797]             if (.Platform$OS.type == "windows") {
[10:31:47.797]                 old_names <- names(...future.oldEnvVars)
[10:31:47.797]                 envs <- base::Sys.getenv()
[10:31:47.797]                 names <- names(envs)
[10:31:47.797]                 common <- intersect(names, old_names)
[10:31:47.797]                 added <- setdiff(names, old_names)
[10:31:47.797]                 removed <- setdiff(old_names, names)
[10:31:47.797]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:47.797]                   envs[common]]
[10:31:47.797]                 NAMES <- toupper(changed)
[10:31:47.797]                 args <- list()
[10:31:47.797]                 for (kk in seq_along(NAMES)) {
[10:31:47.797]                   name <- changed[[kk]]
[10:31:47.797]                   NAME <- NAMES[[kk]]
[10:31:47.797]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:47.797]                     next
[10:31:47.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:47.797]                 }
[10:31:47.797]                 NAMES <- toupper(added)
[10:31:47.797]                 for (kk in seq_along(NAMES)) {
[10:31:47.797]                   name <- added[[kk]]
[10:31:47.797]                   NAME <- NAMES[[kk]]
[10:31:47.797]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:47.797]                     next
[10:31:47.797]                   args[[name]] <- ""
[10:31:47.797]                 }
[10:31:47.797]                 NAMES <- toupper(removed)
[10:31:47.797]                 for (kk in seq_along(NAMES)) {
[10:31:47.797]                   name <- removed[[kk]]
[10:31:47.797]                   NAME <- NAMES[[kk]]
[10:31:47.797]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:47.797]                     next
[10:31:47.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:47.797]                 }
[10:31:47.797]                 if (length(args) > 0) 
[10:31:47.797]                   base::do.call(base::Sys.setenv, args = args)
[10:31:47.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:47.797]             }
[10:31:47.797]             else {
[10:31:47.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:47.797]             }
[10:31:47.797]             {
[10:31:47.797]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:47.797]                   0L) {
[10:31:47.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:47.797]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:47.797]                   base::options(opts)
[10:31:47.797]                 }
[10:31:47.797]                 {
[10:31:47.797]                   {
[10:31:47.797]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:47.797]                     NULL
[10:31:47.797]                   }
[10:31:47.797]                   options(future.plan = NULL)
[10:31:47.797]                   if (is.na(NA_character_)) 
[10:31:47.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:47.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:47.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:47.797]                     .init = FALSE)
[10:31:47.797]                 }
[10:31:47.797]             }
[10:31:47.797]         }
[10:31:47.797]     })
[10:31:47.797]     if (TRUE) {
[10:31:47.797]         base::sink(type = "output", split = FALSE)
[10:31:47.797]         if (FALSE) {
[10:31:47.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:47.797]         }
[10:31:47.797]         else {
[10:31:47.797]             ...future.result["stdout"] <- base::list(NULL)
[10:31:47.797]         }
[10:31:47.797]         base::close(...future.stdout)
[10:31:47.797]         ...future.stdout <- NULL
[10:31:47.797]     }
[10:31:47.797]     ...future.result$conditions <- ...future.conditions
[10:31:47.797]     ...future.result$finished <- base::Sys.time()
[10:31:47.797]     ...future.result
[10:31:47.797] }
[10:31:47.799] assign_globals() ...
[10:31:47.799] List of 5
[10:31:47.799]  $ ...future.FUN            :function (x, y)  
[10:31:47.799]  $ MoreArgs                 : NULL
[10:31:47.799]  $ ...future.elements_ii    :List of 2
[10:31:47.799]   ..$ :List of 1
[10:31:47.799]   .. ..$ : int 1
[10:31:47.799]   ..$ :List of 1
[10:31:47.799]   .. ..$ : int 0
[10:31:47.799]  $ ...future.seeds_ii       : NULL
[10:31:47.799]  $ ...future.globals.maxSize: NULL
[10:31:47.799]  - attr(*, "where")=List of 5
[10:31:47.799]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:47.799]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:47.799]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:47.799]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:47.799]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:47.799]  - attr(*, "resolved")= logi FALSE
[10:31:47.799]  - attr(*, "total_size")= num 6368
[10:31:47.799]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:47.799]  - attr(*, "already-done")= logi TRUE
[10:31:47.807] - reassign environment for ‘...future.FUN’
[10:31:47.807] - copied ‘...future.FUN’ to environment
[10:31:47.807] - copied ‘MoreArgs’ to environment
[10:31:47.807] - copied ‘...future.elements_ii’ to environment
[10:31:47.807] - copied ‘...future.seeds_ii’ to environment
[10:31:47.807] - copied ‘...future.globals.maxSize’ to environment
[10:31:47.807] assign_globals() ... done
[10:31:47.808] requestCore(): workers = 2
[10:31:47.810] MulticoreFuture started
[10:31:47.811] - Launch lazy future ... done
[10:31:47.811] run() for ‘MulticoreFuture’ ... done
[10:31:47.811] Created future:
[10:31:47.811] plan(): Setting new future strategy stack:
[10:31:47.812] List of future strategies:
[10:31:47.812] 1. sequential:
[10:31:47.812]    - args: function (..., envir = parent.frame())
[10:31:47.812]    - tweaked: FALSE
[10:31:47.812]    - call: NULL
[10:31:47.813] plan(): nbrOfWorkers() = 1
[10:31:47.812] MulticoreFuture:
[10:31:47.812] Label: ‘future_mapply-1’
[10:31:47.812] Expression:
[10:31:47.812] {
[10:31:47.812]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:47.812]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:47.812]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:47.812]         on.exit(options(oopts), add = TRUE)
[10:31:47.812]     }
[10:31:47.812]     {
[10:31:47.812]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:47.812]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:47.812]         do.call(mapply, args = args)
[10:31:47.812]     }
[10:31:47.812] }
[10:31:47.812] Lazy evaluation: FALSE
[10:31:47.812] Asynchronous evaluation: TRUE
[10:31:47.812] Local evaluation: TRUE
[10:31:47.812] Environment: R_GlobalEnv
[10:31:47.812] Capture standard output: FALSE
[10:31:47.812] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:47.812] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:47.812] Packages: <none>
[10:31:47.812] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:47.812] Resolved: FALSE
[10:31:47.812] Value: <not collected>
[10:31:47.812] Conditions captured: <none>
[10:31:47.812] Early signaling: FALSE
[10:31:47.812] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:47.812] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:47.825] Chunk #1 of 2 ... DONE
[10:31:47.825] Chunk #2 of 2 ...
[10:31:47.825]  - Finding globals in '...' for chunk #2 ...
[10:31:47.826] getGlobalsAndPackages() ...
[10:31:47.826] Searching for globals...
[10:31:47.827] 
[10:31:47.827] Searching for globals ... DONE
[10:31:47.827] - globals: [0] <none>
[10:31:47.827] getGlobalsAndPackages() ... DONE
[10:31:47.827]    + additional globals found: [n=0] 
[10:31:47.827]    + additional namespaces needed: [n=0] 
[10:31:47.828]  - Finding globals in '...' for chunk #2 ... DONE
[10:31:47.828]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:47.828]  - seeds: <none>
[10:31:47.828]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:47.828] getGlobalsAndPackages() ...
[10:31:47.828] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:47.829] Resolving globals: FALSE
[10:31:47.830] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:31:47.831] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:47.831] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:47.831] 
[10:31:47.831] getGlobalsAndPackages() ... DONE
[10:31:47.832] run() for ‘Future’ ...
[10:31:47.832] - state: ‘created’
[10:31:47.832] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:47.837] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:47.838] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:47.838]   - Field: ‘label’
[10:31:47.838]   - Field: ‘local’
[10:31:47.838]   - Field: ‘owner’
[10:31:47.838]   - Field: ‘envir’
[10:31:47.839]   - Field: ‘workers’
[10:31:47.839]   - Field: ‘packages’
[10:31:47.839]   - Field: ‘gc’
[10:31:47.839]   - Field: ‘job’
[10:31:47.839]   - Field: ‘conditions’
[10:31:47.839]   - Field: ‘expr’
[10:31:47.839]   - Field: ‘uuid’
[10:31:47.840]   - Field: ‘seed’
[10:31:47.840]   - Field: ‘version’
[10:31:47.840]   - Field: ‘result’
[10:31:47.840]   - Field: ‘asynchronous’
[10:31:47.840]   - Field: ‘calls’
[10:31:47.840]   - Field: ‘globals’
[10:31:47.840]   - Field: ‘stdout’
[10:31:47.841]   - Field: ‘earlySignal’
[10:31:47.841]   - Field: ‘lazy’
[10:31:47.841]   - Field: ‘state’
[10:31:47.841] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:47.841] - Launch lazy future ...
[10:31:47.842] Packages needed by the future expression (n = 0): <none>
[10:31:47.842] Packages needed by future strategies (n = 0): <none>
[10:31:47.843] {
[10:31:47.843]     {
[10:31:47.843]         {
[10:31:47.843]             ...future.startTime <- base::Sys.time()
[10:31:47.843]             {
[10:31:47.843]                 {
[10:31:47.843]                   {
[10:31:47.843]                     {
[10:31:47.843]                       base::local({
[10:31:47.843]                         has_future <- base::requireNamespace("future", 
[10:31:47.843]                           quietly = TRUE)
[10:31:47.843]                         if (has_future) {
[10:31:47.843]                           ns <- base::getNamespace("future")
[10:31:47.843]                           version <- ns[[".package"]][["version"]]
[10:31:47.843]                           if (is.null(version)) 
[10:31:47.843]                             version <- utils::packageVersion("future")
[10:31:47.843]                         }
[10:31:47.843]                         else {
[10:31:47.843]                           version <- NULL
[10:31:47.843]                         }
[10:31:47.843]                         if (!has_future || version < "1.8.0") {
[10:31:47.843]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:47.843]                             "", base::R.version$version.string), 
[10:31:47.843]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:47.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:47.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:47.843]                               "release", "version")], collapse = " "), 
[10:31:47.843]                             hostname = base::Sys.info()[["nodename"]])
[10:31:47.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:47.843]                             info)
[10:31:47.843]                           info <- base::paste(info, collapse = "; ")
[10:31:47.843]                           if (!has_future) {
[10:31:47.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:47.843]                               info)
[10:31:47.843]                           }
[10:31:47.843]                           else {
[10:31:47.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:47.843]                               info, version)
[10:31:47.843]                           }
[10:31:47.843]                           base::stop(msg)
[10:31:47.843]                         }
[10:31:47.843]                       })
[10:31:47.843]                     }
[10:31:47.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:47.843]                     base::options(mc.cores = 1L)
[10:31:47.843]                   }
[10:31:47.843]                   ...future.strategy.old <- future::plan("list")
[10:31:47.843]                   options(future.plan = NULL)
[10:31:47.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:47.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:47.843]                 }
[10:31:47.843]                 ...future.workdir <- getwd()
[10:31:47.843]             }
[10:31:47.843]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:47.843]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:47.843]         }
[10:31:47.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:47.843]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:47.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:47.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:47.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:47.843]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:47.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:47.843]             base::names(...future.oldOptions))
[10:31:47.843]     }
[10:31:47.843]     if (FALSE) {
[10:31:47.843]     }
[10:31:47.843]     else {
[10:31:47.843]         if (FALSE) {
[10:31:47.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:47.843]                 open = "w")
[10:31:47.843]         }
[10:31:47.843]         else {
[10:31:47.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:47.843]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:47.843]         }
[10:31:47.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:47.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:47.843]             base::sink(type = "output", split = FALSE)
[10:31:47.843]             base::close(...future.stdout)
[10:31:47.843]         }, add = TRUE)
[10:31:47.843]     }
[10:31:47.843]     ...future.frame <- base::sys.nframe()
[10:31:47.843]     ...future.conditions <- base::list()
[10:31:47.843]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:47.843]     if (FALSE) {
[10:31:47.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:47.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:47.843]     }
[10:31:47.843]     ...future.result <- base::tryCatch({
[10:31:47.843]         base::withCallingHandlers({
[10:31:47.843]             ...future.value <- base::withVisible(base::local({
[10:31:47.843]                 withCallingHandlers({
[10:31:47.843]                   {
[10:31:47.843]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:47.843]                     if (!identical(...future.globals.maxSize.org, 
[10:31:47.843]                       ...future.globals.maxSize)) {
[10:31:47.843]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:47.843]                       on.exit(options(oopts), add = TRUE)
[10:31:47.843]                     }
[10:31:47.843]                     {
[10:31:47.843]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:47.843]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:47.843]                         USE.NAMES = FALSE)
[10:31:47.843]                       do.call(mapply, args = args)
[10:31:47.843]                     }
[10:31:47.843]                   }
[10:31:47.843]                 }, immediateCondition = function(cond) {
[10:31:47.843]                   save_rds <- function (object, pathname, ...) 
[10:31:47.843]                   {
[10:31:47.843]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:47.843]                     if (file_test("-f", pathname_tmp)) {
[10:31:47.843]                       fi_tmp <- file.info(pathname_tmp)
[10:31:47.843]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:47.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:47.843]                         fi_tmp[["mtime"]])
[10:31:47.843]                     }
[10:31:47.843]                     tryCatch({
[10:31:47.843]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:47.843]                     }, error = function(ex) {
[10:31:47.843]                       msg <- conditionMessage(ex)
[10:31:47.843]                       fi_tmp <- file.info(pathname_tmp)
[10:31:47.843]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:47.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:47.843]                         fi_tmp[["mtime"]], msg)
[10:31:47.843]                       ex$message <- msg
[10:31:47.843]                       stop(ex)
[10:31:47.843]                     })
[10:31:47.843]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:47.843]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:47.843]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:47.843]                       fi_tmp <- file.info(pathname_tmp)
[10:31:47.843]                       fi <- file.info(pathname)
[10:31:47.843]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:47.843]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:47.843]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:47.843]                         fi[["size"]], fi[["mtime"]])
[10:31:47.843]                       stop(msg)
[10:31:47.843]                     }
[10:31:47.843]                     invisible(pathname)
[10:31:47.843]                   }
[10:31:47.843]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:47.843]                     rootPath = tempdir()) 
[10:31:47.843]                   {
[10:31:47.843]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:47.843]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:47.843]                       tmpdir = path, fileext = ".rds")
[10:31:47.843]                     save_rds(obj, file)
[10:31:47.843]                   }
[10:31:47.843]                   saveImmediateCondition(cond, path = "/tmp/Rtmptsj9Jv/.future/immediateConditions")
[10:31:47.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:47.843]                   {
[10:31:47.843]                     inherits <- base::inherits
[10:31:47.843]                     invokeRestart <- base::invokeRestart
[10:31:47.843]                     is.null <- base::is.null
[10:31:47.843]                     muffled <- FALSE
[10:31:47.843]                     if (inherits(cond, "message")) {
[10:31:47.843]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:47.843]                       if (muffled) 
[10:31:47.843]                         invokeRestart("muffleMessage")
[10:31:47.843]                     }
[10:31:47.843]                     else if (inherits(cond, "warning")) {
[10:31:47.843]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:47.843]                       if (muffled) 
[10:31:47.843]                         invokeRestart("muffleWarning")
[10:31:47.843]                     }
[10:31:47.843]                     else if (inherits(cond, "condition")) {
[10:31:47.843]                       if (!is.null(pattern)) {
[10:31:47.843]                         computeRestarts <- base::computeRestarts
[10:31:47.843]                         grepl <- base::grepl
[10:31:47.843]                         restarts <- computeRestarts(cond)
[10:31:47.843]                         for (restart in restarts) {
[10:31:47.843]                           name <- restart$name
[10:31:47.843]                           if (is.null(name)) 
[10:31:47.843]                             next
[10:31:47.843]                           if (!grepl(pattern, name)) 
[10:31:47.843]                             next
[10:31:47.843]                           invokeRestart(restart)
[10:31:47.843]                           muffled <- TRUE
[10:31:47.843]                           break
[10:31:47.843]                         }
[10:31:47.843]                       }
[10:31:47.843]                     }
[10:31:47.843]                     invisible(muffled)
[10:31:47.843]                   }
[10:31:47.843]                   muffleCondition(cond)
[10:31:47.843]                 })
[10:31:47.843]             }))
[10:31:47.843]             future::FutureResult(value = ...future.value$value, 
[10:31:47.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:47.843]                   ...future.rng), globalenv = if (FALSE) 
[10:31:47.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:47.843]                     ...future.globalenv.names))
[10:31:47.843]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:47.843]         }, condition = base::local({
[10:31:47.843]             c <- base::c
[10:31:47.843]             inherits <- base::inherits
[10:31:47.843]             invokeRestart <- base::invokeRestart
[10:31:47.843]             length <- base::length
[10:31:47.843]             list <- base::list
[10:31:47.843]             seq.int <- base::seq.int
[10:31:47.843]             signalCondition <- base::signalCondition
[10:31:47.843]             sys.calls <- base::sys.calls
[10:31:47.843]             `[[` <- base::`[[`
[10:31:47.843]             `+` <- base::`+`
[10:31:47.843]             `<<-` <- base::`<<-`
[10:31:47.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:47.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:47.843]                   3L)]
[10:31:47.843]             }
[10:31:47.843]             function(cond) {
[10:31:47.843]                 is_error <- inherits(cond, "error")
[10:31:47.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:47.843]                   NULL)
[10:31:47.843]                 if (is_error) {
[10:31:47.843]                   sessionInformation <- function() {
[10:31:47.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:47.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:47.843]                       search = base::search(), system = base::Sys.info())
[10:31:47.843]                   }
[10:31:47.843]                   ...future.conditions[[length(...future.conditions) + 
[10:31:47.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:47.843]                     cond$call), session = sessionInformation(), 
[10:31:47.843]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:47.843]                   signalCondition(cond)
[10:31:47.843]                 }
[10:31:47.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:47.843]                 "immediateCondition"))) {
[10:31:47.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:47.843]                   ...future.conditions[[length(...future.conditions) + 
[10:31:47.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:47.843]                   if (TRUE && !signal) {
[10:31:47.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:47.843]                     {
[10:31:47.843]                       inherits <- base::inherits
[10:31:47.843]                       invokeRestart <- base::invokeRestart
[10:31:47.843]                       is.null <- base::is.null
[10:31:47.843]                       muffled <- FALSE
[10:31:47.843]                       if (inherits(cond, "message")) {
[10:31:47.843]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:47.843]                         if (muffled) 
[10:31:47.843]                           invokeRestart("muffleMessage")
[10:31:47.843]                       }
[10:31:47.843]                       else if (inherits(cond, "warning")) {
[10:31:47.843]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:47.843]                         if (muffled) 
[10:31:47.843]                           invokeRestart("muffleWarning")
[10:31:47.843]                       }
[10:31:47.843]                       else if (inherits(cond, "condition")) {
[10:31:47.843]                         if (!is.null(pattern)) {
[10:31:47.843]                           computeRestarts <- base::computeRestarts
[10:31:47.843]                           grepl <- base::grepl
[10:31:47.843]                           restarts <- computeRestarts(cond)
[10:31:47.843]                           for (restart in restarts) {
[10:31:47.843]                             name <- restart$name
[10:31:47.843]                             if (is.null(name)) 
[10:31:47.843]                               next
[10:31:47.843]                             if (!grepl(pattern, name)) 
[10:31:47.843]                               next
[10:31:47.843]                             invokeRestart(restart)
[10:31:47.843]                             muffled <- TRUE
[10:31:47.843]                             break
[10:31:47.843]                           }
[10:31:47.843]                         }
[10:31:47.843]                       }
[10:31:47.843]                       invisible(muffled)
[10:31:47.843]                     }
[10:31:47.843]                     muffleCondition(cond, pattern = "^muffle")
[10:31:47.843]                   }
[10:31:47.843]                 }
[10:31:47.843]                 else {
[10:31:47.843]                   if (TRUE) {
[10:31:47.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:47.843]                     {
[10:31:47.843]                       inherits <- base::inherits
[10:31:47.843]                       invokeRestart <- base::invokeRestart
[10:31:47.843]                       is.null <- base::is.null
[10:31:47.843]                       muffled <- FALSE
[10:31:47.843]                       if (inherits(cond, "message")) {
[10:31:47.843]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:47.843]                         if (muffled) 
[10:31:47.843]                           invokeRestart("muffleMessage")
[10:31:47.843]                       }
[10:31:47.843]                       else if (inherits(cond, "warning")) {
[10:31:47.843]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:47.843]                         if (muffled) 
[10:31:47.843]                           invokeRestart("muffleWarning")
[10:31:47.843]                       }
[10:31:47.843]                       else if (inherits(cond, "condition")) {
[10:31:47.843]                         if (!is.null(pattern)) {
[10:31:47.843]                           computeRestarts <- base::computeRestarts
[10:31:47.843]                           grepl <- base::grepl
[10:31:47.843]                           restarts <- computeRestarts(cond)
[10:31:47.843]                           for (restart in restarts) {
[10:31:47.843]                             name <- restart$name
[10:31:47.843]                             if (is.null(name)) 
[10:31:47.843]                               next
[10:31:47.843]                             if (!grepl(pattern, name)) 
[10:31:47.843]                               next
[10:31:47.843]                             invokeRestart(restart)
[10:31:47.843]                             muffled <- TRUE
[10:31:47.843]                             break
[10:31:47.843]                           }
[10:31:47.843]                         }
[10:31:47.843]                       }
[10:31:47.843]                       invisible(muffled)
[10:31:47.843]                     }
[10:31:47.843]                     muffleCondition(cond, pattern = "^muffle")
[10:31:47.843]                   }
[10:31:47.843]                 }
[10:31:47.843]             }
[10:31:47.843]         }))
[10:31:47.843]     }, error = function(ex) {
[10:31:47.843]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:47.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:47.843]                 ...future.rng), started = ...future.startTime, 
[10:31:47.843]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:47.843]             version = "1.8"), class = "FutureResult")
[10:31:47.843]     }, finally = {
[10:31:47.843]         if (!identical(...future.workdir, getwd())) 
[10:31:47.843]             setwd(...future.workdir)
[10:31:47.843]         {
[10:31:47.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:47.843]                 ...future.oldOptions$nwarnings <- NULL
[10:31:47.843]             }
[10:31:47.843]             base::options(...future.oldOptions)
[10:31:47.843]             if (.Platform$OS.type == "windows") {
[10:31:47.843]                 old_names <- names(...future.oldEnvVars)
[10:31:47.843]                 envs <- base::Sys.getenv()
[10:31:47.843]                 names <- names(envs)
[10:31:47.843]                 common <- intersect(names, old_names)
[10:31:47.843]                 added <- setdiff(names, old_names)
[10:31:47.843]                 removed <- setdiff(old_names, names)
[10:31:47.843]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:47.843]                   envs[common]]
[10:31:47.843]                 NAMES <- toupper(changed)
[10:31:47.843]                 args <- list()
[10:31:47.843]                 for (kk in seq_along(NAMES)) {
[10:31:47.843]                   name <- changed[[kk]]
[10:31:47.843]                   NAME <- NAMES[[kk]]
[10:31:47.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:47.843]                     next
[10:31:47.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:47.843]                 }
[10:31:47.843]                 NAMES <- toupper(added)
[10:31:47.843]                 for (kk in seq_along(NAMES)) {
[10:31:47.843]                   name <- added[[kk]]
[10:31:47.843]                   NAME <- NAMES[[kk]]
[10:31:47.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:47.843]                     next
[10:31:47.843]                   args[[name]] <- ""
[10:31:47.843]                 }
[10:31:47.843]                 NAMES <- toupper(removed)
[10:31:47.843]                 for (kk in seq_along(NAMES)) {
[10:31:47.843]                   name <- removed[[kk]]
[10:31:47.843]                   NAME <- NAMES[[kk]]
[10:31:47.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:47.843]                     next
[10:31:47.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:47.843]                 }
[10:31:47.843]                 if (length(args) > 0) 
[10:31:47.843]                   base::do.call(base::Sys.setenv, args = args)
[10:31:47.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:47.843]             }
[10:31:47.843]             else {
[10:31:47.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:47.843]             }
[10:31:47.843]             {
[10:31:47.843]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:47.843]                   0L) {
[10:31:47.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:47.843]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:47.843]                   base::options(opts)
[10:31:47.843]                 }
[10:31:47.843]                 {
[10:31:47.843]                   {
[10:31:47.843]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:47.843]                     NULL
[10:31:47.843]                   }
[10:31:47.843]                   options(future.plan = NULL)
[10:31:47.843]                   if (is.na(NA_character_)) 
[10:31:47.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:47.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:47.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:47.843]                     .init = FALSE)
[10:31:47.843]                 }
[10:31:47.843]             }
[10:31:47.843]         }
[10:31:47.843]     })
[10:31:47.843]     if (TRUE) {
[10:31:47.843]         base::sink(type = "output", split = FALSE)
[10:31:47.843]         if (FALSE) {
[10:31:47.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:47.843]         }
[10:31:47.843]         else {
[10:31:47.843]             ...future.result["stdout"] <- base::list(NULL)
[10:31:47.843]         }
[10:31:47.843]         base::close(...future.stdout)
[10:31:47.843]         ...future.stdout <- NULL
[10:31:47.843]     }
[10:31:47.843]     ...future.result$conditions <- ...future.conditions
[10:31:47.843]     ...future.result$finished <- base::Sys.time()
[10:31:47.843]     ...future.result
[10:31:47.843] }
[10:31:47.846] assign_globals() ...
[10:31:47.846] List of 5
[10:31:47.846]  $ ...future.FUN            :function (x, y)  
[10:31:47.846]  $ MoreArgs                 : NULL
[10:31:47.846]  $ ...future.elements_ii    :List of 2
[10:31:47.846]   ..$ :List of 1
[10:31:47.846]   .. ..$ : int 0
[10:31:47.846]   ..$ :List of 1
[10:31:47.846]   .. ..$ : int 1
[10:31:47.846]  $ ...future.seeds_ii       : NULL
[10:31:47.846]  $ ...future.globals.maxSize: NULL
[10:31:47.846]  - attr(*, "where")=List of 5
[10:31:47.846]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:47.846]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:47.846]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:47.846]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:47.846]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:47.846]  - attr(*, "resolved")= logi FALSE
[10:31:47.846]  - attr(*, "total_size")= num 6368
[10:31:47.846]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:47.846]  - attr(*, "already-done")= logi TRUE
[10:31:47.854] - reassign environment for ‘...future.FUN’
[10:31:47.855] - copied ‘...future.FUN’ to environment
[10:31:47.855] - copied ‘MoreArgs’ to environment
[10:31:47.855] - copied ‘...future.elements_ii’ to environment
[10:31:47.855] - copied ‘...future.seeds_ii’ to environment
[10:31:47.855] - copied ‘...future.globals.maxSize’ to environment
[10:31:47.855] assign_globals() ... done
[10:31:47.856] requestCore(): workers = 2
[10:31:47.858] MulticoreFuture started
[10:31:47.858] - Launch lazy future ... done
[10:31:47.859] run() for ‘MulticoreFuture’ ... done
[10:31:47.859] Created future:
[10:31:47.859] plan(): Setting new future strategy stack:
[10:31:47.859] List of future strategies:
[10:31:47.859] 1. sequential:
[10:31:47.859]    - args: function (..., envir = parent.frame())
[10:31:47.859]    - tweaked: FALSE
[10:31:47.859]    - call: NULL
[10:31:47.863] plan(): nbrOfWorkers() = 1
[10:31:47.866] plan(): Setting new future strategy stack:
[10:31:47.867] List of future strategies:
[10:31:47.867] 1. multicore:
[10:31:47.867]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:47.867]    - tweaked: FALSE
[10:31:47.867]    - call: plan(strategy)
[10:31:47.873] plan(): nbrOfWorkers() = 2
[10:31:47.859] MulticoreFuture:
[10:31:47.859] Label: ‘future_mapply-2’
[10:31:47.859] Expression:
[10:31:47.859] {
[10:31:47.859]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:47.859]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:47.859]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:47.859]         on.exit(options(oopts), add = TRUE)
[10:31:47.859]     }
[10:31:47.859]     {
[10:31:47.859]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:47.859]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:47.859]         do.call(mapply, args = args)
[10:31:47.859]     }
[10:31:47.859] }
[10:31:47.859] Lazy evaluation: FALSE
[10:31:47.859] Asynchronous evaluation: TRUE
[10:31:47.859] Local evaluation: TRUE
[10:31:47.859] Environment: R_GlobalEnv
[10:31:47.859] Capture standard output: FALSE
[10:31:47.859] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:47.859] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:47.859] Packages: <none>
[10:31:47.859] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:47.859] Resolved: TRUE
[10:31:47.859] Value: <not collected>
[10:31:47.859] Conditions captured: <none>
[10:31:47.859] Early signaling: FALSE
[10:31:47.859] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:47.859] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:47.875] Chunk #2 of 2 ... DONE
[10:31:47.875] Launching 2 futures (chunks) ... DONE
[10:31:47.875] Resolving 2 futures (chunks) ...
[10:31:47.876] resolve() on list ...
[10:31:47.876]  recursive: 0
[10:31:47.876]  length: 2
[10:31:47.876] 
[10:31:47.887] Future #2
[10:31:47.887] result() for MulticoreFuture ...
[10:31:47.888] result() for MulticoreFuture ...
[10:31:47.889] result() for MulticoreFuture ... done
[10:31:47.889] result() for MulticoreFuture ... done
[10:31:47.889] result() for MulticoreFuture ...
[10:31:47.889] result() for MulticoreFuture ... done
[10:31:47.889] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:47.890] - nx: 2
[10:31:47.890] - relay: TRUE
[10:31:47.890] - stdout: TRUE
[10:31:47.890] - signal: TRUE
[10:31:47.890] - resignal: FALSE
[10:31:47.890] - force: TRUE
[10:31:47.890] - relayed: [n=2] FALSE, FALSE
[10:31:47.891] - queued futures: [n=2] FALSE, FALSE
[10:31:47.891]  - until=1
[10:31:47.891]  - relaying element #1
[10:31:47.891] - relayed: [n=2] FALSE, FALSE
[10:31:47.891] - queued futures: [n=2] FALSE, TRUE
[10:31:47.891] signalConditionsASAP(NULL, pos=2) ... done
[10:31:47.892]  length: 1 (resolved future 2)
[10:31:48.316] plan(): Setting new future strategy stack:
[10:31:48.316] List of future strategies:
[10:31:48.316] 1. multicore:
[10:31:48.316]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:48.316]    - tweaked: FALSE
[10:31:48.316]    - call: plan(strategy)
[10:31:48.321] plan(): nbrOfWorkers() = 2
[10:31:48.321] Future #1
[10:31:48.321] result() for MulticoreFuture ...
[10:31:48.322] result() for MulticoreFuture ...
[10:31:48.322] result() for MulticoreFuture ... done
[10:31:48.322] result() for MulticoreFuture ... done
[10:31:48.323] result() for MulticoreFuture ...
[10:31:48.323] result() for MulticoreFuture ... done
[10:31:48.323] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:48.323] - nx: 2
[10:31:48.323] - relay: TRUE
[10:31:48.323] - stdout: TRUE
[10:31:48.323] - signal: TRUE
[10:31:48.324] - resignal: FALSE
[10:31:48.324] - force: TRUE
[10:31:48.324] - relayed: [n=2] FALSE, FALSE
[10:31:48.324] - queued futures: [n=2] FALSE, TRUE
[10:31:48.324]  - until=1
[10:31:48.324]  - relaying element #1
[10:31:48.325] result() for MulticoreFuture ...
[10:31:48.325] result() for MulticoreFuture ... done
[10:31:48.325] result() for MulticoreFuture ...
[10:31:48.325] result() for MulticoreFuture ... done
[10:31:48.325] result() for MulticoreFuture ...
[10:31:48.325] result() for MulticoreFuture ... done
[10:31:48.326] result() for MulticoreFuture ...
[10:31:48.326] result() for MulticoreFuture ... done
[10:31:48.326] - relayed: [n=2] TRUE, FALSE
[10:31:48.326] - queued futures: [n=2] TRUE, TRUE
[10:31:48.326] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:48.326]  length: 0 (resolved future 1)
[10:31:48.326] Relaying remaining futures
[10:31:48.327] signalConditionsASAP(NULL, pos=0) ...
[10:31:48.327] - nx: 2
[10:31:48.327] - relay: TRUE
[10:31:48.327] - stdout: TRUE
[10:31:48.327] - signal: TRUE
[10:31:48.327] - resignal: FALSE
[10:31:48.327] - force: TRUE
[10:31:48.327] - relayed: [n=2] TRUE, FALSE
[10:31:48.327] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:48.328]  - relaying element #2
[10:31:48.328] result() for MulticoreFuture ...
[10:31:48.328] result() for MulticoreFuture ... done
[10:31:48.328] result() for MulticoreFuture ...
[10:31:48.328] result() for MulticoreFuture ... done
[10:31:48.328] result() for MulticoreFuture ...
[10:31:48.328] result() for MulticoreFuture ... done
[10:31:48.328] result() for MulticoreFuture ...
[10:31:48.328] result() for MulticoreFuture ... done
[10:31:48.329] - relayed: [n=2] TRUE, TRUE
[10:31:48.329] - queued futures: [n=2] TRUE, TRUE
[10:31:48.329] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:31:48.329] resolve() on list ... DONE
[10:31:48.329] result() for MulticoreFuture ...
[10:31:48.329] result() for MulticoreFuture ... done
[10:31:48.329] result() for MulticoreFuture ...
[10:31:48.329] result() for MulticoreFuture ... done
[10:31:48.330] result() for MulticoreFuture ...
[10:31:48.330] result() for MulticoreFuture ... done
[10:31:48.330] result() for MulticoreFuture ...
[10:31:48.330] result() for MulticoreFuture ... done
[10:31:48.330]  - Number of value chunks collected: 2
[10:31:48.330] Resolving 2 futures (chunks) ... DONE
[10:31:48.330] Reducing values from 2 chunks ...
[10:31:48.330]  - Number of values collected after concatenation: 2
[10:31:48.330]  - Number of values expected: 2
[10:31:48.331] Reducing values from 2 chunks ... DONE
[10:31:48.331] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:31:48.331] future_mapply() ...
[10:31:48.336] Number of chunks: 2
[10:31:48.336] getGlobalsAndPackagesXApply() ...
[10:31:48.336]  - future.globals: TRUE
[10:31:48.336] getGlobalsAndPackages() ...
[10:31:48.336] Searching for globals...
[10:31:48.338] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:48.339] Searching for globals ... DONE
[10:31:48.339] Resolving globals: FALSE
[10:31:48.339] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:48.340] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:48.340] - globals: [1] ‘FUN’
[10:31:48.340] 
[10:31:48.340] getGlobalsAndPackages() ... DONE
[10:31:48.340]  - globals found/used: [n=1] ‘FUN’
[10:31:48.340]  - needed namespaces: [n=0] 
[10:31:48.340] Finding globals ... DONE
[10:31:48.341] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:48.341] List of 2
[10:31:48.341]  $ ...future.FUN:function (x, y)  
[10:31:48.341]  $ MoreArgs     : NULL
[10:31:48.341]  - attr(*, "where")=List of 2
[10:31:48.341]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:48.341]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:48.341]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:48.341]  - attr(*, "resolved")= logi FALSE
[10:31:48.341]  - attr(*, "total_size")= num NA
[10:31:48.346] Packages to be attached in all futures: [n=0] 
[10:31:48.346] getGlobalsAndPackagesXApply() ... DONE
[10:31:48.346] Number of futures (= number of chunks): 2
[10:31:48.346] Launching 2 futures (chunks) ...
[10:31:48.346] Chunk #1 of 2 ...
[10:31:48.346]  - Finding globals in '...' for chunk #1 ...
[10:31:48.346] getGlobalsAndPackages() ...
[10:31:48.347] Searching for globals...
[10:31:48.347] 
[10:31:48.347] Searching for globals ... DONE
[10:31:48.347] - globals: [0] <none>
[10:31:48.347] getGlobalsAndPackages() ... DONE
[10:31:48.347]    + additional globals found: [n=0] 
[10:31:48.347]    + additional namespaces needed: [n=0] 
[10:31:48.348]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:48.348]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:48.348]  - seeds: <none>
[10:31:48.348]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:48.348] getGlobalsAndPackages() ...
[10:31:48.348] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:48.348] Resolving globals: FALSE
[10:31:48.349] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:31:48.349] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:48.349] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:48.349] 
[10:31:48.349] getGlobalsAndPackages() ... DONE
[10:31:48.350] run() for ‘Future’ ...
[10:31:48.350] - state: ‘created’
[10:31:48.350] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:48.354] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:48.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:48.354]   - Field: ‘label’
[10:31:48.354]   - Field: ‘local’
[10:31:48.354]   - Field: ‘owner’
[10:31:48.354]   - Field: ‘envir’
[10:31:48.354]   - Field: ‘workers’
[10:31:48.355]   - Field: ‘packages’
[10:31:48.355]   - Field: ‘gc’
[10:31:48.355]   - Field: ‘job’
[10:31:48.355]   - Field: ‘conditions’
[10:31:48.355]   - Field: ‘expr’
[10:31:48.355]   - Field: ‘uuid’
[10:31:48.355]   - Field: ‘seed’
[10:31:48.355]   - Field: ‘version’
[10:31:48.355]   - Field: ‘result’
[10:31:48.355]   - Field: ‘asynchronous’
[10:31:48.356]   - Field: ‘calls’
[10:31:48.356]   - Field: ‘globals’
[10:31:48.356]   - Field: ‘stdout’
[10:31:48.356]   - Field: ‘earlySignal’
[10:31:48.356]   - Field: ‘lazy’
[10:31:48.356]   - Field: ‘state’
[10:31:48.356] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:48.356] - Launch lazy future ...
[10:31:48.356] Packages needed by the future expression (n = 0): <none>
[10:31:48.357] Packages needed by future strategies (n = 0): <none>
[10:31:48.357] {
[10:31:48.357]     {
[10:31:48.357]         {
[10:31:48.357]             ...future.startTime <- base::Sys.time()
[10:31:48.357]             {
[10:31:48.357]                 {
[10:31:48.357]                   {
[10:31:48.357]                     {
[10:31:48.357]                       base::local({
[10:31:48.357]                         has_future <- base::requireNamespace("future", 
[10:31:48.357]                           quietly = TRUE)
[10:31:48.357]                         if (has_future) {
[10:31:48.357]                           ns <- base::getNamespace("future")
[10:31:48.357]                           version <- ns[[".package"]][["version"]]
[10:31:48.357]                           if (is.null(version)) 
[10:31:48.357]                             version <- utils::packageVersion("future")
[10:31:48.357]                         }
[10:31:48.357]                         else {
[10:31:48.357]                           version <- NULL
[10:31:48.357]                         }
[10:31:48.357]                         if (!has_future || version < "1.8.0") {
[10:31:48.357]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:48.357]                             "", base::R.version$version.string), 
[10:31:48.357]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:48.357]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:48.357]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:48.357]                               "release", "version")], collapse = " "), 
[10:31:48.357]                             hostname = base::Sys.info()[["nodename"]])
[10:31:48.357]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:48.357]                             info)
[10:31:48.357]                           info <- base::paste(info, collapse = "; ")
[10:31:48.357]                           if (!has_future) {
[10:31:48.357]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:48.357]                               info)
[10:31:48.357]                           }
[10:31:48.357]                           else {
[10:31:48.357]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:48.357]                               info, version)
[10:31:48.357]                           }
[10:31:48.357]                           base::stop(msg)
[10:31:48.357]                         }
[10:31:48.357]                       })
[10:31:48.357]                     }
[10:31:48.357]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:48.357]                     base::options(mc.cores = 1L)
[10:31:48.357]                   }
[10:31:48.357]                   ...future.strategy.old <- future::plan("list")
[10:31:48.357]                   options(future.plan = NULL)
[10:31:48.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:48.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:48.357]                 }
[10:31:48.357]                 ...future.workdir <- getwd()
[10:31:48.357]             }
[10:31:48.357]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:48.357]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:48.357]         }
[10:31:48.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:48.357]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:48.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:48.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:48.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:48.357]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:48.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:48.357]             base::names(...future.oldOptions))
[10:31:48.357]     }
[10:31:48.357]     if (FALSE) {
[10:31:48.357]     }
[10:31:48.357]     else {
[10:31:48.357]         if (TRUE) {
[10:31:48.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:48.357]                 open = "w")
[10:31:48.357]         }
[10:31:48.357]         else {
[10:31:48.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:48.357]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:48.357]         }
[10:31:48.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:48.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:48.357]             base::sink(type = "output", split = FALSE)
[10:31:48.357]             base::close(...future.stdout)
[10:31:48.357]         }, add = TRUE)
[10:31:48.357]     }
[10:31:48.357]     ...future.frame <- base::sys.nframe()
[10:31:48.357]     ...future.conditions <- base::list()
[10:31:48.357]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:48.357]     if (FALSE) {
[10:31:48.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:48.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:48.357]     }
[10:31:48.357]     ...future.result <- base::tryCatch({
[10:31:48.357]         base::withCallingHandlers({
[10:31:48.357]             ...future.value <- base::withVisible(base::local({
[10:31:48.357]                 withCallingHandlers({
[10:31:48.357]                   {
[10:31:48.357]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:48.357]                     if (!identical(...future.globals.maxSize.org, 
[10:31:48.357]                       ...future.globals.maxSize)) {
[10:31:48.357]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:48.357]                       on.exit(options(oopts), add = TRUE)
[10:31:48.357]                     }
[10:31:48.357]                     {
[10:31:48.357]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:48.357]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:48.357]                         USE.NAMES = FALSE)
[10:31:48.357]                       do.call(mapply, args = args)
[10:31:48.357]                     }
[10:31:48.357]                   }
[10:31:48.357]                 }, immediateCondition = function(cond) {
[10:31:48.357]                   save_rds <- function (object, pathname, ...) 
[10:31:48.357]                   {
[10:31:48.357]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:48.357]                     if (file_test("-f", pathname_tmp)) {
[10:31:48.357]                       fi_tmp <- file.info(pathname_tmp)
[10:31:48.357]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:48.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:48.357]                         fi_tmp[["mtime"]])
[10:31:48.357]                     }
[10:31:48.357]                     tryCatch({
[10:31:48.357]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:48.357]                     }, error = function(ex) {
[10:31:48.357]                       msg <- conditionMessage(ex)
[10:31:48.357]                       fi_tmp <- file.info(pathname_tmp)
[10:31:48.357]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:48.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:48.357]                         fi_tmp[["mtime"]], msg)
[10:31:48.357]                       ex$message <- msg
[10:31:48.357]                       stop(ex)
[10:31:48.357]                     })
[10:31:48.357]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:48.357]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:48.357]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:48.357]                       fi_tmp <- file.info(pathname_tmp)
[10:31:48.357]                       fi <- file.info(pathname)
[10:31:48.357]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:48.357]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:48.357]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:48.357]                         fi[["size"]], fi[["mtime"]])
[10:31:48.357]                       stop(msg)
[10:31:48.357]                     }
[10:31:48.357]                     invisible(pathname)
[10:31:48.357]                   }
[10:31:48.357]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:48.357]                     rootPath = tempdir()) 
[10:31:48.357]                   {
[10:31:48.357]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:48.357]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:48.357]                       tmpdir = path, fileext = ".rds")
[10:31:48.357]                     save_rds(obj, file)
[10:31:48.357]                   }
[10:31:48.357]                   saveImmediateCondition(cond, path = "/tmp/Rtmptsj9Jv/.future/immediateConditions")
[10:31:48.357]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:48.357]                   {
[10:31:48.357]                     inherits <- base::inherits
[10:31:48.357]                     invokeRestart <- base::invokeRestart
[10:31:48.357]                     is.null <- base::is.null
[10:31:48.357]                     muffled <- FALSE
[10:31:48.357]                     if (inherits(cond, "message")) {
[10:31:48.357]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:48.357]                       if (muffled) 
[10:31:48.357]                         invokeRestart("muffleMessage")
[10:31:48.357]                     }
[10:31:48.357]                     else if (inherits(cond, "warning")) {
[10:31:48.357]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:48.357]                       if (muffled) 
[10:31:48.357]                         invokeRestart("muffleWarning")
[10:31:48.357]                     }
[10:31:48.357]                     else if (inherits(cond, "condition")) {
[10:31:48.357]                       if (!is.null(pattern)) {
[10:31:48.357]                         computeRestarts <- base::computeRestarts
[10:31:48.357]                         grepl <- base::grepl
[10:31:48.357]                         restarts <- computeRestarts(cond)
[10:31:48.357]                         for (restart in restarts) {
[10:31:48.357]                           name <- restart$name
[10:31:48.357]                           if (is.null(name)) 
[10:31:48.357]                             next
[10:31:48.357]                           if (!grepl(pattern, name)) 
[10:31:48.357]                             next
[10:31:48.357]                           invokeRestart(restart)
[10:31:48.357]                           muffled <- TRUE
[10:31:48.357]                           break
[10:31:48.357]                         }
[10:31:48.357]                       }
[10:31:48.357]                     }
[10:31:48.357]                     invisible(muffled)
[10:31:48.357]                   }
[10:31:48.357]                   muffleCondition(cond)
[10:31:48.357]                 })
[10:31:48.357]             }))
[10:31:48.357]             future::FutureResult(value = ...future.value$value, 
[10:31:48.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:48.357]                   ...future.rng), globalenv = if (FALSE) 
[10:31:48.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:48.357]                     ...future.globalenv.names))
[10:31:48.357]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:48.357]         }, condition = base::local({
[10:31:48.357]             c <- base::c
[10:31:48.357]             inherits <- base::inherits
[10:31:48.357]             invokeRestart <- base::invokeRestart
[10:31:48.357]             length <- base::length
[10:31:48.357]             list <- base::list
[10:31:48.357]             seq.int <- base::seq.int
[10:31:48.357]             signalCondition <- base::signalCondition
[10:31:48.357]             sys.calls <- base::sys.calls
[10:31:48.357]             `[[` <- base::`[[`
[10:31:48.357]             `+` <- base::`+`
[10:31:48.357]             `<<-` <- base::`<<-`
[10:31:48.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:48.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:48.357]                   3L)]
[10:31:48.357]             }
[10:31:48.357]             function(cond) {
[10:31:48.357]                 is_error <- inherits(cond, "error")
[10:31:48.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:48.357]                   NULL)
[10:31:48.357]                 if (is_error) {
[10:31:48.357]                   sessionInformation <- function() {
[10:31:48.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:48.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:48.357]                       search = base::search(), system = base::Sys.info())
[10:31:48.357]                   }
[10:31:48.357]                   ...future.conditions[[length(...future.conditions) + 
[10:31:48.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:48.357]                     cond$call), session = sessionInformation(), 
[10:31:48.357]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:48.357]                   signalCondition(cond)
[10:31:48.357]                 }
[10:31:48.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:48.357]                 "immediateCondition"))) {
[10:31:48.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:48.357]                   ...future.conditions[[length(...future.conditions) + 
[10:31:48.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:48.357]                   if (TRUE && !signal) {
[10:31:48.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:48.357]                     {
[10:31:48.357]                       inherits <- base::inherits
[10:31:48.357]                       invokeRestart <- base::invokeRestart
[10:31:48.357]                       is.null <- base::is.null
[10:31:48.357]                       muffled <- FALSE
[10:31:48.357]                       if (inherits(cond, "message")) {
[10:31:48.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:48.357]                         if (muffled) 
[10:31:48.357]                           invokeRestart("muffleMessage")
[10:31:48.357]                       }
[10:31:48.357]                       else if (inherits(cond, "warning")) {
[10:31:48.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:48.357]                         if (muffled) 
[10:31:48.357]                           invokeRestart("muffleWarning")
[10:31:48.357]                       }
[10:31:48.357]                       else if (inherits(cond, "condition")) {
[10:31:48.357]                         if (!is.null(pattern)) {
[10:31:48.357]                           computeRestarts <- base::computeRestarts
[10:31:48.357]                           grepl <- base::grepl
[10:31:48.357]                           restarts <- computeRestarts(cond)
[10:31:48.357]                           for (restart in restarts) {
[10:31:48.357]                             name <- restart$name
[10:31:48.357]                             if (is.null(name)) 
[10:31:48.357]                               next
[10:31:48.357]                             if (!grepl(pattern, name)) 
[10:31:48.357]                               next
[10:31:48.357]                             invokeRestart(restart)
[10:31:48.357]                             muffled <- TRUE
[10:31:48.357]                             break
[10:31:48.357]                           }
[10:31:48.357]                         }
[10:31:48.357]                       }
[10:31:48.357]                       invisible(muffled)
[10:31:48.357]                     }
[10:31:48.357]                     muffleCondition(cond, pattern = "^muffle")
[10:31:48.357]                   }
[10:31:48.357]                 }
[10:31:48.357]                 else {
[10:31:48.357]                   if (TRUE) {
[10:31:48.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:48.357]                     {
[10:31:48.357]                       inherits <- base::inherits
[10:31:48.357]                       invokeRestart <- base::invokeRestart
[10:31:48.357]                       is.null <- base::is.null
[10:31:48.357]                       muffled <- FALSE
[10:31:48.357]                       if (inherits(cond, "message")) {
[10:31:48.357]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:48.357]                         if (muffled) 
[10:31:48.357]                           invokeRestart("muffleMessage")
[10:31:48.357]                       }
[10:31:48.357]                       else if (inherits(cond, "warning")) {
[10:31:48.357]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:48.357]                         if (muffled) 
[10:31:48.357]                           invokeRestart("muffleWarning")
[10:31:48.357]                       }
[10:31:48.357]                       else if (inherits(cond, "condition")) {
[10:31:48.357]                         if (!is.null(pattern)) {
[10:31:48.357]                           computeRestarts <- base::computeRestarts
[10:31:48.357]                           grepl <- base::grepl
[10:31:48.357]                           restarts <- computeRestarts(cond)
[10:31:48.357]                           for (restart in restarts) {
[10:31:48.357]                             name <- restart$name
[10:31:48.357]                             if (is.null(name)) 
[10:31:48.357]                               next
[10:31:48.357]                             if (!grepl(pattern, name)) 
[10:31:48.357]                               next
[10:31:48.357]                             invokeRestart(restart)
[10:31:48.357]                             muffled <- TRUE
[10:31:48.357]                             break
[10:31:48.357]                           }
[10:31:48.357]                         }
[10:31:48.357]                       }
[10:31:48.357]                       invisible(muffled)
[10:31:48.357]                     }
[10:31:48.357]                     muffleCondition(cond, pattern = "^muffle")
[10:31:48.357]                   }
[10:31:48.357]                 }
[10:31:48.357]             }
[10:31:48.357]         }))
[10:31:48.357]     }, error = function(ex) {
[10:31:48.357]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:48.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:48.357]                 ...future.rng), started = ...future.startTime, 
[10:31:48.357]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:48.357]             version = "1.8"), class = "FutureResult")
[10:31:48.357]     }, finally = {
[10:31:48.357]         if (!identical(...future.workdir, getwd())) 
[10:31:48.357]             setwd(...future.workdir)
[10:31:48.357]         {
[10:31:48.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:48.357]                 ...future.oldOptions$nwarnings <- NULL
[10:31:48.357]             }
[10:31:48.357]             base::options(...future.oldOptions)
[10:31:48.357]             if (.Platform$OS.type == "windows") {
[10:31:48.357]                 old_names <- names(...future.oldEnvVars)
[10:31:48.357]                 envs <- base::Sys.getenv()
[10:31:48.357]                 names <- names(envs)
[10:31:48.357]                 common <- intersect(names, old_names)
[10:31:48.357]                 added <- setdiff(names, old_names)
[10:31:48.357]                 removed <- setdiff(old_names, names)
[10:31:48.357]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:48.357]                   envs[common]]
[10:31:48.357]                 NAMES <- toupper(changed)
[10:31:48.357]                 args <- list()
[10:31:48.357]                 for (kk in seq_along(NAMES)) {
[10:31:48.357]                   name <- changed[[kk]]
[10:31:48.357]                   NAME <- NAMES[[kk]]
[10:31:48.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:48.357]                     next
[10:31:48.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:48.357]                 }
[10:31:48.357]                 NAMES <- toupper(added)
[10:31:48.357]                 for (kk in seq_along(NAMES)) {
[10:31:48.357]                   name <- added[[kk]]
[10:31:48.357]                   NAME <- NAMES[[kk]]
[10:31:48.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:48.357]                     next
[10:31:48.357]                   args[[name]] <- ""
[10:31:48.357]                 }
[10:31:48.357]                 NAMES <- toupper(removed)
[10:31:48.357]                 for (kk in seq_along(NAMES)) {
[10:31:48.357]                   name <- removed[[kk]]
[10:31:48.357]                   NAME <- NAMES[[kk]]
[10:31:48.357]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:48.357]                     next
[10:31:48.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:48.357]                 }
[10:31:48.357]                 if (length(args) > 0) 
[10:31:48.357]                   base::do.call(base::Sys.setenv, args = args)
[10:31:48.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:48.357]             }
[10:31:48.357]             else {
[10:31:48.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:48.357]             }
[10:31:48.357]             {
[10:31:48.357]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:48.357]                   0L) {
[10:31:48.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:48.357]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:48.357]                   base::options(opts)
[10:31:48.357]                 }
[10:31:48.357]                 {
[10:31:48.357]                   {
[10:31:48.357]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:48.357]                     NULL
[10:31:48.357]                   }
[10:31:48.357]                   options(future.plan = NULL)
[10:31:48.357]                   if (is.na(NA_character_)) 
[10:31:48.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:48.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:48.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:48.357]                     .init = FALSE)
[10:31:48.357]                 }
[10:31:48.357]             }
[10:31:48.357]         }
[10:31:48.357]     })
[10:31:48.357]     if (TRUE) {
[10:31:48.357]         base::sink(type = "output", split = FALSE)
[10:31:48.357]         if (TRUE) {
[10:31:48.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:48.357]         }
[10:31:48.357]         else {
[10:31:48.357]             ...future.result["stdout"] <- base::list(NULL)
[10:31:48.357]         }
[10:31:48.357]         base::close(...future.stdout)
[10:31:48.357]         ...future.stdout <- NULL
[10:31:48.357]     }
[10:31:48.357]     ...future.result$conditions <- ...future.conditions
[10:31:48.357]     ...future.result$finished <- base::Sys.time()
[10:31:48.357]     ...future.result
[10:31:48.357] }
[10:31:48.359] assign_globals() ...
[10:31:48.360] List of 5
[10:31:48.360]  $ ...future.FUN            :function (x, y)  
[10:31:48.360]  $ MoreArgs                 : NULL
[10:31:48.360]  $ ...future.elements_ii    :List of 2
[10:31:48.360]   ..$ :List of 1
[10:31:48.360]   .. ..$ : int 1
[10:31:48.360]   ..$ :List of 1
[10:31:48.360]   .. ..$ : int 0
[10:31:48.360]  $ ...future.seeds_ii       : NULL
[10:31:48.360]  $ ...future.globals.maxSize: NULL
[10:31:48.360]  - attr(*, "where")=List of 5
[10:31:48.360]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:48.360]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:48.360]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:48.360]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:48.360]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:48.360]  - attr(*, "resolved")= logi FALSE
[10:31:48.360]  - attr(*, "total_size")= num 6368
[10:31:48.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:48.360]  - attr(*, "already-done")= logi TRUE
[10:31:48.365] - reassign environment for ‘...future.FUN’
[10:31:48.365] - copied ‘...future.FUN’ to environment
[10:31:48.365] - copied ‘MoreArgs’ to environment
[10:31:48.365] - copied ‘...future.elements_ii’ to environment
[10:31:48.365] - copied ‘...future.seeds_ii’ to environment
[10:31:48.365] - copied ‘...future.globals.maxSize’ to environment
[10:31:48.366] assign_globals() ... done
[10:31:48.366] requestCore(): workers = 2
[10:31:48.368] MulticoreFuture started
[10:31:48.368] - Launch lazy future ... done
[10:31:48.369] run() for ‘MulticoreFuture’ ... done
[10:31:48.369] Created future:
[10:31:48.369] plan(): Setting new future strategy stack:
[10:31:48.370] List of future strategies:
[10:31:48.370] 1. sequential:
[10:31:48.370]    - args: function (..., envir = parent.frame())
[10:31:48.370]    - tweaked: FALSE
[10:31:48.370]    - call: NULL
[10:31:48.370] plan(): nbrOfWorkers() = 1
[10:31:48.369] MulticoreFuture:
[10:31:48.369] Label: ‘future_mapply-1’
[10:31:48.369] Expression:
[10:31:48.369] {
[10:31:48.369]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:48.369]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:48.369]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:48.369]         on.exit(options(oopts), add = TRUE)
[10:31:48.369]     }
[10:31:48.369]     {
[10:31:48.369]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:48.369]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:48.369]         do.call(mapply, args = args)
[10:31:48.369]     }
[10:31:48.369] }
[10:31:48.369] Lazy evaluation: FALSE
[10:31:48.369] Asynchronous evaluation: TRUE
[10:31:48.369] Local evaluation: TRUE
[10:31:48.369] Environment: R_GlobalEnv
[10:31:48.369] Capture standard output: TRUE
[10:31:48.369] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:48.369] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:48.369] Packages: <none>
[10:31:48.369] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:48.369] Resolved: FALSE
[10:31:48.369] Value: <not collected>
[10:31:48.369] Conditions captured: <none>
[10:31:48.369] Early signaling: FALSE
[10:31:48.369] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:48.369] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:48.382] Chunk #1 of 2 ... DONE
[10:31:48.382] Chunk #2 of 2 ...
[10:31:48.382]  - Finding globals in '...' for chunk #2 ...
[10:31:48.383] getGlobalsAndPackages() ...
[10:31:48.383] Searching for globals...
[10:31:48.383] 
[10:31:48.384] Searching for globals ... DONE
[10:31:48.384] - globals: [0] <none>
[10:31:48.384] getGlobalsAndPackages() ... DONE
[10:31:48.384]    + additional globals found: [n=0] 
[10:31:48.384]    + additional namespaces needed: [n=0] 
[10:31:48.384]  - Finding globals in '...' for chunk #2 ... DONE
[10:31:48.384]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:48.385]  - seeds: <none>
[10:31:48.385]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:48.385] getGlobalsAndPackages() ...
[10:31:48.385] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:48.385] Resolving globals: FALSE
[10:31:48.386] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:31:48.387] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:48.387] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:48.388] 
[10:31:48.388] getGlobalsAndPackages() ... DONE
[10:31:48.400] run() for ‘Future’ ...
[10:31:48.401] - state: ‘created’
[10:31:48.401] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:48.406] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:48.406] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:48.406]   - Field: ‘label’
[10:31:48.406]   - Field: ‘local’
[10:31:48.406]   - Field: ‘owner’
[10:31:48.407]   - Field: ‘envir’
[10:31:48.407]   - Field: ‘workers’
[10:31:48.407]   - Field: ‘packages’
[10:31:48.407]   - Field: ‘gc’
[10:31:48.407]   - Field: ‘job’
[10:31:48.407]   - Field: ‘conditions’
[10:31:48.407]   - Field: ‘expr’
[10:31:48.408]   - Field: ‘uuid’
[10:31:48.408]   - Field: ‘seed’
[10:31:48.408]   - Field: ‘version’
[10:31:48.408]   - Field: ‘result’
[10:31:48.408]   - Field: ‘asynchronous’
[10:31:48.408]   - Field: ‘calls’
[10:31:48.408]   - Field: ‘globals’
[10:31:48.408]   - Field: ‘stdout’
[10:31:48.409]   - Field: ‘earlySignal’
[10:31:48.409]   - Field: ‘lazy’
[10:31:48.409]   - Field: ‘state’
[10:31:48.409] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:48.409] - Launch lazy future ...
[10:31:48.410] Packages needed by the future expression (n = 0): <none>
[10:31:48.410] Packages needed by future strategies (n = 0): <none>
[10:31:48.411] {
[10:31:48.411]     {
[10:31:48.411]         {
[10:31:48.411]             ...future.startTime <- base::Sys.time()
[10:31:48.411]             {
[10:31:48.411]                 {
[10:31:48.411]                   {
[10:31:48.411]                     {
[10:31:48.411]                       base::local({
[10:31:48.411]                         has_future <- base::requireNamespace("future", 
[10:31:48.411]                           quietly = TRUE)
[10:31:48.411]                         if (has_future) {
[10:31:48.411]                           ns <- base::getNamespace("future")
[10:31:48.411]                           version <- ns[[".package"]][["version"]]
[10:31:48.411]                           if (is.null(version)) 
[10:31:48.411]                             version <- utils::packageVersion("future")
[10:31:48.411]                         }
[10:31:48.411]                         else {
[10:31:48.411]                           version <- NULL
[10:31:48.411]                         }
[10:31:48.411]                         if (!has_future || version < "1.8.0") {
[10:31:48.411]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:48.411]                             "", base::R.version$version.string), 
[10:31:48.411]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:48.411]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:48.411]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:48.411]                               "release", "version")], collapse = " "), 
[10:31:48.411]                             hostname = base::Sys.info()[["nodename"]])
[10:31:48.411]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:48.411]                             info)
[10:31:48.411]                           info <- base::paste(info, collapse = "; ")
[10:31:48.411]                           if (!has_future) {
[10:31:48.411]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:48.411]                               info)
[10:31:48.411]                           }
[10:31:48.411]                           else {
[10:31:48.411]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:48.411]                               info, version)
[10:31:48.411]                           }
[10:31:48.411]                           base::stop(msg)
[10:31:48.411]                         }
[10:31:48.411]                       })
[10:31:48.411]                     }
[10:31:48.411]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:48.411]                     base::options(mc.cores = 1L)
[10:31:48.411]                   }
[10:31:48.411]                   ...future.strategy.old <- future::plan("list")
[10:31:48.411]                   options(future.plan = NULL)
[10:31:48.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:48.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:48.411]                 }
[10:31:48.411]                 ...future.workdir <- getwd()
[10:31:48.411]             }
[10:31:48.411]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:48.411]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:48.411]         }
[10:31:48.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:48.411]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:48.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:48.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:48.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:48.411]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:48.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:48.411]             base::names(...future.oldOptions))
[10:31:48.411]     }
[10:31:48.411]     if (FALSE) {
[10:31:48.411]     }
[10:31:48.411]     else {
[10:31:48.411]         if (TRUE) {
[10:31:48.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:48.411]                 open = "w")
[10:31:48.411]         }
[10:31:48.411]         else {
[10:31:48.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:48.411]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:48.411]         }
[10:31:48.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:48.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:48.411]             base::sink(type = "output", split = FALSE)
[10:31:48.411]             base::close(...future.stdout)
[10:31:48.411]         }, add = TRUE)
[10:31:48.411]     }
[10:31:48.411]     ...future.frame <- base::sys.nframe()
[10:31:48.411]     ...future.conditions <- base::list()
[10:31:48.411]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:48.411]     if (FALSE) {
[10:31:48.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:48.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:48.411]     }
[10:31:48.411]     ...future.result <- base::tryCatch({
[10:31:48.411]         base::withCallingHandlers({
[10:31:48.411]             ...future.value <- base::withVisible(base::local({
[10:31:48.411]                 withCallingHandlers({
[10:31:48.411]                   {
[10:31:48.411]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:48.411]                     if (!identical(...future.globals.maxSize.org, 
[10:31:48.411]                       ...future.globals.maxSize)) {
[10:31:48.411]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:48.411]                       on.exit(options(oopts), add = TRUE)
[10:31:48.411]                     }
[10:31:48.411]                     {
[10:31:48.411]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:48.411]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:48.411]                         USE.NAMES = FALSE)
[10:31:48.411]                       do.call(mapply, args = args)
[10:31:48.411]                     }
[10:31:48.411]                   }
[10:31:48.411]                 }, immediateCondition = function(cond) {
[10:31:48.411]                   save_rds <- function (object, pathname, ...) 
[10:31:48.411]                   {
[10:31:48.411]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:48.411]                     if (file_test("-f", pathname_tmp)) {
[10:31:48.411]                       fi_tmp <- file.info(pathname_tmp)
[10:31:48.411]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:48.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:48.411]                         fi_tmp[["mtime"]])
[10:31:48.411]                     }
[10:31:48.411]                     tryCatch({
[10:31:48.411]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:48.411]                     }, error = function(ex) {
[10:31:48.411]                       msg <- conditionMessage(ex)
[10:31:48.411]                       fi_tmp <- file.info(pathname_tmp)
[10:31:48.411]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:48.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:48.411]                         fi_tmp[["mtime"]], msg)
[10:31:48.411]                       ex$message <- msg
[10:31:48.411]                       stop(ex)
[10:31:48.411]                     })
[10:31:48.411]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:48.411]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:48.411]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:48.411]                       fi_tmp <- file.info(pathname_tmp)
[10:31:48.411]                       fi <- file.info(pathname)
[10:31:48.411]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:48.411]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:48.411]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:48.411]                         fi[["size"]], fi[["mtime"]])
[10:31:48.411]                       stop(msg)
[10:31:48.411]                     }
[10:31:48.411]                     invisible(pathname)
[10:31:48.411]                   }
[10:31:48.411]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:48.411]                     rootPath = tempdir()) 
[10:31:48.411]                   {
[10:31:48.411]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:48.411]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:48.411]                       tmpdir = path, fileext = ".rds")
[10:31:48.411]                     save_rds(obj, file)
[10:31:48.411]                   }
[10:31:48.411]                   saveImmediateCondition(cond, path = "/tmp/Rtmptsj9Jv/.future/immediateConditions")
[10:31:48.411]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:48.411]                   {
[10:31:48.411]                     inherits <- base::inherits
[10:31:48.411]                     invokeRestart <- base::invokeRestart
[10:31:48.411]                     is.null <- base::is.null
[10:31:48.411]                     muffled <- FALSE
[10:31:48.411]                     if (inherits(cond, "message")) {
[10:31:48.411]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:48.411]                       if (muffled) 
[10:31:48.411]                         invokeRestart("muffleMessage")
[10:31:48.411]                     }
[10:31:48.411]                     else if (inherits(cond, "warning")) {
[10:31:48.411]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:48.411]                       if (muffled) 
[10:31:48.411]                         invokeRestart("muffleWarning")
[10:31:48.411]                     }
[10:31:48.411]                     else if (inherits(cond, "condition")) {
[10:31:48.411]                       if (!is.null(pattern)) {
[10:31:48.411]                         computeRestarts <- base::computeRestarts
[10:31:48.411]                         grepl <- base::grepl
[10:31:48.411]                         restarts <- computeRestarts(cond)
[10:31:48.411]                         for (restart in restarts) {
[10:31:48.411]                           name <- restart$name
[10:31:48.411]                           if (is.null(name)) 
[10:31:48.411]                             next
[10:31:48.411]                           if (!grepl(pattern, name)) 
[10:31:48.411]                             next
[10:31:48.411]                           invokeRestart(restart)
[10:31:48.411]                           muffled <- TRUE
[10:31:48.411]                           break
[10:31:48.411]                         }
[10:31:48.411]                       }
[10:31:48.411]                     }
[10:31:48.411]                     invisible(muffled)
[10:31:48.411]                   }
[10:31:48.411]                   muffleCondition(cond)
[10:31:48.411]                 })
[10:31:48.411]             }))
[10:31:48.411]             future::FutureResult(value = ...future.value$value, 
[10:31:48.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:48.411]                   ...future.rng), globalenv = if (FALSE) 
[10:31:48.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:48.411]                     ...future.globalenv.names))
[10:31:48.411]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:48.411]         }, condition = base::local({
[10:31:48.411]             c <- base::c
[10:31:48.411]             inherits <- base::inherits
[10:31:48.411]             invokeRestart <- base::invokeRestart
[10:31:48.411]             length <- base::length
[10:31:48.411]             list <- base::list
[10:31:48.411]             seq.int <- base::seq.int
[10:31:48.411]             signalCondition <- base::signalCondition
[10:31:48.411]             sys.calls <- base::sys.calls
[10:31:48.411]             `[[` <- base::`[[`
[10:31:48.411]             `+` <- base::`+`
[10:31:48.411]             `<<-` <- base::`<<-`
[10:31:48.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:48.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:48.411]                   3L)]
[10:31:48.411]             }
[10:31:48.411]             function(cond) {
[10:31:48.411]                 is_error <- inherits(cond, "error")
[10:31:48.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:48.411]                   NULL)
[10:31:48.411]                 if (is_error) {
[10:31:48.411]                   sessionInformation <- function() {
[10:31:48.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:48.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:48.411]                       search = base::search(), system = base::Sys.info())
[10:31:48.411]                   }
[10:31:48.411]                   ...future.conditions[[length(...future.conditions) + 
[10:31:48.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:48.411]                     cond$call), session = sessionInformation(), 
[10:31:48.411]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:48.411]                   signalCondition(cond)
[10:31:48.411]                 }
[10:31:48.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:48.411]                 "immediateCondition"))) {
[10:31:48.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:48.411]                   ...future.conditions[[length(...future.conditions) + 
[10:31:48.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:48.411]                   if (TRUE && !signal) {
[10:31:48.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:48.411]                     {
[10:31:48.411]                       inherits <- base::inherits
[10:31:48.411]                       invokeRestart <- base::invokeRestart
[10:31:48.411]                       is.null <- base::is.null
[10:31:48.411]                       muffled <- FALSE
[10:31:48.411]                       if (inherits(cond, "message")) {
[10:31:48.411]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:48.411]                         if (muffled) 
[10:31:48.411]                           invokeRestart("muffleMessage")
[10:31:48.411]                       }
[10:31:48.411]                       else if (inherits(cond, "warning")) {
[10:31:48.411]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:48.411]                         if (muffled) 
[10:31:48.411]                           invokeRestart("muffleWarning")
[10:31:48.411]                       }
[10:31:48.411]                       else if (inherits(cond, "condition")) {
[10:31:48.411]                         if (!is.null(pattern)) {
[10:31:48.411]                           computeRestarts <- base::computeRestarts
[10:31:48.411]                           grepl <- base::grepl
[10:31:48.411]                           restarts <- computeRestarts(cond)
[10:31:48.411]                           for (restart in restarts) {
[10:31:48.411]                             name <- restart$name
[10:31:48.411]                             if (is.null(name)) 
[10:31:48.411]                               next
[10:31:48.411]                             if (!grepl(pattern, name)) 
[10:31:48.411]                               next
[10:31:48.411]                             invokeRestart(restart)
[10:31:48.411]                             muffled <- TRUE
[10:31:48.411]                             break
[10:31:48.411]                           }
[10:31:48.411]                         }
[10:31:48.411]                       }
[10:31:48.411]                       invisible(muffled)
[10:31:48.411]                     }
[10:31:48.411]                     muffleCondition(cond, pattern = "^muffle")
[10:31:48.411]                   }
[10:31:48.411]                 }
[10:31:48.411]                 else {
[10:31:48.411]                   if (TRUE) {
[10:31:48.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:48.411]                     {
[10:31:48.411]                       inherits <- base::inherits
[10:31:48.411]                       invokeRestart <- base::invokeRestart
[10:31:48.411]                       is.null <- base::is.null
[10:31:48.411]                       muffled <- FALSE
[10:31:48.411]                       if (inherits(cond, "message")) {
[10:31:48.411]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:48.411]                         if (muffled) 
[10:31:48.411]                           invokeRestart("muffleMessage")
[10:31:48.411]                       }
[10:31:48.411]                       else if (inherits(cond, "warning")) {
[10:31:48.411]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:48.411]                         if (muffled) 
[10:31:48.411]                           invokeRestart("muffleWarning")
[10:31:48.411]                       }
[10:31:48.411]                       else if (inherits(cond, "condition")) {
[10:31:48.411]                         if (!is.null(pattern)) {
[10:31:48.411]                           computeRestarts <- base::computeRestarts
[10:31:48.411]                           grepl <- base::grepl
[10:31:48.411]                           restarts <- computeRestarts(cond)
[10:31:48.411]                           for (restart in restarts) {
[10:31:48.411]                             name <- restart$name
[10:31:48.411]                             if (is.null(name)) 
[10:31:48.411]                               next
[10:31:48.411]                             if (!grepl(pattern, name)) 
[10:31:48.411]                               next
[10:31:48.411]                             invokeRestart(restart)
[10:31:48.411]                             muffled <- TRUE
[10:31:48.411]                             break
[10:31:48.411]                           }
[10:31:48.411]                         }
[10:31:48.411]                       }
[10:31:48.411]                       invisible(muffled)
[10:31:48.411]                     }
[10:31:48.411]                     muffleCondition(cond, pattern = "^muffle")
[10:31:48.411]                   }
[10:31:48.411]                 }
[10:31:48.411]             }
[10:31:48.411]         }))
[10:31:48.411]     }, error = function(ex) {
[10:31:48.411]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:48.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:48.411]                 ...future.rng), started = ...future.startTime, 
[10:31:48.411]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:48.411]             version = "1.8"), class = "FutureResult")
[10:31:48.411]     }, finally = {
[10:31:48.411]         if (!identical(...future.workdir, getwd())) 
[10:31:48.411]             setwd(...future.workdir)
[10:31:48.411]         {
[10:31:48.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:48.411]                 ...future.oldOptions$nwarnings <- NULL
[10:31:48.411]             }
[10:31:48.411]             base::options(...future.oldOptions)
[10:31:48.411]             if (.Platform$OS.type == "windows") {
[10:31:48.411]                 old_names <- names(...future.oldEnvVars)
[10:31:48.411]                 envs <- base::Sys.getenv()
[10:31:48.411]                 names <- names(envs)
[10:31:48.411]                 common <- intersect(names, old_names)
[10:31:48.411]                 added <- setdiff(names, old_names)
[10:31:48.411]                 removed <- setdiff(old_names, names)
[10:31:48.411]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:48.411]                   envs[common]]
[10:31:48.411]                 NAMES <- toupper(changed)
[10:31:48.411]                 args <- list()
[10:31:48.411]                 for (kk in seq_along(NAMES)) {
[10:31:48.411]                   name <- changed[[kk]]
[10:31:48.411]                   NAME <- NAMES[[kk]]
[10:31:48.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:48.411]                     next
[10:31:48.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:48.411]                 }
[10:31:48.411]                 NAMES <- toupper(added)
[10:31:48.411]                 for (kk in seq_along(NAMES)) {
[10:31:48.411]                   name <- added[[kk]]
[10:31:48.411]                   NAME <- NAMES[[kk]]
[10:31:48.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:48.411]                     next
[10:31:48.411]                   args[[name]] <- ""
[10:31:48.411]                 }
[10:31:48.411]                 NAMES <- toupper(removed)
[10:31:48.411]                 for (kk in seq_along(NAMES)) {
[10:31:48.411]                   name <- removed[[kk]]
[10:31:48.411]                   NAME <- NAMES[[kk]]
[10:31:48.411]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:48.411]                     next
[10:31:48.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:48.411]                 }
[10:31:48.411]                 if (length(args) > 0) 
[10:31:48.411]                   base::do.call(base::Sys.setenv, args = args)
[10:31:48.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:48.411]             }
[10:31:48.411]             else {
[10:31:48.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:48.411]             }
[10:31:48.411]             {
[10:31:48.411]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:48.411]                   0L) {
[10:31:48.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:48.411]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:48.411]                   base::options(opts)
[10:31:48.411]                 }
[10:31:48.411]                 {
[10:31:48.411]                   {
[10:31:48.411]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:48.411]                     NULL
[10:31:48.411]                   }
[10:31:48.411]                   options(future.plan = NULL)
[10:31:48.411]                   if (is.na(NA_character_)) 
[10:31:48.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:48.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:48.411]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:48.411]                     .init = FALSE)
[10:31:48.411]                 }
[10:31:48.411]             }
[10:31:48.411]         }
[10:31:48.411]     })
[10:31:48.411]     if (TRUE) {
[10:31:48.411]         base::sink(type = "output", split = FALSE)
[10:31:48.411]         if (TRUE) {
[10:31:48.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:48.411]         }
[10:31:48.411]         else {
[10:31:48.411]             ...future.result["stdout"] <- base::list(NULL)
[10:31:48.411]         }
[10:31:48.411]         base::close(...future.stdout)
[10:31:48.411]         ...future.stdout <- NULL
[10:31:48.411]     }
[10:31:48.411]     ...future.result$conditions <- ...future.conditions
[10:31:48.411]     ...future.result$finished <- base::Sys.time()
[10:31:48.411]     ...future.result
[10:31:48.411] }
[10:31:48.413] assign_globals() ...
[10:31:48.414] List of 5
[10:31:48.414]  $ ...future.FUN            :function (x, y)  
[10:31:48.414]  $ MoreArgs                 : NULL
[10:31:48.414]  $ ...future.elements_ii    :List of 2
[10:31:48.414]   ..$ :List of 1
[10:31:48.414]   .. ..$ : int 0
[10:31:48.414]   ..$ :List of 1
[10:31:48.414]   .. ..$ : int 1
[10:31:48.414]  $ ...future.seeds_ii       : NULL
[10:31:48.414]  $ ...future.globals.maxSize: NULL
[10:31:48.414]  - attr(*, "where")=List of 5
[10:31:48.414]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:48.414]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:48.414]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:48.414]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:48.414]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:48.414]  - attr(*, "resolved")= logi FALSE
[10:31:48.414]  - attr(*, "total_size")= num 6368
[10:31:48.414]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:48.414]  - attr(*, "already-done")= logi TRUE
[10:31:48.420] - reassign environment for ‘...future.FUN’
[10:31:48.421] - copied ‘...future.FUN’ to environment
[10:31:48.421] - copied ‘MoreArgs’ to environment
[10:31:48.421] - copied ‘...future.elements_ii’ to environment
[10:31:48.421] - copied ‘...future.seeds_ii’ to environment
[10:31:48.421] - copied ‘...future.globals.maxSize’ to environment
[10:31:48.421] assign_globals() ... done
[10:31:48.421] requestCore(): workers = 2
[10:31:48.424] MulticoreFuture started
[10:31:48.424] - Launch lazy future ... done
[10:31:48.424] run() for ‘MulticoreFuture’ ... done
[10:31:48.425] Created future:
[10:31:48.425] plan(): Setting new future strategy stack:
[10:31:48.425] List of future strategies:
[10:31:48.425] 1. sequential:
[10:31:48.425]    - args: function (..., envir = parent.frame())
[10:31:48.425]    - tweaked: FALSE
[10:31:48.425]    - call: NULL
[10:31:48.426] plan(): nbrOfWorkers() = 1
[10:31:48.428] plan(): Setting new future strategy stack:
[10:31:48.429] List of future strategies:
[10:31:48.429] 1. multicore:
[10:31:48.429]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:48.429]    - tweaked: FALSE
[10:31:48.429]    - call: plan(strategy)
[10:31:48.434] plan(): nbrOfWorkers() = 2
[10:31:48.425] MulticoreFuture:
[10:31:48.425] Label: ‘future_mapply-2’
[10:31:48.425] Expression:
[10:31:48.425] {
[10:31:48.425]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:48.425]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:48.425]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:48.425]         on.exit(options(oopts), add = TRUE)
[10:31:48.425]     }
[10:31:48.425]     {
[10:31:48.425]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:48.425]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:48.425]         do.call(mapply, args = args)
[10:31:48.425]     }
[10:31:48.425] }
[10:31:48.425] Lazy evaluation: FALSE
[10:31:48.425] Asynchronous evaluation: TRUE
[10:31:48.425] Local evaluation: TRUE
[10:31:48.425] Environment: R_GlobalEnv
[10:31:48.425] Capture standard output: TRUE
[10:31:48.425] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:48.425] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:48.425] Packages: <none>
[10:31:48.425] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:48.425] Resolved: TRUE
[10:31:48.425] Value: <not collected>
[10:31:48.425] Conditions captured: <none>
[10:31:48.425] Early signaling: FALSE
[10:31:48.425] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:48.425] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:48.435] Chunk #2 of 2 ... DONE
[10:31:48.435] Launching 2 futures (chunks) ... DONE
[10:31:48.436] Resolving 2 futures (chunks) ...
[10:31:48.436] resolve() on list ...
[10:31:48.436]  recursive: 0
[10:31:48.436]  length: 2
[10:31:48.436] 
[10:31:48.447] Future #2
[10:31:48.447] result() for MulticoreFuture ...
[10:31:48.448] result() for MulticoreFuture ...
[10:31:48.448] result() for MulticoreFuture ... done
[10:31:48.448] result() for MulticoreFuture ... done
[10:31:48.449] result() for MulticoreFuture ...
[10:31:48.449] result() for MulticoreFuture ... done
[10:31:48.449] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:48.449] - nx: 2
[10:31:48.449] - relay: TRUE
[10:31:48.449] - stdout: TRUE
[10:31:48.449] - signal: TRUE
[10:31:48.450] - resignal: FALSE
[10:31:48.450] - force: TRUE
[10:31:48.450] - relayed: [n=2] FALSE, FALSE
[10:31:48.450] - queued futures: [n=2] FALSE, FALSE
[10:31:48.450]  - until=1
[10:31:48.450]  - relaying element #1
[10:31:48.450] - relayed: [n=2] FALSE, FALSE
[10:31:48.451] - queued futures: [n=2] FALSE, TRUE
[10:31:48.451] signalConditionsASAP(NULL, pos=2) ... done
[10:31:48.451]  length: 1 (resolved future 2)
[10:31:48.873] plan(): Setting new future strategy stack:
[10:31:48.874] List of future strategies:
[10:31:48.874] 1. multicore:
[10:31:48.874]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:48.874]    - tweaked: FALSE
[10:31:48.874]    - call: plan(strategy)
[10:31:48.878] plan(): nbrOfWorkers() = 2
[10:31:48.879] Future #1
[10:31:48.879] result() for MulticoreFuture ...
[10:31:48.880] result() for MulticoreFuture ...
[10:31:48.880] result() for MulticoreFuture ... done
[10:31:48.880] result() for MulticoreFuture ... done
[10:31:48.880] result() for MulticoreFuture ...
[10:31:48.881] result() for MulticoreFuture ... done
[10:31:48.881] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:48.881] - nx: 2
[10:31:48.881] - relay: TRUE
[10:31:48.881] - stdout: TRUE
[10:31:48.881] - signal: TRUE
[10:31:48.882] - resignal: FALSE
[10:31:48.882] - force: TRUE
[10:31:48.882] - relayed: [n=2] FALSE, FALSE
[10:31:48.882] - queued futures: [n=2] FALSE, TRUE
[10:31:48.882]  - until=1
[10:31:48.882]  - relaying element #1
[10:31:48.883] result() for MulticoreFuture ...
[10:31:48.883] result() for MulticoreFuture ... done
[10:31:48.883] result() for MulticoreFuture ...
[10:31:48.883] result() for MulticoreFuture ... done
[10:31:48.883] result() for MulticoreFuture ...
[10:31:48.883] result() for MulticoreFuture ... done
[10:31:48.884] result() for MulticoreFuture ...
[10:31:48.884] result() for MulticoreFuture ... done
[10:31:48.884] - relayed: [n=2] TRUE, FALSE
[10:31:48.884] - queued futures: [n=2] TRUE, TRUE
[10:31:48.884] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:48.884]  length: 0 (resolved future 1)
[10:31:48.885] Relaying remaining futures
[10:31:48.885] signalConditionsASAP(NULL, pos=0) ...
[10:31:48.885] - nx: 2
[10:31:48.885] - relay: TRUE
[10:31:48.885] - stdout: TRUE
[10:31:48.885] - signal: TRUE
[10:31:48.885] - resignal: FALSE
[10:31:48.888] - force: TRUE
[10:31:48.888] - relayed: [n=2] TRUE, FALSE
[10:31:48.888] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:48.889]  - relaying element #2
[10:31:48.889] result() for MulticoreFuture ...
[10:31:48.889] result() for MulticoreFuture ... done
[10:31:48.889] result() for MulticoreFuture ...
[10:31:48.890] result() for MulticoreFuture ... done
[10:31:48.890] result() for MulticoreFuture ...
[10:31:48.890] result() for MulticoreFuture ... done
[10:31:48.890] result() for MulticoreFuture ...
[10:31:48.890] result() for MulticoreFuture ... done
[10:31:48.890] - relayed: [n=2] TRUE, TRUE
[10:31:48.891] - queued futures: [n=2] TRUE, TRUE
[10:31:48.891] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:31:48.891] resolve() on list ... DONE
[10:31:48.891] result() for MulticoreFuture ...
[10:31:48.891] result() for MulticoreFuture ... done
[10:31:48.891] result() for MulticoreFuture ...
[10:31:48.892] result() for MulticoreFuture ... done
[10:31:48.892] result() for MulticoreFuture ...
[10:31:48.892] result() for MulticoreFuture ... done
[10:31:48.892] result() for MulticoreFuture ...
[10:31:48.892] result() for MulticoreFuture ... done
[10:31:48.892]  - Number of value chunks collected: 2
[10:31:48.893] Resolving 2 futures (chunks) ... DONE
[10:31:48.893] Reducing values from 2 chunks ...
[10:31:48.893]  - Number of values collected after concatenation: 2
[10:31:48.893]  - Number of values expected: 2
[10:31:48.893] Reducing values from 2 chunks ... DONE
[10:31:48.893] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:31:48.894] future_mapply() ...
[10:31:48.899] Number of chunks: 2
[10:31:48.899] getGlobalsAndPackagesXApply() ...
[10:31:48.899]  - future.globals: TRUE
[10:31:48.899] getGlobalsAndPackages() ...
[10:31:48.899] Searching for globals...
[10:31:48.901] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:48.901] Searching for globals ... DONE
[10:31:48.902] Resolving globals: FALSE
[10:31:48.902] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:48.902] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:48.903] - globals: [1] ‘FUN’
[10:31:48.903] 
[10:31:48.903] getGlobalsAndPackages() ... DONE
[10:31:48.903]  - globals found/used: [n=1] ‘FUN’
[10:31:48.903]  - needed namespaces: [n=0] 
[10:31:48.903] Finding globals ... DONE
[10:31:48.903] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:48.904] List of 2
[10:31:48.904]  $ ...future.FUN:function (x, y)  
[10:31:48.904]  $ MoreArgs     : NULL
[10:31:48.904]  - attr(*, "where")=List of 2
[10:31:48.904]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:48.904]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:48.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:48.904]  - attr(*, "resolved")= logi FALSE
[10:31:48.904]  - attr(*, "total_size")= num NA
[10:31:48.906] Packages to be attached in all futures: [n=0] 
[10:31:48.907] getGlobalsAndPackagesXApply() ... DONE
[10:31:48.907] Number of futures (= number of chunks): 2
[10:31:48.907] Launching 2 futures (chunks) ...
[10:31:48.907] Chunk #1 of 2 ...
[10:31:48.907]  - Finding globals in '...' for chunk #1 ...
[10:31:48.907] getGlobalsAndPackages() ...
[10:31:48.907] Searching for globals...
[10:31:48.908] 
[10:31:48.908] Searching for globals ... DONE
[10:31:48.908] - globals: [0] <none>
[10:31:48.908] getGlobalsAndPackages() ... DONE
[10:31:48.908]    + additional globals found: [n=0] 
[10:31:48.908]    + additional namespaces needed: [n=0] 
[10:31:48.908]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:48.908]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:48.908]  - seeds: <none>
[10:31:48.909]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:48.909] getGlobalsAndPackages() ...
[10:31:48.909] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:48.909] Resolving globals: FALSE
[10:31:48.909] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:31:48.910] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:48.910] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:48.910] 
[10:31:48.910] getGlobalsAndPackages() ... DONE
[10:31:48.911] run() for ‘Future’ ...
[10:31:48.911] - state: ‘created’
[10:31:48.911] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:48.915] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:48.915] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:48.915]   - Field: ‘label’
[10:31:48.915]   - Field: ‘local’
[10:31:48.915]   - Field: ‘owner’
[10:31:48.915]   - Field: ‘envir’
[10:31:48.915]   - Field: ‘workers’
[10:31:48.916]   - Field: ‘packages’
[10:31:48.916]   - Field: ‘gc’
[10:31:48.916]   - Field: ‘job’
[10:31:48.916]   - Field: ‘conditions’
[10:31:48.916]   - Field: ‘expr’
[10:31:48.916]   - Field: ‘uuid’
[10:31:48.916]   - Field: ‘seed’
[10:31:48.916]   - Field: ‘version’
[10:31:48.916]   - Field: ‘result’
[10:31:48.916]   - Field: ‘asynchronous’
[10:31:48.916]   - Field: ‘calls’
[10:31:48.917]   - Field: ‘globals’
[10:31:48.917]   - Field: ‘stdout’
[10:31:48.917]   - Field: ‘earlySignal’
[10:31:48.917]   - Field: ‘lazy’
[10:31:48.917]   - Field: ‘state’
[10:31:48.917] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:48.917] - Launch lazy future ...
[10:31:48.918] Packages needed by the future expression (n = 0): <none>
[10:31:48.918] Packages needed by future strategies (n = 0): <none>
[10:31:48.918] {
[10:31:48.918]     {
[10:31:48.918]         {
[10:31:48.918]             ...future.startTime <- base::Sys.time()
[10:31:48.918]             {
[10:31:48.918]                 {
[10:31:48.918]                   {
[10:31:48.918]                     {
[10:31:48.918]                       base::local({
[10:31:48.918]                         has_future <- base::requireNamespace("future", 
[10:31:48.918]                           quietly = TRUE)
[10:31:48.918]                         if (has_future) {
[10:31:48.918]                           ns <- base::getNamespace("future")
[10:31:48.918]                           version <- ns[[".package"]][["version"]]
[10:31:48.918]                           if (is.null(version)) 
[10:31:48.918]                             version <- utils::packageVersion("future")
[10:31:48.918]                         }
[10:31:48.918]                         else {
[10:31:48.918]                           version <- NULL
[10:31:48.918]                         }
[10:31:48.918]                         if (!has_future || version < "1.8.0") {
[10:31:48.918]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:48.918]                             "", base::R.version$version.string), 
[10:31:48.918]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:48.918]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:48.918]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:48.918]                               "release", "version")], collapse = " "), 
[10:31:48.918]                             hostname = base::Sys.info()[["nodename"]])
[10:31:48.918]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:48.918]                             info)
[10:31:48.918]                           info <- base::paste(info, collapse = "; ")
[10:31:48.918]                           if (!has_future) {
[10:31:48.918]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:48.918]                               info)
[10:31:48.918]                           }
[10:31:48.918]                           else {
[10:31:48.918]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:48.918]                               info, version)
[10:31:48.918]                           }
[10:31:48.918]                           base::stop(msg)
[10:31:48.918]                         }
[10:31:48.918]                       })
[10:31:48.918]                     }
[10:31:48.918]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:48.918]                     base::options(mc.cores = 1L)
[10:31:48.918]                   }
[10:31:48.918]                   ...future.strategy.old <- future::plan("list")
[10:31:48.918]                   options(future.plan = NULL)
[10:31:48.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:48.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:48.918]                 }
[10:31:48.918]                 ...future.workdir <- getwd()
[10:31:48.918]             }
[10:31:48.918]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:48.918]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:48.918]         }
[10:31:48.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:48.918]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:48.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:48.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:48.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:48.918]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:48.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:48.918]             base::names(...future.oldOptions))
[10:31:48.918]     }
[10:31:48.918]     if (TRUE) {
[10:31:48.918]     }
[10:31:48.918]     else {
[10:31:48.918]         if (NA) {
[10:31:48.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:48.918]                 open = "w")
[10:31:48.918]         }
[10:31:48.918]         else {
[10:31:48.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:48.918]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:48.918]         }
[10:31:48.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:48.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:48.918]             base::sink(type = "output", split = FALSE)
[10:31:48.918]             base::close(...future.stdout)
[10:31:48.918]         }, add = TRUE)
[10:31:48.918]     }
[10:31:48.918]     ...future.frame <- base::sys.nframe()
[10:31:48.918]     ...future.conditions <- base::list()
[10:31:48.918]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:48.918]     if (FALSE) {
[10:31:48.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:48.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:48.918]     }
[10:31:48.918]     ...future.result <- base::tryCatch({
[10:31:48.918]         base::withCallingHandlers({
[10:31:48.918]             ...future.value <- base::withVisible(base::local({
[10:31:48.918]                 withCallingHandlers({
[10:31:48.918]                   {
[10:31:48.918]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:48.918]                     if (!identical(...future.globals.maxSize.org, 
[10:31:48.918]                       ...future.globals.maxSize)) {
[10:31:48.918]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:48.918]                       on.exit(options(oopts), add = TRUE)
[10:31:48.918]                     }
[10:31:48.918]                     {
[10:31:48.918]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:48.918]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:48.918]                         USE.NAMES = FALSE)
[10:31:48.918]                       do.call(mapply, args = args)
[10:31:48.918]                     }
[10:31:48.918]                   }
[10:31:48.918]                 }, immediateCondition = function(cond) {
[10:31:48.918]                   save_rds <- function (object, pathname, ...) 
[10:31:48.918]                   {
[10:31:48.918]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:48.918]                     if (file_test("-f", pathname_tmp)) {
[10:31:48.918]                       fi_tmp <- file.info(pathname_tmp)
[10:31:48.918]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:48.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:48.918]                         fi_tmp[["mtime"]])
[10:31:48.918]                     }
[10:31:48.918]                     tryCatch({
[10:31:48.918]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:48.918]                     }, error = function(ex) {
[10:31:48.918]                       msg <- conditionMessage(ex)
[10:31:48.918]                       fi_tmp <- file.info(pathname_tmp)
[10:31:48.918]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:48.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:48.918]                         fi_tmp[["mtime"]], msg)
[10:31:48.918]                       ex$message <- msg
[10:31:48.918]                       stop(ex)
[10:31:48.918]                     })
[10:31:48.918]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:48.918]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:48.918]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:48.918]                       fi_tmp <- file.info(pathname_tmp)
[10:31:48.918]                       fi <- file.info(pathname)
[10:31:48.918]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:48.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:48.918]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:48.918]                         fi[["size"]], fi[["mtime"]])
[10:31:48.918]                       stop(msg)
[10:31:48.918]                     }
[10:31:48.918]                     invisible(pathname)
[10:31:48.918]                   }
[10:31:48.918]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:48.918]                     rootPath = tempdir()) 
[10:31:48.918]                   {
[10:31:48.918]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:48.918]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:48.918]                       tmpdir = path, fileext = ".rds")
[10:31:48.918]                     save_rds(obj, file)
[10:31:48.918]                   }
[10:31:48.918]                   saveImmediateCondition(cond, path = "/tmp/Rtmptsj9Jv/.future/immediateConditions")
[10:31:48.918]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:48.918]                   {
[10:31:48.918]                     inherits <- base::inherits
[10:31:48.918]                     invokeRestart <- base::invokeRestart
[10:31:48.918]                     is.null <- base::is.null
[10:31:48.918]                     muffled <- FALSE
[10:31:48.918]                     if (inherits(cond, "message")) {
[10:31:48.918]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:48.918]                       if (muffled) 
[10:31:48.918]                         invokeRestart("muffleMessage")
[10:31:48.918]                     }
[10:31:48.918]                     else if (inherits(cond, "warning")) {
[10:31:48.918]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:48.918]                       if (muffled) 
[10:31:48.918]                         invokeRestart("muffleWarning")
[10:31:48.918]                     }
[10:31:48.918]                     else if (inherits(cond, "condition")) {
[10:31:48.918]                       if (!is.null(pattern)) {
[10:31:48.918]                         computeRestarts <- base::computeRestarts
[10:31:48.918]                         grepl <- base::grepl
[10:31:48.918]                         restarts <- computeRestarts(cond)
[10:31:48.918]                         for (restart in restarts) {
[10:31:48.918]                           name <- restart$name
[10:31:48.918]                           if (is.null(name)) 
[10:31:48.918]                             next
[10:31:48.918]                           if (!grepl(pattern, name)) 
[10:31:48.918]                             next
[10:31:48.918]                           invokeRestart(restart)
[10:31:48.918]                           muffled <- TRUE
[10:31:48.918]                           break
[10:31:48.918]                         }
[10:31:48.918]                       }
[10:31:48.918]                     }
[10:31:48.918]                     invisible(muffled)
[10:31:48.918]                   }
[10:31:48.918]                   muffleCondition(cond)
[10:31:48.918]                 })
[10:31:48.918]             }))
[10:31:48.918]             future::FutureResult(value = ...future.value$value, 
[10:31:48.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:48.918]                   ...future.rng), globalenv = if (FALSE) 
[10:31:48.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:48.918]                     ...future.globalenv.names))
[10:31:48.918]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:48.918]         }, condition = base::local({
[10:31:48.918]             c <- base::c
[10:31:48.918]             inherits <- base::inherits
[10:31:48.918]             invokeRestart <- base::invokeRestart
[10:31:48.918]             length <- base::length
[10:31:48.918]             list <- base::list
[10:31:48.918]             seq.int <- base::seq.int
[10:31:48.918]             signalCondition <- base::signalCondition
[10:31:48.918]             sys.calls <- base::sys.calls
[10:31:48.918]             `[[` <- base::`[[`
[10:31:48.918]             `+` <- base::`+`
[10:31:48.918]             `<<-` <- base::`<<-`
[10:31:48.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:48.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:48.918]                   3L)]
[10:31:48.918]             }
[10:31:48.918]             function(cond) {
[10:31:48.918]                 is_error <- inherits(cond, "error")
[10:31:48.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:48.918]                   NULL)
[10:31:48.918]                 if (is_error) {
[10:31:48.918]                   sessionInformation <- function() {
[10:31:48.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:48.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:48.918]                       search = base::search(), system = base::Sys.info())
[10:31:48.918]                   }
[10:31:48.918]                   ...future.conditions[[length(...future.conditions) + 
[10:31:48.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:48.918]                     cond$call), session = sessionInformation(), 
[10:31:48.918]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:48.918]                   signalCondition(cond)
[10:31:48.918]                 }
[10:31:48.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:48.918]                 "immediateCondition"))) {
[10:31:48.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:48.918]                   ...future.conditions[[length(...future.conditions) + 
[10:31:48.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:48.918]                   if (TRUE && !signal) {
[10:31:48.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:48.918]                     {
[10:31:48.918]                       inherits <- base::inherits
[10:31:48.918]                       invokeRestart <- base::invokeRestart
[10:31:48.918]                       is.null <- base::is.null
[10:31:48.918]                       muffled <- FALSE
[10:31:48.918]                       if (inherits(cond, "message")) {
[10:31:48.918]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:48.918]                         if (muffled) 
[10:31:48.918]                           invokeRestart("muffleMessage")
[10:31:48.918]                       }
[10:31:48.918]                       else if (inherits(cond, "warning")) {
[10:31:48.918]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:48.918]                         if (muffled) 
[10:31:48.918]                           invokeRestart("muffleWarning")
[10:31:48.918]                       }
[10:31:48.918]                       else if (inherits(cond, "condition")) {
[10:31:48.918]                         if (!is.null(pattern)) {
[10:31:48.918]                           computeRestarts <- base::computeRestarts
[10:31:48.918]                           grepl <- base::grepl
[10:31:48.918]                           restarts <- computeRestarts(cond)
[10:31:48.918]                           for (restart in restarts) {
[10:31:48.918]                             name <- restart$name
[10:31:48.918]                             if (is.null(name)) 
[10:31:48.918]                               next
[10:31:48.918]                             if (!grepl(pattern, name)) 
[10:31:48.918]                               next
[10:31:48.918]                             invokeRestart(restart)
[10:31:48.918]                             muffled <- TRUE
[10:31:48.918]                             break
[10:31:48.918]                           }
[10:31:48.918]                         }
[10:31:48.918]                       }
[10:31:48.918]                       invisible(muffled)
[10:31:48.918]                     }
[10:31:48.918]                     muffleCondition(cond, pattern = "^muffle")
[10:31:48.918]                   }
[10:31:48.918]                 }
[10:31:48.918]                 else {
[10:31:48.918]                   if (TRUE) {
[10:31:48.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:48.918]                     {
[10:31:48.918]                       inherits <- base::inherits
[10:31:48.918]                       invokeRestart <- base::invokeRestart
[10:31:48.918]                       is.null <- base::is.null
[10:31:48.918]                       muffled <- FALSE
[10:31:48.918]                       if (inherits(cond, "message")) {
[10:31:48.918]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:48.918]                         if (muffled) 
[10:31:48.918]                           invokeRestart("muffleMessage")
[10:31:48.918]                       }
[10:31:48.918]                       else if (inherits(cond, "warning")) {
[10:31:48.918]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:48.918]                         if (muffled) 
[10:31:48.918]                           invokeRestart("muffleWarning")
[10:31:48.918]                       }
[10:31:48.918]                       else if (inherits(cond, "condition")) {
[10:31:48.918]                         if (!is.null(pattern)) {
[10:31:48.918]                           computeRestarts <- base::computeRestarts
[10:31:48.918]                           grepl <- base::grepl
[10:31:48.918]                           restarts <- computeRestarts(cond)
[10:31:48.918]                           for (restart in restarts) {
[10:31:48.918]                             name <- restart$name
[10:31:48.918]                             if (is.null(name)) 
[10:31:48.918]                               next
[10:31:48.918]                             if (!grepl(pattern, name)) 
[10:31:48.918]                               next
[10:31:48.918]                             invokeRestart(restart)
[10:31:48.918]                             muffled <- TRUE
[10:31:48.918]                             break
[10:31:48.918]                           }
[10:31:48.918]                         }
[10:31:48.918]                       }
[10:31:48.918]                       invisible(muffled)
[10:31:48.918]                     }
[10:31:48.918]                     muffleCondition(cond, pattern = "^muffle")
[10:31:48.918]                   }
[10:31:48.918]                 }
[10:31:48.918]             }
[10:31:48.918]         }))
[10:31:48.918]     }, error = function(ex) {
[10:31:48.918]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:48.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:48.918]                 ...future.rng), started = ...future.startTime, 
[10:31:48.918]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:48.918]             version = "1.8"), class = "FutureResult")
[10:31:48.918]     }, finally = {
[10:31:48.918]         if (!identical(...future.workdir, getwd())) 
[10:31:48.918]             setwd(...future.workdir)
[10:31:48.918]         {
[10:31:48.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:48.918]                 ...future.oldOptions$nwarnings <- NULL
[10:31:48.918]             }
[10:31:48.918]             base::options(...future.oldOptions)
[10:31:48.918]             if (.Platform$OS.type == "windows") {
[10:31:48.918]                 old_names <- names(...future.oldEnvVars)
[10:31:48.918]                 envs <- base::Sys.getenv()
[10:31:48.918]                 names <- names(envs)
[10:31:48.918]                 common <- intersect(names, old_names)
[10:31:48.918]                 added <- setdiff(names, old_names)
[10:31:48.918]                 removed <- setdiff(old_names, names)
[10:31:48.918]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:48.918]                   envs[common]]
[10:31:48.918]                 NAMES <- toupper(changed)
[10:31:48.918]                 args <- list()
[10:31:48.918]                 for (kk in seq_along(NAMES)) {
[10:31:48.918]                   name <- changed[[kk]]
[10:31:48.918]                   NAME <- NAMES[[kk]]
[10:31:48.918]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:48.918]                     next
[10:31:48.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:48.918]                 }
[10:31:48.918]                 NAMES <- toupper(added)
[10:31:48.918]                 for (kk in seq_along(NAMES)) {
[10:31:48.918]                   name <- added[[kk]]
[10:31:48.918]                   NAME <- NAMES[[kk]]
[10:31:48.918]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:48.918]                     next
[10:31:48.918]                   args[[name]] <- ""
[10:31:48.918]                 }
[10:31:48.918]                 NAMES <- toupper(removed)
[10:31:48.918]                 for (kk in seq_along(NAMES)) {
[10:31:48.918]                   name <- removed[[kk]]
[10:31:48.918]                   NAME <- NAMES[[kk]]
[10:31:48.918]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:48.918]                     next
[10:31:48.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:48.918]                 }
[10:31:48.918]                 if (length(args) > 0) 
[10:31:48.918]                   base::do.call(base::Sys.setenv, args = args)
[10:31:48.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:48.918]             }
[10:31:48.918]             else {
[10:31:48.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:48.918]             }
[10:31:48.918]             {
[10:31:48.918]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:48.918]                   0L) {
[10:31:48.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:48.918]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:48.918]                   base::options(opts)
[10:31:48.918]                 }
[10:31:48.918]                 {
[10:31:48.918]                   {
[10:31:48.918]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:48.918]                     NULL
[10:31:48.918]                   }
[10:31:48.918]                   options(future.plan = NULL)
[10:31:48.918]                   if (is.na(NA_character_)) 
[10:31:48.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:48.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:48.918]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:48.918]                     .init = FALSE)
[10:31:48.918]                 }
[10:31:48.918]             }
[10:31:48.918]         }
[10:31:48.918]     })
[10:31:48.918]     if (FALSE) {
[10:31:48.918]         base::sink(type = "output", split = FALSE)
[10:31:48.918]         if (NA) {
[10:31:48.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:48.918]         }
[10:31:48.918]         else {
[10:31:48.918]             ...future.result["stdout"] <- base::list(NULL)
[10:31:48.918]         }
[10:31:48.918]         base::close(...future.stdout)
[10:31:48.918]         ...future.stdout <- NULL
[10:31:48.918]     }
[10:31:48.918]     ...future.result$conditions <- ...future.conditions
[10:31:48.918]     ...future.result$finished <- base::Sys.time()
[10:31:48.918]     ...future.result
[10:31:48.918] }
[10:31:48.920] assign_globals() ...
[10:31:48.921] List of 5
[10:31:48.921]  $ ...future.FUN            :function (x, y)  
[10:31:48.921]  $ MoreArgs                 : NULL
[10:31:48.921]  $ ...future.elements_ii    :List of 2
[10:31:48.921]   ..$ :List of 1
[10:31:48.921]   .. ..$ : int 1
[10:31:48.921]   ..$ :List of 1
[10:31:48.921]   .. ..$ : int 0
[10:31:48.921]  $ ...future.seeds_ii       : NULL
[10:31:48.921]  $ ...future.globals.maxSize: NULL
[10:31:48.921]  - attr(*, "where")=List of 5
[10:31:48.921]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:48.921]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:48.921]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:48.921]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:48.921]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:48.921]  - attr(*, "resolved")= logi FALSE
[10:31:48.921]  - attr(*, "total_size")= num 6368
[10:31:48.921]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:48.921]  - attr(*, "already-done")= logi TRUE
[10:31:48.928] - reassign environment for ‘...future.FUN’
[10:31:48.928] - copied ‘...future.FUN’ to environment
[10:31:48.929] - copied ‘MoreArgs’ to environment
[10:31:48.929] - copied ‘...future.elements_ii’ to environment
[10:31:48.929] - copied ‘...future.seeds_ii’ to environment
[10:31:48.929] - copied ‘...future.globals.maxSize’ to environment
[10:31:48.929] assign_globals() ... done
[10:31:48.929] requestCore(): workers = 2
[10:31:48.932] MulticoreFuture started
[10:31:48.932] - Launch lazy future ... done
[10:31:48.932] run() for ‘MulticoreFuture’ ... done
[10:31:48.933] Created future:
[10:31:48.933] plan(): Setting new future strategy stack:
[10:31:48.933] List of future strategies:
[10:31:48.933] 1. sequential:
[10:31:48.933]    - args: function (..., envir = parent.frame())
[10:31:48.933]    - tweaked: FALSE
[10:31:48.933]    - call: NULL
[10:31:48.934] plan(): nbrOfWorkers() = 1
[10:31:48.933] MulticoreFuture:
[10:31:48.933] Label: ‘future_mapply-1’
[10:31:48.933] Expression:
[10:31:48.933] {
[10:31:48.933]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:48.933]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:48.933]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:48.933]         on.exit(options(oopts), add = TRUE)
[10:31:48.933]     }
[10:31:48.933]     {
[10:31:48.933]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:48.933]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:48.933]         do.call(mapply, args = args)
[10:31:48.933]     }
[10:31:48.933] }
[10:31:48.933] Lazy evaluation: FALSE
[10:31:48.933] Asynchronous evaluation: TRUE
[10:31:48.933] Local evaluation: TRUE
[10:31:48.933] Environment: R_GlobalEnv
[10:31:48.933] Capture standard output: NA
[10:31:48.933] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:48.933] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:48.933] Packages: <none>
[10:31:48.933] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:48.933] Resolved: FALSE
[10:31:48.933] Value: <not collected>
[10:31:48.933] Conditions captured: <none>
[10:31:48.933] Early signaling: FALSE
[10:31:48.933] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:48.933] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:48.947] Chunk #1 of 2 ... DONE
[10:31:48.947] Chunk #2 of 2 ...
[10:31:48.947]  - Finding globals in '...' for chunk #2 ...
[10:31:48.947] getGlobalsAndPackages() ...
[10:31:48.948] Searching for globals...
[10:31:48.948] 
[10:31:48.948] Searching for globals ... DONE
[10:31:48.949] - globals: [0] <none>
[10:31:48.949] getGlobalsAndPackages() ... DONE
[10:31:48.949]    + additional globals found: [n=0] 
[10:31:48.949]    + additional namespaces needed: [n=0] 
[10:31:48.949]  - Finding globals in '...' for chunk #2 ... DONE
[10:31:48.949]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:48.950]  - seeds: <none>
[10:31:48.950]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:48.950] getGlobalsAndPackages() ...
[10:31:48.950] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:48.950] Resolving globals: FALSE
[10:31:48.951] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:31:48.952] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:48.952] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:48.953] 
[10:31:48.953] getGlobalsAndPackages() ... DONE
[10:31:48.953] run() for ‘Future’ ...
[10:31:48.953] - state: ‘created’
[10:31:48.954] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:48.959] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:48.960] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:48.960]   - Field: ‘label’
[10:31:48.960]   - Field: ‘local’
[10:31:48.960]   - Field: ‘owner’
[10:31:48.960]   - Field: ‘envir’
[10:31:48.960]   - Field: ‘workers’
[10:31:48.961]   - Field: ‘packages’
[10:31:48.961]   - Field: ‘gc’
[10:31:48.961]   - Field: ‘job’
[10:31:48.961]   - Field: ‘conditions’
[10:31:48.961]   - Field: ‘expr’
[10:31:48.961]   - Field: ‘uuid’
[10:31:48.962]   - Field: ‘seed’
[10:31:48.962]   - Field: ‘version’
[10:31:48.962]   - Field: ‘result’
[10:31:48.962]   - Field: ‘asynchronous’
[10:31:48.962]   - Field: ‘calls’
[10:31:48.962]   - Field: ‘globals’
[10:31:48.962]   - Field: ‘stdout’
[10:31:48.963]   - Field: ‘earlySignal’
[10:31:48.963]   - Field: ‘lazy’
[10:31:48.963]   - Field: ‘state’
[10:31:48.963] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:48.963] - Launch lazy future ...
[10:31:48.964] Packages needed by the future expression (n = 0): <none>
[10:31:48.964] Packages needed by future strategies (n = 0): <none>
[10:31:48.965] {
[10:31:48.965]     {
[10:31:48.965]         {
[10:31:48.965]             ...future.startTime <- base::Sys.time()
[10:31:48.965]             {
[10:31:48.965]                 {
[10:31:48.965]                   {
[10:31:48.965]                     {
[10:31:48.965]                       base::local({
[10:31:48.965]                         has_future <- base::requireNamespace("future", 
[10:31:48.965]                           quietly = TRUE)
[10:31:48.965]                         if (has_future) {
[10:31:48.965]                           ns <- base::getNamespace("future")
[10:31:48.965]                           version <- ns[[".package"]][["version"]]
[10:31:48.965]                           if (is.null(version)) 
[10:31:48.965]                             version <- utils::packageVersion("future")
[10:31:48.965]                         }
[10:31:48.965]                         else {
[10:31:48.965]                           version <- NULL
[10:31:48.965]                         }
[10:31:48.965]                         if (!has_future || version < "1.8.0") {
[10:31:48.965]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:48.965]                             "", base::R.version$version.string), 
[10:31:48.965]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:48.965]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:48.965]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:48.965]                               "release", "version")], collapse = " "), 
[10:31:48.965]                             hostname = base::Sys.info()[["nodename"]])
[10:31:48.965]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:48.965]                             info)
[10:31:48.965]                           info <- base::paste(info, collapse = "; ")
[10:31:48.965]                           if (!has_future) {
[10:31:48.965]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:48.965]                               info)
[10:31:48.965]                           }
[10:31:48.965]                           else {
[10:31:48.965]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:48.965]                               info, version)
[10:31:48.965]                           }
[10:31:48.965]                           base::stop(msg)
[10:31:48.965]                         }
[10:31:48.965]                       })
[10:31:48.965]                     }
[10:31:48.965]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:48.965]                     base::options(mc.cores = 1L)
[10:31:48.965]                   }
[10:31:48.965]                   ...future.strategy.old <- future::plan("list")
[10:31:48.965]                   options(future.plan = NULL)
[10:31:48.965]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:48.965]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:48.965]                 }
[10:31:48.965]                 ...future.workdir <- getwd()
[10:31:48.965]             }
[10:31:48.965]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:48.965]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:48.965]         }
[10:31:48.965]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:48.965]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:48.965]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:48.965]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:48.965]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:48.965]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:48.965]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:48.965]             base::names(...future.oldOptions))
[10:31:48.965]     }
[10:31:48.965]     if (TRUE) {
[10:31:48.965]     }
[10:31:48.965]     else {
[10:31:48.965]         if (NA) {
[10:31:48.965]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:48.965]                 open = "w")
[10:31:48.965]         }
[10:31:48.965]         else {
[10:31:48.965]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:48.965]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:48.965]         }
[10:31:48.965]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:48.965]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:48.965]             base::sink(type = "output", split = FALSE)
[10:31:48.965]             base::close(...future.stdout)
[10:31:48.965]         }, add = TRUE)
[10:31:48.965]     }
[10:31:48.965]     ...future.frame <- base::sys.nframe()
[10:31:48.965]     ...future.conditions <- base::list()
[10:31:48.965]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:48.965]     if (FALSE) {
[10:31:48.965]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:48.965]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:48.965]     }
[10:31:48.965]     ...future.result <- base::tryCatch({
[10:31:48.965]         base::withCallingHandlers({
[10:31:48.965]             ...future.value <- base::withVisible(base::local({
[10:31:48.965]                 withCallingHandlers({
[10:31:48.965]                   {
[10:31:48.965]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:48.965]                     if (!identical(...future.globals.maxSize.org, 
[10:31:48.965]                       ...future.globals.maxSize)) {
[10:31:48.965]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:48.965]                       on.exit(options(oopts), add = TRUE)
[10:31:48.965]                     }
[10:31:48.965]                     {
[10:31:48.965]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:48.965]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:48.965]                         USE.NAMES = FALSE)
[10:31:48.965]                       do.call(mapply, args = args)
[10:31:48.965]                     }
[10:31:48.965]                   }
[10:31:48.965]                 }, immediateCondition = function(cond) {
[10:31:48.965]                   save_rds <- function (object, pathname, ...) 
[10:31:48.965]                   {
[10:31:48.965]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:48.965]                     if (file_test("-f", pathname_tmp)) {
[10:31:48.965]                       fi_tmp <- file.info(pathname_tmp)
[10:31:48.965]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:48.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:48.965]                         fi_tmp[["mtime"]])
[10:31:48.965]                     }
[10:31:48.965]                     tryCatch({
[10:31:48.965]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:48.965]                     }, error = function(ex) {
[10:31:48.965]                       msg <- conditionMessage(ex)
[10:31:48.965]                       fi_tmp <- file.info(pathname_tmp)
[10:31:48.965]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:48.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:48.965]                         fi_tmp[["mtime"]], msg)
[10:31:48.965]                       ex$message <- msg
[10:31:48.965]                       stop(ex)
[10:31:48.965]                     })
[10:31:48.965]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:48.965]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:48.965]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:48.965]                       fi_tmp <- file.info(pathname_tmp)
[10:31:48.965]                       fi <- file.info(pathname)
[10:31:48.965]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:48.965]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:48.965]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:48.965]                         fi[["size"]], fi[["mtime"]])
[10:31:48.965]                       stop(msg)
[10:31:48.965]                     }
[10:31:48.965]                     invisible(pathname)
[10:31:48.965]                   }
[10:31:48.965]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:48.965]                     rootPath = tempdir()) 
[10:31:48.965]                   {
[10:31:48.965]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:48.965]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:48.965]                       tmpdir = path, fileext = ".rds")
[10:31:48.965]                     save_rds(obj, file)
[10:31:48.965]                   }
[10:31:48.965]                   saveImmediateCondition(cond, path = "/tmp/Rtmptsj9Jv/.future/immediateConditions")
[10:31:48.965]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:48.965]                   {
[10:31:48.965]                     inherits <- base::inherits
[10:31:48.965]                     invokeRestart <- base::invokeRestart
[10:31:48.965]                     is.null <- base::is.null
[10:31:48.965]                     muffled <- FALSE
[10:31:48.965]                     if (inherits(cond, "message")) {
[10:31:48.965]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:48.965]                       if (muffled) 
[10:31:48.965]                         invokeRestart("muffleMessage")
[10:31:48.965]                     }
[10:31:48.965]                     else if (inherits(cond, "warning")) {
[10:31:48.965]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:48.965]                       if (muffled) 
[10:31:48.965]                         invokeRestart("muffleWarning")
[10:31:48.965]                     }
[10:31:48.965]                     else if (inherits(cond, "condition")) {
[10:31:48.965]                       if (!is.null(pattern)) {
[10:31:48.965]                         computeRestarts <- base::computeRestarts
[10:31:48.965]                         grepl <- base::grepl
[10:31:48.965]                         restarts <- computeRestarts(cond)
[10:31:48.965]                         for (restart in restarts) {
[10:31:48.965]                           name <- restart$name
[10:31:48.965]                           if (is.null(name)) 
[10:31:48.965]                             next
[10:31:48.965]                           if (!grepl(pattern, name)) 
[10:31:48.965]                             next
[10:31:48.965]                           invokeRestart(restart)
[10:31:48.965]                           muffled <- TRUE
[10:31:48.965]                           break
[10:31:48.965]                         }
[10:31:48.965]                       }
[10:31:48.965]                     }
[10:31:48.965]                     invisible(muffled)
[10:31:48.965]                   }
[10:31:48.965]                   muffleCondition(cond)
[10:31:48.965]                 })
[10:31:48.965]             }))
[10:31:48.965]             future::FutureResult(value = ...future.value$value, 
[10:31:48.965]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:48.965]                   ...future.rng), globalenv = if (FALSE) 
[10:31:48.965]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:48.965]                     ...future.globalenv.names))
[10:31:48.965]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:48.965]         }, condition = base::local({
[10:31:48.965]             c <- base::c
[10:31:48.965]             inherits <- base::inherits
[10:31:48.965]             invokeRestart <- base::invokeRestart
[10:31:48.965]             length <- base::length
[10:31:48.965]             list <- base::list
[10:31:48.965]             seq.int <- base::seq.int
[10:31:48.965]             signalCondition <- base::signalCondition
[10:31:48.965]             sys.calls <- base::sys.calls
[10:31:48.965]             `[[` <- base::`[[`
[10:31:48.965]             `+` <- base::`+`
[10:31:48.965]             `<<-` <- base::`<<-`
[10:31:48.965]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:48.965]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:48.965]                   3L)]
[10:31:48.965]             }
[10:31:48.965]             function(cond) {
[10:31:48.965]                 is_error <- inherits(cond, "error")
[10:31:48.965]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:48.965]                   NULL)
[10:31:48.965]                 if (is_error) {
[10:31:48.965]                   sessionInformation <- function() {
[10:31:48.965]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:48.965]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:48.965]                       search = base::search(), system = base::Sys.info())
[10:31:48.965]                   }
[10:31:48.965]                   ...future.conditions[[length(...future.conditions) + 
[10:31:48.965]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:48.965]                     cond$call), session = sessionInformation(), 
[10:31:48.965]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:48.965]                   signalCondition(cond)
[10:31:48.965]                 }
[10:31:48.965]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:48.965]                 "immediateCondition"))) {
[10:31:48.965]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:48.965]                   ...future.conditions[[length(...future.conditions) + 
[10:31:48.965]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:48.965]                   if (TRUE && !signal) {
[10:31:48.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:48.965]                     {
[10:31:48.965]                       inherits <- base::inherits
[10:31:48.965]                       invokeRestart <- base::invokeRestart
[10:31:48.965]                       is.null <- base::is.null
[10:31:48.965]                       muffled <- FALSE
[10:31:48.965]                       if (inherits(cond, "message")) {
[10:31:48.965]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:48.965]                         if (muffled) 
[10:31:48.965]                           invokeRestart("muffleMessage")
[10:31:48.965]                       }
[10:31:48.965]                       else if (inherits(cond, "warning")) {
[10:31:48.965]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:48.965]                         if (muffled) 
[10:31:48.965]                           invokeRestart("muffleWarning")
[10:31:48.965]                       }
[10:31:48.965]                       else if (inherits(cond, "condition")) {
[10:31:48.965]                         if (!is.null(pattern)) {
[10:31:48.965]                           computeRestarts <- base::computeRestarts
[10:31:48.965]                           grepl <- base::grepl
[10:31:48.965]                           restarts <- computeRestarts(cond)
[10:31:48.965]                           for (restart in restarts) {
[10:31:48.965]                             name <- restart$name
[10:31:48.965]                             if (is.null(name)) 
[10:31:48.965]                               next
[10:31:48.965]                             if (!grepl(pattern, name)) 
[10:31:48.965]                               next
[10:31:48.965]                             invokeRestart(restart)
[10:31:48.965]                             muffled <- TRUE
[10:31:48.965]                             break
[10:31:48.965]                           }
[10:31:48.965]                         }
[10:31:48.965]                       }
[10:31:48.965]                       invisible(muffled)
[10:31:48.965]                     }
[10:31:48.965]                     muffleCondition(cond, pattern = "^muffle")
[10:31:48.965]                   }
[10:31:48.965]                 }
[10:31:48.965]                 else {
[10:31:48.965]                   if (TRUE) {
[10:31:48.965]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:48.965]                     {
[10:31:48.965]                       inherits <- base::inherits
[10:31:48.965]                       invokeRestart <- base::invokeRestart
[10:31:48.965]                       is.null <- base::is.null
[10:31:48.965]                       muffled <- FALSE
[10:31:48.965]                       if (inherits(cond, "message")) {
[10:31:48.965]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:48.965]                         if (muffled) 
[10:31:48.965]                           invokeRestart("muffleMessage")
[10:31:48.965]                       }
[10:31:48.965]                       else if (inherits(cond, "warning")) {
[10:31:48.965]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:48.965]                         if (muffled) 
[10:31:48.965]                           invokeRestart("muffleWarning")
[10:31:48.965]                       }
[10:31:48.965]                       else if (inherits(cond, "condition")) {
[10:31:48.965]                         if (!is.null(pattern)) {
[10:31:48.965]                           computeRestarts <- base::computeRestarts
[10:31:48.965]                           grepl <- base::grepl
[10:31:48.965]                           restarts <- computeRestarts(cond)
[10:31:48.965]                           for (restart in restarts) {
[10:31:48.965]                             name <- restart$name
[10:31:48.965]                             if (is.null(name)) 
[10:31:48.965]                               next
[10:31:48.965]                             if (!grepl(pattern, name)) 
[10:31:48.965]                               next
[10:31:48.965]                             invokeRestart(restart)
[10:31:48.965]                             muffled <- TRUE
[10:31:48.965]                             break
[10:31:48.965]                           }
[10:31:48.965]                         }
[10:31:48.965]                       }
[10:31:48.965]                       invisible(muffled)
[10:31:48.965]                     }
[10:31:48.965]                     muffleCondition(cond, pattern = "^muffle")
[10:31:48.965]                   }
[10:31:48.965]                 }
[10:31:48.965]             }
[10:31:48.965]         }))
[10:31:48.965]     }, error = function(ex) {
[10:31:48.965]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:48.965]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:48.965]                 ...future.rng), started = ...future.startTime, 
[10:31:48.965]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:48.965]             version = "1.8"), class = "FutureResult")
[10:31:48.965]     }, finally = {
[10:31:48.965]         if (!identical(...future.workdir, getwd())) 
[10:31:48.965]             setwd(...future.workdir)
[10:31:48.965]         {
[10:31:48.965]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:48.965]                 ...future.oldOptions$nwarnings <- NULL
[10:31:48.965]             }
[10:31:48.965]             base::options(...future.oldOptions)
[10:31:48.965]             if (.Platform$OS.type == "windows") {
[10:31:48.965]                 old_names <- names(...future.oldEnvVars)
[10:31:48.965]                 envs <- base::Sys.getenv()
[10:31:48.965]                 names <- names(envs)
[10:31:48.965]                 common <- intersect(names, old_names)
[10:31:48.965]                 added <- setdiff(names, old_names)
[10:31:48.965]                 removed <- setdiff(old_names, names)
[10:31:48.965]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:48.965]                   envs[common]]
[10:31:48.965]                 NAMES <- toupper(changed)
[10:31:48.965]                 args <- list()
[10:31:48.965]                 for (kk in seq_along(NAMES)) {
[10:31:48.965]                   name <- changed[[kk]]
[10:31:48.965]                   NAME <- NAMES[[kk]]
[10:31:48.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:48.965]                     next
[10:31:48.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:48.965]                 }
[10:31:48.965]                 NAMES <- toupper(added)
[10:31:48.965]                 for (kk in seq_along(NAMES)) {
[10:31:48.965]                   name <- added[[kk]]
[10:31:48.965]                   NAME <- NAMES[[kk]]
[10:31:48.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:48.965]                     next
[10:31:48.965]                   args[[name]] <- ""
[10:31:48.965]                 }
[10:31:48.965]                 NAMES <- toupper(removed)
[10:31:48.965]                 for (kk in seq_along(NAMES)) {
[10:31:48.965]                   name <- removed[[kk]]
[10:31:48.965]                   NAME <- NAMES[[kk]]
[10:31:48.965]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:48.965]                     next
[10:31:48.965]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:48.965]                 }
[10:31:48.965]                 if (length(args) > 0) 
[10:31:48.965]                   base::do.call(base::Sys.setenv, args = args)
[10:31:48.965]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:48.965]             }
[10:31:48.965]             else {
[10:31:48.965]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:48.965]             }
[10:31:48.965]             {
[10:31:48.965]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:48.965]                   0L) {
[10:31:48.965]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:48.965]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:48.965]                   base::options(opts)
[10:31:48.965]                 }
[10:31:48.965]                 {
[10:31:48.965]                   {
[10:31:48.965]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:48.965]                     NULL
[10:31:48.965]                   }
[10:31:48.965]                   options(future.plan = NULL)
[10:31:48.965]                   if (is.na(NA_character_)) 
[10:31:48.965]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:48.965]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:48.965]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:48.965]                     .init = FALSE)
[10:31:48.965]                 }
[10:31:48.965]             }
[10:31:48.965]         }
[10:31:48.965]     })
[10:31:48.965]     if (FALSE) {
[10:31:48.965]         base::sink(type = "output", split = FALSE)
[10:31:48.965]         if (NA) {
[10:31:48.965]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:48.965]         }
[10:31:48.965]         else {
[10:31:48.965]             ...future.result["stdout"] <- base::list(NULL)
[10:31:48.965]         }
[10:31:48.965]         base::close(...future.stdout)
[10:31:48.965]         ...future.stdout <- NULL
[10:31:48.965]     }
[10:31:48.965]     ...future.result$conditions <- ...future.conditions
[10:31:48.965]     ...future.result$finished <- base::Sys.time()
[10:31:48.965]     ...future.result
[10:31:48.965] }
[10:31:48.968] assign_globals() ...
[10:31:48.968] List of 5
[10:31:48.968]  $ ...future.FUN            :function (x, y)  
[10:31:48.968]  $ MoreArgs                 : NULL
[10:31:48.968]  $ ...future.elements_ii    :List of 2
[10:31:48.968]   ..$ :List of 1
[10:31:48.968]   .. ..$ : int 0
[10:31:48.968]   ..$ :List of 1
[10:31:48.968]   .. ..$ : int 1
[10:31:48.968]  $ ...future.seeds_ii       : NULL
[10:31:48.968]  $ ...future.globals.maxSize: NULL
[10:31:48.968]  - attr(*, "where")=List of 5
[10:31:48.968]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:48.968]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[10:31:48.968]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:48.968]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:48.968]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:48.968]  - attr(*, "resolved")= logi FALSE
[10:31:48.968]  - attr(*, "total_size")= num 6368
[10:31:48.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:48.968]  - attr(*, "already-done")= logi TRUE
[10:31:48.977] - reassign environment for ‘...future.FUN’
[10:31:48.977] - copied ‘...future.FUN’ to environment
[10:31:48.977] - copied ‘MoreArgs’ to environment
[10:31:48.977] - copied ‘...future.elements_ii’ to environment
[10:31:48.977] - copied ‘...future.seeds_ii’ to environment
[10:31:48.980] - copied ‘...future.globals.maxSize’ to environment
[10:31:48.980] assign_globals() ... done
[10:31:48.980] requestCore(): workers = 2
[10:31:48.983] MulticoreFuture started
[10:31:48.984] - Launch lazy future ... done
[10:31:48.985] run() for ‘MulticoreFuture’ ... done
[10:31:48.985] plan(): Setting new future strategy stack:
[10:31:48.985] Created future:
[10:31:48.985] List of future strategies:
[10:31:48.985] 1. sequential:
[10:31:48.985]    - args: function (..., envir = parent.frame())
[10:31:48.985]    - tweaked: FALSE
[10:31:48.985]    - call: NULL
[10:31:48.987] plan(): nbrOfWorkers() = 1
[10:31:48.990] plan(): Setting new future strategy stack:
[10:31:48.990] List of future strategies:
[10:31:48.990] 1. multicore:
[10:31:48.990]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:48.990]    - tweaked: FALSE
[10:31:48.990]    - call: plan(strategy)
[10:31:48.996] plan(): nbrOfWorkers() = 2
[10:31:48.986] MulticoreFuture:
[10:31:48.986] Label: ‘future_mapply-2’
[10:31:48.986] Expression:
[10:31:48.986] {
[10:31:48.986]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:48.986]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:48.986]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:48.986]         on.exit(options(oopts), add = TRUE)
[10:31:48.986]     }
[10:31:48.986]     {
[10:31:48.986]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:48.986]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:48.986]         do.call(mapply, args = args)
[10:31:48.986]     }
[10:31:48.986] }
[10:31:48.986] Lazy evaluation: FALSE
[10:31:48.986] Asynchronous evaluation: TRUE
[10:31:48.986] Local evaluation: TRUE
[10:31:48.986] Environment: R_GlobalEnv
[10:31:48.986] Capture standard output: NA
[10:31:48.986] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:48.986] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:48.986] Packages: <none>
[10:31:48.986] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:48.986] Resolved: TRUE
[10:31:48.986] Value: <not collected>
[10:31:48.986] Conditions captured: <none>
[10:31:48.986] Early signaling: FALSE
[10:31:48.986] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:48.986] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:48.998] Chunk #2 of 2 ... DONE
[10:31:48.998] Launching 2 futures (chunks) ... DONE
[10:31:48.998] Resolving 2 futures (chunks) ...
[10:31:48.999] resolve() on list ...
[10:31:48.999]  recursive: 0
[10:31:48.999]  length: 2
[10:31:48.999] 
[10:31:49.010] Future #2
[10:31:49.011] result() for MulticoreFuture ...
[10:31:49.011] result() for MulticoreFuture ...
[10:31:49.012] result() for MulticoreFuture ... done
[10:31:49.012] result() for MulticoreFuture ... done
[10:31:49.012] result() for MulticoreFuture ...
[10:31:49.012] result() for MulticoreFuture ... done
[10:31:49.012] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:49.013] - nx: 2
[10:31:49.013] - relay: TRUE
[10:31:49.013] - stdout: TRUE
[10:31:49.013] - signal: TRUE
[10:31:49.013] - resignal: FALSE
[10:31:49.013] - force: TRUE
[10:31:49.014] - relayed: [n=2] FALSE, FALSE
[10:31:49.014] - queued futures: [n=2] FALSE, FALSE
[10:31:49.014]  - until=1
[10:31:49.014]  - relaying element #1
[10:31:49.014] - relayed: [n=2] FALSE, FALSE
[10:31:49.014] - queued futures: [n=2] FALSE, TRUE
[10:31:49.015] signalConditionsASAP(NULL, pos=2) ... done
[10:31:49.015]  length: 1 (resolved future 2)
[10:31:49.438] plan(): Setting new future strategy stack:
[10:31:49.438] List of future strategies:
[10:31:49.438] 1. multicore:
[10:31:49.438]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:49.438]    - tweaked: FALSE
[10:31:49.438]    - call: plan(strategy)
[10:31:49.443] plan(): nbrOfWorkers() = 2
[10:31:49.443] Future #1
[10:31:49.444] result() for MulticoreFuture ...
[10:31:49.445] result() for MulticoreFuture ...
[10:31:49.445] result() for MulticoreFuture ... done
[10:31:49.445] result() for MulticoreFuture ... done
[10:31:49.445] result() for MulticoreFuture ...
[10:31:49.445] result() for MulticoreFuture ... done
[10:31:49.445] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:49.445] - nx: 2
[10:31:49.446] - relay: TRUE
[10:31:49.446] - stdout: TRUE
[10:31:49.446] - signal: TRUE
[10:31:49.446] - resignal: FALSE
[10:31:49.446] - force: TRUE
[10:31:49.446] - relayed: [n=2] FALSE, FALSE
[10:31:49.446] - queued futures: [n=2] FALSE, TRUE
[10:31:49.446]  - until=1
[10:31:49.447]  - relaying element #1
[10:31:49.447] result() for MulticoreFuture ...
[10:31:49.447] result() for MulticoreFuture ... done
[10:31:49.447] result() for MulticoreFuture ...
[10:31:49.447] result() for MulticoreFuture ... done
[10:31:49.447] result() for MulticoreFuture ...
[10:31:49.448] result() for MulticoreFuture ... done
[10:31:49.448] result() for MulticoreFuture ...
[10:31:49.448] result() for MulticoreFuture ... done
[10:31:49.448] - relayed: [n=2] TRUE, FALSE
[10:31:49.448] - queued futures: [n=2] TRUE, TRUE
[10:31:49.448] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:49.448]  length: 0 (resolved future 1)
[10:31:49.449] Relaying remaining futures
[10:31:49.449] signalConditionsASAP(NULL, pos=0) ...
[10:31:49.449] - nx: 2
[10:31:49.449] - relay: TRUE
[10:31:49.449] - stdout: TRUE
[10:31:49.449] - signal: TRUE
[10:31:49.449] - resignal: FALSE
[10:31:49.449] - force: TRUE
[10:31:49.450] - relayed: [n=2] TRUE, FALSE
[10:31:49.450] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:49.450]  - relaying element #2
[10:31:49.450] result() for MulticoreFuture ...
[10:31:49.450] result() for MulticoreFuture ... done
[10:31:49.450] result() for MulticoreFuture ...
[10:31:49.450] result() for MulticoreFuture ... done
[10:31:49.451] result() for MulticoreFuture ...
[10:31:49.451] result() for MulticoreFuture ... done
[10:31:49.451] result() for MulticoreFuture ...
[10:31:49.451] result() for MulticoreFuture ... done
[10:31:49.451] - relayed: [n=2] TRUE, TRUE
[10:31:49.451] - queued futures: [n=2] TRUE, TRUE
[10:31:49.452] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[10:31:49.452] resolve() on list ... DONE
[10:31:49.452] result() for MulticoreFuture ...
[10:31:49.452] result() for MulticoreFuture ... done
[10:31:49.452] result() for MulticoreFuture ...
[10:31:49.452] result() for MulticoreFuture ... done
[10:31:49.452] result() for MulticoreFuture ...
[10:31:49.453] result() for MulticoreFuture ... done
[10:31:49.453] result() for MulticoreFuture ...
[10:31:49.453] result() for MulticoreFuture ... done
[10:31:49.453]  - Number of value chunks collected: 2
[10:31:49.453] Resolving 2 futures (chunks) ... DONE
[10:31:49.453] Reducing values from 2 chunks ...
[10:31:49.454]  - Number of values collected after concatenation: 2
[10:31:49.454]  - Number of values expected: 2
[10:31:49.454] Reducing values from 2 chunks ... DONE
[10:31:49.454] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[10:31:49.455] plan(): Setting new future strategy stack:
[10:31:49.455] List of future strategies:
[10:31:49.455] 1. multisession:
[10:31:49.455]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:49.455]    - tweaked: FALSE
[10:31:49.455]    - call: plan(strategy)
[10:31:49.456] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:31:49.456] multisession:
[10:31:49.456] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:49.456] - tweaked: FALSE
[10:31:49.456] - call: plan(strategy)
[10:31:49.462] getGlobalsAndPackages() ...
[10:31:49.463] Not searching for globals
[10:31:49.463] - globals: [0] <none>
[10:31:49.463] getGlobalsAndPackages() ... DONE
[10:31:49.463] [local output] makeClusterPSOCK() ...
[10:31:49.516] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:31:49.518] [local output] Base port: 11404
[10:31:49.518] [local output] Getting setup options for 2 cluster nodes ...
[10:31:49.518] [local output]  - Node 1 of 2 ...
[10:31:49.518] [local output] localMachine=TRUE => revtunnel=FALSE

[10:31:49.519] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmptsj9Jv/worker.rank=1.parallelly.parent=77485.12eadd818439.pid")), silent = TRUE)' -e 'file.exists("/tmp/Rtmptsj9Jv/worker.rank=1.parallelly.parent=77485.12eadd818439.pid")'’
[10:31:49.711] - Possible to infer worker's PID: TRUE
[10:31:49.711] [local output] Rscript port: 11404

[10:31:49.712] [local output]  - Node 2 of 2 ...
[10:31:49.712] [local output] localMachine=TRUE => revtunnel=FALSE

[10:31:49.713] [local output] Rscript port: 11404

[10:31:49.713] [local output] Getting setup options for 2 cluster nodes ... done
[10:31:49.713] [local output]  - Parallel setup requested for some PSOCK nodes
[10:31:49.714] [local output] Setting up PSOCK nodes in parallel
[10:31:49.714] List of 36
[10:31:49.714]  $ worker          : chr "localhost"
[10:31:49.714]   ..- attr(*, "localhost")= logi TRUE
[10:31:49.714]  $ master          : chr "localhost"
[10:31:49.714]  $ port            : int 11404
[10:31:49.714]  $ connectTimeout  : num 120
[10:31:49.714]  $ timeout         : num 2592000
[10:31:49.714]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:31:49.714]  $ homogeneous     : logi TRUE
[10:31:49.714]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:31:49.714]  $ rscript_envs    : NULL
[10:31:49.714]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:31:49.714]  $ rscript_startup : NULL
[10:31:49.714]  $ rscript_sh      : chr "sh"
[10:31:49.714]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:31:49.714]  $ methods         : logi TRUE
[10:31:49.714]  $ socketOptions   : chr "no-delay"
[10:31:49.714]  $ useXDR          : logi FALSE
[10:31:49.714]  $ outfile         : chr "/dev/null"
[10:31:49.714]  $ renice          : int NA
[10:31:49.714]  $ rshcmd          : NULL
[10:31:49.714]  $ user            : chr(0) 
[10:31:49.714]  $ revtunnel       : logi FALSE
[10:31:49.714]  $ rshlogfile      : NULL
[10:31:49.714]  $ rshopts         : chr(0) 
[10:31:49.714]  $ rank            : int 1
[10:31:49.714]  $ manual          : logi FALSE
[10:31:49.714]  $ dryrun          : logi FALSE
[10:31:49.714]  $ quiet           : logi FALSE
[10:31:49.714]  $ setup_strategy  : chr "parallel"
[10:31:49.714]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:31:49.714]  $ pidfile         : chr "/tmp/Rtmptsj9Jv/worker.rank=1.parallelly.parent=77485.12eadd818439.pid"
[10:31:49.714]  $ rshcmd_label    : NULL
[10:31:49.714]  $ rsh_call        : NULL
[10:31:49.714]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:31:49.714]  $ localMachine    : logi TRUE
[10:31:49.714]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:31:49.714]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:31:49.714]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:31:49.714]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:31:49.714]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:31:49.714]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:31:49.714]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:31:49.714]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:31:49.714]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:31:49.714]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:31:49.714]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:31:49.714]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:31:49.714]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:31:49.714]  $ arguments       :List of 28
[10:31:49.714]   ..$ worker          : chr "localhost"
[10:31:49.714]   ..$ master          : NULL
[10:31:49.714]   ..$ port            : int 11404
[10:31:49.714]   ..$ connectTimeout  : num 120
[10:31:49.714]   ..$ timeout         : num 2592000
[10:31:49.714]   ..$ rscript         : NULL
[10:31:49.714]   ..$ homogeneous     : NULL
[10:31:49.714]   ..$ rscript_args    : NULL
[10:31:49.714]   ..$ rscript_envs    : NULL
[10:31:49.714]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:31:49.714]   ..$ rscript_startup : NULL
[10:31:49.714]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:31:49.714]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:31:49.714]   ..$ methods         : logi TRUE
[10:31:49.714]   ..$ socketOptions   : chr "no-delay"
[10:31:49.714]   ..$ useXDR          : logi FALSE
[10:31:49.714]   ..$ outfile         : chr "/dev/null"
[10:31:49.714]   ..$ renice          : int NA
[10:31:49.714]   ..$ rshcmd          : NULL
[10:31:49.714]   ..$ user            : NULL
[10:31:49.714]   ..$ revtunnel       : logi NA
[10:31:49.714]   ..$ rshlogfile      : NULL
[10:31:49.714]   ..$ rshopts         : NULL
[10:31:49.714]   ..$ rank            : int 1
[10:31:49.714]   ..$ manual          : logi FALSE
[10:31:49.714]   ..$ dryrun          : logi FALSE
[10:31:49.714]   ..$ quiet           : logi FALSE
[10:31:49.714]   ..$ setup_strategy  : chr "parallel"
[10:31:49.714]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:31:49.731] [local output] System call to launch all workers:
[10:31:49.731] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/Rtmptsj9Jv/worker.rank=1.parallelly.parent=77485.12eadd818439.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11404 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:31:49.731] [local output] Starting PSOCK main server
[10:31:49.737] [local output] Workers launched
[10:31:49.737] [local output] Waiting for workers to connect back
[10:31:49.737]  - [local output] 0 workers out of 2 ready
[10:31:49.984]  - [local output] 0 workers out of 2 ready
[10:31:49.985]  - [local output] 1 workers out of 2 ready
[10:31:49.985]  - [local output] 2 workers out of 2 ready
[10:31:49.985] [local output] Launching of workers completed
[10:31:49.985] [local output] Collecting session information from workers
[10:31:49.986] [local output]  - Worker #1 of 2
[10:31:49.987] [local output]  - Worker #2 of 2
[10:31:49.987] [local output] makeClusterPSOCK() ... done
[10:31:49.999] Packages needed by the future expression (n = 0): <none>
[10:31:49.999] Packages needed by future strategies (n = 0): <none>
[10:31:49.999] {
[10:31:49.999]     {
[10:31:49.999]         {
[10:31:49.999]             ...future.startTime <- base::Sys.time()
[10:31:49.999]             {
[10:31:49.999]                 {
[10:31:49.999]                   {
[10:31:49.999]                     {
[10:31:49.999]                       base::local({
[10:31:49.999]                         has_future <- base::requireNamespace("future", 
[10:31:49.999]                           quietly = TRUE)
[10:31:49.999]                         if (has_future) {
[10:31:49.999]                           ns <- base::getNamespace("future")
[10:31:49.999]                           version <- ns[[".package"]][["version"]]
[10:31:49.999]                           if (is.null(version)) 
[10:31:49.999]                             version <- utils::packageVersion("future")
[10:31:49.999]                         }
[10:31:49.999]                         else {
[10:31:49.999]                           version <- NULL
[10:31:49.999]                         }
[10:31:49.999]                         if (!has_future || version < "1.8.0") {
[10:31:49.999]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:49.999]                             "", base::R.version$version.string), 
[10:31:49.999]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:49.999]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:49.999]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:49.999]                               "release", "version")], collapse = " "), 
[10:31:49.999]                             hostname = base::Sys.info()[["nodename"]])
[10:31:49.999]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:49.999]                             info)
[10:31:49.999]                           info <- base::paste(info, collapse = "; ")
[10:31:49.999]                           if (!has_future) {
[10:31:49.999]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:49.999]                               info)
[10:31:49.999]                           }
[10:31:49.999]                           else {
[10:31:49.999]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:49.999]                               info, version)
[10:31:49.999]                           }
[10:31:49.999]                           base::stop(msg)
[10:31:49.999]                         }
[10:31:49.999]                       })
[10:31:49.999]                     }
[10:31:49.999]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:49.999]                     base::options(mc.cores = 1L)
[10:31:49.999]                   }
[10:31:49.999]                   ...future.strategy.old <- future::plan("list")
[10:31:49.999]                   options(future.plan = NULL)
[10:31:49.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:49.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:49.999]                 }
[10:31:49.999]                 ...future.workdir <- getwd()
[10:31:49.999]             }
[10:31:49.999]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:49.999]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:49.999]         }
[10:31:49.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:49.999]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:49.999]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:49.999]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:49.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:49.999]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:49.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:49.999]             base::names(...future.oldOptions))
[10:31:49.999]     }
[10:31:49.999]     if (FALSE) {
[10:31:49.999]     }
[10:31:49.999]     else {
[10:31:49.999]         if (TRUE) {
[10:31:49.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:49.999]                 open = "w")
[10:31:49.999]         }
[10:31:49.999]         else {
[10:31:49.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:49.999]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:49.999]         }
[10:31:49.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:49.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:49.999]             base::sink(type = "output", split = FALSE)
[10:31:49.999]             base::close(...future.stdout)
[10:31:49.999]         }, add = TRUE)
[10:31:49.999]     }
[10:31:49.999]     ...future.frame <- base::sys.nframe()
[10:31:49.999]     ...future.conditions <- base::list()
[10:31:49.999]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:49.999]     if (FALSE) {
[10:31:49.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:49.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:49.999]     }
[10:31:49.999]     ...future.result <- base::tryCatch({
[10:31:49.999]         base::withCallingHandlers({
[10:31:49.999]             ...future.value <- base::withVisible(base::local({
[10:31:49.999]                 ...future.makeSendCondition <- base::local({
[10:31:49.999]                   sendCondition <- NULL
[10:31:49.999]                   function(frame = 1L) {
[10:31:49.999]                     if (is.function(sendCondition)) 
[10:31:49.999]                       return(sendCondition)
[10:31:49.999]                     ns <- getNamespace("parallel")
[10:31:49.999]                     if (exists("sendData", mode = "function", 
[10:31:49.999]                       envir = ns)) {
[10:31:49.999]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:49.999]                         envir = ns)
[10:31:49.999]                       envir <- sys.frame(frame)
[10:31:49.999]                       master <- NULL
[10:31:49.999]                       while (!identical(envir, .GlobalEnv) && 
[10:31:49.999]                         !identical(envir, emptyenv())) {
[10:31:49.999]                         if (exists("master", mode = "list", envir = envir, 
[10:31:49.999]                           inherits = FALSE)) {
[10:31:49.999]                           master <- get("master", mode = "list", 
[10:31:49.999]                             envir = envir, inherits = FALSE)
[10:31:49.999]                           if (inherits(master, c("SOCKnode", 
[10:31:49.999]                             "SOCK0node"))) {
[10:31:49.999]                             sendCondition <<- function(cond) {
[10:31:49.999]                               data <- list(type = "VALUE", value = cond, 
[10:31:49.999]                                 success = TRUE)
[10:31:49.999]                               parallel_sendData(master, data)
[10:31:49.999]                             }
[10:31:49.999]                             return(sendCondition)
[10:31:49.999]                           }
[10:31:49.999]                         }
[10:31:49.999]                         frame <- frame + 1L
[10:31:49.999]                         envir <- sys.frame(frame)
[10:31:49.999]                       }
[10:31:49.999]                     }
[10:31:49.999]                     sendCondition <<- function(cond) NULL
[10:31:49.999]                   }
[10:31:49.999]                 })
[10:31:49.999]                 withCallingHandlers({
[10:31:49.999]                   NA
[10:31:49.999]                 }, immediateCondition = function(cond) {
[10:31:49.999]                   sendCondition <- ...future.makeSendCondition()
[10:31:49.999]                   sendCondition(cond)
[10:31:49.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:49.999]                   {
[10:31:49.999]                     inherits <- base::inherits
[10:31:49.999]                     invokeRestart <- base::invokeRestart
[10:31:49.999]                     is.null <- base::is.null
[10:31:49.999]                     muffled <- FALSE
[10:31:49.999]                     if (inherits(cond, "message")) {
[10:31:49.999]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:49.999]                       if (muffled) 
[10:31:49.999]                         invokeRestart("muffleMessage")
[10:31:49.999]                     }
[10:31:49.999]                     else if (inherits(cond, "warning")) {
[10:31:49.999]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:49.999]                       if (muffled) 
[10:31:49.999]                         invokeRestart("muffleWarning")
[10:31:49.999]                     }
[10:31:49.999]                     else if (inherits(cond, "condition")) {
[10:31:49.999]                       if (!is.null(pattern)) {
[10:31:49.999]                         computeRestarts <- base::computeRestarts
[10:31:49.999]                         grepl <- base::grepl
[10:31:49.999]                         restarts <- computeRestarts(cond)
[10:31:49.999]                         for (restart in restarts) {
[10:31:49.999]                           name <- restart$name
[10:31:49.999]                           if (is.null(name)) 
[10:31:49.999]                             next
[10:31:49.999]                           if (!grepl(pattern, name)) 
[10:31:49.999]                             next
[10:31:49.999]                           invokeRestart(restart)
[10:31:49.999]                           muffled <- TRUE
[10:31:49.999]                           break
[10:31:49.999]                         }
[10:31:49.999]                       }
[10:31:49.999]                     }
[10:31:49.999]                     invisible(muffled)
[10:31:49.999]                   }
[10:31:49.999]                   muffleCondition(cond)
[10:31:49.999]                 })
[10:31:49.999]             }))
[10:31:49.999]             future::FutureResult(value = ...future.value$value, 
[10:31:49.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:49.999]                   ...future.rng), globalenv = if (FALSE) 
[10:31:49.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:49.999]                     ...future.globalenv.names))
[10:31:49.999]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:49.999]         }, condition = base::local({
[10:31:49.999]             c <- base::c
[10:31:49.999]             inherits <- base::inherits
[10:31:49.999]             invokeRestart <- base::invokeRestart
[10:31:49.999]             length <- base::length
[10:31:49.999]             list <- base::list
[10:31:49.999]             seq.int <- base::seq.int
[10:31:49.999]             signalCondition <- base::signalCondition
[10:31:49.999]             sys.calls <- base::sys.calls
[10:31:49.999]             `[[` <- base::`[[`
[10:31:49.999]             `+` <- base::`+`
[10:31:49.999]             `<<-` <- base::`<<-`
[10:31:49.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:49.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:49.999]                   3L)]
[10:31:49.999]             }
[10:31:49.999]             function(cond) {
[10:31:49.999]                 is_error <- inherits(cond, "error")
[10:31:49.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:49.999]                   NULL)
[10:31:49.999]                 if (is_error) {
[10:31:49.999]                   sessionInformation <- function() {
[10:31:49.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:49.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:49.999]                       search = base::search(), system = base::Sys.info())
[10:31:49.999]                   }
[10:31:49.999]                   ...future.conditions[[length(...future.conditions) + 
[10:31:49.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:49.999]                     cond$call), session = sessionInformation(), 
[10:31:49.999]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:49.999]                   signalCondition(cond)
[10:31:49.999]                 }
[10:31:49.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:49.999]                 "immediateCondition"))) {
[10:31:49.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:49.999]                   ...future.conditions[[length(...future.conditions) + 
[10:31:49.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:49.999]                   if (TRUE && !signal) {
[10:31:49.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:49.999]                     {
[10:31:49.999]                       inherits <- base::inherits
[10:31:49.999]                       invokeRestart <- base::invokeRestart
[10:31:49.999]                       is.null <- base::is.null
[10:31:49.999]                       muffled <- FALSE
[10:31:49.999]                       if (inherits(cond, "message")) {
[10:31:49.999]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:49.999]                         if (muffled) 
[10:31:49.999]                           invokeRestart("muffleMessage")
[10:31:49.999]                       }
[10:31:49.999]                       else if (inherits(cond, "warning")) {
[10:31:49.999]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:49.999]                         if (muffled) 
[10:31:49.999]                           invokeRestart("muffleWarning")
[10:31:49.999]                       }
[10:31:49.999]                       else if (inherits(cond, "condition")) {
[10:31:49.999]                         if (!is.null(pattern)) {
[10:31:49.999]                           computeRestarts <- base::computeRestarts
[10:31:49.999]                           grepl <- base::grepl
[10:31:49.999]                           restarts <- computeRestarts(cond)
[10:31:49.999]                           for (restart in restarts) {
[10:31:49.999]                             name <- restart$name
[10:31:49.999]                             if (is.null(name)) 
[10:31:49.999]                               next
[10:31:49.999]                             if (!grepl(pattern, name)) 
[10:31:49.999]                               next
[10:31:49.999]                             invokeRestart(restart)
[10:31:49.999]                             muffled <- TRUE
[10:31:49.999]                             break
[10:31:49.999]                           }
[10:31:49.999]                         }
[10:31:49.999]                       }
[10:31:49.999]                       invisible(muffled)
[10:31:49.999]                     }
[10:31:49.999]                     muffleCondition(cond, pattern = "^muffle")
[10:31:49.999]                   }
[10:31:49.999]                 }
[10:31:49.999]                 else {
[10:31:49.999]                   if (TRUE) {
[10:31:49.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:49.999]                     {
[10:31:49.999]                       inherits <- base::inherits
[10:31:49.999]                       invokeRestart <- base::invokeRestart
[10:31:49.999]                       is.null <- base::is.null
[10:31:49.999]                       muffled <- FALSE
[10:31:49.999]                       if (inherits(cond, "message")) {
[10:31:49.999]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:49.999]                         if (muffled) 
[10:31:49.999]                           invokeRestart("muffleMessage")
[10:31:49.999]                       }
[10:31:49.999]                       else if (inherits(cond, "warning")) {
[10:31:49.999]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:49.999]                         if (muffled) 
[10:31:49.999]                           invokeRestart("muffleWarning")
[10:31:49.999]                       }
[10:31:49.999]                       else if (inherits(cond, "condition")) {
[10:31:49.999]                         if (!is.null(pattern)) {
[10:31:49.999]                           computeRestarts <- base::computeRestarts
[10:31:49.999]                           grepl <- base::grepl
[10:31:49.999]                           restarts <- computeRestarts(cond)
[10:31:49.999]                           for (restart in restarts) {
[10:31:49.999]                             name <- restart$name
[10:31:49.999]                             if (is.null(name)) 
[10:31:49.999]                               next
[10:31:49.999]                             if (!grepl(pattern, name)) 
[10:31:49.999]                               next
[10:31:49.999]                             invokeRestart(restart)
[10:31:49.999]                             muffled <- TRUE
[10:31:49.999]                             break
[10:31:49.999]                           }
[10:31:49.999]                         }
[10:31:49.999]                       }
[10:31:49.999]                       invisible(muffled)
[10:31:49.999]                     }
[10:31:49.999]                     muffleCondition(cond, pattern = "^muffle")
[10:31:49.999]                   }
[10:31:49.999]                 }
[10:31:49.999]             }
[10:31:49.999]         }))
[10:31:49.999]     }, error = function(ex) {
[10:31:49.999]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:49.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:49.999]                 ...future.rng), started = ...future.startTime, 
[10:31:49.999]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:49.999]             version = "1.8"), class = "FutureResult")
[10:31:49.999]     }, finally = {
[10:31:49.999]         if (!identical(...future.workdir, getwd())) 
[10:31:49.999]             setwd(...future.workdir)
[10:31:49.999]         {
[10:31:49.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:49.999]                 ...future.oldOptions$nwarnings <- NULL
[10:31:49.999]             }
[10:31:49.999]             base::options(...future.oldOptions)
[10:31:49.999]             if (.Platform$OS.type == "windows") {
[10:31:49.999]                 old_names <- names(...future.oldEnvVars)
[10:31:49.999]                 envs <- base::Sys.getenv()
[10:31:49.999]                 names <- names(envs)
[10:31:49.999]                 common <- intersect(names, old_names)
[10:31:49.999]                 added <- setdiff(names, old_names)
[10:31:49.999]                 removed <- setdiff(old_names, names)
[10:31:49.999]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:49.999]                   envs[common]]
[10:31:49.999]                 NAMES <- toupper(changed)
[10:31:49.999]                 args <- list()
[10:31:49.999]                 for (kk in seq_along(NAMES)) {
[10:31:49.999]                   name <- changed[[kk]]
[10:31:49.999]                   NAME <- NAMES[[kk]]
[10:31:49.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:49.999]                     next
[10:31:49.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:49.999]                 }
[10:31:49.999]                 NAMES <- toupper(added)
[10:31:49.999]                 for (kk in seq_along(NAMES)) {
[10:31:49.999]                   name <- added[[kk]]
[10:31:49.999]                   NAME <- NAMES[[kk]]
[10:31:49.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:49.999]                     next
[10:31:49.999]                   args[[name]] <- ""
[10:31:49.999]                 }
[10:31:49.999]                 NAMES <- toupper(removed)
[10:31:49.999]                 for (kk in seq_along(NAMES)) {
[10:31:49.999]                   name <- removed[[kk]]
[10:31:49.999]                   NAME <- NAMES[[kk]]
[10:31:49.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:49.999]                     next
[10:31:49.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:49.999]                 }
[10:31:49.999]                 if (length(args) > 0) 
[10:31:49.999]                   base::do.call(base::Sys.setenv, args = args)
[10:31:49.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:49.999]             }
[10:31:49.999]             else {
[10:31:49.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:49.999]             }
[10:31:49.999]             {
[10:31:49.999]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:49.999]                   0L) {
[10:31:49.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:49.999]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:49.999]                   base::options(opts)
[10:31:49.999]                 }
[10:31:49.999]                 {
[10:31:49.999]                   {
[10:31:49.999]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:49.999]                     NULL
[10:31:49.999]                   }
[10:31:49.999]                   options(future.plan = NULL)
[10:31:49.999]                   if (is.na(NA_character_)) 
[10:31:49.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:49.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:49.999]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:49.999]                     .init = FALSE)
[10:31:49.999]                 }
[10:31:49.999]             }
[10:31:49.999]         }
[10:31:49.999]     })
[10:31:49.999]     if (TRUE) {
[10:31:49.999]         base::sink(type = "output", split = FALSE)
[10:31:49.999]         if (TRUE) {
[10:31:49.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:49.999]         }
[10:31:49.999]         else {
[10:31:49.999]             ...future.result["stdout"] <- base::list(NULL)
[10:31:49.999]         }
[10:31:49.999]         base::close(...future.stdout)
[10:31:49.999]         ...future.stdout <- NULL
[10:31:49.999]     }
[10:31:49.999]     ...future.result$conditions <- ...future.conditions
[10:31:49.999]     ...future.result$finished <- base::Sys.time()
[10:31:49.999]     ...future.result
[10:31:49.999] }
[10:31:50.053] MultisessionFuture started
[10:31:50.054] result() for ClusterFuture ...
[10:31:50.055] receiveMessageFromWorker() for ClusterFuture ...
[10:31:50.055] - Validating connection of MultisessionFuture
[10:31:50.088] - received message: FutureResult
[10:31:50.088] - Received FutureResult
[10:31:50.088] - Erased future from FutureRegistry
[10:31:50.088] result() for ClusterFuture ...
[10:31:50.089] - result already collected: FutureResult
[10:31:50.089] result() for ClusterFuture ... done
[10:31:50.089] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:50.089] result() for ClusterFuture ... done
[10:31:50.089] result() for ClusterFuture ...
[10:31:50.089] - result already collected: FutureResult
[10:31:50.089] result() for ClusterFuture ... done
[10:31:50.090] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:31:50.094] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[10:31:50.094] future_lapply() ...
[10:31:50.099] Number of chunks: 2
[10:31:50.099] getGlobalsAndPackagesXApply() ...
[10:31:50.099]  - future.globals: TRUE
[10:31:50.099] getGlobalsAndPackages() ...
[10:31:50.099] Searching for globals...
[10:31:50.101] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:50.101] Searching for globals ... DONE
[10:31:50.101] Resolving globals: FALSE
[10:31:50.102] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:50.102] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:50.102] - globals: [1] ‘FUN’
[10:31:50.102] 
[10:31:50.103] getGlobalsAndPackages() ... DONE
[10:31:50.103]  - globals found/used: [n=1] ‘FUN’
[10:31:50.103]  - needed namespaces: [n=0] 
[10:31:50.103] Finding globals ... DONE
[10:31:50.103]  - use_args: TRUE
[10:31:50.103]  - Getting '...' globals ...
[10:31:50.104] resolve() on list ...
[10:31:50.104]  recursive: 0
[10:31:50.104]  length: 1
[10:31:50.104]  elements: ‘...’
[10:31:50.104]  length: 0 (resolved future 1)
[10:31:50.104] resolve() on list ... DONE
[10:31:50.104]    - '...' content: [n=0] 
[10:31:50.104] List of 1
[10:31:50.104]  $ ...: list()
[10:31:50.104]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:50.104]  - attr(*, "where")=List of 1
[10:31:50.104]   ..$ ...:<environment: 0x564ff50b6698> 
[10:31:50.104]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:50.104]  - attr(*, "resolved")= logi TRUE
[10:31:50.104]  - attr(*, "total_size")= num NA
[10:31:50.108]  - Getting '...' globals ... DONE
[10:31:50.108] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:50.108] List of 2
[10:31:50.108]  $ ...future.FUN:function (x)  
[10:31:50.108]  $ ...          : list()
[10:31:50.108]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:50.108]  - attr(*, "where")=List of 2
[10:31:50.108]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:50.108]   ..$ ...          :<environment: 0x564ff50b6698> 
[10:31:50.108]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:50.108]  - attr(*, "resolved")= logi FALSE
[10:31:50.108]  - attr(*, "total_size")= num 4720
[10:31:50.111] Packages to be attached in all futures: [n=0] 
[10:31:50.111] getGlobalsAndPackagesXApply() ... DONE
[10:31:50.112] Number of futures (= number of chunks): 2
[10:31:50.112] Launching 2 futures (chunks) ...
[10:31:50.112] Chunk #1 of 2 ...
[10:31:50.112]  - Finding globals in 'X' for chunk #1 ...
[10:31:50.112] getGlobalsAndPackages() ...
[10:31:50.112] Searching for globals...
[10:31:50.112] 
[10:31:50.113] Searching for globals ... DONE
[10:31:50.113] - globals: [0] <none>
[10:31:50.113] getGlobalsAndPackages() ... DONE
[10:31:50.113]    + additional globals found: [n=0] 
[10:31:50.113]    + additional namespaces needed: [n=0] 
[10:31:50.113]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:50.113]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:50.113]  - seeds: <none>
[10:31:50.114]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:50.114] getGlobalsAndPackages() ...
[10:31:50.114] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:50.114] Resolving globals: FALSE
[10:31:50.114] Tweak future expression to call with '...' arguments ...
[10:31:50.114] {
[10:31:50.114]     do.call(function(...) {
[10:31:50.114]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:50.114]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:50.114]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:50.114]             on.exit(options(oopts), add = TRUE)
[10:31:50.114]         }
[10:31:50.114]         {
[10:31:50.114]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:50.114]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:50.114]                 ...future.FUN(...future.X_jj, ...)
[10:31:50.114]             })
[10:31:50.114]         }
[10:31:50.114]     }, args = future.call.arguments)
[10:31:50.114] }
[10:31:50.115] Tweak future expression to call with '...' arguments ... DONE
[10:31:50.115] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:50.115] 
[10:31:50.115] getGlobalsAndPackages() ... DONE
[10:31:50.116] run() for ‘Future’ ...
[10:31:50.116] - state: ‘created’
[10:31:50.116] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:50.131] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:50.131] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:50.131]   - Field: ‘node’
[10:31:50.131]   - Field: ‘label’
[10:31:50.131]   - Field: ‘local’
[10:31:50.132]   - Field: ‘owner’
[10:31:50.132]   - Field: ‘envir’
[10:31:50.132]   - Field: ‘workers’
[10:31:50.132]   - Field: ‘packages’
[10:31:50.132]   - Field: ‘gc’
[10:31:50.132]   - Field: ‘conditions’
[10:31:50.132]   - Field: ‘persistent’
[10:31:50.132]   - Field: ‘expr’
[10:31:50.132]   - Field: ‘uuid’
[10:31:50.133]   - Field: ‘seed’
[10:31:50.133]   - Field: ‘version’
[10:31:50.133]   - Field: ‘result’
[10:31:50.133]   - Field: ‘asynchronous’
[10:31:50.133]   - Field: ‘calls’
[10:31:50.133]   - Field: ‘globals’
[10:31:50.133]   - Field: ‘stdout’
[10:31:50.133]   - Field: ‘earlySignal’
[10:31:50.133]   - Field: ‘lazy’
[10:31:50.134]   - Field: ‘state’
[10:31:50.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:50.134] - Launch lazy future ...
[10:31:50.134] Packages needed by the future expression (n = 0): <none>
[10:31:50.134] Packages needed by future strategies (n = 0): <none>
[10:31:50.135] {
[10:31:50.135]     {
[10:31:50.135]         {
[10:31:50.135]             ...future.startTime <- base::Sys.time()
[10:31:50.135]             {
[10:31:50.135]                 {
[10:31:50.135]                   {
[10:31:50.135]                     {
[10:31:50.135]                       base::local({
[10:31:50.135]                         has_future <- base::requireNamespace("future", 
[10:31:50.135]                           quietly = TRUE)
[10:31:50.135]                         if (has_future) {
[10:31:50.135]                           ns <- base::getNamespace("future")
[10:31:50.135]                           version <- ns[[".package"]][["version"]]
[10:31:50.135]                           if (is.null(version)) 
[10:31:50.135]                             version <- utils::packageVersion("future")
[10:31:50.135]                         }
[10:31:50.135]                         else {
[10:31:50.135]                           version <- NULL
[10:31:50.135]                         }
[10:31:50.135]                         if (!has_future || version < "1.8.0") {
[10:31:50.135]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:50.135]                             "", base::R.version$version.string), 
[10:31:50.135]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:50.135]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:50.135]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:50.135]                               "release", "version")], collapse = " "), 
[10:31:50.135]                             hostname = base::Sys.info()[["nodename"]])
[10:31:50.135]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:50.135]                             info)
[10:31:50.135]                           info <- base::paste(info, collapse = "; ")
[10:31:50.135]                           if (!has_future) {
[10:31:50.135]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:50.135]                               info)
[10:31:50.135]                           }
[10:31:50.135]                           else {
[10:31:50.135]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:50.135]                               info, version)
[10:31:50.135]                           }
[10:31:50.135]                           base::stop(msg)
[10:31:50.135]                         }
[10:31:50.135]                       })
[10:31:50.135]                     }
[10:31:50.135]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:50.135]                     base::options(mc.cores = 1L)
[10:31:50.135]                   }
[10:31:50.135]                   ...future.strategy.old <- future::plan("list")
[10:31:50.135]                   options(future.plan = NULL)
[10:31:50.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:50.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:50.135]                 }
[10:31:50.135]                 ...future.workdir <- getwd()
[10:31:50.135]             }
[10:31:50.135]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:50.135]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:50.135]         }
[10:31:50.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:50.135]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:50.135]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:50.135]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:50.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:50.135]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:50.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:50.135]             base::names(...future.oldOptions))
[10:31:50.135]     }
[10:31:50.135]     if (FALSE) {
[10:31:50.135]     }
[10:31:50.135]     else {
[10:31:50.135]         if (FALSE) {
[10:31:50.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:50.135]                 open = "w")
[10:31:50.135]         }
[10:31:50.135]         else {
[10:31:50.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:50.135]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:50.135]         }
[10:31:50.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:50.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:50.135]             base::sink(type = "output", split = FALSE)
[10:31:50.135]             base::close(...future.stdout)
[10:31:50.135]         }, add = TRUE)
[10:31:50.135]     }
[10:31:50.135]     ...future.frame <- base::sys.nframe()
[10:31:50.135]     ...future.conditions <- base::list()
[10:31:50.135]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:50.135]     if (FALSE) {
[10:31:50.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:50.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:50.135]     }
[10:31:50.135]     ...future.result <- base::tryCatch({
[10:31:50.135]         base::withCallingHandlers({
[10:31:50.135]             ...future.value <- base::withVisible(base::local({
[10:31:50.135]                 ...future.makeSendCondition <- base::local({
[10:31:50.135]                   sendCondition <- NULL
[10:31:50.135]                   function(frame = 1L) {
[10:31:50.135]                     if (is.function(sendCondition)) 
[10:31:50.135]                       return(sendCondition)
[10:31:50.135]                     ns <- getNamespace("parallel")
[10:31:50.135]                     if (exists("sendData", mode = "function", 
[10:31:50.135]                       envir = ns)) {
[10:31:50.135]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:50.135]                         envir = ns)
[10:31:50.135]                       envir <- sys.frame(frame)
[10:31:50.135]                       master <- NULL
[10:31:50.135]                       while (!identical(envir, .GlobalEnv) && 
[10:31:50.135]                         !identical(envir, emptyenv())) {
[10:31:50.135]                         if (exists("master", mode = "list", envir = envir, 
[10:31:50.135]                           inherits = FALSE)) {
[10:31:50.135]                           master <- get("master", mode = "list", 
[10:31:50.135]                             envir = envir, inherits = FALSE)
[10:31:50.135]                           if (inherits(master, c("SOCKnode", 
[10:31:50.135]                             "SOCK0node"))) {
[10:31:50.135]                             sendCondition <<- function(cond) {
[10:31:50.135]                               data <- list(type = "VALUE", value = cond, 
[10:31:50.135]                                 success = TRUE)
[10:31:50.135]                               parallel_sendData(master, data)
[10:31:50.135]                             }
[10:31:50.135]                             return(sendCondition)
[10:31:50.135]                           }
[10:31:50.135]                         }
[10:31:50.135]                         frame <- frame + 1L
[10:31:50.135]                         envir <- sys.frame(frame)
[10:31:50.135]                       }
[10:31:50.135]                     }
[10:31:50.135]                     sendCondition <<- function(cond) NULL
[10:31:50.135]                   }
[10:31:50.135]                 })
[10:31:50.135]                 withCallingHandlers({
[10:31:50.135]                   {
[10:31:50.135]                     do.call(function(...) {
[10:31:50.135]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:50.135]                       if (!identical(...future.globals.maxSize.org, 
[10:31:50.135]                         ...future.globals.maxSize)) {
[10:31:50.135]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:50.135]                         on.exit(options(oopts), add = TRUE)
[10:31:50.135]                       }
[10:31:50.135]                       {
[10:31:50.135]                         lapply(seq_along(...future.elements_ii), 
[10:31:50.135]                           FUN = function(jj) {
[10:31:50.135]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:50.135]                             ...future.FUN(...future.X_jj, ...)
[10:31:50.135]                           })
[10:31:50.135]                       }
[10:31:50.135]                     }, args = future.call.arguments)
[10:31:50.135]                   }
[10:31:50.135]                 }, immediateCondition = function(cond) {
[10:31:50.135]                   sendCondition <- ...future.makeSendCondition()
[10:31:50.135]                   sendCondition(cond)
[10:31:50.135]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:50.135]                   {
[10:31:50.135]                     inherits <- base::inherits
[10:31:50.135]                     invokeRestart <- base::invokeRestart
[10:31:50.135]                     is.null <- base::is.null
[10:31:50.135]                     muffled <- FALSE
[10:31:50.135]                     if (inherits(cond, "message")) {
[10:31:50.135]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:50.135]                       if (muffled) 
[10:31:50.135]                         invokeRestart("muffleMessage")
[10:31:50.135]                     }
[10:31:50.135]                     else if (inherits(cond, "warning")) {
[10:31:50.135]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:50.135]                       if (muffled) 
[10:31:50.135]                         invokeRestart("muffleWarning")
[10:31:50.135]                     }
[10:31:50.135]                     else if (inherits(cond, "condition")) {
[10:31:50.135]                       if (!is.null(pattern)) {
[10:31:50.135]                         computeRestarts <- base::computeRestarts
[10:31:50.135]                         grepl <- base::grepl
[10:31:50.135]                         restarts <- computeRestarts(cond)
[10:31:50.135]                         for (restart in restarts) {
[10:31:50.135]                           name <- restart$name
[10:31:50.135]                           if (is.null(name)) 
[10:31:50.135]                             next
[10:31:50.135]                           if (!grepl(pattern, name)) 
[10:31:50.135]                             next
[10:31:50.135]                           invokeRestart(restart)
[10:31:50.135]                           muffled <- TRUE
[10:31:50.135]                           break
[10:31:50.135]                         }
[10:31:50.135]                       }
[10:31:50.135]                     }
[10:31:50.135]                     invisible(muffled)
[10:31:50.135]                   }
[10:31:50.135]                   muffleCondition(cond)
[10:31:50.135]                 })
[10:31:50.135]             }))
[10:31:50.135]             future::FutureResult(value = ...future.value$value, 
[10:31:50.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:50.135]                   ...future.rng), globalenv = if (FALSE) 
[10:31:50.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:50.135]                     ...future.globalenv.names))
[10:31:50.135]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:50.135]         }, condition = base::local({
[10:31:50.135]             c <- base::c
[10:31:50.135]             inherits <- base::inherits
[10:31:50.135]             invokeRestart <- base::invokeRestart
[10:31:50.135]             length <- base::length
[10:31:50.135]             list <- base::list
[10:31:50.135]             seq.int <- base::seq.int
[10:31:50.135]             signalCondition <- base::signalCondition
[10:31:50.135]             sys.calls <- base::sys.calls
[10:31:50.135]             `[[` <- base::`[[`
[10:31:50.135]             `+` <- base::`+`
[10:31:50.135]             `<<-` <- base::`<<-`
[10:31:50.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:50.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:50.135]                   3L)]
[10:31:50.135]             }
[10:31:50.135]             function(cond) {
[10:31:50.135]                 is_error <- inherits(cond, "error")
[10:31:50.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:50.135]                   NULL)
[10:31:50.135]                 if (is_error) {
[10:31:50.135]                   sessionInformation <- function() {
[10:31:50.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:50.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:50.135]                       search = base::search(), system = base::Sys.info())
[10:31:50.135]                   }
[10:31:50.135]                   ...future.conditions[[length(...future.conditions) + 
[10:31:50.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:50.135]                     cond$call), session = sessionInformation(), 
[10:31:50.135]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:50.135]                   signalCondition(cond)
[10:31:50.135]                 }
[10:31:50.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:50.135]                 "immediateCondition"))) {
[10:31:50.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:50.135]                   ...future.conditions[[length(...future.conditions) + 
[10:31:50.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:50.135]                   if (TRUE && !signal) {
[10:31:50.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:50.135]                     {
[10:31:50.135]                       inherits <- base::inherits
[10:31:50.135]                       invokeRestart <- base::invokeRestart
[10:31:50.135]                       is.null <- base::is.null
[10:31:50.135]                       muffled <- FALSE
[10:31:50.135]                       if (inherits(cond, "message")) {
[10:31:50.135]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:50.135]                         if (muffled) 
[10:31:50.135]                           invokeRestart("muffleMessage")
[10:31:50.135]                       }
[10:31:50.135]                       else if (inherits(cond, "warning")) {
[10:31:50.135]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:50.135]                         if (muffled) 
[10:31:50.135]                           invokeRestart("muffleWarning")
[10:31:50.135]                       }
[10:31:50.135]                       else if (inherits(cond, "condition")) {
[10:31:50.135]                         if (!is.null(pattern)) {
[10:31:50.135]                           computeRestarts <- base::computeRestarts
[10:31:50.135]                           grepl <- base::grepl
[10:31:50.135]                           restarts <- computeRestarts(cond)
[10:31:50.135]                           for (restart in restarts) {
[10:31:50.135]                             name <- restart$name
[10:31:50.135]                             if (is.null(name)) 
[10:31:50.135]                               next
[10:31:50.135]                             if (!grepl(pattern, name)) 
[10:31:50.135]                               next
[10:31:50.135]                             invokeRestart(restart)
[10:31:50.135]                             muffled <- TRUE
[10:31:50.135]                             break
[10:31:50.135]                           }
[10:31:50.135]                         }
[10:31:50.135]                       }
[10:31:50.135]                       invisible(muffled)
[10:31:50.135]                     }
[10:31:50.135]                     muffleCondition(cond, pattern = "^muffle")
[10:31:50.135]                   }
[10:31:50.135]                 }
[10:31:50.135]                 else {
[10:31:50.135]                   if (TRUE) {
[10:31:50.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:50.135]                     {
[10:31:50.135]                       inherits <- base::inherits
[10:31:50.135]                       invokeRestart <- base::invokeRestart
[10:31:50.135]                       is.null <- base::is.null
[10:31:50.135]                       muffled <- FALSE
[10:31:50.135]                       if (inherits(cond, "message")) {
[10:31:50.135]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:50.135]                         if (muffled) 
[10:31:50.135]                           invokeRestart("muffleMessage")
[10:31:50.135]                       }
[10:31:50.135]                       else if (inherits(cond, "warning")) {
[10:31:50.135]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:50.135]                         if (muffled) 
[10:31:50.135]                           invokeRestart("muffleWarning")
[10:31:50.135]                       }
[10:31:50.135]                       else if (inherits(cond, "condition")) {
[10:31:50.135]                         if (!is.null(pattern)) {
[10:31:50.135]                           computeRestarts <- base::computeRestarts
[10:31:50.135]                           grepl <- base::grepl
[10:31:50.135]                           restarts <- computeRestarts(cond)
[10:31:50.135]                           for (restart in restarts) {
[10:31:50.135]                             name <- restart$name
[10:31:50.135]                             if (is.null(name)) 
[10:31:50.135]                               next
[10:31:50.135]                             if (!grepl(pattern, name)) 
[10:31:50.135]                               next
[10:31:50.135]                             invokeRestart(restart)
[10:31:50.135]                             muffled <- TRUE
[10:31:50.135]                             break
[10:31:50.135]                           }
[10:31:50.135]                         }
[10:31:50.135]                       }
[10:31:50.135]                       invisible(muffled)
[10:31:50.135]                     }
[10:31:50.135]                     muffleCondition(cond, pattern = "^muffle")
[10:31:50.135]                   }
[10:31:50.135]                 }
[10:31:50.135]             }
[10:31:50.135]         }))
[10:31:50.135]     }, error = function(ex) {
[10:31:50.135]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:50.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:50.135]                 ...future.rng), started = ...future.startTime, 
[10:31:50.135]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:50.135]             version = "1.8"), class = "FutureResult")
[10:31:50.135]     }, finally = {
[10:31:50.135]         if (!identical(...future.workdir, getwd())) 
[10:31:50.135]             setwd(...future.workdir)
[10:31:50.135]         {
[10:31:50.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:50.135]                 ...future.oldOptions$nwarnings <- NULL
[10:31:50.135]             }
[10:31:50.135]             base::options(...future.oldOptions)
[10:31:50.135]             if (.Platform$OS.type == "windows") {
[10:31:50.135]                 old_names <- names(...future.oldEnvVars)
[10:31:50.135]                 envs <- base::Sys.getenv()
[10:31:50.135]                 names <- names(envs)
[10:31:50.135]                 common <- intersect(names, old_names)
[10:31:50.135]                 added <- setdiff(names, old_names)
[10:31:50.135]                 removed <- setdiff(old_names, names)
[10:31:50.135]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:50.135]                   envs[common]]
[10:31:50.135]                 NAMES <- toupper(changed)
[10:31:50.135]                 args <- list()
[10:31:50.135]                 for (kk in seq_along(NAMES)) {
[10:31:50.135]                   name <- changed[[kk]]
[10:31:50.135]                   NAME <- NAMES[[kk]]
[10:31:50.135]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:50.135]                     next
[10:31:50.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:50.135]                 }
[10:31:50.135]                 NAMES <- toupper(added)
[10:31:50.135]                 for (kk in seq_along(NAMES)) {
[10:31:50.135]                   name <- added[[kk]]
[10:31:50.135]                   NAME <- NAMES[[kk]]
[10:31:50.135]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:50.135]                     next
[10:31:50.135]                   args[[name]] <- ""
[10:31:50.135]                 }
[10:31:50.135]                 NAMES <- toupper(removed)
[10:31:50.135]                 for (kk in seq_along(NAMES)) {
[10:31:50.135]                   name <- removed[[kk]]
[10:31:50.135]                   NAME <- NAMES[[kk]]
[10:31:50.135]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:50.135]                     next
[10:31:50.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:50.135]                 }
[10:31:50.135]                 if (length(args) > 0) 
[10:31:50.135]                   base::do.call(base::Sys.setenv, args = args)
[10:31:50.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:50.135]             }
[10:31:50.135]             else {
[10:31:50.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:50.135]             }
[10:31:50.135]             {
[10:31:50.135]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:50.135]                   0L) {
[10:31:50.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:50.135]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:50.135]                   base::options(opts)
[10:31:50.135]                 }
[10:31:50.135]                 {
[10:31:50.135]                   {
[10:31:50.135]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:50.135]                     NULL
[10:31:50.135]                   }
[10:31:50.135]                   options(future.plan = NULL)
[10:31:50.135]                   if (is.na(NA_character_)) 
[10:31:50.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:50.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:50.135]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:50.135]                     .init = FALSE)
[10:31:50.135]                 }
[10:31:50.135]             }
[10:31:50.135]         }
[10:31:50.135]     })
[10:31:50.135]     if (TRUE) {
[10:31:50.135]         base::sink(type = "output", split = FALSE)
[10:31:50.135]         if (FALSE) {
[10:31:50.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:50.135]         }
[10:31:50.135]         else {
[10:31:50.135]             ...future.result["stdout"] <- base::list(NULL)
[10:31:50.135]         }
[10:31:50.135]         base::close(...future.stdout)
[10:31:50.135]         ...future.stdout <- NULL
[10:31:50.135]     }
[10:31:50.135]     ...future.result$conditions <- ...future.conditions
[10:31:50.135]     ...future.result$finished <- base::Sys.time()
[10:31:50.135]     ...future.result
[10:31:50.135] }
[10:31:50.138] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[10:31:50.138] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[10:31:50.139] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[10:31:50.139] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:50.140] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:50.140] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:31:50.140] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:31:50.140] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:50.141] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:50.141] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:50.141] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:50.141] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[10:31:50.142] MultisessionFuture started
[10:31:50.142] - Launch lazy future ... done
[10:31:50.142] run() for ‘MultisessionFuture’ ... done
[10:31:50.143] Created future:
[10:31:50.143] MultisessionFuture:
[10:31:50.143] Label: ‘future_lapply-1’
[10:31:50.143] Expression:
[10:31:50.143] {
[10:31:50.143]     do.call(function(...) {
[10:31:50.143]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:50.143]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:50.143]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:50.143]             on.exit(options(oopts), add = TRUE)
[10:31:50.143]         }
[10:31:50.143]         {
[10:31:50.143]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:50.143]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:50.143]                 ...future.FUN(...future.X_jj, ...)
[10:31:50.143]             })
[10:31:50.143]         }
[10:31:50.143]     }, args = future.call.arguments)
[10:31:50.143] }
[10:31:50.143] Lazy evaluation: FALSE
[10:31:50.143] Asynchronous evaluation: TRUE
[10:31:50.143] Local evaluation: TRUE
[10:31:50.143] Environment: R_GlobalEnv
[10:31:50.143] Capture standard output: FALSE
[10:31:50.143] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:50.143] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:50.143] Packages: <none>
[10:31:50.143] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:50.143] Resolved: FALSE
[10:31:50.143] Value: <not collected>
[10:31:50.143] Conditions captured: <none>
[10:31:50.143] Early signaling: FALSE
[10:31:50.143] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:50.143] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:50.155] Chunk #1 of 2 ... DONE
[10:31:50.155] Chunk #2 of 2 ...
[10:31:50.155]  - Finding globals in 'X' for chunk #2 ...
[10:31:50.155] getGlobalsAndPackages() ...
[10:31:50.156] Searching for globals...
[10:31:50.156] 
[10:31:50.156] Searching for globals ... DONE
[10:31:50.156] - globals: [0] <none>
[10:31:50.156] getGlobalsAndPackages() ... DONE
[10:31:50.156]    + additional globals found: [n=0] 
[10:31:50.157]    + additional namespaces needed: [n=0] 
[10:31:50.157]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:50.157]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:50.157]  - seeds: <none>
[10:31:50.157]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:50.157] getGlobalsAndPackages() ...
[10:31:50.157] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:50.157] Resolving globals: FALSE
[10:31:50.158] Tweak future expression to call with '...' arguments ...
[10:31:50.158] {
[10:31:50.158]     do.call(function(...) {
[10:31:50.158]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:50.158]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:50.158]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:50.158]             on.exit(options(oopts), add = TRUE)
[10:31:50.158]         }
[10:31:50.158]         {
[10:31:50.158]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:50.158]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:50.158]                 ...future.FUN(...future.X_jj, ...)
[10:31:50.158]             })
[10:31:50.158]         }
[10:31:50.158]     }, args = future.call.arguments)
[10:31:50.158] }
[10:31:50.158] Tweak future expression to call with '...' arguments ... DONE
[10:31:50.158] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:50.159] 
[10:31:50.159] getGlobalsAndPackages() ... DONE
[10:31:50.159] run() for ‘Future’ ...
[10:31:50.159] - state: ‘created’
[10:31:50.159] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:50.174] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:50.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:50.175]   - Field: ‘node’
[10:31:50.175]   - Field: ‘label’
[10:31:50.175]   - Field: ‘local’
[10:31:50.175]   - Field: ‘owner’
[10:31:50.175]   - Field: ‘envir’
[10:31:50.175]   - Field: ‘workers’
[10:31:50.175]   - Field: ‘packages’
[10:31:50.175]   - Field: ‘gc’
[10:31:50.175]   - Field: ‘conditions’
[10:31:50.176]   - Field: ‘persistent’
[10:31:50.176]   - Field: ‘expr’
[10:31:50.176]   - Field: ‘uuid’
[10:31:50.176]   - Field: ‘seed’
[10:31:50.176]   - Field: ‘version’
[10:31:50.176]   - Field: ‘result’
[10:31:50.176]   - Field: ‘asynchronous’
[10:31:50.176]   - Field: ‘calls’
[10:31:50.176]   - Field: ‘globals’
[10:31:50.177]   - Field: ‘stdout’
[10:31:50.177]   - Field: ‘earlySignal’
[10:31:50.177]   - Field: ‘lazy’
[10:31:50.177]   - Field: ‘state’
[10:31:50.177] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:50.177] - Launch lazy future ...
[10:31:50.178] Packages needed by the future expression (n = 0): <none>
[10:31:50.178] Packages needed by future strategies (n = 0): <none>
[10:31:50.178] {
[10:31:50.178]     {
[10:31:50.178]         {
[10:31:50.178]             ...future.startTime <- base::Sys.time()
[10:31:50.178]             {
[10:31:50.178]                 {
[10:31:50.178]                   {
[10:31:50.178]                     {
[10:31:50.178]                       base::local({
[10:31:50.178]                         has_future <- base::requireNamespace("future", 
[10:31:50.178]                           quietly = TRUE)
[10:31:50.178]                         if (has_future) {
[10:31:50.178]                           ns <- base::getNamespace("future")
[10:31:50.178]                           version <- ns[[".package"]][["version"]]
[10:31:50.178]                           if (is.null(version)) 
[10:31:50.178]                             version <- utils::packageVersion("future")
[10:31:50.178]                         }
[10:31:50.178]                         else {
[10:31:50.178]                           version <- NULL
[10:31:50.178]                         }
[10:31:50.178]                         if (!has_future || version < "1.8.0") {
[10:31:50.178]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:50.178]                             "", base::R.version$version.string), 
[10:31:50.178]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:50.178]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:50.178]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:50.178]                               "release", "version")], collapse = " "), 
[10:31:50.178]                             hostname = base::Sys.info()[["nodename"]])
[10:31:50.178]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:50.178]                             info)
[10:31:50.178]                           info <- base::paste(info, collapse = "; ")
[10:31:50.178]                           if (!has_future) {
[10:31:50.178]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:50.178]                               info)
[10:31:50.178]                           }
[10:31:50.178]                           else {
[10:31:50.178]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:50.178]                               info, version)
[10:31:50.178]                           }
[10:31:50.178]                           base::stop(msg)
[10:31:50.178]                         }
[10:31:50.178]                       })
[10:31:50.178]                     }
[10:31:50.178]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:50.178]                     base::options(mc.cores = 1L)
[10:31:50.178]                   }
[10:31:50.178]                   ...future.strategy.old <- future::plan("list")
[10:31:50.178]                   options(future.plan = NULL)
[10:31:50.178]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:50.178]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:50.178]                 }
[10:31:50.178]                 ...future.workdir <- getwd()
[10:31:50.178]             }
[10:31:50.178]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:50.178]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:50.178]         }
[10:31:50.178]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:50.178]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:50.178]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:50.178]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:50.178]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:50.178]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:50.178]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:50.178]             base::names(...future.oldOptions))
[10:31:50.178]     }
[10:31:50.178]     if (FALSE) {
[10:31:50.178]     }
[10:31:50.178]     else {
[10:31:50.178]         if (FALSE) {
[10:31:50.178]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:50.178]                 open = "w")
[10:31:50.178]         }
[10:31:50.178]         else {
[10:31:50.178]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:50.178]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:50.178]         }
[10:31:50.178]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:50.178]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:50.178]             base::sink(type = "output", split = FALSE)
[10:31:50.178]             base::close(...future.stdout)
[10:31:50.178]         }, add = TRUE)
[10:31:50.178]     }
[10:31:50.178]     ...future.frame <- base::sys.nframe()
[10:31:50.178]     ...future.conditions <- base::list()
[10:31:50.178]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:50.178]     if (FALSE) {
[10:31:50.178]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:50.178]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:50.178]     }
[10:31:50.178]     ...future.result <- base::tryCatch({
[10:31:50.178]         base::withCallingHandlers({
[10:31:50.178]             ...future.value <- base::withVisible(base::local({
[10:31:50.178]                 ...future.makeSendCondition <- base::local({
[10:31:50.178]                   sendCondition <- NULL
[10:31:50.178]                   function(frame = 1L) {
[10:31:50.178]                     if (is.function(sendCondition)) 
[10:31:50.178]                       return(sendCondition)
[10:31:50.178]                     ns <- getNamespace("parallel")
[10:31:50.178]                     if (exists("sendData", mode = "function", 
[10:31:50.178]                       envir = ns)) {
[10:31:50.178]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:50.178]                         envir = ns)
[10:31:50.178]                       envir <- sys.frame(frame)
[10:31:50.178]                       master <- NULL
[10:31:50.178]                       while (!identical(envir, .GlobalEnv) && 
[10:31:50.178]                         !identical(envir, emptyenv())) {
[10:31:50.178]                         if (exists("master", mode = "list", envir = envir, 
[10:31:50.178]                           inherits = FALSE)) {
[10:31:50.178]                           master <- get("master", mode = "list", 
[10:31:50.178]                             envir = envir, inherits = FALSE)
[10:31:50.178]                           if (inherits(master, c("SOCKnode", 
[10:31:50.178]                             "SOCK0node"))) {
[10:31:50.178]                             sendCondition <<- function(cond) {
[10:31:50.178]                               data <- list(type = "VALUE", value = cond, 
[10:31:50.178]                                 success = TRUE)
[10:31:50.178]                               parallel_sendData(master, data)
[10:31:50.178]                             }
[10:31:50.178]                             return(sendCondition)
[10:31:50.178]                           }
[10:31:50.178]                         }
[10:31:50.178]                         frame <- frame + 1L
[10:31:50.178]                         envir <- sys.frame(frame)
[10:31:50.178]                       }
[10:31:50.178]                     }
[10:31:50.178]                     sendCondition <<- function(cond) NULL
[10:31:50.178]                   }
[10:31:50.178]                 })
[10:31:50.178]                 withCallingHandlers({
[10:31:50.178]                   {
[10:31:50.178]                     do.call(function(...) {
[10:31:50.178]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:50.178]                       if (!identical(...future.globals.maxSize.org, 
[10:31:50.178]                         ...future.globals.maxSize)) {
[10:31:50.178]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:50.178]                         on.exit(options(oopts), add = TRUE)
[10:31:50.178]                       }
[10:31:50.178]                       {
[10:31:50.178]                         lapply(seq_along(...future.elements_ii), 
[10:31:50.178]                           FUN = function(jj) {
[10:31:50.178]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:50.178]                             ...future.FUN(...future.X_jj, ...)
[10:31:50.178]                           })
[10:31:50.178]                       }
[10:31:50.178]                     }, args = future.call.arguments)
[10:31:50.178]                   }
[10:31:50.178]                 }, immediateCondition = function(cond) {
[10:31:50.178]                   sendCondition <- ...future.makeSendCondition()
[10:31:50.178]                   sendCondition(cond)
[10:31:50.178]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:50.178]                   {
[10:31:50.178]                     inherits <- base::inherits
[10:31:50.178]                     invokeRestart <- base::invokeRestart
[10:31:50.178]                     is.null <- base::is.null
[10:31:50.178]                     muffled <- FALSE
[10:31:50.178]                     if (inherits(cond, "message")) {
[10:31:50.178]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:50.178]                       if (muffled) 
[10:31:50.178]                         invokeRestart("muffleMessage")
[10:31:50.178]                     }
[10:31:50.178]                     else if (inherits(cond, "warning")) {
[10:31:50.178]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:50.178]                       if (muffled) 
[10:31:50.178]                         invokeRestart("muffleWarning")
[10:31:50.178]                     }
[10:31:50.178]                     else if (inherits(cond, "condition")) {
[10:31:50.178]                       if (!is.null(pattern)) {
[10:31:50.178]                         computeRestarts <- base::computeRestarts
[10:31:50.178]                         grepl <- base::grepl
[10:31:50.178]                         restarts <- computeRestarts(cond)
[10:31:50.178]                         for (restart in restarts) {
[10:31:50.178]                           name <- restart$name
[10:31:50.178]                           if (is.null(name)) 
[10:31:50.178]                             next
[10:31:50.178]                           if (!grepl(pattern, name)) 
[10:31:50.178]                             next
[10:31:50.178]                           invokeRestart(restart)
[10:31:50.178]                           muffled <- TRUE
[10:31:50.178]                           break
[10:31:50.178]                         }
[10:31:50.178]                       }
[10:31:50.178]                     }
[10:31:50.178]                     invisible(muffled)
[10:31:50.178]                   }
[10:31:50.178]                   muffleCondition(cond)
[10:31:50.178]                 })
[10:31:50.178]             }))
[10:31:50.178]             future::FutureResult(value = ...future.value$value, 
[10:31:50.178]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:50.178]                   ...future.rng), globalenv = if (FALSE) 
[10:31:50.178]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:50.178]                     ...future.globalenv.names))
[10:31:50.178]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:50.178]         }, condition = base::local({
[10:31:50.178]             c <- base::c
[10:31:50.178]             inherits <- base::inherits
[10:31:50.178]             invokeRestart <- base::invokeRestart
[10:31:50.178]             length <- base::length
[10:31:50.178]             list <- base::list
[10:31:50.178]             seq.int <- base::seq.int
[10:31:50.178]             signalCondition <- base::signalCondition
[10:31:50.178]             sys.calls <- base::sys.calls
[10:31:50.178]             `[[` <- base::`[[`
[10:31:50.178]             `+` <- base::`+`
[10:31:50.178]             `<<-` <- base::`<<-`
[10:31:50.178]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:50.178]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:50.178]                   3L)]
[10:31:50.178]             }
[10:31:50.178]             function(cond) {
[10:31:50.178]                 is_error <- inherits(cond, "error")
[10:31:50.178]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:50.178]                   NULL)
[10:31:50.178]                 if (is_error) {
[10:31:50.178]                   sessionInformation <- function() {
[10:31:50.178]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:50.178]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:50.178]                       search = base::search(), system = base::Sys.info())
[10:31:50.178]                   }
[10:31:50.178]                   ...future.conditions[[length(...future.conditions) + 
[10:31:50.178]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:50.178]                     cond$call), session = sessionInformation(), 
[10:31:50.178]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:50.178]                   signalCondition(cond)
[10:31:50.178]                 }
[10:31:50.178]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:50.178]                 "immediateCondition"))) {
[10:31:50.178]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:50.178]                   ...future.conditions[[length(...future.conditions) + 
[10:31:50.178]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:50.178]                   if (TRUE && !signal) {
[10:31:50.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:50.178]                     {
[10:31:50.178]                       inherits <- base::inherits
[10:31:50.178]                       invokeRestart <- base::invokeRestart
[10:31:50.178]                       is.null <- base::is.null
[10:31:50.178]                       muffled <- FALSE
[10:31:50.178]                       if (inherits(cond, "message")) {
[10:31:50.178]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:50.178]                         if (muffled) 
[10:31:50.178]                           invokeRestart("muffleMessage")
[10:31:50.178]                       }
[10:31:50.178]                       else if (inherits(cond, "warning")) {
[10:31:50.178]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:50.178]                         if (muffled) 
[10:31:50.178]                           invokeRestart("muffleWarning")
[10:31:50.178]                       }
[10:31:50.178]                       else if (inherits(cond, "condition")) {
[10:31:50.178]                         if (!is.null(pattern)) {
[10:31:50.178]                           computeRestarts <- base::computeRestarts
[10:31:50.178]                           grepl <- base::grepl
[10:31:50.178]                           restarts <- computeRestarts(cond)
[10:31:50.178]                           for (restart in restarts) {
[10:31:50.178]                             name <- restart$name
[10:31:50.178]                             if (is.null(name)) 
[10:31:50.178]                               next
[10:31:50.178]                             if (!grepl(pattern, name)) 
[10:31:50.178]                               next
[10:31:50.178]                             invokeRestart(restart)
[10:31:50.178]                             muffled <- TRUE
[10:31:50.178]                             break
[10:31:50.178]                           }
[10:31:50.178]                         }
[10:31:50.178]                       }
[10:31:50.178]                       invisible(muffled)
[10:31:50.178]                     }
[10:31:50.178]                     muffleCondition(cond, pattern = "^muffle")
[10:31:50.178]                   }
[10:31:50.178]                 }
[10:31:50.178]                 else {
[10:31:50.178]                   if (TRUE) {
[10:31:50.178]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:50.178]                     {
[10:31:50.178]                       inherits <- base::inherits
[10:31:50.178]                       invokeRestart <- base::invokeRestart
[10:31:50.178]                       is.null <- base::is.null
[10:31:50.178]                       muffled <- FALSE
[10:31:50.178]                       if (inherits(cond, "message")) {
[10:31:50.178]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:50.178]                         if (muffled) 
[10:31:50.178]                           invokeRestart("muffleMessage")
[10:31:50.178]                       }
[10:31:50.178]                       else if (inherits(cond, "warning")) {
[10:31:50.178]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:50.178]                         if (muffled) 
[10:31:50.178]                           invokeRestart("muffleWarning")
[10:31:50.178]                       }
[10:31:50.178]                       else if (inherits(cond, "condition")) {
[10:31:50.178]                         if (!is.null(pattern)) {
[10:31:50.178]                           computeRestarts <- base::computeRestarts
[10:31:50.178]                           grepl <- base::grepl
[10:31:50.178]                           restarts <- computeRestarts(cond)
[10:31:50.178]                           for (restart in restarts) {
[10:31:50.178]                             name <- restart$name
[10:31:50.178]                             if (is.null(name)) 
[10:31:50.178]                               next
[10:31:50.178]                             if (!grepl(pattern, name)) 
[10:31:50.178]                               next
[10:31:50.178]                             invokeRestart(restart)
[10:31:50.178]                             muffled <- TRUE
[10:31:50.178]                             break
[10:31:50.178]                           }
[10:31:50.178]                         }
[10:31:50.178]                       }
[10:31:50.178]                       invisible(muffled)
[10:31:50.178]                     }
[10:31:50.178]                     muffleCondition(cond, pattern = "^muffle")
[10:31:50.178]                   }
[10:31:50.178]                 }
[10:31:50.178]             }
[10:31:50.178]         }))
[10:31:50.178]     }, error = function(ex) {
[10:31:50.178]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:50.178]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:50.178]                 ...future.rng), started = ...future.startTime, 
[10:31:50.178]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:50.178]             version = "1.8"), class = "FutureResult")
[10:31:50.178]     }, finally = {
[10:31:50.178]         if (!identical(...future.workdir, getwd())) 
[10:31:50.178]             setwd(...future.workdir)
[10:31:50.178]         {
[10:31:50.178]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:50.178]                 ...future.oldOptions$nwarnings <- NULL
[10:31:50.178]             }
[10:31:50.178]             base::options(...future.oldOptions)
[10:31:50.178]             if (.Platform$OS.type == "windows") {
[10:31:50.178]                 old_names <- names(...future.oldEnvVars)
[10:31:50.178]                 envs <- base::Sys.getenv()
[10:31:50.178]                 names <- names(envs)
[10:31:50.178]                 common <- intersect(names, old_names)
[10:31:50.178]                 added <- setdiff(names, old_names)
[10:31:50.178]                 removed <- setdiff(old_names, names)
[10:31:50.178]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:50.178]                   envs[common]]
[10:31:50.178]                 NAMES <- toupper(changed)
[10:31:50.178]                 args <- list()
[10:31:50.178]                 for (kk in seq_along(NAMES)) {
[10:31:50.178]                   name <- changed[[kk]]
[10:31:50.178]                   NAME <- NAMES[[kk]]
[10:31:50.178]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:50.178]                     next
[10:31:50.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:50.178]                 }
[10:31:50.178]                 NAMES <- toupper(added)
[10:31:50.178]                 for (kk in seq_along(NAMES)) {
[10:31:50.178]                   name <- added[[kk]]
[10:31:50.178]                   NAME <- NAMES[[kk]]
[10:31:50.178]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:50.178]                     next
[10:31:50.178]                   args[[name]] <- ""
[10:31:50.178]                 }
[10:31:50.178]                 NAMES <- toupper(removed)
[10:31:50.178]                 for (kk in seq_along(NAMES)) {
[10:31:50.178]                   name <- removed[[kk]]
[10:31:50.178]                   NAME <- NAMES[[kk]]
[10:31:50.178]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:50.178]                     next
[10:31:50.178]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:50.178]                 }
[10:31:50.178]                 if (length(args) > 0) 
[10:31:50.178]                   base::do.call(base::Sys.setenv, args = args)
[10:31:50.178]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:50.178]             }
[10:31:50.178]             else {
[10:31:50.178]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:50.178]             }
[10:31:50.178]             {
[10:31:50.178]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:50.178]                   0L) {
[10:31:50.178]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:50.178]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:50.178]                   base::options(opts)
[10:31:50.178]                 }
[10:31:50.178]                 {
[10:31:50.178]                   {
[10:31:50.178]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:50.178]                     NULL
[10:31:50.178]                   }
[10:31:50.178]                   options(future.plan = NULL)
[10:31:50.178]                   if (is.na(NA_character_)) 
[10:31:50.178]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:50.178]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:50.178]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:50.178]                     .init = FALSE)
[10:31:50.178]                 }
[10:31:50.178]             }
[10:31:50.178]         }
[10:31:50.178]     })
[10:31:50.178]     if (TRUE) {
[10:31:50.178]         base::sink(type = "output", split = FALSE)
[10:31:50.178]         if (FALSE) {
[10:31:50.178]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:50.178]         }
[10:31:50.178]         else {
[10:31:50.178]             ...future.result["stdout"] <- base::list(NULL)
[10:31:50.178]         }
[10:31:50.178]         base::close(...future.stdout)
[10:31:50.178]         ...future.stdout <- NULL
[10:31:50.178]     }
[10:31:50.178]     ...future.result$conditions <- ...future.conditions
[10:31:50.178]     ...future.result$finished <- base::Sys.time()
[10:31:50.178]     ...future.result
[10:31:50.178] }
[10:31:50.234] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[10:31:50.234] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[10:31:50.235] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[10:31:50.235] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:31:50.235] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:31:50.236] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:31:50.236] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:31:50.236] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:50.236] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:50.237] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:50.237] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:50.237] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[10:31:50.238] MultisessionFuture started
[10:31:50.238] - Launch lazy future ... done
[10:31:50.238] run() for ‘MultisessionFuture’ ... done
[10:31:50.238] Created future:
[10:31:50.238] MultisessionFuture:
[10:31:50.238] Label: ‘future_lapply-2’
[10:31:50.238] Expression:
[10:31:50.238] {
[10:31:50.238]     do.call(function(...) {
[10:31:50.238]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:50.238]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:50.238]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:50.238]             on.exit(options(oopts), add = TRUE)
[10:31:50.238]         }
[10:31:50.238]         {
[10:31:50.238]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:50.238]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:50.238]                 ...future.FUN(...future.X_jj, ...)
[10:31:50.238]             })
[10:31:50.238]         }
[10:31:50.238]     }, args = future.call.arguments)
[10:31:50.238] }
[10:31:50.238] Lazy evaluation: FALSE
[10:31:50.238] Asynchronous evaluation: TRUE
[10:31:50.238] Local evaluation: TRUE
[10:31:50.238] Environment: R_GlobalEnv
[10:31:50.238] Capture standard output: FALSE
[10:31:50.238] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:50.238] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:50.238] Packages: <none>
[10:31:50.238] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:50.238] Resolved: FALSE
[10:31:50.238] Value: <not collected>
[10:31:50.238] Conditions captured: <none>
[10:31:50.238] Early signaling: FALSE
[10:31:50.238] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:50.238] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:50.250] Chunk #2 of 2 ... DONE
[10:31:50.250] Launching 2 futures (chunks) ... DONE
[10:31:50.250] Resolving 2 futures (chunks) ...
[10:31:50.251] resolve() on list ...
[10:31:50.251]  recursive: 0
[10:31:50.251]  length: 2
[10:31:50.251] 
[10:31:50.327] receiveMessageFromWorker() for ClusterFuture ...
[10:31:50.327] - Validating connection of MultisessionFuture
[10:31:50.327] - received message: FutureResult
[10:31:50.327] - Received FutureResult
[10:31:50.327] - Erased future from FutureRegistry
[10:31:50.327] result() for ClusterFuture ...
[10:31:50.327] - result already collected: FutureResult
[10:31:50.327] result() for ClusterFuture ... done
[10:31:50.328] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:50.328] Future #2
[10:31:50.328] result() for ClusterFuture ...
[10:31:50.328] - result already collected: FutureResult
[10:31:50.328] result() for ClusterFuture ... done
[10:31:50.328] result() for ClusterFuture ...
[10:31:50.328] - result already collected: FutureResult
[10:31:50.328] result() for ClusterFuture ... done
[10:31:50.328] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:50.328] - nx: 2
[10:31:50.328] - relay: TRUE
[10:31:50.329] - stdout: TRUE
[10:31:50.329] - signal: TRUE
[10:31:50.329] - resignal: FALSE
[10:31:50.329] - force: TRUE
[10:31:50.329] - relayed: [n=2] FALSE, FALSE
[10:31:50.329] - queued futures: [n=2] FALSE, FALSE
[10:31:50.329]  - until=1
[10:31:50.329]  - relaying element #1
[10:31:50.329] - relayed: [n=2] FALSE, FALSE
[10:31:50.329] - queued futures: [n=2] FALSE, TRUE
[10:31:50.330] signalConditionsASAP(NULL, pos=2) ... done
[10:31:50.330]  length: 1 (resolved future 2)
[10:31:50.693] receiveMessageFromWorker() for ClusterFuture ...
[10:31:50.694] - Validating connection of MultisessionFuture
[10:31:50.694] - received message: FutureResult
[10:31:50.694] - Received FutureResult
[10:31:50.694] - Erased future from FutureRegistry
[10:31:50.694] result() for ClusterFuture ...
[10:31:50.694] - result already collected: FutureResult
[10:31:50.694] result() for ClusterFuture ... done
[10:31:50.695] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:50.695] Future #1
[10:31:50.695] result() for ClusterFuture ...
[10:31:50.695] - result already collected: FutureResult
[10:31:50.695] result() for ClusterFuture ... done
[10:31:50.695] result() for ClusterFuture ...
[10:31:50.695] - result already collected: FutureResult
[10:31:50.695] result() for ClusterFuture ... done
[10:31:50.695] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:50.695] - nx: 2
[10:31:50.695] - relay: TRUE
[10:31:50.695] - stdout: TRUE
[10:31:50.696] - signal: TRUE
[10:31:50.696] - resignal: FALSE
[10:31:50.696] - force: TRUE
[10:31:50.696] - relayed: [n=2] FALSE, FALSE
[10:31:50.696] - queued futures: [n=2] FALSE, TRUE
[10:31:50.696]  - until=1
[10:31:50.696]  - relaying element #1
[10:31:50.696] result() for ClusterFuture ...
[10:31:50.696] - result already collected: FutureResult
[10:31:50.696] result() for ClusterFuture ... done
[10:31:50.696] result() for ClusterFuture ...
[10:31:50.697] - result already collected: FutureResult
[10:31:50.697] result() for ClusterFuture ... done
[10:31:50.697] result() for ClusterFuture ...
[10:31:50.697] - result already collected: FutureResult
[10:31:50.697] result() for ClusterFuture ... done
[10:31:50.697] result() for ClusterFuture ...
[10:31:50.697] - result already collected: FutureResult
[10:31:50.697] result() for ClusterFuture ... done
[10:31:50.697] - relayed: [n=2] TRUE, FALSE
[10:31:50.697] - queued futures: [n=2] TRUE, TRUE
[10:31:50.697] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:50.698]  length: 0 (resolved future 1)
[10:31:50.698] Relaying remaining futures
[10:31:50.698] signalConditionsASAP(NULL, pos=0) ...
[10:31:50.698] - nx: 2
[10:31:50.698] - relay: TRUE
[10:31:50.698] - stdout: TRUE
[10:31:50.698] - signal: TRUE
[10:31:50.698] - resignal: FALSE
[10:31:50.698] - force: TRUE
[10:31:50.698] - relayed: [n=2] TRUE, FALSE
[10:31:50.698] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:50.699]  - relaying element #2
[10:31:50.699] result() for ClusterFuture ...
[10:31:50.699] - result already collected: FutureResult
[10:31:50.699] result() for ClusterFuture ... done
[10:31:50.699] result() for ClusterFuture ...
[10:31:50.699] - result already collected: FutureResult
[10:31:50.699] result() for ClusterFuture ... done
[10:31:50.699] result() for ClusterFuture ...
[10:31:50.699] - result already collected: FutureResult
[10:31:50.699] result() for ClusterFuture ... done
[10:31:50.699] result() for ClusterFuture ...
[10:31:50.700] - result already collected: FutureResult
[10:31:50.700] result() for ClusterFuture ... done
[10:31:50.700] - relayed: [n=2] TRUE, TRUE
[10:31:50.700] - queued futures: [n=2] TRUE, TRUE
[10:31:50.700] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:31:50.700] resolve() on list ... DONE
[10:31:50.700] result() for ClusterFuture ...
[10:31:50.700] - result already collected: FutureResult
[10:31:50.700] result() for ClusterFuture ... done
[10:31:50.700] result() for ClusterFuture ...
[10:31:50.700] - result already collected: FutureResult
[10:31:50.700] result() for ClusterFuture ... done
[10:31:50.701] result() for ClusterFuture ...
[10:31:50.701] - result already collected: FutureResult
[10:31:50.701] result() for ClusterFuture ... done
[10:31:50.701] result() for ClusterFuture ...
[10:31:50.701] - result already collected: FutureResult
[10:31:50.701] result() for ClusterFuture ... done
[10:31:50.701]  - Number of value chunks collected: 2
[10:31:50.701] Resolving 2 futures (chunks) ... DONE
[10:31:50.701] Reducing values from 2 chunks ...
[10:31:50.701]  - Number of values collected after concatenation: 2
[10:31:50.702]  - Number of values expected: 2
[10:31:50.702] Reducing values from 2 chunks ... DONE
[10:31:50.702] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[10:31:50.702] future_lapply() ...
[10:31:50.707] Number of chunks: 2
[10:31:50.707] getGlobalsAndPackagesXApply() ...
[10:31:50.707]  - future.globals: TRUE
[10:31:50.707] getGlobalsAndPackages() ...
[10:31:50.707] Searching for globals...
[10:31:50.708] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:50.708] Searching for globals ... DONE
[10:31:50.709] Resolving globals: FALSE
[10:31:50.709] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:50.709] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:50.709] - globals: [1] ‘FUN’
[10:31:50.710] 
[10:31:50.710] getGlobalsAndPackages() ... DONE
[10:31:50.710]  - globals found/used: [n=1] ‘FUN’
[10:31:50.710]  - needed namespaces: [n=0] 
[10:31:50.710] Finding globals ... DONE
[10:31:50.710]  - use_args: TRUE
[10:31:50.710]  - Getting '...' globals ...
[10:31:50.710] resolve() on list ...
[10:31:50.711]  recursive: 0
[10:31:50.711]  length: 1
[10:31:50.711]  elements: ‘...’
[10:31:50.711]  length: 0 (resolved future 1)
[10:31:50.711] resolve() on list ... DONE
[10:31:50.711]    - '...' content: [n=0] 
[10:31:50.711] List of 1
[10:31:50.711]  $ ...: list()
[10:31:50.711]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:50.711]  - attr(*, "where")=List of 1
[10:31:50.711]   ..$ ...:<environment: 0x564ff35285f8> 
[10:31:50.711]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:50.711]  - attr(*, "resolved")= logi TRUE
[10:31:50.711]  - attr(*, "total_size")= num NA
[10:31:50.714]  - Getting '...' globals ... DONE
[10:31:50.714] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:50.714] List of 2
[10:31:50.714]  $ ...future.FUN:function (x)  
[10:31:50.714]  $ ...          : list()
[10:31:50.714]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:50.714]  - attr(*, "where")=List of 2
[10:31:50.714]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:50.714]   ..$ ...          :<environment: 0x564ff35285f8> 
[10:31:50.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:50.714]  - attr(*, "resolved")= logi FALSE
[10:31:50.714]  - attr(*, "total_size")= num 4720
[10:31:50.717] Packages to be attached in all futures: [n=0] 
[10:31:50.717] getGlobalsAndPackagesXApply() ... DONE
[10:31:50.717] Number of futures (= number of chunks): 2
[10:31:50.717] Launching 2 futures (chunks) ...
[10:31:50.717] Chunk #1 of 2 ...
[10:31:50.717]  - Finding globals in 'X' for chunk #1 ...
[10:31:50.717] getGlobalsAndPackages() ...
[10:31:50.717] Searching for globals...
[10:31:50.718] 
[10:31:50.718] Searching for globals ... DONE
[10:31:50.718] - globals: [0] <none>
[10:31:50.718] getGlobalsAndPackages() ... DONE
[10:31:50.718]    + additional globals found: [n=0] 
[10:31:50.718]    + additional namespaces needed: [n=0] 
[10:31:50.718]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:50.718]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:50.718]  - seeds: <none>
[10:31:50.718]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:50.719] getGlobalsAndPackages() ...
[10:31:50.719] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:50.719] Resolving globals: FALSE
[10:31:50.719] Tweak future expression to call with '...' arguments ...
[10:31:50.719] {
[10:31:50.719]     do.call(function(...) {
[10:31:50.719]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:50.719]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:50.719]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:50.719]             on.exit(options(oopts), add = TRUE)
[10:31:50.719]         }
[10:31:50.719]         {
[10:31:50.719]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:50.719]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:50.719]                 ...future.FUN(...future.X_jj, ...)
[10:31:50.719]             })
[10:31:50.719]         }
[10:31:50.719]     }, args = future.call.arguments)
[10:31:50.719] }
[10:31:50.719] Tweak future expression to call with '...' arguments ... DONE
[10:31:50.720] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:50.720] 
[10:31:50.720] getGlobalsAndPackages() ... DONE
[10:31:50.720] run() for ‘Future’ ...
[10:31:50.720] - state: ‘created’
[10:31:50.720] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:50.734] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:50.734] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:50.734]   - Field: ‘node’
[10:31:50.735]   - Field: ‘label’
[10:31:50.735]   - Field: ‘local’
[10:31:50.735]   - Field: ‘owner’
[10:31:50.735]   - Field: ‘envir’
[10:31:50.735]   - Field: ‘workers’
[10:31:50.735]   - Field: ‘packages’
[10:31:50.735]   - Field: ‘gc’
[10:31:50.735]   - Field: ‘conditions’
[10:31:50.735]   - Field: ‘persistent’
[10:31:50.735]   - Field: ‘expr’
[10:31:50.735]   - Field: ‘uuid’
[10:31:50.736]   - Field: ‘seed’
[10:31:50.736]   - Field: ‘version’
[10:31:50.736]   - Field: ‘result’
[10:31:50.736]   - Field: ‘asynchronous’
[10:31:50.736]   - Field: ‘calls’
[10:31:50.736]   - Field: ‘globals’
[10:31:50.736]   - Field: ‘stdout’
[10:31:50.736]   - Field: ‘earlySignal’
[10:31:50.736]   - Field: ‘lazy’
[10:31:50.736]   - Field: ‘state’
[10:31:50.736] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:50.737] - Launch lazy future ...
[10:31:50.737] Packages needed by the future expression (n = 0): <none>
[10:31:50.737] Packages needed by future strategies (n = 0): <none>
[10:31:50.737] {
[10:31:50.737]     {
[10:31:50.737]         {
[10:31:50.737]             ...future.startTime <- base::Sys.time()
[10:31:50.737]             {
[10:31:50.737]                 {
[10:31:50.737]                   {
[10:31:50.737]                     {
[10:31:50.737]                       base::local({
[10:31:50.737]                         has_future <- base::requireNamespace("future", 
[10:31:50.737]                           quietly = TRUE)
[10:31:50.737]                         if (has_future) {
[10:31:50.737]                           ns <- base::getNamespace("future")
[10:31:50.737]                           version <- ns[[".package"]][["version"]]
[10:31:50.737]                           if (is.null(version)) 
[10:31:50.737]                             version <- utils::packageVersion("future")
[10:31:50.737]                         }
[10:31:50.737]                         else {
[10:31:50.737]                           version <- NULL
[10:31:50.737]                         }
[10:31:50.737]                         if (!has_future || version < "1.8.0") {
[10:31:50.737]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:50.737]                             "", base::R.version$version.string), 
[10:31:50.737]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:50.737]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:50.737]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:50.737]                               "release", "version")], collapse = " "), 
[10:31:50.737]                             hostname = base::Sys.info()[["nodename"]])
[10:31:50.737]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:50.737]                             info)
[10:31:50.737]                           info <- base::paste(info, collapse = "; ")
[10:31:50.737]                           if (!has_future) {
[10:31:50.737]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:50.737]                               info)
[10:31:50.737]                           }
[10:31:50.737]                           else {
[10:31:50.737]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:50.737]                               info, version)
[10:31:50.737]                           }
[10:31:50.737]                           base::stop(msg)
[10:31:50.737]                         }
[10:31:50.737]                       })
[10:31:50.737]                     }
[10:31:50.737]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:50.737]                     base::options(mc.cores = 1L)
[10:31:50.737]                   }
[10:31:50.737]                   ...future.strategy.old <- future::plan("list")
[10:31:50.737]                   options(future.plan = NULL)
[10:31:50.737]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:50.737]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:50.737]                 }
[10:31:50.737]                 ...future.workdir <- getwd()
[10:31:50.737]             }
[10:31:50.737]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:50.737]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:50.737]         }
[10:31:50.737]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:50.737]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:50.737]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:50.737]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:50.737]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:50.737]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:50.737]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:50.737]             base::names(...future.oldOptions))
[10:31:50.737]     }
[10:31:50.737]     if (FALSE) {
[10:31:50.737]     }
[10:31:50.737]     else {
[10:31:50.737]         if (TRUE) {
[10:31:50.737]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:50.737]                 open = "w")
[10:31:50.737]         }
[10:31:50.737]         else {
[10:31:50.737]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:50.737]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:50.737]         }
[10:31:50.737]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:50.737]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:50.737]             base::sink(type = "output", split = FALSE)
[10:31:50.737]             base::close(...future.stdout)
[10:31:50.737]         }, add = TRUE)
[10:31:50.737]     }
[10:31:50.737]     ...future.frame <- base::sys.nframe()
[10:31:50.737]     ...future.conditions <- base::list()
[10:31:50.737]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:50.737]     if (FALSE) {
[10:31:50.737]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:50.737]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:50.737]     }
[10:31:50.737]     ...future.result <- base::tryCatch({
[10:31:50.737]         base::withCallingHandlers({
[10:31:50.737]             ...future.value <- base::withVisible(base::local({
[10:31:50.737]                 ...future.makeSendCondition <- base::local({
[10:31:50.737]                   sendCondition <- NULL
[10:31:50.737]                   function(frame = 1L) {
[10:31:50.737]                     if (is.function(sendCondition)) 
[10:31:50.737]                       return(sendCondition)
[10:31:50.737]                     ns <- getNamespace("parallel")
[10:31:50.737]                     if (exists("sendData", mode = "function", 
[10:31:50.737]                       envir = ns)) {
[10:31:50.737]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:50.737]                         envir = ns)
[10:31:50.737]                       envir <- sys.frame(frame)
[10:31:50.737]                       master <- NULL
[10:31:50.737]                       while (!identical(envir, .GlobalEnv) && 
[10:31:50.737]                         !identical(envir, emptyenv())) {
[10:31:50.737]                         if (exists("master", mode = "list", envir = envir, 
[10:31:50.737]                           inherits = FALSE)) {
[10:31:50.737]                           master <- get("master", mode = "list", 
[10:31:50.737]                             envir = envir, inherits = FALSE)
[10:31:50.737]                           if (inherits(master, c("SOCKnode", 
[10:31:50.737]                             "SOCK0node"))) {
[10:31:50.737]                             sendCondition <<- function(cond) {
[10:31:50.737]                               data <- list(type = "VALUE", value = cond, 
[10:31:50.737]                                 success = TRUE)
[10:31:50.737]                               parallel_sendData(master, data)
[10:31:50.737]                             }
[10:31:50.737]                             return(sendCondition)
[10:31:50.737]                           }
[10:31:50.737]                         }
[10:31:50.737]                         frame <- frame + 1L
[10:31:50.737]                         envir <- sys.frame(frame)
[10:31:50.737]                       }
[10:31:50.737]                     }
[10:31:50.737]                     sendCondition <<- function(cond) NULL
[10:31:50.737]                   }
[10:31:50.737]                 })
[10:31:50.737]                 withCallingHandlers({
[10:31:50.737]                   {
[10:31:50.737]                     do.call(function(...) {
[10:31:50.737]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:50.737]                       if (!identical(...future.globals.maxSize.org, 
[10:31:50.737]                         ...future.globals.maxSize)) {
[10:31:50.737]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:50.737]                         on.exit(options(oopts), add = TRUE)
[10:31:50.737]                       }
[10:31:50.737]                       {
[10:31:50.737]                         lapply(seq_along(...future.elements_ii), 
[10:31:50.737]                           FUN = function(jj) {
[10:31:50.737]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:50.737]                             ...future.FUN(...future.X_jj, ...)
[10:31:50.737]                           })
[10:31:50.737]                       }
[10:31:50.737]                     }, args = future.call.arguments)
[10:31:50.737]                   }
[10:31:50.737]                 }, immediateCondition = function(cond) {
[10:31:50.737]                   sendCondition <- ...future.makeSendCondition()
[10:31:50.737]                   sendCondition(cond)
[10:31:50.737]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:50.737]                   {
[10:31:50.737]                     inherits <- base::inherits
[10:31:50.737]                     invokeRestart <- base::invokeRestart
[10:31:50.737]                     is.null <- base::is.null
[10:31:50.737]                     muffled <- FALSE
[10:31:50.737]                     if (inherits(cond, "message")) {
[10:31:50.737]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:50.737]                       if (muffled) 
[10:31:50.737]                         invokeRestart("muffleMessage")
[10:31:50.737]                     }
[10:31:50.737]                     else if (inherits(cond, "warning")) {
[10:31:50.737]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:50.737]                       if (muffled) 
[10:31:50.737]                         invokeRestart("muffleWarning")
[10:31:50.737]                     }
[10:31:50.737]                     else if (inherits(cond, "condition")) {
[10:31:50.737]                       if (!is.null(pattern)) {
[10:31:50.737]                         computeRestarts <- base::computeRestarts
[10:31:50.737]                         grepl <- base::grepl
[10:31:50.737]                         restarts <- computeRestarts(cond)
[10:31:50.737]                         for (restart in restarts) {
[10:31:50.737]                           name <- restart$name
[10:31:50.737]                           if (is.null(name)) 
[10:31:50.737]                             next
[10:31:50.737]                           if (!grepl(pattern, name)) 
[10:31:50.737]                             next
[10:31:50.737]                           invokeRestart(restart)
[10:31:50.737]                           muffled <- TRUE
[10:31:50.737]                           break
[10:31:50.737]                         }
[10:31:50.737]                       }
[10:31:50.737]                     }
[10:31:50.737]                     invisible(muffled)
[10:31:50.737]                   }
[10:31:50.737]                   muffleCondition(cond)
[10:31:50.737]                 })
[10:31:50.737]             }))
[10:31:50.737]             future::FutureResult(value = ...future.value$value, 
[10:31:50.737]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:50.737]                   ...future.rng), globalenv = if (FALSE) 
[10:31:50.737]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:50.737]                     ...future.globalenv.names))
[10:31:50.737]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:50.737]         }, condition = base::local({
[10:31:50.737]             c <- base::c
[10:31:50.737]             inherits <- base::inherits
[10:31:50.737]             invokeRestart <- base::invokeRestart
[10:31:50.737]             length <- base::length
[10:31:50.737]             list <- base::list
[10:31:50.737]             seq.int <- base::seq.int
[10:31:50.737]             signalCondition <- base::signalCondition
[10:31:50.737]             sys.calls <- base::sys.calls
[10:31:50.737]             `[[` <- base::`[[`
[10:31:50.737]             `+` <- base::`+`
[10:31:50.737]             `<<-` <- base::`<<-`
[10:31:50.737]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:50.737]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:50.737]                   3L)]
[10:31:50.737]             }
[10:31:50.737]             function(cond) {
[10:31:50.737]                 is_error <- inherits(cond, "error")
[10:31:50.737]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:50.737]                   NULL)
[10:31:50.737]                 if (is_error) {
[10:31:50.737]                   sessionInformation <- function() {
[10:31:50.737]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:50.737]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:50.737]                       search = base::search(), system = base::Sys.info())
[10:31:50.737]                   }
[10:31:50.737]                   ...future.conditions[[length(...future.conditions) + 
[10:31:50.737]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:50.737]                     cond$call), session = sessionInformation(), 
[10:31:50.737]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:50.737]                   signalCondition(cond)
[10:31:50.737]                 }
[10:31:50.737]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:50.737]                 "immediateCondition"))) {
[10:31:50.737]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:50.737]                   ...future.conditions[[length(...future.conditions) + 
[10:31:50.737]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:50.737]                   if (TRUE && !signal) {
[10:31:50.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:50.737]                     {
[10:31:50.737]                       inherits <- base::inherits
[10:31:50.737]                       invokeRestart <- base::invokeRestart
[10:31:50.737]                       is.null <- base::is.null
[10:31:50.737]                       muffled <- FALSE
[10:31:50.737]                       if (inherits(cond, "message")) {
[10:31:50.737]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:50.737]                         if (muffled) 
[10:31:50.737]                           invokeRestart("muffleMessage")
[10:31:50.737]                       }
[10:31:50.737]                       else if (inherits(cond, "warning")) {
[10:31:50.737]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:50.737]                         if (muffled) 
[10:31:50.737]                           invokeRestart("muffleWarning")
[10:31:50.737]                       }
[10:31:50.737]                       else if (inherits(cond, "condition")) {
[10:31:50.737]                         if (!is.null(pattern)) {
[10:31:50.737]                           computeRestarts <- base::computeRestarts
[10:31:50.737]                           grepl <- base::grepl
[10:31:50.737]                           restarts <- computeRestarts(cond)
[10:31:50.737]                           for (restart in restarts) {
[10:31:50.737]                             name <- restart$name
[10:31:50.737]                             if (is.null(name)) 
[10:31:50.737]                               next
[10:31:50.737]                             if (!grepl(pattern, name)) 
[10:31:50.737]                               next
[10:31:50.737]                             invokeRestart(restart)
[10:31:50.737]                             muffled <- TRUE
[10:31:50.737]                             break
[10:31:50.737]                           }
[10:31:50.737]                         }
[10:31:50.737]                       }
[10:31:50.737]                       invisible(muffled)
[10:31:50.737]                     }
[10:31:50.737]                     muffleCondition(cond, pattern = "^muffle")
[10:31:50.737]                   }
[10:31:50.737]                 }
[10:31:50.737]                 else {
[10:31:50.737]                   if (TRUE) {
[10:31:50.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:50.737]                     {
[10:31:50.737]                       inherits <- base::inherits
[10:31:50.737]                       invokeRestart <- base::invokeRestart
[10:31:50.737]                       is.null <- base::is.null
[10:31:50.737]                       muffled <- FALSE
[10:31:50.737]                       if (inherits(cond, "message")) {
[10:31:50.737]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:50.737]                         if (muffled) 
[10:31:50.737]                           invokeRestart("muffleMessage")
[10:31:50.737]                       }
[10:31:50.737]                       else if (inherits(cond, "warning")) {
[10:31:50.737]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:50.737]                         if (muffled) 
[10:31:50.737]                           invokeRestart("muffleWarning")
[10:31:50.737]                       }
[10:31:50.737]                       else if (inherits(cond, "condition")) {
[10:31:50.737]                         if (!is.null(pattern)) {
[10:31:50.737]                           computeRestarts <- base::computeRestarts
[10:31:50.737]                           grepl <- base::grepl
[10:31:50.737]                           restarts <- computeRestarts(cond)
[10:31:50.737]                           for (restart in restarts) {
[10:31:50.737]                             name <- restart$name
[10:31:50.737]                             if (is.null(name)) 
[10:31:50.737]                               next
[10:31:50.737]                             if (!grepl(pattern, name)) 
[10:31:50.737]                               next
[10:31:50.737]                             invokeRestart(restart)
[10:31:50.737]                             muffled <- TRUE
[10:31:50.737]                             break
[10:31:50.737]                           }
[10:31:50.737]                         }
[10:31:50.737]                       }
[10:31:50.737]                       invisible(muffled)
[10:31:50.737]                     }
[10:31:50.737]                     muffleCondition(cond, pattern = "^muffle")
[10:31:50.737]                   }
[10:31:50.737]                 }
[10:31:50.737]             }
[10:31:50.737]         }))
[10:31:50.737]     }, error = function(ex) {
[10:31:50.737]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:50.737]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:50.737]                 ...future.rng), started = ...future.startTime, 
[10:31:50.737]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:50.737]             version = "1.8"), class = "FutureResult")
[10:31:50.737]     }, finally = {
[10:31:50.737]         if (!identical(...future.workdir, getwd())) 
[10:31:50.737]             setwd(...future.workdir)
[10:31:50.737]         {
[10:31:50.737]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:50.737]                 ...future.oldOptions$nwarnings <- NULL
[10:31:50.737]             }
[10:31:50.737]             base::options(...future.oldOptions)
[10:31:50.737]             if (.Platform$OS.type == "windows") {
[10:31:50.737]                 old_names <- names(...future.oldEnvVars)
[10:31:50.737]                 envs <- base::Sys.getenv()
[10:31:50.737]                 names <- names(envs)
[10:31:50.737]                 common <- intersect(names, old_names)
[10:31:50.737]                 added <- setdiff(names, old_names)
[10:31:50.737]                 removed <- setdiff(old_names, names)
[10:31:50.737]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:50.737]                   envs[common]]
[10:31:50.737]                 NAMES <- toupper(changed)
[10:31:50.737]                 args <- list()
[10:31:50.737]                 for (kk in seq_along(NAMES)) {
[10:31:50.737]                   name <- changed[[kk]]
[10:31:50.737]                   NAME <- NAMES[[kk]]
[10:31:50.737]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:50.737]                     next
[10:31:50.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:50.737]                 }
[10:31:50.737]                 NAMES <- toupper(added)
[10:31:50.737]                 for (kk in seq_along(NAMES)) {
[10:31:50.737]                   name <- added[[kk]]
[10:31:50.737]                   NAME <- NAMES[[kk]]
[10:31:50.737]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:50.737]                     next
[10:31:50.737]                   args[[name]] <- ""
[10:31:50.737]                 }
[10:31:50.737]                 NAMES <- toupper(removed)
[10:31:50.737]                 for (kk in seq_along(NAMES)) {
[10:31:50.737]                   name <- removed[[kk]]
[10:31:50.737]                   NAME <- NAMES[[kk]]
[10:31:50.737]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:50.737]                     next
[10:31:50.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:50.737]                 }
[10:31:50.737]                 if (length(args) > 0) 
[10:31:50.737]                   base::do.call(base::Sys.setenv, args = args)
[10:31:50.737]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:50.737]             }
[10:31:50.737]             else {
[10:31:50.737]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:50.737]             }
[10:31:50.737]             {
[10:31:50.737]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:50.737]                   0L) {
[10:31:50.737]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:50.737]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:50.737]                   base::options(opts)
[10:31:50.737]                 }
[10:31:50.737]                 {
[10:31:50.737]                   {
[10:31:50.737]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:50.737]                     NULL
[10:31:50.737]                   }
[10:31:50.737]                   options(future.plan = NULL)
[10:31:50.737]                   if (is.na(NA_character_)) 
[10:31:50.737]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:50.737]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:50.737]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:50.737]                     .init = FALSE)
[10:31:50.737]                 }
[10:31:50.737]             }
[10:31:50.737]         }
[10:31:50.737]     })
[10:31:50.737]     if (TRUE) {
[10:31:50.737]         base::sink(type = "output", split = FALSE)
[10:31:50.737]         if (TRUE) {
[10:31:50.737]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:50.737]         }
[10:31:50.737]         else {
[10:31:50.737]             ...future.result["stdout"] <- base::list(NULL)
[10:31:50.737]         }
[10:31:50.737]         base::close(...future.stdout)
[10:31:50.737]         ...future.stdout <- NULL
[10:31:50.737]     }
[10:31:50.737]     ...future.result$conditions <- ...future.conditions
[10:31:50.737]     ...future.result$finished <- base::Sys.time()
[10:31:50.737]     ...future.result
[10:31:50.737] }
[10:31:50.740] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[10:31:50.740] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[10:31:50.741] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[10:31:50.741] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:50.741] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:50.742] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:31:50.742] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:31:50.742] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:50.742] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:50.743] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:50.743] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:50.743] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[10:31:50.744] MultisessionFuture started
[10:31:50.744] - Launch lazy future ... done
[10:31:50.744] run() for ‘MultisessionFuture’ ... done
[10:31:50.744] Created future:
[10:31:50.744] MultisessionFuture:
[10:31:50.744] Label: ‘future_lapply-1’
[10:31:50.744] Expression:
[10:31:50.744] {
[10:31:50.744]     do.call(function(...) {
[10:31:50.744]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:50.744]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:50.744]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:50.744]             on.exit(options(oopts), add = TRUE)
[10:31:50.744]         }
[10:31:50.744]         {
[10:31:50.744]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:50.744]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:50.744]                 ...future.FUN(...future.X_jj, ...)
[10:31:50.744]             })
[10:31:50.744]         }
[10:31:50.744]     }, args = future.call.arguments)
[10:31:50.744] }
[10:31:50.744] Lazy evaluation: FALSE
[10:31:50.744] Asynchronous evaluation: TRUE
[10:31:50.744] Local evaluation: TRUE
[10:31:50.744] Environment: R_GlobalEnv
[10:31:50.744] Capture standard output: TRUE
[10:31:50.744] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:50.744] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:50.744] Packages: <none>
[10:31:50.744] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:50.744] Resolved: FALSE
[10:31:50.744] Value: <not collected>
[10:31:50.744] Conditions captured: <none>
[10:31:50.744] Early signaling: FALSE
[10:31:50.744] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:50.744] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:50.756] Chunk #1 of 2 ... DONE
[10:31:50.756] Chunk #2 of 2 ...
[10:31:50.756]  - Finding globals in 'X' for chunk #2 ...
[10:31:50.756] getGlobalsAndPackages() ...
[10:31:50.756] Searching for globals...
[10:31:50.756] 
[10:31:50.757] Searching for globals ... DONE
[10:31:50.757] - globals: [0] <none>
[10:31:50.757] getGlobalsAndPackages() ... DONE
[10:31:50.757]    + additional globals found: [n=0] 
[10:31:50.757]    + additional namespaces needed: [n=0] 
[10:31:50.757]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:50.757]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:50.757]  - seeds: <none>
[10:31:50.757]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:50.758] getGlobalsAndPackages() ...
[10:31:50.758] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:50.758] Resolving globals: FALSE
[10:31:50.758] Tweak future expression to call with '...' arguments ...
[10:31:50.758] {
[10:31:50.758]     do.call(function(...) {
[10:31:50.758]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:50.758]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:50.758]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:50.758]             on.exit(options(oopts), add = TRUE)
[10:31:50.758]         }
[10:31:50.758]         {
[10:31:50.758]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:50.758]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:50.758]                 ...future.FUN(...future.X_jj, ...)
[10:31:50.758]             })
[10:31:50.758]         }
[10:31:50.758]     }, args = future.call.arguments)
[10:31:50.758] }
[10:31:50.758] Tweak future expression to call with '...' arguments ... DONE
[10:31:50.759] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:50.759] 
[10:31:50.759] getGlobalsAndPackages() ... DONE
[10:31:50.759] run() for ‘Future’ ...
[10:31:50.759] - state: ‘created’
[10:31:50.759] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:50.773] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:50.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:50.774]   - Field: ‘node’
[10:31:50.774]   - Field: ‘label’
[10:31:50.774]   - Field: ‘local’
[10:31:50.774]   - Field: ‘owner’
[10:31:50.774]   - Field: ‘envir’
[10:31:50.774]   - Field: ‘workers’
[10:31:50.774]   - Field: ‘packages’
[10:31:50.774]   - Field: ‘gc’
[10:31:50.774]   - Field: ‘conditions’
[10:31:50.774]   - Field: ‘persistent’
[10:31:50.775]   - Field: ‘expr’
[10:31:50.775]   - Field: ‘uuid’
[10:31:50.775]   - Field: ‘seed’
[10:31:50.775]   - Field: ‘version’
[10:31:50.775]   - Field: ‘result’
[10:31:50.775]   - Field: ‘asynchronous’
[10:31:50.775]   - Field: ‘calls’
[10:31:50.775]   - Field: ‘globals’
[10:31:50.775]   - Field: ‘stdout’
[10:31:50.775]   - Field: ‘earlySignal’
[10:31:50.775]   - Field: ‘lazy’
[10:31:50.776]   - Field: ‘state’
[10:31:50.776] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:50.776] - Launch lazy future ...
[10:31:50.776] Packages needed by the future expression (n = 0): <none>
[10:31:50.776] Packages needed by future strategies (n = 0): <none>
[10:31:50.777] {
[10:31:50.777]     {
[10:31:50.777]         {
[10:31:50.777]             ...future.startTime <- base::Sys.time()
[10:31:50.777]             {
[10:31:50.777]                 {
[10:31:50.777]                   {
[10:31:50.777]                     {
[10:31:50.777]                       base::local({
[10:31:50.777]                         has_future <- base::requireNamespace("future", 
[10:31:50.777]                           quietly = TRUE)
[10:31:50.777]                         if (has_future) {
[10:31:50.777]                           ns <- base::getNamespace("future")
[10:31:50.777]                           version <- ns[[".package"]][["version"]]
[10:31:50.777]                           if (is.null(version)) 
[10:31:50.777]                             version <- utils::packageVersion("future")
[10:31:50.777]                         }
[10:31:50.777]                         else {
[10:31:50.777]                           version <- NULL
[10:31:50.777]                         }
[10:31:50.777]                         if (!has_future || version < "1.8.0") {
[10:31:50.777]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:50.777]                             "", base::R.version$version.string), 
[10:31:50.777]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:50.777]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:50.777]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:50.777]                               "release", "version")], collapse = " "), 
[10:31:50.777]                             hostname = base::Sys.info()[["nodename"]])
[10:31:50.777]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:50.777]                             info)
[10:31:50.777]                           info <- base::paste(info, collapse = "; ")
[10:31:50.777]                           if (!has_future) {
[10:31:50.777]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:50.777]                               info)
[10:31:50.777]                           }
[10:31:50.777]                           else {
[10:31:50.777]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:50.777]                               info, version)
[10:31:50.777]                           }
[10:31:50.777]                           base::stop(msg)
[10:31:50.777]                         }
[10:31:50.777]                       })
[10:31:50.777]                     }
[10:31:50.777]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:50.777]                     base::options(mc.cores = 1L)
[10:31:50.777]                   }
[10:31:50.777]                   ...future.strategy.old <- future::plan("list")
[10:31:50.777]                   options(future.plan = NULL)
[10:31:50.777]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:50.777]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:50.777]                 }
[10:31:50.777]                 ...future.workdir <- getwd()
[10:31:50.777]             }
[10:31:50.777]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:50.777]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:50.777]         }
[10:31:50.777]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:50.777]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:50.777]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:50.777]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:50.777]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:50.777]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:50.777]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:50.777]             base::names(...future.oldOptions))
[10:31:50.777]     }
[10:31:50.777]     if (FALSE) {
[10:31:50.777]     }
[10:31:50.777]     else {
[10:31:50.777]         if (TRUE) {
[10:31:50.777]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:50.777]                 open = "w")
[10:31:50.777]         }
[10:31:50.777]         else {
[10:31:50.777]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:50.777]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:50.777]         }
[10:31:50.777]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:50.777]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:50.777]             base::sink(type = "output", split = FALSE)
[10:31:50.777]             base::close(...future.stdout)
[10:31:50.777]         }, add = TRUE)
[10:31:50.777]     }
[10:31:50.777]     ...future.frame <- base::sys.nframe()
[10:31:50.777]     ...future.conditions <- base::list()
[10:31:50.777]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:50.777]     if (FALSE) {
[10:31:50.777]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:50.777]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:50.777]     }
[10:31:50.777]     ...future.result <- base::tryCatch({
[10:31:50.777]         base::withCallingHandlers({
[10:31:50.777]             ...future.value <- base::withVisible(base::local({
[10:31:50.777]                 ...future.makeSendCondition <- base::local({
[10:31:50.777]                   sendCondition <- NULL
[10:31:50.777]                   function(frame = 1L) {
[10:31:50.777]                     if (is.function(sendCondition)) 
[10:31:50.777]                       return(sendCondition)
[10:31:50.777]                     ns <- getNamespace("parallel")
[10:31:50.777]                     if (exists("sendData", mode = "function", 
[10:31:50.777]                       envir = ns)) {
[10:31:50.777]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:50.777]                         envir = ns)
[10:31:50.777]                       envir <- sys.frame(frame)
[10:31:50.777]                       master <- NULL
[10:31:50.777]                       while (!identical(envir, .GlobalEnv) && 
[10:31:50.777]                         !identical(envir, emptyenv())) {
[10:31:50.777]                         if (exists("master", mode = "list", envir = envir, 
[10:31:50.777]                           inherits = FALSE)) {
[10:31:50.777]                           master <- get("master", mode = "list", 
[10:31:50.777]                             envir = envir, inherits = FALSE)
[10:31:50.777]                           if (inherits(master, c("SOCKnode", 
[10:31:50.777]                             "SOCK0node"))) {
[10:31:50.777]                             sendCondition <<- function(cond) {
[10:31:50.777]                               data <- list(type = "VALUE", value = cond, 
[10:31:50.777]                                 success = TRUE)
[10:31:50.777]                               parallel_sendData(master, data)
[10:31:50.777]                             }
[10:31:50.777]                             return(sendCondition)
[10:31:50.777]                           }
[10:31:50.777]                         }
[10:31:50.777]                         frame <- frame + 1L
[10:31:50.777]                         envir <- sys.frame(frame)
[10:31:50.777]                       }
[10:31:50.777]                     }
[10:31:50.777]                     sendCondition <<- function(cond) NULL
[10:31:50.777]                   }
[10:31:50.777]                 })
[10:31:50.777]                 withCallingHandlers({
[10:31:50.777]                   {
[10:31:50.777]                     do.call(function(...) {
[10:31:50.777]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:50.777]                       if (!identical(...future.globals.maxSize.org, 
[10:31:50.777]                         ...future.globals.maxSize)) {
[10:31:50.777]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:50.777]                         on.exit(options(oopts), add = TRUE)
[10:31:50.777]                       }
[10:31:50.777]                       {
[10:31:50.777]                         lapply(seq_along(...future.elements_ii), 
[10:31:50.777]                           FUN = function(jj) {
[10:31:50.777]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:50.777]                             ...future.FUN(...future.X_jj, ...)
[10:31:50.777]                           })
[10:31:50.777]                       }
[10:31:50.777]                     }, args = future.call.arguments)
[10:31:50.777]                   }
[10:31:50.777]                 }, immediateCondition = function(cond) {
[10:31:50.777]                   sendCondition <- ...future.makeSendCondition()
[10:31:50.777]                   sendCondition(cond)
[10:31:50.777]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:50.777]                   {
[10:31:50.777]                     inherits <- base::inherits
[10:31:50.777]                     invokeRestart <- base::invokeRestart
[10:31:50.777]                     is.null <- base::is.null
[10:31:50.777]                     muffled <- FALSE
[10:31:50.777]                     if (inherits(cond, "message")) {
[10:31:50.777]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:50.777]                       if (muffled) 
[10:31:50.777]                         invokeRestart("muffleMessage")
[10:31:50.777]                     }
[10:31:50.777]                     else if (inherits(cond, "warning")) {
[10:31:50.777]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:50.777]                       if (muffled) 
[10:31:50.777]                         invokeRestart("muffleWarning")
[10:31:50.777]                     }
[10:31:50.777]                     else if (inherits(cond, "condition")) {
[10:31:50.777]                       if (!is.null(pattern)) {
[10:31:50.777]                         computeRestarts <- base::computeRestarts
[10:31:50.777]                         grepl <- base::grepl
[10:31:50.777]                         restarts <- computeRestarts(cond)
[10:31:50.777]                         for (restart in restarts) {
[10:31:50.777]                           name <- restart$name
[10:31:50.777]                           if (is.null(name)) 
[10:31:50.777]                             next
[10:31:50.777]                           if (!grepl(pattern, name)) 
[10:31:50.777]                             next
[10:31:50.777]                           invokeRestart(restart)
[10:31:50.777]                           muffled <- TRUE
[10:31:50.777]                           break
[10:31:50.777]                         }
[10:31:50.777]                       }
[10:31:50.777]                     }
[10:31:50.777]                     invisible(muffled)
[10:31:50.777]                   }
[10:31:50.777]                   muffleCondition(cond)
[10:31:50.777]                 })
[10:31:50.777]             }))
[10:31:50.777]             future::FutureResult(value = ...future.value$value, 
[10:31:50.777]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:50.777]                   ...future.rng), globalenv = if (FALSE) 
[10:31:50.777]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:50.777]                     ...future.globalenv.names))
[10:31:50.777]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:50.777]         }, condition = base::local({
[10:31:50.777]             c <- base::c
[10:31:50.777]             inherits <- base::inherits
[10:31:50.777]             invokeRestart <- base::invokeRestart
[10:31:50.777]             length <- base::length
[10:31:50.777]             list <- base::list
[10:31:50.777]             seq.int <- base::seq.int
[10:31:50.777]             signalCondition <- base::signalCondition
[10:31:50.777]             sys.calls <- base::sys.calls
[10:31:50.777]             `[[` <- base::`[[`
[10:31:50.777]             `+` <- base::`+`
[10:31:50.777]             `<<-` <- base::`<<-`
[10:31:50.777]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:50.777]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:50.777]                   3L)]
[10:31:50.777]             }
[10:31:50.777]             function(cond) {
[10:31:50.777]                 is_error <- inherits(cond, "error")
[10:31:50.777]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:50.777]                   NULL)
[10:31:50.777]                 if (is_error) {
[10:31:50.777]                   sessionInformation <- function() {
[10:31:50.777]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:50.777]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:50.777]                       search = base::search(), system = base::Sys.info())
[10:31:50.777]                   }
[10:31:50.777]                   ...future.conditions[[length(...future.conditions) + 
[10:31:50.777]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:50.777]                     cond$call), session = sessionInformation(), 
[10:31:50.777]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:50.777]                   signalCondition(cond)
[10:31:50.777]                 }
[10:31:50.777]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:50.777]                 "immediateCondition"))) {
[10:31:50.777]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:50.777]                   ...future.conditions[[length(...future.conditions) + 
[10:31:50.777]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:50.777]                   if (TRUE && !signal) {
[10:31:50.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:50.777]                     {
[10:31:50.777]                       inherits <- base::inherits
[10:31:50.777]                       invokeRestart <- base::invokeRestart
[10:31:50.777]                       is.null <- base::is.null
[10:31:50.777]                       muffled <- FALSE
[10:31:50.777]                       if (inherits(cond, "message")) {
[10:31:50.777]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:50.777]                         if (muffled) 
[10:31:50.777]                           invokeRestart("muffleMessage")
[10:31:50.777]                       }
[10:31:50.777]                       else if (inherits(cond, "warning")) {
[10:31:50.777]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:50.777]                         if (muffled) 
[10:31:50.777]                           invokeRestart("muffleWarning")
[10:31:50.777]                       }
[10:31:50.777]                       else if (inherits(cond, "condition")) {
[10:31:50.777]                         if (!is.null(pattern)) {
[10:31:50.777]                           computeRestarts <- base::computeRestarts
[10:31:50.777]                           grepl <- base::grepl
[10:31:50.777]                           restarts <- computeRestarts(cond)
[10:31:50.777]                           for (restart in restarts) {
[10:31:50.777]                             name <- restart$name
[10:31:50.777]                             if (is.null(name)) 
[10:31:50.777]                               next
[10:31:50.777]                             if (!grepl(pattern, name)) 
[10:31:50.777]                               next
[10:31:50.777]                             invokeRestart(restart)
[10:31:50.777]                             muffled <- TRUE
[10:31:50.777]                             break
[10:31:50.777]                           }
[10:31:50.777]                         }
[10:31:50.777]                       }
[10:31:50.777]                       invisible(muffled)
[10:31:50.777]                     }
[10:31:50.777]                     muffleCondition(cond, pattern = "^muffle")
[10:31:50.777]                   }
[10:31:50.777]                 }
[10:31:50.777]                 else {
[10:31:50.777]                   if (TRUE) {
[10:31:50.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:50.777]                     {
[10:31:50.777]                       inherits <- base::inherits
[10:31:50.777]                       invokeRestart <- base::invokeRestart
[10:31:50.777]                       is.null <- base::is.null
[10:31:50.777]                       muffled <- FALSE
[10:31:50.777]                       if (inherits(cond, "message")) {
[10:31:50.777]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:50.777]                         if (muffled) 
[10:31:50.777]                           invokeRestart("muffleMessage")
[10:31:50.777]                       }
[10:31:50.777]                       else if (inherits(cond, "warning")) {
[10:31:50.777]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:50.777]                         if (muffled) 
[10:31:50.777]                           invokeRestart("muffleWarning")
[10:31:50.777]                       }
[10:31:50.777]                       else if (inherits(cond, "condition")) {
[10:31:50.777]                         if (!is.null(pattern)) {
[10:31:50.777]                           computeRestarts <- base::computeRestarts
[10:31:50.777]                           grepl <- base::grepl
[10:31:50.777]                           restarts <- computeRestarts(cond)
[10:31:50.777]                           for (restart in restarts) {
[10:31:50.777]                             name <- restart$name
[10:31:50.777]                             if (is.null(name)) 
[10:31:50.777]                               next
[10:31:50.777]                             if (!grepl(pattern, name)) 
[10:31:50.777]                               next
[10:31:50.777]                             invokeRestart(restart)
[10:31:50.777]                             muffled <- TRUE
[10:31:50.777]                             break
[10:31:50.777]                           }
[10:31:50.777]                         }
[10:31:50.777]                       }
[10:31:50.777]                       invisible(muffled)
[10:31:50.777]                     }
[10:31:50.777]                     muffleCondition(cond, pattern = "^muffle")
[10:31:50.777]                   }
[10:31:50.777]                 }
[10:31:50.777]             }
[10:31:50.777]         }))
[10:31:50.777]     }, error = function(ex) {
[10:31:50.777]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:50.777]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:50.777]                 ...future.rng), started = ...future.startTime, 
[10:31:50.777]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:50.777]             version = "1.8"), class = "FutureResult")
[10:31:50.777]     }, finally = {
[10:31:50.777]         if (!identical(...future.workdir, getwd())) 
[10:31:50.777]             setwd(...future.workdir)
[10:31:50.777]         {
[10:31:50.777]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:50.777]                 ...future.oldOptions$nwarnings <- NULL
[10:31:50.777]             }
[10:31:50.777]             base::options(...future.oldOptions)
[10:31:50.777]             if (.Platform$OS.type == "windows") {
[10:31:50.777]                 old_names <- names(...future.oldEnvVars)
[10:31:50.777]                 envs <- base::Sys.getenv()
[10:31:50.777]                 names <- names(envs)
[10:31:50.777]                 common <- intersect(names, old_names)
[10:31:50.777]                 added <- setdiff(names, old_names)
[10:31:50.777]                 removed <- setdiff(old_names, names)
[10:31:50.777]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:50.777]                   envs[common]]
[10:31:50.777]                 NAMES <- toupper(changed)
[10:31:50.777]                 args <- list()
[10:31:50.777]                 for (kk in seq_along(NAMES)) {
[10:31:50.777]                   name <- changed[[kk]]
[10:31:50.777]                   NAME <- NAMES[[kk]]
[10:31:50.777]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:50.777]                     next
[10:31:50.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:50.777]                 }
[10:31:50.777]                 NAMES <- toupper(added)
[10:31:50.777]                 for (kk in seq_along(NAMES)) {
[10:31:50.777]                   name <- added[[kk]]
[10:31:50.777]                   NAME <- NAMES[[kk]]
[10:31:50.777]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:50.777]                     next
[10:31:50.777]                   args[[name]] <- ""
[10:31:50.777]                 }
[10:31:50.777]                 NAMES <- toupper(removed)
[10:31:50.777]                 for (kk in seq_along(NAMES)) {
[10:31:50.777]                   name <- removed[[kk]]
[10:31:50.777]                   NAME <- NAMES[[kk]]
[10:31:50.777]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:50.777]                     next
[10:31:50.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:50.777]                 }
[10:31:50.777]                 if (length(args) > 0) 
[10:31:50.777]                   base::do.call(base::Sys.setenv, args = args)
[10:31:50.777]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:50.777]             }
[10:31:50.777]             else {
[10:31:50.777]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:50.777]             }
[10:31:50.777]             {
[10:31:50.777]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:50.777]                   0L) {
[10:31:50.777]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:50.777]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:50.777]                   base::options(opts)
[10:31:50.777]                 }
[10:31:50.777]                 {
[10:31:50.777]                   {
[10:31:50.777]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:50.777]                     NULL
[10:31:50.777]                   }
[10:31:50.777]                   options(future.plan = NULL)
[10:31:50.777]                   if (is.na(NA_character_)) 
[10:31:50.777]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:50.777]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:50.777]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:50.777]                     .init = FALSE)
[10:31:50.777]                 }
[10:31:50.777]             }
[10:31:50.777]         }
[10:31:50.777]     })
[10:31:50.777]     if (TRUE) {
[10:31:50.777]         base::sink(type = "output", split = FALSE)
[10:31:50.777]         if (TRUE) {
[10:31:50.777]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:50.777]         }
[10:31:50.777]         else {
[10:31:50.777]             ...future.result["stdout"] <- base::list(NULL)
[10:31:50.777]         }
[10:31:50.777]         base::close(...future.stdout)
[10:31:50.777]         ...future.stdout <- NULL
[10:31:50.777]     }
[10:31:50.777]     ...future.result$conditions <- ...future.conditions
[10:31:50.777]     ...future.result$finished <- base::Sys.time()
[10:31:50.777]     ...future.result
[10:31:50.777] }
[10:31:50.779] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[10:31:50.780] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[10:31:50.780] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[10:31:50.780] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:31:50.781] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:31:50.781] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:31:50.781] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:31:50.781] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:50.781] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:50.782] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:50.782] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:50.782] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[10:31:50.782] MultisessionFuture started
[10:31:50.783] - Launch lazy future ... done
[10:31:50.783] run() for ‘MultisessionFuture’ ... done
[10:31:50.783] Created future:
[10:31:50.783] MultisessionFuture:
[10:31:50.783] Label: ‘future_lapply-2’
[10:31:50.783] Expression:
[10:31:50.783] {
[10:31:50.783]     do.call(function(...) {
[10:31:50.783]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:50.783]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:50.783]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:50.783]             on.exit(options(oopts), add = TRUE)
[10:31:50.783]         }
[10:31:50.783]         {
[10:31:50.783]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:50.783]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:50.783]                 ...future.FUN(...future.X_jj, ...)
[10:31:50.783]             })
[10:31:50.783]         }
[10:31:50.783]     }, args = future.call.arguments)
[10:31:50.783] }
[10:31:50.783] Lazy evaluation: FALSE
[10:31:50.783] Asynchronous evaluation: TRUE
[10:31:50.783] Local evaluation: TRUE
[10:31:50.783] Environment: R_GlobalEnv
[10:31:50.783] Capture standard output: TRUE
[10:31:50.783] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:50.783] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:50.783] Packages: <none>
[10:31:50.783] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:50.783] Resolved: FALSE
[10:31:50.783] Value: <not collected>
[10:31:50.783] Conditions captured: <none>
[10:31:50.783] Early signaling: FALSE
[10:31:50.783] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:50.783] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:50.794] Chunk #2 of 2 ... DONE
[10:31:50.795] Launching 2 futures (chunks) ... DONE
[10:31:50.795] Resolving 2 futures (chunks) ...
[10:31:50.795] resolve() on list ...
[10:31:50.795]  recursive: 0
[10:31:50.795]  length: 2
[10:31:50.795] 
[10:31:50.837] receiveMessageFromWorker() for ClusterFuture ...
[10:31:50.837] - Validating connection of MultisessionFuture
[10:31:50.838] - received message: FutureResult
[10:31:50.838] - Received FutureResult
[10:31:50.838] - Erased future from FutureRegistry
[10:31:50.838] result() for ClusterFuture ...
[10:31:50.838] - result already collected: FutureResult
[10:31:50.838] result() for ClusterFuture ... done
[10:31:50.838] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:50.838] Future #2
[10:31:50.839] result() for ClusterFuture ...
[10:31:50.839] - result already collected: FutureResult
[10:31:50.839] result() for ClusterFuture ... done
[10:31:50.839] result() for ClusterFuture ...
[10:31:50.839] - result already collected: FutureResult
[10:31:50.839] result() for ClusterFuture ... done
[10:31:50.839] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:50.839] - nx: 2
[10:31:50.839] - relay: TRUE
[10:31:50.839] - stdout: TRUE
[10:31:50.839] - signal: TRUE
[10:31:50.840] - resignal: FALSE
[10:31:50.840] - force: TRUE
[10:31:50.840] - relayed: [n=2] FALSE, FALSE
[10:31:50.840] - queued futures: [n=2] FALSE, FALSE
[10:31:50.840]  - until=1
[10:31:50.840]  - relaying element #1
[10:31:50.840] - relayed: [n=2] FALSE, FALSE
[10:31:50.840] - queued futures: [n=2] FALSE, TRUE
[10:31:50.840] signalConditionsASAP(NULL, pos=2) ... done
[10:31:50.840]  length: 1 (resolved future 2)
[10:31:51.287] receiveMessageFromWorker() for ClusterFuture ...
[10:31:51.288] - Validating connection of MultisessionFuture
[10:31:51.288] - received message: FutureResult
[10:31:51.288] - Received FutureResult
[10:31:51.288] - Erased future from FutureRegistry
[10:31:51.288] result() for ClusterFuture ...
[10:31:51.288] - result already collected: FutureResult
[10:31:51.288] result() for ClusterFuture ... done
[10:31:51.289] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:51.289] Future #1
[10:31:51.289] result() for ClusterFuture ...
[10:31:51.289] - result already collected: FutureResult
[10:31:51.289] result() for ClusterFuture ... done
[10:31:51.289] result() for ClusterFuture ...
[10:31:51.289] - result already collected: FutureResult
[10:31:51.289] result() for ClusterFuture ... done
[10:31:51.289] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:51.289] - nx: 2
[10:31:51.290] - relay: TRUE
[10:31:51.290] - stdout: TRUE
[10:31:51.290] - signal: TRUE
[10:31:51.290] - resignal: FALSE
[10:31:51.290] - force: TRUE
[10:31:51.290] - relayed: [n=2] FALSE, FALSE
[10:31:51.290] - queued futures: [n=2] FALSE, TRUE
[10:31:51.290]  - until=1
[10:31:51.290]  - relaying element #1
[10:31:51.290] result() for ClusterFuture ...
[10:31:51.290] - result already collected: FutureResult
[10:31:51.290] result() for ClusterFuture ... done
[10:31:51.291] result() for ClusterFuture ...
[10:31:51.291] - result already collected: FutureResult
[10:31:51.291] result() for ClusterFuture ... done
[10:31:51.291] result() for ClusterFuture ...
[10:31:51.291] - result already collected: FutureResult
[10:31:51.291] result() for ClusterFuture ... done
[10:31:51.291] result() for ClusterFuture ...
[10:31:51.291] - result already collected: FutureResult
[10:31:51.291] result() for ClusterFuture ... done
[10:31:51.291] - relayed: [n=2] TRUE, FALSE
[10:31:51.291] - queued futures: [n=2] TRUE, TRUE
[10:31:51.291] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:51.292]  length: 0 (resolved future 1)
[10:31:51.292] Relaying remaining futures
[10:31:51.292] signalConditionsASAP(NULL, pos=0) ...
[10:31:51.292] - nx: 2
[10:31:51.292] - relay: TRUE
[10:31:51.292] - stdout: TRUE
[10:31:51.292] - signal: TRUE
[10:31:51.294] - resignal: FALSE
[10:31:51.294] - force: TRUE
[10:31:51.294] - relayed: [n=2] TRUE, FALSE
[10:31:51.294] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:51.294]  - relaying element #2
[10:31:51.295] result() for ClusterFuture ...
[10:31:51.295] - result already collected: FutureResult
[10:31:51.295] result() for ClusterFuture ... done
[10:31:51.295] result() for ClusterFuture ...
[10:31:51.295] - result already collected: FutureResult
[10:31:51.295] result() for ClusterFuture ... done
[10:31:51.295] result() for ClusterFuture ...
[10:31:51.295] - result already collected: FutureResult
[10:31:51.295] result() for ClusterFuture ... done
[10:31:51.295] result() for ClusterFuture ...
[10:31:51.295] - result already collected: FutureResult
[10:31:51.296] result() for ClusterFuture ... done
[10:31:51.296] - relayed: [n=2] TRUE, TRUE
[10:31:51.296] - queued futures: [n=2] TRUE, TRUE
[10:31:51.296] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:31:51.296] resolve() on list ... DONE
[10:31:51.296] result() for ClusterFuture ...
[10:31:51.296] - result already collected: FutureResult
[10:31:51.296] result() for ClusterFuture ... done
[10:31:51.296] result() for ClusterFuture ...
[10:31:51.296] - result already collected: FutureResult
[10:31:51.296] result() for ClusterFuture ... done
[10:31:51.297] result() for ClusterFuture ...
[10:31:51.297] - result already collected: FutureResult
[10:31:51.297] result() for ClusterFuture ... done
[10:31:51.297] result() for ClusterFuture ...
[10:31:51.297] - result already collected: FutureResult
[10:31:51.297] result() for ClusterFuture ... done
[10:31:51.297]  - Number of value chunks collected: 2
[10:31:51.297] Resolving 2 futures (chunks) ... DONE
[10:31:51.297] Reducing values from 2 chunks ...
[10:31:51.297]  - Number of values collected after concatenation: 2
[10:31:51.297]  - Number of values expected: 2
[10:31:51.298] Reducing values from 2 chunks ... DONE
[10:31:51.298] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[10:31:51.298] future_lapply() ...
[10:31:51.302] Number of chunks: 2
[10:31:51.303] getGlobalsAndPackagesXApply() ...
[10:31:51.303]  - future.globals: TRUE
[10:31:51.303] getGlobalsAndPackages() ...
[10:31:51.303] Searching for globals...
[10:31:51.304] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[10:31:51.304] Searching for globals ... DONE
[10:31:51.304] Resolving globals: FALSE
[10:31:51.305] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[10:31:51.305] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[10:31:51.305] - globals: [1] ‘FUN’
[10:31:51.305] 
[10:31:51.306] getGlobalsAndPackages() ... DONE
[10:31:51.306]  - globals found/used: [n=1] ‘FUN’
[10:31:51.306]  - needed namespaces: [n=0] 
[10:31:51.306] Finding globals ... DONE
[10:31:51.306]  - use_args: TRUE
[10:31:51.306]  - Getting '...' globals ...
[10:31:51.306] resolve() on list ...
[10:31:51.306]  recursive: 0
[10:31:51.307]  length: 1
[10:31:51.307]  elements: ‘...’
[10:31:51.307]  length: 0 (resolved future 1)
[10:31:51.307] resolve() on list ... DONE
[10:31:51.307]    - '...' content: [n=0] 
[10:31:51.307] List of 1
[10:31:51.307]  $ ...: list()
[10:31:51.307]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:51.307]  - attr(*, "where")=List of 1
[10:31:51.307]   ..$ ...:<environment: 0x564ff43a7fb0> 
[10:31:51.307]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:51.307]  - attr(*, "resolved")= logi TRUE
[10:31:51.307]  - attr(*, "total_size")= num NA
[10:31:51.310]  - Getting '...' globals ... DONE
[10:31:51.310] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:51.310] List of 2
[10:31:51.310]  $ ...future.FUN:function (x)  
[10:31:51.310]  $ ...          : list()
[10:31:51.310]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:51.310]  - attr(*, "where")=List of 2
[10:31:51.310]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:51.310]   ..$ ...          :<environment: 0x564ff43a7fb0> 
[10:31:51.310]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:51.310]  - attr(*, "resolved")= logi FALSE
[10:31:51.310]  - attr(*, "total_size")= num 4720
[10:31:51.312] Packages to be attached in all futures: [n=0] 
[10:31:51.312] getGlobalsAndPackagesXApply() ... DONE
[10:31:51.313] Number of futures (= number of chunks): 2
[10:31:51.313] Launching 2 futures (chunks) ...
[10:31:51.313] Chunk #1 of 2 ...
[10:31:51.313]  - Finding globals in 'X' for chunk #1 ...
[10:31:51.313] getGlobalsAndPackages() ...
[10:31:51.313] Searching for globals...
[10:31:51.314] 
[10:31:51.314] Searching for globals ... DONE
[10:31:51.314] - globals: [0] <none>
[10:31:51.314] getGlobalsAndPackages() ... DONE
[10:31:51.314]    + additional globals found: [n=0] 
[10:31:51.314]    + additional namespaces needed: [n=0] 
[10:31:51.314]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:51.314]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:51.314]  - seeds: <none>
[10:31:51.314]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:51.314] getGlobalsAndPackages() ...
[10:31:51.315] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:51.315] Resolving globals: FALSE
[10:31:51.315] Tweak future expression to call with '...' arguments ...
[10:31:51.315] {
[10:31:51.315]     do.call(function(...) {
[10:31:51.315]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:51.315]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:51.315]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:51.315]             on.exit(options(oopts), add = TRUE)
[10:31:51.315]         }
[10:31:51.315]         {
[10:31:51.315]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:51.315]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:51.315]                 ...future.FUN(...future.X_jj, ...)
[10:31:51.315]             })
[10:31:51.315]         }
[10:31:51.315]     }, args = future.call.arguments)
[10:31:51.315] }
[10:31:51.315] Tweak future expression to call with '...' arguments ... DONE
[10:31:51.315] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:51.316] 
[10:31:51.316] getGlobalsAndPackages() ... DONE
[10:31:51.316] run() for ‘Future’ ...
[10:31:51.316] - state: ‘created’
[10:31:51.316] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:51.332] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:51.332] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:51.332]   - Field: ‘node’
[10:31:51.332]   - Field: ‘label’
[10:31:51.332]   - Field: ‘local’
[10:31:51.332]   - Field: ‘owner’
[10:31:51.332]   - Field: ‘envir’
[10:31:51.333]   - Field: ‘workers’
[10:31:51.333]   - Field: ‘packages’
[10:31:51.333]   - Field: ‘gc’
[10:31:51.333]   - Field: ‘conditions’
[10:31:51.333]   - Field: ‘persistent’
[10:31:51.333]   - Field: ‘expr’
[10:31:51.333]   - Field: ‘uuid’
[10:31:51.333]   - Field: ‘seed’
[10:31:51.333]   - Field: ‘version’
[10:31:51.334]   - Field: ‘result’
[10:31:51.334]   - Field: ‘asynchronous’
[10:31:51.334]   - Field: ‘calls’
[10:31:51.334]   - Field: ‘globals’
[10:31:51.334]   - Field: ‘stdout’
[10:31:51.334]   - Field: ‘earlySignal’
[10:31:51.334]   - Field: ‘lazy’
[10:31:51.334]   - Field: ‘state’
[10:31:51.334] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:51.334] - Launch lazy future ...
[10:31:51.335] Packages needed by the future expression (n = 0): <none>
[10:31:51.335] Packages needed by future strategies (n = 0): <none>
[10:31:51.335] {
[10:31:51.335]     {
[10:31:51.335]         {
[10:31:51.335]             ...future.startTime <- base::Sys.time()
[10:31:51.335]             {
[10:31:51.335]                 {
[10:31:51.335]                   {
[10:31:51.335]                     {
[10:31:51.335]                       base::local({
[10:31:51.335]                         has_future <- base::requireNamespace("future", 
[10:31:51.335]                           quietly = TRUE)
[10:31:51.335]                         if (has_future) {
[10:31:51.335]                           ns <- base::getNamespace("future")
[10:31:51.335]                           version <- ns[[".package"]][["version"]]
[10:31:51.335]                           if (is.null(version)) 
[10:31:51.335]                             version <- utils::packageVersion("future")
[10:31:51.335]                         }
[10:31:51.335]                         else {
[10:31:51.335]                           version <- NULL
[10:31:51.335]                         }
[10:31:51.335]                         if (!has_future || version < "1.8.0") {
[10:31:51.335]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:51.335]                             "", base::R.version$version.string), 
[10:31:51.335]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:51.335]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:51.335]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:51.335]                               "release", "version")], collapse = " "), 
[10:31:51.335]                             hostname = base::Sys.info()[["nodename"]])
[10:31:51.335]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:51.335]                             info)
[10:31:51.335]                           info <- base::paste(info, collapse = "; ")
[10:31:51.335]                           if (!has_future) {
[10:31:51.335]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:51.335]                               info)
[10:31:51.335]                           }
[10:31:51.335]                           else {
[10:31:51.335]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:51.335]                               info, version)
[10:31:51.335]                           }
[10:31:51.335]                           base::stop(msg)
[10:31:51.335]                         }
[10:31:51.335]                       })
[10:31:51.335]                     }
[10:31:51.335]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:51.335]                     base::options(mc.cores = 1L)
[10:31:51.335]                   }
[10:31:51.335]                   ...future.strategy.old <- future::plan("list")
[10:31:51.335]                   options(future.plan = NULL)
[10:31:51.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:51.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:51.335]                 }
[10:31:51.335]                 ...future.workdir <- getwd()
[10:31:51.335]             }
[10:31:51.335]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:51.335]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:51.335]         }
[10:31:51.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:51.335]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:51.335]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:51.335]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:51.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:51.335]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:51.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:51.335]             base::names(...future.oldOptions))
[10:31:51.335]     }
[10:31:51.335]     if (TRUE) {
[10:31:51.335]     }
[10:31:51.335]     else {
[10:31:51.335]         if (NA) {
[10:31:51.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:51.335]                 open = "w")
[10:31:51.335]         }
[10:31:51.335]         else {
[10:31:51.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:51.335]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:51.335]         }
[10:31:51.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:51.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:51.335]             base::sink(type = "output", split = FALSE)
[10:31:51.335]             base::close(...future.stdout)
[10:31:51.335]         }, add = TRUE)
[10:31:51.335]     }
[10:31:51.335]     ...future.frame <- base::sys.nframe()
[10:31:51.335]     ...future.conditions <- base::list()
[10:31:51.335]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:51.335]     if (FALSE) {
[10:31:51.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:51.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:51.335]     }
[10:31:51.335]     ...future.result <- base::tryCatch({
[10:31:51.335]         base::withCallingHandlers({
[10:31:51.335]             ...future.value <- base::withVisible(base::local({
[10:31:51.335]                 ...future.makeSendCondition <- base::local({
[10:31:51.335]                   sendCondition <- NULL
[10:31:51.335]                   function(frame = 1L) {
[10:31:51.335]                     if (is.function(sendCondition)) 
[10:31:51.335]                       return(sendCondition)
[10:31:51.335]                     ns <- getNamespace("parallel")
[10:31:51.335]                     if (exists("sendData", mode = "function", 
[10:31:51.335]                       envir = ns)) {
[10:31:51.335]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:51.335]                         envir = ns)
[10:31:51.335]                       envir <- sys.frame(frame)
[10:31:51.335]                       master <- NULL
[10:31:51.335]                       while (!identical(envir, .GlobalEnv) && 
[10:31:51.335]                         !identical(envir, emptyenv())) {
[10:31:51.335]                         if (exists("master", mode = "list", envir = envir, 
[10:31:51.335]                           inherits = FALSE)) {
[10:31:51.335]                           master <- get("master", mode = "list", 
[10:31:51.335]                             envir = envir, inherits = FALSE)
[10:31:51.335]                           if (inherits(master, c("SOCKnode", 
[10:31:51.335]                             "SOCK0node"))) {
[10:31:51.335]                             sendCondition <<- function(cond) {
[10:31:51.335]                               data <- list(type = "VALUE", value = cond, 
[10:31:51.335]                                 success = TRUE)
[10:31:51.335]                               parallel_sendData(master, data)
[10:31:51.335]                             }
[10:31:51.335]                             return(sendCondition)
[10:31:51.335]                           }
[10:31:51.335]                         }
[10:31:51.335]                         frame <- frame + 1L
[10:31:51.335]                         envir <- sys.frame(frame)
[10:31:51.335]                       }
[10:31:51.335]                     }
[10:31:51.335]                     sendCondition <<- function(cond) NULL
[10:31:51.335]                   }
[10:31:51.335]                 })
[10:31:51.335]                 withCallingHandlers({
[10:31:51.335]                   {
[10:31:51.335]                     do.call(function(...) {
[10:31:51.335]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:51.335]                       if (!identical(...future.globals.maxSize.org, 
[10:31:51.335]                         ...future.globals.maxSize)) {
[10:31:51.335]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:51.335]                         on.exit(options(oopts), add = TRUE)
[10:31:51.335]                       }
[10:31:51.335]                       {
[10:31:51.335]                         lapply(seq_along(...future.elements_ii), 
[10:31:51.335]                           FUN = function(jj) {
[10:31:51.335]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:51.335]                             ...future.FUN(...future.X_jj, ...)
[10:31:51.335]                           })
[10:31:51.335]                       }
[10:31:51.335]                     }, args = future.call.arguments)
[10:31:51.335]                   }
[10:31:51.335]                 }, immediateCondition = function(cond) {
[10:31:51.335]                   sendCondition <- ...future.makeSendCondition()
[10:31:51.335]                   sendCondition(cond)
[10:31:51.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:51.335]                   {
[10:31:51.335]                     inherits <- base::inherits
[10:31:51.335]                     invokeRestart <- base::invokeRestart
[10:31:51.335]                     is.null <- base::is.null
[10:31:51.335]                     muffled <- FALSE
[10:31:51.335]                     if (inherits(cond, "message")) {
[10:31:51.335]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:51.335]                       if (muffled) 
[10:31:51.335]                         invokeRestart("muffleMessage")
[10:31:51.335]                     }
[10:31:51.335]                     else if (inherits(cond, "warning")) {
[10:31:51.335]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:51.335]                       if (muffled) 
[10:31:51.335]                         invokeRestart("muffleWarning")
[10:31:51.335]                     }
[10:31:51.335]                     else if (inherits(cond, "condition")) {
[10:31:51.335]                       if (!is.null(pattern)) {
[10:31:51.335]                         computeRestarts <- base::computeRestarts
[10:31:51.335]                         grepl <- base::grepl
[10:31:51.335]                         restarts <- computeRestarts(cond)
[10:31:51.335]                         for (restart in restarts) {
[10:31:51.335]                           name <- restart$name
[10:31:51.335]                           if (is.null(name)) 
[10:31:51.335]                             next
[10:31:51.335]                           if (!grepl(pattern, name)) 
[10:31:51.335]                             next
[10:31:51.335]                           invokeRestart(restart)
[10:31:51.335]                           muffled <- TRUE
[10:31:51.335]                           break
[10:31:51.335]                         }
[10:31:51.335]                       }
[10:31:51.335]                     }
[10:31:51.335]                     invisible(muffled)
[10:31:51.335]                   }
[10:31:51.335]                   muffleCondition(cond)
[10:31:51.335]                 })
[10:31:51.335]             }))
[10:31:51.335]             future::FutureResult(value = ...future.value$value, 
[10:31:51.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:51.335]                   ...future.rng), globalenv = if (FALSE) 
[10:31:51.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:51.335]                     ...future.globalenv.names))
[10:31:51.335]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:51.335]         }, condition = base::local({
[10:31:51.335]             c <- base::c
[10:31:51.335]             inherits <- base::inherits
[10:31:51.335]             invokeRestart <- base::invokeRestart
[10:31:51.335]             length <- base::length
[10:31:51.335]             list <- base::list
[10:31:51.335]             seq.int <- base::seq.int
[10:31:51.335]             signalCondition <- base::signalCondition
[10:31:51.335]             sys.calls <- base::sys.calls
[10:31:51.335]             `[[` <- base::`[[`
[10:31:51.335]             `+` <- base::`+`
[10:31:51.335]             `<<-` <- base::`<<-`
[10:31:51.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:51.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:51.335]                   3L)]
[10:31:51.335]             }
[10:31:51.335]             function(cond) {
[10:31:51.335]                 is_error <- inherits(cond, "error")
[10:31:51.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:51.335]                   NULL)
[10:31:51.335]                 if (is_error) {
[10:31:51.335]                   sessionInformation <- function() {
[10:31:51.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:51.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:51.335]                       search = base::search(), system = base::Sys.info())
[10:31:51.335]                   }
[10:31:51.335]                   ...future.conditions[[length(...future.conditions) + 
[10:31:51.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:51.335]                     cond$call), session = sessionInformation(), 
[10:31:51.335]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:51.335]                   signalCondition(cond)
[10:31:51.335]                 }
[10:31:51.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:51.335]                 "immediateCondition"))) {
[10:31:51.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:51.335]                   ...future.conditions[[length(...future.conditions) + 
[10:31:51.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:51.335]                   if (TRUE && !signal) {
[10:31:51.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:51.335]                     {
[10:31:51.335]                       inherits <- base::inherits
[10:31:51.335]                       invokeRestart <- base::invokeRestart
[10:31:51.335]                       is.null <- base::is.null
[10:31:51.335]                       muffled <- FALSE
[10:31:51.335]                       if (inherits(cond, "message")) {
[10:31:51.335]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:51.335]                         if (muffled) 
[10:31:51.335]                           invokeRestart("muffleMessage")
[10:31:51.335]                       }
[10:31:51.335]                       else if (inherits(cond, "warning")) {
[10:31:51.335]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:51.335]                         if (muffled) 
[10:31:51.335]                           invokeRestart("muffleWarning")
[10:31:51.335]                       }
[10:31:51.335]                       else if (inherits(cond, "condition")) {
[10:31:51.335]                         if (!is.null(pattern)) {
[10:31:51.335]                           computeRestarts <- base::computeRestarts
[10:31:51.335]                           grepl <- base::grepl
[10:31:51.335]                           restarts <- computeRestarts(cond)
[10:31:51.335]                           for (restart in restarts) {
[10:31:51.335]                             name <- restart$name
[10:31:51.335]                             if (is.null(name)) 
[10:31:51.335]                               next
[10:31:51.335]                             if (!grepl(pattern, name)) 
[10:31:51.335]                               next
[10:31:51.335]                             invokeRestart(restart)
[10:31:51.335]                             muffled <- TRUE
[10:31:51.335]                             break
[10:31:51.335]                           }
[10:31:51.335]                         }
[10:31:51.335]                       }
[10:31:51.335]                       invisible(muffled)
[10:31:51.335]                     }
[10:31:51.335]                     muffleCondition(cond, pattern = "^muffle")
[10:31:51.335]                   }
[10:31:51.335]                 }
[10:31:51.335]                 else {
[10:31:51.335]                   if (TRUE) {
[10:31:51.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:51.335]                     {
[10:31:51.335]                       inherits <- base::inherits
[10:31:51.335]                       invokeRestart <- base::invokeRestart
[10:31:51.335]                       is.null <- base::is.null
[10:31:51.335]                       muffled <- FALSE
[10:31:51.335]                       if (inherits(cond, "message")) {
[10:31:51.335]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:51.335]                         if (muffled) 
[10:31:51.335]                           invokeRestart("muffleMessage")
[10:31:51.335]                       }
[10:31:51.335]                       else if (inherits(cond, "warning")) {
[10:31:51.335]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:51.335]                         if (muffled) 
[10:31:51.335]                           invokeRestart("muffleWarning")
[10:31:51.335]                       }
[10:31:51.335]                       else if (inherits(cond, "condition")) {
[10:31:51.335]                         if (!is.null(pattern)) {
[10:31:51.335]                           computeRestarts <- base::computeRestarts
[10:31:51.335]                           grepl <- base::grepl
[10:31:51.335]                           restarts <- computeRestarts(cond)
[10:31:51.335]                           for (restart in restarts) {
[10:31:51.335]                             name <- restart$name
[10:31:51.335]                             if (is.null(name)) 
[10:31:51.335]                               next
[10:31:51.335]                             if (!grepl(pattern, name)) 
[10:31:51.335]                               next
[10:31:51.335]                             invokeRestart(restart)
[10:31:51.335]                             muffled <- TRUE
[10:31:51.335]                             break
[10:31:51.335]                           }
[10:31:51.335]                         }
[10:31:51.335]                       }
[10:31:51.335]                       invisible(muffled)
[10:31:51.335]                     }
[10:31:51.335]                     muffleCondition(cond, pattern = "^muffle")
[10:31:51.335]                   }
[10:31:51.335]                 }
[10:31:51.335]             }
[10:31:51.335]         }))
[10:31:51.335]     }, error = function(ex) {
[10:31:51.335]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:51.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:51.335]                 ...future.rng), started = ...future.startTime, 
[10:31:51.335]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:51.335]             version = "1.8"), class = "FutureResult")
[10:31:51.335]     }, finally = {
[10:31:51.335]         if (!identical(...future.workdir, getwd())) 
[10:31:51.335]             setwd(...future.workdir)
[10:31:51.335]         {
[10:31:51.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:51.335]                 ...future.oldOptions$nwarnings <- NULL
[10:31:51.335]             }
[10:31:51.335]             base::options(...future.oldOptions)
[10:31:51.335]             if (.Platform$OS.type == "windows") {
[10:31:51.335]                 old_names <- names(...future.oldEnvVars)
[10:31:51.335]                 envs <- base::Sys.getenv()
[10:31:51.335]                 names <- names(envs)
[10:31:51.335]                 common <- intersect(names, old_names)
[10:31:51.335]                 added <- setdiff(names, old_names)
[10:31:51.335]                 removed <- setdiff(old_names, names)
[10:31:51.335]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:51.335]                   envs[common]]
[10:31:51.335]                 NAMES <- toupper(changed)
[10:31:51.335]                 args <- list()
[10:31:51.335]                 for (kk in seq_along(NAMES)) {
[10:31:51.335]                   name <- changed[[kk]]
[10:31:51.335]                   NAME <- NAMES[[kk]]
[10:31:51.335]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:51.335]                     next
[10:31:51.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:51.335]                 }
[10:31:51.335]                 NAMES <- toupper(added)
[10:31:51.335]                 for (kk in seq_along(NAMES)) {
[10:31:51.335]                   name <- added[[kk]]
[10:31:51.335]                   NAME <- NAMES[[kk]]
[10:31:51.335]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:51.335]                     next
[10:31:51.335]                   args[[name]] <- ""
[10:31:51.335]                 }
[10:31:51.335]                 NAMES <- toupper(removed)
[10:31:51.335]                 for (kk in seq_along(NAMES)) {
[10:31:51.335]                   name <- removed[[kk]]
[10:31:51.335]                   NAME <- NAMES[[kk]]
[10:31:51.335]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:51.335]                     next
[10:31:51.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:51.335]                 }
[10:31:51.335]                 if (length(args) > 0) 
[10:31:51.335]                   base::do.call(base::Sys.setenv, args = args)
[10:31:51.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:51.335]             }
[10:31:51.335]             else {
[10:31:51.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:51.335]             }
[10:31:51.335]             {
[10:31:51.335]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:51.335]                   0L) {
[10:31:51.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:51.335]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:51.335]                   base::options(opts)
[10:31:51.335]                 }
[10:31:51.335]                 {
[10:31:51.335]                   {
[10:31:51.335]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:51.335]                     NULL
[10:31:51.335]                   }
[10:31:51.335]                   options(future.plan = NULL)
[10:31:51.335]                   if (is.na(NA_character_)) 
[10:31:51.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:51.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:51.335]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:51.335]                     .init = FALSE)
[10:31:51.335]                 }
[10:31:51.335]             }
[10:31:51.335]         }
[10:31:51.335]     })
[10:31:51.335]     if (FALSE) {
[10:31:51.335]         base::sink(type = "output", split = FALSE)
[10:31:51.335]         if (NA) {
[10:31:51.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:51.335]         }
[10:31:51.335]         else {
[10:31:51.335]             ...future.result["stdout"] <- base::list(NULL)
[10:31:51.335]         }
[10:31:51.335]         base::close(...future.stdout)
[10:31:51.335]         ...future.stdout <- NULL
[10:31:51.335]     }
[10:31:51.335]     ...future.result$conditions <- ...future.conditions
[10:31:51.335]     ...future.result$finished <- base::Sys.time()
[10:31:51.335]     ...future.result
[10:31:51.335] }
[10:31:51.338] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[10:31:51.338] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[10:31:51.339] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[10:31:51.339] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:51.339] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:51.339] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:31:51.340] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:31:51.340] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:51.340] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:51.340] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:51.341] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:51.341] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[10:31:51.341] MultisessionFuture started
[10:31:51.341] - Launch lazy future ... done
[10:31:51.342] run() for ‘MultisessionFuture’ ... done
[10:31:51.342] Created future:
[10:31:51.342] MultisessionFuture:
[10:31:51.342] Label: ‘future_lapply-1’
[10:31:51.342] Expression:
[10:31:51.342] {
[10:31:51.342]     do.call(function(...) {
[10:31:51.342]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:51.342]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:51.342]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:51.342]             on.exit(options(oopts), add = TRUE)
[10:31:51.342]         }
[10:31:51.342]         {
[10:31:51.342]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:51.342]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:51.342]                 ...future.FUN(...future.X_jj, ...)
[10:31:51.342]             })
[10:31:51.342]         }
[10:31:51.342]     }, args = future.call.arguments)
[10:31:51.342] }
[10:31:51.342] Lazy evaluation: FALSE
[10:31:51.342] Asynchronous evaluation: TRUE
[10:31:51.342] Local evaluation: TRUE
[10:31:51.342] Environment: R_GlobalEnv
[10:31:51.342] Capture standard output: NA
[10:31:51.342] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:51.342] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:51.342] Packages: <none>
[10:31:51.342] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:51.342] Resolved: FALSE
[10:31:51.342] Value: <not collected>
[10:31:51.342] Conditions captured: <none>
[10:31:51.342] Early signaling: FALSE
[10:31:51.342] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:51.342] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:51.353] Chunk #1 of 2 ... DONE
[10:31:51.353] Chunk #2 of 2 ...
[10:31:51.354]  - Finding globals in 'X' for chunk #2 ...
[10:31:51.354] getGlobalsAndPackages() ...
[10:31:51.354] Searching for globals...
[10:31:51.354] 
[10:31:51.354] Searching for globals ... DONE
[10:31:51.354] - globals: [0] <none>
[10:31:51.354] getGlobalsAndPackages() ... DONE
[10:31:51.354]    + additional globals found: [n=0] 
[10:31:51.355]    + additional namespaces needed: [n=0] 
[10:31:51.355]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:51.355]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:51.355]  - seeds: <none>
[10:31:51.355]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:51.355] getGlobalsAndPackages() ...
[10:31:51.355] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:51.355] Resolving globals: FALSE
[10:31:51.355] Tweak future expression to call with '...' arguments ...
[10:31:51.355] {
[10:31:51.355]     do.call(function(...) {
[10:31:51.355]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:51.355]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:51.355]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:51.355]             on.exit(options(oopts), add = TRUE)
[10:31:51.355]         }
[10:31:51.355]         {
[10:31:51.355]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:51.355]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:51.355]                 ...future.FUN(...future.X_jj, ...)
[10:31:51.355]             })
[10:31:51.355]         }
[10:31:51.355]     }, args = future.call.arguments)
[10:31:51.355] }
[10:31:51.356] Tweak future expression to call with '...' arguments ... DONE
[10:31:51.356] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:51.356] 
[10:31:51.356] getGlobalsAndPackages() ... DONE
[10:31:51.356] run() for ‘Future’ ...
[10:31:51.357] - state: ‘created’
[10:31:51.357] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:51.370] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:51.371] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:51.371]   - Field: ‘node’
[10:31:51.371]   - Field: ‘label’
[10:31:51.371]   - Field: ‘local’
[10:31:51.371]   - Field: ‘owner’
[10:31:51.371]   - Field: ‘envir’
[10:31:51.371]   - Field: ‘workers’
[10:31:51.371]   - Field: ‘packages’
[10:31:51.371]   - Field: ‘gc’
[10:31:51.372]   - Field: ‘conditions’
[10:31:51.372]   - Field: ‘persistent’
[10:31:51.372]   - Field: ‘expr’
[10:31:51.372]   - Field: ‘uuid’
[10:31:51.372]   - Field: ‘seed’
[10:31:51.372]   - Field: ‘version’
[10:31:51.372]   - Field: ‘result’
[10:31:51.372]   - Field: ‘asynchronous’
[10:31:51.372]   - Field: ‘calls’
[10:31:51.372]   - Field: ‘globals’
[10:31:51.372]   - Field: ‘stdout’
[10:31:51.373]   - Field: ‘earlySignal’
[10:31:51.373]   - Field: ‘lazy’
[10:31:51.373]   - Field: ‘state’
[10:31:51.373] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:51.373] - Launch lazy future ...
[10:31:51.373] Packages needed by the future expression (n = 0): <none>
[10:31:51.373] Packages needed by future strategies (n = 0): <none>
[10:31:51.374] {
[10:31:51.374]     {
[10:31:51.374]         {
[10:31:51.374]             ...future.startTime <- base::Sys.time()
[10:31:51.374]             {
[10:31:51.374]                 {
[10:31:51.374]                   {
[10:31:51.374]                     {
[10:31:51.374]                       base::local({
[10:31:51.374]                         has_future <- base::requireNamespace("future", 
[10:31:51.374]                           quietly = TRUE)
[10:31:51.374]                         if (has_future) {
[10:31:51.374]                           ns <- base::getNamespace("future")
[10:31:51.374]                           version <- ns[[".package"]][["version"]]
[10:31:51.374]                           if (is.null(version)) 
[10:31:51.374]                             version <- utils::packageVersion("future")
[10:31:51.374]                         }
[10:31:51.374]                         else {
[10:31:51.374]                           version <- NULL
[10:31:51.374]                         }
[10:31:51.374]                         if (!has_future || version < "1.8.0") {
[10:31:51.374]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:51.374]                             "", base::R.version$version.string), 
[10:31:51.374]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:51.374]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:51.374]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:51.374]                               "release", "version")], collapse = " "), 
[10:31:51.374]                             hostname = base::Sys.info()[["nodename"]])
[10:31:51.374]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:51.374]                             info)
[10:31:51.374]                           info <- base::paste(info, collapse = "; ")
[10:31:51.374]                           if (!has_future) {
[10:31:51.374]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:51.374]                               info)
[10:31:51.374]                           }
[10:31:51.374]                           else {
[10:31:51.374]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:51.374]                               info, version)
[10:31:51.374]                           }
[10:31:51.374]                           base::stop(msg)
[10:31:51.374]                         }
[10:31:51.374]                       })
[10:31:51.374]                     }
[10:31:51.374]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:51.374]                     base::options(mc.cores = 1L)
[10:31:51.374]                   }
[10:31:51.374]                   ...future.strategy.old <- future::plan("list")
[10:31:51.374]                   options(future.plan = NULL)
[10:31:51.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:51.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:51.374]                 }
[10:31:51.374]                 ...future.workdir <- getwd()
[10:31:51.374]             }
[10:31:51.374]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:51.374]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:51.374]         }
[10:31:51.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:51.374]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:51.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:51.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:51.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:51.374]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:51.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:51.374]             base::names(...future.oldOptions))
[10:31:51.374]     }
[10:31:51.374]     if (TRUE) {
[10:31:51.374]     }
[10:31:51.374]     else {
[10:31:51.374]         if (NA) {
[10:31:51.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:51.374]                 open = "w")
[10:31:51.374]         }
[10:31:51.374]         else {
[10:31:51.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:51.374]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:51.374]         }
[10:31:51.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:51.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:51.374]             base::sink(type = "output", split = FALSE)
[10:31:51.374]             base::close(...future.stdout)
[10:31:51.374]         }, add = TRUE)
[10:31:51.374]     }
[10:31:51.374]     ...future.frame <- base::sys.nframe()
[10:31:51.374]     ...future.conditions <- base::list()
[10:31:51.374]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:51.374]     if (FALSE) {
[10:31:51.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:51.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:51.374]     }
[10:31:51.374]     ...future.result <- base::tryCatch({
[10:31:51.374]         base::withCallingHandlers({
[10:31:51.374]             ...future.value <- base::withVisible(base::local({
[10:31:51.374]                 ...future.makeSendCondition <- base::local({
[10:31:51.374]                   sendCondition <- NULL
[10:31:51.374]                   function(frame = 1L) {
[10:31:51.374]                     if (is.function(sendCondition)) 
[10:31:51.374]                       return(sendCondition)
[10:31:51.374]                     ns <- getNamespace("parallel")
[10:31:51.374]                     if (exists("sendData", mode = "function", 
[10:31:51.374]                       envir = ns)) {
[10:31:51.374]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:51.374]                         envir = ns)
[10:31:51.374]                       envir <- sys.frame(frame)
[10:31:51.374]                       master <- NULL
[10:31:51.374]                       while (!identical(envir, .GlobalEnv) && 
[10:31:51.374]                         !identical(envir, emptyenv())) {
[10:31:51.374]                         if (exists("master", mode = "list", envir = envir, 
[10:31:51.374]                           inherits = FALSE)) {
[10:31:51.374]                           master <- get("master", mode = "list", 
[10:31:51.374]                             envir = envir, inherits = FALSE)
[10:31:51.374]                           if (inherits(master, c("SOCKnode", 
[10:31:51.374]                             "SOCK0node"))) {
[10:31:51.374]                             sendCondition <<- function(cond) {
[10:31:51.374]                               data <- list(type = "VALUE", value = cond, 
[10:31:51.374]                                 success = TRUE)
[10:31:51.374]                               parallel_sendData(master, data)
[10:31:51.374]                             }
[10:31:51.374]                             return(sendCondition)
[10:31:51.374]                           }
[10:31:51.374]                         }
[10:31:51.374]                         frame <- frame + 1L
[10:31:51.374]                         envir <- sys.frame(frame)
[10:31:51.374]                       }
[10:31:51.374]                     }
[10:31:51.374]                     sendCondition <<- function(cond) NULL
[10:31:51.374]                   }
[10:31:51.374]                 })
[10:31:51.374]                 withCallingHandlers({
[10:31:51.374]                   {
[10:31:51.374]                     do.call(function(...) {
[10:31:51.374]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:51.374]                       if (!identical(...future.globals.maxSize.org, 
[10:31:51.374]                         ...future.globals.maxSize)) {
[10:31:51.374]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:51.374]                         on.exit(options(oopts), add = TRUE)
[10:31:51.374]                       }
[10:31:51.374]                       {
[10:31:51.374]                         lapply(seq_along(...future.elements_ii), 
[10:31:51.374]                           FUN = function(jj) {
[10:31:51.374]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:51.374]                             ...future.FUN(...future.X_jj, ...)
[10:31:51.374]                           })
[10:31:51.374]                       }
[10:31:51.374]                     }, args = future.call.arguments)
[10:31:51.374]                   }
[10:31:51.374]                 }, immediateCondition = function(cond) {
[10:31:51.374]                   sendCondition <- ...future.makeSendCondition()
[10:31:51.374]                   sendCondition(cond)
[10:31:51.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:51.374]                   {
[10:31:51.374]                     inherits <- base::inherits
[10:31:51.374]                     invokeRestart <- base::invokeRestart
[10:31:51.374]                     is.null <- base::is.null
[10:31:51.374]                     muffled <- FALSE
[10:31:51.374]                     if (inherits(cond, "message")) {
[10:31:51.374]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:51.374]                       if (muffled) 
[10:31:51.374]                         invokeRestart("muffleMessage")
[10:31:51.374]                     }
[10:31:51.374]                     else if (inherits(cond, "warning")) {
[10:31:51.374]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:51.374]                       if (muffled) 
[10:31:51.374]                         invokeRestart("muffleWarning")
[10:31:51.374]                     }
[10:31:51.374]                     else if (inherits(cond, "condition")) {
[10:31:51.374]                       if (!is.null(pattern)) {
[10:31:51.374]                         computeRestarts <- base::computeRestarts
[10:31:51.374]                         grepl <- base::grepl
[10:31:51.374]                         restarts <- computeRestarts(cond)
[10:31:51.374]                         for (restart in restarts) {
[10:31:51.374]                           name <- restart$name
[10:31:51.374]                           if (is.null(name)) 
[10:31:51.374]                             next
[10:31:51.374]                           if (!grepl(pattern, name)) 
[10:31:51.374]                             next
[10:31:51.374]                           invokeRestart(restart)
[10:31:51.374]                           muffled <- TRUE
[10:31:51.374]                           break
[10:31:51.374]                         }
[10:31:51.374]                       }
[10:31:51.374]                     }
[10:31:51.374]                     invisible(muffled)
[10:31:51.374]                   }
[10:31:51.374]                   muffleCondition(cond)
[10:31:51.374]                 })
[10:31:51.374]             }))
[10:31:51.374]             future::FutureResult(value = ...future.value$value, 
[10:31:51.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:51.374]                   ...future.rng), globalenv = if (FALSE) 
[10:31:51.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:51.374]                     ...future.globalenv.names))
[10:31:51.374]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:51.374]         }, condition = base::local({
[10:31:51.374]             c <- base::c
[10:31:51.374]             inherits <- base::inherits
[10:31:51.374]             invokeRestart <- base::invokeRestart
[10:31:51.374]             length <- base::length
[10:31:51.374]             list <- base::list
[10:31:51.374]             seq.int <- base::seq.int
[10:31:51.374]             signalCondition <- base::signalCondition
[10:31:51.374]             sys.calls <- base::sys.calls
[10:31:51.374]             `[[` <- base::`[[`
[10:31:51.374]             `+` <- base::`+`
[10:31:51.374]             `<<-` <- base::`<<-`
[10:31:51.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:51.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:51.374]                   3L)]
[10:31:51.374]             }
[10:31:51.374]             function(cond) {
[10:31:51.374]                 is_error <- inherits(cond, "error")
[10:31:51.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:51.374]                   NULL)
[10:31:51.374]                 if (is_error) {
[10:31:51.374]                   sessionInformation <- function() {
[10:31:51.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:51.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:51.374]                       search = base::search(), system = base::Sys.info())
[10:31:51.374]                   }
[10:31:51.374]                   ...future.conditions[[length(...future.conditions) + 
[10:31:51.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:51.374]                     cond$call), session = sessionInformation(), 
[10:31:51.374]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:51.374]                   signalCondition(cond)
[10:31:51.374]                 }
[10:31:51.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:51.374]                 "immediateCondition"))) {
[10:31:51.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:51.374]                   ...future.conditions[[length(...future.conditions) + 
[10:31:51.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:51.374]                   if (TRUE && !signal) {
[10:31:51.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:51.374]                     {
[10:31:51.374]                       inherits <- base::inherits
[10:31:51.374]                       invokeRestart <- base::invokeRestart
[10:31:51.374]                       is.null <- base::is.null
[10:31:51.374]                       muffled <- FALSE
[10:31:51.374]                       if (inherits(cond, "message")) {
[10:31:51.374]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:51.374]                         if (muffled) 
[10:31:51.374]                           invokeRestart("muffleMessage")
[10:31:51.374]                       }
[10:31:51.374]                       else if (inherits(cond, "warning")) {
[10:31:51.374]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:51.374]                         if (muffled) 
[10:31:51.374]                           invokeRestart("muffleWarning")
[10:31:51.374]                       }
[10:31:51.374]                       else if (inherits(cond, "condition")) {
[10:31:51.374]                         if (!is.null(pattern)) {
[10:31:51.374]                           computeRestarts <- base::computeRestarts
[10:31:51.374]                           grepl <- base::grepl
[10:31:51.374]                           restarts <- computeRestarts(cond)
[10:31:51.374]                           for (restart in restarts) {
[10:31:51.374]                             name <- restart$name
[10:31:51.374]                             if (is.null(name)) 
[10:31:51.374]                               next
[10:31:51.374]                             if (!grepl(pattern, name)) 
[10:31:51.374]                               next
[10:31:51.374]                             invokeRestart(restart)
[10:31:51.374]                             muffled <- TRUE
[10:31:51.374]                             break
[10:31:51.374]                           }
[10:31:51.374]                         }
[10:31:51.374]                       }
[10:31:51.374]                       invisible(muffled)
[10:31:51.374]                     }
[10:31:51.374]                     muffleCondition(cond, pattern = "^muffle")
[10:31:51.374]                   }
[10:31:51.374]                 }
[10:31:51.374]                 else {
[10:31:51.374]                   if (TRUE) {
[10:31:51.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:51.374]                     {
[10:31:51.374]                       inherits <- base::inherits
[10:31:51.374]                       invokeRestart <- base::invokeRestart
[10:31:51.374]                       is.null <- base::is.null
[10:31:51.374]                       muffled <- FALSE
[10:31:51.374]                       if (inherits(cond, "message")) {
[10:31:51.374]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:51.374]                         if (muffled) 
[10:31:51.374]                           invokeRestart("muffleMessage")
[10:31:51.374]                       }
[10:31:51.374]                       else if (inherits(cond, "warning")) {
[10:31:51.374]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:51.374]                         if (muffled) 
[10:31:51.374]                           invokeRestart("muffleWarning")
[10:31:51.374]                       }
[10:31:51.374]                       else if (inherits(cond, "condition")) {
[10:31:51.374]                         if (!is.null(pattern)) {
[10:31:51.374]                           computeRestarts <- base::computeRestarts
[10:31:51.374]                           grepl <- base::grepl
[10:31:51.374]                           restarts <- computeRestarts(cond)
[10:31:51.374]                           for (restart in restarts) {
[10:31:51.374]                             name <- restart$name
[10:31:51.374]                             if (is.null(name)) 
[10:31:51.374]                               next
[10:31:51.374]                             if (!grepl(pattern, name)) 
[10:31:51.374]                               next
[10:31:51.374]                             invokeRestart(restart)
[10:31:51.374]                             muffled <- TRUE
[10:31:51.374]                             break
[10:31:51.374]                           }
[10:31:51.374]                         }
[10:31:51.374]                       }
[10:31:51.374]                       invisible(muffled)
[10:31:51.374]                     }
[10:31:51.374]                     muffleCondition(cond, pattern = "^muffle")
[10:31:51.374]                   }
[10:31:51.374]                 }
[10:31:51.374]             }
[10:31:51.374]         }))
[10:31:51.374]     }, error = function(ex) {
[10:31:51.374]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:51.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:51.374]                 ...future.rng), started = ...future.startTime, 
[10:31:51.374]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:51.374]             version = "1.8"), class = "FutureResult")
[10:31:51.374]     }, finally = {
[10:31:51.374]         if (!identical(...future.workdir, getwd())) 
[10:31:51.374]             setwd(...future.workdir)
[10:31:51.374]         {
[10:31:51.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:51.374]                 ...future.oldOptions$nwarnings <- NULL
[10:31:51.374]             }
[10:31:51.374]             base::options(...future.oldOptions)
[10:31:51.374]             if (.Platform$OS.type == "windows") {
[10:31:51.374]                 old_names <- names(...future.oldEnvVars)
[10:31:51.374]                 envs <- base::Sys.getenv()
[10:31:51.374]                 names <- names(envs)
[10:31:51.374]                 common <- intersect(names, old_names)
[10:31:51.374]                 added <- setdiff(names, old_names)
[10:31:51.374]                 removed <- setdiff(old_names, names)
[10:31:51.374]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:51.374]                   envs[common]]
[10:31:51.374]                 NAMES <- toupper(changed)
[10:31:51.374]                 args <- list()
[10:31:51.374]                 for (kk in seq_along(NAMES)) {
[10:31:51.374]                   name <- changed[[kk]]
[10:31:51.374]                   NAME <- NAMES[[kk]]
[10:31:51.374]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:51.374]                     next
[10:31:51.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:51.374]                 }
[10:31:51.374]                 NAMES <- toupper(added)
[10:31:51.374]                 for (kk in seq_along(NAMES)) {
[10:31:51.374]                   name <- added[[kk]]
[10:31:51.374]                   NAME <- NAMES[[kk]]
[10:31:51.374]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:51.374]                     next
[10:31:51.374]                   args[[name]] <- ""
[10:31:51.374]                 }
[10:31:51.374]                 NAMES <- toupper(removed)
[10:31:51.374]                 for (kk in seq_along(NAMES)) {
[10:31:51.374]                   name <- removed[[kk]]
[10:31:51.374]                   NAME <- NAMES[[kk]]
[10:31:51.374]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:51.374]                     next
[10:31:51.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:51.374]                 }
[10:31:51.374]                 if (length(args) > 0) 
[10:31:51.374]                   base::do.call(base::Sys.setenv, args = args)
[10:31:51.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:51.374]             }
[10:31:51.374]             else {
[10:31:51.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:51.374]             }
[10:31:51.374]             {
[10:31:51.374]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:51.374]                   0L) {
[10:31:51.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:51.374]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:51.374]                   base::options(opts)
[10:31:51.374]                 }
[10:31:51.374]                 {
[10:31:51.374]                   {
[10:31:51.374]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:51.374]                     NULL
[10:31:51.374]                   }
[10:31:51.374]                   options(future.plan = NULL)
[10:31:51.374]                   if (is.na(NA_character_)) 
[10:31:51.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:51.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:51.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:51.374]                     .init = FALSE)
[10:31:51.374]                 }
[10:31:51.374]             }
[10:31:51.374]         }
[10:31:51.374]     })
[10:31:51.374]     if (FALSE) {
[10:31:51.374]         base::sink(type = "output", split = FALSE)
[10:31:51.374]         if (NA) {
[10:31:51.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:51.374]         }
[10:31:51.374]         else {
[10:31:51.374]             ...future.result["stdout"] <- base::list(NULL)
[10:31:51.374]         }
[10:31:51.374]         base::close(...future.stdout)
[10:31:51.374]         ...future.stdout <- NULL
[10:31:51.374]     }
[10:31:51.374]     ...future.result$conditions <- ...future.conditions
[10:31:51.374]     ...future.result$finished <- base::Sys.time()
[10:31:51.374]     ...future.result
[10:31:51.374] }
[10:31:51.377] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[10:31:51.377] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[10:31:51.377] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[10:31:51.377] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:31:51.378] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:31:51.378] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[10:31:51.378] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[10:31:51.378] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:51.379] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:51.379] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:51.379] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:51.379] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[10:31:51.380] MultisessionFuture started
[10:31:51.380] - Launch lazy future ... done
[10:31:51.380] run() for ‘MultisessionFuture’ ... done
[10:31:51.380] Created future:
[10:31:51.380] MultisessionFuture:
[10:31:51.380] Label: ‘future_lapply-2’
[10:31:51.380] Expression:
[10:31:51.380] {
[10:31:51.380]     do.call(function(...) {
[10:31:51.380]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:51.380]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:51.380]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:51.380]             on.exit(options(oopts), add = TRUE)
[10:31:51.380]         }
[10:31:51.380]         {
[10:31:51.380]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:51.380]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:51.380]                 ...future.FUN(...future.X_jj, ...)
[10:31:51.380]             })
[10:31:51.380]         }
[10:31:51.380]     }, args = future.call.arguments)
[10:31:51.380] }
[10:31:51.380] Lazy evaluation: FALSE
[10:31:51.380] Asynchronous evaluation: TRUE
[10:31:51.380] Local evaluation: TRUE
[10:31:51.380] Environment: R_GlobalEnv
[10:31:51.380] Capture standard output: NA
[10:31:51.380] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:51.380] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:51.380] Packages: <none>
[10:31:51.380] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:51.380] Resolved: FALSE
[10:31:51.380] Value: <not collected>
[10:31:51.380] Conditions captured: <none>
[10:31:51.380] Early signaling: FALSE
[10:31:51.380] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:51.380] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:51.392] Chunk #2 of 2 ... DONE
[10:31:51.392] Launching 2 futures (chunks) ... DONE
[10:31:51.392] Resolving 2 futures (chunks) ...
[10:31:51.392] resolve() on list ...
[10:31:51.392]  recursive: 0
[10:31:51.392]  length: 2
[10:31:51.392] 
[10:31:51.434] receiveMessageFromWorker() for ClusterFuture ...
[10:31:51.435] - Validating connection of MultisessionFuture
[10:31:51.435] - received message: FutureResult
[10:31:51.435] - Received FutureResult
[10:31:51.435] - Erased future from FutureRegistry
[10:31:51.435] result() for ClusterFuture ...
[10:31:51.435] - result already collected: FutureResult
[10:31:51.435] result() for ClusterFuture ... done
[10:31:51.435] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:51.436] Future #2
[10:31:51.436] result() for ClusterFuture ...
[10:31:51.436] - result already collected: FutureResult
[10:31:51.436] result() for ClusterFuture ... done
[10:31:51.436] result() for ClusterFuture ...
[10:31:51.436] - result already collected: FutureResult
[10:31:51.436] result() for ClusterFuture ... done
[10:31:51.436] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:51.436] - nx: 2
[10:31:51.436] - relay: TRUE
[10:31:51.436] - stdout: TRUE
[10:31:51.437] - signal: TRUE
[10:31:51.437] - resignal: FALSE
[10:31:51.437] - force: TRUE
[10:31:51.437] - relayed: [n=2] FALSE, FALSE
[10:31:51.437] - queued futures: [n=2] FALSE, FALSE
[10:31:51.437]  - until=1
[10:31:51.437]  - relaying element #1
[10:31:51.437] - relayed: [n=2] FALSE, FALSE
[10:31:51.437] - queued futures: [n=2] FALSE, TRUE
[10:31:51.437] signalConditionsASAP(NULL, pos=2) ... done
[10:31:51.438]  length: 1 (resolved future 2)
[10:31:51.887] receiveMessageFromWorker() for ClusterFuture ...
[10:31:51.887] - Validating connection of MultisessionFuture
[10:31:51.888] - received message: FutureResult
[10:31:51.888] - Received FutureResult
[10:31:51.888] - Erased future from FutureRegistry
[10:31:51.888] result() for ClusterFuture ...
[10:31:51.888] - result already collected: FutureResult
[10:31:51.888] result() for ClusterFuture ... done
[10:31:51.888] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:51.888] Future #1
[10:31:51.888] result() for ClusterFuture ...
[10:31:51.888] - result already collected: FutureResult
[10:31:51.889] result() for ClusterFuture ... done
[10:31:51.889] result() for ClusterFuture ...
[10:31:51.889] - result already collected: FutureResult
[10:31:51.889] result() for ClusterFuture ... done
[10:31:51.889] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:51.889] - nx: 2
[10:31:51.889] - relay: TRUE
[10:31:51.889] - stdout: TRUE
[10:31:51.889] - signal: TRUE
[10:31:51.889] - resignal: FALSE
[10:31:51.889] - force: TRUE
[10:31:51.890] - relayed: [n=2] FALSE, FALSE
[10:31:51.890] - queued futures: [n=2] FALSE, TRUE
[10:31:51.890]  - until=1
[10:31:51.890]  - relaying element #1
[10:31:51.890] result() for ClusterFuture ...
[10:31:51.890] - result already collected: FutureResult
[10:31:51.890] result() for ClusterFuture ... done
[10:31:51.890] result() for ClusterFuture ...
[10:31:51.890] - result already collected: FutureResult
[10:31:51.890] result() for ClusterFuture ... done
[10:31:51.890] result() for ClusterFuture ...
[10:31:51.891] - result already collected: FutureResult
[10:31:51.891] result() for ClusterFuture ... done
[10:31:51.891] result() for ClusterFuture ...
[10:31:51.891] - result already collected: FutureResult
[10:31:51.891] result() for ClusterFuture ... done
[10:31:51.891] - relayed: [n=2] TRUE, FALSE
[10:31:51.891] - queued futures: [n=2] TRUE, TRUE
[10:31:51.891] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:51.891]  length: 0 (resolved future 1)
[10:31:51.891] Relaying remaining futures
[10:31:51.891] signalConditionsASAP(NULL, pos=0) ...
[10:31:51.892] - nx: 2
[10:31:51.892] - relay: TRUE
[10:31:51.892] - stdout: TRUE
[10:31:51.892] - signal: TRUE
[10:31:51.892] - resignal: FALSE
[10:31:51.892] - force: TRUE
[10:31:51.892] - relayed: [n=2] TRUE, FALSE
[10:31:51.892] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:51.892]  - relaying element #2
[10:31:51.892] result() for ClusterFuture ...
[10:31:51.892] - result already collected: FutureResult
[10:31:51.893] result() for ClusterFuture ... done
[10:31:51.893] result() for ClusterFuture ...
[10:31:51.893] - result already collected: FutureResult
[10:31:51.893] result() for ClusterFuture ... done
[10:31:51.893] result() for ClusterFuture ...
[10:31:51.893] - result already collected: FutureResult
[10:31:51.893] result() for ClusterFuture ... done
[10:31:51.893] result() for ClusterFuture ...
[10:31:51.893] - result already collected: FutureResult
[10:31:51.893] result() for ClusterFuture ... done
[10:31:51.893] - relayed: [n=2] TRUE, TRUE
[10:31:51.893] - queued futures: [n=2] TRUE, TRUE
[10:31:51.894] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:31:51.894] resolve() on list ... DONE
[10:31:51.894] result() for ClusterFuture ...
[10:31:51.894] - result already collected: FutureResult
[10:31:51.894] result() for ClusterFuture ... done
[10:31:51.894] result() for ClusterFuture ...
[10:31:51.894] - result already collected: FutureResult
[10:31:51.894] result() for ClusterFuture ... done
[10:31:51.894] result() for ClusterFuture ...
[10:31:51.894] - result already collected: FutureResult
[10:31:51.894] result() for ClusterFuture ... done
[10:31:51.895] result() for ClusterFuture ...
[10:31:51.895] - result already collected: FutureResult
[10:31:51.895] result() for ClusterFuture ... done
[10:31:51.895]  - Number of value chunks collected: 2
[10:31:51.895] Resolving 2 futures (chunks) ... DONE
[10:31:51.895] Reducing values from 2 chunks ...
[10:31:51.895]  - Number of values collected after concatenation: 2
[10:31:51.895]  - Number of values expected: 2
[10:31:51.895] Reducing values from 2 chunks ... DONE
[10:31:51.895] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[10:31:51.896] future_mapply() ...
[10:31:51.900] Number of chunks: 2
[10:31:51.900] getGlobalsAndPackagesXApply() ...
[10:31:51.900]  - future.globals: TRUE
[10:31:51.900] getGlobalsAndPackages() ...
[10:31:51.901] Searching for globals...
[10:31:51.902] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:51.902] Searching for globals ... DONE
[10:31:51.903] Resolving globals: FALSE
[10:31:51.903] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:51.903] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:51.903] - globals: [1] ‘FUN’
[10:31:51.904] 
[10:31:51.904] getGlobalsAndPackages() ... DONE
[10:31:51.904]  - globals found/used: [n=1] ‘FUN’
[10:31:51.904]  - needed namespaces: [n=0] 
[10:31:51.904] Finding globals ... DONE
[10:31:51.904] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:51.904] List of 2
[10:31:51.904]  $ ...future.FUN:function (x, y)  
[10:31:51.904]  $ MoreArgs     : NULL
[10:31:51.904]  - attr(*, "where")=List of 2
[10:31:51.904]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:51.904]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:51.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:51.904]  - attr(*, "resolved")= logi FALSE
[10:31:51.904]  - attr(*, "total_size")= num NA
[10:31:51.907] Packages to be attached in all futures: [n=0] 
[10:31:51.907] getGlobalsAndPackagesXApply() ... DONE
[10:31:51.907] Number of futures (= number of chunks): 2
[10:31:51.907] Launching 2 futures (chunks) ...
[10:31:51.907] Chunk #1 of 2 ...
[10:31:51.907]  - Finding globals in '...' for chunk #1 ...
[10:31:51.908] getGlobalsAndPackages() ...
[10:31:51.908] Searching for globals...
[10:31:51.908] 
[10:31:51.908] Searching for globals ... DONE
[10:31:51.908] - globals: [0] <none>
[10:31:51.908] getGlobalsAndPackages() ... DONE
[10:31:51.908]    + additional globals found: [n=0] 
[10:31:51.910]    + additional namespaces needed: [n=0] 
[10:31:51.910]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:51.910]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:51.911]  - seeds: <none>
[10:31:51.911]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:51.911] getGlobalsAndPackages() ...
[10:31:51.911] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:51.911] Resolving globals: FALSE
[10:31:51.911] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:31:51.912] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:51.912] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:51.912] 
[10:31:51.912] getGlobalsAndPackages() ... DONE
[10:31:51.913] run() for ‘Future’ ...
[10:31:51.913] - state: ‘created’
[10:31:51.913] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:51.928] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:51.928] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:51.928]   - Field: ‘node’
[10:31:51.928]   - Field: ‘label’
[10:31:51.928]   - Field: ‘local’
[10:31:51.928]   - Field: ‘owner’
[10:31:51.928]   - Field: ‘envir’
[10:31:51.929]   - Field: ‘workers’
[10:31:51.929]   - Field: ‘packages’
[10:31:51.929]   - Field: ‘gc’
[10:31:51.929]   - Field: ‘conditions’
[10:31:51.929]   - Field: ‘persistent’
[10:31:51.929]   - Field: ‘expr’
[10:31:51.929]   - Field: ‘uuid’
[10:31:51.929]   - Field: ‘seed’
[10:31:51.929]   - Field: ‘version’
[10:31:51.929]   - Field: ‘result’
[10:31:51.930]   - Field: ‘asynchronous’
[10:31:51.930]   - Field: ‘calls’
[10:31:51.930]   - Field: ‘globals’
[10:31:51.930]   - Field: ‘stdout’
[10:31:51.930]   - Field: ‘earlySignal’
[10:31:51.930]   - Field: ‘lazy’
[10:31:51.930]   - Field: ‘state’
[10:31:51.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:51.930] - Launch lazy future ...
[10:31:51.931] Packages needed by the future expression (n = 0): <none>
[10:31:51.931] Packages needed by future strategies (n = 0): <none>
[10:31:51.931] {
[10:31:51.931]     {
[10:31:51.931]         {
[10:31:51.931]             ...future.startTime <- base::Sys.time()
[10:31:51.931]             {
[10:31:51.931]                 {
[10:31:51.931]                   {
[10:31:51.931]                     {
[10:31:51.931]                       base::local({
[10:31:51.931]                         has_future <- base::requireNamespace("future", 
[10:31:51.931]                           quietly = TRUE)
[10:31:51.931]                         if (has_future) {
[10:31:51.931]                           ns <- base::getNamespace("future")
[10:31:51.931]                           version <- ns[[".package"]][["version"]]
[10:31:51.931]                           if (is.null(version)) 
[10:31:51.931]                             version <- utils::packageVersion("future")
[10:31:51.931]                         }
[10:31:51.931]                         else {
[10:31:51.931]                           version <- NULL
[10:31:51.931]                         }
[10:31:51.931]                         if (!has_future || version < "1.8.0") {
[10:31:51.931]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:51.931]                             "", base::R.version$version.string), 
[10:31:51.931]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:51.931]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:51.931]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:51.931]                               "release", "version")], collapse = " "), 
[10:31:51.931]                             hostname = base::Sys.info()[["nodename"]])
[10:31:51.931]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:51.931]                             info)
[10:31:51.931]                           info <- base::paste(info, collapse = "; ")
[10:31:51.931]                           if (!has_future) {
[10:31:51.931]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:51.931]                               info)
[10:31:51.931]                           }
[10:31:51.931]                           else {
[10:31:51.931]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:51.931]                               info, version)
[10:31:51.931]                           }
[10:31:51.931]                           base::stop(msg)
[10:31:51.931]                         }
[10:31:51.931]                       })
[10:31:51.931]                     }
[10:31:51.931]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:51.931]                     base::options(mc.cores = 1L)
[10:31:51.931]                   }
[10:31:51.931]                   ...future.strategy.old <- future::plan("list")
[10:31:51.931]                   options(future.plan = NULL)
[10:31:51.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:51.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:51.931]                 }
[10:31:51.931]                 ...future.workdir <- getwd()
[10:31:51.931]             }
[10:31:51.931]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:51.931]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:51.931]         }
[10:31:51.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:51.931]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:51.931]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:51.931]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:51.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:51.931]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:51.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:51.931]             base::names(...future.oldOptions))
[10:31:51.931]     }
[10:31:51.931]     if (FALSE) {
[10:31:51.931]     }
[10:31:51.931]     else {
[10:31:51.931]         if (FALSE) {
[10:31:51.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:51.931]                 open = "w")
[10:31:51.931]         }
[10:31:51.931]         else {
[10:31:51.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:51.931]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:51.931]         }
[10:31:51.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:51.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:51.931]             base::sink(type = "output", split = FALSE)
[10:31:51.931]             base::close(...future.stdout)
[10:31:51.931]         }, add = TRUE)
[10:31:51.931]     }
[10:31:51.931]     ...future.frame <- base::sys.nframe()
[10:31:51.931]     ...future.conditions <- base::list()
[10:31:51.931]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:51.931]     if (FALSE) {
[10:31:51.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:51.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:51.931]     }
[10:31:51.931]     ...future.result <- base::tryCatch({
[10:31:51.931]         base::withCallingHandlers({
[10:31:51.931]             ...future.value <- base::withVisible(base::local({
[10:31:51.931]                 ...future.makeSendCondition <- base::local({
[10:31:51.931]                   sendCondition <- NULL
[10:31:51.931]                   function(frame = 1L) {
[10:31:51.931]                     if (is.function(sendCondition)) 
[10:31:51.931]                       return(sendCondition)
[10:31:51.931]                     ns <- getNamespace("parallel")
[10:31:51.931]                     if (exists("sendData", mode = "function", 
[10:31:51.931]                       envir = ns)) {
[10:31:51.931]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:51.931]                         envir = ns)
[10:31:51.931]                       envir <- sys.frame(frame)
[10:31:51.931]                       master <- NULL
[10:31:51.931]                       while (!identical(envir, .GlobalEnv) && 
[10:31:51.931]                         !identical(envir, emptyenv())) {
[10:31:51.931]                         if (exists("master", mode = "list", envir = envir, 
[10:31:51.931]                           inherits = FALSE)) {
[10:31:51.931]                           master <- get("master", mode = "list", 
[10:31:51.931]                             envir = envir, inherits = FALSE)
[10:31:51.931]                           if (inherits(master, c("SOCKnode", 
[10:31:51.931]                             "SOCK0node"))) {
[10:31:51.931]                             sendCondition <<- function(cond) {
[10:31:51.931]                               data <- list(type = "VALUE", value = cond, 
[10:31:51.931]                                 success = TRUE)
[10:31:51.931]                               parallel_sendData(master, data)
[10:31:51.931]                             }
[10:31:51.931]                             return(sendCondition)
[10:31:51.931]                           }
[10:31:51.931]                         }
[10:31:51.931]                         frame <- frame + 1L
[10:31:51.931]                         envir <- sys.frame(frame)
[10:31:51.931]                       }
[10:31:51.931]                     }
[10:31:51.931]                     sendCondition <<- function(cond) NULL
[10:31:51.931]                   }
[10:31:51.931]                 })
[10:31:51.931]                 withCallingHandlers({
[10:31:51.931]                   {
[10:31:51.931]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:51.931]                     if (!identical(...future.globals.maxSize.org, 
[10:31:51.931]                       ...future.globals.maxSize)) {
[10:31:51.931]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:51.931]                       on.exit(options(oopts), add = TRUE)
[10:31:51.931]                     }
[10:31:51.931]                     {
[10:31:51.931]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:51.931]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:51.931]                         USE.NAMES = FALSE)
[10:31:51.931]                       do.call(mapply, args = args)
[10:31:51.931]                     }
[10:31:51.931]                   }
[10:31:51.931]                 }, immediateCondition = function(cond) {
[10:31:51.931]                   sendCondition <- ...future.makeSendCondition()
[10:31:51.931]                   sendCondition(cond)
[10:31:51.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:51.931]                   {
[10:31:51.931]                     inherits <- base::inherits
[10:31:51.931]                     invokeRestart <- base::invokeRestart
[10:31:51.931]                     is.null <- base::is.null
[10:31:51.931]                     muffled <- FALSE
[10:31:51.931]                     if (inherits(cond, "message")) {
[10:31:51.931]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:51.931]                       if (muffled) 
[10:31:51.931]                         invokeRestart("muffleMessage")
[10:31:51.931]                     }
[10:31:51.931]                     else if (inherits(cond, "warning")) {
[10:31:51.931]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:51.931]                       if (muffled) 
[10:31:51.931]                         invokeRestart("muffleWarning")
[10:31:51.931]                     }
[10:31:51.931]                     else if (inherits(cond, "condition")) {
[10:31:51.931]                       if (!is.null(pattern)) {
[10:31:51.931]                         computeRestarts <- base::computeRestarts
[10:31:51.931]                         grepl <- base::grepl
[10:31:51.931]                         restarts <- computeRestarts(cond)
[10:31:51.931]                         for (restart in restarts) {
[10:31:51.931]                           name <- restart$name
[10:31:51.931]                           if (is.null(name)) 
[10:31:51.931]                             next
[10:31:51.931]                           if (!grepl(pattern, name)) 
[10:31:51.931]                             next
[10:31:51.931]                           invokeRestart(restart)
[10:31:51.931]                           muffled <- TRUE
[10:31:51.931]                           break
[10:31:51.931]                         }
[10:31:51.931]                       }
[10:31:51.931]                     }
[10:31:51.931]                     invisible(muffled)
[10:31:51.931]                   }
[10:31:51.931]                   muffleCondition(cond)
[10:31:51.931]                 })
[10:31:51.931]             }))
[10:31:51.931]             future::FutureResult(value = ...future.value$value, 
[10:31:51.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:51.931]                   ...future.rng), globalenv = if (FALSE) 
[10:31:51.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:51.931]                     ...future.globalenv.names))
[10:31:51.931]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:51.931]         }, condition = base::local({
[10:31:51.931]             c <- base::c
[10:31:51.931]             inherits <- base::inherits
[10:31:51.931]             invokeRestart <- base::invokeRestart
[10:31:51.931]             length <- base::length
[10:31:51.931]             list <- base::list
[10:31:51.931]             seq.int <- base::seq.int
[10:31:51.931]             signalCondition <- base::signalCondition
[10:31:51.931]             sys.calls <- base::sys.calls
[10:31:51.931]             `[[` <- base::`[[`
[10:31:51.931]             `+` <- base::`+`
[10:31:51.931]             `<<-` <- base::`<<-`
[10:31:51.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:51.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:51.931]                   3L)]
[10:31:51.931]             }
[10:31:51.931]             function(cond) {
[10:31:51.931]                 is_error <- inherits(cond, "error")
[10:31:51.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:51.931]                   NULL)
[10:31:51.931]                 if (is_error) {
[10:31:51.931]                   sessionInformation <- function() {
[10:31:51.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:51.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:51.931]                       search = base::search(), system = base::Sys.info())
[10:31:51.931]                   }
[10:31:51.931]                   ...future.conditions[[length(...future.conditions) + 
[10:31:51.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:51.931]                     cond$call), session = sessionInformation(), 
[10:31:51.931]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:51.931]                   signalCondition(cond)
[10:31:51.931]                 }
[10:31:51.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:51.931]                 "immediateCondition"))) {
[10:31:51.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:51.931]                   ...future.conditions[[length(...future.conditions) + 
[10:31:51.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:51.931]                   if (TRUE && !signal) {
[10:31:51.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:51.931]                     {
[10:31:51.931]                       inherits <- base::inherits
[10:31:51.931]                       invokeRestart <- base::invokeRestart
[10:31:51.931]                       is.null <- base::is.null
[10:31:51.931]                       muffled <- FALSE
[10:31:51.931]                       if (inherits(cond, "message")) {
[10:31:51.931]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:51.931]                         if (muffled) 
[10:31:51.931]                           invokeRestart("muffleMessage")
[10:31:51.931]                       }
[10:31:51.931]                       else if (inherits(cond, "warning")) {
[10:31:51.931]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:51.931]                         if (muffled) 
[10:31:51.931]                           invokeRestart("muffleWarning")
[10:31:51.931]                       }
[10:31:51.931]                       else if (inherits(cond, "condition")) {
[10:31:51.931]                         if (!is.null(pattern)) {
[10:31:51.931]                           computeRestarts <- base::computeRestarts
[10:31:51.931]                           grepl <- base::grepl
[10:31:51.931]                           restarts <- computeRestarts(cond)
[10:31:51.931]                           for (restart in restarts) {
[10:31:51.931]                             name <- restart$name
[10:31:51.931]                             if (is.null(name)) 
[10:31:51.931]                               next
[10:31:51.931]                             if (!grepl(pattern, name)) 
[10:31:51.931]                               next
[10:31:51.931]                             invokeRestart(restart)
[10:31:51.931]                             muffled <- TRUE
[10:31:51.931]                             break
[10:31:51.931]                           }
[10:31:51.931]                         }
[10:31:51.931]                       }
[10:31:51.931]                       invisible(muffled)
[10:31:51.931]                     }
[10:31:51.931]                     muffleCondition(cond, pattern = "^muffle")
[10:31:51.931]                   }
[10:31:51.931]                 }
[10:31:51.931]                 else {
[10:31:51.931]                   if (TRUE) {
[10:31:51.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:51.931]                     {
[10:31:51.931]                       inherits <- base::inherits
[10:31:51.931]                       invokeRestart <- base::invokeRestart
[10:31:51.931]                       is.null <- base::is.null
[10:31:51.931]                       muffled <- FALSE
[10:31:51.931]                       if (inherits(cond, "message")) {
[10:31:51.931]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:51.931]                         if (muffled) 
[10:31:51.931]                           invokeRestart("muffleMessage")
[10:31:51.931]                       }
[10:31:51.931]                       else if (inherits(cond, "warning")) {
[10:31:51.931]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:51.931]                         if (muffled) 
[10:31:51.931]                           invokeRestart("muffleWarning")
[10:31:51.931]                       }
[10:31:51.931]                       else if (inherits(cond, "condition")) {
[10:31:51.931]                         if (!is.null(pattern)) {
[10:31:51.931]                           computeRestarts <- base::computeRestarts
[10:31:51.931]                           grepl <- base::grepl
[10:31:51.931]                           restarts <- computeRestarts(cond)
[10:31:51.931]                           for (restart in restarts) {
[10:31:51.931]                             name <- restart$name
[10:31:51.931]                             if (is.null(name)) 
[10:31:51.931]                               next
[10:31:51.931]                             if (!grepl(pattern, name)) 
[10:31:51.931]                               next
[10:31:51.931]                             invokeRestart(restart)
[10:31:51.931]                             muffled <- TRUE
[10:31:51.931]                             break
[10:31:51.931]                           }
[10:31:51.931]                         }
[10:31:51.931]                       }
[10:31:51.931]                       invisible(muffled)
[10:31:51.931]                     }
[10:31:51.931]                     muffleCondition(cond, pattern = "^muffle")
[10:31:51.931]                   }
[10:31:51.931]                 }
[10:31:51.931]             }
[10:31:51.931]         }))
[10:31:51.931]     }, error = function(ex) {
[10:31:51.931]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:51.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:51.931]                 ...future.rng), started = ...future.startTime, 
[10:31:51.931]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:51.931]             version = "1.8"), class = "FutureResult")
[10:31:51.931]     }, finally = {
[10:31:51.931]         if (!identical(...future.workdir, getwd())) 
[10:31:51.931]             setwd(...future.workdir)
[10:31:51.931]         {
[10:31:51.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:51.931]                 ...future.oldOptions$nwarnings <- NULL
[10:31:51.931]             }
[10:31:51.931]             base::options(...future.oldOptions)
[10:31:51.931]             if (.Platform$OS.type == "windows") {
[10:31:51.931]                 old_names <- names(...future.oldEnvVars)
[10:31:51.931]                 envs <- base::Sys.getenv()
[10:31:51.931]                 names <- names(envs)
[10:31:51.931]                 common <- intersect(names, old_names)
[10:31:51.931]                 added <- setdiff(names, old_names)
[10:31:51.931]                 removed <- setdiff(old_names, names)
[10:31:51.931]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:51.931]                   envs[common]]
[10:31:51.931]                 NAMES <- toupper(changed)
[10:31:51.931]                 args <- list()
[10:31:51.931]                 for (kk in seq_along(NAMES)) {
[10:31:51.931]                   name <- changed[[kk]]
[10:31:51.931]                   NAME <- NAMES[[kk]]
[10:31:51.931]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:51.931]                     next
[10:31:51.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:51.931]                 }
[10:31:51.931]                 NAMES <- toupper(added)
[10:31:51.931]                 for (kk in seq_along(NAMES)) {
[10:31:51.931]                   name <- added[[kk]]
[10:31:51.931]                   NAME <- NAMES[[kk]]
[10:31:51.931]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:51.931]                     next
[10:31:51.931]                   args[[name]] <- ""
[10:31:51.931]                 }
[10:31:51.931]                 NAMES <- toupper(removed)
[10:31:51.931]                 for (kk in seq_along(NAMES)) {
[10:31:51.931]                   name <- removed[[kk]]
[10:31:51.931]                   NAME <- NAMES[[kk]]
[10:31:51.931]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:51.931]                     next
[10:31:51.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:51.931]                 }
[10:31:51.931]                 if (length(args) > 0) 
[10:31:51.931]                   base::do.call(base::Sys.setenv, args = args)
[10:31:51.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:51.931]             }
[10:31:51.931]             else {
[10:31:51.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:51.931]             }
[10:31:51.931]             {
[10:31:51.931]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:51.931]                   0L) {
[10:31:51.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:51.931]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:51.931]                   base::options(opts)
[10:31:51.931]                 }
[10:31:51.931]                 {
[10:31:51.931]                   {
[10:31:51.931]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:51.931]                     NULL
[10:31:51.931]                   }
[10:31:51.931]                   options(future.plan = NULL)
[10:31:51.931]                   if (is.na(NA_character_)) 
[10:31:51.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:51.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:51.931]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:51.931]                     .init = FALSE)
[10:31:51.931]                 }
[10:31:51.931]             }
[10:31:51.931]         }
[10:31:51.931]     })
[10:31:51.931]     if (TRUE) {
[10:31:51.931]         base::sink(type = "output", split = FALSE)
[10:31:51.931]         if (FALSE) {
[10:31:51.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:51.931]         }
[10:31:51.931]         else {
[10:31:51.931]             ...future.result["stdout"] <- base::list(NULL)
[10:31:51.931]         }
[10:31:51.931]         base::close(...future.stdout)
[10:31:51.931]         ...future.stdout <- NULL
[10:31:51.931]     }
[10:31:51.931]     ...future.result$conditions <- ...future.conditions
[10:31:51.931]     ...future.result$finished <- base::Sys.time()
[10:31:51.931]     ...future.result
[10:31:51.931] }
[10:31:51.934] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[10:31:51.935] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[10:31:51.935] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[10:31:51.935] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:31:51.935] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:31:51.936] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:31:51.936] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:31:51.936] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:51.936] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:51.937] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:51.937] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:51.937] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[10:31:51.938] MultisessionFuture started
[10:31:51.938] - Launch lazy future ... done
[10:31:51.938] run() for ‘MultisessionFuture’ ... done
[10:31:51.938] Created future:
[10:31:51.938] MultisessionFuture:
[10:31:51.938] Label: ‘future_mapply-1’
[10:31:51.938] Expression:
[10:31:51.938] {
[10:31:51.938]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:51.938]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:51.938]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:51.938]         on.exit(options(oopts), add = TRUE)
[10:31:51.938]     }
[10:31:51.938]     {
[10:31:51.938]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:51.938]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:51.938]         do.call(mapply, args = args)
[10:31:51.938]     }
[10:31:51.938] }
[10:31:51.938] Lazy evaluation: FALSE
[10:31:51.938] Asynchronous evaluation: TRUE
[10:31:51.938] Local evaluation: TRUE
[10:31:51.938] Environment: R_GlobalEnv
[10:31:51.938] Capture standard output: FALSE
[10:31:51.938] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:51.938] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:51.938] Packages: <none>
[10:31:51.938] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:51.938] Resolved: FALSE
[10:31:51.938] Value: <not collected>
[10:31:51.938] Conditions captured: <none>
[10:31:51.938] Early signaling: FALSE
[10:31:51.938] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:51.938] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:51.950] Chunk #1 of 2 ... DONE
[10:31:51.950] Chunk #2 of 2 ...
[10:31:51.950]  - Finding globals in '...' for chunk #2 ...
[10:31:51.950] getGlobalsAndPackages() ...
[10:31:51.950] Searching for globals...
[10:31:51.951] 
[10:31:51.951] Searching for globals ... DONE
[10:31:51.951] - globals: [0] <none>
[10:31:51.951] getGlobalsAndPackages() ... DONE
[10:31:51.951]    + additional globals found: [n=0] 
[10:31:51.951]    + additional namespaces needed: [n=0] 
[10:31:51.951]  - Finding globals in '...' for chunk #2 ... DONE
[10:31:51.952]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:51.952]  - seeds: <none>
[10:31:51.952]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:51.952] getGlobalsAndPackages() ...
[10:31:51.952] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:51.952] Resolving globals: FALSE
[10:31:51.953] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:31:51.953] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:51.954] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:51.954] 
[10:31:51.954] getGlobalsAndPackages() ... DONE
[10:31:51.954] run() for ‘Future’ ...
[10:31:51.954] - state: ‘created’
[10:31:51.955] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:51.969] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:51.970] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:51.970]   - Field: ‘node’
[10:31:51.970]   - Field: ‘label’
[10:31:51.970]   - Field: ‘local’
[10:31:51.970]   - Field: ‘owner’
[10:31:51.970]   - Field: ‘envir’
[10:31:51.971]   - Field: ‘workers’
[10:31:51.971]   - Field: ‘packages’
[10:31:51.971]   - Field: ‘gc’
[10:31:51.971]   - Field: ‘conditions’
[10:31:51.971]   - Field: ‘persistent’
[10:31:51.971]   - Field: ‘expr’
[10:31:51.971]   - Field: ‘uuid’
[10:31:51.972]   - Field: ‘seed’
[10:31:51.972]   - Field: ‘version’
[10:31:51.972]   - Field: ‘result’
[10:31:51.972]   - Field: ‘asynchronous’
[10:31:51.972]   - Field: ‘calls’
[10:31:51.972]   - Field: ‘globals’
[10:31:51.972]   - Field: ‘stdout’
[10:31:51.972]   - Field: ‘earlySignal’
[10:31:51.973]   - Field: ‘lazy’
[10:31:51.973]   - Field: ‘state’
[10:31:51.973] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:51.973] - Launch lazy future ...
[10:31:51.974] Packages needed by the future expression (n = 0): <none>
[10:31:51.974] Packages needed by future strategies (n = 0): <none>
[10:31:51.974] {
[10:31:51.974]     {
[10:31:51.974]         {
[10:31:51.974]             ...future.startTime <- base::Sys.time()
[10:31:51.974]             {
[10:31:51.974]                 {
[10:31:51.974]                   {
[10:31:51.974]                     {
[10:31:51.974]                       base::local({
[10:31:51.974]                         has_future <- base::requireNamespace("future", 
[10:31:51.974]                           quietly = TRUE)
[10:31:51.974]                         if (has_future) {
[10:31:51.974]                           ns <- base::getNamespace("future")
[10:31:51.974]                           version <- ns[[".package"]][["version"]]
[10:31:51.974]                           if (is.null(version)) 
[10:31:51.974]                             version <- utils::packageVersion("future")
[10:31:51.974]                         }
[10:31:51.974]                         else {
[10:31:51.974]                           version <- NULL
[10:31:51.974]                         }
[10:31:51.974]                         if (!has_future || version < "1.8.0") {
[10:31:51.974]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:51.974]                             "", base::R.version$version.string), 
[10:31:51.974]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:51.974]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:51.974]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:51.974]                               "release", "version")], collapse = " "), 
[10:31:51.974]                             hostname = base::Sys.info()[["nodename"]])
[10:31:51.974]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:51.974]                             info)
[10:31:51.974]                           info <- base::paste(info, collapse = "; ")
[10:31:51.974]                           if (!has_future) {
[10:31:51.974]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:51.974]                               info)
[10:31:51.974]                           }
[10:31:51.974]                           else {
[10:31:51.974]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:51.974]                               info, version)
[10:31:51.974]                           }
[10:31:51.974]                           base::stop(msg)
[10:31:51.974]                         }
[10:31:51.974]                       })
[10:31:51.974]                     }
[10:31:51.974]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:51.974]                     base::options(mc.cores = 1L)
[10:31:51.974]                   }
[10:31:51.974]                   ...future.strategy.old <- future::plan("list")
[10:31:51.974]                   options(future.plan = NULL)
[10:31:51.974]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:51.974]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:51.974]                 }
[10:31:51.974]                 ...future.workdir <- getwd()
[10:31:51.974]             }
[10:31:51.974]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:51.974]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:51.974]         }
[10:31:51.974]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:51.974]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:51.974]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:51.974]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:51.974]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:51.974]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:51.974]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:51.974]             base::names(...future.oldOptions))
[10:31:51.974]     }
[10:31:51.974]     if (FALSE) {
[10:31:51.974]     }
[10:31:51.974]     else {
[10:31:51.974]         if (FALSE) {
[10:31:51.974]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:51.974]                 open = "w")
[10:31:51.974]         }
[10:31:51.974]         else {
[10:31:51.974]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:51.974]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:51.974]         }
[10:31:51.974]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:51.974]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:51.974]             base::sink(type = "output", split = FALSE)
[10:31:51.974]             base::close(...future.stdout)
[10:31:51.974]         }, add = TRUE)
[10:31:51.974]     }
[10:31:51.974]     ...future.frame <- base::sys.nframe()
[10:31:51.974]     ...future.conditions <- base::list()
[10:31:51.974]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:51.974]     if (FALSE) {
[10:31:51.974]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:51.974]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:51.974]     }
[10:31:51.974]     ...future.result <- base::tryCatch({
[10:31:51.974]         base::withCallingHandlers({
[10:31:51.974]             ...future.value <- base::withVisible(base::local({
[10:31:51.974]                 ...future.makeSendCondition <- base::local({
[10:31:51.974]                   sendCondition <- NULL
[10:31:51.974]                   function(frame = 1L) {
[10:31:51.974]                     if (is.function(sendCondition)) 
[10:31:51.974]                       return(sendCondition)
[10:31:51.974]                     ns <- getNamespace("parallel")
[10:31:51.974]                     if (exists("sendData", mode = "function", 
[10:31:51.974]                       envir = ns)) {
[10:31:51.974]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:51.974]                         envir = ns)
[10:31:51.974]                       envir <- sys.frame(frame)
[10:31:51.974]                       master <- NULL
[10:31:51.974]                       while (!identical(envir, .GlobalEnv) && 
[10:31:51.974]                         !identical(envir, emptyenv())) {
[10:31:51.974]                         if (exists("master", mode = "list", envir = envir, 
[10:31:51.974]                           inherits = FALSE)) {
[10:31:51.974]                           master <- get("master", mode = "list", 
[10:31:51.974]                             envir = envir, inherits = FALSE)
[10:31:51.974]                           if (inherits(master, c("SOCKnode", 
[10:31:51.974]                             "SOCK0node"))) {
[10:31:51.974]                             sendCondition <<- function(cond) {
[10:31:51.974]                               data <- list(type = "VALUE", value = cond, 
[10:31:51.974]                                 success = TRUE)
[10:31:51.974]                               parallel_sendData(master, data)
[10:31:51.974]                             }
[10:31:51.974]                             return(sendCondition)
[10:31:51.974]                           }
[10:31:51.974]                         }
[10:31:51.974]                         frame <- frame + 1L
[10:31:51.974]                         envir <- sys.frame(frame)
[10:31:51.974]                       }
[10:31:51.974]                     }
[10:31:51.974]                     sendCondition <<- function(cond) NULL
[10:31:51.974]                   }
[10:31:51.974]                 })
[10:31:51.974]                 withCallingHandlers({
[10:31:51.974]                   {
[10:31:51.974]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:51.974]                     if (!identical(...future.globals.maxSize.org, 
[10:31:51.974]                       ...future.globals.maxSize)) {
[10:31:51.974]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:51.974]                       on.exit(options(oopts), add = TRUE)
[10:31:51.974]                     }
[10:31:51.974]                     {
[10:31:51.974]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:51.974]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:51.974]                         USE.NAMES = FALSE)
[10:31:51.974]                       do.call(mapply, args = args)
[10:31:51.974]                     }
[10:31:51.974]                   }
[10:31:51.974]                 }, immediateCondition = function(cond) {
[10:31:51.974]                   sendCondition <- ...future.makeSendCondition()
[10:31:51.974]                   sendCondition(cond)
[10:31:51.974]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:51.974]                   {
[10:31:51.974]                     inherits <- base::inherits
[10:31:51.974]                     invokeRestart <- base::invokeRestart
[10:31:51.974]                     is.null <- base::is.null
[10:31:51.974]                     muffled <- FALSE
[10:31:51.974]                     if (inherits(cond, "message")) {
[10:31:51.974]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:51.974]                       if (muffled) 
[10:31:51.974]                         invokeRestart("muffleMessage")
[10:31:51.974]                     }
[10:31:51.974]                     else if (inherits(cond, "warning")) {
[10:31:51.974]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:51.974]                       if (muffled) 
[10:31:51.974]                         invokeRestart("muffleWarning")
[10:31:51.974]                     }
[10:31:51.974]                     else if (inherits(cond, "condition")) {
[10:31:51.974]                       if (!is.null(pattern)) {
[10:31:51.974]                         computeRestarts <- base::computeRestarts
[10:31:51.974]                         grepl <- base::grepl
[10:31:51.974]                         restarts <- computeRestarts(cond)
[10:31:51.974]                         for (restart in restarts) {
[10:31:51.974]                           name <- restart$name
[10:31:51.974]                           if (is.null(name)) 
[10:31:51.974]                             next
[10:31:51.974]                           if (!grepl(pattern, name)) 
[10:31:51.974]                             next
[10:31:51.974]                           invokeRestart(restart)
[10:31:51.974]                           muffled <- TRUE
[10:31:51.974]                           break
[10:31:51.974]                         }
[10:31:51.974]                       }
[10:31:51.974]                     }
[10:31:51.974]                     invisible(muffled)
[10:31:51.974]                   }
[10:31:51.974]                   muffleCondition(cond)
[10:31:51.974]                 })
[10:31:51.974]             }))
[10:31:51.974]             future::FutureResult(value = ...future.value$value, 
[10:31:51.974]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:51.974]                   ...future.rng), globalenv = if (FALSE) 
[10:31:51.974]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:51.974]                     ...future.globalenv.names))
[10:31:51.974]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:51.974]         }, condition = base::local({
[10:31:51.974]             c <- base::c
[10:31:51.974]             inherits <- base::inherits
[10:31:51.974]             invokeRestart <- base::invokeRestart
[10:31:51.974]             length <- base::length
[10:31:51.974]             list <- base::list
[10:31:51.974]             seq.int <- base::seq.int
[10:31:51.974]             signalCondition <- base::signalCondition
[10:31:51.974]             sys.calls <- base::sys.calls
[10:31:51.974]             `[[` <- base::`[[`
[10:31:51.974]             `+` <- base::`+`
[10:31:51.974]             `<<-` <- base::`<<-`
[10:31:51.974]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:51.974]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:51.974]                   3L)]
[10:31:51.974]             }
[10:31:51.974]             function(cond) {
[10:31:51.974]                 is_error <- inherits(cond, "error")
[10:31:51.974]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:51.974]                   NULL)
[10:31:51.974]                 if (is_error) {
[10:31:51.974]                   sessionInformation <- function() {
[10:31:51.974]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:51.974]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:51.974]                       search = base::search(), system = base::Sys.info())
[10:31:51.974]                   }
[10:31:51.974]                   ...future.conditions[[length(...future.conditions) + 
[10:31:51.974]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:51.974]                     cond$call), session = sessionInformation(), 
[10:31:51.974]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:51.974]                   signalCondition(cond)
[10:31:51.974]                 }
[10:31:51.974]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:51.974]                 "immediateCondition"))) {
[10:31:51.974]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:51.974]                   ...future.conditions[[length(...future.conditions) + 
[10:31:51.974]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:51.974]                   if (TRUE && !signal) {
[10:31:51.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:51.974]                     {
[10:31:51.974]                       inherits <- base::inherits
[10:31:51.974]                       invokeRestart <- base::invokeRestart
[10:31:51.974]                       is.null <- base::is.null
[10:31:51.974]                       muffled <- FALSE
[10:31:51.974]                       if (inherits(cond, "message")) {
[10:31:51.974]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:51.974]                         if (muffled) 
[10:31:51.974]                           invokeRestart("muffleMessage")
[10:31:51.974]                       }
[10:31:51.974]                       else if (inherits(cond, "warning")) {
[10:31:51.974]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:51.974]                         if (muffled) 
[10:31:51.974]                           invokeRestart("muffleWarning")
[10:31:51.974]                       }
[10:31:51.974]                       else if (inherits(cond, "condition")) {
[10:31:51.974]                         if (!is.null(pattern)) {
[10:31:51.974]                           computeRestarts <- base::computeRestarts
[10:31:51.974]                           grepl <- base::grepl
[10:31:51.974]                           restarts <- computeRestarts(cond)
[10:31:51.974]                           for (restart in restarts) {
[10:31:51.974]                             name <- restart$name
[10:31:51.974]                             if (is.null(name)) 
[10:31:51.974]                               next
[10:31:51.974]                             if (!grepl(pattern, name)) 
[10:31:51.974]                               next
[10:31:51.974]                             invokeRestart(restart)
[10:31:51.974]                             muffled <- TRUE
[10:31:51.974]                             break
[10:31:51.974]                           }
[10:31:51.974]                         }
[10:31:51.974]                       }
[10:31:51.974]                       invisible(muffled)
[10:31:51.974]                     }
[10:31:51.974]                     muffleCondition(cond, pattern = "^muffle")
[10:31:51.974]                   }
[10:31:51.974]                 }
[10:31:51.974]                 else {
[10:31:51.974]                   if (TRUE) {
[10:31:51.974]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:51.974]                     {
[10:31:51.974]                       inherits <- base::inherits
[10:31:51.974]                       invokeRestart <- base::invokeRestart
[10:31:51.974]                       is.null <- base::is.null
[10:31:51.974]                       muffled <- FALSE
[10:31:51.974]                       if (inherits(cond, "message")) {
[10:31:51.974]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:51.974]                         if (muffled) 
[10:31:51.974]                           invokeRestart("muffleMessage")
[10:31:51.974]                       }
[10:31:51.974]                       else if (inherits(cond, "warning")) {
[10:31:51.974]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:51.974]                         if (muffled) 
[10:31:51.974]                           invokeRestart("muffleWarning")
[10:31:51.974]                       }
[10:31:51.974]                       else if (inherits(cond, "condition")) {
[10:31:51.974]                         if (!is.null(pattern)) {
[10:31:51.974]                           computeRestarts <- base::computeRestarts
[10:31:51.974]                           grepl <- base::grepl
[10:31:51.974]                           restarts <- computeRestarts(cond)
[10:31:51.974]                           for (restart in restarts) {
[10:31:51.974]                             name <- restart$name
[10:31:51.974]                             if (is.null(name)) 
[10:31:51.974]                               next
[10:31:51.974]                             if (!grepl(pattern, name)) 
[10:31:51.974]                               next
[10:31:51.974]                             invokeRestart(restart)
[10:31:51.974]                             muffled <- TRUE
[10:31:51.974]                             break
[10:31:51.974]                           }
[10:31:51.974]                         }
[10:31:51.974]                       }
[10:31:51.974]                       invisible(muffled)
[10:31:51.974]                     }
[10:31:51.974]                     muffleCondition(cond, pattern = "^muffle")
[10:31:51.974]                   }
[10:31:51.974]                 }
[10:31:51.974]             }
[10:31:51.974]         }))
[10:31:51.974]     }, error = function(ex) {
[10:31:51.974]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:51.974]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:51.974]                 ...future.rng), started = ...future.startTime, 
[10:31:51.974]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:51.974]             version = "1.8"), class = "FutureResult")
[10:31:51.974]     }, finally = {
[10:31:51.974]         if (!identical(...future.workdir, getwd())) 
[10:31:51.974]             setwd(...future.workdir)
[10:31:51.974]         {
[10:31:51.974]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:51.974]                 ...future.oldOptions$nwarnings <- NULL
[10:31:51.974]             }
[10:31:51.974]             base::options(...future.oldOptions)
[10:31:51.974]             if (.Platform$OS.type == "windows") {
[10:31:51.974]                 old_names <- names(...future.oldEnvVars)
[10:31:51.974]                 envs <- base::Sys.getenv()
[10:31:51.974]                 names <- names(envs)
[10:31:51.974]                 common <- intersect(names, old_names)
[10:31:51.974]                 added <- setdiff(names, old_names)
[10:31:51.974]                 removed <- setdiff(old_names, names)
[10:31:51.974]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:51.974]                   envs[common]]
[10:31:51.974]                 NAMES <- toupper(changed)
[10:31:51.974]                 args <- list()
[10:31:51.974]                 for (kk in seq_along(NAMES)) {
[10:31:51.974]                   name <- changed[[kk]]
[10:31:51.974]                   NAME <- NAMES[[kk]]
[10:31:51.974]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:51.974]                     next
[10:31:51.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:51.974]                 }
[10:31:51.974]                 NAMES <- toupper(added)
[10:31:51.974]                 for (kk in seq_along(NAMES)) {
[10:31:51.974]                   name <- added[[kk]]
[10:31:51.974]                   NAME <- NAMES[[kk]]
[10:31:51.974]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:51.974]                     next
[10:31:51.974]                   args[[name]] <- ""
[10:31:51.974]                 }
[10:31:51.974]                 NAMES <- toupper(removed)
[10:31:51.974]                 for (kk in seq_along(NAMES)) {
[10:31:51.974]                   name <- removed[[kk]]
[10:31:51.974]                   NAME <- NAMES[[kk]]
[10:31:51.974]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:51.974]                     next
[10:31:51.974]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:51.974]                 }
[10:31:51.974]                 if (length(args) > 0) 
[10:31:51.974]                   base::do.call(base::Sys.setenv, args = args)
[10:31:51.974]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:51.974]             }
[10:31:51.974]             else {
[10:31:51.974]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:51.974]             }
[10:31:51.974]             {
[10:31:51.974]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:51.974]                   0L) {
[10:31:51.974]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:51.974]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:51.974]                   base::options(opts)
[10:31:51.974]                 }
[10:31:51.974]                 {
[10:31:51.974]                   {
[10:31:51.974]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:51.974]                     NULL
[10:31:51.974]                   }
[10:31:51.974]                   options(future.plan = NULL)
[10:31:51.974]                   if (is.na(NA_character_)) 
[10:31:51.974]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:51.974]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:51.974]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:51.974]                     .init = FALSE)
[10:31:51.974]                 }
[10:31:51.974]             }
[10:31:51.974]         }
[10:31:51.974]     })
[10:31:51.974]     if (TRUE) {
[10:31:51.974]         base::sink(type = "output", split = FALSE)
[10:31:51.974]         if (FALSE) {
[10:31:51.974]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:51.974]         }
[10:31:51.974]         else {
[10:31:51.974]             ...future.result["stdout"] <- base::list(NULL)
[10:31:51.974]         }
[10:31:51.974]         base::close(...future.stdout)
[10:31:51.974]         ...future.stdout <- NULL
[10:31:51.974]     }
[10:31:51.974]     ...future.result$conditions <- ...future.conditions
[10:31:51.974]     ...future.result$finished <- base::Sys.time()
[10:31:51.974]     ...future.result
[10:31:51.974] }
[10:31:51.978] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[10:31:51.978] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[10:31:51.979] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[10:31:51.979] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:31:51.979] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:31:51.979] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:31:51.980] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:31:51.980] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:51.980] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:51.980] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:51.981] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:51.981] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[10:31:51.982] MultisessionFuture started
[10:31:51.982] - Launch lazy future ... done
[10:31:51.982] run() for ‘MultisessionFuture’ ... done
[10:31:51.982] Created future:
[10:31:51.983] receiveMessageFromWorker() for ClusterFuture ...
[10:31:51.984] - Validating connection of MultisessionFuture
[10:31:51.984] - received message: FutureResult
[10:31:51.984] - Received FutureResult
[10:31:51.984] - Erased future from FutureRegistry
[10:31:51.984] result() for ClusterFuture ...
[10:31:51.984] - result already collected: FutureResult
[10:31:51.984] result() for ClusterFuture ... done
[10:31:51.984] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:51.982] MultisessionFuture:
[10:31:51.982] Label: ‘future_mapply-2’
[10:31:51.982] Expression:
[10:31:51.982] {
[10:31:51.982]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:51.982]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:51.982]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:51.982]         on.exit(options(oopts), add = TRUE)
[10:31:51.982]     }
[10:31:51.982]     {
[10:31:51.982]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:51.982]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:51.982]         do.call(mapply, args = args)
[10:31:51.982]     }
[10:31:51.982] }
[10:31:51.982] Lazy evaluation: FALSE
[10:31:51.982] Asynchronous evaluation: TRUE
[10:31:51.982] Local evaluation: TRUE
[10:31:51.982] Environment: R_GlobalEnv
[10:31:51.982] Capture standard output: FALSE
[10:31:51.982] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:51.982] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:51.982] Packages: <none>
[10:31:51.982] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:51.982] Resolved: TRUE
[10:31:51.982] Value: <not collected>
[10:31:51.982] Conditions captured: <none>
[10:31:51.982] Early signaling: FALSE
[10:31:51.982] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:51.982] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:51.985] Chunk #2 of 2 ... DONE
[10:31:51.985] Launching 2 futures (chunks) ... DONE
[10:31:51.985] Resolving 2 futures (chunks) ...
[10:31:51.985] resolve() on list ...
[10:31:51.985]  recursive: 0
[10:31:51.985]  length: 2
[10:31:51.985] 
[10:31:51.996] Future #2
[10:31:51.996] result() for ClusterFuture ...
[10:31:51.996] - result already collected: FutureResult
[10:31:51.996] result() for ClusterFuture ... done
[10:31:51.996] result() for ClusterFuture ...
[10:31:51.996] - result already collected: FutureResult
[10:31:51.997] result() for ClusterFuture ... done
[10:31:51.997] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:51.997] - nx: 2
[10:31:51.997] - relay: TRUE
[10:31:51.997] - stdout: TRUE
[10:31:51.997] - signal: TRUE
[10:31:51.997] - resignal: FALSE
[10:31:51.997] - force: TRUE
[10:31:51.997] - relayed: [n=2] FALSE, FALSE
[10:31:51.998] - queued futures: [n=2] FALSE, FALSE
[10:31:51.998]  - until=1
[10:31:51.998]  - relaying element #1
[10:31:51.998] - relayed: [n=2] FALSE, FALSE
[10:31:51.998] - queued futures: [n=2] FALSE, TRUE
[10:31:51.998] signalConditionsASAP(NULL, pos=2) ... done
[10:31:51.998]  length: 1 (resolved future 2)
[10:31:52.486] receiveMessageFromWorker() for ClusterFuture ...
[10:31:52.486] - Validating connection of MultisessionFuture
[10:31:52.487] - received message: FutureResult
[10:31:52.487] - Received FutureResult
[10:31:52.487] - Erased future from FutureRegistry
[10:31:52.487] result() for ClusterFuture ...
[10:31:52.487] - result already collected: FutureResult
[10:31:52.487] result() for ClusterFuture ... done
[10:31:52.488] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:52.488] Future #1
[10:31:52.488] result() for ClusterFuture ...
[10:31:52.488] - result already collected: FutureResult
[10:31:52.488] result() for ClusterFuture ... done
[10:31:52.488] result() for ClusterFuture ...
[10:31:52.488] - result already collected: FutureResult
[10:31:52.488] result() for ClusterFuture ... done
[10:31:52.489] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:52.489] - nx: 2
[10:31:52.489] - relay: TRUE
[10:31:52.489] - stdout: TRUE
[10:31:52.489] - signal: TRUE
[10:31:52.489] - resignal: FALSE
[10:31:52.489] - force: TRUE
[10:31:52.489] - relayed: [n=2] FALSE, FALSE
[10:31:52.489] - queued futures: [n=2] FALSE, TRUE
[10:31:52.489]  - until=1
[10:31:52.489]  - relaying element #1
[10:31:52.490] result() for ClusterFuture ...
[10:31:52.490] - result already collected: FutureResult
[10:31:52.490] result() for ClusterFuture ... done
[10:31:52.490] result() for ClusterFuture ...
[10:31:52.490] - result already collected: FutureResult
[10:31:52.490] result() for ClusterFuture ... done
[10:31:52.490] result() for ClusterFuture ...
[10:31:52.490] - result already collected: FutureResult
[10:31:52.490] result() for ClusterFuture ... done
[10:31:52.490] result() for ClusterFuture ...
[10:31:52.491] - result already collected: FutureResult
[10:31:52.491] result() for ClusterFuture ... done
[10:31:52.491] - relayed: [n=2] TRUE, FALSE
[10:31:52.491] - queued futures: [n=2] TRUE, TRUE
[10:31:52.491] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:52.491]  length: 0 (resolved future 1)
[10:31:52.491] Relaying remaining futures
[10:31:52.491] signalConditionsASAP(NULL, pos=0) ...
[10:31:52.491] - nx: 2
[10:31:52.491] - relay: TRUE
[10:31:52.491] - stdout: TRUE
[10:31:52.491] - signal: TRUE
[10:31:52.492] - resignal: FALSE
[10:31:52.492] - force: TRUE
[10:31:52.492] - relayed: [n=2] TRUE, FALSE
[10:31:52.492] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:52.492]  - relaying element #2
[10:31:52.492] result() for ClusterFuture ...
[10:31:52.492] - result already collected: FutureResult
[10:31:52.492] result() for ClusterFuture ... done
[10:31:52.492] result() for ClusterFuture ...
[10:31:52.492] - result already collected: FutureResult
[10:31:52.493] result() for ClusterFuture ... done
[10:31:52.493] result() for ClusterFuture ...
[10:31:52.493] - result already collected: FutureResult
[10:31:52.493] result() for ClusterFuture ... done
[10:31:52.493] result() for ClusterFuture ...
[10:31:52.493] - result already collected: FutureResult
[10:31:52.493] result() for ClusterFuture ... done
[10:31:52.493] - relayed: [n=2] TRUE, TRUE
[10:31:52.493] - queued futures: [n=2] TRUE, TRUE
[10:31:52.493] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:31:52.493] resolve() on list ... DONE
[10:31:52.494] result() for ClusterFuture ...
[10:31:52.494] - result already collected: FutureResult
[10:31:52.494] result() for ClusterFuture ... done
[10:31:52.494] result() for ClusterFuture ...
[10:31:52.494] - result already collected: FutureResult
[10:31:52.494] result() for ClusterFuture ... done
[10:31:52.494] result() for ClusterFuture ...
[10:31:52.494] - result already collected: FutureResult
[10:31:52.494] result() for ClusterFuture ... done
[10:31:52.494] result() for ClusterFuture ...
[10:31:52.494] - result already collected: FutureResult
[10:31:52.495] result() for ClusterFuture ... done
[10:31:52.495]  - Number of value chunks collected: 2
[10:31:52.495] Resolving 2 futures (chunks) ... DONE
[10:31:52.495] Reducing values from 2 chunks ...
[10:31:52.495]  - Number of values collected after concatenation: 2
[10:31:52.495]  - Number of values expected: 2
[10:31:52.495] Reducing values from 2 chunks ... DONE
[10:31:52.495] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[10:31:52.496] future_mapply() ...
[10:31:52.500] Number of chunks: 2
[10:31:52.500] getGlobalsAndPackagesXApply() ...
[10:31:52.500]  - future.globals: TRUE
[10:31:52.500] getGlobalsAndPackages() ...
[10:31:52.500] Searching for globals...
[10:31:52.502] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:52.502] Searching for globals ... DONE
[10:31:52.502] Resolving globals: FALSE
[10:31:52.502] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:52.503] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:52.503] - globals: [1] ‘FUN’
[10:31:52.503] 
[10:31:52.503] getGlobalsAndPackages() ... DONE
[10:31:52.503]  - globals found/used: [n=1] ‘FUN’
[10:31:52.503]  - needed namespaces: [n=0] 
[10:31:52.503] Finding globals ... DONE
[10:31:52.504] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:52.504] List of 2
[10:31:52.504]  $ ...future.FUN:function (x, y)  
[10:31:52.504]  $ MoreArgs     : NULL
[10:31:52.504]  - attr(*, "where")=List of 2
[10:31:52.504]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:52.504]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:52.504]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:52.504]  - attr(*, "resolved")= logi FALSE
[10:31:52.504]  - attr(*, "total_size")= num NA
[10:31:52.506] Packages to be attached in all futures: [n=0] 
[10:31:52.506] getGlobalsAndPackagesXApply() ... DONE
[10:31:52.506] Number of futures (= number of chunks): 2
[10:31:52.507] Launching 2 futures (chunks) ...
[10:31:52.507] Chunk #1 of 2 ...
[10:31:52.507]  - Finding globals in '...' for chunk #1 ...
[10:31:52.507] getGlobalsAndPackages() ...
[10:31:52.507] Searching for globals...
[10:31:52.507] 
[10:31:52.507] Searching for globals ... DONE
[10:31:52.508] - globals: [0] <none>
[10:31:52.508] getGlobalsAndPackages() ... DONE
[10:31:52.508]    + additional globals found: [n=0] 
[10:31:52.508]    + additional namespaces needed: [n=0] 
[10:31:52.508]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:52.508]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:52.508]  - seeds: <none>
[10:31:52.508]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:52.508] getGlobalsAndPackages() ...
[10:31:52.508] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:52.508] Resolving globals: FALSE
[10:31:52.509] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:31:52.509] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:52.510] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:52.510] 
[10:31:52.510] getGlobalsAndPackages() ... DONE
[10:31:52.510] run() for ‘Future’ ...
[10:31:52.510] - state: ‘created’
[10:31:52.510] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:52.524] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:52.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:52.524]   - Field: ‘node’
[10:31:52.525]   - Field: ‘label’
[10:31:52.525]   - Field: ‘local’
[10:31:52.525]   - Field: ‘owner’
[10:31:52.525]   - Field: ‘envir’
[10:31:52.525]   - Field: ‘workers’
[10:31:52.525]   - Field: ‘packages’
[10:31:52.525]   - Field: ‘gc’
[10:31:52.525]   - Field: ‘conditions’
[10:31:52.525]   - Field: ‘persistent’
[10:31:52.526]   - Field: ‘expr’
[10:31:52.526]   - Field: ‘uuid’
[10:31:52.526]   - Field: ‘seed’
[10:31:52.526]   - Field: ‘version’
[10:31:52.526]   - Field: ‘result’
[10:31:52.526]   - Field: ‘asynchronous’
[10:31:52.526]   - Field: ‘calls’
[10:31:52.526]   - Field: ‘globals’
[10:31:52.526]   - Field: ‘stdout’
[10:31:52.526]   - Field: ‘earlySignal’
[10:31:52.526]   - Field: ‘lazy’
[10:31:52.527]   - Field: ‘state’
[10:31:52.527] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:52.527] - Launch lazy future ...
[10:31:52.527] Packages needed by the future expression (n = 0): <none>
[10:31:52.527] Packages needed by future strategies (n = 0): <none>
[10:31:52.528] {
[10:31:52.528]     {
[10:31:52.528]         {
[10:31:52.528]             ...future.startTime <- base::Sys.time()
[10:31:52.528]             {
[10:31:52.528]                 {
[10:31:52.528]                   {
[10:31:52.528]                     {
[10:31:52.528]                       base::local({
[10:31:52.528]                         has_future <- base::requireNamespace("future", 
[10:31:52.528]                           quietly = TRUE)
[10:31:52.528]                         if (has_future) {
[10:31:52.528]                           ns <- base::getNamespace("future")
[10:31:52.528]                           version <- ns[[".package"]][["version"]]
[10:31:52.528]                           if (is.null(version)) 
[10:31:52.528]                             version <- utils::packageVersion("future")
[10:31:52.528]                         }
[10:31:52.528]                         else {
[10:31:52.528]                           version <- NULL
[10:31:52.528]                         }
[10:31:52.528]                         if (!has_future || version < "1.8.0") {
[10:31:52.528]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:52.528]                             "", base::R.version$version.string), 
[10:31:52.528]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:52.528]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:52.528]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:52.528]                               "release", "version")], collapse = " "), 
[10:31:52.528]                             hostname = base::Sys.info()[["nodename"]])
[10:31:52.528]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:52.528]                             info)
[10:31:52.528]                           info <- base::paste(info, collapse = "; ")
[10:31:52.528]                           if (!has_future) {
[10:31:52.528]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:52.528]                               info)
[10:31:52.528]                           }
[10:31:52.528]                           else {
[10:31:52.528]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:52.528]                               info, version)
[10:31:52.528]                           }
[10:31:52.528]                           base::stop(msg)
[10:31:52.528]                         }
[10:31:52.528]                       })
[10:31:52.528]                     }
[10:31:52.528]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:52.528]                     base::options(mc.cores = 1L)
[10:31:52.528]                   }
[10:31:52.528]                   ...future.strategy.old <- future::plan("list")
[10:31:52.528]                   options(future.plan = NULL)
[10:31:52.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:52.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:52.528]                 }
[10:31:52.528]                 ...future.workdir <- getwd()
[10:31:52.528]             }
[10:31:52.528]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:52.528]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:52.528]         }
[10:31:52.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:52.528]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:52.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:52.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:52.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:52.528]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:52.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:52.528]             base::names(...future.oldOptions))
[10:31:52.528]     }
[10:31:52.528]     if (FALSE) {
[10:31:52.528]     }
[10:31:52.528]     else {
[10:31:52.528]         if (TRUE) {
[10:31:52.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:52.528]                 open = "w")
[10:31:52.528]         }
[10:31:52.528]         else {
[10:31:52.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:52.528]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:52.528]         }
[10:31:52.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:52.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:52.528]             base::sink(type = "output", split = FALSE)
[10:31:52.528]             base::close(...future.stdout)
[10:31:52.528]         }, add = TRUE)
[10:31:52.528]     }
[10:31:52.528]     ...future.frame <- base::sys.nframe()
[10:31:52.528]     ...future.conditions <- base::list()
[10:31:52.528]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:52.528]     if (FALSE) {
[10:31:52.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:52.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:52.528]     }
[10:31:52.528]     ...future.result <- base::tryCatch({
[10:31:52.528]         base::withCallingHandlers({
[10:31:52.528]             ...future.value <- base::withVisible(base::local({
[10:31:52.528]                 ...future.makeSendCondition <- base::local({
[10:31:52.528]                   sendCondition <- NULL
[10:31:52.528]                   function(frame = 1L) {
[10:31:52.528]                     if (is.function(sendCondition)) 
[10:31:52.528]                       return(sendCondition)
[10:31:52.528]                     ns <- getNamespace("parallel")
[10:31:52.528]                     if (exists("sendData", mode = "function", 
[10:31:52.528]                       envir = ns)) {
[10:31:52.528]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:52.528]                         envir = ns)
[10:31:52.528]                       envir <- sys.frame(frame)
[10:31:52.528]                       master <- NULL
[10:31:52.528]                       while (!identical(envir, .GlobalEnv) && 
[10:31:52.528]                         !identical(envir, emptyenv())) {
[10:31:52.528]                         if (exists("master", mode = "list", envir = envir, 
[10:31:52.528]                           inherits = FALSE)) {
[10:31:52.528]                           master <- get("master", mode = "list", 
[10:31:52.528]                             envir = envir, inherits = FALSE)
[10:31:52.528]                           if (inherits(master, c("SOCKnode", 
[10:31:52.528]                             "SOCK0node"))) {
[10:31:52.528]                             sendCondition <<- function(cond) {
[10:31:52.528]                               data <- list(type = "VALUE", value = cond, 
[10:31:52.528]                                 success = TRUE)
[10:31:52.528]                               parallel_sendData(master, data)
[10:31:52.528]                             }
[10:31:52.528]                             return(sendCondition)
[10:31:52.528]                           }
[10:31:52.528]                         }
[10:31:52.528]                         frame <- frame + 1L
[10:31:52.528]                         envir <- sys.frame(frame)
[10:31:52.528]                       }
[10:31:52.528]                     }
[10:31:52.528]                     sendCondition <<- function(cond) NULL
[10:31:52.528]                   }
[10:31:52.528]                 })
[10:31:52.528]                 withCallingHandlers({
[10:31:52.528]                   {
[10:31:52.528]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:52.528]                     if (!identical(...future.globals.maxSize.org, 
[10:31:52.528]                       ...future.globals.maxSize)) {
[10:31:52.528]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:52.528]                       on.exit(options(oopts), add = TRUE)
[10:31:52.528]                     }
[10:31:52.528]                     {
[10:31:52.528]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:52.528]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:52.528]                         USE.NAMES = FALSE)
[10:31:52.528]                       do.call(mapply, args = args)
[10:31:52.528]                     }
[10:31:52.528]                   }
[10:31:52.528]                 }, immediateCondition = function(cond) {
[10:31:52.528]                   sendCondition <- ...future.makeSendCondition()
[10:31:52.528]                   sendCondition(cond)
[10:31:52.528]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:52.528]                   {
[10:31:52.528]                     inherits <- base::inherits
[10:31:52.528]                     invokeRestart <- base::invokeRestart
[10:31:52.528]                     is.null <- base::is.null
[10:31:52.528]                     muffled <- FALSE
[10:31:52.528]                     if (inherits(cond, "message")) {
[10:31:52.528]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:52.528]                       if (muffled) 
[10:31:52.528]                         invokeRestart("muffleMessage")
[10:31:52.528]                     }
[10:31:52.528]                     else if (inherits(cond, "warning")) {
[10:31:52.528]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:52.528]                       if (muffled) 
[10:31:52.528]                         invokeRestart("muffleWarning")
[10:31:52.528]                     }
[10:31:52.528]                     else if (inherits(cond, "condition")) {
[10:31:52.528]                       if (!is.null(pattern)) {
[10:31:52.528]                         computeRestarts <- base::computeRestarts
[10:31:52.528]                         grepl <- base::grepl
[10:31:52.528]                         restarts <- computeRestarts(cond)
[10:31:52.528]                         for (restart in restarts) {
[10:31:52.528]                           name <- restart$name
[10:31:52.528]                           if (is.null(name)) 
[10:31:52.528]                             next
[10:31:52.528]                           if (!grepl(pattern, name)) 
[10:31:52.528]                             next
[10:31:52.528]                           invokeRestart(restart)
[10:31:52.528]                           muffled <- TRUE
[10:31:52.528]                           break
[10:31:52.528]                         }
[10:31:52.528]                       }
[10:31:52.528]                     }
[10:31:52.528]                     invisible(muffled)
[10:31:52.528]                   }
[10:31:52.528]                   muffleCondition(cond)
[10:31:52.528]                 })
[10:31:52.528]             }))
[10:31:52.528]             future::FutureResult(value = ...future.value$value, 
[10:31:52.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:52.528]                   ...future.rng), globalenv = if (FALSE) 
[10:31:52.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:52.528]                     ...future.globalenv.names))
[10:31:52.528]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:52.528]         }, condition = base::local({
[10:31:52.528]             c <- base::c
[10:31:52.528]             inherits <- base::inherits
[10:31:52.528]             invokeRestart <- base::invokeRestart
[10:31:52.528]             length <- base::length
[10:31:52.528]             list <- base::list
[10:31:52.528]             seq.int <- base::seq.int
[10:31:52.528]             signalCondition <- base::signalCondition
[10:31:52.528]             sys.calls <- base::sys.calls
[10:31:52.528]             `[[` <- base::`[[`
[10:31:52.528]             `+` <- base::`+`
[10:31:52.528]             `<<-` <- base::`<<-`
[10:31:52.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:52.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:52.528]                   3L)]
[10:31:52.528]             }
[10:31:52.528]             function(cond) {
[10:31:52.528]                 is_error <- inherits(cond, "error")
[10:31:52.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:52.528]                   NULL)
[10:31:52.528]                 if (is_error) {
[10:31:52.528]                   sessionInformation <- function() {
[10:31:52.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:52.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:52.528]                       search = base::search(), system = base::Sys.info())
[10:31:52.528]                   }
[10:31:52.528]                   ...future.conditions[[length(...future.conditions) + 
[10:31:52.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:52.528]                     cond$call), session = sessionInformation(), 
[10:31:52.528]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:52.528]                   signalCondition(cond)
[10:31:52.528]                 }
[10:31:52.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:52.528]                 "immediateCondition"))) {
[10:31:52.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:52.528]                   ...future.conditions[[length(...future.conditions) + 
[10:31:52.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:52.528]                   if (TRUE && !signal) {
[10:31:52.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:52.528]                     {
[10:31:52.528]                       inherits <- base::inherits
[10:31:52.528]                       invokeRestart <- base::invokeRestart
[10:31:52.528]                       is.null <- base::is.null
[10:31:52.528]                       muffled <- FALSE
[10:31:52.528]                       if (inherits(cond, "message")) {
[10:31:52.528]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:52.528]                         if (muffled) 
[10:31:52.528]                           invokeRestart("muffleMessage")
[10:31:52.528]                       }
[10:31:52.528]                       else if (inherits(cond, "warning")) {
[10:31:52.528]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:52.528]                         if (muffled) 
[10:31:52.528]                           invokeRestart("muffleWarning")
[10:31:52.528]                       }
[10:31:52.528]                       else if (inherits(cond, "condition")) {
[10:31:52.528]                         if (!is.null(pattern)) {
[10:31:52.528]                           computeRestarts <- base::computeRestarts
[10:31:52.528]                           grepl <- base::grepl
[10:31:52.528]                           restarts <- computeRestarts(cond)
[10:31:52.528]                           for (restart in restarts) {
[10:31:52.528]                             name <- restart$name
[10:31:52.528]                             if (is.null(name)) 
[10:31:52.528]                               next
[10:31:52.528]                             if (!grepl(pattern, name)) 
[10:31:52.528]                               next
[10:31:52.528]                             invokeRestart(restart)
[10:31:52.528]                             muffled <- TRUE
[10:31:52.528]                             break
[10:31:52.528]                           }
[10:31:52.528]                         }
[10:31:52.528]                       }
[10:31:52.528]                       invisible(muffled)
[10:31:52.528]                     }
[10:31:52.528]                     muffleCondition(cond, pattern = "^muffle")
[10:31:52.528]                   }
[10:31:52.528]                 }
[10:31:52.528]                 else {
[10:31:52.528]                   if (TRUE) {
[10:31:52.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:52.528]                     {
[10:31:52.528]                       inherits <- base::inherits
[10:31:52.528]                       invokeRestart <- base::invokeRestart
[10:31:52.528]                       is.null <- base::is.null
[10:31:52.528]                       muffled <- FALSE
[10:31:52.528]                       if (inherits(cond, "message")) {
[10:31:52.528]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:52.528]                         if (muffled) 
[10:31:52.528]                           invokeRestart("muffleMessage")
[10:31:52.528]                       }
[10:31:52.528]                       else if (inherits(cond, "warning")) {
[10:31:52.528]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:52.528]                         if (muffled) 
[10:31:52.528]                           invokeRestart("muffleWarning")
[10:31:52.528]                       }
[10:31:52.528]                       else if (inherits(cond, "condition")) {
[10:31:52.528]                         if (!is.null(pattern)) {
[10:31:52.528]                           computeRestarts <- base::computeRestarts
[10:31:52.528]                           grepl <- base::grepl
[10:31:52.528]                           restarts <- computeRestarts(cond)
[10:31:52.528]                           for (restart in restarts) {
[10:31:52.528]                             name <- restart$name
[10:31:52.528]                             if (is.null(name)) 
[10:31:52.528]                               next
[10:31:52.528]                             if (!grepl(pattern, name)) 
[10:31:52.528]                               next
[10:31:52.528]                             invokeRestart(restart)
[10:31:52.528]                             muffled <- TRUE
[10:31:52.528]                             break
[10:31:52.528]                           }
[10:31:52.528]                         }
[10:31:52.528]                       }
[10:31:52.528]                       invisible(muffled)
[10:31:52.528]                     }
[10:31:52.528]                     muffleCondition(cond, pattern = "^muffle")
[10:31:52.528]                   }
[10:31:52.528]                 }
[10:31:52.528]             }
[10:31:52.528]         }))
[10:31:52.528]     }, error = function(ex) {
[10:31:52.528]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:52.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:52.528]                 ...future.rng), started = ...future.startTime, 
[10:31:52.528]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:52.528]             version = "1.8"), class = "FutureResult")
[10:31:52.528]     }, finally = {
[10:31:52.528]         if (!identical(...future.workdir, getwd())) 
[10:31:52.528]             setwd(...future.workdir)
[10:31:52.528]         {
[10:31:52.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:52.528]                 ...future.oldOptions$nwarnings <- NULL
[10:31:52.528]             }
[10:31:52.528]             base::options(...future.oldOptions)
[10:31:52.528]             if (.Platform$OS.type == "windows") {
[10:31:52.528]                 old_names <- names(...future.oldEnvVars)
[10:31:52.528]                 envs <- base::Sys.getenv()
[10:31:52.528]                 names <- names(envs)
[10:31:52.528]                 common <- intersect(names, old_names)
[10:31:52.528]                 added <- setdiff(names, old_names)
[10:31:52.528]                 removed <- setdiff(old_names, names)
[10:31:52.528]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:52.528]                   envs[common]]
[10:31:52.528]                 NAMES <- toupper(changed)
[10:31:52.528]                 args <- list()
[10:31:52.528]                 for (kk in seq_along(NAMES)) {
[10:31:52.528]                   name <- changed[[kk]]
[10:31:52.528]                   NAME <- NAMES[[kk]]
[10:31:52.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:52.528]                     next
[10:31:52.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:52.528]                 }
[10:31:52.528]                 NAMES <- toupper(added)
[10:31:52.528]                 for (kk in seq_along(NAMES)) {
[10:31:52.528]                   name <- added[[kk]]
[10:31:52.528]                   NAME <- NAMES[[kk]]
[10:31:52.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:52.528]                     next
[10:31:52.528]                   args[[name]] <- ""
[10:31:52.528]                 }
[10:31:52.528]                 NAMES <- toupper(removed)
[10:31:52.528]                 for (kk in seq_along(NAMES)) {
[10:31:52.528]                   name <- removed[[kk]]
[10:31:52.528]                   NAME <- NAMES[[kk]]
[10:31:52.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:52.528]                     next
[10:31:52.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:52.528]                 }
[10:31:52.528]                 if (length(args) > 0) 
[10:31:52.528]                   base::do.call(base::Sys.setenv, args = args)
[10:31:52.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:52.528]             }
[10:31:52.528]             else {
[10:31:52.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:52.528]             }
[10:31:52.528]             {
[10:31:52.528]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:52.528]                   0L) {
[10:31:52.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:52.528]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:52.528]                   base::options(opts)
[10:31:52.528]                 }
[10:31:52.528]                 {
[10:31:52.528]                   {
[10:31:52.528]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:52.528]                     NULL
[10:31:52.528]                   }
[10:31:52.528]                   options(future.plan = NULL)
[10:31:52.528]                   if (is.na(NA_character_)) 
[10:31:52.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:52.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:52.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:52.528]                     .init = FALSE)
[10:31:52.528]                 }
[10:31:52.528]             }
[10:31:52.528]         }
[10:31:52.528]     })
[10:31:52.528]     if (TRUE) {
[10:31:52.528]         base::sink(type = "output", split = FALSE)
[10:31:52.528]         if (TRUE) {
[10:31:52.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:52.528]         }
[10:31:52.528]         else {
[10:31:52.528]             ...future.result["stdout"] <- base::list(NULL)
[10:31:52.528]         }
[10:31:52.528]         base::close(...future.stdout)
[10:31:52.528]         ...future.stdout <- NULL
[10:31:52.528]     }
[10:31:52.528]     ...future.result$conditions <- ...future.conditions
[10:31:52.528]     ...future.result$finished <- base::Sys.time()
[10:31:52.528]     ...future.result
[10:31:52.528] }
[10:31:52.531] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[10:31:52.531] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[10:31:52.531] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[10:31:52.531] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:31:52.532] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:31:52.532] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:31:52.532] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:31:52.532] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:52.533] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:52.533] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:52.533] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:52.533] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[10:31:52.534] MultisessionFuture started
[10:31:52.534] - Launch lazy future ... done
[10:31:52.534] run() for ‘MultisessionFuture’ ... done
[10:31:52.534] Created future:
[10:31:52.534] MultisessionFuture:
[10:31:52.534] Label: ‘future_mapply-1’
[10:31:52.534] Expression:
[10:31:52.534] {
[10:31:52.534]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:52.534]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:52.534]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:52.534]         on.exit(options(oopts), add = TRUE)
[10:31:52.534]     }
[10:31:52.534]     {
[10:31:52.534]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:52.534]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:52.534]         do.call(mapply, args = args)
[10:31:52.534]     }
[10:31:52.534] }
[10:31:52.534] Lazy evaluation: FALSE
[10:31:52.534] Asynchronous evaluation: TRUE
[10:31:52.534] Local evaluation: TRUE
[10:31:52.534] Environment: R_GlobalEnv
[10:31:52.534] Capture standard output: TRUE
[10:31:52.534] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:52.534] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:52.534] Packages: <none>
[10:31:52.534] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:52.534] Resolved: FALSE
[10:31:52.534] Value: <not collected>
[10:31:52.534] Conditions captured: <none>
[10:31:52.534] Early signaling: FALSE
[10:31:52.534] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:52.534] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:52.546] Chunk #1 of 2 ... DONE
[10:31:52.546] Chunk #2 of 2 ...
[10:31:52.546]  - Finding globals in '...' for chunk #2 ...
[10:31:52.546] getGlobalsAndPackages() ...
[10:31:52.546] Searching for globals...
[10:31:52.547] 
[10:31:52.547] Searching for globals ... DONE
[10:31:52.547] - globals: [0] <none>
[10:31:52.547] getGlobalsAndPackages() ... DONE
[10:31:52.547]    + additional globals found: [n=0] 
[10:31:52.547]    + additional namespaces needed: [n=0] 
[10:31:52.547]  - Finding globals in '...' for chunk #2 ... DONE
[10:31:52.547]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:52.547]  - seeds: <none>
[10:31:52.548]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:52.548] getGlobalsAndPackages() ...
[10:31:52.548] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:52.548] Resolving globals: FALSE
[10:31:52.548] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:31:52.549] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:52.549] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:52.549] 
[10:31:52.549] getGlobalsAndPackages() ... DONE
[10:31:52.550] run() for ‘Future’ ...
[10:31:52.550] - state: ‘created’
[10:31:52.550] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:52.566] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:52.566] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:52.567]   - Field: ‘node’
[10:31:52.567]   - Field: ‘label’
[10:31:52.567]   - Field: ‘local’
[10:31:52.567]   - Field: ‘owner’
[10:31:52.567]   - Field: ‘envir’
[10:31:52.567]   - Field: ‘workers’
[10:31:52.567]   - Field: ‘packages’
[10:31:52.567]   - Field: ‘gc’
[10:31:52.567]   - Field: ‘conditions’
[10:31:52.567]   - Field: ‘persistent’
[10:31:52.567]   - Field: ‘expr’
[10:31:52.568]   - Field: ‘uuid’
[10:31:52.568]   - Field: ‘seed’
[10:31:52.568]   - Field: ‘version’
[10:31:52.568]   - Field: ‘result’
[10:31:52.568]   - Field: ‘asynchronous’
[10:31:52.568]   - Field: ‘calls’
[10:31:52.568]   - Field: ‘globals’
[10:31:52.568]   - Field: ‘stdout’
[10:31:52.568]   - Field: ‘earlySignal’
[10:31:52.568]   - Field: ‘lazy’
[10:31:52.568]   - Field: ‘state’
[10:31:52.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:52.569] - Launch lazy future ...
[10:31:52.569] Packages needed by the future expression (n = 0): <none>
[10:31:52.569] Packages needed by future strategies (n = 0): <none>
[10:31:52.570] {
[10:31:52.570]     {
[10:31:52.570]         {
[10:31:52.570]             ...future.startTime <- base::Sys.time()
[10:31:52.570]             {
[10:31:52.570]                 {
[10:31:52.570]                   {
[10:31:52.570]                     {
[10:31:52.570]                       base::local({
[10:31:52.570]                         has_future <- base::requireNamespace("future", 
[10:31:52.570]                           quietly = TRUE)
[10:31:52.570]                         if (has_future) {
[10:31:52.570]                           ns <- base::getNamespace("future")
[10:31:52.570]                           version <- ns[[".package"]][["version"]]
[10:31:52.570]                           if (is.null(version)) 
[10:31:52.570]                             version <- utils::packageVersion("future")
[10:31:52.570]                         }
[10:31:52.570]                         else {
[10:31:52.570]                           version <- NULL
[10:31:52.570]                         }
[10:31:52.570]                         if (!has_future || version < "1.8.0") {
[10:31:52.570]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:52.570]                             "", base::R.version$version.string), 
[10:31:52.570]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:52.570]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:52.570]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:52.570]                               "release", "version")], collapse = " "), 
[10:31:52.570]                             hostname = base::Sys.info()[["nodename"]])
[10:31:52.570]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:52.570]                             info)
[10:31:52.570]                           info <- base::paste(info, collapse = "; ")
[10:31:52.570]                           if (!has_future) {
[10:31:52.570]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:52.570]                               info)
[10:31:52.570]                           }
[10:31:52.570]                           else {
[10:31:52.570]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:52.570]                               info, version)
[10:31:52.570]                           }
[10:31:52.570]                           base::stop(msg)
[10:31:52.570]                         }
[10:31:52.570]                       })
[10:31:52.570]                     }
[10:31:52.570]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:52.570]                     base::options(mc.cores = 1L)
[10:31:52.570]                   }
[10:31:52.570]                   ...future.strategy.old <- future::plan("list")
[10:31:52.570]                   options(future.plan = NULL)
[10:31:52.570]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:52.570]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:52.570]                 }
[10:31:52.570]                 ...future.workdir <- getwd()
[10:31:52.570]             }
[10:31:52.570]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:52.570]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:52.570]         }
[10:31:52.570]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:52.570]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:52.570]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:52.570]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:52.570]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:52.570]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:52.570]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:52.570]             base::names(...future.oldOptions))
[10:31:52.570]     }
[10:31:52.570]     if (FALSE) {
[10:31:52.570]     }
[10:31:52.570]     else {
[10:31:52.570]         if (TRUE) {
[10:31:52.570]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:52.570]                 open = "w")
[10:31:52.570]         }
[10:31:52.570]         else {
[10:31:52.570]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:52.570]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:52.570]         }
[10:31:52.570]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:52.570]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:52.570]             base::sink(type = "output", split = FALSE)
[10:31:52.570]             base::close(...future.stdout)
[10:31:52.570]         }, add = TRUE)
[10:31:52.570]     }
[10:31:52.570]     ...future.frame <- base::sys.nframe()
[10:31:52.570]     ...future.conditions <- base::list()
[10:31:52.570]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:52.570]     if (FALSE) {
[10:31:52.570]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:52.570]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:52.570]     }
[10:31:52.570]     ...future.result <- base::tryCatch({
[10:31:52.570]         base::withCallingHandlers({
[10:31:52.570]             ...future.value <- base::withVisible(base::local({
[10:31:52.570]                 ...future.makeSendCondition <- base::local({
[10:31:52.570]                   sendCondition <- NULL
[10:31:52.570]                   function(frame = 1L) {
[10:31:52.570]                     if (is.function(sendCondition)) 
[10:31:52.570]                       return(sendCondition)
[10:31:52.570]                     ns <- getNamespace("parallel")
[10:31:52.570]                     if (exists("sendData", mode = "function", 
[10:31:52.570]                       envir = ns)) {
[10:31:52.570]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:52.570]                         envir = ns)
[10:31:52.570]                       envir <- sys.frame(frame)
[10:31:52.570]                       master <- NULL
[10:31:52.570]                       while (!identical(envir, .GlobalEnv) && 
[10:31:52.570]                         !identical(envir, emptyenv())) {
[10:31:52.570]                         if (exists("master", mode = "list", envir = envir, 
[10:31:52.570]                           inherits = FALSE)) {
[10:31:52.570]                           master <- get("master", mode = "list", 
[10:31:52.570]                             envir = envir, inherits = FALSE)
[10:31:52.570]                           if (inherits(master, c("SOCKnode", 
[10:31:52.570]                             "SOCK0node"))) {
[10:31:52.570]                             sendCondition <<- function(cond) {
[10:31:52.570]                               data <- list(type = "VALUE", value = cond, 
[10:31:52.570]                                 success = TRUE)
[10:31:52.570]                               parallel_sendData(master, data)
[10:31:52.570]                             }
[10:31:52.570]                             return(sendCondition)
[10:31:52.570]                           }
[10:31:52.570]                         }
[10:31:52.570]                         frame <- frame + 1L
[10:31:52.570]                         envir <- sys.frame(frame)
[10:31:52.570]                       }
[10:31:52.570]                     }
[10:31:52.570]                     sendCondition <<- function(cond) NULL
[10:31:52.570]                   }
[10:31:52.570]                 })
[10:31:52.570]                 withCallingHandlers({
[10:31:52.570]                   {
[10:31:52.570]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:52.570]                     if (!identical(...future.globals.maxSize.org, 
[10:31:52.570]                       ...future.globals.maxSize)) {
[10:31:52.570]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:52.570]                       on.exit(options(oopts), add = TRUE)
[10:31:52.570]                     }
[10:31:52.570]                     {
[10:31:52.570]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:52.570]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:52.570]                         USE.NAMES = FALSE)
[10:31:52.570]                       do.call(mapply, args = args)
[10:31:52.570]                     }
[10:31:52.570]                   }
[10:31:52.570]                 }, immediateCondition = function(cond) {
[10:31:52.570]                   sendCondition <- ...future.makeSendCondition()
[10:31:52.570]                   sendCondition(cond)
[10:31:52.570]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:52.570]                   {
[10:31:52.570]                     inherits <- base::inherits
[10:31:52.570]                     invokeRestart <- base::invokeRestart
[10:31:52.570]                     is.null <- base::is.null
[10:31:52.570]                     muffled <- FALSE
[10:31:52.570]                     if (inherits(cond, "message")) {
[10:31:52.570]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:52.570]                       if (muffled) 
[10:31:52.570]                         invokeRestart("muffleMessage")
[10:31:52.570]                     }
[10:31:52.570]                     else if (inherits(cond, "warning")) {
[10:31:52.570]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:52.570]                       if (muffled) 
[10:31:52.570]                         invokeRestart("muffleWarning")
[10:31:52.570]                     }
[10:31:52.570]                     else if (inherits(cond, "condition")) {
[10:31:52.570]                       if (!is.null(pattern)) {
[10:31:52.570]                         computeRestarts <- base::computeRestarts
[10:31:52.570]                         grepl <- base::grepl
[10:31:52.570]                         restarts <- computeRestarts(cond)
[10:31:52.570]                         for (restart in restarts) {
[10:31:52.570]                           name <- restart$name
[10:31:52.570]                           if (is.null(name)) 
[10:31:52.570]                             next
[10:31:52.570]                           if (!grepl(pattern, name)) 
[10:31:52.570]                             next
[10:31:52.570]                           invokeRestart(restart)
[10:31:52.570]                           muffled <- TRUE
[10:31:52.570]                           break
[10:31:52.570]                         }
[10:31:52.570]                       }
[10:31:52.570]                     }
[10:31:52.570]                     invisible(muffled)
[10:31:52.570]                   }
[10:31:52.570]                   muffleCondition(cond)
[10:31:52.570]                 })
[10:31:52.570]             }))
[10:31:52.570]             future::FutureResult(value = ...future.value$value, 
[10:31:52.570]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:52.570]                   ...future.rng), globalenv = if (FALSE) 
[10:31:52.570]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:52.570]                     ...future.globalenv.names))
[10:31:52.570]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:52.570]         }, condition = base::local({
[10:31:52.570]             c <- base::c
[10:31:52.570]             inherits <- base::inherits
[10:31:52.570]             invokeRestart <- base::invokeRestart
[10:31:52.570]             length <- base::length
[10:31:52.570]             list <- base::list
[10:31:52.570]             seq.int <- base::seq.int
[10:31:52.570]             signalCondition <- base::signalCondition
[10:31:52.570]             sys.calls <- base::sys.calls
[10:31:52.570]             `[[` <- base::`[[`
[10:31:52.570]             `+` <- base::`+`
[10:31:52.570]             `<<-` <- base::`<<-`
[10:31:52.570]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:52.570]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:52.570]                   3L)]
[10:31:52.570]             }
[10:31:52.570]             function(cond) {
[10:31:52.570]                 is_error <- inherits(cond, "error")
[10:31:52.570]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:52.570]                   NULL)
[10:31:52.570]                 if (is_error) {
[10:31:52.570]                   sessionInformation <- function() {
[10:31:52.570]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:52.570]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:52.570]                       search = base::search(), system = base::Sys.info())
[10:31:52.570]                   }
[10:31:52.570]                   ...future.conditions[[length(...future.conditions) + 
[10:31:52.570]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:52.570]                     cond$call), session = sessionInformation(), 
[10:31:52.570]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:52.570]                   signalCondition(cond)
[10:31:52.570]                 }
[10:31:52.570]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:52.570]                 "immediateCondition"))) {
[10:31:52.570]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:52.570]                   ...future.conditions[[length(...future.conditions) + 
[10:31:52.570]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:52.570]                   if (TRUE && !signal) {
[10:31:52.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:52.570]                     {
[10:31:52.570]                       inherits <- base::inherits
[10:31:52.570]                       invokeRestart <- base::invokeRestart
[10:31:52.570]                       is.null <- base::is.null
[10:31:52.570]                       muffled <- FALSE
[10:31:52.570]                       if (inherits(cond, "message")) {
[10:31:52.570]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:52.570]                         if (muffled) 
[10:31:52.570]                           invokeRestart("muffleMessage")
[10:31:52.570]                       }
[10:31:52.570]                       else if (inherits(cond, "warning")) {
[10:31:52.570]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:52.570]                         if (muffled) 
[10:31:52.570]                           invokeRestart("muffleWarning")
[10:31:52.570]                       }
[10:31:52.570]                       else if (inherits(cond, "condition")) {
[10:31:52.570]                         if (!is.null(pattern)) {
[10:31:52.570]                           computeRestarts <- base::computeRestarts
[10:31:52.570]                           grepl <- base::grepl
[10:31:52.570]                           restarts <- computeRestarts(cond)
[10:31:52.570]                           for (restart in restarts) {
[10:31:52.570]                             name <- restart$name
[10:31:52.570]                             if (is.null(name)) 
[10:31:52.570]                               next
[10:31:52.570]                             if (!grepl(pattern, name)) 
[10:31:52.570]                               next
[10:31:52.570]                             invokeRestart(restart)
[10:31:52.570]                             muffled <- TRUE
[10:31:52.570]                             break
[10:31:52.570]                           }
[10:31:52.570]                         }
[10:31:52.570]                       }
[10:31:52.570]                       invisible(muffled)
[10:31:52.570]                     }
[10:31:52.570]                     muffleCondition(cond, pattern = "^muffle")
[10:31:52.570]                   }
[10:31:52.570]                 }
[10:31:52.570]                 else {
[10:31:52.570]                   if (TRUE) {
[10:31:52.570]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:52.570]                     {
[10:31:52.570]                       inherits <- base::inherits
[10:31:52.570]                       invokeRestart <- base::invokeRestart
[10:31:52.570]                       is.null <- base::is.null
[10:31:52.570]                       muffled <- FALSE
[10:31:52.570]                       if (inherits(cond, "message")) {
[10:31:52.570]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:52.570]                         if (muffled) 
[10:31:52.570]                           invokeRestart("muffleMessage")
[10:31:52.570]                       }
[10:31:52.570]                       else if (inherits(cond, "warning")) {
[10:31:52.570]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:52.570]                         if (muffled) 
[10:31:52.570]                           invokeRestart("muffleWarning")
[10:31:52.570]                       }
[10:31:52.570]                       else if (inherits(cond, "condition")) {
[10:31:52.570]                         if (!is.null(pattern)) {
[10:31:52.570]                           computeRestarts <- base::computeRestarts
[10:31:52.570]                           grepl <- base::grepl
[10:31:52.570]                           restarts <- computeRestarts(cond)
[10:31:52.570]                           for (restart in restarts) {
[10:31:52.570]                             name <- restart$name
[10:31:52.570]                             if (is.null(name)) 
[10:31:52.570]                               next
[10:31:52.570]                             if (!grepl(pattern, name)) 
[10:31:52.570]                               next
[10:31:52.570]                             invokeRestart(restart)
[10:31:52.570]                             muffled <- TRUE
[10:31:52.570]                             break
[10:31:52.570]                           }
[10:31:52.570]                         }
[10:31:52.570]                       }
[10:31:52.570]                       invisible(muffled)
[10:31:52.570]                     }
[10:31:52.570]                     muffleCondition(cond, pattern = "^muffle")
[10:31:52.570]                   }
[10:31:52.570]                 }
[10:31:52.570]             }
[10:31:52.570]         }))
[10:31:52.570]     }, error = function(ex) {
[10:31:52.570]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:52.570]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:52.570]                 ...future.rng), started = ...future.startTime, 
[10:31:52.570]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:52.570]             version = "1.8"), class = "FutureResult")
[10:31:52.570]     }, finally = {
[10:31:52.570]         if (!identical(...future.workdir, getwd())) 
[10:31:52.570]             setwd(...future.workdir)
[10:31:52.570]         {
[10:31:52.570]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:52.570]                 ...future.oldOptions$nwarnings <- NULL
[10:31:52.570]             }
[10:31:52.570]             base::options(...future.oldOptions)
[10:31:52.570]             if (.Platform$OS.type == "windows") {
[10:31:52.570]                 old_names <- names(...future.oldEnvVars)
[10:31:52.570]                 envs <- base::Sys.getenv()
[10:31:52.570]                 names <- names(envs)
[10:31:52.570]                 common <- intersect(names, old_names)
[10:31:52.570]                 added <- setdiff(names, old_names)
[10:31:52.570]                 removed <- setdiff(old_names, names)
[10:31:52.570]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:52.570]                   envs[common]]
[10:31:52.570]                 NAMES <- toupper(changed)
[10:31:52.570]                 args <- list()
[10:31:52.570]                 for (kk in seq_along(NAMES)) {
[10:31:52.570]                   name <- changed[[kk]]
[10:31:52.570]                   NAME <- NAMES[[kk]]
[10:31:52.570]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:52.570]                     next
[10:31:52.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:52.570]                 }
[10:31:52.570]                 NAMES <- toupper(added)
[10:31:52.570]                 for (kk in seq_along(NAMES)) {
[10:31:52.570]                   name <- added[[kk]]
[10:31:52.570]                   NAME <- NAMES[[kk]]
[10:31:52.570]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:52.570]                     next
[10:31:52.570]                   args[[name]] <- ""
[10:31:52.570]                 }
[10:31:52.570]                 NAMES <- toupper(removed)
[10:31:52.570]                 for (kk in seq_along(NAMES)) {
[10:31:52.570]                   name <- removed[[kk]]
[10:31:52.570]                   NAME <- NAMES[[kk]]
[10:31:52.570]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:52.570]                     next
[10:31:52.570]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:52.570]                 }
[10:31:52.570]                 if (length(args) > 0) 
[10:31:52.570]                   base::do.call(base::Sys.setenv, args = args)
[10:31:52.570]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:52.570]             }
[10:31:52.570]             else {
[10:31:52.570]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:52.570]             }
[10:31:52.570]             {
[10:31:52.570]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:52.570]                   0L) {
[10:31:52.570]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:52.570]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:52.570]                   base::options(opts)
[10:31:52.570]                 }
[10:31:52.570]                 {
[10:31:52.570]                   {
[10:31:52.570]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:52.570]                     NULL
[10:31:52.570]                   }
[10:31:52.570]                   options(future.plan = NULL)
[10:31:52.570]                   if (is.na(NA_character_)) 
[10:31:52.570]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:52.570]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:52.570]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:52.570]                     .init = FALSE)
[10:31:52.570]                 }
[10:31:52.570]             }
[10:31:52.570]         }
[10:31:52.570]     })
[10:31:52.570]     if (TRUE) {
[10:31:52.570]         base::sink(type = "output", split = FALSE)
[10:31:52.570]         if (TRUE) {
[10:31:52.570]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:52.570]         }
[10:31:52.570]         else {
[10:31:52.570]             ...future.result["stdout"] <- base::list(NULL)
[10:31:52.570]         }
[10:31:52.570]         base::close(...future.stdout)
[10:31:52.570]         ...future.stdout <- NULL
[10:31:52.570]     }
[10:31:52.570]     ...future.result$conditions <- ...future.conditions
[10:31:52.570]     ...future.result$finished <- base::Sys.time()
[10:31:52.570]     ...future.result
[10:31:52.570] }
[10:31:52.572] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[10:31:52.572] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[10:31:52.573] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[10:31:52.573] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:31:52.573] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:31:52.573] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:31:52.574] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:31:52.574] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:52.574] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:52.574] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:52.575] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:52.575] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[10:31:52.575] MultisessionFuture started
[10:31:52.575] - Launch lazy future ... done
[10:31:52.575] run() for ‘MultisessionFuture’ ... done
[10:31:52.575] Created future:
[10:31:52.575] MultisessionFuture:
[10:31:52.575] Label: ‘future_mapply-2’
[10:31:52.575] Expression:
[10:31:52.575] {
[10:31:52.575]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:52.575]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:52.575]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:52.575]         on.exit(options(oopts), add = TRUE)
[10:31:52.575]     }
[10:31:52.575]     {
[10:31:52.575]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:52.575]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:52.575]         do.call(mapply, args = args)
[10:31:52.575]     }
[10:31:52.575] }
[10:31:52.575] Lazy evaluation: FALSE
[10:31:52.575] Asynchronous evaluation: TRUE
[10:31:52.575] Local evaluation: TRUE
[10:31:52.575] Environment: R_GlobalEnv
[10:31:52.575] Capture standard output: TRUE
[10:31:52.575] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:52.575] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:52.575] Packages: <none>
[10:31:52.575] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:52.575] Resolved: FALSE
[10:31:52.575] Value: <not collected>
[10:31:52.575] Conditions captured: <none>
[10:31:52.575] Early signaling: FALSE
[10:31:52.575] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:52.575] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:52.587] Chunk #2 of 2 ... DONE
[10:31:52.587] Launching 2 futures (chunks) ... DONE
[10:31:52.587] Resolving 2 futures (chunks) ...
[10:31:52.587] resolve() on list ...
[10:31:52.587]  recursive: 0
[10:31:52.587]  length: 2
[10:31:52.587] 
[10:31:52.629] receiveMessageFromWorker() for ClusterFuture ...
[10:31:52.630] - Validating connection of MultisessionFuture
[10:31:52.630] - received message: FutureResult
[10:31:52.630] - Received FutureResult
[10:31:52.630] - Erased future from FutureRegistry
[10:31:52.630] result() for ClusterFuture ...
[10:31:52.630] - result already collected: FutureResult
[10:31:52.631] result() for ClusterFuture ... done
[10:31:52.631] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:52.631] Future #2
[10:31:52.631] result() for ClusterFuture ...
[10:31:52.631] - result already collected: FutureResult
[10:31:52.631] result() for ClusterFuture ... done
[10:31:52.631] result() for ClusterFuture ...
[10:31:52.631] - result already collected: FutureResult
[10:31:52.631] result() for ClusterFuture ... done
[10:31:52.631] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:52.632] - nx: 2
[10:31:52.632] - relay: TRUE
[10:31:52.632] - stdout: TRUE
[10:31:52.632] - signal: TRUE
[10:31:52.632] - resignal: FALSE
[10:31:52.632] - force: TRUE
[10:31:52.632] - relayed: [n=2] FALSE, FALSE
[10:31:52.632] - queued futures: [n=2] FALSE, FALSE
[10:31:52.632]  - until=1
[10:31:52.632]  - relaying element #1
[10:31:52.632] - relayed: [n=2] FALSE, FALSE
[10:31:52.632] - queued futures: [n=2] FALSE, TRUE
[10:31:52.633] signalConditionsASAP(NULL, pos=2) ... done
[10:31:52.633]  length: 1 (resolved future 2)
[10:31:53.080] receiveMessageFromWorker() for ClusterFuture ...
[10:31:53.080] - Validating connection of MultisessionFuture
[10:31:53.080] - received message: FutureResult
[10:31:53.080] - Received FutureResult
[10:31:53.080] - Erased future from FutureRegistry
[10:31:53.080] result() for ClusterFuture ...
[10:31:53.081] - result already collected: FutureResult
[10:31:53.081] result() for ClusterFuture ... done
[10:31:53.081] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:53.081] Future #1
[10:31:53.081] result() for ClusterFuture ...
[10:31:53.081] - result already collected: FutureResult
[10:31:53.081] result() for ClusterFuture ... done
[10:31:53.081] result() for ClusterFuture ...
[10:31:53.081] - result already collected: FutureResult
[10:31:53.081] result() for ClusterFuture ... done
[10:31:53.082] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:53.082] - nx: 2
[10:31:53.082] - relay: TRUE
[10:31:53.082] - stdout: TRUE
[10:31:53.082] - signal: TRUE
[10:31:53.082] - resignal: FALSE
[10:31:53.082] - force: TRUE
[10:31:53.082] - relayed: [n=2] FALSE, FALSE
[10:31:53.082] - queued futures: [n=2] FALSE, TRUE
[10:31:53.082]  - until=1
[10:31:53.082]  - relaying element #1
[10:31:53.083] result() for ClusterFuture ...
[10:31:53.083] - result already collected: FutureResult
[10:31:53.083] result() for ClusterFuture ... done
[10:31:53.083] result() for ClusterFuture ...
[10:31:53.083] - result already collected: FutureResult
[10:31:53.083] result() for ClusterFuture ... done
[10:31:53.083] result() for ClusterFuture ...
[10:31:53.083] - result already collected: FutureResult
[10:31:53.083] result() for ClusterFuture ... done
[10:31:53.083] result() for ClusterFuture ...
[10:31:53.083] - result already collected: FutureResult
[10:31:53.084] result() for ClusterFuture ... done
[10:31:53.084] - relayed: [n=2] TRUE, FALSE
[10:31:53.084] - queued futures: [n=2] TRUE, TRUE
[10:31:53.084] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:53.084]  length: 0 (resolved future 1)
[10:31:53.084] Relaying remaining futures
[10:31:53.084] signalConditionsASAP(NULL, pos=0) ...
[10:31:53.084] - nx: 2
[10:31:53.084] - relay: TRUE
[10:31:53.084] - stdout: TRUE
[10:31:53.084] - signal: TRUE
[10:31:53.084] - resignal: FALSE
[10:31:53.085] - force: TRUE
[10:31:53.085] - relayed: [n=2] TRUE, FALSE
[10:31:53.085] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:53.085]  - relaying element #2
[10:31:53.085] result() for ClusterFuture ...
[10:31:53.085] - result already collected: FutureResult
[10:31:53.085] result() for ClusterFuture ... done
[10:31:53.085] result() for ClusterFuture ...
[10:31:53.085] - result already collected: FutureResult
[10:31:53.085] result() for ClusterFuture ... done
[10:31:53.086] result() for ClusterFuture ...
[10:31:53.086] - result already collected: FutureResult
[10:31:53.086] result() for ClusterFuture ... done
[10:31:53.086] result() for ClusterFuture ...
[10:31:53.086] - result already collected: FutureResult
[10:31:53.086] result() for ClusterFuture ... done
[10:31:53.086] - relayed: [n=2] TRUE, TRUE
[10:31:53.086] - queued futures: [n=2] TRUE, TRUE
[10:31:53.086] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:31:53.086] resolve() on list ... DONE
[10:31:53.086] result() for ClusterFuture ...
[10:31:53.087] - result already collected: FutureResult
[10:31:53.087] result() for ClusterFuture ... done
[10:31:53.087] result() for ClusterFuture ...
[10:31:53.087] - result already collected: FutureResult
[10:31:53.087] result() for ClusterFuture ... done
[10:31:53.087] result() for ClusterFuture ...
[10:31:53.087] - result already collected: FutureResult
[10:31:53.087] result() for ClusterFuture ... done
[10:31:53.087] result() for ClusterFuture ...
[10:31:53.087] - result already collected: FutureResult
[10:31:53.087] result() for ClusterFuture ... done
[10:31:53.088]  - Number of value chunks collected: 2
[10:31:53.088] Resolving 2 futures (chunks) ... DONE
[10:31:53.088] Reducing values from 2 chunks ...
[10:31:53.088]  - Number of values collected after concatenation: 2
[10:31:53.088]  - Number of values expected: 2
[10:31:53.088] Reducing values from 2 chunks ... DONE
[10:31:53.088] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[10:31:53.088] future_mapply() ...
[10:31:53.092] Number of chunks: 2
[10:31:53.092] getGlobalsAndPackagesXApply() ...
[10:31:53.093]  - future.globals: TRUE
[10:31:53.093] getGlobalsAndPackages() ...
[10:31:53.093] Searching for globals...
[10:31:53.094] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[10:31:53.094] Searching for globals ... DONE
[10:31:53.095] Resolving globals: FALSE
[10:31:53.095] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[10:31:53.095] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[10:31:53.095] - globals: [1] ‘FUN’
[10:31:53.096] 
[10:31:53.096] getGlobalsAndPackages() ... DONE
[10:31:53.096]  - globals found/used: [n=1] ‘FUN’
[10:31:53.096]  - needed namespaces: [n=0] 
[10:31:53.096] Finding globals ... DONE
[10:31:53.096] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[10:31:53.096] List of 2
[10:31:53.096]  $ ...future.FUN:function (x, y)  
[10:31:53.096]  $ MoreArgs     : NULL
[10:31:53.096]  - attr(*, "where")=List of 2
[10:31:53.096]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:53.096]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[10:31:53.096]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:53.096]  - attr(*, "resolved")= logi FALSE
[10:31:53.096]  - attr(*, "total_size")= num NA
[10:31:53.099] Packages to be attached in all futures: [n=0] 
[10:31:53.099] getGlobalsAndPackagesXApply() ... DONE
[10:31:53.099] Number of futures (= number of chunks): 2
[10:31:53.099] Launching 2 futures (chunks) ...
[10:31:53.099] Chunk #1 of 2 ...
[10:31:53.099]  - Finding globals in '...' for chunk #1 ...
[10:31:53.099] getGlobalsAndPackages() ...
[10:31:53.100] Searching for globals...
[10:31:53.100] 
[10:31:53.100] Searching for globals ... DONE
[10:31:53.100] - globals: [0] <none>
[10:31:53.100] getGlobalsAndPackages() ... DONE
[10:31:53.100]    + additional globals found: [n=0] 
[10:31:53.100]    + additional namespaces needed: [n=0] 
[10:31:53.100]  - Finding globals in '...' for chunk #1 ... DONE
[10:31:53.100]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:53.101]  - seeds: <none>
[10:31:53.101]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:53.101] getGlobalsAndPackages() ...
[10:31:53.101] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:53.101] Resolving globals: FALSE
[10:31:53.101] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:31:53.102] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:53.102] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:53.102] 
[10:31:53.102] getGlobalsAndPackages() ... DONE
[10:31:53.102] run() for ‘Future’ ...
[10:31:53.103] - state: ‘created’
[10:31:53.103] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:53.116] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:53.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:53.117]   - Field: ‘node’
[10:31:53.117]   - Field: ‘label’
[10:31:53.117]   - Field: ‘local’
[10:31:53.117]   - Field: ‘owner’
[10:31:53.117]   - Field: ‘envir’
[10:31:53.117]   - Field: ‘workers’
[10:31:53.117]   - Field: ‘packages’
[10:31:53.117]   - Field: ‘gc’
[10:31:53.118]   - Field: ‘conditions’
[10:31:53.118]   - Field: ‘persistent’
[10:31:53.118]   - Field: ‘expr’
[10:31:53.118]   - Field: ‘uuid’
[10:31:53.118]   - Field: ‘seed’
[10:31:53.118]   - Field: ‘version’
[10:31:53.118]   - Field: ‘result’
[10:31:53.118]   - Field: ‘asynchronous’
[10:31:53.118]   - Field: ‘calls’
[10:31:53.118]   - Field: ‘globals’
[10:31:53.118]   - Field: ‘stdout’
[10:31:53.119]   - Field: ‘earlySignal’
[10:31:53.119]   - Field: ‘lazy’
[10:31:53.119]   - Field: ‘state’
[10:31:53.119] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:53.119] - Launch lazy future ...
[10:31:53.119] Packages needed by the future expression (n = 0): <none>
[10:31:53.119] Packages needed by future strategies (n = 0): <none>
[10:31:53.120] {
[10:31:53.120]     {
[10:31:53.120]         {
[10:31:53.120]             ...future.startTime <- base::Sys.time()
[10:31:53.120]             {
[10:31:53.120]                 {
[10:31:53.120]                   {
[10:31:53.120]                     {
[10:31:53.120]                       base::local({
[10:31:53.120]                         has_future <- base::requireNamespace("future", 
[10:31:53.120]                           quietly = TRUE)
[10:31:53.120]                         if (has_future) {
[10:31:53.120]                           ns <- base::getNamespace("future")
[10:31:53.120]                           version <- ns[[".package"]][["version"]]
[10:31:53.120]                           if (is.null(version)) 
[10:31:53.120]                             version <- utils::packageVersion("future")
[10:31:53.120]                         }
[10:31:53.120]                         else {
[10:31:53.120]                           version <- NULL
[10:31:53.120]                         }
[10:31:53.120]                         if (!has_future || version < "1.8.0") {
[10:31:53.120]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:53.120]                             "", base::R.version$version.string), 
[10:31:53.120]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:53.120]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:53.120]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:53.120]                               "release", "version")], collapse = " "), 
[10:31:53.120]                             hostname = base::Sys.info()[["nodename"]])
[10:31:53.120]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:53.120]                             info)
[10:31:53.120]                           info <- base::paste(info, collapse = "; ")
[10:31:53.120]                           if (!has_future) {
[10:31:53.120]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:53.120]                               info)
[10:31:53.120]                           }
[10:31:53.120]                           else {
[10:31:53.120]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:53.120]                               info, version)
[10:31:53.120]                           }
[10:31:53.120]                           base::stop(msg)
[10:31:53.120]                         }
[10:31:53.120]                       })
[10:31:53.120]                     }
[10:31:53.120]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:53.120]                     base::options(mc.cores = 1L)
[10:31:53.120]                   }
[10:31:53.120]                   ...future.strategy.old <- future::plan("list")
[10:31:53.120]                   options(future.plan = NULL)
[10:31:53.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:53.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:53.120]                 }
[10:31:53.120]                 ...future.workdir <- getwd()
[10:31:53.120]             }
[10:31:53.120]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:53.120]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:53.120]         }
[10:31:53.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:53.120]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:53.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:53.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:53.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:53.120]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:53.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:53.120]             base::names(...future.oldOptions))
[10:31:53.120]     }
[10:31:53.120]     if (TRUE) {
[10:31:53.120]     }
[10:31:53.120]     else {
[10:31:53.120]         if (NA) {
[10:31:53.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:53.120]                 open = "w")
[10:31:53.120]         }
[10:31:53.120]         else {
[10:31:53.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:53.120]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:53.120]         }
[10:31:53.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:53.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:53.120]             base::sink(type = "output", split = FALSE)
[10:31:53.120]             base::close(...future.stdout)
[10:31:53.120]         }, add = TRUE)
[10:31:53.120]     }
[10:31:53.120]     ...future.frame <- base::sys.nframe()
[10:31:53.120]     ...future.conditions <- base::list()
[10:31:53.120]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:53.120]     if (FALSE) {
[10:31:53.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:53.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:53.120]     }
[10:31:53.120]     ...future.result <- base::tryCatch({
[10:31:53.120]         base::withCallingHandlers({
[10:31:53.120]             ...future.value <- base::withVisible(base::local({
[10:31:53.120]                 ...future.makeSendCondition <- base::local({
[10:31:53.120]                   sendCondition <- NULL
[10:31:53.120]                   function(frame = 1L) {
[10:31:53.120]                     if (is.function(sendCondition)) 
[10:31:53.120]                       return(sendCondition)
[10:31:53.120]                     ns <- getNamespace("parallel")
[10:31:53.120]                     if (exists("sendData", mode = "function", 
[10:31:53.120]                       envir = ns)) {
[10:31:53.120]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:53.120]                         envir = ns)
[10:31:53.120]                       envir <- sys.frame(frame)
[10:31:53.120]                       master <- NULL
[10:31:53.120]                       while (!identical(envir, .GlobalEnv) && 
[10:31:53.120]                         !identical(envir, emptyenv())) {
[10:31:53.120]                         if (exists("master", mode = "list", envir = envir, 
[10:31:53.120]                           inherits = FALSE)) {
[10:31:53.120]                           master <- get("master", mode = "list", 
[10:31:53.120]                             envir = envir, inherits = FALSE)
[10:31:53.120]                           if (inherits(master, c("SOCKnode", 
[10:31:53.120]                             "SOCK0node"))) {
[10:31:53.120]                             sendCondition <<- function(cond) {
[10:31:53.120]                               data <- list(type = "VALUE", value = cond, 
[10:31:53.120]                                 success = TRUE)
[10:31:53.120]                               parallel_sendData(master, data)
[10:31:53.120]                             }
[10:31:53.120]                             return(sendCondition)
[10:31:53.120]                           }
[10:31:53.120]                         }
[10:31:53.120]                         frame <- frame + 1L
[10:31:53.120]                         envir <- sys.frame(frame)
[10:31:53.120]                       }
[10:31:53.120]                     }
[10:31:53.120]                     sendCondition <<- function(cond) NULL
[10:31:53.120]                   }
[10:31:53.120]                 })
[10:31:53.120]                 withCallingHandlers({
[10:31:53.120]                   {
[10:31:53.120]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:53.120]                     if (!identical(...future.globals.maxSize.org, 
[10:31:53.120]                       ...future.globals.maxSize)) {
[10:31:53.120]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:53.120]                       on.exit(options(oopts), add = TRUE)
[10:31:53.120]                     }
[10:31:53.120]                     {
[10:31:53.120]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:53.120]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:53.120]                         USE.NAMES = FALSE)
[10:31:53.120]                       do.call(mapply, args = args)
[10:31:53.120]                     }
[10:31:53.120]                   }
[10:31:53.120]                 }, immediateCondition = function(cond) {
[10:31:53.120]                   sendCondition <- ...future.makeSendCondition()
[10:31:53.120]                   sendCondition(cond)
[10:31:53.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:53.120]                   {
[10:31:53.120]                     inherits <- base::inherits
[10:31:53.120]                     invokeRestart <- base::invokeRestart
[10:31:53.120]                     is.null <- base::is.null
[10:31:53.120]                     muffled <- FALSE
[10:31:53.120]                     if (inherits(cond, "message")) {
[10:31:53.120]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:53.120]                       if (muffled) 
[10:31:53.120]                         invokeRestart("muffleMessage")
[10:31:53.120]                     }
[10:31:53.120]                     else if (inherits(cond, "warning")) {
[10:31:53.120]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:53.120]                       if (muffled) 
[10:31:53.120]                         invokeRestart("muffleWarning")
[10:31:53.120]                     }
[10:31:53.120]                     else if (inherits(cond, "condition")) {
[10:31:53.120]                       if (!is.null(pattern)) {
[10:31:53.120]                         computeRestarts <- base::computeRestarts
[10:31:53.120]                         grepl <- base::grepl
[10:31:53.120]                         restarts <- computeRestarts(cond)
[10:31:53.120]                         for (restart in restarts) {
[10:31:53.120]                           name <- restart$name
[10:31:53.120]                           if (is.null(name)) 
[10:31:53.120]                             next
[10:31:53.120]                           if (!grepl(pattern, name)) 
[10:31:53.120]                             next
[10:31:53.120]                           invokeRestart(restart)
[10:31:53.120]                           muffled <- TRUE
[10:31:53.120]                           break
[10:31:53.120]                         }
[10:31:53.120]                       }
[10:31:53.120]                     }
[10:31:53.120]                     invisible(muffled)
[10:31:53.120]                   }
[10:31:53.120]                   muffleCondition(cond)
[10:31:53.120]                 })
[10:31:53.120]             }))
[10:31:53.120]             future::FutureResult(value = ...future.value$value, 
[10:31:53.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:53.120]                   ...future.rng), globalenv = if (FALSE) 
[10:31:53.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:53.120]                     ...future.globalenv.names))
[10:31:53.120]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:53.120]         }, condition = base::local({
[10:31:53.120]             c <- base::c
[10:31:53.120]             inherits <- base::inherits
[10:31:53.120]             invokeRestart <- base::invokeRestart
[10:31:53.120]             length <- base::length
[10:31:53.120]             list <- base::list
[10:31:53.120]             seq.int <- base::seq.int
[10:31:53.120]             signalCondition <- base::signalCondition
[10:31:53.120]             sys.calls <- base::sys.calls
[10:31:53.120]             `[[` <- base::`[[`
[10:31:53.120]             `+` <- base::`+`
[10:31:53.120]             `<<-` <- base::`<<-`
[10:31:53.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:53.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:53.120]                   3L)]
[10:31:53.120]             }
[10:31:53.120]             function(cond) {
[10:31:53.120]                 is_error <- inherits(cond, "error")
[10:31:53.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:53.120]                   NULL)
[10:31:53.120]                 if (is_error) {
[10:31:53.120]                   sessionInformation <- function() {
[10:31:53.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:53.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:53.120]                       search = base::search(), system = base::Sys.info())
[10:31:53.120]                   }
[10:31:53.120]                   ...future.conditions[[length(...future.conditions) + 
[10:31:53.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:53.120]                     cond$call), session = sessionInformation(), 
[10:31:53.120]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:53.120]                   signalCondition(cond)
[10:31:53.120]                 }
[10:31:53.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:53.120]                 "immediateCondition"))) {
[10:31:53.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:53.120]                   ...future.conditions[[length(...future.conditions) + 
[10:31:53.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:53.120]                   if (TRUE && !signal) {
[10:31:53.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:53.120]                     {
[10:31:53.120]                       inherits <- base::inherits
[10:31:53.120]                       invokeRestart <- base::invokeRestart
[10:31:53.120]                       is.null <- base::is.null
[10:31:53.120]                       muffled <- FALSE
[10:31:53.120]                       if (inherits(cond, "message")) {
[10:31:53.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:53.120]                         if (muffled) 
[10:31:53.120]                           invokeRestart("muffleMessage")
[10:31:53.120]                       }
[10:31:53.120]                       else if (inherits(cond, "warning")) {
[10:31:53.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:53.120]                         if (muffled) 
[10:31:53.120]                           invokeRestart("muffleWarning")
[10:31:53.120]                       }
[10:31:53.120]                       else if (inherits(cond, "condition")) {
[10:31:53.120]                         if (!is.null(pattern)) {
[10:31:53.120]                           computeRestarts <- base::computeRestarts
[10:31:53.120]                           grepl <- base::grepl
[10:31:53.120]                           restarts <- computeRestarts(cond)
[10:31:53.120]                           for (restart in restarts) {
[10:31:53.120]                             name <- restart$name
[10:31:53.120]                             if (is.null(name)) 
[10:31:53.120]                               next
[10:31:53.120]                             if (!grepl(pattern, name)) 
[10:31:53.120]                               next
[10:31:53.120]                             invokeRestart(restart)
[10:31:53.120]                             muffled <- TRUE
[10:31:53.120]                             break
[10:31:53.120]                           }
[10:31:53.120]                         }
[10:31:53.120]                       }
[10:31:53.120]                       invisible(muffled)
[10:31:53.120]                     }
[10:31:53.120]                     muffleCondition(cond, pattern = "^muffle")
[10:31:53.120]                   }
[10:31:53.120]                 }
[10:31:53.120]                 else {
[10:31:53.120]                   if (TRUE) {
[10:31:53.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:53.120]                     {
[10:31:53.120]                       inherits <- base::inherits
[10:31:53.120]                       invokeRestart <- base::invokeRestart
[10:31:53.120]                       is.null <- base::is.null
[10:31:53.120]                       muffled <- FALSE
[10:31:53.120]                       if (inherits(cond, "message")) {
[10:31:53.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:53.120]                         if (muffled) 
[10:31:53.120]                           invokeRestart("muffleMessage")
[10:31:53.120]                       }
[10:31:53.120]                       else if (inherits(cond, "warning")) {
[10:31:53.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:53.120]                         if (muffled) 
[10:31:53.120]                           invokeRestart("muffleWarning")
[10:31:53.120]                       }
[10:31:53.120]                       else if (inherits(cond, "condition")) {
[10:31:53.120]                         if (!is.null(pattern)) {
[10:31:53.120]                           computeRestarts <- base::computeRestarts
[10:31:53.120]                           grepl <- base::grepl
[10:31:53.120]                           restarts <- computeRestarts(cond)
[10:31:53.120]                           for (restart in restarts) {
[10:31:53.120]                             name <- restart$name
[10:31:53.120]                             if (is.null(name)) 
[10:31:53.120]                               next
[10:31:53.120]                             if (!grepl(pattern, name)) 
[10:31:53.120]                               next
[10:31:53.120]                             invokeRestart(restart)
[10:31:53.120]                             muffled <- TRUE
[10:31:53.120]                             break
[10:31:53.120]                           }
[10:31:53.120]                         }
[10:31:53.120]                       }
[10:31:53.120]                       invisible(muffled)
[10:31:53.120]                     }
[10:31:53.120]                     muffleCondition(cond, pattern = "^muffle")
[10:31:53.120]                   }
[10:31:53.120]                 }
[10:31:53.120]             }
[10:31:53.120]         }))
[10:31:53.120]     }, error = function(ex) {
[10:31:53.120]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:53.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:53.120]                 ...future.rng), started = ...future.startTime, 
[10:31:53.120]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:53.120]             version = "1.8"), class = "FutureResult")
[10:31:53.120]     }, finally = {
[10:31:53.120]         if (!identical(...future.workdir, getwd())) 
[10:31:53.120]             setwd(...future.workdir)
[10:31:53.120]         {
[10:31:53.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:53.120]                 ...future.oldOptions$nwarnings <- NULL
[10:31:53.120]             }
[10:31:53.120]             base::options(...future.oldOptions)
[10:31:53.120]             if (.Platform$OS.type == "windows") {
[10:31:53.120]                 old_names <- names(...future.oldEnvVars)
[10:31:53.120]                 envs <- base::Sys.getenv()
[10:31:53.120]                 names <- names(envs)
[10:31:53.120]                 common <- intersect(names, old_names)
[10:31:53.120]                 added <- setdiff(names, old_names)
[10:31:53.120]                 removed <- setdiff(old_names, names)
[10:31:53.120]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:53.120]                   envs[common]]
[10:31:53.120]                 NAMES <- toupper(changed)
[10:31:53.120]                 args <- list()
[10:31:53.120]                 for (kk in seq_along(NAMES)) {
[10:31:53.120]                   name <- changed[[kk]]
[10:31:53.120]                   NAME <- NAMES[[kk]]
[10:31:53.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:53.120]                     next
[10:31:53.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:53.120]                 }
[10:31:53.120]                 NAMES <- toupper(added)
[10:31:53.120]                 for (kk in seq_along(NAMES)) {
[10:31:53.120]                   name <- added[[kk]]
[10:31:53.120]                   NAME <- NAMES[[kk]]
[10:31:53.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:53.120]                     next
[10:31:53.120]                   args[[name]] <- ""
[10:31:53.120]                 }
[10:31:53.120]                 NAMES <- toupper(removed)
[10:31:53.120]                 for (kk in seq_along(NAMES)) {
[10:31:53.120]                   name <- removed[[kk]]
[10:31:53.120]                   NAME <- NAMES[[kk]]
[10:31:53.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:53.120]                     next
[10:31:53.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:53.120]                 }
[10:31:53.120]                 if (length(args) > 0) 
[10:31:53.120]                   base::do.call(base::Sys.setenv, args = args)
[10:31:53.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:53.120]             }
[10:31:53.120]             else {
[10:31:53.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:53.120]             }
[10:31:53.120]             {
[10:31:53.120]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:53.120]                   0L) {
[10:31:53.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:53.120]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:53.120]                   base::options(opts)
[10:31:53.120]                 }
[10:31:53.120]                 {
[10:31:53.120]                   {
[10:31:53.120]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:53.120]                     NULL
[10:31:53.120]                   }
[10:31:53.120]                   options(future.plan = NULL)
[10:31:53.120]                   if (is.na(NA_character_)) 
[10:31:53.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:53.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:53.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:53.120]                     .init = FALSE)
[10:31:53.120]                 }
[10:31:53.120]             }
[10:31:53.120]         }
[10:31:53.120]     })
[10:31:53.120]     if (FALSE) {
[10:31:53.120]         base::sink(type = "output", split = FALSE)
[10:31:53.120]         if (NA) {
[10:31:53.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:53.120]         }
[10:31:53.120]         else {
[10:31:53.120]             ...future.result["stdout"] <- base::list(NULL)
[10:31:53.120]         }
[10:31:53.120]         base::close(...future.stdout)
[10:31:53.120]         ...future.stdout <- NULL
[10:31:53.120]     }
[10:31:53.120]     ...future.result$conditions <- ...future.conditions
[10:31:53.120]     ...future.result$finished <- base::Sys.time()
[10:31:53.120]     ...future.result
[10:31:53.120] }
[10:31:53.123] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[10:31:53.123] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[10:31:53.123] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[10:31:53.123] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[10:31:53.124] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[10:31:53.124] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:31:53.124] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:31:53.124] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:53.125] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:53.125] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:53.125] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:53.125] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[10:31:53.126] MultisessionFuture started
[10:31:53.126] - Launch lazy future ... done
[10:31:53.126] run() for ‘MultisessionFuture’ ... done
[10:31:53.126] Created future:
[10:31:53.126] MultisessionFuture:
[10:31:53.126] Label: ‘future_mapply-1’
[10:31:53.126] Expression:
[10:31:53.126] {
[10:31:53.126]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:53.126]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:53.126]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:53.126]         on.exit(options(oopts), add = TRUE)
[10:31:53.126]     }
[10:31:53.126]     {
[10:31:53.126]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:53.126]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:53.126]         do.call(mapply, args = args)
[10:31:53.126]     }
[10:31:53.126] }
[10:31:53.126] Lazy evaluation: FALSE
[10:31:53.126] Asynchronous evaluation: TRUE
[10:31:53.126] Local evaluation: TRUE
[10:31:53.126] Environment: R_GlobalEnv
[10:31:53.126] Capture standard output: NA
[10:31:53.126] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:53.126] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:53.126] Packages: <none>
[10:31:53.126] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:53.126] Resolved: FALSE
[10:31:53.126] Value: <not collected>
[10:31:53.126] Conditions captured: <none>
[10:31:53.126] Early signaling: FALSE
[10:31:53.126] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:53.126] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:53.138] Chunk #1 of 2 ... DONE
[10:31:53.138] Chunk #2 of 2 ...
[10:31:53.138]  - Finding globals in '...' for chunk #2 ...
[10:31:53.138] getGlobalsAndPackages() ...
[10:31:53.138] Searching for globals...
[10:31:53.139] 
[10:31:53.139] Searching for globals ... DONE
[10:31:53.139] - globals: [0] <none>
[10:31:53.139] getGlobalsAndPackages() ... DONE
[10:31:53.139]    + additional globals found: [n=0] 
[10:31:53.139]    + additional namespaces needed: [n=0] 
[10:31:53.139]  - Finding globals in '...' for chunk #2 ... DONE
[10:31:53.139]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:53.139]  - seeds: <none>
[10:31:53.140]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:53.140] getGlobalsAndPackages() ...
[10:31:53.140] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:53.140] Resolving globals: FALSE
[10:31:53.140] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[10:31:53.141] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[10:31:53.141] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:53.141] 
[10:31:53.141] getGlobalsAndPackages() ... DONE
[10:31:53.141] run() for ‘Future’ ...
[10:31:53.142] - state: ‘created’
[10:31:53.142] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:53.155] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:53.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:53.156]   - Field: ‘node’
[10:31:53.156]   - Field: ‘label’
[10:31:53.156]   - Field: ‘local’
[10:31:53.156]   - Field: ‘owner’
[10:31:53.156]   - Field: ‘envir’
[10:31:53.156]   - Field: ‘workers’
[10:31:53.156]   - Field: ‘packages’
[10:31:53.156]   - Field: ‘gc’
[10:31:53.156]   - Field: ‘conditions’
[10:31:53.157]   - Field: ‘persistent’
[10:31:53.157]   - Field: ‘expr’
[10:31:53.157]   - Field: ‘uuid’
[10:31:53.157]   - Field: ‘seed’
[10:31:53.157]   - Field: ‘version’
[10:31:53.157]   - Field: ‘result’
[10:31:53.157]   - Field: ‘asynchronous’
[10:31:53.157]   - Field: ‘calls’
[10:31:53.157]   - Field: ‘globals’
[10:31:53.157]   - Field: ‘stdout’
[10:31:53.158]   - Field: ‘earlySignal’
[10:31:53.158]   - Field: ‘lazy’
[10:31:53.158]   - Field: ‘state’
[10:31:53.158] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:53.158] - Launch lazy future ...
[10:31:53.158] Packages needed by the future expression (n = 0): <none>
[10:31:53.158] Packages needed by future strategies (n = 0): <none>
[10:31:53.159] {
[10:31:53.159]     {
[10:31:53.159]         {
[10:31:53.159]             ...future.startTime <- base::Sys.time()
[10:31:53.159]             {
[10:31:53.159]                 {
[10:31:53.159]                   {
[10:31:53.159]                     {
[10:31:53.159]                       base::local({
[10:31:53.159]                         has_future <- base::requireNamespace("future", 
[10:31:53.159]                           quietly = TRUE)
[10:31:53.159]                         if (has_future) {
[10:31:53.159]                           ns <- base::getNamespace("future")
[10:31:53.159]                           version <- ns[[".package"]][["version"]]
[10:31:53.159]                           if (is.null(version)) 
[10:31:53.159]                             version <- utils::packageVersion("future")
[10:31:53.159]                         }
[10:31:53.159]                         else {
[10:31:53.159]                           version <- NULL
[10:31:53.159]                         }
[10:31:53.159]                         if (!has_future || version < "1.8.0") {
[10:31:53.159]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:53.159]                             "", base::R.version$version.string), 
[10:31:53.159]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:53.159]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:53.159]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:53.159]                               "release", "version")], collapse = " "), 
[10:31:53.159]                             hostname = base::Sys.info()[["nodename"]])
[10:31:53.159]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:53.159]                             info)
[10:31:53.159]                           info <- base::paste(info, collapse = "; ")
[10:31:53.159]                           if (!has_future) {
[10:31:53.159]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:53.159]                               info)
[10:31:53.159]                           }
[10:31:53.159]                           else {
[10:31:53.159]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:53.159]                               info, version)
[10:31:53.159]                           }
[10:31:53.159]                           base::stop(msg)
[10:31:53.159]                         }
[10:31:53.159]                       })
[10:31:53.159]                     }
[10:31:53.159]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:53.159]                     base::options(mc.cores = 1L)
[10:31:53.159]                   }
[10:31:53.159]                   ...future.strategy.old <- future::plan("list")
[10:31:53.159]                   options(future.plan = NULL)
[10:31:53.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:53.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:53.159]                 }
[10:31:53.159]                 ...future.workdir <- getwd()
[10:31:53.159]             }
[10:31:53.159]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:53.159]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:53.159]         }
[10:31:53.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:53.159]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:53.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:53.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:53.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:53.159]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:53.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:53.159]             base::names(...future.oldOptions))
[10:31:53.159]     }
[10:31:53.159]     if (TRUE) {
[10:31:53.159]     }
[10:31:53.159]     else {
[10:31:53.159]         if (NA) {
[10:31:53.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:53.159]                 open = "w")
[10:31:53.159]         }
[10:31:53.159]         else {
[10:31:53.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:53.159]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:53.159]         }
[10:31:53.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:53.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:53.159]             base::sink(type = "output", split = FALSE)
[10:31:53.159]             base::close(...future.stdout)
[10:31:53.159]         }, add = TRUE)
[10:31:53.159]     }
[10:31:53.159]     ...future.frame <- base::sys.nframe()
[10:31:53.159]     ...future.conditions <- base::list()
[10:31:53.159]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:53.159]     if (FALSE) {
[10:31:53.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:53.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:53.159]     }
[10:31:53.159]     ...future.result <- base::tryCatch({
[10:31:53.159]         base::withCallingHandlers({
[10:31:53.159]             ...future.value <- base::withVisible(base::local({
[10:31:53.159]                 ...future.makeSendCondition <- base::local({
[10:31:53.159]                   sendCondition <- NULL
[10:31:53.159]                   function(frame = 1L) {
[10:31:53.159]                     if (is.function(sendCondition)) 
[10:31:53.159]                       return(sendCondition)
[10:31:53.159]                     ns <- getNamespace("parallel")
[10:31:53.159]                     if (exists("sendData", mode = "function", 
[10:31:53.159]                       envir = ns)) {
[10:31:53.159]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:53.159]                         envir = ns)
[10:31:53.159]                       envir <- sys.frame(frame)
[10:31:53.159]                       master <- NULL
[10:31:53.159]                       while (!identical(envir, .GlobalEnv) && 
[10:31:53.159]                         !identical(envir, emptyenv())) {
[10:31:53.159]                         if (exists("master", mode = "list", envir = envir, 
[10:31:53.159]                           inherits = FALSE)) {
[10:31:53.159]                           master <- get("master", mode = "list", 
[10:31:53.159]                             envir = envir, inherits = FALSE)
[10:31:53.159]                           if (inherits(master, c("SOCKnode", 
[10:31:53.159]                             "SOCK0node"))) {
[10:31:53.159]                             sendCondition <<- function(cond) {
[10:31:53.159]                               data <- list(type = "VALUE", value = cond, 
[10:31:53.159]                                 success = TRUE)
[10:31:53.159]                               parallel_sendData(master, data)
[10:31:53.159]                             }
[10:31:53.159]                             return(sendCondition)
[10:31:53.159]                           }
[10:31:53.159]                         }
[10:31:53.159]                         frame <- frame + 1L
[10:31:53.159]                         envir <- sys.frame(frame)
[10:31:53.159]                       }
[10:31:53.159]                     }
[10:31:53.159]                     sendCondition <<- function(cond) NULL
[10:31:53.159]                   }
[10:31:53.159]                 })
[10:31:53.159]                 withCallingHandlers({
[10:31:53.159]                   {
[10:31:53.159]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:53.159]                     if (!identical(...future.globals.maxSize.org, 
[10:31:53.159]                       ...future.globals.maxSize)) {
[10:31:53.159]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:53.159]                       on.exit(options(oopts), add = TRUE)
[10:31:53.159]                     }
[10:31:53.159]                     {
[10:31:53.159]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:53.159]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[10:31:53.159]                         USE.NAMES = FALSE)
[10:31:53.159]                       do.call(mapply, args = args)
[10:31:53.159]                     }
[10:31:53.159]                   }
[10:31:53.159]                 }, immediateCondition = function(cond) {
[10:31:53.159]                   sendCondition <- ...future.makeSendCondition()
[10:31:53.159]                   sendCondition(cond)
[10:31:53.159]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:53.159]                   {
[10:31:53.159]                     inherits <- base::inherits
[10:31:53.159]                     invokeRestart <- base::invokeRestart
[10:31:53.159]                     is.null <- base::is.null
[10:31:53.159]                     muffled <- FALSE
[10:31:53.159]                     if (inherits(cond, "message")) {
[10:31:53.159]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:53.159]                       if (muffled) 
[10:31:53.159]                         invokeRestart("muffleMessage")
[10:31:53.159]                     }
[10:31:53.159]                     else if (inherits(cond, "warning")) {
[10:31:53.159]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:53.159]                       if (muffled) 
[10:31:53.159]                         invokeRestart("muffleWarning")
[10:31:53.159]                     }
[10:31:53.159]                     else if (inherits(cond, "condition")) {
[10:31:53.159]                       if (!is.null(pattern)) {
[10:31:53.159]                         computeRestarts <- base::computeRestarts
[10:31:53.159]                         grepl <- base::grepl
[10:31:53.159]                         restarts <- computeRestarts(cond)
[10:31:53.159]                         for (restart in restarts) {
[10:31:53.159]                           name <- restart$name
[10:31:53.159]                           if (is.null(name)) 
[10:31:53.159]                             next
[10:31:53.159]                           if (!grepl(pattern, name)) 
[10:31:53.159]                             next
[10:31:53.159]                           invokeRestart(restart)
[10:31:53.159]                           muffled <- TRUE
[10:31:53.159]                           break
[10:31:53.159]                         }
[10:31:53.159]                       }
[10:31:53.159]                     }
[10:31:53.159]                     invisible(muffled)
[10:31:53.159]                   }
[10:31:53.159]                   muffleCondition(cond)
[10:31:53.159]                 })
[10:31:53.159]             }))
[10:31:53.159]             future::FutureResult(value = ...future.value$value, 
[10:31:53.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:53.159]                   ...future.rng), globalenv = if (FALSE) 
[10:31:53.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:53.159]                     ...future.globalenv.names))
[10:31:53.159]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:53.159]         }, condition = base::local({
[10:31:53.159]             c <- base::c
[10:31:53.159]             inherits <- base::inherits
[10:31:53.159]             invokeRestart <- base::invokeRestart
[10:31:53.159]             length <- base::length
[10:31:53.159]             list <- base::list
[10:31:53.159]             seq.int <- base::seq.int
[10:31:53.159]             signalCondition <- base::signalCondition
[10:31:53.159]             sys.calls <- base::sys.calls
[10:31:53.159]             `[[` <- base::`[[`
[10:31:53.159]             `+` <- base::`+`
[10:31:53.159]             `<<-` <- base::`<<-`
[10:31:53.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:53.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:53.159]                   3L)]
[10:31:53.159]             }
[10:31:53.159]             function(cond) {
[10:31:53.159]                 is_error <- inherits(cond, "error")
[10:31:53.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:53.159]                   NULL)
[10:31:53.159]                 if (is_error) {
[10:31:53.159]                   sessionInformation <- function() {
[10:31:53.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:53.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:53.159]                       search = base::search(), system = base::Sys.info())
[10:31:53.159]                   }
[10:31:53.159]                   ...future.conditions[[length(...future.conditions) + 
[10:31:53.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:53.159]                     cond$call), session = sessionInformation(), 
[10:31:53.159]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:53.159]                   signalCondition(cond)
[10:31:53.159]                 }
[10:31:53.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:53.159]                 "immediateCondition"))) {
[10:31:53.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:53.159]                   ...future.conditions[[length(...future.conditions) + 
[10:31:53.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:53.159]                   if (TRUE && !signal) {
[10:31:53.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:53.159]                     {
[10:31:53.159]                       inherits <- base::inherits
[10:31:53.159]                       invokeRestart <- base::invokeRestart
[10:31:53.159]                       is.null <- base::is.null
[10:31:53.159]                       muffled <- FALSE
[10:31:53.159]                       if (inherits(cond, "message")) {
[10:31:53.159]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:53.159]                         if (muffled) 
[10:31:53.159]                           invokeRestart("muffleMessage")
[10:31:53.159]                       }
[10:31:53.159]                       else if (inherits(cond, "warning")) {
[10:31:53.159]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:53.159]                         if (muffled) 
[10:31:53.159]                           invokeRestart("muffleWarning")
[10:31:53.159]                       }
[10:31:53.159]                       else if (inherits(cond, "condition")) {
[10:31:53.159]                         if (!is.null(pattern)) {
[10:31:53.159]                           computeRestarts <- base::computeRestarts
[10:31:53.159]                           grepl <- base::grepl
[10:31:53.159]                           restarts <- computeRestarts(cond)
[10:31:53.159]                           for (restart in restarts) {
[10:31:53.159]                             name <- restart$name
[10:31:53.159]                             if (is.null(name)) 
[10:31:53.159]                               next
[10:31:53.159]                             if (!grepl(pattern, name)) 
[10:31:53.159]                               next
[10:31:53.159]                             invokeRestart(restart)
[10:31:53.159]                             muffled <- TRUE
[10:31:53.159]                             break
[10:31:53.159]                           }
[10:31:53.159]                         }
[10:31:53.159]                       }
[10:31:53.159]                       invisible(muffled)
[10:31:53.159]                     }
[10:31:53.159]                     muffleCondition(cond, pattern = "^muffle")
[10:31:53.159]                   }
[10:31:53.159]                 }
[10:31:53.159]                 else {
[10:31:53.159]                   if (TRUE) {
[10:31:53.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:53.159]                     {
[10:31:53.159]                       inherits <- base::inherits
[10:31:53.159]                       invokeRestart <- base::invokeRestart
[10:31:53.159]                       is.null <- base::is.null
[10:31:53.159]                       muffled <- FALSE
[10:31:53.159]                       if (inherits(cond, "message")) {
[10:31:53.159]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:53.159]                         if (muffled) 
[10:31:53.159]                           invokeRestart("muffleMessage")
[10:31:53.159]                       }
[10:31:53.159]                       else if (inherits(cond, "warning")) {
[10:31:53.159]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:53.159]                         if (muffled) 
[10:31:53.159]                           invokeRestart("muffleWarning")
[10:31:53.159]                       }
[10:31:53.159]                       else if (inherits(cond, "condition")) {
[10:31:53.159]                         if (!is.null(pattern)) {
[10:31:53.159]                           computeRestarts <- base::computeRestarts
[10:31:53.159]                           grepl <- base::grepl
[10:31:53.159]                           restarts <- computeRestarts(cond)
[10:31:53.159]                           for (restart in restarts) {
[10:31:53.159]                             name <- restart$name
[10:31:53.159]                             if (is.null(name)) 
[10:31:53.159]                               next
[10:31:53.159]                             if (!grepl(pattern, name)) 
[10:31:53.159]                               next
[10:31:53.159]                             invokeRestart(restart)
[10:31:53.159]                             muffled <- TRUE
[10:31:53.159]                             break
[10:31:53.159]                           }
[10:31:53.159]                         }
[10:31:53.159]                       }
[10:31:53.159]                       invisible(muffled)
[10:31:53.159]                     }
[10:31:53.159]                     muffleCondition(cond, pattern = "^muffle")
[10:31:53.159]                   }
[10:31:53.159]                 }
[10:31:53.159]             }
[10:31:53.159]         }))
[10:31:53.159]     }, error = function(ex) {
[10:31:53.159]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:53.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:53.159]                 ...future.rng), started = ...future.startTime, 
[10:31:53.159]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:53.159]             version = "1.8"), class = "FutureResult")
[10:31:53.159]     }, finally = {
[10:31:53.159]         if (!identical(...future.workdir, getwd())) 
[10:31:53.159]             setwd(...future.workdir)
[10:31:53.159]         {
[10:31:53.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:53.159]                 ...future.oldOptions$nwarnings <- NULL
[10:31:53.159]             }
[10:31:53.159]             base::options(...future.oldOptions)
[10:31:53.159]             if (.Platform$OS.type == "windows") {
[10:31:53.159]                 old_names <- names(...future.oldEnvVars)
[10:31:53.159]                 envs <- base::Sys.getenv()
[10:31:53.159]                 names <- names(envs)
[10:31:53.159]                 common <- intersect(names, old_names)
[10:31:53.159]                 added <- setdiff(names, old_names)
[10:31:53.159]                 removed <- setdiff(old_names, names)
[10:31:53.159]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:53.159]                   envs[common]]
[10:31:53.159]                 NAMES <- toupper(changed)
[10:31:53.159]                 args <- list()
[10:31:53.159]                 for (kk in seq_along(NAMES)) {
[10:31:53.159]                   name <- changed[[kk]]
[10:31:53.159]                   NAME <- NAMES[[kk]]
[10:31:53.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:53.159]                     next
[10:31:53.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:53.159]                 }
[10:31:53.159]                 NAMES <- toupper(added)
[10:31:53.159]                 for (kk in seq_along(NAMES)) {
[10:31:53.159]                   name <- added[[kk]]
[10:31:53.159]                   NAME <- NAMES[[kk]]
[10:31:53.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:53.159]                     next
[10:31:53.159]                   args[[name]] <- ""
[10:31:53.159]                 }
[10:31:53.159]                 NAMES <- toupper(removed)
[10:31:53.159]                 for (kk in seq_along(NAMES)) {
[10:31:53.159]                   name <- removed[[kk]]
[10:31:53.159]                   NAME <- NAMES[[kk]]
[10:31:53.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:53.159]                     next
[10:31:53.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:53.159]                 }
[10:31:53.159]                 if (length(args) > 0) 
[10:31:53.159]                   base::do.call(base::Sys.setenv, args = args)
[10:31:53.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:53.159]             }
[10:31:53.159]             else {
[10:31:53.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:53.159]             }
[10:31:53.159]             {
[10:31:53.159]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:53.159]                   0L) {
[10:31:53.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:53.159]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:53.159]                   base::options(opts)
[10:31:53.159]                 }
[10:31:53.159]                 {
[10:31:53.159]                   {
[10:31:53.159]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:53.159]                     NULL
[10:31:53.159]                   }
[10:31:53.159]                   options(future.plan = NULL)
[10:31:53.159]                   if (is.na(NA_character_)) 
[10:31:53.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:53.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:53.159]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:53.159]                     .init = FALSE)
[10:31:53.159]                 }
[10:31:53.159]             }
[10:31:53.159]         }
[10:31:53.159]     })
[10:31:53.159]     if (FALSE) {
[10:31:53.159]         base::sink(type = "output", split = FALSE)
[10:31:53.159]         if (NA) {
[10:31:53.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:53.159]         }
[10:31:53.159]         else {
[10:31:53.159]             ...future.result["stdout"] <- base::list(NULL)
[10:31:53.159]         }
[10:31:53.159]         base::close(...future.stdout)
[10:31:53.159]         ...future.stdout <- NULL
[10:31:53.159]     }
[10:31:53.159]     ...future.result$conditions <- ...future.conditions
[10:31:53.159]     ...future.result$finished <- base::Sys.time()
[10:31:53.159]     ...future.result
[10:31:53.159] }
[10:31:53.162] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[10:31:53.162] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[10:31:53.162] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[10:31:53.162] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[10:31:53.162] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[10:31:53.163] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:31:53.163] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:31:53.163] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:53.163] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:53.163] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:53.164] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:53.164] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[10:31:53.164] MultisessionFuture started
[10:31:53.164] - Launch lazy future ... done
[10:31:53.165] run() for ‘MultisessionFuture’ ... done
[10:31:53.165] Created future:
[10:31:53.165] MultisessionFuture:
[10:31:53.165] Label: ‘future_mapply-2’
[10:31:53.165] Expression:
[10:31:53.165] {
[10:31:53.165]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:53.165]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:53.165]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:53.165]         on.exit(options(oopts), add = TRUE)
[10:31:53.165]     }
[10:31:53.165]     {
[10:31:53.165]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[10:31:53.165]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[10:31:53.165]         do.call(mapply, args = args)
[10:31:53.165]     }
[10:31:53.165] }
[10:31:53.165] Lazy evaluation: FALSE
[10:31:53.165] Asynchronous evaluation: TRUE
[10:31:53.165] Local evaluation: TRUE
[10:31:53.165] Environment: R_GlobalEnv
[10:31:53.165] Capture standard output: NA
[10:31:53.165] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:53.165] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:53.165] Packages: <none>
[10:31:53.165] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:53.165] Resolved: FALSE
[10:31:53.165] Value: <not collected>
[10:31:53.165] Conditions captured: <none>
[10:31:53.165] Early signaling: FALSE
[10:31:53.165] Owner process: ef1c7aa9-0b35-76d6-a9b4-452d6c596e5f
[10:31:53.165] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:53.176] Chunk #2 of 2 ... DONE
[10:31:53.176] Launching 2 futures (chunks) ... DONE
[10:31:53.177] Resolving 2 futures (chunks) ...
[10:31:53.177] resolve() on list ...
[10:31:53.177]  recursive: 0
[10:31:53.177]  length: 2
[10:31:53.177] 
[10:31:53.219] receiveMessageFromWorker() for ClusterFuture ...
[10:31:53.219] - Validating connection of MultisessionFuture
[10:31:53.220] - received message: FutureResult
[10:31:53.220] - Received FutureResult
[10:31:53.220] - Erased future from FutureRegistry
[10:31:53.220] result() for ClusterFuture ...
[10:31:53.220] - result already collected: FutureResult
[10:31:53.220] result() for ClusterFuture ... done
[10:31:53.220] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:53.220] Future #2
[10:31:53.220] result() for ClusterFuture ...
[10:31:53.221] - result already collected: FutureResult
[10:31:53.221] result() for ClusterFuture ... done
[10:31:53.221] result() for ClusterFuture ...
[10:31:53.221] - result already collected: FutureResult
[10:31:53.221] result() for ClusterFuture ... done
[10:31:53.221] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:53.221] - nx: 2
[10:31:53.221] - relay: TRUE
[10:31:53.221] - stdout: TRUE
[10:31:53.221] - signal: TRUE
[10:31:53.222] - resignal: FALSE
[10:31:53.222] - force: TRUE
[10:31:53.222] - relayed: [n=2] FALSE, FALSE
[10:31:53.222] - queued futures: [n=2] FALSE, FALSE
[10:31:53.222]  - until=1
[10:31:53.222]  - relaying element #1
[10:31:53.222] - relayed: [n=2] FALSE, FALSE
[10:31:53.222] - queued futures: [n=2] FALSE, TRUE
[10:31:53.222] signalConditionsASAP(NULL, pos=2) ... done
[10:31:53.222]  length: 1 (resolved future 2)
[10:31:53.672] receiveMessageFromWorker() for ClusterFuture ...
[10:31:53.672] - Validating connection of MultisessionFuture
[10:31:53.672] - received message: FutureResult
[10:31:53.672] - Received FutureResult
[10:31:53.672] - Erased future from FutureRegistry
[10:31:53.672] result() for ClusterFuture ...
[10:31:53.672] - result already collected: FutureResult
[10:31:53.672] result() for ClusterFuture ... done
[10:31:53.673] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:53.673] Future #1
[10:31:53.673] result() for ClusterFuture ...
[10:31:53.673] - result already collected: FutureResult
[10:31:53.673] result() for ClusterFuture ... done
[10:31:53.673] result() for ClusterFuture ...
[10:31:53.673] - result already collected: FutureResult
[10:31:53.673] result() for ClusterFuture ... done
[10:31:53.673] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:53.673] - nx: 2
[10:31:53.674] - relay: TRUE
[10:31:53.674] - stdout: TRUE
[10:31:53.674] - signal: TRUE
[10:31:53.674] - resignal: FALSE
[10:31:53.674] - force: TRUE
[10:31:53.674] - relayed: [n=2] FALSE, FALSE
[10:31:53.674] - queued futures: [n=2] FALSE, TRUE
[10:31:53.674]  - until=1
[10:31:53.674]  - relaying element #1
[10:31:53.674] result() for ClusterFuture ...
[10:31:53.674] - result already collected: FutureResult
[10:31:53.674] result() for ClusterFuture ... done
[10:31:53.675] result() for ClusterFuture ...
[10:31:53.675] - result already collected: FutureResult
[10:31:53.675] result() for ClusterFuture ... done
[10:31:53.675] result() for ClusterFuture ...
[10:31:53.675] - result already collected: FutureResult
[10:31:53.675] result() for ClusterFuture ... done
[10:31:53.675] result() for ClusterFuture ...
[10:31:53.675] - result already collected: FutureResult
[10:31:53.675] result() for ClusterFuture ... done
[10:31:53.675] - relayed: [n=2] TRUE, FALSE
[10:31:53.675] - queued futures: [n=2] TRUE, TRUE
[10:31:53.676] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:53.676]  length: 0 (resolved future 1)
[10:31:53.676] Relaying remaining futures
[10:31:53.676] signalConditionsASAP(NULL, pos=0) ...
[10:31:53.676] - nx: 2
[10:31:53.676] - relay: TRUE
[10:31:53.676] - stdout: TRUE
[10:31:53.676] - signal: TRUE
[10:31:53.676] - resignal: FALSE
[10:31:53.676] - force: TRUE
[10:31:53.676] - relayed: [n=2] TRUE, FALSE
[10:31:53.676] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:53.677]  - relaying element #2
[10:31:53.677] result() for ClusterFuture ...
[10:31:53.677] - result already collected: FutureResult
[10:31:53.677] result() for ClusterFuture ... done
[10:31:53.677] result() for ClusterFuture ...
[10:31:53.677] - result already collected: FutureResult
[10:31:53.677] result() for ClusterFuture ... done
[10:31:53.677] result() for ClusterFuture ...
[10:31:53.677] - result already collected: FutureResult
[10:31:53.677] result() for ClusterFuture ... done
[10:31:53.677] result() for ClusterFuture ...
[10:31:53.678] - result already collected: FutureResult
[10:31:53.678] result() for ClusterFuture ... done
[10:31:53.678] - relayed: [n=2] TRUE, TRUE
[10:31:53.678] - queued futures: [n=2] TRUE, TRUE
[10:31:53.678] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[10:31:53.678] resolve() on list ... DONE
[10:31:53.678] result() for ClusterFuture ...
[10:31:53.678] - result already collected: FutureResult
[10:31:53.678] result() for ClusterFuture ... done
[10:31:53.678] result() for ClusterFuture ...
[10:31:53.678] - result already collected: FutureResult
[10:31:53.678] result() for ClusterFuture ... done
[10:31:53.679] result() for ClusterFuture ...
[10:31:53.679] - result already collected: FutureResult
[10:31:53.679] result() for ClusterFuture ... done
[10:31:53.679] result() for ClusterFuture ...
[10:31:53.679] - result already collected: FutureResult
[10:31:53.679] result() for ClusterFuture ... done
[10:31:53.679]  - Number of value chunks collected: 2
[10:31:53.679] Resolving 2 futures (chunks) ... DONE
[10:31:53.679] Reducing values from 2 chunks ...
[10:31:53.679]  - Number of values collected after concatenation: 2
[10:31:53.679]  - Number of values expected: 2
[10:31:53.680] Reducing values from 2 chunks ... DONE
[10:31:53.680] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[10:31:53.681] plan(): Setting new future strategy stack:
[10:31:53.681] List of future strategies:
[10:31:53.681] 1. FutureStrategy:
[10:31:53.681]    - args: function (..., envir = parent.frame())
[10:31:53.681]    - tweaked: FALSE
[10:31:53.681]    - call: future::plan(oplan)
[10:31:53.682] plan(): nbrOfWorkers() = 1
> 
