
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[16:19:26.909] plan(): Setting new future strategy stack:
[16:19:26.909] List of future strategies:
[16:19:26.909] 1. sequential:
[16:19:26.909]    - args: function (..., envir = parent.frame())
[16:19:26.909]    - tweaked: FALSE
[16:19:26.909]    - call: future::plan("sequential")
[16:19:26.924] plan(): nbrOfWorkers() = 1
> 
> message("*** future_*apply() and 'future.stdout' ...")
*** future_*apply() and 'future.stdout' ...
> 
> options(future.debug = TRUE)
> 
> truth <- list()
> 
> out <- utils::capture.output({
+   y <- lapply(1:0, FUN = function(x) {
+     print(x)
+   })
+ })
> truth[["lapply"]] <- list(value = y, stdout = out)
> 
> out <- utils::capture.output({
+   y <- mapply(1:0, 0:1, FUN = function(x, y) {
+     print(list(x = x, y = y))
+   })
+ })
> truth[["mapply"]] <- list(value = y, stdout = out)
> 
> for (cores in 1:availCores) {
+   message(sprintf("  - Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+   
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("* plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     for (fun in names(truth)) {
+       for (stdout in c(FALSE, TRUE, NA)) {
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ...", fun, stdout))
+   
+         out <- utils::capture.output({
+           if (fun == "lapply") {
+             y <- future_lapply(1:0, FUN = function(x) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+ 	      print(x)
+             }, future.stdout = stdout)
+ 	  } else if (fun == "mapply") {
+             y <- future_mapply(1:0, 0:1, FUN = function(x, y) {
+               Sys.sleep(x / 2)  ## make futures resolve out of order
+               print(list(x = x, y = y))
+             }, future.stdout = stdout)
+ 	  }
+         })
+         stopifnot(identical(y, truth[[fun]]$value))
+   
+         if (isTRUE(stdout)) {
+           stopifnot(identical(out, truth[[fun]]$stdout))
+         } else if (is.na(stdout)) {
+         } else {
+           stopifnot(nchar(out) == 0)
+         }
+       
+         message(sprintf("* future_%s(x, ..., future.stdout = %s) ... DONE", fun, stdout))
+       } ## for (stdout ...)
+     } ## for (fun ...)
+     
+     message(sprintf("* plan('%s') ... DONE", strategy))
+   }
+   
+   message(sprintf("  - Testing with %d cores ... DONE", cores))
+ }
  - Testing with 1 cores ...
* plan('sequential') ...
[16:19:26.959] plan(): Setting new future strategy stack:
[16:19:26.959] List of future strategies:
[16:19:26.959] 1. sequential:
[16:19:26.959]    - args: function (..., envir = parent.frame())
[16:19:26.959]    - tweaked: FALSE
[16:19:26.959]    - call: plan(strategy)
[16:19:26.970] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:19:26.970] future_lapply() ...
[16:19:26.975] Number of chunks: 1
[16:19:26.975] getGlobalsAndPackagesXApply() ...
[16:19:26.975]  - future.globals: TRUE
[16:19:26.976] getGlobalsAndPackages() ...
[16:19:26.976] Searching for globals...
[16:19:26.978] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:26.979] Searching for globals ... DONE
[16:19:26.979] Resolving globals: FALSE
[16:19:26.980] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:26.980] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:26.981] - globals: [1] ‘FUN’
[16:19:26.981] 
[16:19:26.981] getGlobalsAndPackages() ... DONE
[16:19:26.981]  - globals found/used: [n=1] ‘FUN’
[16:19:26.981]  - needed namespaces: [n=0] 
[16:19:26.981] Finding globals ... DONE
[16:19:26.981]  - use_args: TRUE
[16:19:26.981]  - Getting '...' globals ...
[16:19:26.982] resolve() on list ...
[16:19:26.982]  recursive: 0
[16:19:26.982]  length: 1
[16:19:26.983]  elements: ‘...’
[16:19:26.983]  length: 0 (resolved future 1)
[16:19:26.983] resolve() on list ... DONE
[16:19:26.983]    - '...' content: [n=0] 
[16:19:26.983] List of 1
[16:19:26.983]  $ ...: list()
[16:19:26.983]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:26.983]  - attr(*, "where")=List of 1
[16:19:26.983]   ..$ ...:<environment: 0x563562b087a8> 
[16:19:26.983]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:26.983]  - attr(*, "resolved")= logi TRUE
[16:19:26.983]  - attr(*, "total_size")= num NA
[16:19:26.990]  - Getting '...' globals ... DONE
[16:19:26.991] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:26.991] List of 2
[16:19:26.991]  $ ...future.FUN:function (x)  
[16:19:26.991]  $ ...          : list()
[16:19:26.991]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:26.991]  - attr(*, "where")=List of 2
[16:19:26.991]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:26.991]   ..$ ...          :<environment: 0x563562b087a8> 
[16:19:26.991]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:26.991]  - attr(*, "resolved")= logi FALSE
[16:19:26.991]  - attr(*, "total_size")= num 4720
[16:19:26.994] Packages to be attached in all futures: [n=0] 
[16:19:26.994] getGlobalsAndPackagesXApply() ... DONE
[16:19:26.994] Number of futures (= number of chunks): 1
[16:19:26.994] Launching 1 futures (chunks) ...
[16:19:26.994] Chunk #1 of 1 ...
[16:19:26.995]  - Finding globals in 'X' for chunk #1 ...
[16:19:26.995] getGlobalsAndPackages() ...
[16:19:26.995] Searching for globals...
[16:19:26.995] 
[16:19:26.995] Searching for globals ... DONE
[16:19:26.995] - globals: [0] <none>
[16:19:26.995] getGlobalsAndPackages() ... DONE
[16:19:26.995]    + additional globals found: [n=0] 
[16:19:26.996]    + additional namespaces needed: [n=0] 
[16:19:26.996]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:26.996]  - seeds: <none>
[16:19:26.996]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:26.996] getGlobalsAndPackages() ...
[16:19:26.996] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:26.996] Resolving globals: FALSE
[16:19:26.996] Tweak future expression to call with '...' arguments ...
[16:19:26.997] {
[16:19:26.997]     do.call(function(...) {
[16:19:26.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:26.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:26.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:26.997]             on.exit(options(oopts), add = TRUE)
[16:19:26.997]         }
[16:19:26.997]         {
[16:19:26.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:26.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:26.997]                 ...future.FUN(...future.X_jj, ...)
[16:19:26.997]             })
[16:19:26.997]         }
[16:19:26.997]     }, args = future.call.arguments)
[16:19:26.997] }
[16:19:26.997] Tweak future expression to call with '...' arguments ... DONE
[16:19:26.997] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:26.997] 
[16:19:26.997] getGlobalsAndPackages() ... DONE
[16:19:26.998] run() for ‘Future’ ...
[16:19:26.998] - state: ‘created’
[16:19:26.999] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:26.999] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:26.999] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:26.999]   - Field: ‘label’
[16:19:26.999]   - Field: ‘local’
[16:19:26.999]   - Field: ‘owner’
[16:19:26.999]   - Field: ‘envir’
[16:19:27.000]   - Field: ‘packages’
[16:19:27.000]   - Field: ‘gc’
[16:19:27.000]   - Field: ‘conditions’
[16:19:27.000]   - Field: ‘expr’
[16:19:27.000]   - Field: ‘uuid’
[16:19:27.000]   - Field: ‘seed’
[16:19:27.000]   - Field: ‘version’
[16:19:27.000]   - Field: ‘result’
[16:19:27.000]   - Field: ‘asynchronous’
[16:19:27.000]   - Field: ‘calls’
[16:19:27.000]   - Field: ‘globals’
[16:19:27.001]   - Field: ‘stdout’
[16:19:27.001]   - Field: ‘earlySignal’
[16:19:27.001]   - Field: ‘lazy’
[16:19:27.001]   - Field: ‘state’
[16:19:27.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:27.001] - Launch lazy future ...
[16:19:27.002] Packages needed by the future expression (n = 0): <none>
[16:19:27.002] Packages needed by future strategies (n = 0): <none>
[16:19:27.003] {
[16:19:27.003]     {
[16:19:27.003]         {
[16:19:27.003]             ...future.startTime <- base::Sys.time()
[16:19:27.003]             {
[16:19:27.003]                 {
[16:19:27.003]                   {
[16:19:27.003]                     base::local({
[16:19:27.003]                       has_future <- base::requireNamespace("future", 
[16:19:27.003]                         quietly = TRUE)
[16:19:27.003]                       if (has_future) {
[16:19:27.003]                         ns <- base::getNamespace("future")
[16:19:27.003]                         version <- ns[[".package"]][["version"]]
[16:19:27.003]                         if (is.null(version)) 
[16:19:27.003]                           version <- utils::packageVersion("future")
[16:19:27.003]                       }
[16:19:27.003]                       else {
[16:19:27.003]                         version <- NULL
[16:19:27.003]                       }
[16:19:27.003]                       if (!has_future || version < "1.8.0") {
[16:19:27.003]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:27.003]                           "", base::R.version$version.string), 
[16:19:27.003]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:27.003]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:27.003]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:27.003]                             "release", "version")], collapse = " "), 
[16:19:27.003]                           hostname = base::Sys.info()[["nodename"]])
[16:19:27.003]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:27.003]                           info)
[16:19:27.003]                         info <- base::paste(info, collapse = "; ")
[16:19:27.003]                         if (!has_future) {
[16:19:27.003]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:27.003]                             info)
[16:19:27.003]                         }
[16:19:27.003]                         else {
[16:19:27.003]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:27.003]                             info, version)
[16:19:27.003]                         }
[16:19:27.003]                         base::stop(msg)
[16:19:27.003]                       }
[16:19:27.003]                     })
[16:19:27.003]                   }
[16:19:27.003]                   ...future.strategy.old <- future::plan("list")
[16:19:27.003]                   options(future.plan = NULL)
[16:19:27.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:27.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:27.003]                 }
[16:19:27.003]                 ...future.workdir <- getwd()
[16:19:27.003]             }
[16:19:27.003]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:27.003]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:27.003]         }
[16:19:27.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:27.003]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:27.003]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:27.003]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:27.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:27.003]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:27.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:27.003]             base::names(...future.oldOptions))
[16:19:27.003]     }
[16:19:27.003]     if (FALSE) {
[16:19:27.003]     }
[16:19:27.003]     else {
[16:19:27.003]         if (FALSE) {
[16:19:27.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:27.003]                 open = "w")
[16:19:27.003]         }
[16:19:27.003]         else {
[16:19:27.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:27.003]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:27.003]         }
[16:19:27.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:27.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:27.003]             base::sink(type = "output", split = FALSE)
[16:19:27.003]             base::close(...future.stdout)
[16:19:27.003]         }, add = TRUE)
[16:19:27.003]     }
[16:19:27.003]     ...future.frame <- base::sys.nframe()
[16:19:27.003]     ...future.conditions <- base::list()
[16:19:27.003]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:27.003]     if (FALSE) {
[16:19:27.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:27.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:27.003]     }
[16:19:27.003]     ...future.result <- base::tryCatch({
[16:19:27.003]         base::withCallingHandlers({
[16:19:27.003]             ...future.value <- base::withVisible(base::local({
[16:19:27.003]                 do.call(function(...) {
[16:19:27.003]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:27.003]                   if (!identical(...future.globals.maxSize.org, 
[16:19:27.003]                     ...future.globals.maxSize)) {
[16:19:27.003]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:27.003]                     on.exit(options(oopts), add = TRUE)
[16:19:27.003]                   }
[16:19:27.003]                   {
[16:19:27.003]                     lapply(seq_along(...future.elements_ii), 
[16:19:27.003]                       FUN = function(jj) {
[16:19:27.003]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:27.003]                         ...future.FUN(...future.X_jj, ...)
[16:19:27.003]                       })
[16:19:27.003]                   }
[16:19:27.003]                 }, args = future.call.arguments)
[16:19:27.003]             }))
[16:19:27.003]             future::FutureResult(value = ...future.value$value, 
[16:19:27.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:27.003]                   ...future.rng), globalenv = if (FALSE) 
[16:19:27.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:27.003]                     ...future.globalenv.names))
[16:19:27.003]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:27.003]         }, condition = base::local({
[16:19:27.003]             c <- base::c
[16:19:27.003]             inherits <- base::inherits
[16:19:27.003]             invokeRestart <- base::invokeRestart
[16:19:27.003]             length <- base::length
[16:19:27.003]             list <- base::list
[16:19:27.003]             seq.int <- base::seq.int
[16:19:27.003]             signalCondition <- base::signalCondition
[16:19:27.003]             sys.calls <- base::sys.calls
[16:19:27.003]             `[[` <- base::`[[`
[16:19:27.003]             `+` <- base::`+`
[16:19:27.003]             `<<-` <- base::`<<-`
[16:19:27.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:27.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:27.003]                   3L)]
[16:19:27.003]             }
[16:19:27.003]             function(cond) {
[16:19:27.003]                 is_error <- inherits(cond, "error")
[16:19:27.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:27.003]                   NULL)
[16:19:27.003]                 if (is_error) {
[16:19:27.003]                   sessionInformation <- function() {
[16:19:27.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:27.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:27.003]                       search = base::search(), system = base::Sys.info())
[16:19:27.003]                   }
[16:19:27.003]                   ...future.conditions[[length(...future.conditions) + 
[16:19:27.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:27.003]                     cond$call), session = sessionInformation(), 
[16:19:27.003]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:27.003]                   signalCondition(cond)
[16:19:27.003]                 }
[16:19:27.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:27.003]                 "immediateCondition"))) {
[16:19:27.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:27.003]                   ...future.conditions[[length(...future.conditions) + 
[16:19:27.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:27.003]                   if (TRUE && !signal) {
[16:19:27.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:27.003]                     {
[16:19:27.003]                       inherits <- base::inherits
[16:19:27.003]                       invokeRestart <- base::invokeRestart
[16:19:27.003]                       is.null <- base::is.null
[16:19:27.003]                       muffled <- FALSE
[16:19:27.003]                       if (inherits(cond, "message")) {
[16:19:27.003]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:27.003]                         if (muffled) 
[16:19:27.003]                           invokeRestart("muffleMessage")
[16:19:27.003]                       }
[16:19:27.003]                       else if (inherits(cond, "warning")) {
[16:19:27.003]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:27.003]                         if (muffled) 
[16:19:27.003]                           invokeRestart("muffleWarning")
[16:19:27.003]                       }
[16:19:27.003]                       else if (inherits(cond, "condition")) {
[16:19:27.003]                         if (!is.null(pattern)) {
[16:19:27.003]                           computeRestarts <- base::computeRestarts
[16:19:27.003]                           grepl <- base::grepl
[16:19:27.003]                           restarts <- computeRestarts(cond)
[16:19:27.003]                           for (restart in restarts) {
[16:19:27.003]                             name <- restart$name
[16:19:27.003]                             if (is.null(name)) 
[16:19:27.003]                               next
[16:19:27.003]                             if (!grepl(pattern, name)) 
[16:19:27.003]                               next
[16:19:27.003]                             invokeRestart(restart)
[16:19:27.003]                             muffled <- TRUE
[16:19:27.003]                             break
[16:19:27.003]                           }
[16:19:27.003]                         }
[16:19:27.003]                       }
[16:19:27.003]                       invisible(muffled)
[16:19:27.003]                     }
[16:19:27.003]                     muffleCondition(cond, pattern = "^muffle")
[16:19:27.003]                   }
[16:19:27.003]                 }
[16:19:27.003]                 else {
[16:19:27.003]                   if (TRUE) {
[16:19:27.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:27.003]                     {
[16:19:27.003]                       inherits <- base::inherits
[16:19:27.003]                       invokeRestart <- base::invokeRestart
[16:19:27.003]                       is.null <- base::is.null
[16:19:27.003]                       muffled <- FALSE
[16:19:27.003]                       if (inherits(cond, "message")) {
[16:19:27.003]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:27.003]                         if (muffled) 
[16:19:27.003]                           invokeRestart("muffleMessage")
[16:19:27.003]                       }
[16:19:27.003]                       else if (inherits(cond, "warning")) {
[16:19:27.003]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:27.003]                         if (muffled) 
[16:19:27.003]                           invokeRestart("muffleWarning")
[16:19:27.003]                       }
[16:19:27.003]                       else if (inherits(cond, "condition")) {
[16:19:27.003]                         if (!is.null(pattern)) {
[16:19:27.003]                           computeRestarts <- base::computeRestarts
[16:19:27.003]                           grepl <- base::grepl
[16:19:27.003]                           restarts <- computeRestarts(cond)
[16:19:27.003]                           for (restart in restarts) {
[16:19:27.003]                             name <- restart$name
[16:19:27.003]                             if (is.null(name)) 
[16:19:27.003]                               next
[16:19:27.003]                             if (!grepl(pattern, name)) 
[16:19:27.003]                               next
[16:19:27.003]                             invokeRestart(restart)
[16:19:27.003]                             muffled <- TRUE
[16:19:27.003]                             break
[16:19:27.003]                           }
[16:19:27.003]                         }
[16:19:27.003]                       }
[16:19:27.003]                       invisible(muffled)
[16:19:27.003]                     }
[16:19:27.003]                     muffleCondition(cond, pattern = "^muffle")
[16:19:27.003]                   }
[16:19:27.003]                 }
[16:19:27.003]             }
[16:19:27.003]         }))
[16:19:27.003]     }, error = function(ex) {
[16:19:27.003]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:27.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:27.003]                 ...future.rng), started = ...future.startTime, 
[16:19:27.003]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:27.003]             version = "1.8"), class = "FutureResult")
[16:19:27.003]     }, finally = {
[16:19:27.003]         if (!identical(...future.workdir, getwd())) 
[16:19:27.003]             setwd(...future.workdir)
[16:19:27.003]         {
[16:19:27.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:27.003]                 ...future.oldOptions$nwarnings <- NULL
[16:19:27.003]             }
[16:19:27.003]             base::options(...future.oldOptions)
[16:19:27.003]             if (.Platform$OS.type == "windows") {
[16:19:27.003]                 old_names <- names(...future.oldEnvVars)
[16:19:27.003]                 envs <- base::Sys.getenv()
[16:19:27.003]                 names <- names(envs)
[16:19:27.003]                 common <- intersect(names, old_names)
[16:19:27.003]                 added <- setdiff(names, old_names)
[16:19:27.003]                 removed <- setdiff(old_names, names)
[16:19:27.003]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:27.003]                   envs[common]]
[16:19:27.003]                 NAMES <- toupper(changed)
[16:19:27.003]                 args <- list()
[16:19:27.003]                 for (kk in seq_along(NAMES)) {
[16:19:27.003]                   name <- changed[[kk]]
[16:19:27.003]                   NAME <- NAMES[[kk]]
[16:19:27.003]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:27.003]                     next
[16:19:27.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:27.003]                 }
[16:19:27.003]                 NAMES <- toupper(added)
[16:19:27.003]                 for (kk in seq_along(NAMES)) {
[16:19:27.003]                   name <- added[[kk]]
[16:19:27.003]                   NAME <- NAMES[[kk]]
[16:19:27.003]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:27.003]                     next
[16:19:27.003]                   args[[name]] <- ""
[16:19:27.003]                 }
[16:19:27.003]                 NAMES <- toupper(removed)
[16:19:27.003]                 for (kk in seq_along(NAMES)) {
[16:19:27.003]                   name <- removed[[kk]]
[16:19:27.003]                   NAME <- NAMES[[kk]]
[16:19:27.003]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:27.003]                     next
[16:19:27.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:27.003]                 }
[16:19:27.003]                 if (length(args) > 0) 
[16:19:27.003]                   base::do.call(base::Sys.setenv, args = args)
[16:19:27.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:27.003]             }
[16:19:27.003]             else {
[16:19:27.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:27.003]             }
[16:19:27.003]             {
[16:19:27.003]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:27.003]                   0L) {
[16:19:27.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:27.003]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:27.003]                   base::options(opts)
[16:19:27.003]                 }
[16:19:27.003]                 {
[16:19:27.003]                   {
[16:19:27.003]                     NULL
[16:19:27.003]                     RNGkind("Mersenne-Twister")
[16:19:27.003]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:27.003]                       inherits = FALSE)
[16:19:27.003]                   }
[16:19:27.003]                   options(future.plan = NULL)
[16:19:27.003]                   if (is.na(NA_character_)) 
[16:19:27.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:27.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:27.003]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:27.003]                     .init = FALSE)
[16:19:27.003]                 }
[16:19:27.003]             }
[16:19:27.003]         }
[16:19:27.003]     })
[16:19:27.003]     if (TRUE) {
[16:19:27.003]         base::sink(type = "output", split = FALSE)
[16:19:27.003]         if (FALSE) {
[16:19:27.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:27.003]         }
[16:19:27.003]         else {
[16:19:27.003]             ...future.result["stdout"] <- base::list(NULL)
[16:19:27.003]         }
[16:19:27.003]         base::close(...future.stdout)
[16:19:27.003]         ...future.stdout <- NULL
[16:19:27.003]     }
[16:19:27.003]     ...future.result$conditions <- ...future.conditions
[16:19:27.003]     ...future.result$finished <- base::Sys.time()
[16:19:27.003]     ...future.result
[16:19:27.003] }
[16:19:27.005] assign_globals() ...
[16:19:27.005] List of 5
[16:19:27.005]  $ ...future.FUN            :function (x)  
[16:19:27.005]  $ future.call.arguments    : list()
[16:19:27.005]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:27.005]  $ ...future.elements_ii    :List of 2
[16:19:27.005]   ..$ : int 1
[16:19:27.005]   ..$ : int 0
[16:19:27.005]  $ ...future.seeds_ii       : NULL
[16:19:27.005]  $ ...future.globals.maxSize: NULL
[16:19:27.005]  - attr(*, "where")=List of 5
[16:19:27.005]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:27.005]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:27.005]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:27.005]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:27.005]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:27.005]  - attr(*, "resolved")= logi FALSE
[16:19:27.005]  - attr(*, "total_size")= num 4720
[16:19:27.005]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:27.005]  - attr(*, "already-done")= logi TRUE
[16:19:27.010] - reassign environment for ‘...future.FUN’
[16:19:27.010] - copied ‘...future.FUN’ to environment
[16:19:27.010] - copied ‘future.call.arguments’ to environment
[16:19:27.010] - copied ‘...future.elements_ii’ to environment
[16:19:27.010] - copied ‘...future.seeds_ii’ to environment
[16:19:27.010] - copied ‘...future.globals.maxSize’ to environment
[16:19:27.010] assign_globals() ... done
[16:19:27.011] plan(): Setting new future strategy stack:
[16:19:27.011] List of future strategies:
[16:19:27.011] 1. sequential:
[16:19:27.011]    - args: function (..., envir = parent.frame())
[16:19:27.011]    - tweaked: FALSE
[16:19:27.011]    - call: NULL
[16:19:27.011] plan(): nbrOfWorkers() = 1
[16:19:27.513] plan(): Setting new future strategy stack:
[16:19:27.514] List of future strategies:
[16:19:27.514] 1. sequential:
[16:19:27.514]    - args: function (..., envir = parent.frame())
[16:19:27.514]    - tweaked: FALSE
[16:19:27.514]    - call: plan(strategy)
[16:19:27.514] plan(): nbrOfWorkers() = 1
[16:19:27.514] SequentialFuture started (and completed)
[16:19:27.515] - Launch lazy future ... done
[16:19:27.515] run() for ‘SequentialFuture’ ... done
[16:19:27.515] Created future:
[16:19:27.515] SequentialFuture:
[16:19:27.515] Label: ‘future_lapply-1’
[16:19:27.515] Expression:
[16:19:27.515] {
[16:19:27.515]     do.call(function(...) {
[16:19:27.515]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:27.515]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:27.515]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:27.515]             on.exit(options(oopts), add = TRUE)
[16:19:27.515]         }
[16:19:27.515]         {
[16:19:27.515]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:27.515]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:27.515]                 ...future.FUN(...future.X_jj, ...)
[16:19:27.515]             })
[16:19:27.515]         }
[16:19:27.515]     }, args = future.call.arguments)
[16:19:27.515] }
[16:19:27.515] Lazy evaluation: FALSE
[16:19:27.515] Asynchronous evaluation: FALSE
[16:19:27.515] Local evaluation: TRUE
[16:19:27.515] Environment: R_GlobalEnv
[16:19:27.515] Capture standard output: FALSE
[16:19:27.515] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:27.515] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:27.515] Packages: <none>
[16:19:27.515] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:27.515] Resolved: TRUE
[16:19:27.515] Value: 112 bytes of class ‘list’
[16:19:27.515] Early signaling: FALSE
[16:19:27.515] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:27.515] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:27.517] Chunk #1 of 1 ... DONE
[16:19:27.517] Launching 1 futures (chunks) ... DONE
[16:19:27.517] Resolving 1 futures (chunks) ...
[16:19:27.517] resolve() on list ...
[16:19:27.517]  recursive: 0
[16:19:27.517]  length: 1
[16:19:27.518] 
[16:19:27.518] resolved() for ‘SequentialFuture’ ...
[16:19:27.518] - state: ‘finished’
[16:19:27.518] - run: TRUE
[16:19:27.518] - result: ‘FutureResult’
[16:19:27.518] resolved() for ‘SequentialFuture’ ... done
[16:19:27.518] Future #1
[16:19:27.519] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:27.519] - nx: 1
[16:19:27.519] - relay: TRUE
[16:19:27.519] - stdout: TRUE
[16:19:27.519] - signal: TRUE
[16:19:27.519] - resignal: FALSE
[16:19:27.519] - force: TRUE
[16:19:27.519] - relayed: [n=1] FALSE
[16:19:27.519] - queued futures: [n=1] FALSE
[16:19:27.519]  - until=1
[16:19:27.520]  - relaying element #1
[16:19:27.520] - relayed: [n=1] TRUE
[16:19:27.520] - queued futures: [n=1] TRUE
[16:19:27.520] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:27.520]  length: 0 (resolved future 1)
[16:19:27.522] Relaying remaining futures
[16:19:27.522] signalConditionsASAP(NULL, pos=0) ...
[16:19:27.523] - nx: 1
[16:19:27.523] - relay: TRUE
[16:19:27.523] - stdout: TRUE
[16:19:27.523] - signal: TRUE
[16:19:27.523] - resignal: FALSE
[16:19:27.523] - force: TRUE
[16:19:27.523] - relayed: [n=1] TRUE
[16:19:27.523] - queued futures: [n=1] TRUE
 - flush all
[16:19:27.523] - relayed: [n=1] TRUE
[16:19:27.523] - queued futures: [n=1] TRUE
[16:19:27.523] signalConditionsASAP(NULL, pos=0) ... done
[16:19:27.524] resolve() on list ... DONE
[16:19:27.524]  - Number of value chunks collected: 1
[16:19:27.524] Resolving 1 futures (chunks) ... DONE
[16:19:27.524] Reducing values from 1 chunks ...
[16:19:27.524]  - Number of values collected after concatenation: 2
[16:19:27.524]  - Number of values expected: 2
[16:19:27.524] Reducing values from 1 chunks ... DONE
[16:19:27.524] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:19:27.525] future_lapply() ...
[16:19:27.525] Number of chunks: 1
[16:19:27.526] getGlobalsAndPackagesXApply() ...
[16:19:27.526]  - future.globals: TRUE
[16:19:27.526] getGlobalsAndPackages() ...
[16:19:27.526] Searching for globals...
[16:19:27.527] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:27.527] Searching for globals ... DONE
[16:19:27.527] Resolving globals: FALSE
[16:19:27.528] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:27.528] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:27.528] - globals: [1] ‘FUN’
[16:19:27.528] 
[16:19:27.528] getGlobalsAndPackages() ... DONE
[16:19:27.529]  - globals found/used: [n=1] ‘FUN’
[16:19:27.529]  - needed namespaces: [n=0] 
[16:19:27.529] Finding globals ... DONE
[16:19:27.529]  - use_args: TRUE
[16:19:27.529]  - Getting '...' globals ...
[16:19:27.529] resolve() on list ...
[16:19:27.529]  recursive: 0
[16:19:27.529]  length: 1
[16:19:27.530]  elements: ‘...’
[16:19:27.530]  length: 0 (resolved future 1)
[16:19:27.530] resolve() on list ... DONE
[16:19:27.530]    - '...' content: [n=0] 
[16:19:27.530] List of 1
[16:19:27.530]  $ ...: list()
[16:19:27.530]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:27.530]  - attr(*, "where")=List of 1
[16:19:27.530]   ..$ ...:<environment: 0x5635615ca448> 
[16:19:27.530]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:27.530]  - attr(*, "resolved")= logi TRUE
[16:19:27.530]  - attr(*, "total_size")= num NA
[16:19:27.533]  - Getting '...' globals ... DONE
[16:19:27.533] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:27.533] List of 2
[16:19:27.533]  $ ...future.FUN:function (x)  
[16:19:27.533]  $ ...          : list()
[16:19:27.533]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:27.533]  - attr(*, "where")=List of 2
[16:19:27.533]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:27.533]   ..$ ...          :<environment: 0x5635615ca448> 
[16:19:27.533]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:27.533]  - attr(*, "resolved")= logi FALSE
[16:19:27.533]  - attr(*, "total_size")= num 4720
[16:19:27.536] Packages to be attached in all futures: [n=0] 
[16:19:27.536] getGlobalsAndPackagesXApply() ... DONE
[16:19:27.536] Number of futures (= number of chunks): 1
[16:19:27.536] Launching 1 futures (chunks) ...
[16:19:27.536] Chunk #1 of 1 ...
[16:19:27.536]  - Finding globals in 'X' for chunk #1 ...
[16:19:27.536] getGlobalsAndPackages() ...
[16:19:27.536] Searching for globals...
[16:19:27.537] 
[16:19:27.537] Searching for globals ... DONE
[16:19:27.537] - globals: [0] <none>
[16:19:27.537] getGlobalsAndPackages() ... DONE
[16:19:27.537]    + additional globals found: [n=0] 
[16:19:27.537]    + additional namespaces needed: [n=0] 
[16:19:27.537]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:27.537]  - seeds: <none>
[16:19:27.537]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:27.537] getGlobalsAndPackages() ...
[16:19:27.538] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:27.538] Resolving globals: FALSE
[16:19:27.538] Tweak future expression to call with '...' arguments ...
[16:19:27.538] {
[16:19:27.538]     do.call(function(...) {
[16:19:27.538]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:27.538]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:27.538]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:27.538]             on.exit(options(oopts), add = TRUE)
[16:19:27.538]         }
[16:19:27.538]         {
[16:19:27.538]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:27.538]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:27.538]                 ...future.FUN(...future.X_jj, ...)
[16:19:27.538]             })
[16:19:27.538]         }
[16:19:27.538]     }, args = future.call.arguments)
[16:19:27.538] }
[16:19:27.538] Tweak future expression to call with '...' arguments ... DONE
[16:19:27.538] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:27.539] 
[16:19:27.539] getGlobalsAndPackages() ... DONE
[16:19:27.539] run() for ‘Future’ ...
[16:19:27.539] - state: ‘created’
[16:19:27.539] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:27.539] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:27.540] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:27.540]   - Field: ‘label’
[16:19:27.540]   - Field: ‘local’
[16:19:27.540]   - Field: ‘owner’
[16:19:27.540]   - Field: ‘envir’
[16:19:27.540]   - Field: ‘packages’
[16:19:27.540]   - Field: ‘gc’
[16:19:27.540]   - Field: ‘conditions’
[16:19:27.540]   - Field: ‘expr’
[16:19:27.540]   - Field: ‘uuid’
[16:19:27.541]   - Field: ‘seed’
[16:19:27.541]   - Field: ‘version’
[16:19:27.541]   - Field: ‘result’
[16:19:27.541]   - Field: ‘asynchronous’
[16:19:27.541]   - Field: ‘calls’
[16:19:27.541]   - Field: ‘globals’
[16:19:27.541]   - Field: ‘stdout’
[16:19:27.541]   - Field: ‘earlySignal’
[16:19:27.541]   - Field: ‘lazy’
[16:19:27.541]   - Field: ‘state’
[16:19:27.542] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:27.542] - Launch lazy future ...
[16:19:27.542] Packages needed by the future expression (n = 0): <none>
[16:19:27.542] Packages needed by future strategies (n = 0): <none>
[16:19:27.542] {
[16:19:27.542]     {
[16:19:27.542]         {
[16:19:27.542]             ...future.startTime <- base::Sys.time()
[16:19:27.542]             {
[16:19:27.542]                 {
[16:19:27.542]                   {
[16:19:27.542]                     base::local({
[16:19:27.542]                       has_future <- base::requireNamespace("future", 
[16:19:27.542]                         quietly = TRUE)
[16:19:27.542]                       if (has_future) {
[16:19:27.542]                         ns <- base::getNamespace("future")
[16:19:27.542]                         version <- ns[[".package"]][["version"]]
[16:19:27.542]                         if (is.null(version)) 
[16:19:27.542]                           version <- utils::packageVersion("future")
[16:19:27.542]                       }
[16:19:27.542]                       else {
[16:19:27.542]                         version <- NULL
[16:19:27.542]                       }
[16:19:27.542]                       if (!has_future || version < "1.8.0") {
[16:19:27.542]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:27.542]                           "", base::R.version$version.string), 
[16:19:27.542]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:27.542]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:27.542]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:27.542]                             "release", "version")], collapse = " "), 
[16:19:27.542]                           hostname = base::Sys.info()[["nodename"]])
[16:19:27.542]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:27.542]                           info)
[16:19:27.542]                         info <- base::paste(info, collapse = "; ")
[16:19:27.542]                         if (!has_future) {
[16:19:27.542]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:27.542]                             info)
[16:19:27.542]                         }
[16:19:27.542]                         else {
[16:19:27.542]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:27.542]                             info, version)
[16:19:27.542]                         }
[16:19:27.542]                         base::stop(msg)
[16:19:27.542]                       }
[16:19:27.542]                     })
[16:19:27.542]                   }
[16:19:27.542]                   ...future.strategy.old <- future::plan("list")
[16:19:27.542]                   options(future.plan = NULL)
[16:19:27.542]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:27.542]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:27.542]                 }
[16:19:27.542]                 ...future.workdir <- getwd()
[16:19:27.542]             }
[16:19:27.542]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:27.542]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:27.542]         }
[16:19:27.542]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:27.542]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:27.542]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:27.542]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:27.542]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:27.542]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:27.542]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:27.542]             base::names(...future.oldOptions))
[16:19:27.542]     }
[16:19:27.542]     if (FALSE) {
[16:19:27.542]     }
[16:19:27.542]     else {
[16:19:27.542]         if (TRUE) {
[16:19:27.542]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:27.542]                 open = "w")
[16:19:27.542]         }
[16:19:27.542]         else {
[16:19:27.542]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:27.542]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:27.542]         }
[16:19:27.542]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:27.542]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:27.542]             base::sink(type = "output", split = FALSE)
[16:19:27.542]             base::close(...future.stdout)
[16:19:27.542]         }, add = TRUE)
[16:19:27.542]     }
[16:19:27.542]     ...future.frame <- base::sys.nframe()
[16:19:27.542]     ...future.conditions <- base::list()
[16:19:27.542]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:27.542]     if (FALSE) {
[16:19:27.542]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:27.542]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:27.542]     }
[16:19:27.542]     ...future.result <- base::tryCatch({
[16:19:27.542]         base::withCallingHandlers({
[16:19:27.542]             ...future.value <- base::withVisible(base::local({
[16:19:27.542]                 do.call(function(...) {
[16:19:27.542]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:27.542]                   if (!identical(...future.globals.maxSize.org, 
[16:19:27.542]                     ...future.globals.maxSize)) {
[16:19:27.542]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:27.542]                     on.exit(options(oopts), add = TRUE)
[16:19:27.542]                   }
[16:19:27.542]                   {
[16:19:27.542]                     lapply(seq_along(...future.elements_ii), 
[16:19:27.542]                       FUN = function(jj) {
[16:19:27.542]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:27.542]                         ...future.FUN(...future.X_jj, ...)
[16:19:27.542]                       })
[16:19:27.542]                   }
[16:19:27.542]                 }, args = future.call.arguments)
[16:19:27.542]             }))
[16:19:27.542]             future::FutureResult(value = ...future.value$value, 
[16:19:27.542]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:27.542]                   ...future.rng), globalenv = if (FALSE) 
[16:19:27.542]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:27.542]                     ...future.globalenv.names))
[16:19:27.542]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:27.542]         }, condition = base::local({
[16:19:27.542]             c <- base::c
[16:19:27.542]             inherits <- base::inherits
[16:19:27.542]             invokeRestart <- base::invokeRestart
[16:19:27.542]             length <- base::length
[16:19:27.542]             list <- base::list
[16:19:27.542]             seq.int <- base::seq.int
[16:19:27.542]             signalCondition <- base::signalCondition
[16:19:27.542]             sys.calls <- base::sys.calls
[16:19:27.542]             `[[` <- base::`[[`
[16:19:27.542]             `+` <- base::`+`
[16:19:27.542]             `<<-` <- base::`<<-`
[16:19:27.542]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:27.542]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:27.542]                   3L)]
[16:19:27.542]             }
[16:19:27.542]             function(cond) {
[16:19:27.542]                 is_error <- inherits(cond, "error")
[16:19:27.542]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:27.542]                   NULL)
[16:19:27.542]                 if (is_error) {
[16:19:27.542]                   sessionInformation <- function() {
[16:19:27.542]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:27.542]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:27.542]                       search = base::search(), system = base::Sys.info())
[16:19:27.542]                   }
[16:19:27.542]                   ...future.conditions[[length(...future.conditions) + 
[16:19:27.542]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:27.542]                     cond$call), session = sessionInformation(), 
[16:19:27.542]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:27.542]                   signalCondition(cond)
[16:19:27.542]                 }
[16:19:27.542]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:27.542]                 "immediateCondition"))) {
[16:19:27.542]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:27.542]                   ...future.conditions[[length(...future.conditions) + 
[16:19:27.542]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:27.542]                   if (TRUE && !signal) {
[16:19:27.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:27.542]                     {
[16:19:27.542]                       inherits <- base::inherits
[16:19:27.542]                       invokeRestart <- base::invokeRestart
[16:19:27.542]                       is.null <- base::is.null
[16:19:27.542]                       muffled <- FALSE
[16:19:27.542]                       if (inherits(cond, "message")) {
[16:19:27.542]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:27.542]                         if (muffled) 
[16:19:27.542]                           invokeRestart("muffleMessage")
[16:19:27.542]                       }
[16:19:27.542]                       else if (inherits(cond, "warning")) {
[16:19:27.542]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:27.542]                         if (muffled) 
[16:19:27.542]                           invokeRestart("muffleWarning")
[16:19:27.542]                       }
[16:19:27.542]                       else if (inherits(cond, "condition")) {
[16:19:27.542]                         if (!is.null(pattern)) {
[16:19:27.542]                           computeRestarts <- base::computeRestarts
[16:19:27.542]                           grepl <- base::grepl
[16:19:27.542]                           restarts <- computeRestarts(cond)
[16:19:27.542]                           for (restart in restarts) {
[16:19:27.542]                             name <- restart$name
[16:19:27.542]                             if (is.null(name)) 
[16:19:27.542]                               next
[16:19:27.542]                             if (!grepl(pattern, name)) 
[16:19:27.542]                               next
[16:19:27.542]                             invokeRestart(restart)
[16:19:27.542]                             muffled <- TRUE
[16:19:27.542]                             break
[16:19:27.542]                           }
[16:19:27.542]                         }
[16:19:27.542]                       }
[16:19:27.542]                       invisible(muffled)
[16:19:27.542]                     }
[16:19:27.542]                     muffleCondition(cond, pattern = "^muffle")
[16:19:27.542]                   }
[16:19:27.542]                 }
[16:19:27.542]                 else {
[16:19:27.542]                   if (TRUE) {
[16:19:27.542]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:27.542]                     {
[16:19:27.542]                       inherits <- base::inherits
[16:19:27.542]                       invokeRestart <- base::invokeRestart
[16:19:27.542]                       is.null <- base::is.null
[16:19:27.542]                       muffled <- FALSE
[16:19:27.542]                       if (inherits(cond, "message")) {
[16:19:27.542]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:27.542]                         if (muffled) 
[16:19:27.542]                           invokeRestart("muffleMessage")
[16:19:27.542]                       }
[16:19:27.542]                       else if (inherits(cond, "warning")) {
[16:19:27.542]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:27.542]                         if (muffled) 
[16:19:27.542]                           invokeRestart("muffleWarning")
[16:19:27.542]                       }
[16:19:27.542]                       else if (inherits(cond, "condition")) {
[16:19:27.542]                         if (!is.null(pattern)) {
[16:19:27.542]                           computeRestarts <- base::computeRestarts
[16:19:27.542]                           grepl <- base::grepl
[16:19:27.542]                           restarts <- computeRestarts(cond)
[16:19:27.542]                           for (restart in restarts) {
[16:19:27.542]                             name <- restart$name
[16:19:27.542]                             if (is.null(name)) 
[16:19:27.542]                               next
[16:19:27.542]                             if (!grepl(pattern, name)) 
[16:19:27.542]                               next
[16:19:27.542]                             invokeRestart(restart)
[16:19:27.542]                             muffled <- TRUE
[16:19:27.542]                             break
[16:19:27.542]                           }
[16:19:27.542]                         }
[16:19:27.542]                       }
[16:19:27.542]                       invisible(muffled)
[16:19:27.542]                     }
[16:19:27.542]                     muffleCondition(cond, pattern = "^muffle")
[16:19:27.542]                   }
[16:19:27.542]                 }
[16:19:27.542]             }
[16:19:27.542]         }))
[16:19:27.542]     }, error = function(ex) {
[16:19:27.542]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:27.542]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:27.542]                 ...future.rng), started = ...future.startTime, 
[16:19:27.542]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:27.542]             version = "1.8"), class = "FutureResult")
[16:19:27.542]     }, finally = {
[16:19:27.542]         if (!identical(...future.workdir, getwd())) 
[16:19:27.542]             setwd(...future.workdir)
[16:19:27.542]         {
[16:19:27.542]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:27.542]                 ...future.oldOptions$nwarnings <- NULL
[16:19:27.542]             }
[16:19:27.542]             base::options(...future.oldOptions)
[16:19:27.542]             if (.Platform$OS.type == "windows") {
[16:19:27.542]                 old_names <- names(...future.oldEnvVars)
[16:19:27.542]                 envs <- base::Sys.getenv()
[16:19:27.542]                 names <- names(envs)
[16:19:27.542]                 common <- intersect(names, old_names)
[16:19:27.542]                 added <- setdiff(names, old_names)
[16:19:27.542]                 removed <- setdiff(old_names, names)
[16:19:27.542]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:27.542]                   envs[common]]
[16:19:27.542]                 NAMES <- toupper(changed)
[16:19:27.542]                 args <- list()
[16:19:27.542]                 for (kk in seq_along(NAMES)) {
[16:19:27.542]                   name <- changed[[kk]]
[16:19:27.542]                   NAME <- NAMES[[kk]]
[16:19:27.542]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:27.542]                     next
[16:19:27.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:27.542]                 }
[16:19:27.542]                 NAMES <- toupper(added)
[16:19:27.542]                 for (kk in seq_along(NAMES)) {
[16:19:27.542]                   name <- added[[kk]]
[16:19:27.542]                   NAME <- NAMES[[kk]]
[16:19:27.542]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:27.542]                     next
[16:19:27.542]                   args[[name]] <- ""
[16:19:27.542]                 }
[16:19:27.542]                 NAMES <- toupper(removed)
[16:19:27.542]                 for (kk in seq_along(NAMES)) {
[16:19:27.542]                   name <- removed[[kk]]
[16:19:27.542]                   NAME <- NAMES[[kk]]
[16:19:27.542]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:27.542]                     next
[16:19:27.542]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:27.542]                 }
[16:19:27.542]                 if (length(args) > 0) 
[16:19:27.542]                   base::do.call(base::Sys.setenv, args = args)
[16:19:27.542]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:27.542]             }
[16:19:27.542]             else {
[16:19:27.542]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:27.542]             }
[16:19:27.542]             {
[16:19:27.542]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:27.542]                   0L) {
[16:19:27.542]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:27.542]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:27.542]                   base::options(opts)
[16:19:27.542]                 }
[16:19:27.542]                 {
[16:19:27.542]                   {
[16:19:27.542]                     NULL
[16:19:27.542]                     RNGkind("Mersenne-Twister")
[16:19:27.542]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:27.542]                       inherits = FALSE)
[16:19:27.542]                   }
[16:19:27.542]                   options(future.plan = NULL)
[16:19:27.542]                   if (is.na(NA_character_)) 
[16:19:27.542]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:27.542]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:27.542]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:27.542]                     .init = FALSE)
[16:19:27.542]                 }
[16:19:27.542]             }
[16:19:27.542]         }
[16:19:27.542]     })
[16:19:27.542]     if (TRUE) {
[16:19:27.542]         base::sink(type = "output", split = FALSE)
[16:19:27.542]         if (TRUE) {
[16:19:27.542]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:27.542]         }
[16:19:27.542]         else {
[16:19:27.542]             ...future.result["stdout"] <- base::list(NULL)
[16:19:27.542]         }
[16:19:27.542]         base::close(...future.stdout)
[16:19:27.542]         ...future.stdout <- NULL
[16:19:27.542]     }
[16:19:27.542]     ...future.result$conditions <- ...future.conditions
[16:19:27.542]     ...future.result$finished <- base::Sys.time()
[16:19:27.542]     ...future.result
[16:19:27.542] }
[16:19:27.544] assign_globals() ...
[16:19:27.544] List of 5
[16:19:27.544]  $ ...future.FUN            :function (x)  
[16:19:27.544]  $ future.call.arguments    : list()
[16:19:27.544]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:27.544]  $ ...future.elements_ii    :List of 2
[16:19:27.544]   ..$ : int 1
[16:19:27.544]   ..$ : int 0
[16:19:27.544]  $ ...future.seeds_ii       : NULL
[16:19:27.544]  $ ...future.globals.maxSize: NULL
[16:19:27.544]  - attr(*, "where")=List of 5
[16:19:27.544]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:27.544]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:27.544]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:27.544]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:27.544]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:27.544]  - attr(*, "resolved")= logi FALSE
[16:19:27.544]  - attr(*, "total_size")= num 4720
[16:19:27.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:27.544]  - attr(*, "already-done")= logi TRUE
[16:19:27.550] - reassign environment for ‘...future.FUN’
[16:19:27.550] - copied ‘...future.FUN’ to environment
[16:19:27.551] - copied ‘future.call.arguments’ to environment
[16:19:27.551] - copied ‘...future.elements_ii’ to environment
[16:19:27.551] - copied ‘...future.seeds_ii’ to environment
[16:19:27.551] - copied ‘...future.globals.maxSize’ to environment
[16:19:27.551] assign_globals() ... done
[16:19:27.551] plan(): Setting new future strategy stack:
[16:19:27.551] List of future strategies:
[16:19:27.551] 1. sequential:
[16:19:27.551]    - args: function (..., envir = parent.frame())
[16:19:27.551]    - tweaked: FALSE
[16:19:27.551]    - call: NULL
[16:19:27.552] plan(): nbrOfWorkers() = 1
[16:19:28.053] plan(): Setting new future strategy stack:
[16:19:28.054] List of future strategies:
[16:19:28.054] 1. sequential:
[16:19:28.054]    - args: function (..., envir = parent.frame())
[16:19:28.054]    - tweaked: FALSE
[16:19:28.054]    - call: plan(strategy)
[16:19:28.054] plan(): nbrOfWorkers() = 1
[16:19:28.054] SequentialFuture started (and completed)
[16:19:28.054] - Launch lazy future ... done
[16:19:28.055] run() for ‘SequentialFuture’ ... done
[16:19:28.055] Created future:
[16:19:28.055] SequentialFuture:
[16:19:28.055] Label: ‘future_lapply-1’
[16:19:28.055] Expression:
[16:19:28.055] {
[16:19:28.055]     do.call(function(...) {
[16:19:28.055]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:28.055]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:28.055]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:28.055]             on.exit(options(oopts), add = TRUE)
[16:19:28.055]         }
[16:19:28.055]         {
[16:19:28.055]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:28.055]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:28.055]                 ...future.FUN(...future.X_jj, ...)
[16:19:28.055]             })
[16:19:28.055]         }
[16:19:28.055]     }, args = future.call.arguments)
[16:19:28.055] }
[16:19:28.055] Lazy evaluation: FALSE
[16:19:28.055] Asynchronous evaluation: FALSE
[16:19:28.055] Local evaluation: TRUE
[16:19:28.055] Environment: R_GlobalEnv
[16:19:28.055] Capture standard output: TRUE
[16:19:28.055] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:28.055] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:28.055] Packages: <none>
[16:19:28.055] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:28.055] Resolved: TRUE
[16:19:28.055] Value: 112 bytes of class ‘list’
[16:19:28.055] Early signaling: FALSE
[16:19:28.055] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:28.055] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:28.056] Chunk #1 of 1 ... DONE
[16:19:28.056] Launching 1 futures (chunks) ... DONE
[16:19:28.056] Resolving 1 futures (chunks) ...
[16:19:28.056] resolve() on list ...
[16:19:28.056]  recursive: 0
[16:19:28.056]  length: 1
[16:19:28.057] 
[16:19:28.057] resolved() for ‘SequentialFuture’ ...
[16:19:28.057] - state: ‘finished’
[16:19:28.057] - run: TRUE
[16:19:28.057] - result: ‘FutureResult’
[16:19:28.057] resolved() for ‘SequentialFuture’ ... done
[16:19:28.057] Future #1
[16:19:28.057] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:28.057] - nx: 1
[16:19:28.057] - relay: TRUE
[16:19:28.058] - stdout: TRUE
[16:19:28.058] - signal: TRUE
[16:19:28.058] - resignal: FALSE
[16:19:28.058] - force: TRUE
[16:19:28.058] - relayed: [n=1] FALSE
[16:19:28.058] - queued futures: [n=1] FALSE
[16:19:28.058]  - until=1
[16:19:28.058]  - relaying element #1
[16:19:28.058] - relayed: [n=1] TRUE
[16:19:28.058] - queued futures: [n=1] TRUE
[16:19:28.059] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:28.059]  length: 0 (resolved future 1)
[16:19:28.059] Relaying remaining futures
[16:19:28.059] signalConditionsASAP(NULL, pos=0) ...
[16:19:28.059] - nx: 1
[16:19:28.059] - relay: TRUE
[16:19:28.059] - stdout: TRUE
[16:19:28.059] - signal: TRUE
[16:19:28.059] - resignal: FALSE
[16:19:28.059] - force: TRUE
[16:19:28.059] - relayed: [n=1] TRUE
[16:19:28.059] - queued futures: [n=1] TRUE
 - flush all
[16:19:28.060] - relayed: [n=1] TRUE
[16:19:28.060] - queued futures: [n=1] TRUE
[16:19:28.060] signalConditionsASAP(NULL, pos=0) ... done
[16:19:28.060] resolve() on list ... DONE
[16:19:28.060]  - Number of value chunks collected: 1
[16:19:28.060] Resolving 1 futures (chunks) ... DONE
[16:19:28.060] Reducing values from 1 chunks ...
[16:19:28.060]  - Number of values collected after concatenation: 2
[16:19:28.060]  - Number of values expected: 2
[16:19:28.060] Reducing values from 1 chunks ... DONE
[16:19:28.061] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:19:28.061] future_lapply() ...
[16:19:28.062] Number of chunks: 1
[16:19:28.062] getGlobalsAndPackagesXApply() ...
[16:19:28.062]  - future.globals: TRUE
[16:19:28.062] getGlobalsAndPackages() ...
[16:19:28.062] Searching for globals...
[16:19:28.063] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:28.064] Searching for globals ... DONE
[16:19:28.064] Resolving globals: FALSE
[16:19:28.064] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:28.064] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:28.065] - globals: [1] ‘FUN’
[16:19:28.065] 
[16:19:28.065] getGlobalsAndPackages() ... DONE
[16:19:28.065]  - globals found/used: [n=1] ‘FUN’
[16:19:28.065]  - needed namespaces: [n=0] 
[16:19:28.065] Finding globals ... DONE
[16:19:28.065]  - use_args: TRUE
[16:19:28.065]  - Getting '...' globals ...
[16:19:28.066] resolve() on list ...
[16:19:28.066]  recursive: 0
[16:19:28.066]  length: 1
[16:19:28.066]  elements: ‘...’
[16:19:28.066]  length: 0 (resolved future 1)
[16:19:28.066] resolve() on list ... DONE
[16:19:28.066]    - '...' content: [n=0] 
[16:19:28.066] List of 1
[16:19:28.066]  $ ...: list()
[16:19:28.066]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:28.066]  - attr(*, "where")=List of 1
[16:19:28.066]   ..$ ...:<environment: 0x5635623890f0> 
[16:19:28.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:28.066]  - attr(*, "resolved")= logi TRUE
[16:19:28.066]  - attr(*, "total_size")= num NA
[16:19:28.069]  - Getting '...' globals ... DONE
[16:19:28.069] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:28.069] List of 2
[16:19:28.069]  $ ...future.FUN:function (x)  
[16:19:28.069]  $ ...          : list()
[16:19:28.069]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:28.069]  - attr(*, "where")=List of 2
[16:19:28.069]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:28.069]   ..$ ...          :<environment: 0x5635623890f0> 
[16:19:28.069]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:28.069]  - attr(*, "resolved")= logi FALSE
[16:19:28.069]  - attr(*, "total_size")= num 4720
[16:19:28.072] Packages to be attached in all futures: [n=0] 
[16:19:28.072] getGlobalsAndPackagesXApply() ... DONE
[16:19:28.072] Number of futures (= number of chunks): 1
[16:19:28.072] Launching 1 futures (chunks) ...
[16:19:28.072] Chunk #1 of 1 ...
[16:19:28.072]  - Finding globals in 'X' for chunk #1 ...
[16:19:28.074] getGlobalsAndPackages() ...
[16:19:28.074] Searching for globals...
[16:19:28.075] 
[16:19:28.075] Searching for globals ... DONE
[16:19:28.075] - globals: [0] <none>
[16:19:28.075] getGlobalsAndPackages() ... DONE
[16:19:28.075]    + additional globals found: [n=0] 
[16:19:28.075]    + additional namespaces needed: [n=0] 
[16:19:28.075]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:28.075]  - seeds: <none>
[16:19:28.075]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:28.076] getGlobalsAndPackages() ...
[16:19:28.076] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:28.076] Resolving globals: FALSE
[16:19:28.076] Tweak future expression to call with '...' arguments ...
[16:19:28.076] {
[16:19:28.076]     do.call(function(...) {
[16:19:28.076]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:28.076]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:28.076]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:28.076]             on.exit(options(oopts), add = TRUE)
[16:19:28.076]         }
[16:19:28.076]         {
[16:19:28.076]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:28.076]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:28.076]                 ...future.FUN(...future.X_jj, ...)
[16:19:28.076]             })
[16:19:28.076]         }
[16:19:28.076]     }, args = future.call.arguments)
[16:19:28.076] }
[16:19:28.076] Tweak future expression to call with '...' arguments ... DONE
[16:19:28.077] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:28.077] 
[16:19:28.077] getGlobalsAndPackages() ... DONE
[16:19:28.077] run() for ‘Future’ ...
[16:19:28.077] - state: ‘created’
[16:19:28.077] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:28.078] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:28.078] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:28.078]   - Field: ‘label’
[16:19:28.078]   - Field: ‘local’
[16:19:28.078]   - Field: ‘owner’
[16:19:28.078]   - Field: ‘envir’
[16:19:28.078]   - Field: ‘packages’
[16:19:28.078]   - Field: ‘gc’
[16:19:28.079]   - Field: ‘conditions’
[16:19:28.079]   - Field: ‘expr’
[16:19:28.079]   - Field: ‘uuid’
[16:19:28.079]   - Field: ‘seed’
[16:19:28.079]   - Field: ‘version’
[16:19:28.079]   - Field: ‘result’
[16:19:28.079]   - Field: ‘asynchronous’
[16:19:28.079]   - Field: ‘calls’
[16:19:28.079]   - Field: ‘globals’
[16:19:28.079]   - Field: ‘stdout’
[16:19:28.079]   - Field: ‘earlySignal’
[16:19:28.080]   - Field: ‘lazy’
[16:19:28.080]   - Field: ‘state’
[16:19:28.080] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:28.080] - Launch lazy future ...
[16:19:28.080] Packages needed by the future expression (n = 0): <none>
[16:19:28.080] Packages needed by future strategies (n = 0): <none>
[16:19:28.081] {
[16:19:28.081]     {
[16:19:28.081]         {
[16:19:28.081]             ...future.startTime <- base::Sys.time()
[16:19:28.081]             {
[16:19:28.081]                 {
[16:19:28.081]                   {
[16:19:28.081]                     base::local({
[16:19:28.081]                       has_future <- base::requireNamespace("future", 
[16:19:28.081]                         quietly = TRUE)
[16:19:28.081]                       if (has_future) {
[16:19:28.081]                         ns <- base::getNamespace("future")
[16:19:28.081]                         version <- ns[[".package"]][["version"]]
[16:19:28.081]                         if (is.null(version)) 
[16:19:28.081]                           version <- utils::packageVersion("future")
[16:19:28.081]                       }
[16:19:28.081]                       else {
[16:19:28.081]                         version <- NULL
[16:19:28.081]                       }
[16:19:28.081]                       if (!has_future || version < "1.8.0") {
[16:19:28.081]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:28.081]                           "", base::R.version$version.string), 
[16:19:28.081]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:28.081]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:28.081]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:28.081]                             "release", "version")], collapse = " "), 
[16:19:28.081]                           hostname = base::Sys.info()[["nodename"]])
[16:19:28.081]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:28.081]                           info)
[16:19:28.081]                         info <- base::paste(info, collapse = "; ")
[16:19:28.081]                         if (!has_future) {
[16:19:28.081]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:28.081]                             info)
[16:19:28.081]                         }
[16:19:28.081]                         else {
[16:19:28.081]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:28.081]                             info, version)
[16:19:28.081]                         }
[16:19:28.081]                         base::stop(msg)
[16:19:28.081]                       }
[16:19:28.081]                     })
[16:19:28.081]                   }
[16:19:28.081]                   ...future.strategy.old <- future::plan("list")
[16:19:28.081]                   options(future.plan = NULL)
[16:19:28.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:28.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:28.081]                 }
[16:19:28.081]                 ...future.workdir <- getwd()
[16:19:28.081]             }
[16:19:28.081]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:28.081]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:28.081]         }
[16:19:28.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:28.081]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:28.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:28.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:28.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:28.081]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:28.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:28.081]             base::names(...future.oldOptions))
[16:19:28.081]     }
[16:19:28.081]     if (TRUE) {
[16:19:28.081]     }
[16:19:28.081]     else {
[16:19:28.081]         if (NA) {
[16:19:28.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:28.081]                 open = "w")
[16:19:28.081]         }
[16:19:28.081]         else {
[16:19:28.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:28.081]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:28.081]         }
[16:19:28.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:28.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:28.081]             base::sink(type = "output", split = FALSE)
[16:19:28.081]             base::close(...future.stdout)
[16:19:28.081]         }, add = TRUE)
[16:19:28.081]     }
[16:19:28.081]     ...future.frame <- base::sys.nframe()
[16:19:28.081]     ...future.conditions <- base::list()
[16:19:28.081]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:28.081]     if (FALSE) {
[16:19:28.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:28.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:28.081]     }
[16:19:28.081]     ...future.result <- base::tryCatch({
[16:19:28.081]         base::withCallingHandlers({
[16:19:28.081]             ...future.value <- base::withVisible(base::local({
[16:19:28.081]                 do.call(function(...) {
[16:19:28.081]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:28.081]                   if (!identical(...future.globals.maxSize.org, 
[16:19:28.081]                     ...future.globals.maxSize)) {
[16:19:28.081]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:28.081]                     on.exit(options(oopts), add = TRUE)
[16:19:28.081]                   }
[16:19:28.081]                   {
[16:19:28.081]                     lapply(seq_along(...future.elements_ii), 
[16:19:28.081]                       FUN = function(jj) {
[16:19:28.081]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:28.081]                         ...future.FUN(...future.X_jj, ...)
[16:19:28.081]                       })
[16:19:28.081]                   }
[16:19:28.081]                 }, args = future.call.arguments)
[16:19:28.081]             }))
[16:19:28.081]             future::FutureResult(value = ...future.value$value, 
[16:19:28.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:28.081]                   ...future.rng), globalenv = if (FALSE) 
[16:19:28.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:28.081]                     ...future.globalenv.names))
[16:19:28.081]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:28.081]         }, condition = base::local({
[16:19:28.081]             c <- base::c
[16:19:28.081]             inherits <- base::inherits
[16:19:28.081]             invokeRestart <- base::invokeRestart
[16:19:28.081]             length <- base::length
[16:19:28.081]             list <- base::list
[16:19:28.081]             seq.int <- base::seq.int
[16:19:28.081]             signalCondition <- base::signalCondition
[16:19:28.081]             sys.calls <- base::sys.calls
[16:19:28.081]             `[[` <- base::`[[`
[16:19:28.081]             `+` <- base::`+`
[16:19:28.081]             `<<-` <- base::`<<-`
[16:19:28.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:28.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:28.081]                   3L)]
[16:19:28.081]             }
[16:19:28.081]             function(cond) {
[16:19:28.081]                 is_error <- inherits(cond, "error")
[16:19:28.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:28.081]                   NULL)
[16:19:28.081]                 if (is_error) {
[16:19:28.081]                   sessionInformation <- function() {
[16:19:28.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:28.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:28.081]                       search = base::search(), system = base::Sys.info())
[16:19:28.081]                   }
[16:19:28.081]                   ...future.conditions[[length(...future.conditions) + 
[16:19:28.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:28.081]                     cond$call), session = sessionInformation(), 
[16:19:28.081]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:28.081]                   signalCondition(cond)
[16:19:28.081]                 }
[16:19:28.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:28.081]                 "immediateCondition"))) {
[16:19:28.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:28.081]                   ...future.conditions[[length(...future.conditions) + 
[16:19:28.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:28.081]                   if (TRUE && !signal) {
[16:19:28.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:28.081]                     {
[16:19:28.081]                       inherits <- base::inherits
[16:19:28.081]                       invokeRestart <- base::invokeRestart
[16:19:28.081]                       is.null <- base::is.null
[16:19:28.081]                       muffled <- FALSE
[16:19:28.081]                       if (inherits(cond, "message")) {
[16:19:28.081]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:28.081]                         if (muffled) 
[16:19:28.081]                           invokeRestart("muffleMessage")
[16:19:28.081]                       }
[16:19:28.081]                       else if (inherits(cond, "warning")) {
[16:19:28.081]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:28.081]                         if (muffled) 
[16:19:28.081]                           invokeRestart("muffleWarning")
[16:19:28.081]                       }
[16:19:28.081]                       else if (inherits(cond, "condition")) {
[16:19:28.081]                         if (!is.null(pattern)) {
[16:19:28.081]                           computeRestarts <- base::computeRestarts
[16:19:28.081]                           grepl <- base::grepl
[16:19:28.081]                           restarts <- computeRestarts(cond)
[16:19:28.081]                           for (restart in restarts) {
[16:19:28.081]                             name <- restart$name
[16:19:28.081]                             if (is.null(name)) 
[16:19:28.081]                               next
[16:19:28.081]                             if (!grepl(pattern, name)) 
[16:19:28.081]                               next
[16:19:28.081]                             invokeRestart(restart)
[16:19:28.081]                             muffled <- TRUE
[16:19:28.081]                             break
[16:19:28.081]                           }
[16:19:28.081]                         }
[16:19:28.081]                       }
[16:19:28.081]                       invisible(muffled)
[16:19:28.081]                     }
[16:19:28.081]                     muffleCondition(cond, pattern = "^muffle")
[16:19:28.081]                   }
[16:19:28.081]                 }
[16:19:28.081]                 else {
[16:19:28.081]                   if (TRUE) {
[16:19:28.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:28.081]                     {
[16:19:28.081]                       inherits <- base::inherits
[16:19:28.081]                       invokeRestart <- base::invokeRestart
[16:19:28.081]                       is.null <- base::is.null
[16:19:28.081]                       muffled <- FALSE
[16:19:28.081]                       if (inherits(cond, "message")) {
[16:19:28.081]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:28.081]                         if (muffled) 
[16:19:28.081]                           invokeRestart("muffleMessage")
[16:19:28.081]                       }
[16:19:28.081]                       else if (inherits(cond, "warning")) {
[16:19:28.081]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:28.081]                         if (muffled) 
[16:19:28.081]                           invokeRestart("muffleWarning")
[16:19:28.081]                       }
[16:19:28.081]                       else if (inherits(cond, "condition")) {
[16:19:28.081]                         if (!is.null(pattern)) {
[16:19:28.081]                           computeRestarts <- base::computeRestarts
[16:19:28.081]                           grepl <- base::grepl
[16:19:28.081]                           restarts <- computeRestarts(cond)
[16:19:28.081]                           for (restart in restarts) {
[16:19:28.081]                             name <- restart$name
[16:19:28.081]                             if (is.null(name)) 
[16:19:28.081]                               next
[16:19:28.081]                             if (!grepl(pattern, name)) 
[16:19:28.081]                               next
[16:19:28.081]                             invokeRestart(restart)
[16:19:28.081]                             muffled <- TRUE
[16:19:28.081]                             break
[16:19:28.081]                           }
[16:19:28.081]                         }
[16:19:28.081]                       }
[16:19:28.081]                       invisible(muffled)
[16:19:28.081]                     }
[16:19:28.081]                     muffleCondition(cond, pattern = "^muffle")
[16:19:28.081]                   }
[16:19:28.081]                 }
[16:19:28.081]             }
[16:19:28.081]         }))
[16:19:28.081]     }, error = function(ex) {
[16:19:28.081]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:28.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:28.081]                 ...future.rng), started = ...future.startTime, 
[16:19:28.081]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:28.081]             version = "1.8"), class = "FutureResult")
[16:19:28.081]     }, finally = {
[16:19:28.081]         if (!identical(...future.workdir, getwd())) 
[16:19:28.081]             setwd(...future.workdir)
[16:19:28.081]         {
[16:19:28.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:28.081]                 ...future.oldOptions$nwarnings <- NULL
[16:19:28.081]             }
[16:19:28.081]             base::options(...future.oldOptions)
[16:19:28.081]             if (.Platform$OS.type == "windows") {
[16:19:28.081]                 old_names <- names(...future.oldEnvVars)
[16:19:28.081]                 envs <- base::Sys.getenv()
[16:19:28.081]                 names <- names(envs)
[16:19:28.081]                 common <- intersect(names, old_names)
[16:19:28.081]                 added <- setdiff(names, old_names)
[16:19:28.081]                 removed <- setdiff(old_names, names)
[16:19:28.081]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:28.081]                   envs[common]]
[16:19:28.081]                 NAMES <- toupper(changed)
[16:19:28.081]                 args <- list()
[16:19:28.081]                 for (kk in seq_along(NAMES)) {
[16:19:28.081]                   name <- changed[[kk]]
[16:19:28.081]                   NAME <- NAMES[[kk]]
[16:19:28.081]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:28.081]                     next
[16:19:28.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:28.081]                 }
[16:19:28.081]                 NAMES <- toupper(added)
[16:19:28.081]                 for (kk in seq_along(NAMES)) {
[16:19:28.081]                   name <- added[[kk]]
[16:19:28.081]                   NAME <- NAMES[[kk]]
[16:19:28.081]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:28.081]                     next
[16:19:28.081]                   args[[name]] <- ""
[16:19:28.081]                 }
[16:19:28.081]                 NAMES <- toupper(removed)
[16:19:28.081]                 for (kk in seq_along(NAMES)) {
[16:19:28.081]                   name <- removed[[kk]]
[16:19:28.081]                   NAME <- NAMES[[kk]]
[16:19:28.081]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:28.081]                     next
[16:19:28.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:28.081]                 }
[16:19:28.081]                 if (length(args) > 0) 
[16:19:28.081]                   base::do.call(base::Sys.setenv, args = args)
[16:19:28.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:28.081]             }
[16:19:28.081]             else {
[16:19:28.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:28.081]             }
[16:19:28.081]             {
[16:19:28.081]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:28.081]                   0L) {
[16:19:28.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:28.081]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:28.081]                   base::options(opts)
[16:19:28.081]                 }
[16:19:28.081]                 {
[16:19:28.081]                   {
[16:19:28.081]                     NULL
[16:19:28.081]                     RNGkind("Mersenne-Twister")
[16:19:28.081]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:28.081]                       inherits = FALSE)
[16:19:28.081]                   }
[16:19:28.081]                   options(future.plan = NULL)
[16:19:28.081]                   if (is.na(NA_character_)) 
[16:19:28.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:28.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:28.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:28.081]                     .init = FALSE)
[16:19:28.081]                 }
[16:19:28.081]             }
[16:19:28.081]         }
[16:19:28.081]     })
[16:19:28.081]     if (FALSE) {
[16:19:28.081]         base::sink(type = "output", split = FALSE)
[16:19:28.081]         if (NA) {
[16:19:28.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:28.081]         }
[16:19:28.081]         else {
[16:19:28.081]             ...future.result["stdout"] <- base::list(NULL)
[16:19:28.081]         }
[16:19:28.081]         base::close(...future.stdout)
[16:19:28.081]         ...future.stdout <- NULL
[16:19:28.081]     }
[16:19:28.081]     ...future.result$conditions <- ...future.conditions
[16:19:28.081]     ...future.result$finished <- base::Sys.time()
[16:19:28.081]     ...future.result
[16:19:28.081] }
[16:19:28.082] assign_globals() ...
[16:19:28.082] List of 5
[16:19:28.082]  $ ...future.FUN            :function (x)  
[16:19:28.082]  $ future.call.arguments    : list()
[16:19:28.082]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:28.082]  $ ...future.elements_ii    :List of 2
[16:19:28.082]   ..$ : int 1
[16:19:28.082]   ..$ : int 0
[16:19:28.082]  $ ...future.seeds_ii       : NULL
[16:19:28.082]  $ ...future.globals.maxSize: NULL
[16:19:28.082]  - attr(*, "where")=List of 5
[16:19:28.082]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:28.082]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:28.082]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:28.082]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:28.082]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:28.082]  - attr(*, "resolved")= logi FALSE
[16:19:28.082]  - attr(*, "total_size")= num 4720
[16:19:28.082]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:28.082]  - attr(*, "already-done")= logi TRUE
[16:19:28.087] - reassign environment for ‘...future.FUN’
[16:19:28.087] - copied ‘...future.FUN’ to environment
[16:19:28.087] - copied ‘future.call.arguments’ to environment
[16:19:28.087] - copied ‘...future.elements_ii’ to environment
[16:19:28.087] - copied ‘...future.seeds_ii’ to environment
[16:19:28.088] - copied ‘...future.globals.maxSize’ to environment
[16:19:28.088] assign_globals() ... done
[16:19:28.088] plan(): Setting new future strategy stack:
[16:19:28.088] List of future strategies:
[16:19:28.088] 1. sequential:
[16:19:28.088]    - args: function (..., envir = parent.frame())
[16:19:28.088]    - tweaked: FALSE
[16:19:28.088]    - call: NULL
[16:19:28.088] plan(): nbrOfWorkers() = 1
[16:19:28.590] plan(): Setting new future strategy stack:
[16:19:28.590] List of future strategies:
[16:19:28.590] 1. sequential:
[16:19:28.590]    - args: function (..., envir = parent.frame())
[16:19:28.590]    - tweaked: FALSE
[16:19:28.590]    - call: plan(strategy)
[16:19:28.591] plan(): nbrOfWorkers() = 1
[16:19:28.591] SequentialFuture started (and completed)
[16:19:28.591] - Launch lazy future ... done
[16:19:28.591] run() for ‘SequentialFuture’ ... done
[16:19:28.591] Created future:
[16:19:28.591] SequentialFuture:
[16:19:28.591] Label: ‘future_lapply-1’
[16:19:28.591] Expression:
[16:19:28.591] {
[16:19:28.591]     do.call(function(...) {
[16:19:28.591]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:28.591]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:28.591]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:28.591]             on.exit(options(oopts), add = TRUE)
[16:19:28.591]         }
[16:19:28.591]         {
[16:19:28.591]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:28.591]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:28.591]                 ...future.FUN(...future.X_jj, ...)
[16:19:28.591]             })
[16:19:28.591]         }
[16:19:28.591]     }, args = future.call.arguments)
[16:19:28.591] }
[16:19:28.591] Lazy evaluation: FALSE
[16:19:28.591] Asynchronous evaluation: FALSE
[16:19:28.591] Local evaluation: TRUE
[16:19:28.591] Environment: R_GlobalEnv
[16:19:28.591] Capture standard output: NA
[16:19:28.591] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:28.591] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:28.591] Packages: <none>
[16:19:28.591] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:28.591] Resolved: TRUE
[16:19:28.591] Value: 112 bytes of class ‘list’
[16:19:28.591] Early signaling: FALSE
[16:19:28.591] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:28.591] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:28.592] Chunk #1 of 1 ... DONE
[16:19:28.592] Launching 1 futures (chunks) ... DONE
[16:19:28.593] Resolving 1 futures (chunks) ...
[16:19:28.593] resolve() on list ...
[16:19:28.593]  recursive: 0
[16:19:28.593]  length: 1
[16:19:28.593] 
[16:19:28.593] resolved() for ‘SequentialFuture’ ...
[16:19:28.593] - state: ‘finished’
[16:19:28.593] - run: TRUE
[16:19:28.593] - result: ‘FutureResult’
[16:19:28.593] resolved() for ‘SequentialFuture’ ... done
[16:19:28.594] Future #1
[16:19:28.594] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:28.594] - nx: 1
[16:19:28.594] - relay: TRUE
[16:19:28.594] - stdout: TRUE
[16:19:28.594] - signal: TRUE
[16:19:28.594] - resignal: FALSE
[16:19:28.594] - force: TRUE
[16:19:28.594] - relayed: [n=1] FALSE
[16:19:28.594] - queued futures: [n=1] FALSE
[16:19:28.594]  - until=1
[16:19:28.595]  - relaying element #1
[16:19:28.595] - relayed: [n=1] TRUE
[16:19:28.595] - queued futures: [n=1] TRUE
[16:19:28.595] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:28.595]  length: 0 (resolved future 1)
[16:19:28.595] Relaying remaining futures
[16:19:28.595] signalConditionsASAP(NULL, pos=0) ...
[16:19:28.595] - nx: 1
[16:19:28.595] - relay: TRUE
[16:19:28.595] - stdout: TRUE
[16:19:28.596] - signal: TRUE
[16:19:28.596] - resignal: FALSE
[16:19:28.596] - force: TRUE
[16:19:28.596] - relayed: [n=1] TRUE
[16:19:28.596] - queued futures: [n=1] TRUE
 - flush all
[16:19:28.596] - relayed: [n=1] TRUE
[16:19:28.596] - queued futures: [n=1] TRUE
[16:19:28.596] signalConditionsASAP(NULL, pos=0) ... done
[16:19:28.596] resolve() on list ... DONE
[16:19:28.597]  - Number of value chunks collected: 1
[16:19:28.597] Resolving 1 futures (chunks) ... DONE
[16:19:28.597] Reducing values from 1 chunks ...
[16:19:28.597]  - Number of values collected after concatenation: 2
[16:19:28.597]  - Number of values expected: 2
[16:19:28.597] Reducing values from 1 chunks ... DONE
[16:19:28.597] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:19:28.597] future_mapply() ...
[16:19:28.598] Number of chunks: 1
[16:19:28.598] getGlobalsAndPackagesXApply() ...
[16:19:28.598]  - future.globals: TRUE
[16:19:28.598] getGlobalsAndPackages() ...
[16:19:28.598] Searching for globals...
[16:19:28.599] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:28.600] Searching for globals ... DONE
[16:19:28.600] Resolving globals: FALSE
[16:19:28.602] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:28.602] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:28.603] - globals: [1] ‘FUN’
[16:19:28.603] 
[16:19:28.603] getGlobalsAndPackages() ... DONE
[16:19:28.603]  - globals found/used: [n=1] ‘FUN’
[16:19:28.603]  - needed namespaces: [n=0] 
[16:19:28.603] Finding globals ... DONE
[16:19:28.603] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:28.603] List of 2
[16:19:28.603]  $ ...future.FUN:function (x, y)  
[16:19:28.603]  $ MoreArgs     : NULL
[16:19:28.603]  - attr(*, "where")=List of 2
[16:19:28.603]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:28.603]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:28.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:28.603]  - attr(*, "resolved")= logi FALSE
[16:19:28.603]  - attr(*, "total_size")= num NA
[16:19:28.606] Packages to be attached in all futures: [n=0] 
[16:19:28.606] getGlobalsAndPackagesXApply() ... DONE
[16:19:28.606] Number of futures (= number of chunks): 1
[16:19:28.606] Launching 1 futures (chunks) ...
[16:19:28.606] Chunk #1 of 1 ...
[16:19:28.607]  - Finding globals in '...' for chunk #1 ...
[16:19:28.607] getGlobalsAndPackages() ...
[16:19:28.607] Searching for globals...
[16:19:28.607] 
[16:19:28.607] Searching for globals ... DONE
[16:19:28.607] - globals: [0] <none>
[16:19:28.607] getGlobalsAndPackages() ... DONE
[16:19:28.607]    + additional globals found: [n=0] 
[16:19:28.608]    + additional namespaces needed: [n=0] 
[16:19:28.608]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:28.608]  - seeds: <none>
[16:19:28.608]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:28.608] getGlobalsAndPackages() ...
[16:19:28.608] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:28.608] Resolving globals: FALSE
[16:19:28.609] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:19:28.609] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:28.609] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:28.609] 
[16:19:28.609] getGlobalsAndPackages() ... DONE
[16:19:28.610] run() for ‘Future’ ...
[16:19:28.610] - state: ‘created’
[16:19:28.610] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:28.610] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:28.610] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:28.610]   - Field: ‘label’
[16:19:28.611]   - Field: ‘local’
[16:19:28.611]   - Field: ‘owner’
[16:19:28.611]   - Field: ‘envir’
[16:19:28.611]   - Field: ‘packages’
[16:19:28.611]   - Field: ‘gc’
[16:19:28.611]   - Field: ‘conditions’
[16:19:28.611]   - Field: ‘expr’
[16:19:28.611]   - Field: ‘uuid’
[16:19:28.611]   - Field: ‘seed’
[16:19:28.611]   - Field: ‘version’
[16:19:28.611]   - Field: ‘result’
[16:19:28.612]   - Field: ‘asynchronous’
[16:19:28.612]   - Field: ‘calls’
[16:19:28.612]   - Field: ‘globals’
[16:19:28.612]   - Field: ‘stdout’
[16:19:28.612]   - Field: ‘earlySignal’
[16:19:28.612]   - Field: ‘lazy’
[16:19:28.612]   - Field: ‘state’
[16:19:28.612] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:28.612] - Launch lazy future ...
[16:19:28.612] Packages needed by the future expression (n = 0): <none>
[16:19:28.613] Packages needed by future strategies (n = 0): <none>
[16:19:28.613] {
[16:19:28.613]     {
[16:19:28.613]         {
[16:19:28.613]             ...future.startTime <- base::Sys.time()
[16:19:28.613]             {
[16:19:28.613]                 {
[16:19:28.613]                   {
[16:19:28.613]                     base::local({
[16:19:28.613]                       has_future <- base::requireNamespace("future", 
[16:19:28.613]                         quietly = TRUE)
[16:19:28.613]                       if (has_future) {
[16:19:28.613]                         ns <- base::getNamespace("future")
[16:19:28.613]                         version <- ns[[".package"]][["version"]]
[16:19:28.613]                         if (is.null(version)) 
[16:19:28.613]                           version <- utils::packageVersion("future")
[16:19:28.613]                       }
[16:19:28.613]                       else {
[16:19:28.613]                         version <- NULL
[16:19:28.613]                       }
[16:19:28.613]                       if (!has_future || version < "1.8.0") {
[16:19:28.613]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:28.613]                           "", base::R.version$version.string), 
[16:19:28.613]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:28.613]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:28.613]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:28.613]                             "release", "version")], collapse = " "), 
[16:19:28.613]                           hostname = base::Sys.info()[["nodename"]])
[16:19:28.613]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:28.613]                           info)
[16:19:28.613]                         info <- base::paste(info, collapse = "; ")
[16:19:28.613]                         if (!has_future) {
[16:19:28.613]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:28.613]                             info)
[16:19:28.613]                         }
[16:19:28.613]                         else {
[16:19:28.613]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:28.613]                             info, version)
[16:19:28.613]                         }
[16:19:28.613]                         base::stop(msg)
[16:19:28.613]                       }
[16:19:28.613]                     })
[16:19:28.613]                   }
[16:19:28.613]                   ...future.strategy.old <- future::plan("list")
[16:19:28.613]                   options(future.plan = NULL)
[16:19:28.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:28.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:28.613]                 }
[16:19:28.613]                 ...future.workdir <- getwd()
[16:19:28.613]             }
[16:19:28.613]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:28.613]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:28.613]         }
[16:19:28.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:28.613]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:28.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:28.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:28.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:28.613]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:28.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:28.613]             base::names(...future.oldOptions))
[16:19:28.613]     }
[16:19:28.613]     if (FALSE) {
[16:19:28.613]     }
[16:19:28.613]     else {
[16:19:28.613]         if (FALSE) {
[16:19:28.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:28.613]                 open = "w")
[16:19:28.613]         }
[16:19:28.613]         else {
[16:19:28.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:28.613]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:28.613]         }
[16:19:28.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:28.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:28.613]             base::sink(type = "output", split = FALSE)
[16:19:28.613]             base::close(...future.stdout)
[16:19:28.613]         }, add = TRUE)
[16:19:28.613]     }
[16:19:28.613]     ...future.frame <- base::sys.nframe()
[16:19:28.613]     ...future.conditions <- base::list()
[16:19:28.613]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:28.613]     if (FALSE) {
[16:19:28.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:28.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:28.613]     }
[16:19:28.613]     ...future.result <- base::tryCatch({
[16:19:28.613]         base::withCallingHandlers({
[16:19:28.613]             ...future.value <- base::withVisible(base::local({
[16:19:28.613]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:28.613]                 if (!identical(...future.globals.maxSize.org, 
[16:19:28.613]                   ...future.globals.maxSize)) {
[16:19:28.613]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:28.613]                   on.exit(options(oopts), add = TRUE)
[16:19:28.613]                 }
[16:19:28.613]                 {
[16:19:28.613]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:28.613]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:28.613]                     USE.NAMES = FALSE)
[16:19:28.613]                   do.call(mapply, args = args)
[16:19:28.613]                 }
[16:19:28.613]             }))
[16:19:28.613]             future::FutureResult(value = ...future.value$value, 
[16:19:28.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:28.613]                   ...future.rng), globalenv = if (FALSE) 
[16:19:28.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:28.613]                     ...future.globalenv.names))
[16:19:28.613]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:28.613]         }, condition = base::local({
[16:19:28.613]             c <- base::c
[16:19:28.613]             inherits <- base::inherits
[16:19:28.613]             invokeRestart <- base::invokeRestart
[16:19:28.613]             length <- base::length
[16:19:28.613]             list <- base::list
[16:19:28.613]             seq.int <- base::seq.int
[16:19:28.613]             signalCondition <- base::signalCondition
[16:19:28.613]             sys.calls <- base::sys.calls
[16:19:28.613]             `[[` <- base::`[[`
[16:19:28.613]             `+` <- base::`+`
[16:19:28.613]             `<<-` <- base::`<<-`
[16:19:28.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:28.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:28.613]                   3L)]
[16:19:28.613]             }
[16:19:28.613]             function(cond) {
[16:19:28.613]                 is_error <- inherits(cond, "error")
[16:19:28.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:28.613]                   NULL)
[16:19:28.613]                 if (is_error) {
[16:19:28.613]                   sessionInformation <- function() {
[16:19:28.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:28.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:28.613]                       search = base::search(), system = base::Sys.info())
[16:19:28.613]                   }
[16:19:28.613]                   ...future.conditions[[length(...future.conditions) + 
[16:19:28.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:28.613]                     cond$call), session = sessionInformation(), 
[16:19:28.613]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:28.613]                   signalCondition(cond)
[16:19:28.613]                 }
[16:19:28.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:28.613]                 "immediateCondition"))) {
[16:19:28.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:28.613]                   ...future.conditions[[length(...future.conditions) + 
[16:19:28.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:28.613]                   if (TRUE && !signal) {
[16:19:28.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:28.613]                     {
[16:19:28.613]                       inherits <- base::inherits
[16:19:28.613]                       invokeRestart <- base::invokeRestart
[16:19:28.613]                       is.null <- base::is.null
[16:19:28.613]                       muffled <- FALSE
[16:19:28.613]                       if (inherits(cond, "message")) {
[16:19:28.613]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:28.613]                         if (muffled) 
[16:19:28.613]                           invokeRestart("muffleMessage")
[16:19:28.613]                       }
[16:19:28.613]                       else if (inherits(cond, "warning")) {
[16:19:28.613]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:28.613]                         if (muffled) 
[16:19:28.613]                           invokeRestart("muffleWarning")
[16:19:28.613]                       }
[16:19:28.613]                       else if (inherits(cond, "condition")) {
[16:19:28.613]                         if (!is.null(pattern)) {
[16:19:28.613]                           computeRestarts <- base::computeRestarts
[16:19:28.613]                           grepl <- base::grepl
[16:19:28.613]                           restarts <- computeRestarts(cond)
[16:19:28.613]                           for (restart in restarts) {
[16:19:28.613]                             name <- restart$name
[16:19:28.613]                             if (is.null(name)) 
[16:19:28.613]                               next
[16:19:28.613]                             if (!grepl(pattern, name)) 
[16:19:28.613]                               next
[16:19:28.613]                             invokeRestart(restart)
[16:19:28.613]                             muffled <- TRUE
[16:19:28.613]                             break
[16:19:28.613]                           }
[16:19:28.613]                         }
[16:19:28.613]                       }
[16:19:28.613]                       invisible(muffled)
[16:19:28.613]                     }
[16:19:28.613]                     muffleCondition(cond, pattern = "^muffle")
[16:19:28.613]                   }
[16:19:28.613]                 }
[16:19:28.613]                 else {
[16:19:28.613]                   if (TRUE) {
[16:19:28.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:28.613]                     {
[16:19:28.613]                       inherits <- base::inherits
[16:19:28.613]                       invokeRestart <- base::invokeRestart
[16:19:28.613]                       is.null <- base::is.null
[16:19:28.613]                       muffled <- FALSE
[16:19:28.613]                       if (inherits(cond, "message")) {
[16:19:28.613]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:28.613]                         if (muffled) 
[16:19:28.613]                           invokeRestart("muffleMessage")
[16:19:28.613]                       }
[16:19:28.613]                       else if (inherits(cond, "warning")) {
[16:19:28.613]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:28.613]                         if (muffled) 
[16:19:28.613]                           invokeRestart("muffleWarning")
[16:19:28.613]                       }
[16:19:28.613]                       else if (inherits(cond, "condition")) {
[16:19:28.613]                         if (!is.null(pattern)) {
[16:19:28.613]                           computeRestarts <- base::computeRestarts
[16:19:28.613]                           grepl <- base::grepl
[16:19:28.613]                           restarts <- computeRestarts(cond)
[16:19:28.613]                           for (restart in restarts) {
[16:19:28.613]                             name <- restart$name
[16:19:28.613]                             if (is.null(name)) 
[16:19:28.613]                               next
[16:19:28.613]                             if (!grepl(pattern, name)) 
[16:19:28.613]                               next
[16:19:28.613]                             invokeRestart(restart)
[16:19:28.613]                             muffled <- TRUE
[16:19:28.613]                             break
[16:19:28.613]                           }
[16:19:28.613]                         }
[16:19:28.613]                       }
[16:19:28.613]                       invisible(muffled)
[16:19:28.613]                     }
[16:19:28.613]                     muffleCondition(cond, pattern = "^muffle")
[16:19:28.613]                   }
[16:19:28.613]                 }
[16:19:28.613]             }
[16:19:28.613]         }))
[16:19:28.613]     }, error = function(ex) {
[16:19:28.613]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:28.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:28.613]                 ...future.rng), started = ...future.startTime, 
[16:19:28.613]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:28.613]             version = "1.8"), class = "FutureResult")
[16:19:28.613]     }, finally = {
[16:19:28.613]         if (!identical(...future.workdir, getwd())) 
[16:19:28.613]             setwd(...future.workdir)
[16:19:28.613]         {
[16:19:28.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:28.613]                 ...future.oldOptions$nwarnings <- NULL
[16:19:28.613]             }
[16:19:28.613]             base::options(...future.oldOptions)
[16:19:28.613]             if (.Platform$OS.type == "windows") {
[16:19:28.613]                 old_names <- names(...future.oldEnvVars)
[16:19:28.613]                 envs <- base::Sys.getenv()
[16:19:28.613]                 names <- names(envs)
[16:19:28.613]                 common <- intersect(names, old_names)
[16:19:28.613]                 added <- setdiff(names, old_names)
[16:19:28.613]                 removed <- setdiff(old_names, names)
[16:19:28.613]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:28.613]                   envs[common]]
[16:19:28.613]                 NAMES <- toupper(changed)
[16:19:28.613]                 args <- list()
[16:19:28.613]                 for (kk in seq_along(NAMES)) {
[16:19:28.613]                   name <- changed[[kk]]
[16:19:28.613]                   NAME <- NAMES[[kk]]
[16:19:28.613]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:28.613]                     next
[16:19:28.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:28.613]                 }
[16:19:28.613]                 NAMES <- toupper(added)
[16:19:28.613]                 for (kk in seq_along(NAMES)) {
[16:19:28.613]                   name <- added[[kk]]
[16:19:28.613]                   NAME <- NAMES[[kk]]
[16:19:28.613]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:28.613]                     next
[16:19:28.613]                   args[[name]] <- ""
[16:19:28.613]                 }
[16:19:28.613]                 NAMES <- toupper(removed)
[16:19:28.613]                 for (kk in seq_along(NAMES)) {
[16:19:28.613]                   name <- removed[[kk]]
[16:19:28.613]                   NAME <- NAMES[[kk]]
[16:19:28.613]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:28.613]                     next
[16:19:28.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:28.613]                 }
[16:19:28.613]                 if (length(args) > 0) 
[16:19:28.613]                   base::do.call(base::Sys.setenv, args = args)
[16:19:28.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:28.613]             }
[16:19:28.613]             else {
[16:19:28.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:28.613]             }
[16:19:28.613]             {
[16:19:28.613]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:28.613]                   0L) {
[16:19:28.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:28.613]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:28.613]                   base::options(opts)
[16:19:28.613]                 }
[16:19:28.613]                 {
[16:19:28.613]                   {
[16:19:28.613]                     NULL
[16:19:28.613]                     RNGkind("Mersenne-Twister")
[16:19:28.613]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:28.613]                       inherits = FALSE)
[16:19:28.613]                   }
[16:19:28.613]                   options(future.plan = NULL)
[16:19:28.613]                   if (is.na(NA_character_)) 
[16:19:28.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:28.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:28.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:28.613]                     .init = FALSE)
[16:19:28.613]                 }
[16:19:28.613]             }
[16:19:28.613]         }
[16:19:28.613]     })
[16:19:28.613]     if (TRUE) {
[16:19:28.613]         base::sink(type = "output", split = FALSE)
[16:19:28.613]         if (FALSE) {
[16:19:28.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:28.613]         }
[16:19:28.613]         else {
[16:19:28.613]             ...future.result["stdout"] <- base::list(NULL)
[16:19:28.613]         }
[16:19:28.613]         base::close(...future.stdout)
[16:19:28.613]         ...future.stdout <- NULL
[16:19:28.613]     }
[16:19:28.613]     ...future.result$conditions <- ...future.conditions
[16:19:28.613]     ...future.result$finished <- base::Sys.time()
[16:19:28.613]     ...future.result
[16:19:28.613] }
[16:19:28.615] assign_globals() ...
[16:19:28.615] List of 5
[16:19:28.615]  $ ...future.FUN            :function (x, y)  
[16:19:28.615]  $ MoreArgs                 : NULL
[16:19:28.615]  $ ...future.elements_ii    :List of 2
[16:19:28.615]   ..$ :List of 2
[16:19:28.615]   .. ..$ : int 1
[16:19:28.615]   .. ..$ : int 0
[16:19:28.615]   ..$ :List of 2
[16:19:28.615]   .. ..$ : int 0
[16:19:28.615]   .. ..$ : int 1
[16:19:28.615]  $ ...future.seeds_ii       : NULL
[16:19:28.615]  $ ...future.globals.maxSize: NULL
[16:19:28.615]  - attr(*, "where")=List of 5
[16:19:28.615]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:28.615]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:28.615]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:28.615]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:28.615]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:28.615]  - attr(*, "resolved")= logi FALSE
[16:19:28.615]  - attr(*, "total_size")= num 6480
[16:19:28.615]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:28.615]  - attr(*, "already-done")= logi TRUE
[16:19:28.620] - reassign environment for ‘...future.FUN’
[16:19:28.620] - copied ‘...future.FUN’ to environment
[16:19:28.620] - copied ‘MoreArgs’ to environment
[16:19:28.620] - copied ‘...future.elements_ii’ to environment
[16:19:28.621] - copied ‘...future.seeds_ii’ to environment
[16:19:28.621] - copied ‘...future.globals.maxSize’ to environment
[16:19:28.621] assign_globals() ... done
[16:19:28.621] plan(): Setting new future strategy stack:
[16:19:28.621] List of future strategies:
[16:19:28.621] 1. sequential:
[16:19:28.621]    - args: function (..., envir = parent.frame())
[16:19:28.621]    - tweaked: FALSE
[16:19:28.621]    - call: NULL
[16:19:28.621] plan(): nbrOfWorkers() = 1
[16:19:29.123] plan(): Setting new future strategy stack:
[16:19:29.123] List of future strategies:
[16:19:29.123] 1. sequential:
[16:19:29.123]    - args: function (..., envir = parent.frame())
[16:19:29.123]    - tweaked: FALSE
[16:19:29.123]    - call: plan(strategy)
[16:19:29.124] plan(): nbrOfWorkers() = 1
[16:19:29.124] SequentialFuture started (and completed)
[16:19:29.124] - Launch lazy future ... done
[16:19:29.124] run() for ‘SequentialFuture’ ... done
[16:19:29.124] Created future:
[16:19:29.125] SequentialFuture:
[16:19:29.125] Label: ‘future_mapply-1’
[16:19:29.125] Expression:
[16:19:29.125] {
[16:19:29.125]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:29.125]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:29.125]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:29.125]         on.exit(options(oopts), add = TRUE)
[16:19:29.125]     }
[16:19:29.125]     {
[16:19:29.125]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:29.125]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:29.125]         do.call(mapply, args = args)
[16:19:29.125]     }
[16:19:29.125] }
[16:19:29.125] Lazy evaluation: FALSE
[16:19:29.125] Asynchronous evaluation: FALSE
[16:19:29.125] Local evaluation: TRUE
[16:19:29.125] Environment: R_GlobalEnv
[16:19:29.125] Capture standard output: FALSE
[16:19:29.125] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:29.125] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:29.125] Packages: <none>
[16:19:29.125] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:29.125] Resolved: TRUE
[16:19:29.125] Value: 224 bytes of class ‘list’
[16:19:29.125] Early signaling: FALSE
[16:19:29.125] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:29.125] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:29.126] Chunk #1 of 1 ... DONE
[16:19:29.126] Launching 1 futures (chunks) ... DONE
[16:19:29.126] Resolving 1 futures (chunks) ...
[16:19:29.126] resolve() on list ...
[16:19:29.126]  recursive: 0
[16:19:29.126]  length: 1
[16:19:29.126] 
[16:19:29.126] resolved() for ‘SequentialFuture’ ...
[16:19:29.126] - state: ‘finished’
[16:19:29.126] - run: TRUE
[16:19:29.126] - result: ‘FutureResult’
[16:19:29.127] resolved() for ‘SequentialFuture’ ... done
[16:19:29.127] Future #1
[16:19:29.127] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:29.127] - nx: 1
[16:19:29.127] - relay: TRUE
[16:19:29.127] - stdout: TRUE
[16:19:29.127] - signal: TRUE
[16:19:29.129] - resignal: FALSE
[16:19:29.129] - force: TRUE
[16:19:29.129] - relayed: [n=1] FALSE
[16:19:29.129] - queued futures: [n=1] FALSE
[16:19:29.129]  - until=1
[16:19:29.129]  - relaying element #1
[16:19:29.130] - relayed: [n=1] TRUE
[16:19:29.130] - queued futures: [n=1] TRUE
[16:19:29.130] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:29.130]  length: 0 (resolved future 1)
[16:19:29.130] Relaying remaining futures
[16:19:29.130] signalConditionsASAP(NULL, pos=0) ...
[16:19:29.130] - nx: 1
[16:19:29.130] - relay: TRUE
[16:19:29.130] - stdout: TRUE
[16:19:29.130] - signal: TRUE
[16:19:29.130] - resignal: FALSE
[16:19:29.131] - force: TRUE
[16:19:29.131] - relayed: [n=1] TRUE
[16:19:29.131] - queued futures: [n=1] TRUE
 - flush all
[16:19:29.131] - relayed: [n=1] TRUE
[16:19:29.131] - queued futures: [n=1] TRUE
[16:19:29.131] signalConditionsASAP(NULL, pos=0) ... done
[16:19:29.131] resolve() on list ... DONE
[16:19:29.131]  - Number of value chunks collected: 1
[16:19:29.131] Resolving 1 futures (chunks) ... DONE
[16:19:29.131] Reducing values from 1 chunks ...
[16:19:29.132]  - Number of values collected after concatenation: 2
[16:19:29.132]  - Number of values expected: 2
[16:19:29.132] Reducing values from 1 chunks ... DONE
[16:19:29.132] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:19:29.132] future_mapply() ...
[16:19:29.132] Number of chunks: 1
[16:19:29.133] getGlobalsAndPackagesXApply() ...
[16:19:29.133]  - future.globals: TRUE
[16:19:29.133] getGlobalsAndPackages() ...
[16:19:29.133] Searching for globals...
[16:19:29.134] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:29.134] Searching for globals ... DONE
[16:19:29.135] Resolving globals: FALSE
[16:19:29.135] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:29.135] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:29.135] - globals: [1] ‘FUN’
[16:19:29.136] 
[16:19:29.136] getGlobalsAndPackages() ... DONE
[16:19:29.136]  - globals found/used: [n=1] ‘FUN’
[16:19:29.136]  - needed namespaces: [n=0] 
[16:19:29.136] Finding globals ... DONE
[16:19:29.136] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:29.136] List of 2
[16:19:29.136]  $ ...future.FUN:function (x, y)  
[16:19:29.136]  $ MoreArgs     : NULL
[16:19:29.136]  - attr(*, "where")=List of 2
[16:19:29.136]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:29.136]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:29.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:29.136]  - attr(*, "resolved")= logi FALSE
[16:19:29.136]  - attr(*, "total_size")= num NA
[16:19:29.139] Packages to be attached in all futures: [n=0] 
[16:19:29.139] getGlobalsAndPackagesXApply() ... DONE
[16:19:29.139] Number of futures (= number of chunks): 1
[16:19:29.139] Launching 1 futures (chunks) ...
[16:19:29.139] Chunk #1 of 1 ...
[16:19:29.139]  - Finding globals in '...' for chunk #1 ...
[16:19:29.139] getGlobalsAndPackages() ...
[16:19:29.140] Searching for globals...
[16:19:29.140] 
[16:19:29.140] Searching for globals ... DONE
[16:19:29.140] - globals: [0] <none>
[16:19:29.140] getGlobalsAndPackages() ... DONE
[16:19:29.140]    + additional globals found: [n=0] 
[16:19:29.140]    + additional namespaces needed: [n=0] 
[16:19:29.140]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:29.141]  - seeds: <none>
[16:19:29.141]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:29.141] getGlobalsAndPackages() ...
[16:19:29.141] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:29.141] Resolving globals: FALSE
[16:19:29.141] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:19:29.142] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:29.142] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:29.142] 
[16:19:29.142] getGlobalsAndPackages() ... DONE
[16:19:29.142] run() for ‘Future’ ...
[16:19:29.143] - state: ‘created’
[16:19:29.143] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:29.143] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:29.143] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:29.143]   - Field: ‘label’
[16:19:29.143]   - Field: ‘local’
[16:19:29.143]   - Field: ‘owner’
[16:19:29.143]   - Field: ‘envir’
[16:19:29.144]   - Field: ‘packages’
[16:19:29.144]   - Field: ‘gc’
[16:19:29.144]   - Field: ‘conditions’
[16:19:29.144]   - Field: ‘expr’
[16:19:29.144]   - Field: ‘uuid’
[16:19:29.144]   - Field: ‘seed’
[16:19:29.144]   - Field: ‘version’
[16:19:29.144]   - Field: ‘result’
[16:19:29.144]   - Field: ‘asynchronous’
[16:19:29.144]   - Field: ‘calls’
[16:19:29.145]   - Field: ‘globals’
[16:19:29.145]   - Field: ‘stdout’
[16:19:29.145]   - Field: ‘earlySignal’
[16:19:29.145]   - Field: ‘lazy’
[16:19:29.145]   - Field: ‘state’
[16:19:29.145] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:29.145] - Launch lazy future ...
[16:19:29.145] Packages needed by the future expression (n = 0): <none>
[16:19:29.145] Packages needed by future strategies (n = 0): <none>
[16:19:29.146] {
[16:19:29.146]     {
[16:19:29.146]         {
[16:19:29.146]             ...future.startTime <- base::Sys.time()
[16:19:29.146]             {
[16:19:29.146]                 {
[16:19:29.146]                   {
[16:19:29.146]                     base::local({
[16:19:29.146]                       has_future <- base::requireNamespace("future", 
[16:19:29.146]                         quietly = TRUE)
[16:19:29.146]                       if (has_future) {
[16:19:29.146]                         ns <- base::getNamespace("future")
[16:19:29.146]                         version <- ns[[".package"]][["version"]]
[16:19:29.146]                         if (is.null(version)) 
[16:19:29.146]                           version <- utils::packageVersion("future")
[16:19:29.146]                       }
[16:19:29.146]                       else {
[16:19:29.146]                         version <- NULL
[16:19:29.146]                       }
[16:19:29.146]                       if (!has_future || version < "1.8.0") {
[16:19:29.146]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:29.146]                           "", base::R.version$version.string), 
[16:19:29.146]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:29.146]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:29.146]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:29.146]                             "release", "version")], collapse = " "), 
[16:19:29.146]                           hostname = base::Sys.info()[["nodename"]])
[16:19:29.146]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:29.146]                           info)
[16:19:29.146]                         info <- base::paste(info, collapse = "; ")
[16:19:29.146]                         if (!has_future) {
[16:19:29.146]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:29.146]                             info)
[16:19:29.146]                         }
[16:19:29.146]                         else {
[16:19:29.146]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:29.146]                             info, version)
[16:19:29.146]                         }
[16:19:29.146]                         base::stop(msg)
[16:19:29.146]                       }
[16:19:29.146]                     })
[16:19:29.146]                   }
[16:19:29.146]                   ...future.strategy.old <- future::plan("list")
[16:19:29.146]                   options(future.plan = NULL)
[16:19:29.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:29.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:29.146]                 }
[16:19:29.146]                 ...future.workdir <- getwd()
[16:19:29.146]             }
[16:19:29.146]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:29.146]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:29.146]         }
[16:19:29.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:29.146]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:29.146]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:29.146]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:29.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:29.146]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:29.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:29.146]             base::names(...future.oldOptions))
[16:19:29.146]     }
[16:19:29.146]     if (FALSE) {
[16:19:29.146]     }
[16:19:29.146]     else {
[16:19:29.146]         if (TRUE) {
[16:19:29.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:29.146]                 open = "w")
[16:19:29.146]         }
[16:19:29.146]         else {
[16:19:29.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:29.146]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:29.146]         }
[16:19:29.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:29.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:29.146]             base::sink(type = "output", split = FALSE)
[16:19:29.146]             base::close(...future.stdout)
[16:19:29.146]         }, add = TRUE)
[16:19:29.146]     }
[16:19:29.146]     ...future.frame <- base::sys.nframe()
[16:19:29.146]     ...future.conditions <- base::list()
[16:19:29.146]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:29.146]     if (FALSE) {
[16:19:29.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:29.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:29.146]     }
[16:19:29.146]     ...future.result <- base::tryCatch({
[16:19:29.146]         base::withCallingHandlers({
[16:19:29.146]             ...future.value <- base::withVisible(base::local({
[16:19:29.146]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:29.146]                 if (!identical(...future.globals.maxSize.org, 
[16:19:29.146]                   ...future.globals.maxSize)) {
[16:19:29.146]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:29.146]                   on.exit(options(oopts), add = TRUE)
[16:19:29.146]                 }
[16:19:29.146]                 {
[16:19:29.146]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:29.146]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:29.146]                     USE.NAMES = FALSE)
[16:19:29.146]                   do.call(mapply, args = args)
[16:19:29.146]                 }
[16:19:29.146]             }))
[16:19:29.146]             future::FutureResult(value = ...future.value$value, 
[16:19:29.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:29.146]                   ...future.rng), globalenv = if (FALSE) 
[16:19:29.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:29.146]                     ...future.globalenv.names))
[16:19:29.146]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:29.146]         }, condition = base::local({
[16:19:29.146]             c <- base::c
[16:19:29.146]             inherits <- base::inherits
[16:19:29.146]             invokeRestart <- base::invokeRestart
[16:19:29.146]             length <- base::length
[16:19:29.146]             list <- base::list
[16:19:29.146]             seq.int <- base::seq.int
[16:19:29.146]             signalCondition <- base::signalCondition
[16:19:29.146]             sys.calls <- base::sys.calls
[16:19:29.146]             `[[` <- base::`[[`
[16:19:29.146]             `+` <- base::`+`
[16:19:29.146]             `<<-` <- base::`<<-`
[16:19:29.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:29.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:29.146]                   3L)]
[16:19:29.146]             }
[16:19:29.146]             function(cond) {
[16:19:29.146]                 is_error <- inherits(cond, "error")
[16:19:29.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:29.146]                   NULL)
[16:19:29.146]                 if (is_error) {
[16:19:29.146]                   sessionInformation <- function() {
[16:19:29.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:29.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:29.146]                       search = base::search(), system = base::Sys.info())
[16:19:29.146]                   }
[16:19:29.146]                   ...future.conditions[[length(...future.conditions) + 
[16:19:29.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:29.146]                     cond$call), session = sessionInformation(), 
[16:19:29.146]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:29.146]                   signalCondition(cond)
[16:19:29.146]                 }
[16:19:29.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:29.146]                 "immediateCondition"))) {
[16:19:29.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:29.146]                   ...future.conditions[[length(...future.conditions) + 
[16:19:29.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:29.146]                   if (TRUE && !signal) {
[16:19:29.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:29.146]                     {
[16:19:29.146]                       inherits <- base::inherits
[16:19:29.146]                       invokeRestart <- base::invokeRestart
[16:19:29.146]                       is.null <- base::is.null
[16:19:29.146]                       muffled <- FALSE
[16:19:29.146]                       if (inherits(cond, "message")) {
[16:19:29.146]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:29.146]                         if (muffled) 
[16:19:29.146]                           invokeRestart("muffleMessage")
[16:19:29.146]                       }
[16:19:29.146]                       else if (inherits(cond, "warning")) {
[16:19:29.146]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:29.146]                         if (muffled) 
[16:19:29.146]                           invokeRestart("muffleWarning")
[16:19:29.146]                       }
[16:19:29.146]                       else if (inherits(cond, "condition")) {
[16:19:29.146]                         if (!is.null(pattern)) {
[16:19:29.146]                           computeRestarts <- base::computeRestarts
[16:19:29.146]                           grepl <- base::grepl
[16:19:29.146]                           restarts <- computeRestarts(cond)
[16:19:29.146]                           for (restart in restarts) {
[16:19:29.146]                             name <- restart$name
[16:19:29.146]                             if (is.null(name)) 
[16:19:29.146]                               next
[16:19:29.146]                             if (!grepl(pattern, name)) 
[16:19:29.146]                               next
[16:19:29.146]                             invokeRestart(restart)
[16:19:29.146]                             muffled <- TRUE
[16:19:29.146]                             break
[16:19:29.146]                           }
[16:19:29.146]                         }
[16:19:29.146]                       }
[16:19:29.146]                       invisible(muffled)
[16:19:29.146]                     }
[16:19:29.146]                     muffleCondition(cond, pattern = "^muffle")
[16:19:29.146]                   }
[16:19:29.146]                 }
[16:19:29.146]                 else {
[16:19:29.146]                   if (TRUE) {
[16:19:29.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:29.146]                     {
[16:19:29.146]                       inherits <- base::inherits
[16:19:29.146]                       invokeRestart <- base::invokeRestart
[16:19:29.146]                       is.null <- base::is.null
[16:19:29.146]                       muffled <- FALSE
[16:19:29.146]                       if (inherits(cond, "message")) {
[16:19:29.146]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:29.146]                         if (muffled) 
[16:19:29.146]                           invokeRestart("muffleMessage")
[16:19:29.146]                       }
[16:19:29.146]                       else if (inherits(cond, "warning")) {
[16:19:29.146]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:29.146]                         if (muffled) 
[16:19:29.146]                           invokeRestart("muffleWarning")
[16:19:29.146]                       }
[16:19:29.146]                       else if (inherits(cond, "condition")) {
[16:19:29.146]                         if (!is.null(pattern)) {
[16:19:29.146]                           computeRestarts <- base::computeRestarts
[16:19:29.146]                           grepl <- base::grepl
[16:19:29.146]                           restarts <- computeRestarts(cond)
[16:19:29.146]                           for (restart in restarts) {
[16:19:29.146]                             name <- restart$name
[16:19:29.146]                             if (is.null(name)) 
[16:19:29.146]                               next
[16:19:29.146]                             if (!grepl(pattern, name)) 
[16:19:29.146]                               next
[16:19:29.146]                             invokeRestart(restart)
[16:19:29.146]                             muffled <- TRUE
[16:19:29.146]                             break
[16:19:29.146]                           }
[16:19:29.146]                         }
[16:19:29.146]                       }
[16:19:29.146]                       invisible(muffled)
[16:19:29.146]                     }
[16:19:29.146]                     muffleCondition(cond, pattern = "^muffle")
[16:19:29.146]                   }
[16:19:29.146]                 }
[16:19:29.146]             }
[16:19:29.146]         }))
[16:19:29.146]     }, error = function(ex) {
[16:19:29.146]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:29.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:29.146]                 ...future.rng), started = ...future.startTime, 
[16:19:29.146]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:29.146]             version = "1.8"), class = "FutureResult")
[16:19:29.146]     }, finally = {
[16:19:29.146]         if (!identical(...future.workdir, getwd())) 
[16:19:29.146]             setwd(...future.workdir)
[16:19:29.146]         {
[16:19:29.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:29.146]                 ...future.oldOptions$nwarnings <- NULL
[16:19:29.146]             }
[16:19:29.146]             base::options(...future.oldOptions)
[16:19:29.146]             if (.Platform$OS.type == "windows") {
[16:19:29.146]                 old_names <- names(...future.oldEnvVars)
[16:19:29.146]                 envs <- base::Sys.getenv()
[16:19:29.146]                 names <- names(envs)
[16:19:29.146]                 common <- intersect(names, old_names)
[16:19:29.146]                 added <- setdiff(names, old_names)
[16:19:29.146]                 removed <- setdiff(old_names, names)
[16:19:29.146]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:29.146]                   envs[common]]
[16:19:29.146]                 NAMES <- toupper(changed)
[16:19:29.146]                 args <- list()
[16:19:29.146]                 for (kk in seq_along(NAMES)) {
[16:19:29.146]                   name <- changed[[kk]]
[16:19:29.146]                   NAME <- NAMES[[kk]]
[16:19:29.146]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:29.146]                     next
[16:19:29.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:29.146]                 }
[16:19:29.146]                 NAMES <- toupper(added)
[16:19:29.146]                 for (kk in seq_along(NAMES)) {
[16:19:29.146]                   name <- added[[kk]]
[16:19:29.146]                   NAME <- NAMES[[kk]]
[16:19:29.146]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:29.146]                     next
[16:19:29.146]                   args[[name]] <- ""
[16:19:29.146]                 }
[16:19:29.146]                 NAMES <- toupper(removed)
[16:19:29.146]                 for (kk in seq_along(NAMES)) {
[16:19:29.146]                   name <- removed[[kk]]
[16:19:29.146]                   NAME <- NAMES[[kk]]
[16:19:29.146]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:29.146]                     next
[16:19:29.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:29.146]                 }
[16:19:29.146]                 if (length(args) > 0) 
[16:19:29.146]                   base::do.call(base::Sys.setenv, args = args)
[16:19:29.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:29.146]             }
[16:19:29.146]             else {
[16:19:29.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:29.146]             }
[16:19:29.146]             {
[16:19:29.146]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:29.146]                   0L) {
[16:19:29.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:29.146]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:29.146]                   base::options(opts)
[16:19:29.146]                 }
[16:19:29.146]                 {
[16:19:29.146]                   {
[16:19:29.146]                     NULL
[16:19:29.146]                     RNGkind("Mersenne-Twister")
[16:19:29.146]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:29.146]                       inherits = FALSE)
[16:19:29.146]                   }
[16:19:29.146]                   options(future.plan = NULL)
[16:19:29.146]                   if (is.na(NA_character_)) 
[16:19:29.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:29.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:29.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:29.146]                     .init = FALSE)
[16:19:29.146]                 }
[16:19:29.146]             }
[16:19:29.146]         }
[16:19:29.146]     })
[16:19:29.146]     if (TRUE) {
[16:19:29.146]         base::sink(type = "output", split = FALSE)
[16:19:29.146]         if (TRUE) {
[16:19:29.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:29.146]         }
[16:19:29.146]         else {
[16:19:29.146]             ...future.result["stdout"] <- base::list(NULL)
[16:19:29.146]         }
[16:19:29.146]         base::close(...future.stdout)
[16:19:29.146]         ...future.stdout <- NULL
[16:19:29.146]     }
[16:19:29.146]     ...future.result$conditions <- ...future.conditions
[16:19:29.146]     ...future.result$finished <- base::Sys.time()
[16:19:29.146]     ...future.result
[16:19:29.146] }
[16:19:29.147] assign_globals() ...
[16:19:29.148] List of 5
[16:19:29.148]  $ ...future.FUN            :function (x, y)  
[16:19:29.148]  $ MoreArgs                 : NULL
[16:19:29.148]  $ ...future.elements_ii    :List of 2
[16:19:29.148]   ..$ :List of 2
[16:19:29.148]   .. ..$ : int 1
[16:19:29.148]   .. ..$ : int 0
[16:19:29.148]   ..$ :List of 2
[16:19:29.148]   .. ..$ : int 0
[16:19:29.148]   .. ..$ : int 1
[16:19:29.148]  $ ...future.seeds_ii       : NULL
[16:19:29.148]  $ ...future.globals.maxSize: NULL
[16:19:29.148]  - attr(*, "where")=List of 5
[16:19:29.148]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:29.148]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:29.148]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:29.148]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:29.148]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:29.148]  - attr(*, "resolved")= logi FALSE
[16:19:29.148]  - attr(*, "total_size")= num 6480
[16:19:29.148]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:29.148]  - attr(*, "already-done")= logi TRUE
[16:19:29.154] - reassign environment for ‘...future.FUN’
[16:19:29.154] - copied ‘...future.FUN’ to environment
[16:19:29.154] - copied ‘MoreArgs’ to environment
[16:19:29.154] - copied ‘...future.elements_ii’ to environment
[16:19:29.155] - copied ‘...future.seeds_ii’ to environment
[16:19:29.155] - copied ‘...future.globals.maxSize’ to environment
[16:19:29.155] assign_globals() ... done
[16:19:29.155] plan(): Setting new future strategy stack:
[16:19:29.155] List of future strategies:
[16:19:29.155] 1. sequential:
[16:19:29.155]    - args: function (..., envir = parent.frame())
[16:19:29.155]    - tweaked: FALSE
[16:19:29.155]    - call: NULL
[16:19:29.155] plan(): nbrOfWorkers() = 1
[16:19:29.657] plan(): Setting new future strategy stack:
[16:19:29.657] List of future strategies:
[16:19:29.657] 1. sequential:
[16:19:29.657]    - args: function (..., envir = parent.frame())
[16:19:29.657]    - tweaked: FALSE
[16:19:29.657]    - call: plan(strategy)
[16:19:29.658] plan(): nbrOfWorkers() = 1
[16:19:29.658] SequentialFuture started (and completed)
[16:19:29.658] - Launch lazy future ... done
[16:19:29.658] run() for ‘SequentialFuture’ ... done
[16:19:29.658] Created future:
[16:19:29.658] SequentialFuture:
[16:19:29.658] Label: ‘future_mapply-1’
[16:19:29.658] Expression:
[16:19:29.658] {
[16:19:29.658]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:29.658]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:29.658]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:29.658]         on.exit(options(oopts), add = TRUE)
[16:19:29.658]     }
[16:19:29.658]     {
[16:19:29.658]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:29.658]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:29.658]         do.call(mapply, args = args)
[16:19:29.658]     }
[16:19:29.658] }
[16:19:29.658] Lazy evaluation: FALSE
[16:19:29.658] Asynchronous evaluation: FALSE
[16:19:29.658] Local evaluation: TRUE
[16:19:29.658] Environment: R_GlobalEnv
[16:19:29.658] Capture standard output: TRUE
[16:19:29.658] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:29.658] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:29.658] Packages: <none>
[16:19:29.658] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:29.658] Resolved: TRUE
[16:19:29.658] Value: 224 bytes of class ‘list’
[16:19:29.658] Early signaling: FALSE
[16:19:29.658] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:29.658] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:29.659] Chunk #1 of 1 ... DONE
[16:19:29.659] Launching 1 futures (chunks) ... DONE
[16:19:29.660] Resolving 1 futures (chunks) ...
[16:19:29.660] resolve() on list ...
[16:19:29.660]  recursive: 0
[16:19:29.660]  length: 1
[16:19:29.660] 
[16:19:29.660] resolved() for ‘SequentialFuture’ ...
[16:19:29.660] - state: ‘finished’
[16:19:29.660] - run: TRUE
[16:19:29.660] - result: ‘FutureResult’
[16:19:29.660] resolved() for ‘SequentialFuture’ ... done
[16:19:29.661] Future #1
[16:19:29.661] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:29.661] - nx: 1
[16:19:29.661] - relay: TRUE
[16:19:29.661] - stdout: TRUE
[16:19:29.661] - signal: TRUE
[16:19:29.661] - resignal: FALSE
[16:19:29.661] - force: TRUE
[16:19:29.661] - relayed: [n=1] FALSE
[16:19:29.661] - queued futures: [n=1] FALSE
[16:19:29.662]  - until=1
[16:19:29.662]  - relaying element #1
[16:19:29.662] - relayed: [n=1] TRUE
[16:19:29.662] - queued futures: [n=1] TRUE
[16:19:29.662] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:29.662]  length: 0 (resolved future 1)
[16:19:29.662] Relaying remaining futures
[16:19:29.662] signalConditionsASAP(NULL, pos=0) ...
[16:19:29.662] - nx: 1
[16:19:29.662] - relay: TRUE
[16:19:29.663] - stdout: TRUE
[16:19:29.663] - signal: TRUE
[16:19:29.663] - resignal: FALSE
[16:19:29.663] - force: TRUE
[16:19:29.663] - relayed: [n=1] TRUE
[16:19:29.663] - queued futures: [n=1] TRUE
 - flush all
[16:19:29.663] - relayed: [n=1] TRUE
[16:19:29.663] - queued futures: [n=1] TRUE
[16:19:29.663] signalConditionsASAP(NULL, pos=0) ... done
[16:19:29.663] resolve() on list ... DONE
[16:19:29.664]  - Number of value chunks collected: 1
[16:19:29.664] Resolving 1 futures (chunks) ... DONE
[16:19:29.664] Reducing values from 1 chunks ...
[16:19:29.664]  - Number of values collected after concatenation: 2
[16:19:29.664]  - Number of values expected: 2
[16:19:29.664] Reducing values from 1 chunks ... DONE
[16:19:29.664] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:19:29.664] future_mapply() ...
[16:19:29.665] Number of chunks: 1
[16:19:29.665] getGlobalsAndPackagesXApply() ...
[16:19:29.665]  - future.globals: TRUE
[16:19:29.665] getGlobalsAndPackages() ...
[16:19:29.665] Searching for globals...
[16:19:29.667] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:29.667] Searching for globals ... DONE
[16:19:29.667] Resolving globals: FALSE
[16:19:29.667] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:29.668] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:29.668] - globals: [1] ‘FUN’
[16:19:29.668] 
[16:19:29.668] getGlobalsAndPackages() ... DONE
[16:19:29.668]  - globals found/used: [n=1] ‘FUN’
[16:19:29.668]  - needed namespaces: [n=0] 
[16:19:29.668] Finding globals ... DONE
[16:19:29.668] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:29.668] List of 2
[16:19:29.668]  $ ...future.FUN:function (x, y)  
[16:19:29.668]  $ MoreArgs     : NULL
[16:19:29.668]  - attr(*, "where")=List of 2
[16:19:29.668]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:29.668]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:29.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:29.668]  - attr(*, "resolved")= logi FALSE
[16:19:29.668]  - attr(*, "total_size")= num NA
[16:19:29.671] Packages to be attached in all futures: [n=0] 
[16:19:29.671] getGlobalsAndPackagesXApply() ... DONE
[16:19:29.671] Number of futures (= number of chunks): 1
[16:19:29.671] Launching 1 futures (chunks) ...
[16:19:29.671] Chunk #1 of 1 ...
[16:19:29.672]  - Finding globals in '...' for chunk #1 ...
[16:19:29.672] getGlobalsAndPackages() ...
[16:19:29.672] Searching for globals...
[16:19:29.672] 
[16:19:29.672] Searching for globals ... DONE
[16:19:29.672] - globals: [0] <none>
[16:19:29.672] getGlobalsAndPackages() ... DONE
[16:19:29.673]    + additional globals found: [n=0] 
[16:19:29.673]    + additional namespaces needed: [n=0] 
[16:19:29.673]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:29.673]  - seeds: <none>
[16:19:29.673]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:29.673] getGlobalsAndPackages() ...
[16:19:29.673] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:29.673] Resolving globals: FALSE
[16:19:29.674] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:19:29.674] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:29.674] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:29.674] 
[16:19:29.674] getGlobalsAndPackages() ... DONE
[16:19:29.675] run() for ‘Future’ ...
[16:19:29.675] - state: ‘created’
[16:19:29.675] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[16:19:29.675] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:29.675] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:29.675]   - Field: ‘label’
[16:19:29.676]   - Field: ‘local’
[16:19:29.676]   - Field: ‘owner’
[16:19:29.676]   - Field: ‘envir’
[16:19:29.676]   - Field: ‘packages’
[16:19:29.676]   - Field: ‘gc’
[16:19:29.676]   - Field: ‘conditions’
[16:19:29.676]   - Field: ‘expr’
[16:19:29.676]   - Field: ‘uuid’
[16:19:29.676]   - Field: ‘seed’
[16:19:29.676]   - Field: ‘version’
[16:19:29.677]   - Field: ‘result’
[16:19:29.677]   - Field: ‘asynchronous’
[16:19:29.677]   - Field: ‘calls’
[16:19:29.677]   - Field: ‘globals’
[16:19:29.677]   - Field: ‘stdout’
[16:19:29.677]   - Field: ‘earlySignal’
[16:19:29.677]   - Field: ‘lazy’
[16:19:29.677]   - Field: ‘state’
[16:19:29.677] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:29.677] - Launch lazy future ...
[16:19:29.679] Packages needed by the future expression (n = 0): <none>
[16:19:29.679] Packages needed by future strategies (n = 0): <none>
[16:19:29.680] {
[16:19:29.680]     {
[16:19:29.680]         {
[16:19:29.680]             ...future.startTime <- base::Sys.time()
[16:19:29.680]             {
[16:19:29.680]                 {
[16:19:29.680]                   {
[16:19:29.680]                     base::local({
[16:19:29.680]                       has_future <- base::requireNamespace("future", 
[16:19:29.680]                         quietly = TRUE)
[16:19:29.680]                       if (has_future) {
[16:19:29.680]                         ns <- base::getNamespace("future")
[16:19:29.680]                         version <- ns[[".package"]][["version"]]
[16:19:29.680]                         if (is.null(version)) 
[16:19:29.680]                           version <- utils::packageVersion("future")
[16:19:29.680]                       }
[16:19:29.680]                       else {
[16:19:29.680]                         version <- NULL
[16:19:29.680]                       }
[16:19:29.680]                       if (!has_future || version < "1.8.0") {
[16:19:29.680]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:29.680]                           "", base::R.version$version.string), 
[16:19:29.680]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:29.680]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:29.680]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:29.680]                             "release", "version")], collapse = " "), 
[16:19:29.680]                           hostname = base::Sys.info()[["nodename"]])
[16:19:29.680]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:29.680]                           info)
[16:19:29.680]                         info <- base::paste(info, collapse = "; ")
[16:19:29.680]                         if (!has_future) {
[16:19:29.680]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:29.680]                             info)
[16:19:29.680]                         }
[16:19:29.680]                         else {
[16:19:29.680]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:29.680]                             info, version)
[16:19:29.680]                         }
[16:19:29.680]                         base::stop(msg)
[16:19:29.680]                       }
[16:19:29.680]                     })
[16:19:29.680]                   }
[16:19:29.680]                   ...future.strategy.old <- future::plan("list")
[16:19:29.680]                   options(future.plan = NULL)
[16:19:29.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:29.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:29.680]                 }
[16:19:29.680]                 ...future.workdir <- getwd()
[16:19:29.680]             }
[16:19:29.680]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:29.680]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:29.680]         }
[16:19:29.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:29.680]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:29.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:29.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:29.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:29.680]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:29.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:29.680]             base::names(...future.oldOptions))
[16:19:29.680]     }
[16:19:29.680]     if (TRUE) {
[16:19:29.680]     }
[16:19:29.680]     else {
[16:19:29.680]         if (NA) {
[16:19:29.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:29.680]                 open = "w")
[16:19:29.680]         }
[16:19:29.680]         else {
[16:19:29.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:29.680]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:29.680]         }
[16:19:29.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:29.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:29.680]             base::sink(type = "output", split = FALSE)
[16:19:29.680]             base::close(...future.stdout)
[16:19:29.680]         }, add = TRUE)
[16:19:29.680]     }
[16:19:29.680]     ...future.frame <- base::sys.nframe()
[16:19:29.680]     ...future.conditions <- base::list()
[16:19:29.680]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:29.680]     if (FALSE) {
[16:19:29.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:29.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:29.680]     }
[16:19:29.680]     ...future.result <- base::tryCatch({
[16:19:29.680]         base::withCallingHandlers({
[16:19:29.680]             ...future.value <- base::withVisible(base::local({
[16:19:29.680]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:29.680]                 if (!identical(...future.globals.maxSize.org, 
[16:19:29.680]                   ...future.globals.maxSize)) {
[16:19:29.680]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:29.680]                   on.exit(options(oopts), add = TRUE)
[16:19:29.680]                 }
[16:19:29.680]                 {
[16:19:29.680]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:29.680]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:29.680]                     USE.NAMES = FALSE)
[16:19:29.680]                   do.call(mapply, args = args)
[16:19:29.680]                 }
[16:19:29.680]             }))
[16:19:29.680]             future::FutureResult(value = ...future.value$value, 
[16:19:29.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:29.680]                   ...future.rng), globalenv = if (FALSE) 
[16:19:29.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:29.680]                     ...future.globalenv.names))
[16:19:29.680]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:29.680]         }, condition = base::local({
[16:19:29.680]             c <- base::c
[16:19:29.680]             inherits <- base::inherits
[16:19:29.680]             invokeRestart <- base::invokeRestart
[16:19:29.680]             length <- base::length
[16:19:29.680]             list <- base::list
[16:19:29.680]             seq.int <- base::seq.int
[16:19:29.680]             signalCondition <- base::signalCondition
[16:19:29.680]             sys.calls <- base::sys.calls
[16:19:29.680]             `[[` <- base::`[[`
[16:19:29.680]             `+` <- base::`+`
[16:19:29.680]             `<<-` <- base::`<<-`
[16:19:29.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:29.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:29.680]                   3L)]
[16:19:29.680]             }
[16:19:29.680]             function(cond) {
[16:19:29.680]                 is_error <- inherits(cond, "error")
[16:19:29.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:29.680]                   NULL)
[16:19:29.680]                 if (is_error) {
[16:19:29.680]                   sessionInformation <- function() {
[16:19:29.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:29.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:29.680]                       search = base::search(), system = base::Sys.info())
[16:19:29.680]                   }
[16:19:29.680]                   ...future.conditions[[length(...future.conditions) + 
[16:19:29.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:29.680]                     cond$call), session = sessionInformation(), 
[16:19:29.680]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:29.680]                   signalCondition(cond)
[16:19:29.680]                 }
[16:19:29.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:29.680]                 "immediateCondition"))) {
[16:19:29.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:29.680]                   ...future.conditions[[length(...future.conditions) + 
[16:19:29.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:29.680]                   if (TRUE && !signal) {
[16:19:29.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:29.680]                     {
[16:19:29.680]                       inherits <- base::inherits
[16:19:29.680]                       invokeRestart <- base::invokeRestart
[16:19:29.680]                       is.null <- base::is.null
[16:19:29.680]                       muffled <- FALSE
[16:19:29.680]                       if (inherits(cond, "message")) {
[16:19:29.680]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:29.680]                         if (muffled) 
[16:19:29.680]                           invokeRestart("muffleMessage")
[16:19:29.680]                       }
[16:19:29.680]                       else if (inherits(cond, "warning")) {
[16:19:29.680]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:29.680]                         if (muffled) 
[16:19:29.680]                           invokeRestart("muffleWarning")
[16:19:29.680]                       }
[16:19:29.680]                       else if (inherits(cond, "condition")) {
[16:19:29.680]                         if (!is.null(pattern)) {
[16:19:29.680]                           computeRestarts <- base::computeRestarts
[16:19:29.680]                           grepl <- base::grepl
[16:19:29.680]                           restarts <- computeRestarts(cond)
[16:19:29.680]                           for (restart in restarts) {
[16:19:29.680]                             name <- restart$name
[16:19:29.680]                             if (is.null(name)) 
[16:19:29.680]                               next
[16:19:29.680]                             if (!grepl(pattern, name)) 
[16:19:29.680]                               next
[16:19:29.680]                             invokeRestart(restart)
[16:19:29.680]                             muffled <- TRUE
[16:19:29.680]                             break
[16:19:29.680]                           }
[16:19:29.680]                         }
[16:19:29.680]                       }
[16:19:29.680]                       invisible(muffled)
[16:19:29.680]                     }
[16:19:29.680]                     muffleCondition(cond, pattern = "^muffle")
[16:19:29.680]                   }
[16:19:29.680]                 }
[16:19:29.680]                 else {
[16:19:29.680]                   if (TRUE) {
[16:19:29.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:29.680]                     {
[16:19:29.680]                       inherits <- base::inherits
[16:19:29.680]                       invokeRestart <- base::invokeRestart
[16:19:29.680]                       is.null <- base::is.null
[16:19:29.680]                       muffled <- FALSE
[16:19:29.680]                       if (inherits(cond, "message")) {
[16:19:29.680]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:29.680]                         if (muffled) 
[16:19:29.680]                           invokeRestart("muffleMessage")
[16:19:29.680]                       }
[16:19:29.680]                       else if (inherits(cond, "warning")) {
[16:19:29.680]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:29.680]                         if (muffled) 
[16:19:29.680]                           invokeRestart("muffleWarning")
[16:19:29.680]                       }
[16:19:29.680]                       else if (inherits(cond, "condition")) {
[16:19:29.680]                         if (!is.null(pattern)) {
[16:19:29.680]                           computeRestarts <- base::computeRestarts
[16:19:29.680]                           grepl <- base::grepl
[16:19:29.680]                           restarts <- computeRestarts(cond)
[16:19:29.680]                           for (restart in restarts) {
[16:19:29.680]                             name <- restart$name
[16:19:29.680]                             if (is.null(name)) 
[16:19:29.680]                               next
[16:19:29.680]                             if (!grepl(pattern, name)) 
[16:19:29.680]                               next
[16:19:29.680]                             invokeRestart(restart)
[16:19:29.680]                             muffled <- TRUE
[16:19:29.680]                             break
[16:19:29.680]                           }
[16:19:29.680]                         }
[16:19:29.680]                       }
[16:19:29.680]                       invisible(muffled)
[16:19:29.680]                     }
[16:19:29.680]                     muffleCondition(cond, pattern = "^muffle")
[16:19:29.680]                   }
[16:19:29.680]                 }
[16:19:29.680]             }
[16:19:29.680]         }))
[16:19:29.680]     }, error = function(ex) {
[16:19:29.680]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:29.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:29.680]                 ...future.rng), started = ...future.startTime, 
[16:19:29.680]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:29.680]             version = "1.8"), class = "FutureResult")
[16:19:29.680]     }, finally = {
[16:19:29.680]         if (!identical(...future.workdir, getwd())) 
[16:19:29.680]             setwd(...future.workdir)
[16:19:29.680]         {
[16:19:29.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:29.680]                 ...future.oldOptions$nwarnings <- NULL
[16:19:29.680]             }
[16:19:29.680]             base::options(...future.oldOptions)
[16:19:29.680]             if (.Platform$OS.type == "windows") {
[16:19:29.680]                 old_names <- names(...future.oldEnvVars)
[16:19:29.680]                 envs <- base::Sys.getenv()
[16:19:29.680]                 names <- names(envs)
[16:19:29.680]                 common <- intersect(names, old_names)
[16:19:29.680]                 added <- setdiff(names, old_names)
[16:19:29.680]                 removed <- setdiff(old_names, names)
[16:19:29.680]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:29.680]                   envs[common]]
[16:19:29.680]                 NAMES <- toupper(changed)
[16:19:29.680]                 args <- list()
[16:19:29.680]                 for (kk in seq_along(NAMES)) {
[16:19:29.680]                   name <- changed[[kk]]
[16:19:29.680]                   NAME <- NAMES[[kk]]
[16:19:29.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:29.680]                     next
[16:19:29.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:29.680]                 }
[16:19:29.680]                 NAMES <- toupper(added)
[16:19:29.680]                 for (kk in seq_along(NAMES)) {
[16:19:29.680]                   name <- added[[kk]]
[16:19:29.680]                   NAME <- NAMES[[kk]]
[16:19:29.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:29.680]                     next
[16:19:29.680]                   args[[name]] <- ""
[16:19:29.680]                 }
[16:19:29.680]                 NAMES <- toupper(removed)
[16:19:29.680]                 for (kk in seq_along(NAMES)) {
[16:19:29.680]                   name <- removed[[kk]]
[16:19:29.680]                   NAME <- NAMES[[kk]]
[16:19:29.680]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:29.680]                     next
[16:19:29.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:29.680]                 }
[16:19:29.680]                 if (length(args) > 0) 
[16:19:29.680]                   base::do.call(base::Sys.setenv, args = args)
[16:19:29.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:29.680]             }
[16:19:29.680]             else {
[16:19:29.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:29.680]             }
[16:19:29.680]             {
[16:19:29.680]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:29.680]                   0L) {
[16:19:29.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:29.680]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:29.680]                   base::options(opts)
[16:19:29.680]                 }
[16:19:29.680]                 {
[16:19:29.680]                   {
[16:19:29.680]                     NULL
[16:19:29.680]                     RNGkind("Mersenne-Twister")
[16:19:29.680]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:29.680]                       inherits = FALSE)
[16:19:29.680]                   }
[16:19:29.680]                   options(future.plan = NULL)
[16:19:29.680]                   if (is.na(NA_character_)) 
[16:19:29.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:29.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:29.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:29.680]                     .init = FALSE)
[16:19:29.680]                 }
[16:19:29.680]             }
[16:19:29.680]         }
[16:19:29.680]     })
[16:19:29.680]     if (FALSE) {
[16:19:29.680]         base::sink(type = "output", split = FALSE)
[16:19:29.680]         if (NA) {
[16:19:29.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:29.680]         }
[16:19:29.680]         else {
[16:19:29.680]             ...future.result["stdout"] <- base::list(NULL)
[16:19:29.680]         }
[16:19:29.680]         base::close(...future.stdout)
[16:19:29.680]         ...future.stdout <- NULL
[16:19:29.680]     }
[16:19:29.680]     ...future.result$conditions <- ...future.conditions
[16:19:29.680]     ...future.result$finished <- base::Sys.time()
[16:19:29.680]     ...future.result
[16:19:29.680] }
[16:19:29.682] assign_globals() ...
[16:19:29.682] List of 5
[16:19:29.682]  $ ...future.FUN            :function (x, y)  
[16:19:29.682]  $ MoreArgs                 : NULL
[16:19:29.682]  $ ...future.elements_ii    :List of 2
[16:19:29.682]   ..$ :List of 2
[16:19:29.682]   .. ..$ : int 1
[16:19:29.682]   .. ..$ : int 0
[16:19:29.682]   ..$ :List of 2
[16:19:29.682]   .. ..$ : int 0
[16:19:29.682]   .. ..$ : int 1
[16:19:29.682]  $ ...future.seeds_ii       : NULL
[16:19:29.682]  $ ...future.globals.maxSize: NULL
[16:19:29.682]  - attr(*, "where")=List of 5
[16:19:29.682]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:29.682]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:29.682]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:29.682]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:29.682]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:29.682]  - attr(*, "resolved")= logi FALSE
[16:19:29.682]  - attr(*, "total_size")= num 6480
[16:19:29.682]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:29.682]  - attr(*, "already-done")= logi TRUE
[16:19:29.687] - reassign environment for ‘...future.FUN’
[16:19:29.687] - copied ‘...future.FUN’ to environment
[16:19:29.687] - copied ‘MoreArgs’ to environment
[16:19:29.687] - copied ‘...future.elements_ii’ to environment
[16:19:29.688] - copied ‘...future.seeds_ii’ to environment
[16:19:29.688] - copied ‘...future.globals.maxSize’ to environment
[16:19:29.688] assign_globals() ... done
[16:19:29.688] plan(): Setting new future strategy stack:
[16:19:29.688] List of future strategies:
[16:19:29.688] 1. sequential:
[16:19:29.688]    - args: function (..., envir = parent.frame())
[16:19:29.688]    - tweaked: FALSE
[16:19:29.688]    - call: NULL
[16:19:29.688] plan(): nbrOfWorkers() = 1
[16:19:30.190] plan(): Setting new future strategy stack:
[16:19:30.190] List of future strategies:
[16:19:30.190] 1. sequential:
[16:19:30.190]    - args: function (..., envir = parent.frame())
[16:19:30.190]    - tweaked: FALSE
[16:19:30.190]    - call: plan(strategy)
[16:19:30.191] plan(): nbrOfWorkers() = 1
[16:19:30.191] SequentialFuture started (and completed)
[16:19:30.191] - Launch lazy future ... done
[16:19:30.191] run() for ‘SequentialFuture’ ... done
[16:19:30.191] Created future:
[16:19:30.191] SequentialFuture:
[16:19:30.191] Label: ‘future_mapply-1’
[16:19:30.191] Expression:
[16:19:30.191] {
[16:19:30.191]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:30.191]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:30.191]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:30.191]         on.exit(options(oopts), add = TRUE)
[16:19:30.191]     }
[16:19:30.191]     {
[16:19:30.191]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:30.191]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:30.191]         do.call(mapply, args = args)
[16:19:30.191]     }
[16:19:30.191] }
[16:19:30.191] Lazy evaluation: FALSE
[16:19:30.191] Asynchronous evaluation: FALSE
[16:19:30.191] Local evaluation: TRUE
[16:19:30.191] Environment: R_GlobalEnv
[16:19:30.191] Capture standard output: NA
[16:19:30.191] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:30.191] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:30.191] Packages: <none>
[16:19:30.191] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:30.191] Resolved: TRUE
[16:19:30.191] Value: 224 bytes of class ‘list’
[16:19:30.191] Early signaling: FALSE
[16:19:30.191] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:30.191] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:30.192] Chunk #1 of 1 ... DONE
[16:19:30.192] Launching 1 futures (chunks) ... DONE
[16:19:30.193] Resolving 1 futures (chunks) ...
[16:19:30.193] resolve() on list ...
[16:19:30.193]  recursive: 0
[16:19:30.193]  length: 1
[16:19:30.193] 
[16:19:30.193] resolved() for ‘SequentialFuture’ ...
[16:19:30.193] - state: ‘finished’
[16:19:30.193] - run: TRUE
[16:19:30.193] - result: ‘FutureResult’
[16:19:30.193] resolved() for ‘SequentialFuture’ ... done
[16:19:30.194] Future #1
[16:19:30.194] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:30.194] - nx: 1
[16:19:30.194] - relay: TRUE
[16:19:30.194] - stdout: TRUE
[16:19:30.194] - signal: TRUE
[16:19:30.194] - resignal: FALSE
[16:19:30.194] - force: TRUE
[16:19:30.194] - relayed: [n=1] FALSE
[16:19:30.194] - queued futures: [n=1] FALSE
[16:19:30.194]  - until=1
[16:19:30.195]  - relaying element #1
[16:19:30.195] - relayed: [n=1] TRUE
[16:19:30.195] - queued futures: [n=1] TRUE
[16:19:30.195] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:30.195]  length: 0 (resolved future 1)
[16:19:30.195] Relaying remaining futures
[16:19:30.195] signalConditionsASAP(NULL, pos=0) ...
[16:19:30.195] - nx: 1
[16:19:30.195] - relay: TRUE
[16:19:30.195] - stdout: TRUE
[16:19:30.195] - signal: TRUE
[16:19:30.196] - resignal: FALSE
[16:19:30.196] - force: TRUE
[16:19:30.196] - relayed: [n=1] TRUE
[16:19:30.196] - queued futures: [n=1] TRUE
 - flush all
[16:19:30.196] - relayed: [n=1] TRUE
[16:19:30.196] - queued futures: [n=1] TRUE
[16:19:30.196] signalConditionsASAP(NULL, pos=0) ... done
[16:19:30.196] resolve() on list ... DONE
[16:19:30.196]  - Number of value chunks collected: 1
[16:19:30.196] Resolving 1 futures (chunks) ... DONE
[16:19:30.197] Reducing values from 1 chunks ...
[16:19:30.197]  - Number of values collected after concatenation: 2
[16:19:30.197]  - Number of values expected: 2
[16:19:30.197] Reducing values from 1 chunks ... DONE
[16:19:30.197] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('sequential') ... DONE
* plan('multicore') ...
[16:19:30.198] plan(): Setting new future strategy stack:
[16:19:30.198] List of future strategies:
[16:19:30.198] 1. multicore:
[16:19:30.198]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:30.198]    - tweaked: FALSE
[16:19:30.198]    - call: plan(strategy)
[16:19:30.202] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:19:30.202] future_lapply() ...
[16:19:30.206] Number of chunks: 1
[16:19:30.206] getGlobalsAndPackagesXApply() ...
[16:19:30.206]  - future.globals: TRUE
[16:19:30.206] getGlobalsAndPackages() ...
[16:19:30.206] Searching for globals...
[16:19:30.207] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:30.208] Searching for globals ... DONE
[16:19:30.208] Resolving globals: FALSE
[16:19:30.208] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:30.209] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:30.209] - globals: [1] ‘FUN’
[16:19:30.209] 
[16:19:30.209] getGlobalsAndPackages() ... DONE
[16:19:30.211]  - globals found/used: [n=1] ‘FUN’
[16:19:30.211]  - needed namespaces: [n=0] 
[16:19:30.211] Finding globals ... DONE
[16:19:30.211]  - use_args: TRUE
[16:19:30.211]  - Getting '...' globals ...
[16:19:30.211] resolve() on list ...
[16:19:30.211]  recursive: 0
[16:19:30.212]  length: 1
[16:19:30.212]  elements: ‘...’
[16:19:30.212]  length: 0 (resolved future 1)
[16:19:30.212] resolve() on list ... DONE
[16:19:30.212]    - '...' content: [n=0] 
[16:19:30.212] List of 1
[16:19:30.212]  $ ...: list()
[16:19:30.212]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:30.212]  - attr(*, "where")=List of 1
[16:19:30.212]   ..$ ...:<environment: 0x563562c0b830> 
[16:19:30.212]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:30.212]  - attr(*, "resolved")= logi TRUE
[16:19:30.212]  - attr(*, "total_size")= num NA
[16:19:30.215]  - Getting '...' globals ... DONE
[16:19:30.215] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:30.215] List of 2
[16:19:30.215]  $ ...future.FUN:function (x)  
[16:19:30.215]  $ ...          : list()
[16:19:30.215]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:30.215]  - attr(*, "where")=List of 2
[16:19:30.215]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:30.215]   ..$ ...          :<environment: 0x563562c0b830> 
[16:19:30.215]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:30.215]  - attr(*, "resolved")= logi FALSE
[16:19:30.215]  - attr(*, "total_size")= num 4720
[16:19:30.218] Packages to be attached in all futures: [n=0] 
[16:19:30.218] getGlobalsAndPackagesXApply() ... DONE
[16:19:30.218] Number of futures (= number of chunks): 1
[16:19:30.218] Launching 1 futures (chunks) ...
[16:19:30.218] Chunk #1 of 1 ...
[16:19:30.218]  - Finding globals in 'X' for chunk #1 ...
[16:19:30.218] getGlobalsAndPackages() ...
[16:19:30.218] Searching for globals...
[16:19:30.219] 
[16:19:30.219] Searching for globals ... DONE
[16:19:30.219] - globals: [0] <none>
[16:19:30.219] getGlobalsAndPackages() ... DONE
[16:19:30.219]    + additional globals found: [n=0] 
[16:19:30.219]    + additional namespaces needed: [n=0] 
[16:19:30.219]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:30.219]  - seeds: <none>
[16:19:30.219]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:30.219] getGlobalsAndPackages() ...
[16:19:30.220] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:30.220] Resolving globals: FALSE
[16:19:30.220] Tweak future expression to call with '...' arguments ...
[16:19:30.220] {
[16:19:30.220]     do.call(function(...) {
[16:19:30.220]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:30.220]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:30.220]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:30.220]             on.exit(options(oopts), add = TRUE)
[16:19:30.220]         }
[16:19:30.220]         {
[16:19:30.220]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:30.220]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:30.220]                 ...future.FUN(...future.X_jj, ...)
[16:19:30.220]             })
[16:19:30.220]         }
[16:19:30.220]     }, args = future.call.arguments)
[16:19:30.220] }
[16:19:30.220] Tweak future expression to call with '...' arguments ... DONE
[16:19:30.220] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:30.221] 
[16:19:30.221] getGlobalsAndPackages() ... DONE
[16:19:30.221] run() for ‘Future’ ...
[16:19:30.221] - state: ‘created’
[16:19:30.221] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:30.225] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:30.225] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:30.225]   - Field: ‘label’
[16:19:30.225]   - Field: ‘local’
[16:19:30.225]   - Field: ‘owner’
[16:19:30.225]   - Field: ‘envir’
[16:19:30.225]   - Field: ‘packages’
[16:19:30.225]   - Field: ‘gc’
[16:19:30.225]   - Field: ‘conditions’
[16:19:30.225]   - Field: ‘expr’
[16:19:30.226]   - Field: ‘uuid’
[16:19:30.226]   - Field: ‘seed’
[16:19:30.226]   - Field: ‘version’
[16:19:30.226]   - Field: ‘result’
[16:19:30.226]   - Field: ‘asynchronous’
[16:19:30.226]   - Field: ‘calls’
[16:19:30.226]   - Field: ‘globals’
[16:19:30.226]   - Field: ‘stdout’
[16:19:30.226]   - Field: ‘earlySignal’
[16:19:30.226]   - Field: ‘lazy’
[16:19:30.226]   - Field: ‘state’
[16:19:30.227] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:30.227] - Launch lazy future ...
[16:19:30.227] Packages needed by the future expression (n = 0): <none>
[16:19:30.227] Packages needed by future strategies (n = 0): <none>
[16:19:30.227] {
[16:19:30.227]     {
[16:19:30.227]         {
[16:19:30.227]             ...future.startTime <- base::Sys.time()
[16:19:30.227]             {
[16:19:30.227]                 {
[16:19:30.227]                   {
[16:19:30.227]                     base::local({
[16:19:30.227]                       has_future <- base::requireNamespace("future", 
[16:19:30.227]                         quietly = TRUE)
[16:19:30.227]                       if (has_future) {
[16:19:30.227]                         ns <- base::getNamespace("future")
[16:19:30.227]                         version <- ns[[".package"]][["version"]]
[16:19:30.227]                         if (is.null(version)) 
[16:19:30.227]                           version <- utils::packageVersion("future")
[16:19:30.227]                       }
[16:19:30.227]                       else {
[16:19:30.227]                         version <- NULL
[16:19:30.227]                       }
[16:19:30.227]                       if (!has_future || version < "1.8.0") {
[16:19:30.227]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:30.227]                           "", base::R.version$version.string), 
[16:19:30.227]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:30.227]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:30.227]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:30.227]                             "release", "version")], collapse = " "), 
[16:19:30.227]                           hostname = base::Sys.info()[["nodename"]])
[16:19:30.227]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:30.227]                           info)
[16:19:30.227]                         info <- base::paste(info, collapse = "; ")
[16:19:30.227]                         if (!has_future) {
[16:19:30.227]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:30.227]                             info)
[16:19:30.227]                         }
[16:19:30.227]                         else {
[16:19:30.227]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:30.227]                             info, version)
[16:19:30.227]                         }
[16:19:30.227]                         base::stop(msg)
[16:19:30.227]                       }
[16:19:30.227]                     })
[16:19:30.227]                   }
[16:19:30.227]                   ...future.strategy.old <- future::plan("list")
[16:19:30.227]                   options(future.plan = NULL)
[16:19:30.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:30.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:30.227]                 }
[16:19:30.227]                 ...future.workdir <- getwd()
[16:19:30.227]             }
[16:19:30.227]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:30.227]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:30.227]         }
[16:19:30.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:30.227]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:30.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:30.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:30.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:30.227]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:30.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:30.227]             base::names(...future.oldOptions))
[16:19:30.227]     }
[16:19:30.227]     if (FALSE) {
[16:19:30.227]     }
[16:19:30.227]     else {
[16:19:30.227]         if (FALSE) {
[16:19:30.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:30.227]                 open = "w")
[16:19:30.227]         }
[16:19:30.227]         else {
[16:19:30.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:30.227]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:30.227]         }
[16:19:30.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:30.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:30.227]             base::sink(type = "output", split = FALSE)
[16:19:30.227]             base::close(...future.stdout)
[16:19:30.227]         }, add = TRUE)
[16:19:30.227]     }
[16:19:30.227]     ...future.frame <- base::sys.nframe()
[16:19:30.227]     ...future.conditions <- base::list()
[16:19:30.227]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:30.227]     if (FALSE) {
[16:19:30.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:30.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:30.227]     }
[16:19:30.227]     ...future.result <- base::tryCatch({
[16:19:30.227]         base::withCallingHandlers({
[16:19:30.227]             ...future.value <- base::withVisible(base::local({
[16:19:30.227]                 do.call(function(...) {
[16:19:30.227]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:30.227]                   if (!identical(...future.globals.maxSize.org, 
[16:19:30.227]                     ...future.globals.maxSize)) {
[16:19:30.227]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:30.227]                     on.exit(options(oopts), add = TRUE)
[16:19:30.227]                   }
[16:19:30.227]                   {
[16:19:30.227]                     lapply(seq_along(...future.elements_ii), 
[16:19:30.227]                       FUN = function(jj) {
[16:19:30.227]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:30.227]                         ...future.FUN(...future.X_jj, ...)
[16:19:30.227]                       })
[16:19:30.227]                   }
[16:19:30.227]                 }, args = future.call.arguments)
[16:19:30.227]             }))
[16:19:30.227]             future::FutureResult(value = ...future.value$value, 
[16:19:30.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:30.227]                   ...future.rng), globalenv = if (FALSE) 
[16:19:30.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:30.227]                     ...future.globalenv.names))
[16:19:30.227]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:30.227]         }, condition = base::local({
[16:19:30.227]             c <- base::c
[16:19:30.227]             inherits <- base::inherits
[16:19:30.227]             invokeRestart <- base::invokeRestart
[16:19:30.227]             length <- base::length
[16:19:30.227]             list <- base::list
[16:19:30.227]             seq.int <- base::seq.int
[16:19:30.227]             signalCondition <- base::signalCondition
[16:19:30.227]             sys.calls <- base::sys.calls
[16:19:30.227]             `[[` <- base::`[[`
[16:19:30.227]             `+` <- base::`+`
[16:19:30.227]             `<<-` <- base::`<<-`
[16:19:30.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:30.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:30.227]                   3L)]
[16:19:30.227]             }
[16:19:30.227]             function(cond) {
[16:19:30.227]                 is_error <- inherits(cond, "error")
[16:19:30.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:30.227]                   NULL)
[16:19:30.227]                 if (is_error) {
[16:19:30.227]                   sessionInformation <- function() {
[16:19:30.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:30.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:30.227]                       search = base::search(), system = base::Sys.info())
[16:19:30.227]                   }
[16:19:30.227]                   ...future.conditions[[length(...future.conditions) + 
[16:19:30.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:30.227]                     cond$call), session = sessionInformation(), 
[16:19:30.227]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:30.227]                   signalCondition(cond)
[16:19:30.227]                 }
[16:19:30.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:30.227]                 "immediateCondition"))) {
[16:19:30.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:30.227]                   ...future.conditions[[length(...future.conditions) + 
[16:19:30.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:30.227]                   if (TRUE && !signal) {
[16:19:30.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:30.227]                     {
[16:19:30.227]                       inherits <- base::inherits
[16:19:30.227]                       invokeRestart <- base::invokeRestart
[16:19:30.227]                       is.null <- base::is.null
[16:19:30.227]                       muffled <- FALSE
[16:19:30.227]                       if (inherits(cond, "message")) {
[16:19:30.227]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:30.227]                         if (muffled) 
[16:19:30.227]                           invokeRestart("muffleMessage")
[16:19:30.227]                       }
[16:19:30.227]                       else if (inherits(cond, "warning")) {
[16:19:30.227]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:30.227]                         if (muffled) 
[16:19:30.227]                           invokeRestart("muffleWarning")
[16:19:30.227]                       }
[16:19:30.227]                       else if (inherits(cond, "condition")) {
[16:19:30.227]                         if (!is.null(pattern)) {
[16:19:30.227]                           computeRestarts <- base::computeRestarts
[16:19:30.227]                           grepl <- base::grepl
[16:19:30.227]                           restarts <- computeRestarts(cond)
[16:19:30.227]                           for (restart in restarts) {
[16:19:30.227]                             name <- restart$name
[16:19:30.227]                             if (is.null(name)) 
[16:19:30.227]                               next
[16:19:30.227]                             if (!grepl(pattern, name)) 
[16:19:30.227]                               next
[16:19:30.227]                             invokeRestart(restart)
[16:19:30.227]                             muffled <- TRUE
[16:19:30.227]                             break
[16:19:30.227]                           }
[16:19:30.227]                         }
[16:19:30.227]                       }
[16:19:30.227]                       invisible(muffled)
[16:19:30.227]                     }
[16:19:30.227]                     muffleCondition(cond, pattern = "^muffle")
[16:19:30.227]                   }
[16:19:30.227]                 }
[16:19:30.227]                 else {
[16:19:30.227]                   if (TRUE) {
[16:19:30.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:30.227]                     {
[16:19:30.227]                       inherits <- base::inherits
[16:19:30.227]                       invokeRestart <- base::invokeRestart
[16:19:30.227]                       is.null <- base::is.null
[16:19:30.227]                       muffled <- FALSE
[16:19:30.227]                       if (inherits(cond, "message")) {
[16:19:30.227]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:30.227]                         if (muffled) 
[16:19:30.227]                           invokeRestart("muffleMessage")
[16:19:30.227]                       }
[16:19:30.227]                       else if (inherits(cond, "warning")) {
[16:19:30.227]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:30.227]                         if (muffled) 
[16:19:30.227]                           invokeRestart("muffleWarning")
[16:19:30.227]                       }
[16:19:30.227]                       else if (inherits(cond, "condition")) {
[16:19:30.227]                         if (!is.null(pattern)) {
[16:19:30.227]                           computeRestarts <- base::computeRestarts
[16:19:30.227]                           grepl <- base::grepl
[16:19:30.227]                           restarts <- computeRestarts(cond)
[16:19:30.227]                           for (restart in restarts) {
[16:19:30.227]                             name <- restart$name
[16:19:30.227]                             if (is.null(name)) 
[16:19:30.227]                               next
[16:19:30.227]                             if (!grepl(pattern, name)) 
[16:19:30.227]                               next
[16:19:30.227]                             invokeRestart(restart)
[16:19:30.227]                             muffled <- TRUE
[16:19:30.227]                             break
[16:19:30.227]                           }
[16:19:30.227]                         }
[16:19:30.227]                       }
[16:19:30.227]                       invisible(muffled)
[16:19:30.227]                     }
[16:19:30.227]                     muffleCondition(cond, pattern = "^muffle")
[16:19:30.227]                   }
[16:19:30.227]                 }
[16:19:30.227]             }
[16:19:30.227]         }))
[16:19:30.227]     }, error = function(ex) {
[16:19:30.227]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:30.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:30.227]                 ...future.rng), started = ...future.startTime, 
[16:19:30.227]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:30.227]             version = "1.8"), class = "FutureResult")
[16:19:30.227]     }, finally = {
[16:19:30.227]         if (!identical(...future.workdir, getwd())) 
[16:19:30.227]             setwd(...future.workdir)
[16:19:30.227]         {
[16:19:30.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:30.227]                 ...future.oldOptions$nwarnings <- NULL
[16:19:30.227]             }
[16:19:30.227]             base::options(...future.oldOptions)
[16:19:30.227]             if (.Platform$OS.type == "windows") {
[16:19:30.227]                 old_names <- names(...future.oldEnvVars)
[16:19:30.227]                 envs <- base::Sys.getenv()
[16:19:30.227]                 names <- names(envs)
[16:19:30.227]                 common <- intersect(names, old_names)
[16:19:30.227]                 added <- setdiff(names, old_names)
[16:19:30.227]                 removed <- setdiff(old_names, names)
[16:19:30.227]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:30.227]                   envs[common]]
[16:19:30.227]                 NAMES <- toupper(changed)
[16:19:30.227]                 args <- list()
[16:19:30.227]                 for (kk in seq_along(NAMES)) {
[16:19:30.227]                   name <- changed[[kk]]
[16:19:30.227]                   NAME <- NAMES[[kk]]
[16:19:30.227]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:30.227]                     next
[16:19:30.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:30.227]                 }
[16:19:30.227]                 NAMES <- toupper(added)
[16:19:30.227]                 for (kk in seq_along(NAMES)) {
[16:19:30.227]                   name <- added[[kk]]
[16:19:30.227]                   NAME <- NAMES[[kk]]
[16:19:30.227]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:30.227]                     next
[16:19:30.227]                   args[[name]] <- ""
[16:19:30.227]                 }
[16:19:30.227]                 NAMES <- toupper(removed)
[16:19:30.227]                 for (kk in seq_along(NAMES)) {
[16:19:30.227]                   name <- removed[[kk]]
[16:19:30.227]                   NAME <- NAMES[[kk]]
[16:19:30.227]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:30.227]                     next
[16:19:30.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:30.227]                 }
[16:19:30.227]                 if (length(args) > 0) 
[16:19:30.227]                   base::do.call(base::Sys.setenv, args = args)
[16:19:30.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:30.227]             }
[16:19:30.227]             else {
[16:19:30.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:30.227]             }
[16:19:30.227]             {
[16:19:30.227]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:30.227]                   0L) {
[16:19:30.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:30.227]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:30.227]                   base::options(opts)
[16:19:30.227]                 }
[16:19:30.227]                 {
[16:19:30.227]                   {
[16:19:30.227]                     NULL
[16:19:30.227]                     RNGkind("Mersenne-Twister")
[16:19:30.227]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:30.227]                       inherits = FALSE)
[16:19:30.227]                   }
[16:19:30.227]                   options(future.plan = NULL)
[16:19:30.227]                   if (is.na(NA_character_)) 
[16:19:30.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:30.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:30.227]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:30.227]                     .init = FALSE)
[16:19:30.227]                 }
[16:19:30.227]             }
[16:19:30.227]         }
[16:19:30.227]     })
[16:19:30.227]     if (TRUE) {
[16:19:30.227]         base::sink(type = "output", split = FALSE)
[16:19:30.227]         if (FALSE) {
[16:19:30.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:30.227]         }
[16:19:30.227]         else {
[16:19:30.227]             ...future.result["stdout"] <- base::list(NULL)
[16:19:30.227]         }
[16:19:30.227]         base::close(...future.stdout)
[16:19:30.227]         ...future.stdout <- NULL
[16:19:30.227]     }
[16:19:30.227]     ...future.result$conditions <- ...future.conditions
[16:19:30.227]     ...future.result$finished <- base::Sys.time()
[16:19:30.227]     ...future.result
[16:19:30.227] }
[16:19:30.229] assign_globals() ...
[16:19:30.229] List of 5
[16:19:30.229]  $ ...future.FUN            :function (x)  
[16:19:30.229]  $ future.call.arguments    : list()
[16:19:30.229]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:30.229]  $ ...future.elements_ii    :List of 2
[16:19:30.229]   ..$ : int 1
[16:19:30.229]   ..$ : int 0
[16:19:30.229]  $ ...future.seeds_ii       : NULL
[16:19:30.229]  $ ...future.globals.maxSize: NULL
[16:19:30.229]  - attr(*, "where")=List of 5
[16:19:30.229]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:30.229]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:30.229]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:30.229]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:30.229]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:30.229]  - attr(*, "resolved")= logi FALSE
[16:19:30.229]  - attr(*, "total_size")= num 4720
[16:19:30.229]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:30.229]  - attr(*, "already-done")= logi TRUE
[16:19:30.234] - reassign environment for ‘...future.FUN’
[16:19:30.234] - copied ‘...future.FUN’ to environment
[16:19:30.234] - copied ‘future.call.arguments’ to environment
[16:19:30.234] - copied ‘...future.elements_ii’ to environment
[16:19:30.234] - copied ‘...future.seeds_ii’ to environment
[16:19:30.234] - copied ‘...future.globals.maxSize’ to environment
[16:19:30.235] assign_globals() ... done
[16:19:30.235] plan(): Setting new future strategy stack:
[16:19:30.235] List of future strategies:
[16:19:30.235] 1. sequential:
[16:19:30.235]    - args: function (..., envir = parent.frame())
[16:19:30.235]    - tweaked: FALSE
[16:19:30.235]    - call: NULL
[16:19:30.235] plan(): nbrOfWorkers() = 1
[16:19:30.739] plan(): Setting new future strategy stack:
[16:19:30.739] List of future strategies:
[16:19:30.739] 1. multicore:
[16:19:30.739]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:30.739]    - tweaked: FALSE
[16:19:30.739]    - call: plan(strategy)
[16:19:30.743] plan(): nbrOfWorkers() = 1
[16:19:30.743] SequentialFuture started (and completed)
[16:19:30.744] - Launch lazy future ... done
[16:19:30.744] run() for ‘SequentialFuture’ ... done
[16:19:30.744] Created future:
[16:19:30.744] SequentialFuture:
[16:19:30.744] Label: ‘future_lapply-1’
[16:19:30.744] Expression:
[16:19:30.744] {
[16:19:30.744]     do.call(function(...) {
[16:19:30.744]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:30.744]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:30.744]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:30.744]             on.exit(options(oopts), add = TRUE)
[16:19:30.744]         }
[16:19:30.744]         {
[16:19:30.744]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:30.744]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:30.744]                 ...future.FUN(...future.X_jj, ...)
[16:19:30.744]             })
[16:19:30.744]         }
[16:19:30.744]     }, args = future.call.arguments)
[16:19:30.744] }
[16:19:30.744] Lazy evaluation: FALSE
[16:19:30.744] Asynchronous evaluation: FALSE
[16:19:30.744] Local evaluation: TRUE
[16:19:30.744] Environment: R_GlobalEnv
[16:19:30.744] Capture standard output: FALSE
[16:19:30.744] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:30.744] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:30.744] Packages: <none>
[16:19:30.744] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:30.744] Resolved: TRUE
[16:19:30.744] Value: 112 bytes of class ‘list’
[16:19:30.744] Early signaling: FALSE
[16:19:30.744] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:30.744] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:30.745] Chunk #1 of 1 ... DONE
[16:19:30.745] Launching 1 futures (chunks) ... DONE
[16:19:30.745] Resolving 1 futures (chunks) ...
[16:19:30.745] resolve() on list ...
[16:19:30.745]  recursive: 0
[16:19:30.746]  length: 1
[16:19:30.746] 
[16:19:30.746] resolved() for ‘SequentialFuture’ ...
[16:19:30.746] - state: ‘finished’
[16:19:30.746] - run: TRUE
[16:19:30.746] - result: ‘FutureResult’
[16:19:30.746] resolved() for ‘SequentialFuture’ ... done
[16:19:30.746] Future #1
[16:19:30.746] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:30.747] - nx: 1
[16:19:30.747] - relay: TRUE
[16:19:30.747] - stdout: TRUE
[16:19:30.747] - signal: TRUE
[16:19:30.747] - resignal: FALSE
[16:19:30.747] - force: TRUE
[16:19:30.747] - relayed: [n=1] FALSE
[16:19:30.747] - queued futures: [n=1] FALSE
[16:19:30.747]  - until=1
[16:19:30.747]  - relaying element #1
[16:19:30.747] - relayed: [n=1] TRUE
[16:19:30.748] - queued futures: [n=1] TRUE
[16:19:30.748] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:30.748]  length: 0 (resolved future 1)
[16:19:30.748] Relaying remaining futures
[16:19:30.748] signalConditionsASAP(NULL, pos=0) ...
[16:19:30.748] - nx: 1
[16:19:30.748] - relay: TRUE
[16:19:30.748] - stdout: TRUE
[16:19:30.748] - signal: TRUE
[16:19:30.748] - resignal: FALSE
[16:19:30.748] - force: TRUE
[16:19:30.749] - relayed: [n=1] TRUE
[16:19:30.749] - queued futures: [n=1] TRUE
 - flush all
[16:19:30.749] - relayed: [n=1] TRUE
[16:19:30.749] - queued futures: [n=1] TRUE
[16:19:30.749] signalConditionsASAP(NULL, pos=0) ... done
[16:19:30.749] resolve() on list ... DONE
[16:19:30.749]  - Number of value chunks collected: 1
[16:19:30.749] Resolving 1 futures (chunks) ... DONE
[16:19:30.749] Reducing values from 1 chunks ...
[16:19:30.749]  - Number of values collected after concatenation: 2
[16:19:30.750]  - Number of values expected: 2
[16:19:30.750] Reducing values from 1 chunks ... DONE
[16:19:30.750] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:19:30.750] future_lapply() ...
[16:19:30.754] Number of chunks: 1
[16:19:30.754] getGlobalsAndPackagesXApply() ...
[16:19:30.754]  - future.globals: TRUE
[16:19:30.754] getGlobalsAndPackages() ...
[16:19:30.754] Searching for globals...
[16:19:30.756] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:30.756] Searching for globals ... DONE
[16:19:30.756] Resolving globals: FALSE
[16:19:30.756] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:30.757] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:30.757] - globals: [1] ‘FUN’
[16:19:30.757] 
[16:19:30.757] getGlobalsAndPackages() ... DONE
[16:19:30.757]  - globals found/used: [n=1] ‘FUN’
[16:19:30.757]  - needed namespaces: [n=0] 
[16:19:30.757] Finding globals ... DONE
[16:19:30.757]  - use_args: TRUE
[16:19:30.757]  - Getting '...' globals ...
[16:19:30.758] resolve() on list ...
[16:19:30.758]  recursive: 0
[16:19:30.758]  length: 1
[16:19:30.758]  elements: ‘...’
[16:19:30.758]  length: 0 (resolved future 1)
[16:19:30.758] resolve() on list ... DONE
[16:19:30.758]    - '...' content: [n=0] 
[16:19:30.758] List of 1
[16:19:30.758]  $ ...: list()
[16:19:30.758]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:30.758]  - attr(*, "where")=List of 1
[16:19:30.758]   ..$ ...:<environment: 0x563561735290> 
[16:19:30.758]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:30.758]  - attr(*, "resolved")= logi TRUE
[16:19:30.758]  - attr(*, "total_size")= num NA
[16:19:30.761]  - Getting '...' globals ... DONE
[16:19:30.761] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:30.761] List of 2
[16:19:30.761]  $ ...future.FUN:function (x)  
[16:19:30.761]  $ ...          : list()
[16:19:30.761]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:30.761]  - attr(*, "where")=List of 2
[16:19:30.761]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:30.761]   ..$ ...          :<environment: 0x563561735290> 
[16:19:30.761]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:30.761]  - attr(*, "resolved")= logi FALSE
[16:19:30.761]  - attr(*, "total_size")= num 4720
[16:19:30.764] Packages to be attached in all futures: [n=0] 
[16:19:30.764] getGlobalsAndPackagesXApply() ... DONE
[16:19:30.764] Number of futures (= number of chunks): 1
[16:19:30.764] Launching 1 futures (chunks) ...
[16:19:30.764] Chunk #1 of 1 ...
[16:19:30.764]  - Finding globals in 'X' for chunk #1 ...
[16:19:30.764] getGlobalsAndPackages() ...
[16:19:30.765] Searching for globals...
[16:19:30.765] 
[16:19:30.765] Searching for globals ... DONE
[16:19:30.765] - globals: [0] <none>
[16:19:30.765] getGlobalsAndPackages() ... DONE
[16:19:30.765]    + additional globals found: [n=0] 
[16:19:30.765]    + additional namespaces needed: [n=0] 
[16:19:30.765]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:30.765]  - seeds: <none>
[16:19:30.766]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:30.766] getGlobalsAndPackages() ...
[16:19:30.767] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:30.768] Resolving globals: FALSE
[16:19:30.768] Tweak future expression to call with '...' arguments ...
[16:19:30.768] {
[16:19:30.768]     do.call(function(...) {
[16:19:30.768]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:30.768]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:30.768]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:30.768]             on.exit(options(oopts), add = TRUE)
[16:19:30.768]         }
[16:19:30.768]         {
[16:19:30.768]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:30.768]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:30.768]                 ...future.FUN(...future.X_jj, ...)
[16:19:30.768]             })
[16:19:30.768]         }
[16:19:30.768]     }, args = future.call.arguments)
[16:19:30.768] }
[16:19:30.768] Tweak future expression to call with '...' arguments ... DONE
[16:19:30.768] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:30.768] 
[16:19:30.769] getGlobalsAndPackages() ... DONE
[16:19:30.769] run() for ‘Future’ ...
[16:19:30.769] - state: ‘created’
[16:19:30.769] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:30.773] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:30.773] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:30.773]   - Field: ‘label’
[16:19:30.773]   - Field: ‘local’
[16:19:30.773]   - Field: ‘owner’
[16:19:30.773]   - Field: ‘envir’
[16:19:30.774]   - Field: ‘packages’
[16:19:30.774]   - Field: ‘gc’
[16:19:30.774]   - Field: ‘conditions’
[16:19:30.774]   - Field: ‘expr’
[16:19:30.774]   - Field: ‘uuid’
[16:19:30.774]   - Field: ‘seed’
[16:19:30.774]   - Field: ‘version’
[16:19:30.774]   - Field: ‘result’
[16:19:30.774]   - Field: ‘asynchronous’
[16:19:30.775]   - Field: ‘calls’
[16:19:30.775]   - Field: ‘globals’
[16:19:30.775]   - Field: ‘stdout’
[16:19:30.775]   - Field: ‘earlySignal’
[16:19:30.775]   - Field: ‘lazy’
[16:19:30.775]   - Field: ‘state’
[16:19:30.775] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:30.775] - Launch lazy future ...
[16:19:30.775] Packages needed by the future expression (n = 0): <none>
[16:19:30.776] Packages needed by future strategies (n = 0): <none>
[16:19:30.776] {
[16:19:30.776]     {
[16:19:30.776]         {
[16:19:30.776]             ...future.startTime <- base::Sys.time()
[16:19:30.776]             {
[16:19:30.776]                 {
[16:19:30.776]                   {
[16:19:30.776]                     base::local({
[16:19:30.776]                       has_future <- base::requireNamespace("future", 
[16:19:30.776]                         quietly = TRUE)
[16:19:30.776]                       if (has_future) {
[16:19:30.776]                         ns <- base::getNamespace("future")
[16:19:30.776]                         version <- ns[[".package"]][["version"]]
[16:19:30.776]                         if (is.null(version)) 
[16:19:30.776]                           version <- utils::packageVersion("future")
[16:19:30.776]                       }
[16:19:30.776]                       else {
[16:19:30.776]                         version <- NULL
[16:19:30.776]                       }
[16:19:30.776]                       if (!has_future || version < "1.8.0") {
[16:19:30.776]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:30.776]                           "", base::R.version$version.string), 
[16:19:30.776]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:30.776]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:30.776]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:30.776]                             "release", "version")], collapse = " "), 
[16:19:30.776]                           hostname = base::Sys.info()[["nodename"]])
[16:19:30.776]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:30.776]                           info)
[16:19:30.776]                         info <- base::paste(info, collapse = "; ")
[16:19:30.776]                         if (!has_future) {
[16:19:30.776]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:30.776]                             info)
[16:19:30.776]                         }
[16:19:30.776]                         else {
[16:19:30.776]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:30.776]                             info, version)
[16:19:30.776]                         }
[16:19:30.776]                         base::stop(msg)
[16:19:30.776]                       }
[16:19:30.776]                     })
[16:19:30.776]                   }
[16:19:30.776]                   ...future.strategy.old <- future::plan("list")
[16:19:30.776]                   options(future.plan = NULL)
[16:19:30.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:30.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:30.776]                 }
[16:19:30.776]                 ...future.workdir <- getwd()
[16:19:30.776]             }
[16:19:30.776]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:30.776]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:30.776]         }
[16:19:30.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:30.776]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:30.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:30.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:30.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:30.776]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:30.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:30.776]             base::names(...future.oldOptions))
[16:19:30.776]     }
[16:19:30.776]     if (FALSE) {
[16:19:30.776]     }
[16:19:30.776]     else {
[16:19:30.776]         if (TRUE) {
[16:19:30.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:30.776]                 open = "w")
[16:19:30.776]         }
[16:19:30.776]         else {
[16:19:30.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:30.776]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:30.776]         }
[16:19:30.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:30.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:30.776]             base::sink(type = "output", split = FALSE)
[16:19:30.776]             base::close(...future.stdout)
[16:19:30.776]         }, add = TRUE)
[16:19:30.776]     }
[16:19:30.776]     ...future.frame <- base::sys.nframe()
[16:19:30.776]     ...future.conditions <- base::list()
[16:19:30.776]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:30.776]     if (FALSE) {
[16:19:30.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:30.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:30.776]     }
[16:19:30.776]     ...future.result <- base::tryCatch({
[16:19:30.776]         base::withCallingHandlers({
[16:19:30.776]             ...future.value <- base::withVisible(base::local({
[16:19:30.776]                 do.call(function(...) {
[16:19:30.776]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:30.776]                   if (!identical(...future.globals.maxSize.org, 
[16:19:30.776]                     ...future.globals.maxSize)) {
[16:19:30.776]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:30.776]                     on.exit(options(oopts), add = TRUE)
[16:19:30.776]                   }
[16:19:30.776]                   {
[16:19:30.776]                     lapply(seq_along(...future.elements_ii), 
[16:19:30.776]                       FUN = function(jj) {
[16:19:30.776]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:30.776]                         ...future.FUN(...future.X_jj, ...)
[16:19:30.776]                       })
[16:19:30.776]                   }
[16:19:30.776]                 }, args = future.call.arguments)
[16:19:30.776]             }))
[16:19:30.776]             future::FutureResult(value = ...future.value$value, 
[16:19:30.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:30.776]                   ...future.rng), globalenv = if (FALSE) 
[16:19:30.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:30.776]                     ...future.globalenv.names))
[16:19:30.776]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:30.776]         }, condition = base::local({
[16:19:30.776]             c <- base::c
[16:19:30.776]             inherits <- base::inherits
[16:19:30.776]             invokeRestart <- base::invokeRestart
[16:19:30.776]             length <- base::length
[16:19:30.776]             list <- base::list
[16:19:30.776]             seq.int <- base::seq.int
[16:19:30.776]             signalCondition <- base::signalCondition
[16:19:30.776]             sys.calls <- base::sys.calls
[16:19:30.776]             `[[` <- base::`[[`
[16:19:30.776]             `+` <- base::`+`
[16:19:30.776]             `<<-` <- base::`<<-`
[16:19:30.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:30.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:30.776]                   3L)]
[16:19:30.776]             }
[16:19:30.776]             function(cond) {
[16:19:30.776]                 is_error <- inherits(cond, "error")
[16:19:30.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:30.776]                   NULL)
[16:19:30.776]                 if (is_error) {
[16:19:30.776]                   sessionInformation <- function() {
[16:19:30.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:30.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:30.776]                       search = base::search(), system = base::Sys.info())
[16:19:30.776]                   }
[16:19:30.776]                   ...future.conditions[[length(...future.conditions) + 
[16:19:30.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:30.776]                     cond$call), session = sessionInformation(), 
[16:19:30.776]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:30.776]                   signalCondition(cond)
[16:19:30.776]                 }
[16:19:30.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:30.776]                 "immediateCondition"))) {
[16:19:30.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:30.776]                   ...future.conditions[[length(...future.conditions) + 
[16:19:30.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:30.776]                   if (TRUE && !signal) {
[16:19:30.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:30.776]                     {
[16:19:30.776]                       inherits <- base::inherits
[16:19:30.776]                       invokeRestart <- base::invokeRestart
[16:19:30.776]                       is.null <- base::is.null
[16:19:30.776]                       muffled <- FALSE
[16:19:30.776]                       if (inherits(cond, "message")) {
[16:19:30.776]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:30.776]                         if (muffled) 
[16:19:30.776]                           invokeRestart("muffleMessage")
[16:19:30.776]                       }
[16:19:30.776]                       else if (inherits(cond, "warning")) {
[16:19:30.776]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:30.776]                         if (muffled) 
[16:19:30.776]                           invokeRestart("muffleWarning")
[16:19:30.776]                       }
[16:19:30.776]                       else if (inherits(cond, "condition")) {
[16:19:30.776]                         if (!is.null(pattern)) {
[16:19:30.776]                           computeRestarts <- base::computeRestarts
[16:19:30.776]                           grepl <- base::grepl
[16:19:30.776]                           restarts <- computeRestarts(cond)
[16:19:30.776]                           for (restart in restarts) {
[16:19:30.776]                             name <- restart$name
[16:19:30.776]                             if (is.null(name)) 
[16:19:30.776]                               next
[16:19:30.776]                             if (!grepl(pattern, name)) 
[16:19:30.776]                               next
[16:19:30.776]                             invokeRestart(restart)
[16:19:30.776]                             muffled <- TRUE
[16:19:30.776]                             break
[16:19:30.776]                           }
[16:19:30.776]                         }
[16:19:30.776]                       }
[16:19:30.776]                       invisible(muffled)
[16:19:30.776]                     }
[16:19:30.776]                     muffleCondition(cond, pattern = "^muffle")
[16:19:30.776]                   }
[16:19:30.776]                 }
[16:19:30.776]                 else {
[16:19:30.776]                   if (TRUE) {
[16:19:30.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:30.776]                     {
[16:19:30.776]                       inherits <- base::inherits
[16:19:30.776]                       invokeRestart <- base::invokeRestart
[16:19:30.776]                       is.null <- base::is.null
[16:19:30.776]                       muffled <- FALSE
[16:19:30.776]                       if (inherits(cond, "message")) {
[16:19:30.776]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:30.776]                         if (muffled) 
[16:19:30.776]                           invokeRestart("muffleMessage")
[16:19:30.776]                       }
[16:19:30.776]                       else if (inherits(cond, "warning")) {
[16:19:30.776]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:30.776]                         if (muffled) 
[16:19:30.776]                           invokeRestart("muffleWarning")
[16:19:30.776]                       }
[16:19:30.776]                       else if (inherits(cond, "condition")) {
[16:19:30.776]                         if (!is.null(pattern)) {
[16:19:30.776]                           computeRestarts <- base::computeRestarts
[16:19:30.776]                           grepl <- base::grepl
[16:19:30.776]                           restarts <- computeRestarts(cond)
[16:19:30.776]                           for (restart in restarts) {
[16:19:30.776]                             name <- restart$name
[16:19:30.776]                             if (is.null(name)) 
[16:19:30.776]                               next
[16:19:30.776]                             if (!grepl(pattern, name)) 
[16:19:30.776]                               next
[16:19:30.776]                             invokeRestart(restart)
[16:19:30.776]                             muffled <- TRUE
[16:19:30.776]                             break
[16:19:30.776]                           }
[16:19:30.776]                         }
[16:19:30.776]                       }
[16:19:30.776]                       invisible(muffled)
[16:19:30.776]                     }
[16:19:30.776]                     muffleCondition(cond, pattern = "^muffle")
[16:19:30.776]                   }
[16:19:30.776]                 }
[16:19:30.776]             }
[16:19:30.776]         }))
[16:19:30.776]     }, error = function(ex) {
[16:19:30.776]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:30.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:30.776]                 ...future.rng), started = ...future.startTime, 
[16:19:30.776]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:30.776]             version = "1.8"), class = "FutureResult")
[16:19:30.776]     }, finally = {
[16:19:30.776]         if (!identical(...future.workdir, getwd())) 
[16:19:30.776]             setwd(...future.workdir)
[16:19:30.776]         {
[16:19:30.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:30.776]                 ...future.oldOptions$nwarnings <- NULL
[16:19:30.776]             }
[16:19:30.776]             base::options(...future.oldOptions)
[16:19:30.776]             if (.Platform$OS.type == "windows") {
[16:19:30.776]                 old_names <- names(...future.oldEnvVars)
[16:19:30.776]                 envs <- base::Sys.getenv()
[16:19:30.776]                 names <- names(envs)
[16:19:30.776]                 common <- intersect(names, old_names)
[16:19:30.776]                 added <- setdiff(names, old_names)
[16:19:30.776]                 removed <- setdiff(old_names, names)
[16:19:30.776]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:30.776]                   envs[common]]
[16:19:30.776]                 NAMES <- toupper(changed)
[16:19:30.776]                 args <- list()
[16:19:30.776]                 for (kk in seq_along(NAMES)) {
[16:19:30.776]                   name <- changed[[kk]]
[16:19:30.776]                   NAME <- NAMES[[kk]]
[16:19:30.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:30.776]                     next
[16:19:30.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:30.776]                 }
[16:19:30.776]                 NAMES <- toupper(added)
[16:19:30.776]                 for (kk in seq_along(NAMES)) {
[16:19:30.776]                   name <- added[[kk]]
[16:19:30.776]                   NAME <- NAMES[[kk]]
[16:19:30.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:30.776]                     next
[16:19:30.776]                   args[[name]] <- ""
[16:19:30.776]                 }
[16:19:30.776]                 NAMES <- toupper(removed)
[16:19:30.776]                 for (kk in seq_along(NAMES)) {
[16:19:30.776]                   name <- removed[[kk]]
[16:19:30.776]                   NAME <- NAMES[[kk]]
[16:19:30.776]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:30.776]                     next
[16:19:30.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:30.776]                 }
[16:19:30.776]                 if (length(args) > 0) 
[16:19:30.776]                   base::do.call(base::Sys.setenv, args = args)
[16:19:30.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:30.776]             }
[16:19:30.776]             else {
[16:19:30.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:30.776]             }
[16:19:30.776]             {
[16:19:30.776]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:30.776]                   0L) {
[16:19:30.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:30.776]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:30.776]                   base::options(opts)
[16:19:30.776]                 }
[16:19:30.776]                 {
[16:19:30.776]                   {
[16:19:30.776]                     NULL
[16:19:30.776]                     RNGkind("Mersenne-Twister")
[16:19:30.776]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:30.776]                       inherits = FALSE)
[16:19:30.776]                   }
[16:19:30.776]                   options(future.plan = NULL)
[16:19:30.776]                   if (is.na(NA_character_)) 
[16:19:30.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:30.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:30.776]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:30.776]                     .init = FALSE)
[16:19:30.776]                 }
[16:19:30.776]             }
[16:19:30.776]         }
[16:19:30.776]     })
[16:19:30.776]     if (TRUE) {
[16:19:30.776]         base::sink(type = "output", split = FALSE)
[16:19:30.776]         if (TRUE) {
[16:19:30.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:30.776]         }
[16:19:30.776]         else {
[16:19:30.776]             ...future.result["stdout"] <- base::list(NULL)
[16:19:30.776]         }
[16:19:30.776]         base::close(...future.stdout)
[16:19:30.776]         ...future.stdout <- NULL
[16:19:30.776]     }
[16:19:30.776]     ...future.result$conditions <- ...future.conditions
[16:19:30.776]     ...future.result$finished <- base::Sys.time()
[16:19:30.776]     ...future.result
[16:19:30.776] }
[16:19:30.778] assign_globals() ...
[16:19:30.778] List of 5
[16:19:30.778]  $ ...future.FUN            :function (x)  
[16:19:30.778]  $ future.call.arguments    : list()
[16:19:30.778]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:30.778]  $ ...future.elements_ii    :List of 2
[16:19:30.778]   ..$ : int 1
[16:19:30.778]   ..$ : int 0
[16:19:30.778]  $ ...future.seeds_ii       : NULL
[16:19:30.778]  $ ...future.globals.maxSize: NULL
[16:19:30.778]  - attr(*, "where")=List of 5
[16:19:30.778]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:30.778]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:30.778]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:30.778]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:30.778]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:30.778]  - attr(*, "resolved")= logi FALSE
[16:19:30.778]  - attr(*, "total_size")= num 4720
[16:19:30.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:30.778]  - attr(*, "already-done")= logi TRUE
[16:19:30.782] - reassign environment for ‘...future.FUN’
[16:19:30.783] - copied ‘...future.FUN’ to environment
[16:19:30.783] - copied ‘future.call.arguments’ to environment
[16:19:30.783] - copied ‘...future.elements_ii’ to environment
[16:19:30.783] - copied ‘...future.seeds_ii’ to environment
[16:19:30.783] - copied ‘...future.globals.maxSize’ to environment
[16:19:30.783] assign_globals() ... done
[16:19:30.783] plan(): Setting new future strategy stack:
[16:19:30.783] List of future strategies:
[16:19:30.783] 1. sequential:
[16:19:30.783]    - args: function (..., envir = parent.frame())
[16:19:30.783]    - tweaked: FALSE
[16:19:30.783]    - call: NULL
[16:19:30.784] plan(): nbrOfWorkers() = 1
[16:19:31.285] plan(): Setting new future strategy stack:
[16:19:31.286] List of future strategies:
[16:19:31.286] 1. multicore:
[16:19:31.286]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:31.286]    - tweaked: FALSE
[16:19:31.286]    - call: plan(strategy)
[16:19:31.290] plan(): nbrOfWorkers() = 1
[16:19:31.290] SequentialFuture started (and completed)
[16:19:31.290] - Launch lazy future ... done
[16:19:31.290] run() for ‘SequentialFuture’ ... done
[16:19:31.290] Created future:
[16:19:31.290] SequentialFuture:
[16:19:31.290] Label: ‘future_lapply-1’
[16:19:31.290] Expression:
[16:19:31.290] {
[16:19:31.290]     do.call(function(...) {
[16:19:31.290]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:31.290]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:31.290]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:31.290]             on.exit(options(oopts), add = TRUE)
[16:19:31.290]         }
[16:19:31.290]         {
[16:19:31.290]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:31.290]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:31.290]                 ...future.FUN(...future.X_jj, ...)
[16:19:31.290]             })
[16:19:31.290]         }
[16:19:31.290]     }, args = future.call.arguments)
[16:19:31.290] }
[16:19:31.290] Lazy evaluation: FALSE
[16:19:31.290] Asynchronous evaluation: FALSE
[16:19:31.290] Local evaluation: TRUE
[16:19:31.290] Environment: R_GlobalEnv
[16:19:31.290] Capture standard output: TRUE
[16:19:31.290] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:31.290] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:31.290] Packages: <none>
[16:19:31.290] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:31.290] Resolved: TRUE
[16:19:31.290] Value: 112 bytes of class ‘list’
[16:19:31.290] Early signaling: FALSE
[16:19:31.290] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:31.290] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:31.291] Chunk #1 of 1 ... DONE
[16:19:31.291] Launching 1 futures (chunks) ... DONE
[16:19:31.292] Resolving 1 futures (chunks) ...
[16:19:31.292] resolve() on list ...
[16:19:31.292]  recursive: 0
[16:19:31.292]  length: 1
[16:19:31.292] 
[16:19:31.292] resolved() for ‘SequentialFuture’ ...
[16:19:31.292] - state: ‘finished’
[16:19:31.292] - run: TRUE
[16:19:31.292] - result: ‘FutureResult’
[16:19:31.292] resolved() for ‘SequentialFuture’ ... done
[16:19:31.293] Future #1
[16:19:31.293] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:31.293] - nx: 1
[16:19:31.293] - relay: TRUE
[16:19:31.293] - stdout: TRUE
[16:19:31.293] - signal: TRUE
[16:19:31.293] - resignal: FALSE
[16:19:31.293] - force: TRUE
[16:19:31.293] - relayed: [n=1] FALSE
[16:19:31.293] - queued futures: [n=1] FALSE
[16:19:31.293]  - until=1
[16:19:31.294]  - relaying element #1
[16:19:31.294] - relayed: [n=1] TRUE
[16:19:31.294] - queued futures: [n=1] TRUE
[16:19:31.294] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:31.294]  length: 0 (resolved future 1)
[16:19:31.294] Relaying remaining futures
[16:19:31.294] signalConditionsASAP(NULL, pos=0) ...
[16:19:31.294] - nx: 1
[16:19:31.294] - relay: TRUE
[16:19:31.294] - stdout: TRUE
[16:19:31.295] - signal: TRUE
[16:19:31.295] - resignal: FALSE
[16:19:31.295] - force: TRUE
[16:19:31.295] - relayed: [n=1] TRUE
[16:19:31.295] - queued futures: [n=1] TRUE
 - flush all
[16:19:31.295] - relayed: [n=1] TRUE
[16:19:31.295] - queued futures: [n=1] TRUE
[16:19:31.295] signalConditionsASAP(NULL, pos=0) ... done
[16:19:31.295] resolve() on list ... DONE
[16:19:31.295]  - Number of value chunks collected: 1
[16:19:31.296] Resolving 1 futures (chunks) ... DONE
[16:19:31.296] Reducing values from 1 chunks ...
[16:19:31.296]  - Number of values collected after concatenation: 2
[16:19:31.296]  - Number of values expected: 2
[16:19:31.296] Reducing values from 1 chunks ... DONE
[16:19:31.296] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:19:31.296] future_lapply() ...
[16:19:31.302] Number of chunks: 1
[16:19:31.302] getGlobalsAndPackagesXApply() ...
[16:19:31.302]  - future.globals: TRUE
[16:19:31.303] getGlobalsAndPackages() ...
[16:19:31.303] Searching for globals...
[16:19:31.304] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:31.304] Searching for globals ... DONE
[16:19:31.304] Resolving globals: FALSE
[16:19:31.305] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:31.305] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:31.305] - globals: [1] ‘FUN’
[16:19:31.305] 
[16:19:31.305] getGlobalsAndPackages() ... DONE
[16:19:31.306]  - globals found/used: [n=1] ‘FUN’
[16:19:31.306]  - needed namespaces: [n=0] 
[16:19:31.306] Finding globals ... DONE
[16:19:31.306]  - use_args: TRUE
[16:19:31.306]  - Getting '...' globals ...
[16:19:31.306] resolve() on list ...
[16:19:31.306]  recursive: 0
[16:19:31.306]  length: 1
[16:19:31.306]  elements: ‘...’
[16:19:31.307]  length: 0 (resolved future 1)
[16:19:31.307] resolve() on list ... DONE
[16:19:31.307]    - '...' content: [n=0] 
[16:19:31.307] List of 1
[16:19:31.307]  $ ...: list()
[16:19:31.307]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:31.307]  - attr(*, "where")=List of 1
[16:19:31.307]   ..$ ...:<environment: 0x563562f527c0> 
[16:19:31.307]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:31.307]  - attr(*, "resolved")= logi TRUE
[16:19:31.307]  - attr(*, "total_size")= num NA
[16:19:31.310]  - Getting '...' globals ... DONE
[16:19:31.310] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:31.310] List of 2
[16:19:31.310]  $ ...future.FUN:function (x)  
[16:19:31.310]  $ ...          : list()
[16:19:31.310]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:31.310]  - attr(*, "where")=List of 2
[16:19:31.310]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:31.310]   ..$ ...          :<environment: 0x563562f527c0> 
[16:19:31.310]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:31.310]  - attr(*, "resolved")= logi FALSE
[16:19:31.310]  - attr(*, "total_size")= num 4720
[16:19:31.313] Packages to be attached in all futures: [n=0] 
[16:19:31.313] getGlobalsAndPackagesXApply() ... DONE
[16:19:31.313] Number of futures (= number of chunks): 1
[16:19:31.313] Launching 1 futures (chunks) ...
[16:19:31.313] Chunk #1 of 1 ...
[16:19:31.313]  - Finding globals in 'X' for chunk #1 ...
[16:19:31.313] getGlobalsAndPackages() ...
[16:19:31.313] Searching for globals...
[16:19:31.314] 
[16:19:31.314] Searching for globals ... DONE
[16:19:31.314] - globals: [0] <none>
[16:19:31.314] getGlobalsAndPackages() ... DONE
[16:19:31.314]    + additional globals found: [n=0] 
[16:19:31.314]    + additional namespaces needed: [n=0] 
[16:19:31.314]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:31.314]  - seeds: <none>
[16:19:31.314]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:31.315] getGlobalsAndPackages() ...
[16:19:31.315] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:31.315] Resolving globals: FALSE
[16:19:31.315] Tweak future expression to call with '...' arguments ...
[16:19:31.315] {
[16:19:31.315]     do.call(function(...) {
[16:19:31.315]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:31.315]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:31.315]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:31.315]             on.exit(options(oopts), add = TRUE)
[16:19:31.315]         }
[16:19:31.315]         {
[16:19:31.315]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:31.315]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:31.315]                 ...future.FUN(...future.X_jj, ...)
[16:19:31.315]             })
[16:19:31.315]         }
[16:19:31.315]     }, args = future.call.arguments)
[16:19:31.315] }
[16:19:31.315] Tweak future expression to call with '...' arguments ... DONE
[16:19:31.316] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:31.316] 
[16:19:31.316] getGlobalsAndPackages() ... DONE
[16:19:31.316] run() for ‘Future’ ...
[16:19:31.316] - state: ‘created’
[16:19:31.316] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:31.320] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:31.320] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:31.320]   - Field: ‘label’
[16:19:31.320]   - Field: ‘local’
[16:19:31.320]   - Field: ‘owner’
[16:19:31.320]   - Field: ‘envir’
[16:19:31.320]   - Field: ‘packages’
[16:19:31.320]   - Field: ‘gc’
[16:19:31.321]   - Field: ‘conditions’
[16:19:31.321]   - Field: ‘expr’
[16:19:31.321]   - Field: ‘uuid’
[16:19:31.321]   - Field: ‘seed’
[16:19:31.321]   - Field: ‘version’
[16:19:31.321]   - Field: ‘result’
[16:19:31.321]   - Field: ‘asynchronous’
[16:19:31.321]   - Field: ‘calls’
[16:19:31.321]   - Field: ‘globals’
[16:19:31.321]   - Field: ‘stdout’
[16:19:31.321]   - Field: ‘earlySignal’
[16:19:31.321]   - Field: ‘lazy’
[16:19:31.322]   - Field: ‘state’
[16:19:31.322] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:31.322] - Launch lazy future ...
[16:19:31.322] Packages needed by the future expression (n = 0): <none>
[16:19:31.322] Packages needed by future strategies (n = 0): <none>
[16:19:31.322] {
[16:19:31.322]     {
[16:19:31.322]         {
[16:19:31.322]             ...future.startTime <- base::Sys.time()
[16:19:31.322]             {
[16:19:31.322]                 {
[16:19:31.322]                   {
[16:19:31.322]                     base::local({
[16:19:31.322]                       has_future <- base::requireNamespace("future", 
[16:19:31.322]                         quietly = TRUE)
[16:19:31.322]                       if (has_future) {
[16:19:31.322]                         ns <- base::getNamespace("future")
[16:19:31.322]                         version <- ns[[".package"]][["version"]]
[16:19:31.322]                         if (is.null(version)) 
[16:19:31.322]                           version <- utils::packageVersion("future")
[16:19:31.322]                       }
[16:19:31.322]                       else {
[16:19:31.322]                         version <- NULL
[16:19:31.322]                       }
[16:19:31.322]                       if (!has_future || version < "1.8.0") {
[16:19:31.322]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:31.322]                           "", base::R.version$version.string), 
[16:19:31.322]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:31.322]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:31.322]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:31.322]                             "release", "version")], collapse = " "), 
[16:19:31.322]                           hostname = base::Sys.info()[["nodename"]])
[16:19:31.322]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:31.322]                           info)
[16:19:31.322]                         info <- base::paste(info, collapse = "; ")
[16:19:31.322]                         if (!has_future) {
[16:19:31.322]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:31.322]                             info)
[16:19:31.322]                         }
[16:19:31.322]                         else {
[16:19:31.322]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:31.322]                             info, version)
[16:19:31.322]                         }
[16:19:31.322]                         base::stop(msg)
[16:19:31.322]                       }
[16:19:31.322]                     })
[16:19:31.322]                   }
[16:19:31.322]                   ...future.strategy.old <- future::plan("list")
[16:19:31.322]                   options(future.plan = NULL)
[16:19:31.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:31.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:31.322]                 }
[16:19:31.322]                 ...future.workdir <- getwd()
[16:19:31.322]             }
[16:19:31.322]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:31.322]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:31.322]         }
[16:19:31.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:31.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:31.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:31.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:31.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:31.322]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:31.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:31.322]             base::names(...future.oldOptions))
[16:19:31.322]     }
[16:19:31.322]     if (TRUE) {
[16:19:31.322]     }
[16:19:31.322]     else {
[16:19:31.322]         if (NA) {
[16:19:31.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:31.322]                 open = "w")
[16:19:31.322]         }
[16:19:31.322]         else {
[16:19:31.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:31.322]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:31.322]         }
[16:19:31.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:31.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:31.322]             base::sink(type = "output", split = FALSE)
[16:19:31.322]             base::close(...future.stdout)
[16:19:31.322]         }, add = TRUE)
[16:19:31.322]     }
[16:19:31.322]     ...future.frame <- base::sys.nframe()
[16:19:31.322]     ...future.conditions <- base::list()
[16:19:31.322]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:31.322]     if (FALSE) {
[16:19:31.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:31.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:31.322]     }
[16:19:31.322]     ...future.result <- base::tryCatch({
[16:19:31.322]         base::withCallingHandlers({
[16:19:31.322]             ...future.value <- base::withVisible(base::local({
[16:19:31.322]                 do.call(function(...) {
[16:19:31.322]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:31.322]                   if (!identical(...future.globals.maxSize.org, 
[16:19:31.322]                     ...future.globals.maxSize)) {
[16:19:31.322]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:31.322]                     on.exit(options(oopts), add = TRUE)
[16:19:31.322]                   }
[16:19:31.322]                   {
[16:19:31.322]                     lapply(seq_along(...future.elements_ii), 
[16:19:31.322]                       FUN = function(jj) {
[16:19:31.322]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:31.322]                         ...future.FUN(...future.X_jj, ...)
[16:19:31.322]                       })
[16:19:31.322]                   }
[16:19:31.322]                 }, args = future.call.arguments)
[16:19:31.322]             }))
[16:19:31.322]             future::FutureResult(value = ...future.value$value, 
[16:19:31.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:31.322]                   ...future.rng), globalenv = if (FALSE) 
[16:19:31.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:31.322]                     ...future.globalenv.names))
[16:19:31.322]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:31.322]         }, condition = base::local({
[16:19:31.322]             c <- base::c
[16:19:31.322]             inherits <- base::inherits
[16:19:31.322]             invokeRestart <- base::invokeRestart
[16:19:31.322]             length <- base::length
[16:19:31.322]             list <- base::list
[16:19:31.322]             seq.int <- base::seq.int
[16:19:31.322]             signalCondition <- base::signalCondition
[16:19:31.322]             sys.calls <- base::sys.calls
[16:19:31.322]             `[[` <- base::`[[`
[16:19:31.322]             `+` <- base::`+`
[16:19:31.322]             `<<-` <- base::`<<-`
[16:19:31.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:31.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:31.322]                   3L)]
[16:19:31.322]             }
[16:19:31.322]             function(cond) {
[16:19:31.322]                 is_error <- inherits(cond, "error")
[16:19:31.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:31.322]                   NULL)
[16:19:31.322]                 if (is_error) {
[16:19:31.322]                   sessionInformation <- function() {
[16:19:31.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:31.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:31.322]                       search = base::search(), system = base::Sys.info())
[16:19:31.322]                   }
[16:19:31.322]                   ...future.conditions[[length(...future.conditions) + 
[16:19:31.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:31.322]                     cond$call), session = sessionInformation(), 
[16:19:31.322]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:31.322]                   signalCondition(cond)
[16:19:31.322]                 }
[16:19:31.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:31.322]                 "immediateCondition"))) {
[16:19:31.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:31.322]                   ...future.conditions[[length(...future.conditions) + 
[16:19:31.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:31.322]                   if (TRUE && !signal) {
[16:19:31.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:31.322]                     {
[16:19:31.322]                       inherits <- base::inherits
[16:19:31.322]                       invokeRestart <- base::invokeRestart
[16:19:31.322]                       is.null <- base::is.null
[16:19:31.322]                       muffled <- FALSE
[16:19:31.322]                       if (inherits(cond, "message")) {
[16:19:31.322]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:31.322]                         if (muffled) 
[16:19:31.322]                           invokeRestart("muffleMessage")
[16:19:31.322]                       }
[16:19:31.322]                       else if (inherits(cond, "warning")) {
[16:19:31.322]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:31.322]                         if (muffled) 
[16:19:31.322]                           invokeRestart("muffleWarning")
[16:19:31.322]                       }
[16:19:31.322]                       else if (inherits(cond, "condition")) {
[16:19:31.322]                         if (!is.null(pattern)) {
[16:19:31.322]                           computeRestarts <- base::computeRestarts
[16:19:31.322]                           grepl <- base::grepl
[16:19:31.322]                           restarts <- computeRestarts(cond)
[16:19:31.322]                           for (restart in restarts) {
[16:19:31.322]                             name <- restart$name
[16:19:31.322]                             if (is.null(name)) 
[16:19:31.322]                               next
[16:19:31.322]                             if (!grepl(pattern, name)) 
[16:19:31.322]                               next
[16:19:31.322]                             invokeRestart(restart)
[16:19:31.322]                             muffled <- TRUE
[16:19:31.322]                             break
[16:19:31.322]                           }
[16:19:31.322]                         }
[16:19:31.322]                       }
[16:19:31.322]                       invisible(muffled)
[16:19:31.322]                     }
[16:19:31.322]                     muffleCondition(cond, pattern = "^muffle")
[16:19:31.322]                   }
[16:19:31.322]                 }
[16:19:31.322]                 else {
[16:19:31.322]                   if (TRUE) {
[16:19:31.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:31.322]                     {
[16:19:31.322]                       inherits <- base::inherits
[16:19:31.322]                       invokeRestart <- base::invokeRestart
[16:19:31.322]                       is.null <- base::is.null
[16:19:31.322]                       muffled <- FALSE
[16:19:31.322]                       if (inherits(cond, "message")) {
[16:19:31.322]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:31.322]                         if (muffled) 
[16:19:31.322]                           invokeRestart("muffleMessage")
[16:19:31.322]                       }
[16:19:31.322]                       else if (inherits(cond, "warning")) {
[16:19:31.322]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:31.322]                         if (muffled) 
[16:19:31.322]                           invokeRestart("muffleWarning")
[16:19:31.322]                       }
[16:19:31.322]                       else if (inherits(cond, "condition")) {
[16:19:31.322]                         if (!is.null(pattern)) {
[16:19:31.322]                           computeRestarts <- base::computeRestarts
[16:19:31.322]                           grepl <- base::grepl
[16:19:31.322]                           restarts <- computeRestarts(cond)
[16:19:31.322]                           for (restart in restarts) {
[16:19:31.322]                             name <- restart$name
[16:19:31.322]                             if (is.null(name)) 
[16:19:31.322]                               next
[16:19:31.322]                             if (!grepl(pattern, name)) 
[16:19:31.322]                               next
[16:19:31.322]                             invokeRestart(restart)
[16:19:31.322]                             muffled <- TRUE
[16:19:31.322]                             break
[16:19:31.322]                           }
[16:19:31.322]                         }
[16:19:31.322]                       }
[16:19:31.322]                       invisible(muffled)
[16:19:31.322]                     }
[16:19:31.322]                     muffleCondition(cond, pattern = "^muffle")
[16:19:31.322]                   }
[16:19:31.322]                 }
[16:19:31.322]             }
[16:19:31.322]         }))
[16:19:31.322]     }, error = function(ex) {
[16:19:31.322]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:31.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:31.322]                 ...future.rng), started = ...future.startTime, 
[16:19:31.322]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:31.322]             version = "1.8"), class = "FutureResult")
[16:19:31.322]     }, finally = {
[16:19:31.322]         if (!identical(...future.workdir, getwd())) 
[16:19:31.322]             setwd(...future.workdir)
[16:19:31.322]         {
[16:19:31.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:31.322]                 ...future.oldOptions$nwarnings <- NULL
[16:19:31.322]             }
[16:19:31.322]             base::options(...future.oldOptions)
[16:19:31.322]             if (.Platform$OS.type == "windows") {
[16:19:31.322]                 old_names <- names(...future.oldEnvVars)
[16:19:31.322]                 envs <- base::Sys.getenv()
[16:19:31.322]                 names <- names(envs)
[16:19:31.322]                 common <- intersect(names, old_names)
[16:19:31.322]                 added <- setdiff(names, old_names)
[16:19:31.322]                 removed <- setdiff(old_names, names)
[16:19:31.322]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:31.322]                   envs[common]]
[16:19:31.322]                 NAMES <- toupper(changed)
[16:19:31.322]                 args <- list()
[16:19:31.322]                 for (kk in seq_along(NAMES)) {
[16:19:31.322]                   name <- changed[[kk]]
[16:19:31.322]                   NAME <- NAMES[[kk]]
[16:19:31.322]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:31.322]                     next
[16:19:31.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:31.322]                 }
[16:19:31.322]                 NAMES <- toupper(added)
[16:19:31.322]                 for (kk in seq_along(NAMES)) {
[16:19:31.322]                   name <- added[[kk]]
[16:19:31.322]                   NAME <- NAMES[[kk]]
[16:19:31.322]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:31.322]                     next
[16:19:31.322]                   args[[name]] <- ""
[16:19:31.322]                 }
[16:19:31.322]                 NAMES <- toupper(removed)
[16:19:31.322]                 for (kk in seq_along(NAMES)) {
[16:19:31.322]                   name <- removed[[kk]]
[16:19:31.322]                   NAME <- NAMES[[kk]]
[16:19:31.322]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:31.322]                     next
[16:19:31.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:31.322]                 }
[16:19:31.322]                 if (length(args) > 0) 
[16:19:31.322]                   base::do.call(base::Sys.setenv, args = args)
[16:19:31.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:31.322]             }
[16:19:31.322]             else {
[16:19:31.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:31.322]             }
[16:19:31.322]             {
[16:19:31.322]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:31.322]                   0L) {
[16:19:31.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:31.322]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:31.322]                   base::options(opts)
[16:19:31.322]                 }
[16:19:31.322]                 {
[16:19:31.322]                   {
[16:19:31.322]                     NULL
[16:19:31.322]                     RNGkind("Mersenne-Twister")
[16:19:31.322]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:31.322]                       inherits = FALSE)
[16:19:31.322]                   }
[16:19:31.322]                   options(future.plan = NULL)
[16:19:31.322]                   if (is.na(NA_character_)) 
[16:19:31.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:31.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:31.322]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:31.322]                     .init = FALSE)
[16:19:31.322]                 }
[16:19:31.322]             }
[16:19:31.322]         }
[16:19:31.322]     })
[16:19:31.322]     if (FALSE) {
[16:19:31.322]         base::sink(type = "output", split = FALSE)
[16:19:31.322]         if (NA) {
[16:19:31.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:31.322]         }
[16:19:31.322]         else {
[16:19:31.322]             ...future.result["stdout"] <- base::list(NULL)
[16:19:31.322]         }
[16:19:31.322]         base::close(...future.stdout)
[16:19:31.322]         ...future.stdout <- NULL
[16:19:31.322]     }
[16:19:31.322]     ...future.result$conditions <- ...future.conditions
[16:19:31.322]     ...future.result$finished <- base::Sys.time()
[16:19:31.322]     ...future.result
[16:19:31.322] }
[16:19:31.324] assign_globals() ...
[16:19:31.324] List of 5
[16:19:31.324]  $ ...future.FUN            :function (x)  
[16:19:31.324]  $ future.call.arguments    : list()
[16:19:31.324]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:31.324]  $ ...future.elements_ii    :List of 2
[16:19:31.324]   ..$ : int 1
[16:19:31.324]   ..$ : int 0
[16:19:31.324]  $ ...future.seeds_ii       : NULL
[16:19:31.324]  $ ...future.globals.maxSize: NULL
[16:19:31.324]  - attr(*, "where")=List of 5
[16:19:31.324]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:31.324]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:31.324]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:31.324]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:31.324]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:31.324]  - attr(*, "resolved")= logi FALSE
[16:19:31.324]  - attr(*, "total_size")= num 4720
[16:19:31.324]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:31.324]  - attr(*, "already-done")= logi TRUE
[16:19:31.331] - reassign environment for ‘...future.FUN’
[16:19:31.331] - copied ‘...future.FUN’ to environment
[16:19:31.331] - copied ‘future.call.arguments’ to environment
[16:19:31.331] - copied ‘...future.elements_ii’ to environment
[16:19:31.331] - copied ‘...future.seeds_ii’ to environment
[16:19:31.331] - copied ‘...future.globals.maxSize’ to environment
[16:19:31.331] assign_globals() ... done
[16:19:31.332] plan(): Setting new future strategy stack:
[16:19:31.332] List of future strategies:
[16:19:31.332] 1. sequential:
[16:19:31.332]    - args: function (..., envir = parent.frame())
[16:19:31.332]    - tweaked: FALSE
[16:19:31.332]    - call: NULL
[16:19:31.332] plan(): nbrOfWorkers() = 1
[16:19:31.834] plan(): Setting new future strategy stack:
[16:19:31.834] List of future strategies:
[16:19:31.834] 1. multicore:
[16:19:31.834]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:31.834]    - tweaked: FALSE
[16:19:31.834]    - call: plan(strategy)
[16:19:31.838] plan(): nbrOfWorkers() = 1
[16:19:31.838] SequentialFuture started (and completed)
[16:19:31.838] - Launch lazy future ... done
[16:19:31.838] run() for ‘SequentialFuture’ ... done
[16:19:31.839] Created future:
[16:19:31.839] SequentialFuture:
[16:19:31.839] Label: ‘future_lapply-1’
[16:19:31.839] Expression:
[16:19:31.839] {
[16:19:31.839]     do.call(function(...) {
[16:19:31.839]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:31.839]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:31.839]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:31.839]             on.exit(options(oopts), add = TRUE)
[16:19:31.839]         }
[16:19:31.839]         {
[16:19:31.839]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:31.839]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:31.839]                 ...future.FUN(...future.X_jj, ...)
[16:19:31.839]             })
[16:19:31.839]         }
[16:19:31.839]     }, args = future.call.arguments)
[16:19:31.839] }
[16:19:31.839] Lazy evaluation: FALSE
[16:19:31.839] Asynchronous evaluation: FALSE
[16:19:31.839] Local evaluation: TRUE
[16:19:31.839] Environment: R_GlobalEnv
[16:19:31.839] Capture standard output: NA
[16:19:31.839] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:31.839] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:31.839] Packages: <none>
[16:19:31.839] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:31.839] Resolved: TRUE
[16:19:31.839] Value: 112 bytes of class ‘list’
[16:19:31.839] Early signaling: FALSE
[16:19:31.839] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:31.839] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:31.840] Chunk #1 of 1 ... DONE
[16:19:31.840] Launching 1 futures (chunks) ... DONE
[16:19:31.840] Resolving 1 futures (chunks) ...
[16:19:31.840] resolve() on list ...
[16:19:31.840]  recursive: 0
[16:19:31.840]  length: 1
[16:19:31.840] 
[16:19:31.840] resolved() for ‘SequentialFuture’ ...
[16:19:31.841] - state: ‘finished’
[16:19:31.841] - run: TRUE
[16:19:31.841] - result: ‘FutureResult’
[16:19:31.841] resolved() for ‘SequentialFuture’ ... done
[16:19:31.841] Future #1
[16:19:31.841] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:31.841] - nx: 1
[16:19:31.841] - relay: TRUE
[16:19:31.841] - stdout: TRUE
[16:19:31.842] - signal: TRUE
[16:19:31.842] - resignal: FALSE
[16:19:31.842] - force: TRUE
[16:19:31.842] - relayed: [n=1] FALSE
[16:19:31.842] - queued futures: [n=1] FALSE
[16:19:31.842]  - until=1
[16:19:31.842]  - relaying element #1
[16:19:31.843] - relayed: [n=1] TRUE
[16:19:31.843] - queued futures: [n=1] TRUE
[16:19:31.843] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:31.843]  length: 0 (resolved future 1)
[16:19:31.843] Relaying remaining futures
[16:19:31.843] signalConditionsASAP(NULL, pos=0) ...
[16:19:31.844] - nx: 1
[16:19:31.844] - relay: TRUE
[16:19:31.844] - stdout: TRUE
[16:19:31.844] - signal: TRUE
[16:19:31.844] - resignal: FALSE
[16:19:31.844] - force: TRUE
[16:19:31.844] - relayed: [n=1] TRUE
[16:19:31.844] - queued futures: [n=1] TRUE
 - flush all
[16:19:31.845] - relayed: [n=1] TRUE
[16:19:31.845] - queued futures: [n=1] TRUE
[16:19:31.845] signalConditionsASAP(NULL, pos=0) ... done
[16:19:31.845] resolve() on list ... DONE
[16:19:31.845]  - Number of value chunks collected: 1
[16:19:31.845] Resolving 1 futures (chunks) ... DONE
[16:19:31.845] Reducing values from 1 chunks ...
[16:19:31.845]  - Number of values collected after concatenation: 2
[16:19:31.845]  - Number of values expected: 2
[16:19:31.845] Reducing values from 1 chunks ... DONE
[16:19:31.845] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:19:31.846] future_mapply() ...
[16:19:31.849] Number of chunks: 1
[16:19:31.849] getGlobalsAndPackagesXApply() ...
[16:19:31.849]  - future.globals: TRUE
[16:19:31.849] getGlobalsAndPackages() ...
[16:19:31.850] Searching for globals...
[16:19:31.851] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:31.851] Searching for globals ... DONE
[16:19:31.851] Resolving globals: FALSE
[16:19:31.852] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:31.852] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:31.852] - globals: [1] ‘FUN’
[16:19:31.852] 
[16:19:31.852] getGlobalsAndPackages() ... DONE
[16:19:31.853]  - globals found/used: [n=1] ‘FUN’
[16:19:31.853]  - needed namespaces: [n=0] 
[16:19:31.853] Finding globals ... DONE
[16:19:31.853] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:31.853] List of 2
[16:19:31.853]  $ ...future.FUN:function (x, y)  
[16:19:31.853]  $ MoreArgs     : NULL
[16:19:31.853]  - attr(*, "where")=List of 2
[16:19:31.853]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:31.853]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:31.853]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:31.853]  - attr(*, "resolved")= logi FALSE
[16:19:31.853]  - attr(*, "total_size")= num NA
[16:19:31.855] Packages to be attached in all futures: [n=0] 
[16:19:31.856] getGlobalsAndPackagesXApply() ... DONE
[16:19:31.856] Number of futures (= number of chunks): 1
[16:19:31.856] Launching 1 futures (chunks) ...
[16:19:31.856] Chunk #1 of 1 ...
[16:19:31.856]  - Finding globals in '...' for chunk #1 ...
[16:19:31.856] getGlobalsAndPackages() ...
[16:19:31.856] Searching for globals...
[16:19:31.857] 
[16:19:31.857] Searching for globals ... DONE
[16:19:31.857] - globals: [0] <none>
[16:19:31.857] getGlobalsAndPackages() ... DONE
[16:19:31.857]    + additional globals found: [n=0] 
[16:19:31.857]    + additional namespaces needed: [n=0] 
[16:19:31.857]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:31.859]  - seeds: <none>
[16:19:31.859]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:31.859] getGlobalsAndPackages() ...
[16:19:31.859] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:31.860] Resolving globals: FALSE
[16:19:31.860] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:19:31.860] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:31.861] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:31.861] 
[16:19:31.861] getGlobalsAndPackages() ... DONE
[16:19:31.861] run() for ‘Future’ ...
[16:19:31.861] - state: ‘created’
[16:19:31.861] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:31.865] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:31.865] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:31.865]   - Field: ‘label’
[16:19:31.865]   - Field: ‘local’
[16:19:31.865]   - Field: ‘owner’
[16:19:31.865]   - Field: ‘envir’
[16:19:31.865]   - Field: ‘packages’
[16:19:31.866]   - Field: ‘gc’
[16:19:31.866]   - Field: ‘conditions’
[16:19:31.866]   - Field: ‘expr’
[16:19:31.866]   - Field: ‘uuid’
[16:19:31.866]   - Field: ‘seed’
[16:19:31.866]   - Field: ‘version’
[16:19:31.866]   - Field: ‘result’
[16:19:31.866]   - Field: ‘asynchronous’
[16:19:31.866]   - Field: ‘calls’
[16:19:31.866]   - Field: ‘globals’
[16:19:31.866]   - Field: ‘stdout’
[16:19:31.867]   - Field: ‘earlySignal’
[16:19:31.867]   - Field: ‘lazy’
[16:19:31.867]   - Field: ‘state’
[16:19:31.867] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:31.867] - Launch lazy future ...
[16:19:31.867] Packages needed by the future expression (n = 0): <none>
[16:19:31.867] Packages needed by future strategies (n = 0): <none>
[16:19:31.868] {
[16:19:31.868]     {
[16:19:31.868]         {
[16:19:31.868]             ...future.startTime <- base::Sys.time()
[16:19:31.868]             {
[16:19:31.868]                 {
[16:19:31.868]                   {
[16:19:31.868]                     base::local({
[16:19:31.868]                       has_future <- base::requireNamespace("future", 
[16:19:31.868]                         quietly = TRUE)
[16:19:31.868]                       if (has_future) {
[16:19:31.868]                         ns <- base::getNamespace("future")
[16:19:31.868]                         version <- ns[[".package"]][["version"]]
[16:19:31.868]                         if (is.null(version)) 
[16:19:31.868]                           version <- utils::packageVersion("future")
[16:19:31.868]                       }
[16:19:31.868]                       else {
[16:19:31.868]                         version <- NULL
[16:19:31.868]                       }
[16:19:31.868]                       if (!has_future || version < "1.8.0") {
[16:19:31.868]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:31.868]                           "", base::R.version$version.string), 
[16:19:31.868]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:31.868]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:31.868]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:31.868]                             "release", "version")], collapse = " "), 
[16:19:31.868]                           hostname = base::Sys.info()[["nodename"]])
[16:19:31.868]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:31.868]                           info)
[16:19:31.868]                         info <- base::paste(info, collapse = "; ")
[16:19:31.868]                         if (!has_future) {
[16:19:31.868]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:31.868]                             info)
[16:19:31.868]                         }
[16:19:31.868]                         else {
[16:19:31.868]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:31.868]                             info, version)
[16:19:31.868]                         }
[16:19:31.868]                         base::stop(msg)
[16:19:31.868]                       }
[16:19:31.868]                     })
[16:19:31.868]                   }
[16:19:31.868]                   ...future.strategy.old <- future::plan("list")
[16:19:31.868]                   options(future.plan = NULL)
[16:19:31.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:31.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:31.868]                 }
[16:19:31.868]                 ...future.workdir <- getwd()
[16:19:31.868]             }
[16:19:31.868]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:31.868]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:31.868]         }
[16:19:31.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:31.868]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:31.868]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:31.868]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:31.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:31.868]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:31.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:31.868]             base::names(...future.oldOptions))
[16:19:31.868]     }
[16:19:31.868]     if (FALSE) {
[16:19:31.868]     }
[16:19:31.868]     else {
[16:19:31.868]         if (FALSE) {
[16:19:31.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:31.868]                 open = "w")
[16:19:31.868]         }
[16:19:31.868]         else {
[16:19:31.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:31.868]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:31.868]         }
[16:19:31.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:31.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:31.868]             base::sink(type = "output", split = FALSE)
[16:19:31.868]             base::close(...future.stdout)
[16:19:31.868]         }, add = TRUE)
[16:19:31.868]     }
[16:19:31.868]     ...future.frame <- base::sys.nframe()
[16:19:31.868]     ...future.conditions <- base::list()
[16:19:31.868]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:31.868]     if (FALSE) {
[16:19:31.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:31.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:31.868]     }
[16:19:31.868]     ...future.result <- base::tryCatch({
[16:19:31.868]         base::withCallingHandlers({
[16:19:31.868]             ...future.value <- base::withVisible(base::local({
[16:19:31.868]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:31.868]                 if (!identical(...future.globals.maxSize.org, 
[16:19:31.868]                   ...future.globals.maxSize)) {
[16:19:31.868]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:31.868]                   on.exit(options(oopts), add = TRUE)
[16:19:31.868]                 }
[16:19:31.868]                 {
[16:19:31.868]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:31.868]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:31.868]                     USE.NAMES = FALSE)
[16:19:31.868]                   do.call(mapply, args = args)
[16:19:31.868]                 }
[16:19:31.868]             }))
[16:19:31.868]             future::FutureResult(value = ...future.value$value, 
[16:19:31.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:31.868]                   ...future.rng), globalenv = if (FALSE) 
[16:19:31.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:31.868]                     ...future.globalenv.names))
[16:19:31.868]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:31.868]         }, condition = base::local({
[16:19:31.868]             c <- base::c
[16:19:31.868]             inherits <- base::inherits
[16:19:31.868]             invokeRestart <- base::invokeRestart
[16:19:31.868]             length <- base::length
[16:19:31.868]             list <- base::list
[16:19:31.868]             seq.int <- base::seq.int
[16:19:31.868]             signalCondition <- base::signalCondition
[16:19:31.868]             sys.calls <- base::sys.calls
[16:19:31.868]             `[[` <- base::`[[`
[16:19:31.868]             `+` <- base::`+`
[16:19:31.868]             `<<-` <- base::`<<-`
[16:19:31.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:31.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:31.868]                   3L)]
[16:19:31.868]             }
[16:19:31.868]             function(cond) {
[16:19:31.868]                 is_error <- inherits(cond, "error")
[16:19:31.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:31.868]                   NULL)
[16:19:31.868]                 if (is_error) {
[16:19:31.868]                   sessionInformation <- function() {
[16:19:31.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:31.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:31.868]                       search = base::search(), system = base::Sys.info())
[16:19:31.868]                   }
[16:19:31.868]                   ...future.conditions[[length(...future.conditions) + 
[16:19:31.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:31.868]                     cond$call), session = sessionInformation(), 
[16:19:31.868]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:31.868]                   signalCondition(cond)
[16:19:31.868]                 }
[16:19:31.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:31.868]                 "immediateCondition"))) {
[16:19:31.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:31.868]                   ...future.conditions[[length(...future.conditions) + 
[16:19:31.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:31.868]                   if (TRUE && !signal) {
[16:19:31.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:31.868]                     {
[16:19:31.868]                       inherits <- base::inherits
[16:19:31.868]                       invokeRestart <- base::invokeRestart
[16:19:31.868]                       is.null <- base::is.null
[16:19:31.868]                       muffled <- FALSE
[16:19:31.868]                       if (inherits(cond, "message")) {
[16:19:31.868]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:31.868]                         if (muffled) 
[16:19:31.868]                           invokeRestart("muffleMessage")
[16:19:31.868]                       }
[16:19:31.868]                       else if (inherits(cond, "warning")) {
[16:19:31.868]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:31.868]                         if (muffled) 
[16:19:31.868]                           invokeRestart("muffleWarning")
[16:19:31.868]                       }
[16:19:31.868]                       else if (inherits(cond, "condition")) {
[16:19:31.868]                         if (!is.null(pattern)) {
[16:19:31.868]                           computeRestarts <- base::computeRestarts
[16:19:31.868]                           grepl <- base::grepl
[16:19:31.868]                           restarts <- computeRestarts(cond)
[16:19:31.868]                           for (restart in restarts) {
[16:19:31.868]                             name <- restart$name
[16:19:31.868]                             if (is.null(name)) 
[16:19:31.868]                               next
[16:19:31.868]                             if (!grepl(pattern, name)) 
[16:19:31.868]                               next
[16:19:31.868]                             invokeRestart(restart)
[16:19:31.868]                             muffled <- TRUE
[16:19:31.868]                             break
[16:19:31.868]                           }
[16:19:31.868]                         }
[16:19:31.868]                       }
[16:19:31.868]                       invisible(muffled)
[16:19:31.868]                     }
[16:19:31.868]                     muffleCondition(cond, pattern = "^muffle")
[16:19:31.868]                   }
[16:19:31.868]                 }
[16:19:31.868]                 else {
[16:19:31.868]                   if (TRUE) {
[16:19:31.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:31.868]                     {
[16:19:31.868]                       inherits <- base::inherits
[16:19:31.868]                       invokeRestart <- base::invokeRestart
[16:19:31.868]                       is.null <- base::is.null
[16:19:31.868]                       muffled <- FALSE
[16:19:31.868]                       if (inherits(cond, "message")) {
[16:19:31.868]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:31.868]                         if (muffled) 
[16:19:31.868]                           invokeRestart("muffleMessage")
[16:19:31.868]                       }
[16:19:31.868]                       else if (inherits(cond, "warning")) {
[16:19:31.868]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:31.868]                         if (muffled) 
[16:19:31.868]                           invokeRestart("muffleWarning")
[16:19:31.868]                       }
[16:19:31.868]                       else if (inherits(cond, "condition")) {
[16:19:31.868]                         if (!is.null(pattern)) {
[16:19:31.868]                           computeRestarts <- base::computeRestarts
[16:19:31.868]                           grepl <- base::grepl
[16:19:31.868]                           restarts <- computeRestarts(cond)
[16:19:31.868]                           for (restart in restarts) {
[16:19:31.868]                             name <- restart$name
[16:19:31.868]                             if (is.null(name)) 
[16:19:31.868]                               next
[16:19:31.868]                             if (!grepl(pattern, name)) 
[16:19:31.868]                               next
[16:19:31.868]                             invokeRestart(restart)
[16:19:31.868]                             muffled <- TRUE
[16:19:31.868]                             break
[16:19:31.868]                           }
[16:19:31.868]                         }
[16:19:31.868]                       }
[16:19:31.868]                       invisible(muffled)
[16:19:31.868]                     }
[16:19:31.868]                     muffleCondition(cond, pattern = "^muffle")
[16:19:31.868]                   }
[16:19:31.868]                 }
[16:19:31.868]             }
[16:19:31.868]         }))
[16:19:31.868]     }, error = function(ex) {
[16:19:31.868]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:31.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:31.868]                 ...future.rng), started = ...future.startTime, 
[16:19:31.868]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:31.868]             version = "1.8"), class = "FutureResult")
[16:19:31.868]     }, finally = {
[16:19:31.868]         if (!identical(...future.workdir, getwd())) 
[16:19:31.868]             setwd(...future.workdir)
[16:19:31.868]         {
[16:19:31.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:31.868]                 ...future.oldOptions$nwarnings <- NULL
[16:19:31.868]             }
[16:19:31.868]             base::options(...future.oldOptions)
[16:19:31.868]             if (.Platform$OS.type == "windows") {
[16:19:31.868]                 old_names <- names(...future.oldEnvVars)
[16:19:31.868]                 envs <- base::Sys.getenv()
[16:19:31.868]                 names <- names(envs)
[16:19:31.868]                 common <- intersect(names, old_names)
[16:19:31.868]                 added <- setdiff(names, old_names)
[16:19:31.868]                 removed <- setdiff(old_names, names)
[16:19:31.868]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:31.868]                   envs[common]]
[16:19:31.868]                 NAMES <- toupper(changed)
[16:19:31.868]                 args <- list()
[16:19:31.868]                 for (kk in seq_along(NAMES)) {
[16:19:31.868]                   name <- changed[[kk]]
[16:19:31.868]                   NAME <- NAMES[[kk]]
[16:19:31.868]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:31.868]                     next
[16:19:31.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:31.868]                 }
[16:19:31.868]                 NAMES <- toupper(added)
[16:19:31.868]                 for (kk in seq_along(NAMES)) {
[16:19:31.868]                   name <- added[[kk]]
[16:19:31.868]                   NAME <- NAMES[[kk]]
[16:19:31.868]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:31.868]                     next
[16:19:31.868]                   args[[name]] <- ""
[16:19:31.868]                 }
[16:19:31.868]                 NAMES <- toupper(removed)
[16:19:31.868]                 for (kk in seq_along(NAMES)) {
[16:19:31.868]                   name <- removed[[kk]]
[16:19:31.868]                   NAME <- NAMES[[kk]]
[16:19:31.868]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:31.868]                     next
[16:19:31.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:31.868]                 }
[16:19:31.868]                 if (length(args) > 0) 
[16:19:31.868]                   base::do.call(base::Sys.setenv, args = args)
[16:19:31.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:31.868]             }
[16:19:31.868]             else {
[16:19:31.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:31.868]             }
[16:19:31.868]             {
[16:19:31.868]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:31.868]                   0L) {
[16:19:31.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:31.868]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:31.868]                   base::options(opts)
[16:19:31.868]                 }
[16:19:31.868]                 {
[16:19:31.868]                   {
[16:19:31.868]                     NULL
[16:19:31.868]                     RNGkind("Mersenne-Twister")
[16:19:31.868]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:31.868]                       inherits = FALSE)
[16:19:31.868]                   }
[16:19:31.868]                   options(future.plan = NULL)
[16:19:31.868]                   if (is.na(NA_character_)) 
[16:19:31.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:31.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:31.868]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:31.868]                     .init = FALSE)
[16:19:31.868]                 }
[16:19:31.868]             }
[16:19:31.868]         }
[16:19:31.868]     })
[16:19:31.868]     if (TRUE) {
[16:19:31.868]         base::sink(type = "output", split = FALSE)
[16:19:31.868]         if (FALSE) {
[16:19:31.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:31.868]         }
[16:19:31.868]         else {
[16:19:31.868]             ...future.result["stdout"] <- base::list(NULL)
[16:19:31.868]         }
[16:19:31.868]         base::close(...future.stdout)
[16:19:31.868]         ...future.stdout <- NULL
[16:19:31.868]     }
[16:19:31.868]     ...future.result$conditions <- ...future.conditions
[16:19:31.868]     ...future.result$finished <- base::Sys.time()
[16:19:31.868]     ...future.result
[16:19:31.868] }
[16:19:31.869] assign_globals() ...
[16:19:31.869] List of 5
[16:19:31.869]  $ ...future.FUN            :function (x, y)  
[16:19:31.869]  $ MoreArgs                 : NULL
[16:19:31.869]  $ ...future.elements_ii    :List of 2
[16:19:31.869]   ..$ :List of 2
[16:19:31.869]   .. ..$ : int 1
[16:19:31.869]   .. ..$ : int 0
[16:19:31.869]   ..$ :List of 2
[16:19:31.869]   .. ..$ : int 0
[16:19:31.869]   .. ..$ : int 1
[16:19:31.869]  $ ...future.seeds_ii       : NULL
[16:19:31.869]  $ ...future.globals.maxSize: NULL
[16:19:31.869]  - attr(*, "where")=List of 5
[16:19:31.869]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:31.869]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:31.869]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:31.869]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:31.869]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:31.869]  - attr(*, "resolved")= logi FALSE
[16:19:31.869]  - attr(*, "total_size")= num 6480
[16:19:31.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:31.869]  - attr(*, "already-done")= logi TRUE
[16:19:31.875] - reassign environment for ‘...future.FUN’
[16:19:31.875] - copied ‘...future.FUN’ to environment
[16:19:31.875] - copied ‘MoreArgs’ to environment
[16:19:31.875] - copied ‘...future.elements_ii’ to environment
[16:19:31.875] - copied ‘...future.seeds_ii’ to environment
[16:19:31.875] - copied ‘...future.globals.maxSize’ to environment
[16:19:31.876] assign_globals() ... done
[16:19:31.876] plan(): Setting new future strategy stack:
[16:19:31.876] List of future strategies:
[16:19:31.876] 1. sequential:
[16:19:31.876]    - args: function (..., envir = parent.frame())
[16:19:31.876]    - tweaked: FALSE
[16:19:31.876]    - call: NULL
[16:19:31.876] plan(): nbrOfWorkers() = 1
[16:19:32.378] plan(): Setting new future strategy stack:
[16:19:32.378] List of future strategies:
[16:19:32.378] 1. multicore:
[16:19:32.378]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:32.378]    - tweaked: FALSE
[16:19:32.378]    - call: plan(strategy)
[16:19:32.382] plan(): nbrOfWorkers() = 1
[16:19:32.382] SequentialFuture started (and completed)
[16:19:32.382] - Launch lazy future ... done
[16:19:32.383] run() for ‘SequentialFuture’ ... done
[16:19:32.383] Created future:
[16:19:32.383] SequentialFuture:
[16:19:32.383] Label: ‘future_mapply-1’
[16:19:32.383] Expression:
[16:19:32.383] {
[16:19:32.383]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:32.383]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:32.383]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:32.383]         on.exit(options(oopts), add = TRUE)
[16:19:32.383]     }
[16:19:32.383]     {
[16:19:32.383]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:32.383]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:32.383]         do.call(mapply, args = args)
[16:19:32.383]     }
[16:19:32.383] }
[16:19:32.383] Lazy evaluation: FALSE
[16:19:32.383] Asynchronous evaluation: FALSE
[16:19:32.383] Local evaluation: TRUE
[16:19:32.383] Environment: R_GlobalEnv
[16:19:32.383] Capture standard output: FALSE
[16:19:32.383] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:32.383] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:32.383] Packages: <none>
[16:19:32.383] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:32.383] Resolved: TRUE
[16:19:32.383] Value: 224 bytes of class ‘list’
[16:19:32.383] Early signaling: FALSE
[16:19:32.383] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:32.383] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:32.384] Chunk #1 of 1 ... DONE
[16:19:32.384] Launching 1 futures (chunks) ... DONE
[16:19:32.384] Resolving 1 futures (chunks) ...
[16:19:32.384] resolve() on list ...
[16:19:32.384]  recursive: 0
[16:19:32.384]  length: 1
[16:19:32.384] 
[16:19:32.385] resolved() for ‘SequentialFuture’ ...
[16:19:32.385] - state: ‘finished’
[16:19:32.385] - run: TRUE
[16:19:32.385] - result: ‘FutureResult’
[16:19:32.385] resolved() for ‘SequentialFuture’ ... done
[16:19:32.385] Future #1
[16:19:32.385] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:32.385] - nx: 1
[16:19:32.385] - relay: TRUE
[16:19:32.385] - stdout: TRUE
[16:19:32.386] - signal: TRUE
[16:19:32.386] - resignal: FALSE
[16:19:32.386] - force: TRUE
[16:19:32.386] - relayed: [n=1] FALSE
[16:19:32.386] - queued futures: [n=1] FALSE
[16:19:32.386]  - until=1
[16:19:32.386]  - relaying element #1
[16:19:32.386] - relayed: [n=1] TRUE
[16:19:32.386] - queued futures: [n=1] TRUE
[16:19:32.386] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:32.387]  length: 0 (resolved future 1)
[16:19:32.387] Relaying remaining futures
[16:19:32.387] signalConditionsASAP(NULL, pos=0) ...
[16:19:32.387] - nx: 1
[16:19:32.387] - relay: TRUE
[16:19:32.387] - stdout: TRUE
[16:19:32.387] - signal: TRUE
[16:19:32.387] - resignal: FALSE
[16:19:32.387] - force: TRUE
[16:19:32.387] - relayed: [n=1] TRUE
[16:19:32.387] - queued futures: [n=1] TRUE
 - flush all
[16:19:32.387] - relayed: [n=1] TRUE
[16:19:32.388] - queued futures: [n=1] TRUE
[16:19:32.388] signalConditionsASAP(NULL, pos=0) ... done
[16:19:32.388] resolve() on list ... DONE
[16:19:32.388]  - Number of value chunks collected: 1
[16:19:32.388] Resolving 1 futures (chunks) ... DONE
[16:19:32.390] Reducing values from 1 chunks ...
[16:19:32.390]  - Number of values collected after concatenation: 2
[16:19:32.390]  - Number of values expected: 2
[16:19:32.390] Reducing values from 1 chunks ... DONE
[16:19:32.391] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:19:32.391] future_mapply() ...
[16:19:32.394] Number of chunks: 1
[16:19:32.395] getGlobalsAndPackagesXApply() ...
[16:19:32.395]  - future.globals: TRUE
[16:19:32.395] getGlobalsAndPackages() ...
[16:19:32.395] Searching for globals...
[16:19:32.396] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:32.397] Searching for globals ... DONE
[16:19:32.397] Resolving globals: FALSE
[16:19:32.397] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:32.397] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:32.398] - globals: [1] ‘FUN’
[16:19:32.398] 
[16:19:32.398] getGlobalsAndPackages() ... DONE
[16:19:32.398]  - globals found/used: [n=1] ‘FUN’
[16:19:32.398]  - needed namespaces: [n=0] 
[16:19:32.398] Finding globals ... DONE
[16:19:32.398] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:32.398] List of 2
[16:19:32.398]  $ ...future.FUN:function (x, y)  
[16:19:32.398]  $ MoreArgs     : NULL
[16:19:32.398]  - attr(*, "where")=List of 2
[16:19:32.398]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:32.398]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:32.398]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:32.398]  - attr(*, "resolved")= logi FALSE
[16:19:32.398]  - attr(*, "total_size")= num NA
[16:19:32.401] Packages to be attached in all futures: [n=0] 
[16:19:32.401] getGlobalsAndPackagesXApply() ... DONE
[16:19:32.401] Number of futures (= number of chunks): 1
[16:19:32.401] Launching 1 futures (chunks) ...
[16:19:32.401] Chunk #1 of 1 ...
[16:19:32.401]  - Finding globals in '...' for chunk #1 ...
[16:19:32.402] getGlobalsAndPackages() ...
[16:19:32.402] Searching for globals...
[16:19:32.402] 
[16:19:32.402] Searching for globals ... DONE
[16:19:32.402] - globals: [0] <none>
[16:19:32.402] getGlobalsAndPackages() ... DONE
[16:19:32.402]    + additional globals found: [n=0] 
[16:19:32.402]    + additional namespaces needed: [n=0] 
[16:19:32.402]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:32.403]  - seeds: <none>
[16:19:32.403]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:32.403] getGlobalsAndPackages() ...
[16:19:32.403] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:32.403] Resolving globals: FALSE
[16:19:32.403] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:19:32.404] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:32.404] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:32.404] 
[16:19:32.404] getGlobalsAndPackages() ... DONE
[16:19:32.405] run() for ‘Future’ ...
[16:19:32.405] - state: ‘created’
[16:19:32.405] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:32.408] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:32.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:32.408]   - Field: ‘label’
[16:19:32.408]   - Field: ‘local’
[16:19:32.409]   - Field: ‘owner’
[16:19:32.409]   - Field: ‘envir’
[16:19:32.409]   - Field: ‘packages’
[16:19:32.409]   - Field: ‘gc’
[16:19:32.409]   - Field: ‘conditions’
[16:19:32.409]   - Field: ‘expr’
[16:19:32.409]   - Field: ‘uuid’
[16:19:32.409]   - Field: ‘seed’
[16:19:32.409]   - Field: ‘version’
[16:19:32.409]   - Field: ‘result’
[16:19:32.410]   - Field: ‘asynchronous’
[16:19:32.410]   - Field: ‘calls’
[16:19:32.410]   - Field: ‘globals’
[16:19:32.410]   - Field: ‘stdout’
[16:19:32.410]   - Field: ‘earlySignal’
[16:19:32.410]   - Field: ‘lazy’
[16:19:32.410]   - Field: ‘state’
[16:19:32.410] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:32.410] - Launch lazy future ...
[16:19:32.410] Packages needed by the future expression (n = 0): <none>
[16:19:32.411] Packages needed by future strategies (n = 0): <none>
[16:19:32.411] {
[16:19:32.411]     {
[16:19:32.411]         {
[16:19:32.411]             ...future.startTime <- base::Sys.time()
[16:19:32.411]             {
[16:19:32.411]                 {
[16:19:32.411]                   {
[16:19:32.411]                     base::local({
[16:19:32.411]                       has_future <- base::requireNamespace("future", 
[16:19:32.411]                         quietly = TRUE)
[16:19:32.411]                       if (has_future) {
[16:19:32.411]                         ns <- base::getNamespace("future")
[16:19:32.411]                         version <- ns[[".package"]][["version"]]
[16:19:32.411]                         if (is.null(version)) 
[16:19:32.411]                           version <- utils::packageVersion("future")
[16:19:32.411]                       }
[16:19:32.411]                       else {
[16:19:32.411]                         version <- NULL
[16:19:32.411]                       }
[16:19:32.411]                       if (!has_future || version < "1.8.0") {
[16:19:32.411]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:32.411]                           "", base::R.version$version.string), 
[16:19:32.411]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:32.411]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:32.411]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:32.411]                             "release", "version")], collapse = " "), 
[16:19:32.411]                           hostname = base::Sys.info()[["nodename"]])
[16:19:32.411]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:32.411]                           info)
[16:19:32.411]                         info <- base::paste(info, collapse = "; ")
[16:19:32.411]                         if (!has_future) {
[16:19:32.411]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:32.411]                             info)
[16:19:32.411]                         }
[16:19:32.411]                         else {
[16:19:32.411]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:32.411]                             info, version)
[16:19:32.411]                         }
[16:19:32.411]                         base::stop(msg)
[16:19:32.411]                       }
[16:19:32.411]                     })
[16:19:32.411]                   }
[16:19:32.411]                   ...future.strategy.old <- future::plan("list")
[16:19:32.411]                   options(future.plan = NULL)
[16:19:32.411]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:32.411]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:32.411]                 }
[16:19:32.411]                 ...future.workdir <- getwd()
[16:19:32.411]             }
[16:19:32.411]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:32.411]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:32.411]         }
[16:19:32.411]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:32.411]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:32.411]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:32.411]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:32.411]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:32.411]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:32.411]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:32.411]             base::names(...future.oldOptions))
[16:19:32.411]     }
[16:19:32.411]     if (FALSE) {
[16:19:32.411]     }
[16:19:32.411]     else {
[16:19:32.411]         if (TRUE) {
[16:19:32.411]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:32.411]                 open = "w")
[16:19:32.411]         }
[16:19:32.411]         else {
[16:19:32.411]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:32.411]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:32.411]         }
[16:19:32.411]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:32.411]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:32.411]             base::sink(type = "output", split = FALSE)
[16:19:32.411]             base::close(...future.stdout)
[16:19:32.411]         }, add = TRUE)
[16:19:32.411]     }
[16:19:32.411]     ...future.frame <- base::sys.nframe()
[16:19:32.411]     ...future.conditions <- base::list()
[16:19:32.411]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:32.411]     if (FALSE) {
[16:19:32.411]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:32.411]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:32.411]     }
[16:19:32.411]     ...future.result <- base::tryCatch({
[16:19:32.411]         base::withCallingHandlers({
[16:19:32.411]             ...future.value <- base::withVisible(base::local({
[16:19:32.411]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:32.411]                 if (!identical(...future.globals.maxSize.org, 
[16:19:32.411]                   ...future.globals.maxSize)) {
[16:19:32.411]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:32.411]                   on.exit(options(oopts), add = TRUE)
[16:19:32.411]                 }
[16:19:32.411]                 {
[16:19:32.411]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:32.411]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:32.411]                     USE.NAMES = FALSE)
[16:19:32.411]                   do.call(mapply, args = args)
[16:19:32.411]                 }
[16:19:32.411]             }))
[16:19:32.411]             future::FutureResult(value = ...future.value$value, 
[16:19:32.411]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:32.411]                   ...future.rng), globalenv = if (FALSE) 
[16:19:32.411]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:32.411]                     ...future.globalenv.names))
[16:19:32.411]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:32.411]         }, condition = base::local({
[16:19:32.411]             c <- base::c
[16:19:32.411]             inherits <- base::inherits
[16:19:32.411]             invokeRestart <- base::invokeRestart
[16:19:32.411]             length <- base::length
[16:19:32.411]             list <- base::list
[16:19:32.411]             seq.int <- base::seq.int
[16:19:32.411]             signalCondition <- base::signalCondition
[16:19:32.411]             sys.calls <- base::sys.calls
[16:19:32.411]             `[[` <- base::`[[`
[16:19:32.411]             `+` <- base::`+`
[16:19:32.411]             `<<-` <- base::`<<-`
[16:19:32.411]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:32.411]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:32.411]                   3L)]
[16:19:32.411]             }
[16:19:32.411]             function(cond) {
[16:19:32.411]                 is_error <- inherits(cond, "error")
[16:19:32.411]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:32.411]                   NULL)
[16:19:32.411]                 if (is_error) {
[16:19:32.411]                   sessionInformation <- function() {
[16:19:32.411]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:32.411]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:32.411]                       search = base::search(), system = base::Sys.info())
[16:19:32.411]                   }
[16:19:32.411]                   ...future.conditions[[length(...future.conditions) + 
[16:19:32.411]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:32.411]                     cond$call), session = sessionInformation(), 
[16:19:32.411]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:32.411]                   signalCondition(cond)
[16:19:32.411]                 }
[16:19:32.411]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:32.411]                 "immediateCondition"))) {
[16:19:32.411]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:32.411]                   ...future.conditions[[length(...future.conditions) + 
[16:19:32.411]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:32.411]                   if (TRUE && !signal) {
[16:19:32.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:32.411]                     {
[16:19:32.411]                       inherits <- base::inherits
[16:19:32.411]                       invokeRestart <- base::invokeRestart
[16:19:32.411]                       is.null <- base::is.null
[16:19:32.411]                       muffled <- FALSE
[16:19:32.411]                       if (inherits(cond, "message")) {
[16:19:32.411]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:32.411]                         if (muffled) 
[16:19:32.411]                           invokeRestart("muffleMessage")
[16:19:32.411]                       }
[16:19:32.411]                       else if (inherits(cond, "warning")) {
[16:19:32.411]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:32.411]                         if (muffled) 
[16:19:32.411]                           invokeRestart("muffleWarning")
[16:19:32.411]                       }
[16:19:32.411]                       else if (inherits(cond, "condition")) {
[16:19:32.411]                         if (!is.null(pattern)) {
[16:19:32.411]                           computeRestarts <- base::computeRestarts
[16:19:32.411]                           grepl <- base::grepl
[16:19:32.411]                           restarts <- computeRestarts(cond)
[16:19:32.411]                           for (restart in restarts) {
[16:19:32.411]                             name <- restart$name
[16:19:32.411]                             if (is.null(name)) 
[16:19:32.411]                               next
[16:19:32.411]                             if (!grepl(pattern, name)) 
[16:19:32.411]                               next
[16:19:32.411]                             invokeRestart(restart)
[16:19:32.411]                             muffled <- TRUE
[16:19:32.411]                             break
[16:19:32.411]                           }
[16:19:32.411]                         }
[16:19:32.411]                       }
[16:19:32.411]                       invisible(muffled)
[16:19:32.411]                     }
[16:19:32.411]                     muffleCondition(cond, pattern = "^muffle")
[16:19:32.411]                   }
[16:19:32.411]                 }
[16:19:32.411]                 else {
[16:19:32.411]                   if (TRUE) {
[16:19:32.411]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:32.411]                     {
[16:19:32.411]                       inherits <- base::inherits
[16:19:32.411]                       invokeRestart <- base::invokeRestart
[16:19:32.411]                       is.null <- base::is.null
[16:19:32.411]                       muffled <- FALSE
[16:19:32.411]                       if (inherits(cond, "message")) {
[16:19:32.411]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:32.411]                         if (muffled) 
[16:19:32.411]                           invokeRestart("muffleMessage")
[16:19:32.411]                       }
[16:19:32.411]                       else if (inherits(cond, "warning")) {
[16:19:32.411]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:32.411]                         if (muffled) 
[16:19:32.411]                           invokeRestart("muffleWarning")
[16:19:32.411]                       }
[16:19:32.411]                       else if (inherits(cond, "condition")) {
[16:19:32.411]                         if (!is.null(pattern)) {
[16:19:32.411]                           computeRestarts <- base::computeRestarts
[16:19:32.411]                           grepl <- base::grepl
[16:19:32.411]                           restarts <- computeRestarts(cond)
[16:19:32.411]                           for (restart in restarts) {
[16:19:32.411]                             name <- restart$name
[16:19:32.411]                             if (is.null(name)) 
[16:19:32.411]                               next
[16:19:32.411]                             if (!grepl(pattern, name)) 
[16:19:32.411]                               next
[16:19:32.411]                             invokeRestart(restart)
[16:19:32.411]                             muffled <- TRUE
[16:19:32.411]                             break
[16:19:32.411]                           }
[16:19:32.411]                         }
[16:19:32.411]                       }
[16:19:32.411]                       invisible(muffled)
[16:19:32.411]                     }
[16:19:32.411]                     muffleCondition(cond, pattern = "^muffle")
[16:19:32.411]                   }
[16:19:32.411]                 }
[16:19:32.411]             }
[16:19:32.411]         }))
[16:19:32.411]     }, error = function(ex) {
[16:19:32.411]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:32.411]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:32.411]                 ...future.rng), started = ...future.startTime, 
[16:19:32.411]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:32.411]             version = "1.8"), class = "FutureResult")
[16:19:32.411]     }, finally = {
[16:19:32.411]         if (!identical(...future.workdir, getwd())) 
[16:19:32.411]             setwd(...future.workdir)
[16:19:32.411]         {
[16:19:32.411]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:32.411]                 ...future.oldOptions$nwarnings <- NULL
[16:19:32.411]             }
[16:19:32.411]             base::options(...future.oldOptions)
[16:19:32.411]             if (.Platform$OS.type == "windows") {
[16:19:32.411]                 old_names <- names(...future.oldEnvVars)
[16:19:32.411]                 envs <- base::Sys.getenv()
[16:19:32.411]                 names <- names(envs)
[16:19:32.411]                 common <- intersect(names, old_names)
[16:19:32.411]                 added <- setdiff(names, old_names)
[16:19:32.411]                 removed <- setdiff(old_names, names)
[16:19:32.411]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:32.411]                   envs[common]]
[16:19:32.411]                 NAMES <- toupper(changed)
[16:19:32.411]                 args <- list()
[16:19:32.411]                 for (kk in seq_along(NAMES)) {
[16:19:32.411]                   name <- changed[[kk]]
[16:19:32.411]                   NAME <- NAMES[[kk]]
[16:19:32.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:32.411]                     next
[16:19:32.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:32.411]                 }
[16:19:32.411]                 NAMES <- toupper(added)
[16:19:32.411]                 for (kk in seq_along(NAMES)) {
[16:19:32.411]                   name <- added[[kk]]
[16:19:32.411]                   NAME <- NAMES[[kk]]
[16:19:32.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:32.411]                     next
[16:19:32.411]                   args[[name]] <- ""
[16:19:32.411]                 }
[16:19:32.411]                 NAMES <- toupper(removed)
[16:19:32.411]                 for (kk in seq_along(NAMES)) {
[16:19:32.411]                   name <- removed[[kk]]
[16:19:32.411]                   NAME <- NAMES[[kk]]
[16:19:32.411]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:32.411]                     next
[16:19:32.411]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:32.411]                 }
[16:19:32.411]                 if (length(args) > 0) 
[16:19:32.411]                   base::do.call(base::Sys.setenv, args = args)
[16:19:32.411]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:32.411]             }
[16:19:32.411]             else {
[16:19:32.411]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:32.411]             }
[16:19:32.411]             {
[16:19:32.411]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:32.411]                   0L) {
[16:19:32.411]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:32.411]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:32.411]                   base::options(opts)
[16:19:32.411]                 }
[16:19:32.411]                 {
[16:19:32.411]                   {
[16:19:32.411]                     NULL
[16:19:32.411]                     RNGkind("Mersenne-Twister")
[16:19:32.411]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:32.411]                       inherits = FALSE)
[16:19:32.411]                   }
[16:19:32.411]                   options(future.plan = NULL)
[16:19:32.411]                   if (is.na(NA_character_)) 
[16:19:32.411]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:32.411]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:32.411]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:32.411]                     .init = FALSE)
[16:19:32.411]                 }
[16:19:32.411]             }
[16:19:32.411]         }
[16:19:32.411]     })
[16:19:32.411]     if (TRUE) {
[16:19:32.411]         base::sink(type = "output", split = FALSE)
[16:19:32.411]         if (TRUE) {
[16:19:32.411]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:32.411]         }
[16:19:32.411]         else {
[16:19:32.411]             ...future.result["stdout"] <- base::list(NULL)
[16:19:32.411]         }
[16:19:32.411]         base::close(...future.stdout)
[16:19:32.411]         ...future.stdout <- NULL
[16:19:32.411]     }
[16:19:32.411]     ...future.result$conditions <- ...future.conditions
[16:19:32.411]     ...future.result$finished <- base::Sys.time()
[16:19:32.411]     ...future.result
[16:19:32.411] }
[16:19:32.413] assign_globals() ...
[16:19:32.413] List of 5
[16:19:32.413]  $ ...future.FUN            :function (x, y)  
[16:19:32.413]  $ MoreArgs                 : NULL
[16:19:32.413]  $ ...future.elements_ii    :List of 2
[16:19:32.413]   ..$ :List of 2
[16:19:32.413]   .. ..$ : int 1
[16:19:32.413]   .. ..$ : int 0
[16:19:32.413]   ..$ :List of 2
[16:19:32.413]   .. ..$ : int 0
[16:19:32.413]   .. ..$ : int 1
[16:19:32.413]  $ ...future.seeds_ii       : NULL
[16:19:32.413]  $ ...future.globals.maxSize: NULL
[16:19:32.413]  - attr(*, "where")=List of 5
[16:19:32.413]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:32.413]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:32.413]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:32.413]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:32.413]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:32.413]  - attr(*, "resolved")= logi FALSE
[16:19:32.413]  - attr(*, "total_size")= num 6480
[16:19:32.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:32.413]  - attr(*, "already-done")= logi TRUE
[16:19:32.420] - reassign environment for ‘...future.FUN’
[16:19:32.420] - copied ‘...future.FUN’ to environment
[16:19:32.420] - copied ‘MoreArgs’ to environment
[16:19:32.420] - copied ‘...future.elements_ii’ to environment
[16:19:32.421] - copied ‘...future.seeds_ii’ to environment
[16:19:32.421] - copied ‘...future.globals.maxSize’ to environment
[16:19:32.421] assign_globals() ... done
[16:19:32.421] plan(): Setting new future strategy stack:
[16:19:32.421] List of future strategies:
[16:19:32.421] 1. sequential:
[16:19:32.421]    - args: function (..., envir = parent.frame())
[16:19:32.421]    - tweaked: FALSE
[16:19:32.421]    - call: NULL
[16:19:32.421] plan(): nbrOfWorkers() = 1
[16:19:32.923] plan(): Setting new future strategy stack:
[16:19:32.923] List of future strategies:
[16:19:32.923] 1. multicore:
[16:19:32.923]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:32.923]    - tweaked: FALSE
[16:19:32.923]    - call: plan(strategy)
[16:19:32.928] plan(): nbrOfWorkers() = 1
[16:19:32.928] SequentialFuture started (and completed)
[16:19:32.928] - Launch lazy future ... done
[16:19:32.928] run() for ‘SequentialFuture’ ... done
[16:19:32.928] Created future:
[16:19:32.928] SequentialFuture:
[16:19:32.928] Label: ‘future_mapply-1’
[16:19:32.928] Expression:
[16:19:32.928] {
[16:19:32.928]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:32.928]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:32.928]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:32.928]         on.exit(options(oopts), add = TRUE)
[16:19:32.928]     }
[16:19:32.928]     {
[16:19:32.928]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:32.928]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:32.928]         do.call(mapply, args = args)
[16:19:32.928]     }
[16:19:32.928] }
[16:19:32.928] Lazy evaluation: FALSE
[16:19:32.928] Asynchronous evaluation: FALSE
[16:19:32.928] Local evaluation: TRUE
[16:19:32.928] Environment: R_GlobalEnv
[16:19:32.928] Capture standard output: TRUE
[16:19:32.928] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:32.928] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:32.928] Packages: <none>
[16:19:32.928] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:32.928] Resolved: TRUE
[16:19:32.928] Value: 224 bytes of class ‘list’
[16:19:32.928] Early signaling: FALSE
[16:19:32.928] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:32.928] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:32.930] Chunk #1 of 1 ... DONE
[16:19:32.930] Launching 1 futures (chunks) ... DONE
[16:19:32.930] Resolving 1 futures (chunks) ...
[16:19:32.930] resolve() on list ...
[16:19:32.930]  recursive: 0
[16:19:32.930]  length: 1
[16:19:32.930] 
[16:19:32.930] resolved() for ‘SequentialFuture’ ...
[16:19:32.930] - state: ‘finished’
[16:19:32.930] - run: TRUE
[16:19:32.931] - result: ‘FutureResult’
[16:19:32.931] resolved() for ‘SequentialFuture’ ... done
[16:19:32.931] Future #1
[16:19:32.931] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:32.931] - nx: 1
[16:19:32.931] - relay: TRUE
[16:19:32.931] - stdout: TRUE
[16:19:32.931] - signal: TRUE
[16:19:32.931] - resignal: FALSE
[16:19:32.931] - force: TRUE
[16:19:32.932] - relayed: [n=1] FALSE
[16:19:32.932] - queued futures: [n=1] FALSE
[16:19:32.932]  - until=1
[16:19:32.932]  - relaying element #1
[16:19:32.932] - relayed: [n=1] TRUE
[16:19:32.932] - queued futures: [n=1] TRUE
[16:19:32.932] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:32.932]  length: 0 (resolved future 1)
[16:19:32.932] Relaying remaining futures
[16:19:32.933] signalConditionsASAP(NULL, pos=0) ...
[16:19:32.933] - nx: 1
[16:19:32.933] - relay: TRUE
[16:19:32.933] - stdout: TRUE
[16:19:32.933] - signal: TRUE
[16:19:32.933] - resignal: FALSE
[16:19:32.933] - force: TRUE
[16:19:32.933] - relayed: [n=1] TRUE
[16:19:32.933] - queued futures: [n=1] TRUE
 - flush all
[16:19:32.933] - relayed: [n=1] TRUE
[16:19:32.933] - queued futures: [n=1] TRUE
[16:19:32.934] signalConditionsASAP(NULL, pos=0) ... done
[16:19:32.934] resolve() on list ... DONE
[16:19:32.934]  - Number of value chunks collected: 1
[16:19:32.934] Resolving 1 futures (chunks) ... DONE
[16:19:32.934] Reducing values from 1 chunks ...
[16:19:32.934]  - Number of values collected after concatenation: 2
[16:19:32.934]  - Number of values expected: 2
[16:19:32.934] Reducing values from 1 chunks ... DONE
[16:19:32.934] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:19:32.935] future_mapply() ...
[16:19:32.938] Number of chunks: 1
[16:19:32.938] getGlobalsAndPackagesXApply() ...
[16:19:32.938]  - future.globals: TRUE
[16:19:32.938] getGlobalsAndPackages() ...
[16:19:32.938] Searching for globals...
[16:19:32.940] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:32.940] Searching for globals ... DONE
[16:19:32.940] Resolving globals: FALSE
[16:19:32.941] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:32.941] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:32.941] - globals: [1] ‘FUN’
[16:19:32.941] 
[16:19:32.941] getGlobalsAndPackages() ... DONE
[16:19:32.941]  - globals found/used: [n=1] ‘FUN’
[16:19:32.942]  - needed namespaces: [n=0] 
[16:19:32.942] Finding globals ... DONE
[16:19:32.942] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:32.942] List of 2
[16:19:32.942]  $ ...future.FUN:function (x, y)  
[16:19:32.942]  $ MoreArgs     : NULL
[16:19:32.942]  - attr(*, "where")=List of 2
[16:19:32.942]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:32.942]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:32.942]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:32.942]  - attr(*, "resolved")= logi FALSE
[16:19:32.942]  - attr(*, "total_size")= num NA
[16:19:32.944] Packages to be attached in all futures: [n=0] 
[16:19:32.945] getGlobalsAndPackagesXApply() ... DONE
[16:19:32.945] Number of futures (= number of chunks): 1
[16:19:32.945] Launching 1 futures (chunks) ...
[16:19:32.945] Chunk #1 of 1 ...
[16:19:32.945]  - Finding globals in '...' for chunk #1 ...
[16:19:32.945] getGlobalsAndPackages() ...
[16:19:32.945] Searching for globals...
[16:19:32.946] 
[16:19:32.946] Searching for globals ... DONE
[16:19:32.946] - globals: [0] <none>
[16:19:32.946] getGlobalsAndPackages() ... DONE
[16:19:32.946]    + additional globals found: [n=0] 
[16:19:32.946]    + additional namespaces needed: [n=0] 
[16:19:32.946]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:32.946]  - seeds: <none>
[16:19:32.946]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:32.946] getGlobalsAndPackages() ...
[16:19:32.947] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:32.947] Resolving globals: FALSE
[16:19:32.949] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:19:32.949] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:32.949] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:32.950] 
[16:19:32.950] getGlobalsAndPackages() ... DONE
[16:19:32.950] run() for ‘Future’ ...
[16:19:32.950] - state: ‘created’
[16:19:32.950] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:32.954] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:32.954] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:32.954]   - Field: ‘label’
[16:19:32.954]   - Field: ‘local’
[16:19:32.954]   - Field: ‘owner’
[16:19:32.954]   - Field: ‘envir’
[16:19:32.954]   - Field: ‘packages’
[16:19:32.954]   - Field: ‘gc’
[16:19:32.955]   - Field: ‘conditions’
[16:19:32.955]   - Field: ‘expr’
[16:19:32.955]   - Field: ‘uuid’
[16:19:32.955]   - Field: ‘seed’
[16:19:32.955]   - Field: ‘version’
[16:19:32.955]   - Field: ‘result’
[16:19:32.955]   - Field: ‘asynchronous’
[16:19:32.955]   - Field: ‘calls’
[16:19:32.955]   - Field: ‘globals’
[16:19:32.955]   - Field: ‘stdout’
[16:19:32.955]   - Field: ‘earlySignal’
[16:19:32.956]   - Field: ‘lazy’
[16:19:32.956]   - Field: ‘state’
[16:19:32.956] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:32.956] - Launch lazy future ...
[16:19:32.956] Packages needed by the future expression (n = 0): <none>
[16:19:32.956] Packages needed by future strategies (n = 0): <none>
[16:19:32.957] {
[16:19:32.957]     {
[16:19:32.957]         {
[16:19:32.957]             ...future.startTime <- base::Sys.time()
[16:19:32.957]             {
[16:19:32.957]                 {
[16:19:32.957]                   {
[16:19:32.957]                     base::local({
[16:19:32.957]                       has_future <- base::requireNamespace("future", 
[16:19:32.957]                         quietly = TRUE)
[16:19:32.957]                       if (has_future) {
[16:19:32.957]                         ns <- base::getNamespace("future")
[16:19:32.957]                         version <- ns[[".package"]][["version"]]
[16:19:32.957]                         if (is.null(version)) 
[16:19:32.957]                           version <- utils::packageVersion("future")
[16:19:32.957]                       }
[16:19:32.957]                       else {
[16:19:32.957]                         version <- NULL
[16:19:32.957]                       }
[16:19:32.957]                       if (!has_future || version < "1.8.0") {
[16:19:32.957]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:32.957]                           "", base::R.version$version.string), 
[16:19:32.957]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:32.957]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:32.957]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:32.957]                             "release", "version")], collapse = " "), 
[16:19:32.957]                           hostname = base::Sys.info()[["nodename"]])
[16:19:32.957]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:32.957]                           info)
[16:19:32.957]                         info <- base::paste(info, collapse = "; ")
[16:19:32.957]                         if (!has_future) {
[16:19:32.957]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:32.957]                             info)
[16:19:32.957]                         }
[16:19:32.957]                         else {
[16:19:32.957]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:32.957]                             info, version)
[16:19:32.957]                         }
[16:19:32.957]                         base::stop(msg)
[16:19:32.957]                       }
[16:19:32.957]                     })
[16:19:32.957]                   }
[16:19:32.957]                   ...future.strategy.old <- future::plan("list")
[16:19:32.957]                   options(future.plan = NULL)
[16:19:32.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:32.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:32.957]                 }
[16:19:32.957]                 ...future.workdir <- getwd()
[16:19:32.957]             }
[16:19:32.957]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:32.957]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:32.957]         }
[16:19:32.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:32.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:32.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:32.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:32.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:32.957]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:32.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:32.957]             base::names(...future.oldOptions))
[16:19:32.957]     }
[16:19:32.957]     if (TRUE) {
[16:19:32.957]     }
[16:19:32.957]     else {
[16:19:32.957]         if (NA) {
[16:19:32.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:32.957]                 open = "w")
[16:19:32.957]         }
[16:19:32.957]         else {
[16:19:32.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:32.957]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:32.957]         }
[16:19:32.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:32.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:32.957]             base::sink(type = "output", split = FALSE)
[16:19:32.957]             base::close(...future.stdout)
[16:19:32.957]         }, add = TRUE)
[16:19:32.957]     }
[16:19:32.957]     ...future.frame <- base::sys.nframe()
[16:19:32.957]     ...future.conditions <- base::list()
[16:19:32.957]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:32.957]     if (FALSE) {
[16:19:32.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:32.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:32.957]     }
[16:19:32.957]     ...future.result <- base::tryCatch({
[16:19:32.957]         base::withCallingHandlers({
[16:19:32.957]             ...future.value <- base::withVisible(base::local({
[16:19:32.957]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:32.957]                 if (!identical(...future.globals.maxSize.org, 
[16:19:32.957]                   ...future.globals.maxSize)) {
[16:19:32.957]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:32.957]                   on.exit(options(oopts), add = TRUE)
[16:19:32.957]                 }
[16:19:32.957]                 {
[16:19:32.957]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:32.957]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:32.957]                     USE.NAMES = FALSE)
[16:19:32.957]                   do.call(mapply, args = args)
[16:19:32.957]                 }
[16:19:32.957]             }))
[16:19:32.957]             future::FutureResult(value = ...future.value$value, 
[16:19:32.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:32.957]                   ...future.rng), globalenv = if (FALSE) 
[16:19:32.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:32.957]                     ...future.globalenv.names))
[16:19:32.957]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:32.957]         }, condition = base::local({
[16:19:32.957]             c <- base::c
[16:19:32.957]             inherits <- base::inherits
[16:19:32.957]             invokeRestart <- base::invokeRestart
[16:19:32.957]             length <- base::length
[16:19:32.957]             list <- base::list
[16:19:32.957]             seq.int <- base::seq.int
[16:19:32.957]             signalCondition <- base::signalCondition
[16:19:32.957]             sys.calls <- base::sys.calls
[16:19:32.957]             `[[` <- base::`[[`
[16:19:32.957]             `+` <- base::`+`
[16:19:32.957]             `<<-` <- base::`<<-`
[16:19:32.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:32.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:32.957]                   3L)]
[16:19:32.957]             }
[16:19:32.957]             function(cond) {
[16:19:32.957]                 is_error <- inherits(cond, "error")
[16:19:32.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:32.957]                   NULL)
[16:19:32.957]                 if (is_error) {
[16:19:32.957]                   sessionInformation <- function() {
[16:19:32.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:32.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:32.957]                       search = base::search(), system = base::Sys.info())
[16:19:32.957]                   }
[16:19:32.957]                   ...future.conditions[[length(...future.conditions) + 
[16:19:32.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:32.957]                     cond$call), session = sessionInformation(), 
[16:19:32.957]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:32.957]                   signalCondition(cond)
[16:19:32.957]                 }
[16:19:32.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:32.957]                 "immediateCondition"))) {
[16:19:32.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:32.957]                   ...future.conditions[[length(...future.conditions) + 
[16:19:32.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:32.957]                   if (TRUE && !signal) {
[16:19:32.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:32.957]                     {
[16:19:32.957]                       inherits <- base::inherits
[16:19:32.957]                       invokeRestart <- base::invokeRestart
[16:19:32.957]                       is.null <- base::is.null
[16:19:32.957]                       muffled <- FALSE
[16:19:32.957]                       if (inherits(cond, "message")) {
[16:19:32.957]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:32.957]                         if (muffled) 
[16:19:32.957]                           invokeRestart("muffleMessage")
[16:19:32.957]                       }
[16:19:32.957]                       else if (inherits(cond, "warning")) {
[16:19:32.957]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:32.957]                         if (muffled) 
[16:19:32.957]                           invokeRestart("muffleWarning")
[16:19:32.957]                       }
[16:19:32.957]                       else if (inherits(cond, "condition")) {
[16:19:32.957]                         if (!is.null(pattern)) {
[16:19:32.957]                           computeRestarts <- base::computeRestarts
[16:19:32.957]                           grepl <- base::grepl
[16:19:32.957]                           restarts <- computeRestarts(cond)
[16:19:32.957]                           for (restart in restarts) {
[16:19:32.957]                             name <- restart$name
[16:19:32.957]                             if (is.null(name)) 
[16:19:32.957]                               next
[16:19:32.957]                             if (!grepl(pattern, name)) 
[16:19:32.957]                               next
[16:19:32.957]                             invokeRestart(restart)
[16:19:32.957]                             muffled <- TRUE
[16:19:32.957]                             break
[16:19:32.957]                           }
[16:19:32.957]                         }
[16:19:32.957]                       }
[16:19:32.957]                       invisible(muffled)
[16:19:32.957]                     }
[16:19:32.957]                     muffleCondition(cond, pattern = "^muffle")
[16:19:32.957]                   }
[16:19:32.957]                 }
[16:19:32.957]                 else {
[16:19:32.957]                   if (TRUE) {
[16:19:32.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:32.957]                     {
[16:19:32.957]                       inherits <- base::inherits
[16:19:32.957]                       invokeRestart <- base::invokeRestart
[16:19:32.957]                       is.null <- base::is.null
[16:19:32.957]                       muffled <- FALSE
[16:19:32.957]                       if (inherits(cond, "message")) {
[16:19:32.957]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:32.957]                         if (muffled) 
[16:19:32.957]                           invokeRestart("muffleMessage")
[16:19:32.957]                       }
[16:19:32.957]                       else if (inherits(cond, "warning")) {
[16:19:32.957]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:32.957]                         if (muffled) 
[16:19:32.957]                           invokeRestart("muffleWarning")
[16:19:32.957]                       }
[16:19:32.957]                       else if (inherits(cond, "condition")) {
[16:19:32.957]                         if (!is.null(pattern)) {
[16:19:32.957]                           computeRestarts <- base::computeRestarts
[16:19:32.957]                           grepl <- base::grepl
[16:19:32.957]                           restarts <- computeRestarts(cond)
[16:19:32.957]                           for (restart in restarts) {
[16:19:32.957]                             name <- restart$name
[16:19:32.957]                             if (is.null(name)) 
[16:19:32.957]                               next
[16:19:32.957]                             if (!grepl(pattern, name)) 
[16:19:32.957]                               next
[16:19:32.957]                             invokeRestart(restart)
[16:19:32.957]                             muffled <- TRUE
[16:19:32.957]                             break
[16:19:32.957]                           }
[16:19:32.957]                         }
[16:19:32.957]                       }
[16:19:32.957]                       invisible(muffled)
[16:19:32.957]                     }
[16:19:32.957]                     muffleCondition(cond, pattern = "^muffle")
[16:19:32.957]                   }
[16:19:32.957]                 }
[16:19:32.957]             }
[16:19:32.957]         }))
[16:19:32.957]     }, error = function(ex) {
[16:19:32.957]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:32.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:32.957]                 ...future.rng), started = ...future.startTime, 
[16:19:32.957]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:32.957]             version = "1.8"), class = "FutureResult")
[16:19:32.957]     }, finally = {
[16:19:32.957]         if (!identical(...future.workdir, getwd())) 
[16:19:32.957]             setwd(...future.workdir)
[16:19:32.957]         {
[16:19:32.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:32.957]                 ...future.oldOptions$nwarnings <- NULL
[16:19:32.957]             }
[16:19:32.957]             base::options(...future.oldOptions)
[16:19:32.957]             if (.Platform$OS.type == "windows") {
[16:19:32.957]                 old_names <- names(...future.oldEnvVars)
[16:19:32.957]                 envs <- base::Sys.getenv()
[16:19:32.957]                 names <- names(envs)
[16:19:32.957]                 common <- intersect(names, old_names)
[16:19:32.957]                 added <- setdiff(names, old_names)
[16:19:32.957]                 removed <- setdiff(old_names, names)
[16:19:32.957]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:32.957]                   envs[common]]
[16:19:32.957]                 NAMES <- toupper(changed)
[16:19:32.957]                 args <- list()
[16:19:32.957]                 for (kk in seq_along(NAMES)) {
[16:19:32.957]                   name <- changed[[kk]]
[16:19:32.957]                   NAME <- NAMES[[kk]]
[16:19:32.957]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:32.957]                     next
[16:19:32.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:32.957]                 }
[16:19:32.957]                 NAMES <- toupper(added)
[16:19:32.957]                 for (kk in seq_along(NAMES)) {
[16:19:32.957]                   name <- added[[kk]]
[16:19:32.957]                   NAME <- NAMES[[kk]]
[16:19:32.957]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:32.957]                     next
[16:19:32.957]                   args[[name]] <- ""
[16:19:32.957]                 }
[16:19:32.957]                 NAMES <- toupper(removed)
[16:19:32.957]                 for (kk in seq_along(NAMES)) {
[16:19:32.957]                   name <- removed[[kk]]
[16:19:32.957]                   NAME <- NAMES[[kk]]
[16:19:32.957]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:32.957]                     next
[16:19:32.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:32.957]                 }
[16:19:32.957]                 if (length(args) > 0) 
[16:19:32.957]                   base::do.call(base::Sys.setenv, args = args)
[16:19:32.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:32.957]             }
[16:19:32.957]             else {
[16:19:32.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:32.957]             }
[16:19:32.957]             {
[16:19:32.957]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:32.957]                   0L) {
[16:19:32.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:32.957]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:32.957]                   base::options(opts)
[16:19:32.957]                 }
[16:19:32.957]                 {
[16:19:32.957]                   {
[16:19:32.957]                     NULL
[16:19:32.957]                     RNGkind("Mersenne-Twister")
[16:19:32.957]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:32.957]                       inherits = FALSE)
[16:19:32.957]                   }
[16:19:32.957]                   options(future.plan = NULL)
[16:19:32.957]                   if (is.na(NA_character_)) 
[16:19:32.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:32.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:32.957]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:32.957]                     .init = FALSE)
[16:19:32.957]                 }
[16:19:32.957]             }
[16:19:32.957]         }
[16:19:32.957]     })
[16:19:32.957]     if (FALSE) {
[16:19:32.957]         base::sink(type = "output", split = FALSE)
[16:19:32.957]         if (NA) {
[16:19:32.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:32.957]         }
[16:19:32.957]         else {
[16:19:32.957]             ...future.result["stdout"] <- base::list(NULL)
[16:19:32.957]         }
[16:19:32.957]         base::close(...future.stdout)
[16:19:32.957]         ...future.stdout <- NULL
[16:19:32.957]     }
[16:19:32.957]     ...future.result$conditions <- ...future.conditions
[16:19:32.957]     ...future.result$finished <- base::Sys.time()
[16:19:32.957]     ...future.result
[16:19:32.957] }
[16:19:32.958] assign_globals() ...
[16:19:32.958] List of 5
[16:19:32.958]  $ ...future.FUN            :function (x, y)  
[16:19:32.958]  $ MoreArgs                 : NULL
[16:19:32.958]  $ ...future.elements_ii    :List of 2
[16:19:32.958]   ..$ :List of 2
[16:19:32.958]   .. ..$ : int 1
[16:19:32.958]   .. ..$ : int 0
[16:19:32.958]   ..$ :List of 2
[16:19:32.958]   .. ..$ : int 0
[16:19:32.958]   .. ..$ : int 1
[16:19:32.958]  $ ...future.seeds_ii       : NULL
[16:19:32.958]  $ ...future.globals.maxSize: NULL
[16:19:32.958]  - attr(*, "where")=List of 5
[16:19:32.958]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:32.958]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:32.958]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:32.958]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:32.958]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:32.958]  - attr(*, "resolved")= logi FALSE
[16:19:32.958]  - attr(*, "total_size")= num 6480
[16:19:32.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:32.958]  - attr(*, "already-done")= logi TRUE
[16:19:32.964] - reassign environment for ‘...future.FUN’
[16:19:32.964] - copied ‘...future.FUN’ to environment
[16:19:32.964] - copied ‘MoreArgs’ to environment
[16:19:32.964] - copied ‘...future.elements_ii’ to environment
[16:19:32.964] - copied ‘...future.seeds_ii’ to environment
[16:19:32.964] - copied ‘...future.globals.maxSize’ to environment
[16:19:32.964] assign_globals() ... done
[16:19:32.965] plan(): Setting new future strategy stack:
[16:19:32.965] List of future strategies:
[16:19:32.965] 1. sequential:
[16:19:32.965]    - args: function (..., envir = parent.frame())
[16:19:32.965]    - tweaked: FALSE
[16:19:32.965]    - call: NULL
[16:19:32.965] plan(): nbrOfWorkers() = 1
[16:19:33.467] plan(): Setting new future strategy stack:
[16:19:33.467] List of future strategies:
[16:19:33.467] 1. multicore:
[16:19:33.467]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:33.467]    - tweaked: FALSE
[16:19:33.467]    - call: plan(strategy)
[16:19:33.471] plan(): nbrOfWorkers() = 1
[16:19:33.471] SequentialFuture started (and completed)
[16:19:33.471] - Launch lazy future ... done
[16:19:33.471] run() for ‘SequentialFuture’ ... done
[16:19:33.471] Created future:
[16:19:33.472] SequentialFuture:
[16:19:33.472] Label: ‘future_mapply-1’
[16:19:33.472] Expression:
[16:19:33.472] {
[16:19:33.472]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:33.472]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:33.472]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:33.472]         on.exit(options(oopts), add = TRUE)
[16:19:33.472]     }
[16:19:33.472]     {
[16:19:33.472]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:33.472]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:33.472]         do.call(mapply, args = args)
[16:19:33.472]     }
[16:19:33.472] }
[16:19:33.472] Lazy evaluation: FALSE
[16:19:33.472] Asynchronous evaluation: FALSE
[16:19:33.472] Local evaluation: TRUE
[16:19:33.472] Environment: R_GlobalEnv
[16:19:33.472] Capture standard output: NA
[16:19:33.472] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:33.472] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:33.472] Packages: <none>
[16:19:33.472] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:33.472] Resolved: TRUE
[16:19:33.472] Value: 224 bytes of class ‘list’
[16:19:33.472] Early signaling: FALSE
[16:19:33.472] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:33.472] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:33.473] Chunk #1 of 1 ... DONE
[16:19:33.473] Launching 1 futures (chunks) ... DONE
[16:19:33.473] Resolving 1 futures (chunks) ...
[16:19:33.473] resolve() on list ...
[16:19:33.473]  recursive: 0
[16:19:33.473]  length: 1
[16:19:33.473] 
[16:19:33.473] resolved() for ‘SequentialFuture’ ...
[16:19:33.473] - state: ‘finished’
[16:19:33.474] - run: TRUE
[16:19:33.474] - result: ‘FutureResult’
[16:19:33.474] resolved() for ‘SequentialFuture’ ... done
[16:19:33.474] Future #1
[16:19:33.474] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:33.474] - nx: 1
[16:19:33.474] - relay: TRUE
[16:19:33.474] - stdout: TRUE
[16:19:33.474] - signal: TRUE
[16:19:33.474] - resignal: FALSE
[16:19:33.474] - force: TRUE
[16:19:33.475] - relayed: [n=1] FALSE
[16:19:33.475] - queued futures: [n=1] FALSE
[16:19:33.475]  - until=1
[16:19:33.475]  - relaying element #1
[16:19:33.475] - relayed: [n=1] TRUE
[16:19:33.475] - queued futures: [n=1] TRUE
[16:19:33.475] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:33.475]  length: 0 (resolved future 1)
[16:19:33.475] Relaying remaining futures
[16:19:33.475] signalConditionsASAP(NULL, pos=0) ...
[16:19:33.476] - nx: 1
[16:19:33.476] - relay: TRUE
[16:19:33.476] - stdout: TRUE
[16:19:33.476] - signal: TRUE
[16:19:33.476] - resignal: FALSE
[16:19:33.476] - force: TRUE
[16:19:33.476] - relayed: [n=1] TRUE
[16:19:33.476] - queued futures: [n=1] TRUE
 - flush all
[16:19:33.476] - relayed: [n=1] TRUE
[16:19:33.476] - queued futures: [n=1] TRUE
[16:19:33.476] signalConditionsASAP(NULL, pos=0) ... done
[16:19:33.477] resolve() on list ... DONE
[16:19:33.477]  - Number of value chunks collected: 1
[16:19:33.477] Resolving 1 futures (chunks) ... DONE
[16:19:33.477] Reducing values from 1 chunks ...
[16:19:33.477]  - Number of values collected after concatenation: 2
[16:19:33.477]  - Number of values expected: 2
[16:19:33.477] Reducing values from 1 chunks ... DONE
[16:19:33.504] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[16:19:33.504] plan(): Setting new future strategy stack:
[16:19:33.504] List of future strategies:
[16:19:33.504] 1. multisession:
[16:19:33.504]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:33.504]    - tweaked: FALSE
[16:19:33.504]    - call: plan(strategy)
[16:19:33.505] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:19:33.505] multisession:
[16:19:33.505] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:33.505] - tweaked: FALSE
[16:19:33.505] - call: plan(strategy)
[16:19:33.509] getGlobalsAndPackages() ...
[16:19:33.509] Not searching for globals
[16:19:33.509] - globals: [0] <none>
[16:19:33.510] getGlobalsAndPackages() ... DONE
[16:19:33.510] Packages needed by the future expression (n = 0): <none>
[16:19:33.510] Packages needed by future strategies (n = 0): <none>
[16:19:33.511] {
[16:19:33.511]     {
[16:19:33.511]         {
[16:19:33.511]             ...future.startTime <- base::Sys.time()
[16:19:33.511]             {
[16:19:33.511]                 {
[16:19:33.511]                   {
[16:19:33.511]                     base::local({
[16:19:33.511]                       has_future <- base::requireNamespace("future", 
[16:19:33.511]                         quietly = TRUE)
[16:19:33.511]                       if (has_future) {
[16:19:33.511]                         ns <- base::getNamespace("future")
[16:19:33.511]                         version <- ns[[".package"]][["version"]]
[16:19:33.511]                         if (is.null(version)) 
[16:19:33.511]                           version <- utils::packageVersion("future")
[16:19:33.511]                       }
[16:19:33.511]                       else {
[16:19:33.511]                         version <- NULL
[16:19:33.511]                       }
[16:19:33.511]                       if (!has_future || version < "1.8.0") {
[16:19:33.511]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:33.511]                           "", base::R.version$version.string), 
[16:19:33.511]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:33.511]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:33.511]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:33.511]                             "release", "version")], collapse = " "), 
[16:19:33.511]                           hostname = base::Sys.info()[["nodename"]])
[16:19:33.511]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:33.511]                           info)
[16:19:33.511]                         info <- base::paste(info, collapse = "; ")
[16:19:33.511]                         if (!has_future) {
[16:19:33.511]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:33.511]                             info)
[16:19:33.511]                         }
[16:19:33.511]                         else {
[16:19:33.511]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:33.511]                             info, version)
[16:19:33.511]                         }
[16:19:33.511]                         base::stop(msg)
[16:19:33.511]                       }
[16:19:33.511]                     })
[16:19:33.511]                   }
[16:19:33.511]                   ...future.strategy.old <- future::plan("list")
[16:19:33.511]                   options(future.plan = NULL)
[16:19:33.511]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:33.511]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:33.511]                 }
[16:19:33.511]                 ...future.workdir <- getwd()
[16:19:33.511]             }
[16:19:33.511]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:33.511]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:33.511]         }
[16:19:33.511]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:33.511]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:33.511]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:33.511]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:33.511]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:33.511]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:33.511]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:33.511]             base::names(...future.oldOptions))
[16:19:33.511]     }
[16:19:33.511]     if (FALSE) {
[16:19:33.511]     }
[16:19:33.511]     else {
[16:19:33.511]         if (TRUE) {
[16:19:33.511]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:33.511]                 open = "w")
[16:19:33.511]         }
[16:19:33.511]         else {
[16:19:33.511]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:33.511]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:33.511]         }
[16:19:33.511]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:33.511]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:33.511]             base::sink(type = "output", split = FALSE)
[16:19:33.511]             base::close(...future.stdout)
[16:19:33.511]         }, add = TRUE)
[16:19:33.511]     }
[16:19:33.511]     ...future.frame <- base::sys.nframe()
[16:19:33.511]     ...future.conditions <- base::list()
[16:19:33.511]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:33.511]     if (FALSE) {
[16:19:33.511]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:33.511]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:33.511]     }
[16:19:33.511]     ...future.result <- base::tryCatch({
[16:19:33.511]         base::withCallingHandlers({
[16:19:33.511]             ...future.value <- base::withVisible(base::local(NA))
[16:19:33.511]             future::FutureResult(value = ...future.value$value, 
[16:19:33.511]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:33.511]                   ...future.rng), globalenv = if (FALSE) 
[16:19:33.511]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:33.511]                     ...future.globalenv.names))
[16:19:33.511]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:33.511]         }, condition = base::local({
[16:19:33.511]             c <- base::c
[16:19:33.511]             inherits <- base::inherits
[16:19:33.511]             invokeRestart <- base::invokeRestart
[16:19:33.511]             length <- base::length
[16:19:33.511]             list <- base::list
[16:19:33.511]             seq.int <- base::seq.int
[16:19:33.511]             signalCondition <- base::signalCondition
[16:19:33.511]             sys.calls <- base::sys.calls
[16:19:33.511]             `[[` <- base::`[[`
[16:19:33.511]             `+` <- base::`+`
[16:19:33.511]             `<<-` <- base::`<<-`
[16:19:33.511]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:33.511]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:33.511]                   3L)]
[16:19:33.511]             }
[16:19:33.511]             function(cond) {
[16:19:33.511]                 is_error <- inherits(cond, "error")
[16:19:33.511]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:33.511]                   NULL)
[16:19:33.511]                 if (is_error) {
[16:19:33.511]                   sessionInformation <- function() {
[16:19:33.511]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:33.511]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:33.511]                       search = base::search(), system = base::Sys.info())
[16:19:33.511]                   }
[16:19:33.511]                   ...future.conditions[[length(...future.conditions) + 
[16:19:33.511]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:33.511]                     cond$call), session = sessionInformation(), 
[16:19:33.511]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:33.511]                   signalCondition(cond)
[16:19:33.511]                 }
[16:19:33.511]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:33.511]                 "immediateCondition"))) {
[16:19:33.511]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:33.511]                   ...future.conditions[[length(...future.conditions) + 
[16:19:33.511]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:33.511]                   if (TRUE && !signal) {
[16:19:33.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:33.511]                     {
[16:19:33.511]                       inherits <- base::inherits
[16:19:33.511]                       invokeRestart <- base::invokeRestart
[16:19:33.511]                       is.null <- base::is.null
[16:19:33.511]                       muffled <- FALSE
[16:19:33.511]                       if (inherits(cond, "message")) {
[16:19:33.511]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:33.511]                         if (muffled) 
[16:19:33.511]                           invokeRestart("muffleMessage")
[16:19:33.511]                       }
[16:19:33.511]                       else if (inherits(cond, "warning")) {
[16:19:33.511]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:33.511]                         if (muffled) 
[16:19:33.511]                           invokeRestart("muffleWarning")
[16:19:33.511]                       }
[16:19:33.511]                       else if (inherits(cond, "condition")) {
[16:19:33.511]                         if (!is.null(pattern)) {
[16:19:33.511]                           computeRestarts <- base::computeRestarts
[16:19:33.511]                           grepl <- base::grepl
[16:19:33.511]                           restarts <- computeRestarts(cond)
[16:19:33.511]                           for (restart in restarts) {
[16:19:33.511]                             name <- restart$name
[16:19:33.511]                             if (is.null(name)) 
[16:19:33.511]                               next
[16:19:33.511]                             if (!grepl(pattern, name)) 
[16:19:33.511]                               next
[16:19:33.511]                             invokeRestart(restart)
[16:19:33.511]                             muffled <- TRUE
[16:19:33.511]                             break
[16:19:33.511]                           }
[16:19:33.511]                         }
[16:19:33.511]                       }
[16:19:33.511]                       invisible(muffled)
[16:19:33.511]                     }
[16:19:33.511]                     muffleCondition(cond, pattern = "^muffle")
[16:19:33.511]                   }
[16:19:33.511]                 }
[16:19:33.511]                 else {
[16:19:33.511]                   if (TRUE) {
[16:19:33.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:33.511]                     {
[16:19:33.511]                       inherits <- base::inherits
[16:19:33.511]                       invokeRestart <- base::invokeRestart
[16:19:33.511]                       is.null <- base::is.null
[16:19:33.511]                       muffled <- FALSE
[16:19:33.511]                       if (inherits(cond, "message")) {
[16:19:33.511]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:33.511]                         if (muffled) 
[16:19:33.511]                           invokeRestart("muffleMessage")
[16:19:33.511]                       }
[16:19:33.511]                       else if (inherits(cond, "warning")) {
[16:19:33.511]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:33.511]                         if (muffled) 
[16:19:33.511]                           invokeRestart("muffleWarning")
[16:19:33.511]                       }
[16:19:33.511]                       else if (inherits(cond, "condition")) {
[16:19:33.511]                         if (!is.null(pattern)) {
[16:19:33.511]                           computeRestarts <- base::computeRestarts
[16:19:33.511]                           grepl <- base::grepl
[16:19:33.511]                           restarts <- computeRestarts(cond)
[16:19:33.511]                           for (restart in restarts) {
[16:19:33.511]                             name <- restart$name
[16:19:33.511]                             if (is.null(name)) 
[16:19:33.511]                               next
[16:19:33.511]                             if (!grepl(pattern, name)) 
[16:19:33.511]                               next
[16:19:33.511]                             invokeRestart(restart)
[16:19:33.511]                             muffled <- TRUE
[16:19:33.511]                             break
[16:19:33.511]                           }
[16:19:33.511]                         }
[16:19:33.511]                       }
[16:19:33.511]                       invisible(muffled)
[16:19:33.511]                     }
[16:19:33.511]                     muffleCondition(cond, pattern = "^muffle")
[16:19:33.511]                   }
[16:19:33.511]                 }
[16:19:33.511]             }
[16:19:33.511]         }))
[16:19:33.511]     }, error = function(ex) {
[16:19:33.511]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:33.511]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:33.511]                 ...future.rng), started = ...future.startTime, 
[16:19:33.511]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:33.511]             version = "1.8"), class = "FutureResult")
[16:19:33.511]     }, finally = {
[16:19:33.511]         if (!identical(...future.workdir, getwd())) 
[16:19:33.511]             setwd(...future.workdir)
[16:19:33.511]         {
[16:19:33.511]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:33.511]                 ...future.oldOptions$nwarnings <- NULL
[16:19:33.511]             }
[16:19:33.511]             base::options(...future.oldOptions)
[16:19:33.511]             if (.Platform$OS.type == "windows") {
[16:19:33.511]                 old_names <- names(...future.oldEnvVars)
[16:19:33.511]                 envs <- base::Sys.getenv()
[16:19:33.511]                 names <- names(envs)
[16:19:33.511]                 common <- intersect(names, old_names)
[16:19:33.511]                 added <- setdiff(names, old_names)
[16:19:33.511]                 removed <- setdiff(old_names, names)
[16:19:33.511]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:33.511]                   envs[common]]
[16:19:33.511]                 NAMES <- toupper(changed)
[16:19:33.511]                 args <- list()
[16:19:33.511]                 for (kk in seq_along(NAMES)) {
[16:19:33.511]                   name <- changed[[kk]]
[16:19:33.511]                   NAME <- NAMES[[kk]]
[16:19:33.511]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:33.511]                     next
[16:19:33.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:33.511]                 }
[16:19:33.511]                 NAMES <- toupper(added)
[16:19:33.511]                 for (kk in seq_along(NAMES)) {
[16:19:33.511]                   name <- added[[kk]]
[16:19:33.511]                   NAME <- NAMES[[kk]]
[16:19:33.511]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:33.511]                     next
[16:19:33.511]                   args[[name]] <- ""
[16:19:33.511]                 }
[16:19:33.511]                 NAMES <- toupper(removed)
[16:19:33.511]                 for (kk in seq_along(NAMES)) {
[16:19:33.511]                   name <- removed[[kk]]
[16:19:33.511]                   NAME <- NAMES[[kk]]
[16:19:33.511]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:33.511]                     next
[16:19:33.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:33.511]                 }
[16:19:33.511]                 if (length(args) > 0) 
[16:19:33.511]                   base::do.call(base::Sys.setenv, args = args)
[16:19:33.511]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:33.511]             }
[16:19:33.511]             else {
[16:19:33.511]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:33.511]             }
[16:19:33.511]             {
[16:19:33.511]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:33.511]                   0L) {
[16:19:33.511]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:33.511]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:33.511]                   base::options(opts)
[16:19:33.511]                 }
[16:19:33.511]                 {
[16:19:33.511]                   {
[16:19:33.511]                     NULL
[16:19:33.511]                     RNGkind("Mersenne-Twister")
[16:19:33.511]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:33.511]                       inherits = FALSE)
[16:19:33.511]                   }
[16:19:33.511]                   options(future.plan = NULL)
[16:19:33.511]                   if (is.na(NA_character_)) 
[16:19:33.511]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:33.511]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:33.511]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:33.511]                     .init = FALSE)
[16:19:33.511]                 }
[16:19:33.511]             }
[16:19:33.511]         }
[16:19:33.511]     })
[16:19:33.511]     if (TRUE) {
[16:19:33.511]         base::sink(type = "output", split = FALSE)
[16:19:33.511]         if (TRUE) {
[16:19:33.511]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:33.511]         }
[16:19:33.511]         else {
[16:19:33.511]             ...future.result["stdout"] <- base::list(NULL)
[16:19:33.511]         }
[16:19:33.511]         base::close(...future.stdout)
[16:19:33.511]         ...future.stdout <- NULL
[16:19:33.511]     }
[16:19:33.511]     ...future.result$conditions <- ...future.conditions
[16:19:33.511]     ...future.result$finished <- base::Sys.time()
[16:19:33.511]     ...future.result
[16:19:33.511] }
[16:19:33.512] plan(): Setting new future strategy stack:
[16:19:33.512] List of future strategies:
[16:19:33.512] 1. sequential:
[16:19:33.512]    - args: function (..., envir = parent.frame())
[16:19:33.512]    - tweaked: FALSE
[16:19:33.512]    - call: NULL
[16:19:33.513] plan(): nbrOfWorkers() = 1
[16:19:33.514] plan(): Setting new future strategy stack:
[16:19:33.514] List of future strategies:
[16:19:33.514] 1. multisession:
[16:19:33.514]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:33.514]    - tweaked: FALSE
[16:19:33.514]    - call: plan(strategy)
[16:19:33.517] plan(): nbrOfWorkers() = 1
[16:19:33.517] SequentialFuture started (and completed)
[16:19:33.517] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:19:33.521] plan(): nbrOfWorkers() = 1
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:19:33.521] future_lapply() ...
[16:19:33.524] Number of chunks: 1
[16:19:33.525] getGlobalsAndPackagesXApply() ...
[16:19:33.525]  - future.globals: TRUE
[16:19:33.525] getGlobalsAndPackages() ...
[16:19:33.525] Searching for globals...
[16:19:33.526] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:33.526] Searching for globals ... DONE
[16:19:33.526] Resolving globals: FALSE
[16:19:33.527] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:33.527] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:33.527] - globals: [1] ‘FUN’
[16:19:33.527] 
[16:19:33.527] getGlobalsAndPackages() ... DONE
[16:19:33.528]  - globals found/used: [n=1] ‘FUN’
[16:19:33.528]  - needed namespaces: [n=0] 
[16:19:33.528] Finding globals ... DONE
[16:19:33.528]  - use_args: TRUE
[16:19:33.528]  - Getting '...' globals ...
[16:19:33.528] resolve() on list ...
[16:19:33.528]  recursive: 0
[16:19:33.528]  length: 1
[16:19:33.529]  elements: ‘...’
[16:19:33.529]  length: 0 (resolved future 1)
[16:19:33.529] resolve() on list ... DONE
[16:19:33.529]    - '...' content: [n=0] 
[16:19:33.529] List of 1
[16:19:33.529]  $ ...: list()
[16:19:33.529]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:33.529]  - attr(*, "where")=List of 1
[16:19:33.529]   ..$ ...:<environment: 0x563560934a10> 
[16:19:33.529]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:33.529]  - attr(*, "resolved")= logi TRUE
[16:19:33.529]  - attr(*, "total_size")= num NA
[16:19:33.531]  - Getting '...' globals ... DONE
[16:19:33.532] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:33.532] List of 2
[16:19:33.532]  $ ...future.FUN:function (x)  
[16:19:33.532]  $ ...          : list()
[16:19:33.532]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:33.532]  - attr(*, "where")=List of 2
[16:19:33.532]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:33.532]   ..$ ...          :<environment: 0x563560934a10> 
[16:19:33.532]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:33.532]  - attr(*, "resolved")= logi FALSE
[16:19:33.532]  - attr(*, "total_size")= num 4720
[16:19:33.534] Packages to be attached in all futures: [n=0] 
[16:19:33.534] getGlobalsAndPackagesXApply() ... DONE
[16:19:33.535] Number of futures (= number of chunks): 1
[16:19:33.535] Launching 1 futures (chunks) ...
[16:19:33.535] Chunk #1 of 1 ...
[16:19:33.535]  - Finding globals in 'X' for chunk #1 ...
[16:19:33.535] getGlobalsAndPackages() ...
[16:19:33.535] Searching for globals...
[16:19:33.535] 
[16:19:33.536] Searching for globals ... DONE
[16:19:33.536] - globals: [0] <none>
[16:19:33.536] getGlobalsAndPackages() ... DONE
[16:19:33.536]    + additional globals found: [n=0] 
[16:19:33.536]    + additional namespaces needed: [n=0] 
[16:19:33.536]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:33.536]  - seeds: <none>
[16:19:33.536]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:33.536] getGlobalsAndPackages() ...
[16:19:33.536] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:33.536] Resolving globals: FALSE
[16:19:33.537] Tweak future expression to call with '...' arguments ...
[16:19:33.537] {
[16:19:33.537]     do.call(function(...) {
[16:19:33.537]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:33.537]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:33.537]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:33.537]             on.exit(options(oopts), add = TRUE)
[16:19:33.537]         }
[16:19:33.537]         {
[16:19:33.537]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:33.537]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:33.537]                 ...future.FUN(...future.X_jj, ...)
[16:19:33.537]             })
[16:19:33.537]         }
[16:19:33.537]     }, args = future.call.arguments)
[16:19:33.537] }
[16:19:33.537] Tweak future expression to call with '...' arguments ... DONE
[16:19:33.537] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:33.537] 
[16:19:33.537] getGlobalsAndPackages() ... DONE
[16:19:33.538] run() for ‘Future’ ...
[16:19:33.538] - state: ‘created’
[16:19:33.538] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:33.541] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:33.541] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:33.543]   - Field: ‘label’
[16:19:33.543]   - Field: ‘local’
[16:19:33.543]   - Field: ‘owner’
[16:19:33.543]   - Field: ‘envir’
[16:19:33.543]   - Field: ‘packages’
[16:19:33.543]   - Field: ‘gc’
[16:19:33.543]   - Field: ‘conditions’
[16:19:33.543]   - Field: ‘expr’
[16:19:33.543]   - Field: ‘uuid’
[16:19:33.543]   - Field: ‘seed’
[16:19:33.544]   - Field: ‘version’
[16:19:33.544]   - Field: ‘result’
[16:19:33.544]   - Field: ‘asynchronous’
[16:19:33.544]   - Field: ‘calls’
[16:19:33.544]   - Field: ‘globals’
[16:19:33.544]   - Field: ‘stdout’
[16:19:33.544]   - Field: ‘earlySignal’
[16:19:33.544]   - Field: ‘lazy’
[16:19:33.544]   - Field: ‘state’
[16:19:33.544] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:33.545] - Launch lazy future ...
[16:19:33.545] Packages needed by the future expression (n = 0): <none>
[16:19:33.545] Packages needed by future strategies (n = 0): <none>
[16:19:33.545] {
[16:19:33.545]     {
[16:19:33.545]         {
[16:19:33.545]             ...future.startTime <- base::Sys.time()
[16:19:33.545]             {
[16:19:33.545]                 {
[16:19:33.545]                   {
[16:19:33.545]                     base::local({
[16:19:33.545]                       has_future <- base::requireNamespace("future", 
[16:19:33.545]                         quietly = TRUE)
[16:19:33.545]                       if (has_future) {
[16:19:33.545]                         ns <- base::getNamespace("future")
[16:19:33.545]                         version <- ns[[".package"]][["version"]]
[16:19:33.545]                         if (is.null(version)) 
[16:19:33.545]                           version <- utils::packageVersion("future")
[16:19:33.545]                       }
[16:19:33.545]                       else {
[16:19:33.545]                         version <- NULL
[16:19:33.545]                       }
[16:19:33.545]                       if (!has_future || version < "1.8.0") {
[16:19:33.545]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:33.545]                           "", base::R.version$version.string), 
[16:19:33.545]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:33.545]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:33.545]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:33.545]                             "release", "version")], collapse = " "), 
[16:19:33.545]                           hostname = base::Sys.info()[["nodename"]])
[16:19:33.545]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:33.545]                           info)
[16:19:33.545]                         info <- base::paste(info, collapse = "; ")
[16:19:33.545]                         if (!has_future) {
[16:19:33.545]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:33.545]                             info)
[16:19:33.545]                         }
[16:19:33.545]                         else {
[16:19:33.545]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:33.545]                             info, version)
[16:19:33.545]                         }
[16:19:33.545]                         base::stop(msg)
[16:19:33.545]                       }
[16:19:33.545]                     })
[16:19:33.545]                   }
[16:19:33.545]                   ...future.strategy.old <- future::plan("list")
[16:19:33.545]                   options(future.plan = NULL)
[16:19:33.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:33.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:33.545]                 }
[16:19:33.545]                 ...future.workdir <- getwd()
[16:19:33.545]             }
[16:19:33.545]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:33.545]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:33.545]         }
[16:19:33.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:33.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:33.545]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:33.545]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:33.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:33.545]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:33.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:33.545]             base::names(...future.oldOptions))
[16:19:33.545]     }
[16:19:33.545]     if (FALSE) {
[16:19:33.545]     }
[16:19:33.545]     else {
[16:19:33.545]         if (FALSE) {
[16:19:33.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:33.545]                 open = "w")
[16:19:33.545]         }
[16:19:33.545]         else {
[16:19:33.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:33.545]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:33.545]         }
[16:19:33.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:33.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:33.545]             base::sink(type = "output", split = FALSE)
[16:19:33.545]             base::close(...future.stdout)
[16:19:33.545]         }, add = TRUE)
[16:19:33.545]     }
[16:19:33.545]     ...future.frame <- base::sys.nframe()
[16:19:33.545]     ...future.conditions <- base::list()
[16:19:33.545]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:33.545]     if (FALSE) {
[16:19:33.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:33.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:33.545]     }
[16:19:33.545]     ...future.result <- base::tryCatch({
[16:19:33.545]         base::withCallingHandlers({
[16:19:33.545]             ...future.value <- base::withVisible(base::local({
[16:19:33.545]                 do.call(function(...) {
[16:19:33.545]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:33.545]                   if (!identical(...future.globals.maxSize.org, 
[16:19:33.545]                     ...future.globals.maxSize)) {
[16:19:33.545]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:33.545]                     on.exit(options(oopts), add = TRUE)
[16:19:33.545]                   }
[16:19:33.545]                   {
[16:19:33.545]                     lapply(seq_along(...future.elements_ii), 
[16:19:33.545]                       FUN = function(jj) {
[16:19:33.545]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:33.545]                         ...future.FUN(...future.X_jj, ...)
[16:19:33.545]                       })
[16:19:33.545]                   }
[16:19:33.545]                 }, args = future.call.arguments)
[16:19:33.545]             }))
[16:19:33.545]             future::FutureResult(value = ...future.value$value, 
[16:19:33.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:33.545]                   ...future.rng), globalenv = if (FALSE) 
[16:19:33.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:33.545]                     ...future.globalenv.names))
[16:19:33.545]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:33.545]         }, condition = base::local({
[16:19:33.545]             c <- base::c
[16:19:33.545]             inherits <- base::inherits
[16:19:33.545]             invokeRestart <- base::invokeRestart
[16:19:33.545]             length <- base::length
[16:19:33.545]             list <- base::list
[16:19:33.545]             seq.int <- base::seq.int
[16:19:33.545]             signalCondition <- base::signalCondition
[16:19:33.545]             sys.calls <- base::sys.calls
[16:19:33.545]             `[[` <- base::`[[`
[16:19:33.545]             `+` <- base::`+`
[16:19:33.545]             `<<-` <- base::`<<-`
[16:19:33.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:33.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:33.545]                   3L)]
[16:19:33.545]             }
[16:19:33.545]             function(cond) {
[16:19:33.545]                 is_error <- inherits(cond, "error")
[16:19:33.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:33.545]                   NULL)
[16:19:33.545]                 if (is_error) {
[16:19:33.545]                   sessionInformation <- function() {
[16:19:33.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:33.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:33.545]                       search = base::search(), system = base::Sys.info())
[16:19:33.545]                   }
[16:19:33.545]                   ...future.conditions[[length(...future.conditions) + 
[16:19:33.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:33.545]                     cond$call), session = sessionInformation(), 
[16:19:33.545]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:33.545]                   signalCondition(cond)
[16:19:33.545]                 }
[16:19:33.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:33.545]                 "immediateCondition"))) {
[16:19:33.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:33.545]                   ...future.conditions[[length(...future.conditions) + 
[16:19:33.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:33.545]                   if (TRUE && !signal) {
[16:19:33.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:33.545]                     {
[16:19:33.545]                       inherits <- base::inherits
[16:19:33.545]                       invokeRestart <- base::invokeRestart
[16:19:33.545]                       is.null <- base::is.null
[16:19:33.545]                       muffled <- FALSE
[16:19:33.545]                       if (inherits(cond, "message")) {
[16:19:33.545]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:33.545]                         if (muffled) 
[16:19:33.545]                           invokeRestart("muffleMessage")
[16:19:33.545]                       }
[16:19:33.545]                       else if (inherits(cond, "warning")) {
[16:19:33.545]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:33.545]                         if (muffled) 
[16:19:33.545]                           invokeRestart("muffleWarning")
[16:19:33.545]                       }
[16:19:33.545]                       else if (inherits(cond, "condition")) {
[16:19:33.545]                         if (!is.null(pattern)) {
[16:19:33.545]                           computeRestarts <- base::computeRestarts
[16:19:33.545]                           grepl <- base::grepl
[16:19:33.545]                           restarts <- computeRestarts(cond)
[16:19:33.545]                           for (restart in restarts) {
[16:19:33.545]                             name <- restart$name
[16:19:33.545]                             if (is.null(name)) 
[16:19:33.545]                               next
[16:19:33.545]                             if (!grepl(pattern, name)) 
[16:19:33.545]                               next
[16:19:33.545]                             invokeRestart(restart)
[16:19:33.545]                             muffled <- TRUE
[16:19:33.545]                             break
[16:19:33.545]                           }
[16:19:33.545]                         }
[16:19:33.545]                       }
[16:19:33.545]                       invisible(muffled)
[16:19:33.545]                     }
[16:19:33.545]                     muffleCondition(cond, pattern = "^muffle")
[16:19:33.545]                   }
[16:19:33.545]                 }
[16:19:33.545]                 else {
[16:19:33.545]                   if (TRUE) {
[16:19:33.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:33.545]                     {
[16:19:33.545]                       inherits <- base::inherits
[16:19:33.545]                       invokeRestart <- base::invokeRestart
[16:19:33.545]                       is.null <- base::is.null
[16:19:33.545]                       muffled <- FALSE
[16:19:33.545]                       if (inherits(cond, "message")) {
[16:19:33.545]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:33.545]                         if (muffled) 
[16:19:33.545]                           invokeRestart("muffleMessage")
[16:19:33.545]                       }
[16:19:33.545]                       else if (inherits(cond, "warning")) {
[16:19:33.545]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:33.545]                         if (muffled) 
[16:19:33.545]                           invokeRestart("muffleWarning")
[16:19:33.545]                       }
[16:19:33.545]                       else if (inherits(cond, "condition")) {
[16:19:33.545]                         if (!is.null(pattern)) {
[16:19:33.545]                           computeRestarts <- base::computeRestarts
[16:19:33.545]                           grepl <- base::grepl
[16:19:33.545]                           restarts <- computeRestarts(cond)
[16:19:33.545]                           for (restart in restarts) {
[16:19:33.545]                             name <- restart$name
[16:19:33.545]                             if (is.null(name)) 
[16:19:33.545]                               next
[16:19:33.545]                             if (!grepl(pattern, name)) 
[16:19:33.545]                               next
[16:19:33.545]                             invokeRestart(restart)
[16:19:33.545]                             muffled <- TRUE
[16:19:33.545]                             break
[16:19:33.545]                           }
[16:19:33.545]                         }
[16:19:33.545]                       }
[16:19:33.545]                       invisible(muffled)
[16:19:33.545]                     }
[16:19:33.545]                     muffleCondition(cond, pattern = "^muffle")
[16:19:33.545]                   }
[16:19:33.545]                 }
[16:19:33.545]             }
[16:19:33.545]         }))
[16:19:33.545]     }, error = function(ex) {
[16:19:33.545]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:33.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:33.545]                 ...future.rng), started = ...future.startTime, 
[16:19:33.545]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:33.545]             version = "1.8"), class = "FutureResult")
[16:19:33.545]     }, finally = {
[16:19:33.545]         if (!identical(...future.workdir, getwd())) 
[16:19:33.545]             setwd(...future.workdir)
[16:19:33.545]         {
[16:19:33.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:33.545]                 ...future.oldOptions$nwarnings <- NULL
[16:19:33.545]             }
[16:19:33.545]             base::options(...future.oldOptions)
[16:19:33.545]             if (.Platform$OS.type == "windows") {
[16:19:33.545]                 old_names <- names(...future.oldEnvVars)
[16:19:33.545]                 envs <- base::Sys.getenv()
[16:19:33.545]                 names <- names(envs)
[16:19:33.545]                 common <- intersect(names, old_names)
[16:19:33.545]                 added <- setdiff(names, old_names)
[16:19:33.545]                 removed <- setdiff(old_names, names)
[16:19:33.545]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:33.545]                   envs[common]]
[16:19:33.545]                 NAMES <- toupper(changed)
[16:19:33.545]                 args <- list()
[16:19:33.545]                 for (kk in seq_along(NAMES)) {
[16:19:33.545]                   name <- changed[[kk]]
[16:19:33.545]                   NAME <- NAMES[[kk]]
[16:19:33.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:33.545]                     next
[16:19:33.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:33.545]                 }
[16:19:33.545]                 NAMES <- toupper(added)
[16:19:33.545]                 for (kk in seq_along(NAMES)) {
[16:19:33.545]                   name <- added[[kk]]
[16:19:33.545]                   NAME <- NAMES[[kk]]
[16:19:33.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:33.545]                     next
[16:19:33.545]                   args[[name]] <- ""
[16:19:33.545]                 }
[16:19:33.545]                 NAMES <- toupper(removed)
[16:19:33.545]                 for (kk in seq_along(NAMES)) {
[16:19:33.545]                   name <- removed[[kk]]
[16:19:33.545]                   NAME <- NAMES[[kk]]
[16:19:33.545]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:33.545]                     next
[16:19:33.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:33.545]                 }
[16:19:33.545]                 if (length(args) > 0) 
[16:19:33.545]                   base::do.call(base::Sys.setenv, args = args)
[16:19:33.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:33.545]             }
[16:19:33.545]             else {
[16:19:33.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:33.545]             }
[16:19:33.545]             {
[16:19:33.545]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:33.545]                   0L) {
[16:19:33.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:33.545]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:33.545]                   base::options(opts)
[16:19:33.545]                 }
[16:19:33.545]                 {
[16:19:33.545]                   {
[16:19:33.545]                     NULL
[16:19:33.545]                     RNGkind("Mersenne-Twister")
[16:19:33.545]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:33.545]                       inherits = FALSE)
[16:19:33.545]                   }
[16:19:33.545]                   options(future.plan = NULL)
[16:19:33.545]                   if (is.na(NA_character_)) 
[16:19:33.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:33.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:33.545]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:33.545]                     .init = FALSE)
[16:19:33.545]                 }
[16:19:33.545]             }
[16:19:33.545]         }
[16:19:33.545]     })
[16:19:33.545]     if (TRUE) {
[16:19:33.545]         base::sink(type = "output", split = FALSE)
[16:19:33.545]         if (FALSE) {
[16:19:33.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:33.545]         }
[16:19:33.545]         else {
[16:19:33.545]             ...future.result["stdout"] <- base::list(NULL)
[16:19:33.545]         }
[16:19:33.545]         base::close(...future.stdout)
[16:19:33.545]         ...future.stdout <- NULL
[16:19:33.545]     }
[16:19:33.545]     ...future.result$conditions <- ...future.conditions
[16:19:33.545]     ...future.result$finished <- base::Sys.time()
[16:19:33.545]     ...future.result
[16:19:33.545] }
[16:19:33.547] assign_globals() ...
[16:19:33.547] List of 5
[16:19:33.547]  $ ...future.FUN            :function (x)  
[16:19:33.547]  $ future.call.arguments    : list()
[16:19:33.547]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:33.547]  $ ...future.elements_ii    :List of 2
[16:19:33.547]   ..$ : int 1
[16:19:33.547]   ..$ : int 0
[16:19:33.547]  $ ...future.seeds_ii       : NULL
[16:19:33.547]  $ ...future.globals.maxSize: NULL
[16:19:33.547]  - attr(*, "where")=List of 5
[16:19:33.547]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:33.547]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:33.547]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:33.547]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:33.547]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:33.547]  - attr(*, "resolved")= logi FALSE
[16:19:33.547]  - attr(*, "total_size")= num 4720
[16:19:33.547]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:33.547]  - attr(*, "already-done")= logi TRUE
[16:19:33.552] - reassign environment for ‘...future.FUN’
[16:19:33.552] - copied ‘...future.FUN’ to environment
[16:19:33.552] - copied ‘future.call.arguments’ to environment
[16:19:33.552] - copied ‘...future.elements_ii’ to environment
[16:19:33.552] - copied ‘...future.seeds_ii’ to environment
[16:19:33.552] - copied ‘...future.globals.maxSize’ to environment
[16:19:33.552] assign_globals() ... done
[16:19:33.553] plan(): Setting new future strategy stack:
[16:19:33.553] List of future strategies:
[16:19:33.553] 1. sequential:
[16:19:33.553]    - args: function (..., envir = parent.frame())
[16:19:33.553]    - tweaked: FALSE
[16:19:33.553]    - call: NULL
[16:19:33.553] plan(): nbrOfWorkers() = 1
[16:19:34.054] plan(): Setting new future strategy stack:
[16:19:34.055] List of future strategies:
[16:19:34.055] 1. multisession:
[16:19:34.055]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:34.055]    - tweaked: FALSE
[16:19:34.055]    - call: plan(strategy)
[16:19:34.058] plan(): nbrOfWorkers() = 1
[16:19:34.059] SequentialFuture started (and completed)
[16:19:34.059] - Launch lazy future ... done
[16:19:34.059] run() for ‘SequentialFuture’ ... done
[16:19:34.059] Created future:
[16:19:34.059] SequentialFuture:
[16:19:34.059] Label: ‘future_lapply-1’
[16:19:34.059] Expression:
[16:19:34.059] {
[16:19:34.059]     do.call(function(...) {
[16:19:34.059]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:34.059]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:34.059]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:34.059]             on.exit(options(oopts), add = TRUE)
[16:19:34.059]         }
[16:19:34.059]         {
[16:19:34.059]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:34.059]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:34.059]                 ...future.FUN(...future.X_jj, ...)
[16:19:34.059]             })
[16:19:34.059]         }
[16:19:34.059]     }, args = future.call.arguments)
[16:19:34.059] }
[16:19:34.059] Lazy evaluation: FALSE
[16:19:34.059] Asynchronous evaluation: FALSE
[16:19:34.059] Local evaluation: TRUE
[16:19:34.059] Environment: R_GlobalEnv
[16:19:34.059] Capture standard output: FALSE
[16:19:34.059] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:34.059] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:34.059] Packages: <none>
[16:19:34.059] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:34.059] Resolved: TRUE
[16:19:34.059] Value: 112 bytes of class ‘list’
[16:19:34.059] Early signaling: FALSE
[16:19:34.059] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:34.059] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:34.060] Chunk #1 of 1 ... DONE
[16:19:34.060] Launching 1 futures (chunks) ... DONE
[16:19:34.060] Resolving 1 futures (chunks) ...
[16:19:34.061] resolve() on list ...
[16:19:34.061]  recursive: 0
[16:19:34.061]  length: 1
[16:19:34.061] 
[16:19:34.061] resolved() for ‘SequentialFuture’ ...
[16:19:34.061] - state: ‘finished’
[16:19:34.061] - run: TRUE
[16:19:34.061] - result: ‘FutureResult’
[16:19:34.061] resolved() for ‘SequentialFuture’ ... done
[16:19:34.061] Future #1
[16:19:34.062] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:34.062] - nx: 1
[16:19:34.062] - relay: TRUE
[16:19:34.062] - stdout: TRUE
[16:19:34.062] - signal: TRUE
[16:19:34.062] - resignal: FALSE
[16:19:34.062] - force: TRUE
[16:19:34.062] - relayed: [n=1] FALSE
[16:19:34.062] - queued futures: [n=1] FALSE
[16:19:34.062]  - until=1
[16:19:34.062]  - relaying element #1
[16:19:34.063] - relayed: [n=1] TRUE
[16:19:34.063] - queued futures: [n=1] TRUE
[16:19:34.063] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:34.063]  length: 0 (resolved future 1)
[16:19:34.063] Relaying remaining futures
[16:19:34.063] signalConditionsASAP(NULL, pos=0) ...
[16:19:34.063] - nx: 1
[16:19:34.063] - relay: TRUE
[16:19:34.063] - stdout: TRUE
[16:19:34.063] - signal: TRUE
[16:19:34.063] - resignal: FALSE
[16:19:34.064] - force: TRUE
[16:19:34.064] - relayed: [n=1] TRUE
[16:19:34.064] - queued futures: [n=1] TRUE
 - flush all
[16:19:34.064] - relayed: [n=1] TRUE
[16:19:34.064] - queued futures: [n=1] TRUE
[16:19:34.064] signalConditionsASAP(NULL, pos=0) ... done
[16:19:34.064] resolve() on list ... DONE
[16:19:34.064]  - Number of value chunks collected: 1
[16:19:34.064] Resolving 1 futures (chunks) ... DONE
[16:19:34.065] Reducing values from 1 chunks ...
[16:19:34.065]  - Number of values collected after concatenation: 2
[16:19:34.065]  - Number of values expected: 2
[16:19:34.065] Reducing values from 1 chunks ... DONE
[16:19:34.065] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:19:34.065] future_lapply() ...
[16:19:34.069] Number of chunks: 1
[16:19:34.069] getGlobalsAndPackagesXApply() ...
[16:19:34.069]  - future.globals: TRUE
[16:19:34.069] getGlobalsAndPackages() ...
[16:19:34.070] Searching for globals...
[16:19:34.071] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:34.071] Searching for globals ... DONE
[16:19:34.071] Resolving globals: FALSE
[16:19:34.072] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:34.072] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:34.072] - globals: [1] ‘FUN’
[16:19:34.072] 
[16:19:34.072] getGlobalsAndPackages() ... DONE
[16:19:34.072]  - globals found/used: [n=1] ‘FUN’
[16:19:34.072]  - needed namespaces: [n=0] 
[16:19:34.073] Finding globals ... DONE
[16:19:34.073]  - use_args: TRUE
[16:19:34.073]  - Getting '...' globals ...
[16:19:34.073] resolve() on list ...
[16:19:34.073]  recursive: 0
[16:19:34.073]  length: 1
[16:19:34.073]  elements: ‘...’
[16:19:34.073]  length: 0 (resolved future 1)
[16:19:34.075] resolve() on list ... DONE
[16:19:34.075]    - '...' content: [n=0] 
[16:19:34.075] List of 1
[16:19:34.075]  $ ...: list()
[16:19:34.075]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:34.075]  - attr(*, "where")=List of 1
[16:19:34.075]   ..$ ...:<environment: 0x563562aa4cf0> 
[16:19:34.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:34.075]  - attr(*, "resolved")= logi TRUE
[16:19:34.075]  - attr(*, "total_size")= num NA
[16:19:34.078]  - Getting '...' globals ... DONE
[16:19:34.079] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:34.079] List of 2
[16:19:34.079]  $ ...future.FUN:function (x)  
[16:19:34.079]  $ ...          : list()
[16:19:34.079]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:34.079]  - attr(*, "where")=List of 2
[16:19:34.079]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:34.079]   ..$ ...          :<environment: 0x563562aa4cf0> 
[16:19:34.079]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:34.079]  - attr(*, "resolved")= logi FALSE
[16:19:34.079]  - attr(*, "total_size")= num 4720
[16:19:34.081] Packages to be attached in all futures: [n=0] 
[16:19:34.082] getGlobalsAndPackagesXApply() ... DONE
[16:19:34.082] Number of futures (= number of chunks): 1
[16:19:34.082] Launching 1 futures (chunks) ...
[16:19:34.082] Chunk #1 of 1 ...
[16:19:34.082]  - Finding globals in 'X' for chunk #1 ...
[16:19:34.082] getGlobalsAndPackages() ...
[16:19:34.082] Searching for globals...
[16:19:34.083] 
[16:19:34.083] Searching for globals ... DONE
[16:19:34.083] - globals: [0] <none>
[16:19:34.083] getGlobalsAndPackages() ... DONE
[16:19:34.083]    + additional globals found: [n=0] 
[16:19:34.083]    + additional namespaces needed: [n=0] 
[16:19:34.083]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:34.083]  - seeds: <none>
[16:19:34.083]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:34.083] getGlobalsAndPackages() ...
[16:19:34.084] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:34.084] Resolving globals: FALSE
[16:19:34.084] Tweak future expression to call with '...' arguments ...
[16:19:34.084] {
[16:19:34.084]     do.call(function(...) {
[16:19:34.084]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:34.084]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:34.084]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:34.084]             on.exit(options(oopts), add = TRUE)
[16:19:34.084]         }
[16:19:34.084]         {
[16:19:34.084]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:34.084]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:34.084]                 ...future.FUN(...future.X_jj, ...)
[16:19:34.084]             })
[16:19:34.084]         }
[16:19:34.084]     }, args = future.call.arguments)
[16:19:34.084] }
[16:19:34.084] Tweak future expression to call with '...' arguments ... DONE
[16:19:34.084] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:34.085] 
[16:19:34.085] getGlobalsAndPackages() ... DONE
[16:19:34.085] run() for ‘Future’ ...
[16:19:34.085] - state: ‘created’
[16:19:34.085] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:34.088] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:34.089] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:34.089]   - Field: ‘label’
[16:19:34.089]   - Field: ‘local’
[16:19:34.089]   - Field: ‘owner’
[16:19:34.089]   - Field: ‘envir’
[16:19:34.089]   - Field: ‘packages’
[16:19:34.089]   - Field: ‘gc’
[16:19:34.089]   - Field: ‘conditions’
[16:19:34.089]   - Field: ‘expr’
[16:19:34.089]   - Field: ‘uuid’
[16:19:34.089]   - Field: ‘seed’
[16:19:34.090]   - Field: ‘version’
[16:19:34.090]   - Field: ‘result’
[16:19:34.090]   - Field: ‘asynchronous’
[16:19:34.090]   - Field: ‘calls’
[16:19:34.090]   - Field: ‘globals’
[16:19:34.090]   - Field: ‘stdout’
[16:19:34.090]   - Field: ‘earlySignal’
[16:19:34.090]   - Field: ‘lazy’
[16:19:34.090]   - Field: ‘state’
[16:19:34.090] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:34.090] - Launch lazy future ...
[16:19:34.091] Packages needed by the future expression (n = 0): <none>
[16:19:34.091] Packages needed by future strategies (n = 0): <none>
[16:19:34.091] {
[16:19:34.091]     {
[16:19:34.091]         {
[16:19:34.091]             ...future.startTime <- base::Sys.time()
[16:19:34.091]             {
[16:19:34.091]                 {
[16:19:34.091]                   {
[16:19:34.091]                     base::local({
[16:19:34.091]                       has_future <- base::requireNamespace("future", 
[16:19:34.091]                         quietly = TRUE)
[16:19:34.091]                       if (has_future) {
[16:19:34.091]                         ns <- base::getNamespace("future")
[16:19:34.091]                         version <- ns[[".package"]][["version"]]
[16:19:34.091]                         if (is.null(version)) 
[16:19:34.091]                           version <- utils::packageVersion("future")
[16:19:34.091]                       }
[16:19:34.091]                       else {
[16:19:34.091]                         version <- NULL
[16:19:34.091]                       }
[16:19:34.091]                       if (!has_future || version < "1.8.0") {
[16:19:34.091]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:34.091]                           "", base::R.version$version.string), 
[16:19:34.091]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:34.091]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:34.091]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:34.091]                             "release", "version")], collapse = " "), 
[16:19:34.091]                           hostname = base::Sys.info()[["nodename"]])
[16:19:34.091]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:34.091]                           info)
[16:19:34.091]                         info <- base::paste(info, collapse = "; ")
[16:19:34.091]                         if (!has_future) {
[16:19:34.091]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:34.091]                             info)
[16:19:34.091]                         }
[16:19:34.091]                         else {
[16:19:34.091]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:34.091]                             info, version)
[16:19:34.091]                         }
[16:19:34.091]                         base::stop(msg)
[16:19:34.091]                       }
[16:19:34.091]                     })
[16:19:34.091]                   }
[16:19:34.091]                   ...future.strategy.old <- future::plan("list")
[16:19:34.091]                   options(future.plan = NULL)
[16:19:34.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:34.091]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:34.091]                 }
[16:19:34.091]                 ...future.workdir <- getwd()
[16:19:34.091]             }
[16:19:34.091]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:34.091]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:34.091]         }
[16:19:34.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:34.091]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:34.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:34.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:34.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:34.091]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:34.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:34.091]             base::names(...future.oldOptions))
[16:19:34.091]     }
[16:19:34.091]     if (FALSE) {
[16:19:34.091]     }
[16:19:34.091]     else {
[16:19:34.091]         if (TRUE) {
[16:19:34.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:34.091]                 open = "w")
[16:19:34.091]         }
[16:19:34.091]         else {
[16:19:34.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:34.091]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:34.091]         }
[16:19:34.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:34.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:34.091]             base::sink(type = "output", split = FALSE)
[16:19:34.091]             base::close(...future.stdout)
[16:19:34.091]         }, add = TRUE)
[16:19:34.091]     }
[16:19:34.091]     ...future.frame <- base::sys.nframe()
[16:19:34.091]     ...future.conditions <- base::list()
[16:19:34.091]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:34.091]     if (FALSE) {
[16:19:34.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:34.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:34.091]     }
[16:19:34.091]     ...future.result <- base::tryCatch({
[16:19:34.091]         base::withCallingHandlers({
[16:19:34.091]             ...future.value <- base::withVisible(base::local({
[16:19:34.091]                 do.call(function(...) {
[16:19:34.091]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:34.091]                   if (!identical(...future.globals.maxSize.org, 
[16:19:34.091]                     ...future.globals.maxSize)) {
[16:19:34.091]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:34.091]                     on.exit(options(oopts), add = TRUE)
[16:19:34.091]                   }
[16:19:34.091]                   {
[16:19:34.091]                     lapply(seq_along(...future.elements_ii), 
[16:19:34.091]                       FUN = function(jj) {
[16:19:34.091]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:34.091]                         ...future.FUN(...future.X_jj, ...)
[16:19:34.091]                       })
[16:19:34.091]                   }
[16:19:34.091]                 }, args = future.call.arguments)
[16:19:34.091]             }))
[16:19:34.091]             future::FutureResult(value = ...future.value$value, 
[16:19:34.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:34.091]                   ...future.rng), globalenv = if (FALSE) 
[16:19:34.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:34.091]                     ...future.globalenv.names))
[16:19:34.091]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:34.091]         }, condition = base::local({
[16:19:34.091]             c <- base::c
[16:19:34.091]             inherits <- base::inherits
[16:19:34.091]             invokeRestart <- base::invokeRestart
[16:19:34.091]             length <- base::length
[16:19:34.091]             list <- base::list
[16:19:34.091]             seq.int <- base::seq.int
[16:19:34.091]             signalCondition <- base::signalCondition
[16:19:34.091]             sys.calls <- base::sys.calls
[16:19:34.091]             `[[` <- base::`[[`
[16:19:34.091]             `+` <- base::`+`
[16:19:34.091]             `<<-` <- base::`<<-`
[16:19:34.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:34.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:34.091]                   3L)]
[16:19:34.091]             }
[16:19:34.091]             function(cond) {
[16:19:34.091]                 is_error <- inherits(cond, "error")
[16:19:34.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:34.091]                   NULL)
[16:19:34.091]                 if (is_error) {
[16:19:34.091]                   sessionInformation <- function() {
[16:19:34.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:34.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:34.091]                       search = base::search(), system = base::Sys.info())
[16:19:34.091]                   }
[16:19:34.091]                   ...future.conditions[[length(...future.conditions) + 
[16:19:34.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:34.091]                     cond$call), session = sessionInformation(), 
[16:19:34.091]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:34.091]                   signalCondition(cond)
[16:19:34.091]                 }
[16:19:34.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:34.091]                 "immediateCondition"))) {
[16:19:34.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:34.091]                   ...future.conditions[[length(...future.conditions) + 
[16:19:34.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:34.091]                   if (TRUE && !signal) {
[16:19:34.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:34.091]                     {
[16:19:34.091]                       inherits <- base::inherits
[16:19:34.091]                       invokeRestart <- base::invokeRestart
[16:19:34.091]                       is.null <- base::is.null
[16:19:34.091]                       muffled <- FALSE
[16:19:34.091]                       if (inherits(cond, "message")) {
[16:19:34.091]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:34.091]                         if (muffled) 
[16:19:34.091]                           invokeRestart("muffleMessage")
[16:19:34.091]                       }
[16:19:34.091]                       else if (inherits(cond, "warning")) {
[16:19:34.091]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:34.091]                         if (muffled) 
[16:19:34.091]                           invokeRestart("muffleWarning")
[16:19:34.091]                       }
[16:19:34.091]                       else if (inherits(cond, "condition")) {
[16:19:34.091]                         if (!is.null(pattern)) {
[16:19:34.091]                           computeRestarts <- base::computeRestarts
[16:19:34.091]                           grepl <- base::grepl
[16:19:34.091]                           restarts <- computeRestarts(cond)
[16:19:34.091]                           for (restart in restarts) {
[16:19:34.091]                             name <- restart$name
[16:19:34.091]                             if (is.null(name)) 
[16:19:34.091]                               next
[16:19:34.091]                             if (!grepl(pattern, name)) 
[16:19:34.091]                               next
[16:19:34.091]                             invokeRestart(restart)
[16:19:34.091]                             muffled <- TRUE
[16:19:34.091]                             break
[16:19:34.091]                           }
[16:19:34.091]                         }
[16:19:34.091]                       }
[16:19:34.091]                       invisible(muffled)
[16:19:34.091]                     }
[16:19:34.091]                     muffleCondition(cond, pattern = "^muffle")
[16:19:34.091]                   }
[16:19:34.091]                 }
[16:19:34.091]                 else {
[16:19:34.091]                   if (TRUE) {
[16:19:34.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:34.091]                     {
[16:19:34.091]                       inherits <- base::inherits
[16:19:34.091]                       invokeRestart <- base::invokeRestart
[16:19:34.091]                       is.null <- base::is.null
[16:19:34.091]                       muffled <- FALSE
[16:19:34.091]                       if (inherits(cond, "message")) {
[16:19:34.091]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:34.091]                         if (muffled) 
[16:19:34.091]                           invokeRestart("muffleMessage")
[16:19:34.091]                       }
[16:19:34.091]                       else if (inherits(cond, "warning")) {
[16:19:34.091]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:34.091]                         if (muffled) 
[16:19:34.091]                           invokeRestart("muffleWarning")
[16:19:34.091]                       }
[16:19:34.091]                       else if (inherits(cond, "condition")) {
[16:19:34.091]                         if (!is.null(pattern)) {
[16:19:34.091]                           computeRestarts <- base::computeRestarts
[16:19:34.091]                           grepl <- base::grepl
[16:19:34.091]                           restarts <- computeRestarts(cond)
[16:19:34.091]                           for (restart in restarts) {
[16:19:34.091]                             name <- restart$name
[16:19:34.091]                             if (is.null(name)) 
[16:19:34.091]                               next
[16:19:34.091]                             if (!grepl(pattern, name)) 
[16:19:34.091]                               next
[16:19:34.091]                             invokeRestart(restart)
[16:19:34.091]                             muffled <- TRUE
[16:19:34.091]                             break
[16:19:34.091]                           }
[16:19:34.091]                         }
[16:19:34.091]                       }
[16:19:34.091]                       invisible(muffled)
[16:19:34.091]                     }
[16:19:34.091]                     muffleCondition(cond, pattern = "^muffle")
[16:19:34.091]                   }
[16:19:34.091]                 }
[16:19:34.091]             }
[16:19:34.091]         }))
[16:19:34.091]     }, error = function(ex) {
[16:19:34.091]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:34.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:34.091]                 ...future.rng), started = ...future.startTime, 
[16:19:34.091]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:34.091]             version = "1.8"), class = "FutureResult")
[16:19:34.091]     }, finally = {
[16:19:34.091]         if (!identical(...future.workdir, getwd())) 
[16:19:34.091]             setwd(...future.workdir)
[16:19:34.091]         {
[16:19:34.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:34.091]                 ...future.oldOptions$nwarnings <- NULL
[16:19:34.091]             }
[16:19:34.091]             base::options(...future.oldOptions)
[16:19:34.091]             if (.Platform$OS.type == "windows") {
[16:19:34.091]                 old_names <- names(...future.oldEnvVars)
[16:19:34.091]                 envs <- base::Sys.getenv()
[16:19:34.091]                 names <- names(envs)
[16:19:34.091]                 common <- intersect(names, old_names)
[16:19:34.091]                 added <- setdiff(names, old_names)
[16:19:34.091]                 removed <- setdiff(old_names, names)
[16:19:34.091]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:34.091]                   envs[common]]
[16:19:34.091]                 NAMES <- toupper(changed)
[16:19:34.091]                 args <- list()
[16:19:34.091]                 for (kk in seq_along(NAMES)) {
[16:19:34.091]                   name <- changed[[kk]]
[16:19:34.091]                   NAME <- NAMES[[kk]]
[16:19:34.091]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:34.091]                     next
[16:19:34.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:34.091]                 }
[16:19:34.091]                 NAMES <- toupper(added)
[16:19:34.091]                 for (kk in seq_along(NAMES)) {
[16:19:34.091]                   name <- added[[kk]]
[16:19:34.091]                   NAME <- NAMES[[kk]]
[16:19:34.091]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:34.091]                     next
[16:19:34.091]                   args[[name]] <- ""
[16:19:34.091]                 }
[16:19:34.091]                 NAMES <- toupper(removed)
[16:19:34.091]                 for (kk in seq_along(NAMES)) {
[16:19:34.091]                   name <- removed[[kk]]
[16:19:34.091]                   NAME <- NAMES[[kk]]
[16:19:34.091]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:34.091]                     next
[16:19:34.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:34.091]                 }
[16:19:34.091]                 if (length(args) > 0) 
[16:19:34.091]                   base::do.call(base::Sys.setenv, args = args)
[16:19:34.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:34.091]             }
[16:19:34.091]             else {
[16:19:34.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:34.091]             }
[16:19:34.091]             {
[16:19:34.091]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:34.091]                   0L) {
[16:19:34.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:34.091]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:34.091]                   base::options(opts)
[16:19:34.091]                 }
[16:19:34.091]                 {
[16:19:34.091]                   {
[16:19:34.091]                     NULL
[16:19:34.091]                     RNGkind("Mersenne-Twister")
[16:19:34.091]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:34.091]                       inherits = FALSE)
[16:19:34.091]                   }
[16:19:34.091]                   options(future.plan = NULL)
[16:19:34.091]                   if (is.na(NA_character_)) 
[16:19:34.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:34.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:34.091]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:34.091]                     .init = FALSE)
[16:19:34.091]                 }
[16:19:34.091]             }
[16:19:34.091]         }
[16:19:34.091]     })
[16:19:34.091]     if (TRUE) {
[16:19:34.091]         base::sink(type = "output", split = FALSE)
[16:19:34.091]         if (TRUE) {
[16:19:34.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:34.091]         }
[16:19:34.091]         else {
[16:19:34.091]             ...future.result["stdout"] <- base::list(NULL)
[16:19:34.091]         }
[16:19:34.091]         base::close(...future.stdout)
[16:19:34.091]         ...future.stdout <- NULL
[16:19:34.091]     }
[16:19:34.091]     ...future.result$conditions <- ...future.conditions
[16:19:34.091]     ...future.result$finished <- base::Sys.time()
[16:19:34.091]     ...future.result
[16:19:34.091] }
[16:19:34.093] assign_globals() ...
[16:19:34.093] List of 5
[16:19:34.093]  $ ...future.FUN            :function (x)  
[16:19:34.093]  $ future.call.arguments    : list()
[16:19:34.093]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:34.093]  $ ...future.elements_ii    :List of 2
[16:19:34.093]   ..$ : int 1
[16:19:34.093]   ..$ : int 0
[16:19:34.093]  $ ...future.seeds_ii       : NULL
[16:19:34.093]  $ ...future.globals.maxSize: NULL
[16:19:34.093]  - attr(*, "where")=List of 5
[16:19:34.093]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:34.093]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:34.093]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:34.093]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:34.093]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:34.093]  - attr(*, "resolved")= logi FALSE
[16:19:34.093]  - attr(*, "total_size")= num 4720
[16:19:34.093]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:34.093]  - attr(*, "already-done")= logi TRUE
[16:19:34.098] - reassign environment for ‘...future.FUN’
[16:19:34.098] - copied ‘...future.FUN’ to environment
[16:19:34.098] - copied ‘future.call.arguments’ to environment
[16:19:34.098] - copied ‘...future.elements_ii’ to environment
[16:19:34.098] - copied ‘...future.seeds_ii’ to environment
[16:19:34.098] - copied ‘...future.globals.maxSize’ to environment
[16:19:34.098] assign_globals() ... done
[16:19:34.099] plan(): Setting new future strategy stack:
[16:19:34.099] List of future strategies:
[16:19:34.099] 1. sequential:
[16:19:34.099]    - args: function (..., envir = parent.frame())
[16:19:34.099]    - tweaked: FALSE
[16:19:34.099]    - call: NULL
[16:19:34.099] plan(): nbrOfWorkers() = 1
[16:19:34.601] plan(): Setting new future strategy stack:
[16:19:34.601] List of future strategies:
[16:19:34.601] 1. multisession:
[16:19:34.601]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:34.601]    - tweaked: FALSE
[16:19:34.601]    - call: plan(strategy)
[16:19:34.605] plan(): nbrOfWorkers() = 1
[16:19:34.605] SequentialFuture started (and completed)
[16:19:34.605] - Launch lazy future ... done
[16:19:34.605] run() for ‘SequentialFuture’ ... done
[16:19:34.605] Created future:
[16:19:34.605] SequentialFuture:
[16:19:34.605] Label: ‘future_lapply-1’
[16:19:34.605] Expression:
[16:19:34.605] {
[16:19:34.605]     do.call(function(...) {
[16:19:34.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:34.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:34.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:34.605]             on.exit(options(oopts), add = TRUE)
[16:19:34.605]         }
[16:19:34.605]         {
[16:19:34.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:34.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:34.605]                 ...future.FUN(...future.X_jj, ...)
[16:19:34.605]             })
[16:19:34.605]         }
[16:19:34.605]     }, args = future.call.arguments)
[16:19:34.605] }
[16:19:34.605] Lazy evaluation: FALSE
[16:19:34.605] Asynchronous evaluation: FALSE
[16:19:34.605] Local evaluation: TRUE
[16:19:34.605] Environment: R_GlobalEnv
[16:19:34.605] Capture standard output: TRUE
[16:19:34.605] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:34.605] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:34.605] Packages: <none>
[16:19:34.605] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:34.605] Resolved: TRUE
[16:19:34.605] Value: 112 bytes of class ‘list’
[16:19:34.605] Early signaling: FALSE
[16:19:34.605] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:34.605] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:34.606] Chunk #1 of 1 ... DONE
[16:19:34.608] Launching 1 futures (chunks) ... DONE
[16:19:34.608] Resolving 1 futures (chunks) ...
[16:19:34.608] resolve() on list ...
[16:19:34.609]  recursive: 0
[16:19:34.609]  length: 1
[16:19:34.609] 
[16:19:34.609] resolved() for ‘SequentialFuture’ ...
[16:19:34.609] - state: ‘finished’
[16:19:34.609] - run: TRUE
[16:19:34.609] - result: ‘FutureResult’
[16:19:34.609] resolved() for ‘SequentialFuture’ ... done
[16:19:34.609] Future #1
[16:19:34.610] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:34.610] - nx: 1
[16:19:34.610] - relay: TRUE
[16:19:34.610] - stdout: TRUE
[16:19:34.610] - signal: TRUE
[16:19:34.610] - resignal: FALSE
[16:19:34.610] - force: TRUE
[16:19:34.610] - relayed: [n=1] FALSE
[16:19:34.611] - queued futures: [n=1] FALSE
[16:19:34.611]  - until=1
[16:19:34.611]  - relaying element #1
[16:19:34.611] - relayed: [n=1] TRUE
[16:19:34.611] - queued futures: [n=1] TRUE
[16:19:34.611] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:34.611]  length: 0 (resolved future 1)
[16:19:34.611] Relaying remaining futures
[16:19:34.611] signalConditionsASAP(NULL, pos=0) ...
[16:19:34.611] - nx: 1
[16:19:34.612] - relay: TRUE
[16:19:34.612] - stdout: TRUE
[16:19:34.612] - signal: TRUE
[16:19:34.612] - resignal: FALSE
[16:19:34.612] - force: TRUE
[16:19:34.612] - relayed: [n=1] TRUE
[16:19:34.612] - queued futures: [n=1] TRUE
 - flush all
[16:19:34.612] - relayed: [n=1] TRUE
[16:19:34.612] - queued futures: [n=1] TRUE
[16:19:34.612] signalConditionsASAP(NULL, pos=0) ... done
[16:19:34.613] resolve() on list ... DONE
[16:19:34.613]  - Number of value chunks collected: 1
[16:19:34.613] Resolving 1 futures (chunks) ... DONE
[16:19:34.613] Reducing values from 1 chunks ...
[16:19:34.613]  - Number of values collected after concatenation: 2
[16:19:34.613]  - Number of values expected: 2
[16:19:34.613] Reducing values from 1 chunks ... DONE
[16:19:34.613] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:19:34.614] future_lapply() ...
[16:19:34.617] Number of chunks: 1
[16:19:34.617] getGlobalsAndPackagesXApply() ...
[16:19:34.618]  - future.globals: TRUE
[16:19:34.618] getGlobalsAndPackages() ...
[16:19:34.618] Searching for globals...
[16:19:34.619] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:34.619] Searching for globals ... DONE
[16:19:34.619] Resolving globals: FALSE
[16:19:34.620] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:34.620] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:34.620] - globals: [1] ‘FUN’
[16:19:34.620] 
[16:19:34.620] getGlobalsAndPackages() ... DONE
[16:19:34.621]  - globals found/used: [n=1] ‘FUN’
[16:19:34.621]  - needed namespaces: [n=0] 
[16:19:34.621] Finding globals ... DONE
[16:19:34.621]  - use_args: TRUE
[16:19:34.621]  - Getting '...' globals ...
[16:19:34.621] resolve() on list ...
[16:19:34.621]  recursive: 0
[16:19:34.621]  length: 1
[16:19:34.621]  elements: ‘...’
[16:19:34.622]  length: 0 (resolved future 1)
[16:19:34.622] resolve() on list ... DONE
[16:19:34.622]    - '...' content: [n=0] 
[16:19:34.622] List of 1
[16:19:34.622]  $ ...: list()
[16:19:34.622]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:34.622]  - attr(*, "where")=List of 1
[16:19:34.622]   ..$ ...:<environment: 0x563561395570> 
[16:19:34.622]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:34.622]  - attr(*, "resolved")= logi TRUE
[16:19:34.622]  - attr(*, "total_size")= num NA
[16:19:34.624]  - Getting '...' globals ... DONE
[16:19:34.625] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:34.625] List of 2
[16:19:34.625]  $ ...future.FUN:function (x)  
[16:19:34.625]  $ ...          : list()
[16:19:34.625]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:34.625]  - attr(*, "where")=List of 2
[16:19:34.625]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:34.625]   ..$ ...          :<environment: 0x563561395570> 
[16:19:34.625]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:34.625]  - attr(*, "resolved")= logi FALSE
[16:19:34.625]  - attr(*, "total_size")= num 4720
[16:19:34.627] Packages to be attached in all futures: [n=0] 
[16:19:34.627] getGlobalsAndPackagesXApply() ... DONE
[16:19:34.628] Number of futures (= number of chunks): 1
[16:19:34.628] Launching 1 futures (chunks) ...
[16:19:34.628] Chunk #1 of 1 ...
[16:19:34.628]  - Finding globals in 'X' for chunk #1 ...
[16:19:34.628] getGlobalsAndPackages() ...
[16:19:34.628] Searching for globals...
[16:19:34.628] 
[16:19:34.629] Searching for globals ... DONE
[16:19:34.629] - globals: [0] <none>
[16:19:34.629] getGlobalsAndPackages() ... DONE
[16:19:34.629]    + additional globals found: [n=0] 
[16:19:34.629]    + additional namespaces needed: [n=0] 
[16:19:34.629]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:34.629]  - seeds: <none>
[16:19:34.629]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:34.629] getGlobalsAndPackages() ...
[16:19:34.629] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:34.629] Resolving globals: FALSE
[16:19:34.630] Tweak future expression to call with '...' arguments ...
[16:19:34.630] {
[16:19:34.630]     do.call(function(...) {
[16:19:34.630]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:34.630]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:34.630]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:34.630]             on.exit(options(oopts), add = TRUE)
[16:19:34.630]         }
[16:19:34.630]         {
[16:19:34.630]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:34.630]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:34.630]                 ...future.FUN(...future.X_jj, ...)
[16:19:34.630]             })
[16:19:34.630]         }
[16:19:34.630]     }, args = future.call.arguments)
[16:19:34.630] }
[16:19:34.630] Tweak future expression to call with '...' arguments ... DONE
[16:19:34.630] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:34.630] 
[16:19:34.630] getGlobalsAndPackages() ... DONE
[16:19:34.631] run() for ‘Future’ ...
[16:19:34.631] - state: ‘created’
[16:19:34.631] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:34.634] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:34.634] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:34.635]   - Field: ‘label’
[16:19:34.635]   - Field: ‘local’
[16:19:34.635]   - Field: ‘owner’
[16:19:34.635]   - Field: ‘envir’
[16:19:34.635]   - Field: ‘packages’
[16:19:34.635]   - Field: ‘gc’
[16:19:34.635]   - Field: ‘conditions’
[16:19:34.635]   - Field: ‘expr’
[16:19:34.635]   - Field: ‘uuid’
[16:19:34.635]   - Field: ‘seed’
[16:19:34.636]   - Field: ‘version’
[16:19:34.636]   - Field: ‘result’
[16:19:34.636]   - Field: ‘asynchronous’
[16:19:34.636]   - Field: ‘calls’
[16:19:34.636]   - Field: ‘globals’
[16:19:34.636]   - Field: ‘stdout’
[16:19:34.636]   - Field: ‘earlySignal’
[16:19:34.636]   - Field: ‘lazy’
[16:19:34.636]   - Field: ‘state’
[16:19:34.637] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:34.638] - Launch lazy future ...
[16:19:34.638] Packages needed by the future expression (n = 0): <none>
[16:19:34.638] Packages needed by future strategies (n = 0): <none>
[16:19:34.638] {
[16:19:34.638]     {
[16:19:34.638]         {
[16:19:34.638]             ...future.startTime <- base::Sys.time()
[16:19:34.638]             {
[16:19:34.638]                 {
[16:19:34.638]                   {
[16:19:34.638]                     base::local({
[16:19:34.638]                       has_future <- base::requireNamespace("future", 
[16:19:34.638]                         quietly = TRUE)
[16:19:34.638]                       if (has_future) {
[16:19:34.638]                         ns <- base::getNamespace("future")
[16:19:34.638]                         version <- ns[[".package"]][["version"]]
[16:19:34.638]                         if (is.null(version)) 
[16:19:34.638]                           version <- utils::packageVersion("future")
[16:19:34.638]                       }
[16:19:34.638]                       else {
[16:19:34.638]                         version <- NULL
[16:19:34.638]                       }
[16:19:34.638]                       if (!has_future || version < "1.8.0") {
[16:19:34.638]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:34.638]                           "", base::R.version$version.string), 
[16:19:34.638]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:34.638]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:34.638]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:34.638]                             "release", "version")], collapse = " "), 
[16:19:34.638]                           hostname = base::Sys.info()[["nodename"]])
[16:19:34.638]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:34.638]                           info)
[16:19:34.638]                         info <- base::paste(info, collapse = "; ")
[16:19:34.638]                         if (!has_future) {
[16:19:34.638]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:34.638]                             info)
[16:19:34.638]                         }
[16:19:34.638]                         else {
[16:19:34.638]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:34.638]                             info, version)
[16:19:34.638]                         }
[16:19:34.638]                         base::stop(msg)
[16:19:34.638]                       }
[16:19:34.638]                     })
[16:19:34.638]                   }
[16:19:34.638]                   ...future.strategy.old <- future::plan("list")
[16:19:34.638]                   options(future.plan = NULL)
[16:19:34.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:34.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:34.638]                 }
[16:19:34.638]                 ...future.workdir <- getwd()
[16:19:34.638]             }
[16:19:34.638]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:34.638]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:34.638]         }
[16:19:34.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:34.638]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:34.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:34.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:34.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:34.638]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:34.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:34.638]             base::names(...future.oldOptions))
[16:19:34.638]     }
[16:19:34.638]     if (TRUE) {
[16:19:34.638]     }
[16:19:34.638]     else {
[16:19:34.638]         if (NA) {
[16:19:34.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:34.638]                 open = "w")
[16:19:34.638]         }
[16:19:34.638]         else {
[16:19:34.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:34.638]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:34.638]         }
[16:19:34.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:34.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:34.638]             base::sink(type = "output", split = FALSE)
[16:19:34.638]             base::close(...future.stdout)
[16:19:34.638]         }, add = TRUE)
[16:19:34.638]     }
[16:19:34.638]     ...future.frame <- base::sys.nframe()
[16:19:34.638]     ...future.conditions <- base::list()
[16:19:34.638]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:34.638]     if (FALSE) {
[16:19:34.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:34.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:34.638]     }
[16:19:34.638]     ...future.result <- base::tryCatch({
[16:19:34.638]         base::withCallingHandlers({
[16:19:34.638]             ...future.value <- base::withVisible(base::local({
[16:19:34.638]                 do.call(function(...) {
[16:19:34.638]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:34.638]                   if (!identical(...future.globals.maxSize.org, 
[16:19:34.638]                     ...future.globals.maxSize)) {
[16:19:34.638]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:34.638]                     on.exit(options(oopts), add = TRUE)
[16:19:34.638]                   }
[16:19:34.638]                   {
[16:19:34.638]                     lapply(seq_along(...future.elements_ii), 
[16:19:34.638]                       FUN = function(jj) {
[16:19:34.638]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:34.638]                         ...future.FUN(...future.X_jj, ...)
[16:19:34.638]                       })
[16:19:34.638]                   }
[16:19:34.638]                 }, args = future.call.arguments)
[16:19:34.638]             }))
[16:19:34.638]             future::FutureResult(value = ...future.value$value, 
[16:19:34.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:34.638]                   ...future.rng), globalenv = if (FALSE) 
[16:19:34.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:34.638]                     ...future.globalenv.names))
[16:19:34.638]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:34.638]         }, condition = base::local({
[16:19:34.638]             c <- base::c
[16:19:34.638]             inherits <- base::inherits
[16:19:34.638]             invokeRestart <- base::invokeRestart
[16:19:34.638]             length <- base::length
[16:19:34.638]             list <- base::list
[16:19:34.638]             seq.int <- base::seq.int
[16:19:34.638]             signalCondition <- base::signalCondition
[16:19:34.638]             sys.calls <- base::sys.calls
[16:19:34.638]             `[[` <- base::`[[`
[16:19:34.638]             `+` <- base::`+`
[16:19:34.638]             `<<-` <- base::`<<-`
[16:19:34.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:34.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:34.638]                   3L)]
[16:19:34.638]             }
[16:19:34.638]             function(cond) {
[16:19:34.638]                 is_error <- inherits(cond, "error")
[16:19:34.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:34.638]                   NULL)
[16:19:34.638]                 if (is_error) {
[16:19:34.638]                   sessionInformation <- function() {
[16:19:34.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:34.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:34.638]                       search = base::search(), system = base::Sys.info())
[16:19:34.638]                   }
[16:19:34.638]                   ...future.conditions[[length(...future.conditions) + 
[16:19:34.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:34.638]                     cond$call), session = sessionInformation(), 
[16:19:34.638]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:34.638]                   signalCondition(cond)
[16:19:34.638]                 }
[16:19:34.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:34.638]                 "immediateCondition"))) {
[16:19:34.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:34.638]                   ...future.conditions[[length(...future.conditions) + 
[16:19:34.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:34.638]                   if (TRUE && !signal) {
[16:19:34.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:34.638]                     {
[16:19:34.638]                       inherits <- base::inherits
[16:19:34.638]                       invokeRestart <- base::invokeRestart
[16:19:34.638]                       is.null <- base::is.null
[16:19:34.638]                       muffled <- FALSE
[16:19:34.638]                       if (inherits(cond, "message")) {
[16:19:34.638]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:34.638]                         if (muffled) 
[16:19:34.638]                           invokeRestart("muffleMessage")
[16:19:34.638]                       }
[16:19:34.638]                       else if (inherits(cond, "warning")) {
[16:19:34.638]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:34.638]                         if (muffled) 
[16:19:34.638]                           invokeRestart("muffleWarning")
[16:19:34.638]                       }
[16:19:34.638]                       else if (inherits(cond, "condition")) {
[16:19:34.638]                         if (!is.null(pattern)) {
[16:19:34.638]                           computeRestarts <- base::computeRestarts
[16:19:34.638]                           grepl <- base::grepl
[16:19:34.638]                           restarts <- computeRestarts(cond)
[16:19:34.638]                           for (restart in restarts) {
[16:19:34.638]                             name <- restart$name
[16:19:34.638]                             if (is.null(name)) 
[16:19:34.638]                               next
[16:19:34.638]                             if (!grepl(pattern, name)) 
[16:19:34.638]                               next
[16:19:34.638]                             invokeRestart(restart)
[16:19:34.638]                             muffled <- TRUE
[16:19:34.638]                             break
[16:19:34.638]                           }
[16:19:34.638]                         }
[16:19:34.638]                       }
[16:19:34.638]                       invisible(muffled)
[16:19:34.638]                     }
[16:19:34.638]                     muffleCondition(cond, pattern = "^muffle")
[16:19:34.638]                   }
[16:19:34.638]                 }
[16:19:34.638]                 else {
[16:19:34.638]                   if (TRUE) {
[16:19:34.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:34.638]                     {
[16:19:34.638]                       inherits <- base::inherits
[16:19:34.638]                       invokeRestart <- base::invokeRestart
[16:19:34.638]                       is.null <- base::is.null
[16:19:34.638]                       muffled <- FALSE
[16:19:34.638]                       if (inherits(cond, "message")) {
[16:19:34.638]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:34.638]                         if (muffled) 
[16:19:34.638]                           invokeRestart("muffleMessage")
[16:19:34.638]                       }
[16:19:34.638]                       else if (inherits(cond, "warning")) {
[16:19:34.638]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:34.638]                         if (muffled) 
[16:19:34.638]                           invokeRestart("muffleWarning")
[16:19:34.638]                       }
[16:19:34.638]                       else if (inherits(cond, "condition")) {
[16:19:34.638]                         if (!is.null(pattern)) {
[16:19:34.638]                           computeRestarts <- base::computeRestarts
[16:19:34.638]                           grepl <- base::grepl
[16:19:34.638]                           restarts <- computeRestarts(cond)
[16:19:34.638]                           for (restart in restarts) {
[16:19:34.638]                             name <- restart$name
[16:19:34.638]                             if (is.null(name)) 
[16:19:34.638]                               next
[16:19:34.638]                             if (!grepl(pattern, name)) 
[16:19:34.638]                               next
[16:19:34.638]                             invokeRestart(restart)
[16:19:34.638]                             muffled <- TRUE
[16:19:34.638]                             break
[16:19:34.638]                           }
[16:19:34.638]                         }
[16:19:34.638]                       }
[16:19:34.638]                       invisible(muffled)
[16:19:34.638]                     }
[16:19:34.638]                     muffleCondition(cond, pattern = "^muffle")
[16:19:34.638]                   }
[16:19:34.638]                 }
[16:19:34.638]             }
[16:19:34.638]         }))
[16:19:34.638]     }, error = function(ex) {
[16:19:34.638]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:34.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:34.638]                 ...future.rng), started = ...future.startTime, 
[16:19:34.638]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:34.638]             version = "1.8"), class = "FutureResult")
[16:19:34.638]     }, finally = {
[16:19:34.638]         if (!identical(...future.workdir, getwd())) 
[16:19:34.638]             setwd(...future.workdir)
[16:19:34.638]         {
[16:19:34.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:34.638]                 ...future.oldOptions$nwarnings <- NULL
[16:19:34.638]             }
[16:19:34.638]             base::options(...future.oldOptions)
[16:19:34.638]             if (.Platform$OS.type == "windows") {
[16:19:34.638]                 old_names <- names(...future.oldEnvVars)
[16:19:34.638]                 envs <- base::Sys.getenv()
[16:19:34.638]                 names <- names(envs)
[16:19:34.638]                 common <- intersect(names, old_names)
[16:19:34.638]                 added <- setdiff(names, old_names)
[16:19:34.638]                 removed <- setdiff(old_names, names)
[16:19:34.638]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:34.638]                   envs[common]]
[16:19:34.638]                 NAMES <- toupper(changed)
[16:19:34.638]                 args <- list()
[16:19:34.638]                 for (kk in seq_along(NAMES)) {
[16:19:34.638]                   name <- changed[[kk]]
[16:19:34.638]                   NAME <- NAMES[[kk]]
[16:19:34.638]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:34.638]                     next
[16:19:34.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:34.638]                 }
[16:19:34.638]                 NAMES <- toupper(added)
[16:19:34.638]                 for (kk in seq_along(NAMES)) {
[16:19:34.638]                   name <- added[[kk]]
[16:19:34.638]                   NAME <- NAMES[[kk]]
[16:19:34.638]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:34.638]                     next
[16:19:34.638]                   args[[name]] <- ""
[16:19:34.638]                 }
[16:19:34.638]                 NAMES <- toupper(removed)
[16:19:34.638]                 for (kk in seq_along(NAMES)) {
[16:19:34.638]                   name <- removed[[kk]]
[16:19:34.638]                   NAME <- NAMES[[kk]]
[16:19:34.638]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:34.638]                     next
[16:19:34.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:34.638]                 }
[16:19:34.638]                 if (length(args) > 0) 
[16:19:34.638]                   base::do.call(base::Sys.setenv, args = args)
[16:19:34.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:34.638]             }
[16:19:34.638]             else {
[16:19:34.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:34.638]             }
[16:19:34.638]             {
[16:19:34.638]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:34.638]                   0L) {
[16:19:34.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:34.638]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:34.638]                   base::options(opts)
[16:19:34.638]                 }
[16:19:34.638]                 {
[16:19:34.638]                   {
[16:19:34.638]                     NULL
[16:19:34.638]                     RNGkind("Mersenne-Twister")
[16:19:34.638]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:34.638]                       inherits = FALSE)
[16:19:34.638]                   }
[16:19:34.638]                   options(future.plan = NULL)
[16:19:34.638]                   if (is.na(NA_character_)) 
[16:19:34.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:34.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:34.638]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:34.638]                     .init = FALSE)
[16:19:34.638]                 }
[16:19:34.638]             }
[16:19:34.638]         }
[16:19:34.638]     })
[16:19:34.638]     if (FALSE) {
[16:19:34.638]         base::sink(type = "output", split = FALSE)
[16:19:34.638]         if (NA) {
[16:19:34.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:34.638]         }
[16:19:34.638]         else {
[16:19:34.638]             ...future.result["stdout"] <- base::list(NULL)
[16:19:34.638]         }
[16:19:34.638]         base::close(...future.stdout)
[16:19:34.638]         ...future.stdout <- NULL
[16:19:34.638]     }
[16:19:34.638]     ...future.result$conditions <- ...future.conditions
[16:19:34.638]     ...future.result$finished <- base::Sys.time()
[16:19:34.638]     ...future.result
[16:19:34.638] }
[16:19:34.640] assign_globals() ...
[16:19:34.640] List of 5
[16:19:34.640]  $ ...future.FUN            :function (x)  
[16:19:34.640]  $ future.call.arguments    : list()
[16:19:34.640]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:34.640]  $ ...future.elements_ii    :List of 2
[16:19:34.640]   ..$ : int 1
[16:19:34.640]   ..$ : int 0
[16:19:34.640]  $ ...future.seeds_ii       : NULL
[16:19:34.640]  $ ...future.globals.maxSize: NULL
[16:19:34.640]  - attr(*, "where")=List of 5
[16:19:34.640]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:34.640]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:34.640]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:34.640]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:34.640]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:34.640]  - attr(*, "resolved")= logi FALSE
[16:19:34.640]  - attr(*, "total_size")= num 4720
[16:19:34.640]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:34.640]  - attr(*, "already-done")= logi TRUE
[16:19:34.645] - reassign environment for ‘...future.FUN’
[16:19:34.645] - copied ‘...future.FUN’ to environment
[16:19:34.645] - copied ‘future.call.arguments’ to environment
[16:19:34.645] - copied ‘...future.elements_ii’ to environment
[16:19:34.645] - copied ‘...future.seeds_ii’ to environment
[16:19:34.645] - copied ‘...future.globals.maxSize’ to environment
[16:19:34.645] assign_globals() ... done
[16:19:34.646] plan(): Setting new future strategy stack:
[16:19:34.646] List of future strategies:
[16:19:34.646] 1. sequential:
[16:19:34.646]    - args: function (..., envir = parent.frame())
[16:19:34.646]    - tweaked: FALSE
[16:19:34.646]    - call: NULL
[16:19:34.646] plan(): nbrOfWorkers() = 1
[16:19:35.148] plan(): Setting new future strategy stack:
[16:19:35.148] List of future strategies:
[16:19:35.148] 1. multisession:
[16:19:35.148]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:35.148]    - tweaked: FALSE
[16:19:35.148]    - call: plan(strategy)
[16:19:35.152] plan(): nbrOfWorkers() = 1
[16:19:35.152] SequentialFuture started (and completed)
[16:19:35.152] - Launch lazy future ... done
[16:19:35.153] run() for ‘SequentialFuture’ ... done
[16:19:35.153] Created future:
[16:19:35.153] SequentialFuture:
[16:19:35.153] Label: ‘future_lapply-1’
[16:19:35.153] Expression:
[16:19:35.153] {
[16:19:35.153]     do.call(function(...) {
[16:19:35.153]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:35.153]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:35.153]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:35.153]             on.exit(options(oopts), add = TRUE)
[16:19:35.153]         }
[16:19:35.153]         {
[16:19:35.153]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:35.153]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:35.153]                 ...future.FUN(...future.X_jj, ...)
[16:19:35.153]             })
[16:19:35.153]         }
[16:19:35.153]     }, args = future.call.arguments)
[16:19:35.153] }
[16:19:35.153] Lazy evaluation: FALSE
[16:19:35.153] Asynchronous evaluation: FALSE
[16:19:35.153] Local evaluation: TRUE
[16:19:35.153] Environment: R_GlobalEnv
[16:19:35.153] Capture standard output: NA
[16:19:35.153] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:35.153] Globals: 5 objects totaling 4.72 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:35.153] Packages: <none>
[16:19:35.153] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:35.153] Resolved: TRUE
[16:19:35.153] Value: 112 bytes of class ‘list’
[16:19:35.153] Early signaling: FALSE
[16:19:35.153] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:35.153] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:35.154] Chunk #1 of 1 ... DONE
[16:19:35.154] Launching 1 futures (chunks) ... DONE
[16:19:35.154] Resolving 1 futures (chunks) ...
[16:19:35.154] resolve() on list ...
[16:19:35.155]  recursive: 0
[16:19:35.155]  length: 1
[16:19:35.155] 
[16:19:35.155] resolved() for ‘SequentialFuture’ ...
[16:19:35.155] - state: ‘finished’
[16:19:35.155] - run: TRUE
[16:19:35.155] - result: ‘FutureResult’
[16:19:35.155] resolved() for ‘SequentialFuture’ ... done
[16:19:35.155] Future #1
[16:19:35.156] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:35.156] - nx: 1
[16:19:35.156] - relay: TRUE
[16:19:35.156] - stdout: TRUE
[16:19:35.156] - signal: TRUE
[16:19:35.156] - resignal: FALSE
[16:19:35.156] - force: TRUE
[16:19:35.156] - relayed: [n=1] FALSE
[16:19:35.156] - queued futures: [n=1] FALSE
[16:19:35.156]  - until=1
[16:19:35.156]  - relaying element #1
[16:19:35.157] - relayed: [n=1] TRUE
[16:19:35.157] - queued futures: [n=1] TRUE
[16:19:35.157] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:35.157]  length: 0 (resolved future 1)
[16:19:35.157] Relaying remaining futures
[16:19:35.157] signalConditionsASAP(NULL, pos=0) ...
[16:19:35.157] - nx: 1
[16:19:35.157] - relay: TRUE
[16:19:35.157] - stdout: TRUE
[16:19:35.157] - signal: TRUE
[16:19:35.157] - resignal: FALSE
[16:19:35.158] - force: TRUE
[16:19:35.158] - relayed: [n=1] TRUE
[16:19:35.158] - queued futures: [n=1] TRUE
 - flush all
[16:19:35.158] - relayed: [n=1] TRUE
[16:19:35.158] - queued futures: [n=1] TRUE
[16:19:35.158] signalConditionsASAP(NULL, pos=0) ... done
[16:19:35.158] resolve() on list ... DONE
[16:19:35.158]  - Number of value chunks collected: 1
[16:19:35.158] Resolving 1 futures (chunks) ... DONE
[16:19:35.158] Reducing values from 1 chunks ...
[16:19:35.159]  - Number of values collected after concatenation: 2
[16:19:35.159]  - Number of values expected: 2
[16:19:35.159] Reducing values from 1 chunks ... DONE
[16:19:35.159] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:19:35.159] future_mapply() ...
[16:19:35.163] Number of chunks: 1
[16:19:35.163] getGlobalsAndPackagesXApply() ...
[16:19:35.163]  - future.globals: TRUE
[16:19:35.163] getGlobalsAndPackages() ...
[16:19:35.163] Searching for globals...
[16:19:35.165] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:35.165] Searching for globals ... DONE
[16:19:35.165] Resolving globals: FALSE
[16:19:35.165] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:35.166] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:35.166] - globals: [1] ‘FUN’
[16:19:35.166] 
[16:19:35.166] getGlobalsAndPackages() ... DONE
[16:19:35.166]  - globals found/used: [n=1] ‘FUN’
[16:19:35.166]  - needed namespaces: [n=0] 
[16:19:35.166] Finding globals ... DONE
[16:19:35.166] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:35.167] List of 2
[16:19:35.167]  $ ...future.FUN:function (x, y)  
[16:19:35.167]  $ MoreArgs     : NULL
[16:19:35.167]  - attr(*, "where")=List of 2
[16:19:35.167]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:35.167]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:35.167]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:35.167]  - attr(*, "resolved")= logi FALSE
[16:19:35.167]  - attr(*, "total_size")= num NA
[16:19:35.169] Packages to be attached in all futures: [n=0] 
[16:19:35.171] getGlobalsAndPackagesXApply() ... DONE
[16:19:35.171] Number of futures (= number of chunks): 1
[16:19:35.171] Launching 1 futures (chunks) ...
[16:19:35.171] Chunk #1 of 1 ...
[16:19:35.172]  - Finding globals in '...' for chunk #1 ...
[16:19:35.172] getGlobalsAndPackages() ...
[16:19:35.172] Searching for globals...
[16:19:35.172] 
[16:19:35.172] Searching for globals ... DONE
[16:19:35.173] - globals: [0] <none>
[16:19:35.173] getGlobalsAndPackages() ... DONE
[16:19:35.173]    + additional globals found: [n=0] 
[16:19:35.173]    + additional namespaces needed: [n=0] 
[16:19:35.173]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:35.173]  - seeds: <none>
[16:19:35.173]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:35.173] getGlobalsAndPackages() ...
[16:19:35.173] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:35.174] Resolving globals: FALSE
[16:19:35.174] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:19:35.175] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:35.175] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:35.175] 
[16:19:35.175] getGlobalsAndPackages() ... DONE
[16:19:35.175] run() for ‘Future’ ...
[16:19:35.175] - state: ‘created’
[16:19:35.175] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:35.179] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:35.179] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:35.179]   - Field: ‘label’
[16:19:35.179]   - Field: ‘local’
[16:19:35.179]   - Field: ‘owner’
[16:19:35.179]   - Field: ‘envir’
[16:19:35.180]   - Field: ‘packages’
[16:19:35.180]   - Field: ‘gc’
[16:19:35.180]   - Field: ‘conditions’
[16:19:35.180]   - Field: ‘expr’
[16:19:35.180]   - Field: ‘uuid’
[16:19:35.180]   - Field: ‘seed’
[16:19:35.180]   - Field: ‘version’
[16:19:35.180]   - Field: ‘result’
[16:19:35.180]   - Field: ‘asynchronous’
[16:19:35.180]   - Field: ‘calls’
[16:19:35.180]   - Field: ‘globals’
[16:19:35.181]   - Field: ‘stdout’
[16:19:35.181]   - Field: ‘earlySignal’
[16:19:35.181]   - Field: ‘lazy’
[16:19:35.181]   - Field: ‘state’
[16:19:35.181] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:35.181] - Launch lazy future ...
[16:19:35.181] Packages needed by the future expression (n = 0): <none>
[16:19:35.181] Packages needed by future strategies (n = 0): <none>
[16:19:35.182] {
[16:19:35.182]     {
[16:19:35.182]         {
[16:19:35.182]             ...future.startTime <- base::Sys.time()
[16:19:35.182]             {
[16:19:35.182]                 {
[16:19:35.182]                   {
[16:19:35.182]                     base::local({
[16:19:35.182]                       has_future <- base::requireNamespace("future", 
[16:19:35.182]                         quietly = TRUE)
[16:19:35.182]                       if (has_future) {
[16:19:35.182]                         ns <- base::getNamespace("future")
[16:19:35.182]                         version <- ns[[".package"]][["version"]]
[16:19:35.182]                         if (is.null(version)) 
[16:19:35.182]                           version <- utils::packageVersion("future")
[16:19:35.182]                       }
[16:19:35.182]                       else {
[16:19:35.182]                         version <- NULL
[16:19:35.182]                       }
[16:19:35.182]                       if (!has_future || version < "1.8.0") {
[16:19:35.182]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:35.182]                           "", base::R.version$version.string), 
[16:19:35.182]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:35.182]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:35.182]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:35.182]                             "release", "version")], collapse = " "), 
[16:19:35.182]                           hostname = base::Sys.info()[["nodename"]])
[16:19:35.182]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:35.182]                           info)
[16:19:35.182]                         info <- base::paste(info, collapse = "; ")
[16:19:35.182]                         if (!has_future) {
[16:19:35.182]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:35.182]                             info)
[16:19:35.182]                         }
[16:19:35.182]                         else {
[16:19:35.182]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:35.182]                             info, version)
[16:19:35.182]                         }
[16:19:35.182]                         base::stop(msg)
[16:19:35.182]                       }
[16:19:35.182]                     })
[16:19:35.182]                   }
[16:19:35.182]                   ...future.strategy.old <- future::plan("list")
[16:19:35.182]                   options(future.plan = NULL)
[16:19:35.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:35.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:35.182]                 }
[16:19:35.182]                 ...future.workdir <- getwd()
[16:19:35.182]             }
[16:19:35.182]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:35.182]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:35.182]         }
[16:19:35.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:35.182]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:35.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:35.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:35.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:35.182]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:35.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:35.182]             base::names(...future.oldOptions))
[16:19:35.182]     }
[16:19:35.182]     if (FALSE) {
[16:19:35.182]     }
[16:19:35.182]     else {
[16:19:35.182]         if (FALSE) {
[16:19:35.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:35.182]                 open = "w")
[16:19:35.182]         }
[16:19:35.182]         else {
[16:19:35.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:35.182]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:35.182]         }
[16:19:35.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:35.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:35.182]             base::sink(type = "output", split = FALSE)
[16:19:35.182]             base::close(...future.stdout)
[16:19:35.182]         }, add = TRUE)
[16:19:35.182]     }
[16:19:35.182]     ...future.frame <- base::sys.nframe()
[16:19:35.182]     ...future.conditions <- base::list()
[16:19:35.182]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:35.182]     if (FALSE) {
[16:19:35.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:35.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:35.182]     }
[16:19:35.182]     ...future.result <- base::tryCatch({
[16:19:35.182]         base::withCallingHandlers({
[16:19:35.182]             ...future.value <- base::withVisible(base::local({
[16:19:35.182]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:35.182]                 if (!identical(...future.globals.maxSize.org, 
[16:19:35.182]                   ...future.globals.maxSize)) {
[16:19:35.182]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:35.182]                   on.exit(options(oopts), add = TRUE)
[16:19:35.182]                 }
[16:19:35.182]                 {
[16:19:35.182]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:35.182]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:35.182]                     USE.NAMES = FALSE)
[16:19:35.182]                   do.call(mapply, args = args)
[16:19:35.182]                 }
[16:19:35.182]             }))
[16:19:35.182]             future::FutureResult(value = ...future.value$value, 
[16:19:35.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:35.182]                   ...future.rng), globalenv = if (FALSE) 
[16:19:35.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:35.182]                     ...future.globalenv.names))
[16:19:35.182]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:35.182]         }, condition = base::local({
[16:19:35.182]             c <- base::c
[16:19:35.182]             inherits <- base::inherits
[16:19:35.182]             invokeRestart <- base::invokeRestart
[16:19:35.182]             length <- base::length
[16:19:35.182]             list <- base::list
[16:19:35.182]             seq.int <- base::seq.int
[16:19:35.182]             signalCondition <- base::signalCondition
[16:19:35.182]             sys.calls <- base::sys.calls
[16:19:35.182]             `[[` <- base::`[[`
[16:19:35.182]             `+` <- base::`+`
[16:19:35.182]             `<<-` <- base::`<<-`
[16:19:35.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:35.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:35.182]                   3L)]
[16:19:35.182]             }
[16:19:35.182]             function(cond) {
[16:19:35.182]                 is_error <- inherits(cond, "error")
[16:19:35.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:35.182]                   NULL)
[16:19:35.182]                 if (is_error) {
[16:19:35.182]                   sessionInformation <- function() {
[16:19:35.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:35.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:35.182]                       search = base::search(), system = base::Sys.info())
[16:19:35.182]                   }
[16:19:35.182]                   ...future.conditions[[length(...future.conditions) + 
[16:19:35.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:35.182]                     cond$call), session = sessionInformation(), 
[16:19:35.182]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:35.182]                   signalCondition(cond)
[16:19:35.182]                 }
[16:19:35.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:35.182]                 "immediateCondition"))) {
[16:19:35.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:35.182]                   ...future.conditions[[length(...future.conditions) + 
[16:19:35.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:35.182]                   if (TRUE && !signal) {
[16:19:35.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:35.182]                     {
[16:19:35.182]                       inherits <- base::inherits
[16:19:35.182]                       invokeRestart <- base::invokeRestart
[16:19:35.182]                       is.null <- base::is.null
[16:19:35.182]                       muffled <- FALSE
[16:19:35.182]                       if (inherits(cond, "message")) {
[16:19:35.182]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:35.182]                         if (muffled) 
[16:19:35.182]                           invokeRestart("muffleMessage")
[16:19:35.182]                       }
[16:19:35.182]                       else if (inherits(cond, "warning")) {
[16:19:35.182]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:35.182]                         if (muffled) 
[16:19:35.182]                           invokeRestart("muffleWarning")
[16:19:35.182]                       }
[16:19:35.182]                       else if (inherits(cond, "condition")) {
[16:19:35.182]                         if (!is.null(pattern)) {
[16:19:35.182]                           computeRestarts <- base::computeRestarts
[16:19:35.182]                           grepl <- base::grepl
[16:19:35.182]                           restarts <- computeRestarts(cond)
[16:19:35.182]                           for (restart in restarts) {
[16:19:35.182]                             name <- restart$name
[16:19:35.182]                             if (is.null(name)) 
[16:19:35.182]                               next
[16:19:35.182]                             if (!grepl(pattern, name)) 
[16:19:35.182]                               next
[16:19:35.182]                             invokeRestart(restart)
[16:19:35.182]                             muffled <- TRUE
[16:19:35.182]                             break
[16:19:35.182]                           }
[16:19:35.182]                         }
[16:19:35.182]                       }
[16:19:35.182]                       invisible(muffled)
[16:19:35.182]                     }
[16:19:35.182]                     muffleCondition(cond, pattern = "^muffle")
[16:19:35.182]                   }
[16:19:35.182]                 }
[16:19:35.182]                 else {
[16:19:35.182]                   if (TRUE) {
[16:19:35.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:35.182]                     {
[16:19:35.182]                       inherits <- base::inherits
[16:19:35.182]                       invokeRestart <- base::invokeRestart
[16:19:35.182]                       is.null <- base::is.null
[16:19:35.182]                       muffled <- FALSE
[16:19:35.182]                       if (inherits(cond, "message")) {
[16:19:35.182]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:35.182]                         if (muffled) 
[16:19:35.182]                           invokeRestart("muffleMessage")
[16:19:35.182]                       }
[16:19:35.182]                       else if (inherits(cond, "warning")) {
[16:19:35.182]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:35.182]                         if (muffled) 
[16:19:35.182]                           invokeRestart("muffleWarning")
[16:19:35.182]                       }
[16:19:35.182]                       else if (inherits(cond, "condition")) {
[16:19:35.182]                         if (!is.null(pattern)) {
[16:19:35.182]                           computeRestarts <- base::computeRestarts
[16:19:35.182]                           grepl <- base::grepl
[16:19:35.182]                           restarts <- computeRestarts(cond)
[16:19:35.182]                           for (restart in restarts) {
[16:19:35.182]                             name <- restart$name
[16:19:35.182]                             if (is.null(name)) 
[16:19:35.182]                               next
[16:19:35.182]                             if (!grepl(pattern, name)) 
[16:19:35.182]                               next
[16:19:35.182]                             invokeRestart(restart)
[16:19:35.182]                             muffled <- TRUE
[16:19:35.182]                             break
[16:19:35.182]                           }
[16:19:35.182]                         }
[16:19:35.182]                       }
[16:19:35.182]                       invisible(muffled)
[16:19:35.182]                     }
[16:19:35.182]                     muffleCondition(cond, pattern = "^muffle")
[16:19:35.182]                   }
[16:19:35.182]                 }
[16:19:35.182]             }
[16:19:35.182]         }))
[16:19:35.182]     }, error = function(ex) {
[16:19:35.182]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:35.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:35.182]                 ...future.rng), started = ...future.startTime, 
[16:19:35.182]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:35.182]             version = "1.8"), class = "FutureResult")
[16:19:35.182]     }, finally = {
[16:19:35.182]         if (!identical(...future.workdir, getwd())) 
[16:19:35.182]             setwd(...future.workdir)
[16:19:35.182]         {
[16:19:35.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:35.182]                 ...future.oldOptions$nwarnings <- NULL
[16:19:35.182]             }
[16:19:35.182]             base::options(...future.oldOptions)
[16:19:35.182]             if (.Platform$OS.type == "windows") {
[16:19:35.182]                 old_names <- names(...future.oldEnvVars)
[16:19:35.182]                 envs <- base::Sys.getenv()
[16:19:35.182]                 names <- names(envs)
[16:19:35.182]                 common <- intersect(names, old_names)
[16:19:35.182]                 added <- setdiff(names, old_names)
[16:19:35.182]                 removed <- setdiff(old_names, names)
[16:19:35.182]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:35.182]                   envs[common]]
[16:19:35.182]                 NAMES <- toupper(changed)
[16:19:35.182]                 args <- list()
[16:19:35.182]                 for (kk in seq_along(NAMES)) {
[16:19:35.182]                   name <- changed[[kk]]
[16:19:35.182]                   NAME <- NAMES[[kk]]
[16:19:35.182]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:35.182]                     next
[16:19:35.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:35.182]                 }
[16:19:35.182]                 NAMES <- toupper(added)
[16:19:35.182]                 for (kk in seq_along(NAMES)) {
[16:19:35.182]                   name <- added[[kk]]
[16:19:35.182]                   NAME <- NAMES[[kk]]
[16:19:35.182]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:35.182]                     next
[16:19:35.182]                   args[[name]] <- ""
[16:19:35.182]                 }
[16:19:35.182]                 NAMES <- toupper(removed)
[16:19:35.182]                 for (kk in seq_along(NAMES)) {
[16:19:35.182]                   name <- removed[[kk]]
[16:19:35.182]                   NAME <- NAMES[[kk]]
[16:19:35.182]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:35.182]                     next
[16:19:35.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:35.182]                 }
[16:19:35.182]                 if (length(args) > 0) 
[16:19:35.182]                   base::do.call(base::Sys.setenv, args = args)
[16:19:35.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:35.182]             }
[16:19:35.182]             else {
[16:19:35.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:35.182]             }
[16:19:35.182]             {
[16:19:35.182]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:35.182]                   0L) {
[16:19:35.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:35.182]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:35.182]                   base::options(opts)
[16:19:35.182]                 }
[16:19:35.182]                 {
[16:19:35.182]                   {
[16:19:35.182]                     NULL
[16:19:35.182]                     RNGkind("Mersenne-Twister")
[16:19:35.182]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:35.182]                       inherits = FALSE)
[16:19:35.182]                   }
[16:19:35.182]                   options(future.plan = NULL)
[16:19:35.182]                   if (is.na(NA_character_)) 
[16:19:35.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:35.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:35.182]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:35.182]                     .init = FALSE)
[16:19:35.182]                 }
[16:19:35.182]             }
[16:19:35.182]         }
[16:19:35.182]     })
[16:19:35.182]     if (TRUE) {
[16:19:35.182]         base::sink(type = "output", split = FALSE)
[16:19:35.182]         if (FALSE) {
[16:19:35.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:35.182]         }
[16:19:35.182]         else {
[16:19:35.182]             ...future.result["stdout"] <- base::list(NULL)
[16:19:35.182]         }
[16:19:35.182]         base::close(...future.stdout)
[16:19:35.182]         ...future.stdout <- NULL
[16:19:35.182]     }
[16:19:35.182]     ...future.result$conditions <- ...future.conditions
[16:19:35.182]     ...future.result$finished <- base::Sys.time()
[16:19:35.182]     ...future.result
[16:19:35.182] }
[16:19:35.183] assign_globals() ...
[16:19:35.184] List of 5
[16:19:35.184]  $ ...future.FUN            :function (x, y)  
[16:19:35.184]  $ MoreArgs                 : NULL
[16:19:35.184]  $ ...future.elements_ii    :List of 2
[16:19:35.184]   ..$ :List of 2
[16:19:35.184]   .. ..$ : int 1
[16:19:35.184]   .. ..$ : int 0
[16:19:35.184]   ..$ :List of 2
[16:19:35.184]   .. ..$ : int 0
[16:19:35.184]   .. ..$ : int 1
[16:19:35.184]  $ ...future.seeds_ii       : NULL
[16:19:35.184]  $ ...future.globals.maxSize: NULL
[16:19:35.184]  - attr(*, "where")=List of 5
[16:19:35.184]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:35.184]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:35.184]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:35.184]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:35.184]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:35.184]  - attr(*, "resolved")= logi FALSE
[16:19:35.184]  - attr(*, "total_size")= num 6480
[16:19:35.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:35.184]  - attr(*, "already-done")= logi TRUE
[16:19:35.189] - reassign environment for ‘...future.FUN’
[16:19:35.189] - copied ‘...future.FUN’ to environment
[16:19:35.189] - copied ‘MoreArgs’ to environment
[16:19:35.189] - copied ‘...future.elements_ii’ to environment
[16:19:35.189] - copied ‘...future.seeds_ii’ to environment
[16:19:35.190] - copied ‘...future.globals.maxSize’ to environment
[16:19:35.190] assign_globals() ... done
[16:19:35.190] plan(): Setting new future strategy stack:
[16:19:35.190] List of future strategies:
[16:19:35.190] 1. sequential:
[16:19:35.190]    - args: function (..., envir = parent.frame())
[16:19:35.190]    - tweaked: FALSE
[16:19:35.190]    - call: NULL
[16:19:35.190] plan(): nbrOfWorkers() = 1
[16:19:35.692] plan(): Setting new future strategy stack:
[16:19:35.692] List of future strategies:
[16:19:35.692] 1. multisession:
[16:19:35.692]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:35.692]    - tweaked: FALSE
[16:19:35.692]    - call: plan(strategy)
[16:19:35.696] plan(): nbrOfWorkers() = 1
[16:19:35.696] SequentialFuture started (and completed)
[16:19:35.697] - Launch lazy future ... done
[16:19:35.697] run() for ‘SequentialFuture’ ... done
[16:19:35.697] Created future:
[16:19:35.697] SequentialFuture:
[16:19:35.697] Label: ‘future_mapply-1’
[16:19:35.697] Expression:
[16:19:35.697] {
[16:19:35.697]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:35.697]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:35.697]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:35.697]         on.exit(options(oopts), add = TRUE)
[16:19:35.697]     }
[16:19:35.697]     {
[16:19:35.697]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:35.697]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:35.697]         do.call(mapply, args = args)
[16:19:35.697]     }
[16:19:35.697] }
[16:19:35.697] Lazy evaluation: FALSE
[16:19:35.697] Asynchronous evaluation: FALSE
[16:19:35.697] Local evaluation: TRUE
[16:19:35.697] Environment: R_GlobalEnv
[16:19:35.697] Capture standard output: FALSE
[16:19:35.697] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:35.697] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:35.697] Packages: <none>
[16:19:35.697] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:35.697] Resolved: TRUE
[16:19:35.697] Value: 224 bytes of class ‘list’
[16:19:35.697] Early signaling: FALSE
[16:19:35.697] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:35.697] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:35.698] Chunk #1 of 1 ... DONE
[16:19:35.698] Launching 1 futures (chunks) ... DONE
[16:19:35.698] Resolving 1 futures (chunks) ...
[16:19:35.698] resolve() on list ...
[16:19:35.698]  recursive: 0
[16:19:35.698]  length: 1
[16:19:35.699] 
[16:19:35.699] resolved() for ‘SequentialFuture’ ...
[16:19:35.699] - state: ‘finished’
[16:19:35.699] - run: TRUE
[16:19:35.699] - result: ‘FutureResult’
[16:19:35.699] resolved() for ‘SequentialFuture’ ... done
[16:19:35.699] Future #1
[16:19:35.699] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:35.699] - nx: 1
[16:19:35.699] - relay: TRUE
[16:19:35.700] - stdout: TRUE
[16:19:35.700] - signal: TRUE
[16:19:35.700] - resignal: FALSE
[16:19:35.700] - force: TRUE
[16:19:35.700] - relayed: [n=1] FALSE
[16:19:35.700] - queued futures: [n=1] FALSE
[16:19:35.700]  - until=1
[16:19:35.700]  - relaying element #1
[16:19:35.700] - relayed: [n=1] TRUE
[16:19:35.701] - queued futures: [n=1] TRUE
[16:19:35.701] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:35.701]  length: 0 (resolved future 1)
[16:19:35.701] Relaying remaining futures
[16:19:35.701] signalConditionsASAP(NULL, pos=0) ...
[16:19:35.701] - nx: 1
[16:19:35.701] - relay: TRUE
[16:19:35.701] - stdout: TRUE
[16:19:35.701] - signal: TRUE
[16:19:35.701] - resignal: FALSE
[16:19:35.701] - force: TRUE
[16:19:35.701] - relayed: [n=1] TRUE
[16:19:35.702] - queued futures: [n=1] TRUE
 - flush all
[16:19:35.702] - relayed: [n=1] TRUE
[16:19:35.702] - queued futures: [n=1] TRUE
[16:19:35.702] signalConditionsASAP(NULL, pos=0) ... done
[16:19:35.702] resolve() on list ... DONE
[16:19:35.702]  - Number of value chunks collected: 1
[16:19:35.702] Resolving 1 futures (chunks) ... DONE
[16:19:35.702] Reducing values from 1 chunks ...
[16:19:35.702]  - Number of values collected after concatenation: 2
[16:19:35.703]  - Number of values expected: 2
[16:19:35.703] Reducing values from 1 chunks ... DONE
[16:19:35.705] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:19:35.705] future_mapply() ...
[16:19:35.709] Number of chunks: 1
[16:19:35.709] getGlobalsAndPackagesXApply() ...
[16:19:35.709]  - future.globals: TRUE
[16:19:35.709] getGlobalsAndPackages() ...
[16:19:35.710] Searching for globals...
[16:19:35.711] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:35.711] Searching for globals ... DONE
[16:19:35.711] Resolving globals: FALSE
[16:19:35.712] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:35.712] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:35.712] - globals: [1] ‘FUN’
[16:19:35.712] 
[16:19:35.713] getGlobalsAndPackages() ... DONE
[16:19:35.713]  - globals found/used: [n=1] ‘FUN’
[16:19:35.713]  - needed namespaces: [n=0] 
[16:19:35.713] Finding globals ... DONE
[16:19:35.713] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:35.713] List of 2
[16:19:35.713]  $ ...future.FUN:function (x, y)  
[16:19:35.713]  $ MoreArgs     : NULL
[16:19:35.713]  - attr(*, "where")=List of 2
[16:19:35.713]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:35.713]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:35.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:35.713]  - attr(*, "resolved")= logi FALSE
[16:19:35.713]  - attr(*, "total_size")= num NA
[16:19:35.716] Packages to be attached in all futures: [n=0] 
[16:19:35.716] getGlobalsAndPackagesXApply() ... DONE
[16:19:35.716] Number of futures (= number of chunks): 1
[16:19:35.716] Launching 1 futures (chunks) ...
[16:19:35.716] Chunk #1 of 1 ...
[16:19:35.716]  - Finding globals in '...' for chunk #1 ...
[16:19:35.716] getGlobalsAndPackages() ...
[16:19:35.717] Searching for globals...
[16:19:35.717] 
[16:19:35.717] Searching for globals ... DONE
[16:19:35.717] - globals: [0] <none>
[16:19:35.717] getGlobalsAndPackages() ... DONE
[16:19:35.717]    + additional globals found: [n=0] 
[16:19:35.717]    + additional namespaces needed: [n=0] 
[16:19:35.717]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:35.717]  - seeds: <none>
[16:19:35.718]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:35.718] getGlobalsAndPackages() ...
[16:19:35.718] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:35.718] Resolving globals: FALSE
[16:19:35.718] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:19:35.719] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:35.719] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:35.719] 
[16:19:35.719] getGlobalsAndPackages() ... DONE
[16:19:35.719] run() for ‘Future’ ...
[16:19:35.719] - state: ‘created’
[16:19:35.720] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:35.723] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:35.723] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:35.723]   - Field: ‘label’
[16:19:35.723]   - Field: ‘local’
[16:19:35.724]   - Field: ‘owner’
[16:19:35.724]   - Field: ‘envir’
[16:19:35.724]   - Field: ‘packages’
[16:19:35.724]   - Field: ‘gc’
[16:19:35.724]   - Field: ‘conditions’
[16:19:35.724]   - Field: ‘expr’
[16:19:35.724]   - Field: ‘uuid’
[16:19:35.724]   - Field: ‘seed’
[16:19:35.724]   - Field: ‘version’
[16:19:35.725]   - Field: ‘result’
[16:19:35.725]   - Field: ‘asynchronous’
[16:19:35.725]   - Field: ‘calls’
[16:19:35.725]   - Field: ‘globals’
[16:19:35.725]   - Field: ‘stdout’
[16:19:35.725]   - Field: ‘earlySignal’
[16:19:35.725]   - Field: ‘lazy’
[16:19:35.725]   - Field: ‘state’
[16:19:35.725] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:35.725] - Launch lazy future ...
[16:19:35.726] Packages needed by the future expression (n = 0): <none>
[16:19:35.726] Packages needed by future strategies (n = 0): <none>
[16:19:35.726] {
[16:19:35.726]     {
[16:19:35.726]         {
[16:19:35.726]             ...future.startTime <- base::Sys.time()
[16:19:35.726]             {
[16:19:35.726]                 {
[16:19:35.726]                   {
[16:19:35.726]                     base::local({
[16:19:35.726]                       has_future <- base::requireNamespace("future", 
[16:19:35.726]                         quietly = TRUE)
[16:19:35.726]                       if (has_future) {
[16:19:35.726]                         ns <- base::getNamespace("future")
[16:19:35.726]                         version <- ns[[".package"]][["version"]]
[16:19:35.726]                         if (is.null(version)) 
[16:19:35.726]                           version <- utils::packageVersion("future")
[16:19:35.726]                       }
[16:19:35.726]                       else {
[16:19:35.726]                         version <- NULL
[16:19:35.726]                       }
[16:19:35.726]                       if (!has_future || version < "1.8.0") {
[16:19:35.726]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:35.726]                           "", base::R.version$version.string), 
[16:19:35.726]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:35.726]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:35.726]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:35.726]                             "release", "version")], collapse = " "), 
[16:19:35.726]                           hostname = base::Sys.info()[["nodename"]])
[16:19:35.726]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:35.726]                           info)
[16:19:35.726]                         info <- base::paste(info, collapse = "; ")
[16:19:35.726]                         if (!has_future) {
[16:19:35.726]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:35.726]                             info)
[16:19:35.726]                         }
[16:19:35.726]                         else {
[16:19:35.726]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:35.726]                             info, version)
[16:19:35.726]                         }
[16:19:35.726]                         base::stop(msg)
[16:19:35.726]                       }
[16:19:35.726]                     })
[16:19:35.726]                   }
[16:19:35.726]                   ...future.strategy.old <- future::plan("list")
[16:19:35.726]                   options(future.plan = NULL)
[16:19:35.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:35.726]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:35.726]                 }
[16:19:35.726]                 ...future.workdir <- getwd()
[16:19:35.726]             }
[16:19:35.726]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:35.726]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:35.726]         }
[16:19:35.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:35.726]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:35.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:35.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:35.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:35.726]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:35.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:35.726]             base::names(...future.oldOptions))
[16:19:35.726]     }
[16:19:35.726]     if (FALSE) {
[16:19:35.726]     }
[16:19:35.726]     else {
[16:19:35.726]         if (TRUE) {
[16:19:35.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:35.726]                 open = "w")
[16:19:35.726]         }
[16:19:35.726]         else {
[16:19:35.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:35.726]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:35.726]         }
[16:19:35.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:35.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:35.726]             base::sink(type = "output", split = FALSE)
[16:19:35.726]             base::close(...future.stdout)
[16:19:35.726]         }, add = TRUE)
[16:19:35.726]     }
[16:19:35.726]     ...future.frame <- base::sys.nframe()
[16:19:35.726]     ...future.conditions <- base::list()
[16:19:35.726]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:35.726]     if (FALSE) {
[16:19:35.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:35.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:35.726]     }
[16:19:35.726]     ...future.result <- base::tryCatch({
[16:19:35.726]         base::withCallingHandlers({
[16:19:35.726]             ...future.value <- base::withVisible(base::local({
[16:19:35.726]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:35.726]                 if (!identical(...future.globals.maxSize.org, 
[16:19:35.726]                   ...future.globals.maxSize)) {
[16:19:35.726]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:35.726]                   on.exit(options(oopts), add = TRUE)
[16:19:35.726]                 }
[16:19:35.726]                 {
[16:19:35.726]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:35.726]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:35.726]                     USE.NAMES = FALSE)
[16:19:35.726]                   do.call(mapply, args = args)
[16:19:35.726]                 }
[16:19:35.726]             }))
[16:19:35.726]             future::FutureResult(value = ...future.value$value, 
[16:19:35.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:35.726]                   ...future.rng), globalenv = if (FALSE) 
[16:19:35.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:35.726]                     ...future.globalenv.names))
[16:19:35.726]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:35.726]         }, condition = base::local({
[16:19:35.726]             c <- base::c
[16:19:35.726]             inherits <- base::inherits
[16:19:35.726]             invokeRestart <- base::invokeRestart
[16:19:35.726]             length <- base::length
[16:19:35.726]             list <- base::list
[16:19:35.726]             seq.int <- base::seq.int
[16:19:35.726]             signalCondition <- base::signalCondition
[16:19:35.726]             sys.calls <- base::sys.calls
[16:19:35.726]             `[[` <- base::`[[`
[16:19:35.726]             `+` <- base::`+`
[16:19:35.726]             `<<-` <- base::`<<-`
[16:19:35.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:35.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:35.726]                   3L)]
[16:19:35.726]             }
[16:19:35.726]             function(cond) {
[16:19:35.726]                 is_error <- inherits(cond, "error")
[16:19:35.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:35.726]                   NULL)
[16:19:35.726]                 if (is_error) {
[16:19:35.726]                   sessionInformation <- function() {
[16:19:35.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:35.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:35.726]                       search = base::search(), system = base::Sys.info())
[16:19:35.726]                   }
[16:19:35.726]                   ...future.conditions[[length(...future.conditions) + 
[16:19:35.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:35.726]                     cond$call), session = sessionInformation(), 
[16:19:35.726]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:35.726]                   signalCondition(cond)
[16:19:35.726]                 }
[16:19:35.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:35.726]                 "immediateCondition"))) {
[16:19:35.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:35.726]                   ...future.conditions[[length(...future.conditions) + 
[16:19:35.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:35.726]                   if (TRUE && !signal) {
[16:19:35.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:35.726]                     {
[16:19:35.726]                       inherits <- base::inherits
[16:19:35.726]                       invokeRestart <- base::invokeRestart
[16:19:35.726]                       is.null <- base::is.null
[16:19:35.726]                       muffled <- FALSE
[16:19:35.726]                       if (inherits(cond, "message")) {
[16:19:35.726]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:35.726]                         if (muffled) 
[16:19:35.726]                           invokeRestart("muffleMessage")
[16:19:35.726]                       }
[16:19:35.726]                       else if (inherits(cond, "warning")) {
[16:19:35.726]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:35.726]                         if (muffled) 
[16:19:35.726]                           invokeRestart("muffleWarning")
[16:19:35.726]                       }
[16:19:35.726]                       else if (inherits(cond, "condition")) {
[16:19:35.726]                         if (!is.null(pattern)) {
[16:19:35.726]                           computeRestarts <- base::computeRestarts
[16:19:35.726]                           grepl <- base::grepl
[16:19:35.726]                           restarts <- computeRestarts(cond)
[16:19:35.726]                           for (restart in restarts) {
[16:19:35.726]                             name <- restart$name
[16:19:35.726]                             if (is.null(name)) 
[16:19:35.726]                               next
[16:19:35.726]                             if (!grepl(pattern, name)) 
[16:19:35.726]                               next
[16:19:35.726]                             invokeRestart(restart)
[16:19:35.726]                             muffled <- TRUE
[16:19:35.726]                             break
[16:19:35.726]                           }
[16:19:35.726]                         }
[16:19:35.726]                       }
[16:19:35.726]                       invisible(muffled)
[16:19:35.726]                     }
[16:19:35.726]                     muffleCondition(cond, pattern = "^muffle")
[16:19:35.726]                   }
[16:19:35.726]                 }
[16:19:35.726]                 else {
[16:19:35.726]                   if (TRUE) {
[16:19:35.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:35.726]                     {
[16:19:35.726]                       inherits <- base::inherits
[16:19:35.726]                       invokeRestart <- base::invokeRestart
[16:19:35.726]                       is.null <- base::is.null
[16:19:35.726]                       muffled <- FALSE
[16:19:35.726]                       if (inherits(cond, "message")) {
[16:19:35.726]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:35.726]                         if (muffled) 
[16:19:35.726]                           invokeRestart("muffleMessage")
[16:19:35.726]                       }
[16:19:35.726]                       else if (inherits(cond, "warning")) {
[16:19:35.726]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:35.726]                         if (muffled) 
[16:19:35.726]                           invokeRestart("muffleWarning")
[16:19:35.726]                       }
[16:19:35.726]                       else if (inherits(cond, "condition")) {
[16:19:35.726]                         if (!is.null(pattern)) {
[16:19:35.726]                           computeRestarts <- base::computeRestarts
[16:19:35.726]                           grepl <- base::grepl
[16:19:35.726]                           restarts <- computeRestarts(cond)
[16:19:35.726]                           for (restart in restarts) {
[16:19:35.726]                             name <- restart$name
[16:19:35.726]                             if (is.null(name)) 
[16:19:35.726]                               next
[16:19:35.726]                             if (!grepl(pattern, name)) 
[16:19:35.726]                               next
[16:19:35.726]                             invokeRestart(restart)
[16:19:35.726]                             muffled <- TRUE
[16:19:35.726]                             break
[16:19:35.726]                           }
[16:19:35.726]                         }
[16:19:35.726]                       }
[16:19:35.726]                       invisible(muffled)
[16:19:35.726]                     }
[16:19:35.726]                     muffleCondition(cond, pattern = "^muffle")
[16:19:35.726]                   }
[16:19:35.726]                 }
[16:19:35.726]             }
[16:19:35.726]         }))
[16:19:35.726]     }, error = function(ex) {
[16:19:35.726]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:35.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:35.726]                 ...future.rng), started = ...future.startTime, 
[16:19:35.726]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:35.726]             version = "1.8"), class = "FutureResult")
[16:19:35.726]     }, finally = {
[16:19:35.726]         if (!identical(...future.workdir, getwd())) 
[16:19:35.726]             setwd(...future.workdir)
[16:19:35.726]         {
[16:19:35.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:35.726]                 ...future.oldOptions$nwarnings <- NULL
[16:19:35.726]             }
[16:19:35.726]             base::options(...future.oldOptions)
[16:19:35.726]             if (.Platform$OS.type == "windows") {
[16:19:35.726]                 old_names <- names(...future.oldEnvVars)
[16:19:35.726]                 envs <- base::Sys.getenv()
[16:19:35.726]                 names <- names(envs)
[16:19:35.726]                 common <- intersect(names, old_names)
[16:19:35.726]                 added <- setdiff(names, old_names)
[16:19:35.726]                 removed <- setdiff(old_names, names)
[16:19:35.726]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:35.726]                   envs[common]]
[16:19:35.726]                 NAMES <- toupper(changed)
[16:19:35.726]                 args <- list()
[16:19:35.726]                 for (kk in seq_along(NAMES)) {
[16:19:35.726]                   name <- changed[[kk]]
[16:19:35.726]                   NAME <- NAMES[[kk]]
[16:19:35.726]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:35.726]                     next
[16:19:35.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:35.726]                 }
[16:19:35.726]                 NAMES <- toupper(added)
[16:19:35.726]                 for (kk in seq_along(NAMES)) {
[16:19:35.726]                   name <- added[[kk]]
[16:19:35.726]                   NAME <- NAMES[[kk]]
[16:19:35.726]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:35.726]                     next
[16:19:35.726]                   args[[name]] <- ""
[16:19:35.726]                 }
[16:19:35.726]                 NAMES <- toupper(removed)
[16:19:35.726]                 for (kk in seq_along(NAMES)) {
[16:19:35.726]                   name <- removed[[kk]]
[16:19:35.726]                   NAME <- NAMES[[kk]]
[16:19:35.726]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:35.726]                     next
[16:19:35.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:35.726]                 }
[16:19:35.726]                 if (length(args) > 0) 
[16:19:35.726]                   base::do.call(base::Sys.setenv, args = args)
[16:19:35.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:35.726]             }
[16:19:35.726]             else {
[16:19:35.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:35.726]             }
[16:19:35.726]             {
[16:19:35.726]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:35.726]                   0L) {
[16:19:35.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:35.726]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:35.726]                   base::options(opts)
[16:19:35.726]                 }
[16:19:35.726]                 {
[16:19:35.726]                   {
[16:19:35.726]                     NULL
[16:19:35.726]                     RNGkind("Mersenne-Twister")
[16:19:35.726]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:35.726]                       inherits = FALSE)
[16:19:35.726]                   }
[16:19:35.726]                   options(future.plan = NULL)
[16:19:35.726]                   if (is.na(NA_character_)) 
[16:19:35.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:35.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:35.726]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:35.726]                     .init = FALSE)
[16:19:35.726]                 }
[16:19:35.726]             }
[16:19:35.726]         }
[16:19:35.726]     })
[16:19:35.726]     if (TRUE) {
[16:19:35.726]         base::sink(type = "output", split = FALSE)
[16:19:35.726]         if (TRUE) {
[16:19:35.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:35.726]         }
[16:19:35.726]         else {
[16:19:35.726]             ...future.result["stdout"] <- base::list(NULL)
[16:19:35.726]         }
[16:19:35.726]         base::close(...future.stdout)
[16:19:35.726]         ...future.stdout <- NULL
[16:19:35.726]     }
[16:19:35.726]     ...future.result$conditions <- ...future.conditions
[16:19:35.726]     ...future.result$finished <- base::Sys.time()
[16:19:35.726]     ...future.result
[16:19:35.726] }
[16:19:35.728] assign_globals() ...
[16:19:35.728] List of 5
[16:19:35.728]  $ ...future.FUN            :function (x, y)  
[16:19:35.728]  $ MoreArgs                 : NULL
[16:19:35.728]  $ ...future.elements_ii    :List of 2
[16:19:35.728]   ..$ :List of 2
[16:19:35.728]   .. ..$ : int 1
[16:19:35.728]   .. ..$ : int 0
[16:19:35.728]   ..$ :List of 2
[16:19:35.728]   .. ..$ : int 0
[16:19:35.728]   .. ..$ : int 1
[16:19:35.728]  $ ...future.seeds_ii       : NULL
[16:19:35.728]  $ ...future.globals.maxSize: NULL
[16:19:35.728]  - attr(*, "where")=List of 5
[16:19:35.728]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:35.728]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:35.728]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:35.728]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:35.728]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:35.728]  - attr(*, "resolved")= logi FALSE
[16:19:35.728]  - attr(*, "total_size")= num 6480
[16:19:35.728]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:35.728]  - attr(*, "already-done")= logi TRUE
[16:19:35.734] - reassign environment for ‘...future.FUN’
[16:19:35.734] - copied ‘...future.FUN’ to environment
[16:19:35.734] - copied ‘MoreArgs’ to environment
[16:19:35.734] - copied ‘...future.elements_ii’ to environment
[16:19:35.734] - copied ‘...future.seeds_ii’ to environment
[16:19:35.734] - copied ‘...future.globals.maxSize’ to environment
[16:19:35.734] assign_globals() ... done
[16:19:35.734] plan(): Setting new future strategy stack:
[16:19:35.735] List of future strategies:
[16:19:35.735] 1. sequential:
[16:19:35.735]    - args: function (..., envir = parent.frame())
[16:19:35.735]    - tweaked: FALSE
[16:19:35.735]    - call: NULL
[16:19:35.737] plan(): nbrOfWorkers() = 1
[16:19:36.238] plan(): Setting new future strategy stack:
[16:19:36.239] List of future strategies:
[16:19:36.239] 1. multisession:
[16:19:36.239]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:36.239]    - tweaked: FALSE
[16:19:36.239]    - call: plan(strategy)
[16:19:36.243] plan(): nbrOfWorkers() = 1
[16:19:36.243] SequentialFuture started (and completed)
[16:19:36.244] - Launch lazy future ... done
[16:19:36.244] run() for ‘SequentialFuture’ ... done
[16:19:36.244] Created future:
[16:19:36.244] SequentialFuture:
[16:19:36.244] Label: ‘future_mapply-1’
[16:19:36.244] Expression:
[16:19:36.244] {
[16:19:36.244]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:36.244]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:36.244]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:36.244]         on.exit(options(oopts), add = TRUE)
[16:19:36.244]     }
[16:19:36.244]     {
[16:19:36.244]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:36.244]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:36.244]         do.call(mapply, args = args)
[16:19:36.244]     }
[16:19:36.244] }
[16:19:36.244] Lazy evaluation: FALSE
[16:19:36.244] Asynchronous evaluation: FALSE
[16:19:36.244] Local evaluation: TRUE
[16:19:36.244] Environment: R_GlobalEnv
[16:19:36.244] Capture standard output: TRUE
[16:19:36.244] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:36.244] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:36.244] Packages: <none>
[16:19:36.244] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:36.244] Resolved: TRUE
[16:19:36.244] Value: 224 bytes of class ‘list’
[16:19:36.244] Early signaling: FALSE
[16:19:36.244] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:36.244] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:36.245] Chunk #1 of 1 ... DONE
[16:19:36.245] Launching 1 futures (chunks) ... DONE
[16:19:36.245] Resolving 1 futures (chunks) ...
[16:19:36.246] resolve() on list ...
[16:19:36.246]  recursive: 0
[16:19:36.246]  length: 1
[16:19:36.246] 
[16:19:36.246] resolved() for ‘SequentialFuture’ ...
[16:19:36.246] - state: ‘finished’
[16:19:36.246] - run: TRUE
[16:19:36.246] - result: ‘FutureResult’
[16:19:36.246] resolved() for ‘SequentialFuture’ ... done
[16:19:36.246] Future #1
[16:19:36.247] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:36.247] - nx: 1
[16:19:36.247] - relay: TRUE
[16:19:36.247] - stdout: TRUE
[16:19:36.247] - signal: TRUE
[16:19:36.247] - resignal: FALSE
[16:19:36.247] - force: TRUE
[16:19:36.247] - relayed: [n=1] FALSE
[16:19:36.247] - queued futures: [n=1] FALSE
[16:19:36.247]  - until=1
[16:19:36.247]  - relaying element #1
[16:19:36.248] - relayed: [n=1] TRUE
[16:19:36.248] - queued futures: [n=1] TRUE
[16:19:36.248] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:36.248]  length: 0 (resolved future 1)
[16:19:36.248] Relaying remaining futures
[16:19:36.248] signalConditionsASAP(NULL, pos=0) ...
[16:19:36.248] - nx: 1
[16:19:36.248] - relay: TRUE
[16:19:36.248] - stdout: TRUE
[16:19:36.249] - signal: TRUE
[16:19:36.249] - resignal: FALSE
[16:19:36.249] - force: TRUE
[16:19:36.249] - relayed: [n=1] TRUE
[16:19:36.249] - queued futures: [n=1] TRUE
 - flush all
[16:19:36.249] - relayed: [n=1] TRUE
[16:19:36.249] - queued futures: [n=1] TRUE
[16:19:36.249] signalConditionsASAP(NULL, pos=0) ... done
[16:19:36.249] resolve() on list ... DONE
[16:19:36.249]  - Number of value chunks collected: 1
[16:19:36.250] Resolving 1 futures (chunks) ... DONE
[16:19:36.250] Reducing values from 1 chunks ...
[16:19:36.250]  - Number of values collected after concatenation: 2
[16:19:36.250]  - Number of values expected: 2
[16:19:36.250] Reducing values from 1 chunks ... DONE
[16:19:36.250] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:19:36.250] future_mapply() ...
[16:19:36.254] Number of chunks: 1
[16:19:36.254] getGlobalsAndPackagesXApply() ...
[16:19:36.254]  - future.globals: TRUE
[16:19:36.254] getGlobalsAndPackages() ...
[16:19:36.254] Searching for globals...
[16:19:36.256] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:36.256] Searching for globals ... DONE
[16:19:36.256] Resolving globals: FALSE
[16:19:36.256] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:36.257] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:36.257] - globals: [1] ‘FUN’
[16:19:36.257] 
[16:19:36.257] getGlobalsAndPackages() ... DONE
[16:19:36.257]  - globals found/used: [n=1] ‘FUN’
[16:19:36.257]  - needed namespaces: [n=0] 
[16:19:36.257] Finding globals ... DONE
[16:19:36.257] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:36.258] List of 2
[16:19:36.258]  $ ...future.FUN:function (x, y)  
[16:19:36.258]  $ MoreArgs     : NULL
[16:19:36.258]  - attr(*, "where")=List of 2
[16:19:36.258]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:36.258]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:36.258]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:36.258]  - attr(*, "resolved")= logi FALSE
[16:19:36.258]  - attr(*, "total_size")= num NA
[16:19:36.260] Packages to be attached in all futures: [n=0] 
[16:19:36.260] getGlobalsAndPackagesXApply() ... DONE
[16:19:36.260] Number of futures (= number of chunks): 1
[16:19:36.260] Launching 1 futures (chunks) ...
[16:19:36.261] Chunk #1 of 1 ...
[16:19:36.261]  - Finding globals in '...' for chunk #1 ...
[16:19:36.261] getGlobalsAndPackages() ...
[16:19:36.261] Searching for globals...
[16:19:36.261] 
[16:19:36.261] Searching for globals ... DONE
[16:19:36.261] - globals: [0] <none>
[16:19:36.261] getGlobalsAndPackages() ... DONE
[16:19:36.262]    + additional globals found: [n=0] 
[16:19:36.262]    + additional namespaces needed: [n=0] 
[16:19:36.262]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:36.262]  - seeds: <none>
[16:19:36.262]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:36.262] getGlobalsAndPackages() ...
[16:19:36.262] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:36.262] Resolving globals: FALSE
[16:19:36.263] The total size of the 5 globals is 6.33 KiB (6480 bytes)
[16:19:36.263] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.33 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (224 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:36.263] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:36.263] 
[16:19:36.263] getGlobalsAndPackages() ... DONE
[16:19:36.264] run() for ‘Future’ ...
[16:19:36.264] - state: ‘created’
[16:19:36.264] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:36.268] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:36.268] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[16:19:36.268]   - Field: ‘label’
[16:19:36.268]   - Field: ‘local’
[16:19:36.268]   - Field: ‘owner’
[16:19:36.268]   - Field: ‘envir’
[16:19:36.268]   - Field: ‘packages’
[16:19:36.269]   - Field: ‘gc’
[16:19:36.269]   - Field: ‘conditions’
[16:19:36.269]   - Field: ‘expr’
[16:19:36.269]   - Field: ‘uuid’
[16:19:36.269]   - Field: ‘seed’
[16:19:36.269]   - Field: ‘version’
[16:19:36.269]   - Field: ‘result’
[16:19:36.269]   - Field: ‘asynchronous’
[16:19:36.269]   - Field: ‘calls’
[16:19:36.270]   - Field: ‘globals’
[16:19:36.270]   - Field: ‘stdout’
[16:19:36.270]   - Field: ‘earlySignal’
[16:19:36.270]   - Field: ‘lazy’
[16:19:36.270]   - Field: ‘state’
[16:19:36.270] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[16:19:36.270] - Launch lazy future ...
[16:19:36.272] Packages needed by the future expression (n = 0): <none>
[16:19:36.272] Packages needed by future strategies (n = 0): <none>
[16:19:36.273] {
[16:19:36.273]     {
[16:19:36.273]         {
[16:19:36.273]             ...future.startTime <- base::Sys.time()
[16:19:36.273]             {
[16:19:36.273]                 {
[16:19:36.273]                   {
[16:19:36.273]                     base::local({
[16:19:36.273]                       has_future <- base::requireNamespace("future", 
[16:19:36.273]                         quietly = TRUE)
[16:19:36.273]                       if (has_future) {
[16:19:36.273]                         ns <- base::getNamespace("future")
[16:19:36.273]                         version <- ns[[".package"]][["version"]]
[16:19:36.273]                         if (is.null(version)) 
[16:19:36.273]                           version <- utils::packageVersion("future")
[16:19:36.273]                       }
[16:19:36.273]                       else {
[16:19:36.273]                         version <- NULL
[16:19:36.273]                       }
[16:19:36.273]                       if (!has_future || version < "1.8.0") {
[16:19:36.273]                         info <- base::c(r_version = base::gsub("R version ", 
[16:19:36.273]                           "", base::R.version$version.string), 
[16:19:36.273]                           platform = base::sprintf("%s (%s-bit)", 
[16:19:36.273]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:36.273]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:36.273]                             "release", "version")], collapse = " "), 
[16:19:36.273]                           hostname = base::Sys.info()[["nodename"]])
[16:19:36.273]                         info <- base::sprintf("%s: %s", base::names(info), 
[16:19:36.273]                           info)
[16:19:36.273]                         info <- base::paste(info, collapse = "; ")
[16:19:36.273]                         if (!has_future) {
[16:19:36.273]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:36.273]                             info)
[16:19:36.273]                         }
[16:19:36.273]                         else {
[16:19:36.273]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:36.273]                             info, version)
[16:19:36.273]                         }
[16:19:36.273]                         base::stop(msg)
[16:19:36.273]                       }
[16:19:36.273]                     })
[16:19:36.273]                   }
[16:19:36.273]                   ...future.strategy.old <- future::plan("list")
[16:19:36.273]                   options(future.plan = NULL)
[16:19:36.273]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:36.273]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:36.273]                 }
[16:19:36.273]                 ...future.workdir <- getwd()
[16:19:36.273]             }
[16:19:36.273]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:36.273]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:36.273]         }
[16:19:36.273]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:36.273]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:36.273]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:36.273]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:36.273]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:36.273]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:36.273]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:36.273]             base::names(...future.oldOptions))
[16:19:36.273]     }
[16:19:36.273]     if (TRUE) {
[16:19:36.273]     }
[16:19:36.273]     else {
[16:19:36.273]         if (NA) {
[16:19:36.273]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:36.273]                 open = "w")
[16:19:36.273]         }
[16:19:36.273]         else {
[16:19:36.273]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:36.273]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:36.273]         }
[16:19:36.273]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:36.273]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:36.273]             base::sink(type = "output", split = FALSE)
[16:19:36.273]             base::close(...future.stdout)
[16:19:36.273]         }, add = TRUE)
[16:19:36.273]     }
[16:19:36.273]     ...future.frame <- base::sys.nframe()
[16:19:36.273]     ...future.conditions <- base::list()
[16:19:36.273]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:36.273]     if (FALSE) {
[16:19:36.273]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:36.273]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:36.273]     }
[16:19:36.273]     ...future.result <- base::tryCatch({
[16:19:36.273]         base::withCallingHandlers({
[16:19:36.273]             ...future.value <- base::withVisible(base::local({
[16:19:36.273]                 ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:36.273]                 if (!identical(...future.globals.maxSize.org, 
[16:19:36.273]                   ...future.globals.maxSize)) {
[16:19:36.273]                   oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:36.273]                   on.exit(options(oopts), add = TRUE)
[16:19:36.273]                 }
[16:19:36.273]                 {
[16:19:36.273]                   args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:36.273]                     MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:36.273]                     USE.NAMES = FALSE)
[16:19:36.273]                   do.call(mapply, args = args)
[16:19:36.273]                 }
[16:19:36.273]             }))
[16:19:36.273]             future::FutureResult(value = ...future.value$value, 
[16:19:36.273]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:36.273]                   ...future.rng), globalenv = if (FALSE) 
[16:19:36.273]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:36.273]                     ...future.globalenv.names))
[16:19:36.273]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:36.273]         }, condition = base::local({
[16:19:36.273]             c <- base::c
[16:19:36.273]             inherits <- base::inherits
[16:19:36.273]             invokeRestart <- base::invokeRestart
[16:19:36.273]             length <- base::length
[16:19:36.273]             list <- base::list
[16:19:36.273]             seq.int <- base::seq.int
[16:19:36.273]             signalCondition <- base::signalCondition
[16:19:36.273]             sys.calls <- base::sys.calls
[16:19:36.273]             `[[` <- base::`[[`
[16:19:36.273]             `+` <- base::`+`
[16:19:36.273]             `<<-` <- base::`<<-`
[16:19:36.273]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:36.273]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:36.273]                   3L)]
[16:19:36.273]             }
[16:19:36.273]             function(cond) {
[16:19:36.273]                 is_error <- inherits(cond, "error")
[16:19:36.273]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:36.273]                   NULL)
[16:19:36.273]                 if (is_error) {
[16:19:36.273]                   sessionInformation <- function() {
[16:19:36.273]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:36.273]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:36.273]                       search = base::search(), system = base::Sys.info())
[16:19:36.273]                   }
[16:19:36.273]                   ...future.conditions[[length(...future.conditions) + 
[16:19:36.273]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:36.273]                     cond$call), session = sessionInformation(), 
[16:19:36.273]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:36.273]                   signalCondition(cond)
[16:19:36.273]                 }
[16:19:36.273]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:36.273]                 "immediateCondition"))) {
[16:19:36.273]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:36.273]                   ...future.conditions[[length(...future.conditions) + 
[16:19:36.273]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:36.273]                   if (TRUE && !signal) {
[16:19:36.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:36.273]                     {
[16:19:36.273]                       inherits <- base::inherits
[16:19:36.273]                       invokeRestart <- base::invokeRestart
[16:19:36.273]                       is.null <- base::is.null
[16:19:36.273]                       muffled <- FALSE
[16:19:36.273]                       if (inherits(cond, "message")) {
[16:19:36.273]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:36.273]                         if (muffled) 
[16:19:36.273]                           invokeRestart("muffleMessage")
[16:19:36.273]                       }
[16:19:36.273]                       else if (inherits(cond, "warning")) {
[16:19:36.273]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:36.273]                         if (muffled) 
[16:19:36.273]                           invokeRestart("muffleWarning")
[16:19:36.273]                       }
[16:19:36.273]                       else if (inherits(cond, "condition")) {
[16:19:36.273]                         if (!is.null(pattern)) {
[16:19:36.273]                           computeRestarts <- base::computeRestarts
[16:19:36.273]                           grepl <- base::grepl
[16:19:36.273]                           restarts <- computeRestarts(cond)
[16:19:36.273]                           for (restart in restarts) {
[16:19:36.273]                             name <- restart$name
[16:19:36.273]                             if (is.null(name)) 
[16:19:36.273]                               next
[16:19:36.273]                             if (!grepl(pattern, name)) 
[16:19:36.273]                               next
[16:19:36.273]                             invokeRestart(restart)
[16:19:36.273]                             muffled <- TRUE
[16:19:36.273]                             break
[16:19:36.273]                           }
[16:19:36.273]                         }
[16:19:36.273]                       }
[16:19:36.273]                       invisible(muffled)
[16:19:36.273]                     }
[16:19:36.273]                     muffleCondition(cond, pattern = "^muffle")
[16:19:36.273]                   }
[16:19:36.273]                 }
[16:19:36.273]                 else {
[16:19:36.273]                   if (TRUE) {
[16:19:36.273]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:36.273]                     {
[16:19:36.273]                       inherits <- base::inherits
[16:19:36.273]                       invokeRestart <- base::invokeRestart
[16:19:36.273]                       is.null <- base::is.null
[16:19:36.273]                       muffled <- FALSE
[16:19:36.273]                       if (inherits(cond, "message")) {
[16:19:36.273]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:36.273]                         if (muffled) 
[16:19:36.273]                           invokeRestart("muffleMessage")
[16:19:36.273]                       }
[16:19:36.273]                       else if (inherits(cond, "warning")) {
[16:19:36.273]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:36.273]                         if (muffled) 
[16:19:36.273]                           invokeRestart("muffleWarning")
[16:19:36.273]                       }
[16:19:36.273]                       else if (inherits(cond, "condition")) {
[16:19:36.273]                         if (!is.null(pattern)) {
[16:19:36.273]                           computeRestarts <- base::computeRestarts
[16:19:36.273]                           grepl <- base::grepl
[16:19:36.273]                           restarts <- computeRestarts(cond)
[16:19:36.273]                           for (restart in restarts) {
[16:19:36.273]                             name <- restart$name
[16:19:36.273]                             if (is.null(name)) 
[16:19:36.273]                               next
[16:19:36.273]                             if (!grepl(pattern, name)) 
[16:19:36.273]                               next
[16:19:36.273]                             invokeRestart(restart)
[16:19:36.273]                             muffled <- TRUE
[16:19:36.273]                             break
[16:19:36.273]                           }
[16:19:36.273]                         }
[16:19:36.273]                       }
[16:19:36.273]                       invisible(muffled)
[16:19:36.273]                     }
[16:19:36.273]                     muffleCondition(cond, pattern = "^muffle")
[16:19:36.273]                   }
[16:19:36.273]                 }
[16:19:36.273]             }
[16:19:36.273]         }))
[16:19:36.273]     }, error = function(ex) {
[16:19:36.273]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:36.273]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:36.273]                 ...future.rng), started = ...future.startTime, 
[16:19:36.273]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:36.273]             version = "1.8"), class = "FutureResult")
[16:19:36.273]     }, finally = {
[16:19:36.273]         if (!identical(...future.workdir, getwd())) 
[16:19:36.273]             setwd(...future.workdir)
[16:19:36.273]         {
[16:19:36.273]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:36.273]                 ...future.oldOptions$nwarnings <- NULL
[16:19:36.273]             }
[16:19:36.273]             base::options(...future.oldOptions)
[16:19:36.273]             if (.Platform$OS.type == "windows") {
[16:19:36.273]                 old_names <- names(...future.oldEnvVars)
[16:19:36.273]                 envs <- base::Sys.getenv()
[16:19:36.273]                 names <- names(envs)
[16:19:36.273]                 common <- intersect(names, old_names)
[16:19:36.273]                 added <- setdiff(names, old_names)
[16:19:36.273]                 removed <- setdiff(old_names, names)
[16:19:36.273]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:36.273]                   envs[common]]
[16:19:36.273]                 NAMES <- toupper(changed)
[16:19:36.273]                 args <- list()
[16:19:36.273]                 for (kk in seq_along(NAMES)) {
[16:19:36.273]                   name <- changed[[kk]]
[16:19:36.273]                   NAME <- NAMES[[kk]]
[16:19:36.273]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:36.273]                     next
[16:19:36.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:36.273]                 }
[16:19:36.273]                 NAMES <- toupper(added)
[16:19:36.273]                 for (kk in seq_along(NAMES)) {
[16:19:36.273]                   name <- added[[kk]]
[16:19:36.273]                   NAME <- NAMES[[kk]]
[16:19:36.273]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:36.273]                     next
[16:19:36.273]                   args[[name]] <- ""
[16:19:36.273]                 }
[16:19:36.273]                 NAMES <- toupper(removed)
[16:19:36.273]                 for (kk in seq_along(NAMES)) {
[16:19:36.273]                   name <- removed[[kk]]
[16:19:36.273]                   NAME <- NAMES[[kk]]
[16:19:36.273]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:36.273]                     next
[16:19:36.273]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:36.273]                 }
[16:19:36.273]                 if (length(args) > 0) 
[16:19:36.273]                   base::do.call(base::Sys.setenv, args = args)
[16:19:36.273]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:36.273]             }
[16:19:36.273]             else {
[16:19:36.273]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:36.273]             }
[16:19:36.273]             {
[16:19:36.273]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:36.273]                   0L) {
[16:19:36.273]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:36.273]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:36.273]                   base::options(opts)
[16:19:36.273]                 }
[16:19:36.273]                 {
[16:19:36.273]                   {
[16:19:36.273]                     NULL
[16:19:36.273]                     RNGkind("Mersenne-Twister")
[16:19:36.273]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[16:19:36.273]                       inherits = FALSE)
[16:19:36.273]                   }
[16:19:36.273]                   options(future.plan = NULL)
[16:19:36.273]                   if (is.na(NA_character_)) 
[16:19:36.273]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:36.273]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:36.273]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:36.273]                     .init = FALSE)
[16:19:36.273]                 }
[16:19:36.273]             }
[16:19:36.273]         }
[16:19:36.273]     })
[16:19:36.273]     if (FALSE) {
[16:19:36.273]         base::sink(type = "output", split = FALSE)
[16:19:36.273]         if (NA) {
[16:19:36.273]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:36.273]         }
[16:19:36.273]         else {
[16:19:36.273]             ...future.result["stdout"] <- base::list(NULL)
[16:19:36.273]         }
[16:19:36.273]         base::close(...future.stdout)
[16:19:36.273]         ...future.stdout <- NULL
[16:19:36.273]     }
[16:19:36.273]     ...future.result$conditions <- ...future.conditions
[16:19:36.273]     ...future.result$finished <- base::Sys.time()
[16:19:36.273]     ...future.result
[16:19:36.273] }
[16:19:36.274] assign_globals() ...
[16:19:36.275] List of 5
[16:19:36.275]  $ ...future.FUN            :function (x, y)  
[16:19:36.275]  $ MoreArgs                 : NULL
[16:19:36.275]  $ ...future.elements_ii    :List of 2
[16:19:36.275]   ..$ :List of 2
[16:19:36.275]   .. ..$ : int 1
[16:19:36.275]   .. ..$ : int 0
[16:19:36.275]   ..$ :List of 2
[16:19:36.275]   .. ..$ : int 0
[16:19:36.275]   .. ..$ : int 1
[16:19:36.275]  $ ...future.seeds_ii       : NULL
[16:19:36.275]  $ ...future.globals.maxSize: NULL
[16:19:36.275]  - attr(*, "where")=List of 5
[16:19:36.275]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:36.275]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:36.275]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:36.275]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:36.275]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:36.275]  - attr(*, "resolved")= logi FALSE
[16:19:36.275]  - attr(*, "total_size")= num 6480
[16:19:36.275]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:36.275]  - attr(*, "already-done")= logi TRUE
[16:19:36.280] - reassign environment for ‘...future.FUN’
[16:19:36.280] - copied ‘...future.FUN’ to environment
[16:19:36.280] - copied ‘MoreArgs’ to environment
[16:19:36.281] - copied ‘...future.elements_ii’ to environment
[16:19:36.281] - copied ‘...future.seeds_ii’ to environment
[16:19:36.281] - copied ‘...future.globals.maxSize’ to environment
[16:19:36.281] assign_globals() ... done
[16:19:36.281] plan(): Setting new future strategy stack:
[16:19:36.281] List of future strategies:
[16:19:36.281] 1. sequential:
[16:19:36.281]    - args: function (..., envir = parent.frame())
[16:19:36.281]    - tweaked: FALSE
[16:19:36.281]    - call: NULL
[16:19:36.282] plan(): nbrOfWorkers() = 1
[16:19:36.783] plan(): Setting new future strategy stack:
[16:19:36.783] List of future strategies:
[16:19:36.783] 1. multisession:
[16:19:36.783]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:36.783]    - tweaked: FALSE
[16:19:36.783]    - call: plan(strategy)
[16:19:36.787] plan(): nbrOfWorkers() = 1
[16:19:36.787] SequentialFuture started (and completed)
[16:19:36.788] - Launch lazy future ... done
[16:19:36.788] run() for ‘SequentialFuture’ ... done
[16:19:36.788] Created future:
[16:19:36.788] SequentialFuture:
[16:19:36.788] Label: ‘future_mapply-1’
[16:19:36.788] Expression:
[16:19:36.788] {
[16:19:36.788]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:36.788]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:36.788]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:36.788]         on.exit(options(oopts), add = TRUE)
[16:19:36.788]     }
[16:19:36.788]     {
[16:19:36.788]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:36.788]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:36.788]         do.call(mapply, args = args)
[16:19:36.788]     }
[16:19:36.788] }
[16:19:36.788] Lazy evaluation: FALSE
[16:19:36.788] Asynchronous evaluation: FALSE
[16:19:36.788] Local evaluation: TRUE
[16:19:36.788] Environment: R_GlobalEnv
[16:19:36.788] Capture standard output: NA
[16:19:36.788] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:36.788] Globals: 5 objects totaling 6.33 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:36.788] Packages: <none>
[16:19:36.788] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:36.788] Resolved: TRUE
[16:19:36.788] Value: 224 bytes of class ‘list’
[16:19:36.788] Early signaling: FALSE
[16:19:36.788] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:36.788] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[16:19:36.789] Chunk #1 of 1 ... DONE
[16:19:36.789] Launching 1 futures (chunks) ... DONE
[16:19:36.789] Resolving 1 futures (chunks) ...
[16:19:36.789] resolve() on list ...
[16:19:36.789]  recursive: 0
[16:19:36.789]  length: 1
[16:19:36.790] 
[16:19:36.790] resolved() for ‘SequentialFuture’ ...
[16:19:36.790] - state: ‘finished’
[16:19:36.790] - run: TRUE
[16:19:36.790] - result: ‘FutureResult’
[16:19:36.790] resolved() for ‘SequentialFuture’ ... done
[16:19:36.790] Future #1
[16:19:36.790] signalConditionsASAP(SequentialFuture, pos=1) ...
[16:19:36.790] - nx: 1
[16:19:36.790] - relay: TRUE
[16:19:36.791] - stdout: TRUE
[16:19:36.791] - signal: TRUE
[16:19:36.791] - resignal: FALSE
[16:19:36.791] - force: TRUE
[16:19:36.791] - relayed: [n=1] FALSE
[16:19:36.791] - queued futures: [n=1] FALSE
[16:19:36.791]  - until=1
[16:19:36.791]  - relaying element #1
[16:19:36.791] - relayed: [n=1] TRUE
[16:19:36.791] - queued futures: [n=1] TRUE
[16:19:36.792] signalConditionsASAP(SequentialFuture, pos=1) ... done
[16:19:36.792]  length: 0 (resolved future 1)
[16:19:36.792] Relaying remaining futures
[16:19:36.792] signalConditionsASAP(NULL, pos=0) ...
[16:19:36.792] - nx: 1
[16:19:36.792] - relay: TRUE
[16:19:36.792] - stdout: TRUE
[16:19:36.792] - signal: TRUE
[16:19:36.792] - resignal: FALSE
[16:19:36.792] - force: TRUE
[16:19:36.792] - relayed: [n=1] TRUE
[16:19:36.793] - queued futures: [n=1] TRUE
 - flush all
[16:19:36.793] - relayed: [n=1] TRUE
[16:19:36.793] - queued futures: [n=1] TRUE
[16:19:36.793] signalConditionsASAP(NULL, pos=0) ... done
[16:19:36.793] resolve() on list ... DONE
[16:19:36.793]  - Number of value chunks collected: 1
[16:19:36.793] Resolving 1 futures (chunks) ... DONE
[16:19:36.793] Reducing values from 1 chunks ...
[16:19:36.793]  - Number of values collected after concatenation: 2
[16:19:36.793]  - Number of values expected: 2
[16:19:36.794] Reducing values from 1 chunks ... DONE
[16:19:36.794] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 1 cores ... DONE
  - Testing with 2 cores ...
* plan('multicore') ...
[16:19:36.797] plan(): Setting new future strategy stack:
[16:19:36.797] List of future strategies:
[16:19:36.797] 1. multicore:
[16:19:36.797]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:36.797]    - tweaked: FALSE
[16:19:36.797]    - call: plan(strategy)
[16:19:36.801] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:19:36.801] future_lapply() ...
[16:19:36.809] Number of chunks: 2
[16:19:36.809] getGlobalsAndPackagesXApply() ...
[16:19:36.810]  - future.globals: TRUE
[16:19:36.810] getGlobalsAndPackages() ...
[16:19:36.810] Searching for globals...
[16:19:36.811] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:36.811] Searching for globals ... DONE
[16:19:36.811] Resolving globals: FALSE
[16:19:36.812] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:36.812] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:36.812] - globals: [1] ‘FUN’
[16:19:36.812] 
[16:19:36.813] getGlobalsAndPackages() ... DONE
[16:19:36.813]  - globals found/used: [n=1] ‘FUN’
[16:19:36.813]  - needed namespaces: [n=0] 
[16:19:36.813] Finding globals ... DONE
[16:19:36.813]  - use_args: TRUE
[16:19:36.813]  - Getting '...' globals ...
[16:19:36.813] resolve() on list ...
[16:19:36.813]  recursive: 0
[16:19:36.814]  length: 1
[16:19:36.814]  elements: ‘...’
[16:19:36.814]  length: 0 (resolved future 1)
[16:19:36.814] resolve() on list ... DONE
[16:19:36.814]    - '...' content: [n=0] 
[16:19:36.814] List of 1
[16:19:36.814]  $ ...: list()
[16:19:36.814]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:36.814]  - attr(*, "where")=List of 1
[16:19:36.814]   ..$ ...:<environment: 0x563562f86a70> 
[16:19:36.814]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:36.814]  - attr(*, "resolved")= logi TRUE
[16:19:36.814]  - attr(*, "total_size")= num NA
[16:19:36.817]  - Getting '...' globals ... DONE
[16:19:36.817] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:36.817] List of 2
[16:19:36.817]  $ ...future.FUN:function (x)  
[16:19:36.817]  $ ...          : list()
[16:19:36.817]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:36.817]  - attr(*, "where")=List of 2
[16:19:36.817]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:36.817]   ..$ ...          :<environment: 0x563562f86a70> 
[16:19:36.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:36.817]  - attr(*, "resolved")= logi FALSE
[16:19:36.817]  - attr(*, "total_size")= num 4720
[16:19:36.819] Packages to be attached in all futures: [n=0] 
[16:19:36.819] getGlobalsAndPackagesXApply() ... DONE
[16:19:36.820] Number of futures (= number of chunks): 2
[16:19:36.820] Launching 2 futures (chunks) ...
[16:19:36.820] Chunk #1 of 2 ...
[16:19:36.820]  - Finding globals in 'X' for chunk #1 ...
[16:19:36.820] getGlobalsAndPackages() ...
[16:19:36.820] Searching for globals...
[16:19:36.820] 
[16:19:36.821] Searching for globals ... DONE
[16:19:36.821] - globals: [0] <none>
[16:19:36.821] getGlobalsAndPackages() ... DONE
[16:19:36.821]    + additional globals found: [n=0] 
[16:19:36.821]    + additional namespaces needed: [n=0] 
[16:19:36.821]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:36.821]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:36.821]  - seeds: <none>
[16:19:36.821]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:36.821] getGlobalsAndPackages() ...
[16:19:36.821] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:36.822] Resolving globals: FALSE
[16:19:36.822] Tweak future expression to call with '...' arguments ...
[16:19:36.822] {
[16:19:36.822]     do.call(function(...) {
[16:19:36.822]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:36.822]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:36.822]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:36.822]             on.exit(options(oopts), add = TRUE)
[16:19:36.822]         }
[16:19:36.822]         {
[16:19:36.822]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:36.822]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:36.822]                 ...future.FUN(...future.X_jj, ...)
[16:19:36.822]             })
[16:19:36.822]         }
[16:19:36.822]     }, args = future.call.arguments)
[16:19:36.822] }
[16:19:36.822] Tweak future expression to call with '...' arguments ... DONE
[16:19:36.822] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:36.822] 
[16:19:36.823] getGlobalsAndPackages() ... DONE
[16:19:36.823] run() for ‘Future’ ...
[16:19:36.823] - state: ‘created’
[16:19:36.823] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:36.827] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:36.827] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:36.827]   - Field: ‘label’
[16:19:36.827]   - Field: ‘local’
[16:19:36.827]   - Field: ‘owner’
[16:19:36.827]   - Field: ‘envir’
[16:19:36.827]   - Field: ‘workers’
[16:19:36.827]   - Field: ‘packages’
[16:19:36.827]   - Field: ‘gc’
[16:19:36.828]   - Field: ‘job’
[16:19:36.828]   - Field: ‘conditions’
[16:19:36.828]   - Field: ‘expr’
[16:19:36.828]   - Field: ‘uuid’
[16:19:36.828]   - Field: ‘seed’
[16:19:36.828]   - Field: ‘version’
[16:19:36.828]   - Field: ‘result’
[16:19:36.828]   - Field: ‘asynchronous’
[16:19:36.828]   - Field: ‘calls’
[16:19:36.828]   - Field: ‘globals’
[16:19:36.828]   - Field: ‘stdout’
[16:19:36.829]   - Field: ‘earlySignal’
[16:19:36.829]   - Field: ‘lazy’
[16:19:36.829]   - Field: ‘state’
[16:19:36.829] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:36.829] - Launch lazy future ...
[16:19:36.830] Packages needed by the future expression (n = 0): <none>
[16:19:36.830] Packages needed by future strategies (n = 0): <none>
[16:19:36.831] {
[16:19:36.831]     {
[16:19:36.831]         {
[16:19:36.831]             ...future.startTime <- base::Sys.time()
[16:19:36.831]             {
[16:19:36.831]                 {
[16:19:36.831]                   {
[16:19:36.831]                     {
[16:19:36.831]                       base::local({
[16:19:36.831]                         has_future <- base::requireNamespace("future", 
[16:19:36.831]                           quietly = TRUE)
[16:19:36.831]                         if (has_future) {
[16:19:36.831]                           ns <- base::getNamespace("future")
[16:19:36.831]                           version <- ns[[".package"]][["version"]]
[16:19:36.831]                           if (is.null(version)) 
[16:19:36.831]                             version <- utils::packageVersion("future")
[16:19:36.831]                         }
[16:19:36.831]                         else {
[16:19:36.831]                           version <- NULL
[16:19:36.831]                         }
[16:19:36.831]                         if (!has_future || version < "1.8.0") {
[16:19:36.831]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:36.831]                             "", base::R.version$version.string), 
[16:19:36.831]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:36.831]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:36.831]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:36.831]                               "release", "version")], collapse = " "), 
[16:19:36.831]                             hostname = base::Sys.info()[["nodename"]])
[16:19:36.831]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:36.831]                             info)
[16:19:36.831]                           info <- base::paste(info, collapse = "; ")
[16:19:36.831]                           if (!has_future) {
[16:19:36.831]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:36.831]                               info)
[16:19:36.831]                           }
[16:19:36.831]                           else {
[16:19:36.831]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:36.831]                               info, version)
[16:19:36.831]                           }
[16:19:36.831]                           base::stop(msg)
[16:19:36.831]                         }
[16:19:36.831]                       })
[16:19:36.831]                     }
[16:19:36.831]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:36.831]                     base::options(mc.cores = 1L)
[16:19:36.831]                   }
[16:19:36.831]                   ...future.strategy.old <- future::plan("list")
[16:19:36.831]                   options(future.plan = NULL)
[16:19:36.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:36.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:36.831]                 }
[16:19:36.831]                 ...future.workdir <- getwd()
[16:19:36.831]             }
[16:19:36.831]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:36.831]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:36.831]         }
[16:19:36.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:36.831]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:36.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:36.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:36.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:36.831]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:36.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:36.831]             base::names(...future.oldOptions))
[16:19:36.831]     }
[16:19:36.831]     if (FALSE) {
[16:19:36.831]     }
[16:19:36.831]     else {
[16:19:36.831]         if (FALSE) {
[16:19:36.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:36.831]                 open = "w")
[16:19:36.831]         }
[16:19:36.831]         else {
[16:19:36.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:36.831]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:36.831]         }
[16:19:36.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:36.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:36.831]             base::sink(type = "output", split = FALSE)
[16:19:36.831]             base::close(...future.stdout)
[16:19:36.831]         }, add = TRUE)
[16:19:36.831]     }
[16:19:36.831]     ...future.frame <- base::sys.nframe()
[16:19:36.831]     ...future.conditions <- base::list()
[16:19:36.831]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:36.831]     if (FALSE) {
[16:19:36.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:36.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:36.831]     }
[16:19:36.831]     ...future.result <- base::tryCatch({
[16:19:36.831]         base::withCallingHandlers({
[16:19:36.831]             ...future.value <- base::withVisible(base::local({
[16:19:36.831]                 withCallingHandlers({
[16:19:36.831]                   {
[16:19:36.831]                     do.call(function(...) {
[16:19:36.831]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:36.831]                       if (!identical(...future.globals.maxSize.org, 
[16:19:36.831]                         ...future.globals.maxSize)) {
[16:19:36.831]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:36.831]                         on.exit(options(oopts), add = TRUE)
[16:19:36.831]                       }
[16:19:36.831]                       {
[16:19:36.831]                         lapply(seq_along(...future.elements_ii), 
[16:19:36.831]                           FUN = function(jj) {
[16:19:36.831]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:36.831]                             ...future.FUN(...future.X_jj, ...)
[16:19:36.831]                           })
[16:19:36.831]                       }
[16:19:36.831]                     }, args = future.call.arguments)
[16:19:36.831]                   }
[16:19:36.831]                 }, immediateCondition = function(cond) {
[16:19:36.831]                   save_rds <- function (object, pathname, ...) 
[16:19:36.831]                   {
[16:19:36.831]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:36.831]                     if (file_test("-f", pathname_tmp)) {
[16:19:36.831]                       fi_tmp <- file.info(pathname_tmp)
[16:19:36.831]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:36.831]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:36.831]                         fi_tmp[["mtime"]])
[16:19:36.831]                     }
[16:19:36.831]                     tryCatch({
[16:19:36.831]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:36.831]                     }, error = function(ex) {
[16:19:36.831]                       msg <- conditionMessage(ex)
[16:19:36.831]                       fi_tmp <- file.info(pathname_tmp)
[16:19:36.831]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:36.831]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:36.831]                         fi_tmp[["mtime"]], msg)
[16:19:36.831]                       ex$message <- msg
[16:19:36.831]                       stop(ex)
[16:19:36.831]                     })
[16:19:36.831]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:36.831]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:36.831]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:36.831]                       fi_tmp <- file.info(pathname_tmp)
[16:19:36.831]                       fi <- file.info(pathname)
[16:19:36.831]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:36.831]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:36.831]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:36.831]                         fi[["size"]], fi[["mtime"]])
[16:19:36.831]                       stop(msg)
[16:19:36.831]                     }
[16:19:36.831]                     invisible(pathname)
[16:19:36.831]                   }
[16:19:36.831]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:36.831]                     rootPath = tempdir()) 
[16:19:36.831]                   {
[16:19:36.831]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:36.831]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:36.831]                       tmpdir = path, fileext = ".rds")
[16:19:36.831]                     save_rds(obj, file)
[16:19:36.831]                   }
[16:19:36.831]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPcako/.future/immediateConditions")
[16:19:36.831]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:36.831]                   {
[16:19:36.831]                     inherits <- base::inherits
[16:19:36.831]                     invokeRestart <- base::invokeRestart
[16:19:36.831]                     is.null <- base::is.null
[16:19:36.831]                     muffled <- FALSE
[16:19:36.831]                     if (inherits(cond, "message")) {
[16:19:36.831]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:36.831]                       if (muffled) 
[16:19:36.831]                         invokeRestart("muffleMessage")
[16:19:36.831]                     }
[16:19:36.831]                     else if (inherits(cond, "warning")) {
[16:19:36.831]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:36.831]                       if (muffled) 
[16:19:36.831]                         invokeRestart("muffleWarning")
[16:19:36.831]                     }
[16:19:36.831]                     else if (inherits(cond, "condition")) {
[16:19:36.831]                       if (!is.null(pattern)) {
[16:19:36.831]                         computeRestarts <- base::computeRestarts
[16:19:36.831]                         grepl <- base::grepl
[16:19:36.831]                         restarts <- computeRestarts(cond)
[16:19:36.831]                         for (restart in restarts) {
[16:19:36.831]                           name <- restart$name
[16:19:36.831]                           if (is.null(name)) 
[16:19:36.831]                             next
[16:19:36.831]                           if (!grepl(pattern, name)) 
[16:19:36.831]                             next
[16:19:36.831]                           invokeRestart(restart)
[16:19:36.831]                           muffled <- TRUE
[16:19:36.831]                           break
[16:19:36.831]                         }
[16:19:36.831]                       }
[16:19:36.831]                     }
[16:19:36.831]                     invisible(muffled)
[16:19:36.831]                   }
[16:19:36.831]                   muffleCondition(cond)
[16:19:36.831]                 })
[16:19:36.831]             }))
[16:19:36.831]             future::FutureResult(value = ...future.value$value, 
[16:19:36.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:36.831]                   ...future.rng), globalenv = if (FALSE) 
[16:19:36.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:36.831]                     ...future.globalenv.names))
[16:19:36.831]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:36.831]         }, condition = base::local({
[16:19:36.831]             c <- base::c
[16:19:36.831]             inherits <- base::inherits
[16:19:36.831]             invokeRestart <- base::invokeRestart
[16:19:36.831]             length <- base::length
[16:19:36.831]             list <- base::list
[16:19:36.831]             seq.int <- base::seq.int
[16:19:36.831]             signalCondition <- base::signalCondition
[16:19:36.831]             sys.calls <- base::sys.calls
[16:19:36.831]             `[[` <- base::`[[`
[16:19:36.831]             `+` <- base::`+`
[16:19:36.831]             `<<-` <- base::`<<-`
[16:19:36.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:36.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:36.831]                   3L)]
[16:19:36.831]             }
[16:19:36.831]             function(cond) {
[16:19:36.831]                 is_error <- inherits(cond, "error")
[16:19:36.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:36.831]                   NULL)
[16:19:36.831]                 if (is_error) {
[16:19:36.831]                   sessionInformation <- function() {
[16:19:36.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:36.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:36.831]                       search = base::search(), system = base::Sys.info())
[16:19:36.831]                   }
[16:19:36.831]                   ...future.conditions[[length(...future.conditions) + 
[16:19:36.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:36.831]                     cond$call), session = sessionInformation(), 
[16:19:36.831]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:36.831]                   signalCondition(cond)
[16:19:36.831]                 }
[16:19:36.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:36.831]                 "immediateCondition"))) {
[16:19:36.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:36.831]                   ...future.conditions[[length(...future.conditions) + 
[16:19:36.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:36.831]                   if (TRUE && !signal) {
[16:19:36.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:36.831]                     {
[16:19:36.831]                       inherits <- base::inherits
[16:19:36.831]                       invokeRestart <- base::invokeRestart
[16:19:36.831]                       is.null <- base::is.null
[16:19:36.831]                       muffled <- FALSE
[16:19:36.831]                       if (inherits(cond, "message")) {
[16:19:36.831]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:36.831]                         if (muffled) 
[16:19:36.831]                           invokeRestart("muffleMessage")
[16:19:36.831]                       }
[16:19:36.831]                       else if (inherits(cond, "warning")) {
[16:19:36.831]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:36.831]                         if (muffled) 
[16:19:36.831]                           invokeRestart("muffleWarning")
[16:19:36.831]                       }
[16:19:36.831]                       else if (inherits(cond, "condition")) {
[16:19:36.831]                         if (!is.null(pattern)) {
[16:19:36.831]                           computeRestarts <- base::computeRestarts
[16:19:36.831]                           grepl <- base::grepl
[16:19:36.831]                           restarts <- computeRestarts(cond)
[16:19:36.831]                           for (restart in restarts) {
[16:19:36.831]                             name <- restart$name
[16:19:36.831]                             if (is.null(name)) 
[16:19:36.831]                               next
[16:19:36.831]                             if (!grepl(pattern, name)) 
[16:19:36.831]                               next
[16:19:36.831]                             invokeRestart(restart)
[16:19:36.831]                             muffled <- TRUE
[16:19:36.831]                             break
[16:19:36.831]                           }
[16:19:36.831]                         }
[16:19:36.831]                       }
[16:19:36.831]                       invisible(muffled)
[16:19:36.831]                     }
[16:19:36.831]                     muffleCondition(cond, pattern = "^muffle")
[16:19:36.831]                   }
[16:19:36.831]                 }
[16:19:36.831]                 else {
[16:19:36.831]                   if (TRUE) {
[16:19:36.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:36.831]                     {
[16:19:36.831]                       inherits <- base::inherits
[16:19:36.831]                       invokeRestart <- base::invokeRestart
[16:19:36.831]                       is.null <- base::is.null
[16:19:36.831]                       muffled <- FALSE
[16:19:36.831]                       if (inherits(cond, "message")) {
[16:19:36.831]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:36.831]                         if (muffled) 
[16:19:36.831]                           invokeRestart("muffleMessage")
[16:19:36.831]                       }
[16:19:36.831]                       else if (inherits(cond, "warning")) {
[16:19:36.831]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:36.831]                         if (muffled) 
[16:19:36.831]                           invokeRestart("muffleWarning")
[16:19:36.831]                       }
[16:19:36.831]                       else if (inherits(cond, "condition")) {
[16:19:36.831]                         if (!is.null(pattern)) {
[16:19:36.831]                           computeRestarts <- base::computeRestarts
[16:19:36.831]                           grepl <- base::grepl
[16:19:36.831]                           restarts <- computeRestarts(cond)
[16:19:36.831]                           for (restart in restarts) {
[16:19:36.831]                             name <- restart$name
[16:19:36.831]                             if (is.null(name)) 
[16:19:36.831]                               next
[16:19:36.831]                             if (!grepl(pattern, name)) 
[16:19:36.831]                               next
[16:19:36.831]                             invokeRestart(restart)
[16:19:36.831]                             muffled <- TRUE
[16:19:36.831]                             break
[16:19:36.831]                           }
[16:19:36.831]                         }
[16:19:36.831]                       }
[16:19:36.831]                       invisible(muffled)
[16:19:36.831]                     }
[16:19:36.831]                     muffleCondition(cond, pattern = "^muffle")
[16:19:36.831]                   }
[16:19:36.831]                 }
[16:19:36.831]             }
[16:19:36.831]         }))
[16:19:36.831]     }, error = function(ex) {
[16:19:36.831]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:36.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:36.831]                 ...future.rng), started = ...future.startTime, 
[16:19:36.831]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:36.831]             version = "1.8"), class = "FutureResult")
[16:19:36.831]     }, finally = {
[16:19:36.831]         if (!identical(...future.workdir, getwd())) 
[16:19:36.831]             setwd(...future.workdir)
[16:19:36.831]         {
[16:19:36.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:36.831]                 ...future.oldOptions$nwarnings <- NULL
[16:19:36.831]             }
[16:19:36.831]             base::options(...future.oldOptions)
[16:19:36.831]             if (.Platform$OS.type == "windows") {
[16:19:36.831]                 old_names <- names(...future.oldEnvVars)
[16:19:36.831]                 envs <- base::Sys.getenv()
[16:19:36.831]                 names <- names(envs)
[16:19:36.831]                 common <- intersect(names, old_names)
[16:19:36.831]                 added <- setdiff(names, old_names)
[16:19:36.831]                 removed <- setdiff(old_names, names)
[16:19:36.831]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:36.831]                   envs[common]]
[16:19:36.831]                 NAMES <- toupper(changed)
[16:19:36.831]                 args <- list()
[16:19:36.831]                 for (kk in seq_along(NAMES)) {
[16:19:36.831]                   name <- changed[[kk]]
[16:19:36.831]                   NAME <- NAMES[[kk]]
[16:19:36.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:36.831]                     next
[16:19:36.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:36.831]                 }
[16:19:36.831]                 NAMES <- toupper(added)
[16:19:36.831]                 for (kk in seq_along(NAMES)) {
[16:19:36.831]                   name <- added[[kk]]
[16:19:36.831]                   NAME <- NAMES[[kk]]
[16:19:36.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:36.831]                     next
[16:19:36.831]                   args[[name]] <- ""
[16:19:36.831]                 }
[16:19:36.831]                 NAMES <- toupper(removed)
[16:19:36.831]                 for (kk in seq_along(NAMES)) {
[16:19:36.831]                   name <- removed[[kk]]
[16:19:36.831]                   NAME <- NAMES[[kk]]
[16:19:36.831]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:36.831]                     next
[16:19:36.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:36.831]                 }
[16:19:36.831]                 if (length(args) > 0) 
[16:19:36.831]                   base::do.call(base::Sys.setenv, args = args)
[16:19:36.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:36.831]             }
[16:19:36.831]             else {
[16:19:36.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:36.831]             }
[16:19:36.831]             {
[16:19:36.831]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:36.831]                   0L) {
[16:19:36.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:36.831]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:36.831]                   base::options(opts)
[16:19:36.831]                 }
[16:19:36.831]                 {
[16:19:36.831]                   {
[16:19:36.831]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:36.831]                     NULL
[16:19:36.831]                   }
[16:19:36.831]                   options(future.plan = NULL)
[16:19:36.831]                   if (is.na(NA_character_)) 
[16:19:36.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:36.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:36.831]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:36.831]                     .init = FALSE)
[16:19:36.831]                 }
[16:19:36.831]             }
[16:19:36.831]         }
[16:19:36.831]     })
[16:19:36.831]     if (TRUE) {
[16:19:36.831]         base::sink(type = "output", split = FALSE)
[16:19:36.831]         if (FALSE) {
[16:19:36.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:36.831]         }
[16:19:36.831]         else {
[16:19:36.831]             ...future.result["stdout"] <- base::list(NULL)
[16:19:36.831]         }
[16:19:36.831]         base::close(...future.stdout)
[16:19:36.831]         ...future.stdout <- NULL
[16:19:36.831]     }
[16:19:36.831]     ...future.result$conditions <- ...future.conditions
[16:19:36.831]     ...future.result$finished <- base::Sys.time()
[16:19:36.831]     ...future.result
[16:19:36.831] }
[16:19:36.833] assign_globals() ...
[16:19:36.833] List of 5
[16:19:36.833]  $ ...future.FUN            :function (x)  
[16:19:36.833]  $ future.call.arguments    : list()
[16:19:36.833]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:36.833]  $ ...future.elements_ii    :List of 1
[16:19:36.833]   ..$ : int 1
[16:19:36.833]  $ ...future.seeds_ii       : NULL
[16:19:36.833]  $ ...future.globals.maxSize: NULL
[16:19:36.833]  - attr(*, "where")=List of 5
[16:19:36.833]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:36.833]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:36.833]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:36.833]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:36.833]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:36.833]  - attr(*, "resolved")= logi FALSE
[16:19:36.833]  - attr(*, "total_size")= num 4720
[16:19:36.833]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:36.833]  - attr(*, "already-done")= logi TRUE
[16:19:36.840] - reassign environment for ‘...future.FUN’
[16:19:36.840] - copied ‘...future.FUN’ to environment
[16:19:36.840] - copied ‘future.call.arguments’ to environment
[16:19:36.840] - copied ‘...future.elements_ii’ to environment
[16:19:36.840] - copied ‘...future.seeds_ii’ to environment
[16:19:36.840] - copied ‘...future.globals.maxSize’ to environment
[16:19:36.840] assign_globals() ... done
[16:19:36.840] requestCore(): workers = 2
[16:19:36.844] MulticoreFuture started
[16:19:36.844] - Launch lazy future ... done
[16:19:36.844] plan(): Setting new future strategy stack:
[16:19:36.845] run() for ‘MulticoreFuture’ ... done
[16:19:36.845] Created future:
[16:19:36.845] List of future strategies:
[16:19:36.845] 1. sequential:
[16:19:36.845]    - args: function (..., envir = parent.frame())
[16:19:36.845]    - tweaked: FALSE
[16:19:36.845]    - call: NULL
[16:19:36.846] plan(): nbrOfWorkers() = 1
[16:19:36.845] MulticoreFuture:
[16:19:36.845] Label: ‘future_lapply-1’
[16:19:36.845] Expression:
[16:19:36.845] {
[16:19:36.845]     do.call(function(...) {
[16:19:36.845]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:36.845]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:36.845]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:36.845]             on.exit(options(oopts), add = TRUE)
[16:19:36.845]         }
[16:19:36.845]         {
[16:19:36.845]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:36.845]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:36.845]                 ...future.FUN(...future.X_jj, ...)
[16:19:36.845]             })
[16:19:36.845]         }
[16:19:36.845]     }, args = future.call.arguments)
[16:19:36.845] }
[16:19:36.845] Lazy evaluation: FALSE
[16:19:36.845] Asynchronous evaluation: TRUE
[16:19:36.845] Local evaluation: TRUE
[16:19:36.845] Environment: R_GlobalEnv
[16:19:36.845] Capture standard output: FALSE
[16:19:36.845] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:36.845] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:36.845] Packages: <none>
[16:19:36.845] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:36.845] Resolved: FALSE
[16:19:36.845] Value: <not collected>
[16:19:36.845] Conditions captured: <none>
[16:19:36.845] Early signaling: FALSE
[16:19:36.845] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:36.845] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:36.861] Chunk #1 of 2 ... DONE
[16:19:36.861] Chunk #2 of 2 ...
[16:19:36.861]  - Finding globals in 'X' for chunk #2 ...
[16:19:36.861] getGlobalsAndPackages() ...
[16:19:36.862] Searching for globals...
[16:19:36.862] 
[16:19:36.862] Searching for globals ... DONE
[16:19:36.862] - globals: [0] <none>
[16:19:36.863] getGlobalsAndPackages() ... DONE
[16:19:36.863]    + additional globals found: [n=0] 
[16:19:36.863]    + additional namespaces needed: [n=0] 
[16:19:36.863]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:36.863]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:36.863]  - seeds: <none>
[16:19:36.863]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:36.864] getGlobalsAndPackages() ...
[16:19:36.864] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:36.864] Resolving globals: FALSE
[16:19:36.864] Tweak future expression to call with '...' arguments ...
[16:19:36.864] {
[16:19:36.864]     do.call(function(...) {
[16:19:36.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:36.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:36.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:36.864]             on.exit(options(oopts), add = TRUE)
[16:19:36.864]         }
[16:19:36.864]         {
[16:19:36.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:36.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:36.864]                 ...future.FUN(...future.X_jj, ...)
[16:19:36.864]             })
[16:19:36.864]         }
[16:19:36.864]     }, args = future.call.arguments)
[16:19:36.864] }
[16:19:36.865] Tweak future expression to call with '...' arguments ... DONE
[16:19:36.865] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:36.866] 
[16:19:36.866] getGlobalsAndPackages() ... DONE
[16:19:36.866] run() for ‘Future’ ...
[16:19:36.866] - state: ‘created’
[16:19:36.867] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:36.871] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:36.872] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:36.872]   - Field: ‘label’
[16:19:36.872]   - Field: ‘local’
[16:19:36.872]   - Field: ‘owner’
[16:19:36.872]   - Field: ‘envir’
[16:19:36.872]   - Field: ‘workers’
[16:19:36.872]   - Field: ‘packages’
[16:19:36.873]   - Field: ‘gc’
[16:19:36.873]   - Field: ‘job’
[16:19:36.873]   - Field: ‘conditions’
[16:19:36.873]   - Field: ‘expr’
[16:19:36.873]   - Field: ‘uuid’
[16:19:36.873]   - Field: ‘seed’
[16:19:36.874]   - Field: ‘version’
[16:19:36.874]   - Field: ‘result’
[16:19:36.874]   - Field: ‘asynchronous’
[16:19:36.874]   - Field: ‘calls’
[16:19:36.874]   - Field: ‘globals’
[16:19:36.874]   - Field: ‘stdout’
[16:19:36.874]   - Field: ‘earlySignal’
[16:19:36.874]   - Field: ‘lazy’
[16:19:36.875]   - Field: ‘state’
[16:19:36.875] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:36.875] - Launch lazy future ...
[16:19:36.875] Packages needed by the future expression (n = 0): <none>
[16:19:36.875] Packages needed by future strategies (n = 0): <none>
[16:19:36.876] {
[16:19:36.876]     {
[16:19:36.876]         {
[16:19:36.876]             ...future.startTime <- base::Sys.time()
[16:19:36.876]             {
[16:19:36.876]                 {
[16:19:36.876]                   {
[16:19:36.876]                     {
[16:19:36.876]                       base::local({
[16:19:36.876]                         has_future <- base::requireNamespace("future", 
[16:19:36.876]                           quietly = TRUE)
[16:19:36.876]                         if (has_future) {
[16:19:36.876]                           ns <- base::getNamespace("future")
[16:19:36.876]                           version <- ns[[".package"]][["version"]]
[16:19:36.876]                           if (is.null(version)) 
[16:19:36.876]                             version <- utils::packageVersion("future")
[16:19:36.876]                         }
[16:19:36.876]                         else {
[16:19:36.876]                           version <- NULL
[16:19:36.876]                         }
[16:19:36.876]                         if (!has_future || version < "1.8.0") {
[16:19:36.876]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:36.876]                             "", base::R.version$version.string), 
[16:19:36.876]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:36.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:36.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:36.876]                               "release", "version")], collapse = " "), 
[16:19:36.876]                             hostname = base::Sys.info()[["nodename"]])
[16:19:36.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:36.876]                             info)
[16:19:36.876]                           info <- base::paste(info, collapse = "; ")
[16:19:36.876]                           if (!has_future) {
[16:19:36.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:36.876]                               info)
[16:19:36.876]                           }
[16:19:36.876]                           else {
[16:19:36.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:36.876]                               info, version)
[16:19:36.876]                           }
[16:19:36.876]                           base::stop(msg)
[16:19:36.876]                         }
[16:19:36.876]                       })
[16:19:36.876]                     }
[16:19:36.876]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:36.876]                     base::options(mc.cores = 1L)
[16:19:36.876]                   }
[16:19:36.876]                   ...future.strategy.old <- future::plan("list")
[16:19:36.876]                   options(future.plan = NULL)
[16:19:36.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:36.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:36.876]                 }
[16:19:36.876]                 ...future.workdir <- getwd()
[16:19:36.876]             }
[16:19:36.876]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:36.876]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:36.876]         }
[16:19:36.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:36.876]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:36.876]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:36.876]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:36.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:36.876]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:36.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:36.876]             base::names(...future.oldOptions))
[16:19:36.876]     }
[16:19:36.876]     if (FALSE) {
[16:19:36.876]     }
[16:19:36.876]     else {
[16:19:36.876]         if (FALSE) {
[16:19:36.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:36.876]                 open = "w")
[16:19:36.876]         }
[16:19:36.876]         else {
[16:19:36.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:36.876]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:36.876]         }
[16:19:36.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:36.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:36.876]             base::sink(type = "output", split = FALSE)
[16:19:36.876]             base::close(...future.stdout)
[16:19:36.876]         }, add = TRUE)
[16:19:36.876]     }
[16:19:36.876]     ...future.frame <- base::sys.nframe()
[16:19:36.876]     ...future.conditions <- base::list()
[16:19:36.876]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:36.876]     if (FALSE) {
[16:19:36.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:36.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:36.876]     }
[16:19:36.876]     ...future.result <- base::tryCatch({
[16:19:36.876]         base::withCallingHandlers({
[16:19:36.876]             ...future.value <- base::withVisible(base::local({
[16:19:36.876]                 withCallingHandlers({
[16:19:36.876]                   {
[16:19:36.876]                     do.call(function(...) {
[16:19:36.876]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:36.876]                       if (!identical(...future.globals.maxSize.org, 
[16:19:36.876]                         ...future.globals.maxSize)) {
[16:19:36.876]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:36.876]                         on.exit(options(oopts), add = TRUE)
[16:19:36.876]                       }
[16:19:36.876]                       {
[16:19:36.876]                         lapply(seq_along(...future.elements_ii), 
[16:19:36.876]                           FUN = function(jj) {
[16:19:36.876]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:36.876]                             ...future.FUN(...future.X_jj, ...)
[16:19:36.876]                           })
[16:19:36.876]                       }
[16:19:36.876]                     }, args = future.call.arguments)
[16:19:36.876]                   }
[16:19:36.876]                 }, immediateCondition = function(cond) {
[16:19:36.876]                   save_rds <- function (object, pathname, ...) 
[16:19:36.876]                   {
[16:19:36.876]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:36.876]                     if (file_test("-f", pathname_tmp)) {
[16:19:36.876]                       fi_tmp <- file.info(pathname_tmp)
[16:19:36.876]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:36.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:36.876]                         fi_tmp[["mtime"]])
[16:19:36.876]                     }
[16:19:36.876]                     tryCatch({
[16:19:36.876]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:36.876]                     }, error = function(ex) {
[16:19:36.876]                       msg <- conditionMessage(ex)
[16:19:36.876]                       fi_tmp <- file.info(pathname_tmp)
[16:19:36.876]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:36.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:36.876]                         fi_tmp[["mtime"]], msg)
[16:19:36.876]                       ex$message <- msg
[16:19:36.876]                       stop(ex)
[16:19:36.876]                     })
[16:19:36.876]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:36.876]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:36.876]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:36.876]                       fi_tmp <- file.info(pathname_tmp)
[16:19:36.876]                       fi <- file.info(pathname)
[16:19:36.876]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:36.876]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:36.876]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:36.876]                         fi[["size"]], fi[["mtime"]])
[16:19:36.876]                       stop(msg)
[16:19:36.876]                     }
[16:19:36.876]                     invisible(pathname)
[16:19:36.876]                   }
[16:19:36.876]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:36.876]                     rootPath = tempdir()) 
[16:19:36.876]                   {
[16:19:36.876]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:36.876]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:36.876]                       tmpdir = path, fileext = ".rds")
[16:19:36.876]                     save_rds(obj, file)
[16:19:36.876]                   }
[16:19:36.876]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPcako/.future/immediateConditions")
[16:19:36.876]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:36.876]                   {
[16:19:36.876]                     inherits <- base::inherits
[16:19:36.876]                     invokeRestart <- base::invokeRestart
[16:19:36.876]                     is.null <- base::is.null
[16:19:36.876]                     muffled <- FALSE
[16:19:36.876]                     if (inherits(cond, "message")) {
[16:19:36.876]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:36.876]                       if (muffled) 
[16:19:36.876]                         invokeRestart("muffleMessage")
[16:19:36.876]                     }
[16:19:36.876]                     else if (inherits(cond, "warning")) {
[16:19:36.876]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:36.876]                       if (muffled) 
[16:19:36.876]                         invokeRestart("muffleWarning")
[16:19:36.876]                     }
[16:19:36.876]                     else if (inherits(cond, "condition")) {
[16:19:36.876]                       if (!is.null(pattern)) {
[16:19:36.876]                         computeRestarts <- base::computeRestarts
[16:19:36.876]                         grepl <- base::grepl
[16:19:36.876]                         restarts <- computeRestarts(cond)
[16:19:36.876]                         for (restart in restarts) {
[16:19:36.876]                           name <- restart$name
[16:19:36.876]                           if (is.null(name)) 
[16:19:36.876]                             next
[16:19:36.876]                           if (!grepl(pattern, name)) 
[16:19:36.876]                             next
[16:19:36.876]                           invokeRestart(restart)
[16:19:36.876]                           muffled <- TRUE
[16:19:36.876]                           break
[16:19:36.876]                         }
[16:19:36.876]                       }
[16:19:36.876]                     }
[16:19:36.876]                     invisible(muffled)
[16:19:36.876]                   }
[16:19:36.876]                   muffleCondition(cond)
[16:19:36.876]                 })
[16:19:36.876]             }))
[16:19:36.876]             future::FutureResult(value = ...future.value$value, 
[16:19:36.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:36.876]                   ...future.rng), globalenv = if (FALSE) 
[16:19:36.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:36.876]                     ...future.globalenv.names))
[16:19:36.876]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:36.876]         }, condition = base::local({
[16:19:36.876]             c <- base::c
[16:19:36.876]             inherits <- base::inherits
[16:19:36.876]             invokeRestart <- base::invokeRestart
[16:19:36.876]             length <- base::length
[16:19:36.876]             list <- base::list
[16:19:36.876]             seq.int <- base::seq.int
[16:19:36.876]             signalCondition <- base::signalCondition
[16:19:36.876]             sys.calls <- base::sys.calls
[16:19:36.876]             `[[` <- base::`[[`
[16:19:36.876]             `+` <- base::`+`
[16:19:36.876]             `<<-` <- base::`<<-`
[16:19:36.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:36.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:36.876]                   3L)]
[16:19:36.876]             }
[16:19:36.876]             function(cond) {
[16:19:36.876]                 is_error <- inherits(cond, "error")
[16:19:36.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:36.876]                   NULL)
[16:19:36.876]                 if (is_error) {
[16:19:36.876]                   sessionInformation <- function() {
[16:19:36.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:36.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:36.876]                       search = base::search(), system = base::Sys.info())
[16:19:36.876]                   }
[16:19:36.876]                   ...future.conditions[[length(...future.conditions) + 
[16:19:36.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:36.876]                     cond$call), session = sessionInformation(), 
[16:19:36.876]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:36.876]                   signalCondition(cond)
[16:19:36.876]                 }
[16:19:36.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:36.876]                 "immediateCondition"))) {
[16:19:36.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:36.876]                   ...future.conditions[[length(...future.conditions) + 
[16:19:36.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:36.876]                   if (TRUE && !signal) {
[16:19:36.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:36.876]                     {
[16:19:36.876]                       inherits <- base::inherits
[16:19:36.876]                       invokeRestart <- base::invokeRestart
[16:19:36.876]                       is.null <- base::is.null
[16:19:36.876]                       muffled <- FALSE
[16:19:36.876]                       if (inherits(cond, "message")) {
[16:19:36.876]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:36.876]                         if (muffled) 
[16:19:36.876]                           invokeRestart("muffleMessage")
[16:19:36.876]                       }
[16:19:36.876]                       else if (inherits(cond, "warning")) {
[16:19:36.876]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:36.876]                         if (muffled) 
[16:19:36.876]                           invokeRestart("muffleWarning")
[16:19:36.876]                       }
[16:19:36.876]                       else if (inherits(cond, "condition")) {
[16:19:36.876]                         if (!is.null(pattern)) {
[16:19:36.876]                           computeRestarts <- base::computeRestarts
[16:19:36.876]                           grepl <- base::grepl
[16:19:36.876]                           restarts <- computeRestarts(cond)
[16:19:36.876]                           for (restart in restarts) {
[16:19:36.876]                             name <- restart$name
[16:19:36.876]                             if (is.null(name)) 
[16:19:36.876]                               next
[16:19:36.876]                             if (!grepl(pattern, name)) 
[16:19:36.876]                               next
[16:19:36.876]                             invokeRestart(restart)
[16:19:36.876]                             muffled <- TRUE
[16:19:36.876]                             break
[16:19:36.876]                           }
[16:19:36.876]                         }
[16:19:36.876]                       }
[16:19:36.876]                       invisible(muffled)
[16:19:36.876]                     }
[16:19:36.876]                     muffleCondition(cond, pattern = "^muffle")
[16:19:36.876]                   }
[16:19:36.876]                 }
[16:19:36.876]                 else {
[16:19:36.876]                   if (TRUE) {
[16:19:36.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:36.876]                     {
[16:19:36.876]                       inherits <- base::inherits
[16:19:36.876]                       invokeRestart <- base::invokeRestart
[16:19:36.876]                       is.null <- base::is.null
[16:19:36.876]                       muffled <- FALSE
[16:19:36.876]                       if (inherits(cond, "message")) {
[16:19:36.876]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:36.876]                         if (muffled) 
[16:19:36.876]                           invokeRestart("muffleMessage")
[16:19:36.876]                       }
[16:19:36.876]                       else if (inherits(cond, "warning")) {
[16:19:36.876]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:36.876]                         if (muffled) 
[16:19:36.876]                           invokeRestart("muffleWarning")
[16:19:36.876]                       }
[16:19:36.876]                       else if (inherits(cond, "condition")) {
[16:19:36.876]                         if (!is.null(pattern)) {
[16:19:36.876]                           computeRestarts <- base::computeRestarts
[16:19:36.876]                           grepl <- base::grepl
[16:19:36.876]                           restarts <- computeRestarts(cond)
[16:19:36.876]                           for (restart in restarts) {
[16:19:36.876]                             name <- restart$name
[16:19:36.876]                             if (is.null(name)) 
[16:19:36.876]                               next
[16:19:36.876]                             if (!grepl(pattern, name)) 
[16:19:36.876]                               next
[16:19:36.876]                             invokeRestart(restart)
[16:19:36.876]                             muffled <- TRUE
[16:19:36.876]                             break
[16:19:36.876]                           }
[16:19:36.876]                         }
[16:19:36.876]                       }
[16:19:36.876]                       invisible(muffled)
[16:19:36.876]                     }
[16:19:36.876]                     muffleCondition(cond, pattern = "^muffle")
[16:19:36.876]                   }
[16:19:36.876]                 }
[16:19:36.876]             }
[16:19:36.876]         }))
[16:19:36.876]     }, error = function(ex) {
[16:19:36.876]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:36.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:36.876]                 ...future.rng), started = ...future.startTime, 
[16:19:36.876]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:36.876]             version = "1.8"), class = "FutureResult")
[16:19:36.876]     }, finally = {
[16:19:36.876]         if (!identical(...future.workdir, getwd())) 
[16:19:36.876]             setwd(...future.workdir)
[16:19:36.876]         {
[16:19:36.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:36.876]                 ...future.oldOptions$nwarnings <- NULL
[16:19:36.876]             }
[16:19:36.876]             base::options(...future.oldOptions)
[16:19:36.876]             if (.Platform$OS.type == "windows") {
[16:19:36.876]                 old_names <- names(...future.oldEnvVars)
[16:19:36.876]                 envs <- base::Sys.getenv()
[16:19:36.876]                 names <- names(envs)
[16:19:36.876]                 common <- intersect(names, old_names)
[16:19:36.876]                 added <- setdiff(names, old_names)
[16:19:36.876]                 removed <- setdiff(old_names, names)
[16:19:36.876]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:36.876]                   envs[common]]
[16:19:36.876]                 NAMES <- toupper(changed)
[16:19:36.876]                 args <- list()
[16:19:36.876]                 for (kk in seq_along(NAMES)) {
[16:19:36.876]                   name <- changed[[kk]]
[16:19:36.876]                   NAME <- NAMES[[kk]]
[16:19:36.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:36.876]                     next
[16:19:36.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:36.876]                 }
[16:19:36.876]                 NAMES <- toupper(added)
[16:19:36.876]                 for (kk in seq_along(NAMES)) {
[16:19:36.876]                   name <- added[[kk]]
[16:19:36.876]                   NAME <- NAMES[[kk]]
[16:19:36.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:36.876]                     next
[16:19:36.876]                   args[[name]] <- ""
[16:19:36.876]                 }
[16:19:36.876]                 NAMES <- toupper(removed)
[16:19:36.876]                 for (kk in seq_along(NAMES)) {
[16:19:36.876]                   name <- removed[[kk]]
[16:19:36.876]                   NAME <- NAMES[[kk]]
[16:19:36.876]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:36.876]                     next
[16:19:36.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:36.876]                 }
[16:19:36.876]                 if (length(args) > 0) 
[16:19:36.876]                   base::do.call(base::Sys.setenv, args = args)
[16:19:36.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:36.876]             }
[16:19:36.876]             else {
[16:19:36.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:36.876]             }
[16:19:36.876]             {
[16:19:36.876]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:36.876]                   0L) {
[16:19:36.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:36.876]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:36.876]                   base::options(opts)
[16:19:36.876]                 }
[16:19:36.876]                 {
[16:19:36.876]                   {
[16:19:36.876]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:36.876]                     NULL
[16:19:36.876]                   }
[16:19:36.876]                   options(future.plan = NULL)
[16:19:36.876]                   if (is.na(NA_character_)) 
[16:19:36.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:36.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:36.876]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:36.876]                     .init = FALSE)
[16:19:36.876]                 }
[16:19:36.876]             }
[16:19:36.876]         }
[16:19:36.876]     })
[16:19:36.876]     if (TRUE) {
[16:19:36.876]         base::sink(type = "output", split = FALSE)
[16:19:36.876]         if (FALSE) {
[16:19:36.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:36.876]         }
[16:19:36.876]         else {
[16:19:36.876]             ...future.result["stdout"] <- base::list(NULL)
[16:19:36.876]         }
[16:19:36.876]         base::close(...future.stdout)
[16:19:36.876]         ...future.stdout <- NULL
[16:19:36.876]     }
[16:19:36.876]     ...future.result$conditions <- ...future.conditions
[16:19:36.876]     ...future.result$finished <- base::Sys.time()
[16:19:36.876]     ...future.result
[16:19:36.876] }
[16:19:36.879] assign_globals() ...
[16:19:36.880] List of 5
[16:19:36.880]  $ ...future.FUN            :function (x)  
[16:19:36.880]  $ future.call.arguments    : list()
[16:19:36.880]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:36.880]  $ ...future.elements_ii    :List of 1
[16:19:36.880]   ..$ : int 0
[16:19:36.880]  $ ...future.seeds_ii       : NULL
[16:19:36.880]  $ ...future.globals.maxSize: NULL
[16:19:36.880]  - attr(*, "where")=List of 5
[16:19:36.880]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:36.880]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:36.880]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:36.880]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:36.880]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:36.880]  - attr(*, "resolved")= logi FALSE
[16:19:36.880]  - attr(*, "total_size")= num 4720
[16:19:36.880]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:36.880]  - attr(*, "already-done")= logi TRUE
[16:19:36.887] - reassign environment for ‘...future.FUN’
[16:19:36.887] - copied ‘...future.FUN’ to environment
[16:19:36.887] - copied ‘future.call.arguments’ to environment
[16:19:36.887] - copied ‘...future.elements_ii’ to environment
[16:19:36.887] - copied ‘...future.seeds_ii’ to environment
[16:19:36.887] - copied ‘...future.globals.maxSize’ to environment
[16:19:36.888] assign_globals() ... done
[16:19:36.888] requestCore(): workers = 2
[16:19:36.897] MulticoreFuture started
[16:19:36.898] - Launch lazy future ... done
[16:19:36.898] run() for ‘MulticoreFuture’ ... done
[16:19:36.898] plan(): Setting new future strategy stack:
[16:19:36.899] Created future:
[16:19:36.899] List of future strategies:
[16:19:36.899] 1. sequential:
[16:19:36.899]    - args: function (..., envir = parent.frame())
[16:19:36.899]    - tweaked: FALSE
[16:19:36.899]    - call: NULL
[16:19:36.900] plan(): nbrOfWorkers() = 1
[16:19:36.902] plan(): Setting new future strategy stack:
[16:19:36.902] List of future strategies:
[16:19:36.902] 1. multicore:
[16:19:36.902]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:36.902]    - tweaked: FALSE
[16:19:36.902]    - call: plan(strategy)
[16:19:36.908] plan(): nbrOfWorkers() = 2
[16:19:36.899] MulticoreFuture:
[16:19:36.899] Label: ‘future_lapply-2’
[16:19:36.899] Expression:
[16:19:36.899] {
[16:19:36.899]     do.call(function(...) {
[16:19:36.899]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:36.899]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:36.899]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:36.899]             on.exit(options(oopts), add = TRUE)
[16:19:36.899]         }
[16:19:36.899]         {
[16:19:36.899]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:36.899]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:36.899]                 ...future.FUN(...future.X_jj, ...)
[16:19:36.899]             })
[16:19:36.899]         }
[16:19:36.899]     }, args = future.call.arguments)
[16:19:36.899] }
[16:19:36.899] Lazy evaluation: FALSE
[16:19:36.899] Asynchronous evaluation: TRUE
[16:19:36.899] Local evaluation: TRUE
[16:19:36.899] Environment: R_GlobalEnv
[16:19:36.899] Capture standard output: FALSE
[16:19:36.899] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:36.899] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:36.899] Packages: <none>
[16:19:36.899] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:36.899] Resolved: TRUE
[16:19:36.899] Value: <not collected>
[16:19:36.899] Conditions captured: <none>
[16:19:36.899] Early signaling: FALSE
[16:19:36.899] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:36.899] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:36.910] Chunk #2 of 2 ... DONE
[16:19:36.910] Launching 2 futures (chunks) ... DONE
[16:19:36.910] Resolving 2 futures (chunks) ...
[16:19:36.910] resolve() on list ...
[16:19:36.910]  recursive: 0
[16:19:36.911]  length: 2
[16:19:36.911] 
[16:19:36.922] Future #2
[16:19:36.923] result() for MulticoreFuture ...
[16:19:36.925] result() for MulticoreFuture ...
[16:19:36.925] result() for MulticoreFuture ... done
[16:19:36.925] result() for MulticoreFuture ... done
[16:19:36.925] result() for MulticoreFuture ...
[16:19:36.925] result() for MulticoreFuture ... done
[16:19:36.926] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:36.926] - nx: 2
[16:19:36.926] - relay: TRUE
[16:19:36.926] - stdout: TRUE
[16:19:36.926] - signal: TRUE
[16:19:36.926] - resignal: FALSE
[16:19:36.926] - force: TRUE
[16:19:36.926] - relayed: [n=2] FALSE, FALSE
[16:19:36.927] - queued futures: [n=2] FALSE, FALSE
[16:19:36.927]  - until=1
[16:19:36.927]  - relaying element #1
[16:19:36.927] - relayed: [n=2] FALSE, FALSE
[16:19:36.927] - queued futures: [n=2] FALSE, TRUE
[16:19:36.927] signalConditionsASAP(NULL, pos=2) ... done
[16:19:36.927]  length: 1 (resolved future 2)
[16:19:37.349] plan(): Setting new future strategy stack:
[16:19:37.349] List of future strategies:
[16:19:37.349] 1. multicore:
[16:19:37.349]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:37.349]    - tweaked: FALSE
[16:19:37.349]    - call: plan(strategy)
[16:19:37.354] plan(): nbrOfWorkers() = 2
[16:19:37.354] Future #1
[16:19:37.355] result() for MulticoreFuture ...
[16:19:37.355] result() for MulticoreFuture ...
[16:19:37.355] result() for MulticoreFuture ... done
[16:19:37.356] result() for MulticoreFuture ... done
[16:19:37.356] result() for MulticoreFuture ...
[16:19:37.356] result() for MulticoreFuture ... done
[16:19:37.356] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:37.356] - nx: 2
[16:19:37.356] - relay: TRUE
[16:19:37.356] - stdout: TRUE
[16:19:37.357] - signal: TRUE
[16:19:37.357] - resignal: FALSE
[16:19:37.357] - force: TRUE
[16:19:37.357] - relayed: [n=2] FALSE, FALSE
[16:19:37.357] - queued futures: [n=2] FALSE, TRUE
[16:19:37.357]  - until=1
[16:19:37.357]  - relaying element #1
[16:19:37.357] result() for MulticoreFuture ...
[16:19:37.357] result() for MulticoreFuture ... done
[16:19:37.358] result() for MulticoreFuture ...
[16:19:37.358] result() for MulticoreFuture ... done
[16:19:37.358] result() for MulticoreFuture ...
[16:19:37.358] result() for MulticoreFuture ... done
[16:19:37.358] result() for MulticoreFuture ...
[16:19:37.358] result() for MulticoreFuture ... done
[16:19:37.358] - relayed: [n=2] TRUE, FALSE
[16:19:37.358] - queued futures: [n=2] TRUE, TRUE
[16:19:37.358] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:37.359]  length: 0 (resolved future 1)
[16:19:37.359] Relaying remaining futures
[16:19:37.359] signalConditionsASAP(NULL, pos=0) ...
[16:19:37.359] - nx: 2
[16:19:37.359] - relay: TRUE
[16:19:37.359] - stdout: TRUE
[16:19:37.359] - signal: TRUE
[16:19:37.359] - resignal: FALSE
[16:19:37.359] - force: TRUE
[16:19:37.360] - relayed: [n=2] TRUE, FALSE
[16:19:37.360] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:37.360]  - relaying element #2
[16:19:37.360] result() for MulticoreFuture ...
[16:19:37.360] result() for MulticoreFuture ... done
[16:19:37.360] result() for MulticoreFuture ...
[16:19:37.360] result() for MulticoreFuture ... done
[16:19:37.361] result() for MulticoreFuture ...
[16:19:37.361] result() for MulticoreFuture ... done
[16:19:37.361] result() for MulticoreFuture ...
[16:19:37.361] result() for MulticoreFuture ... done
[16:19:37.361] - relayed: [n=2] TRUE, TRUE
[16:19:37.361] - queued futures: [n=2] TRUE, TRUE
[16:19:37.361] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:19:37.361] resolve() on list ... DONE
[16:19:37.361] result() for MulticoreFuture ...
[16:19:37.361] result() for MulticoreFuture ... done
[16:19:37.362] result() for MulticoreFuture ...
[16:19:37.362] result() for MulticoreFuture ... done
[16:19:37.362] result() for MulticoreFuture ...
[16:19:37.362] result() for MulticoreFuture ... done
[16:19:37.362] result() for MulticoreFuture ...
[16:19:37.362] result() for MulticoreFuture ... done
[16:19:37.362]  - Number of value chunks collected: 2
[16:19:37.362] Resolving 2 futures (chunks) ... DONE
[16:19:37.363] Reducing values from 2 chunks ...
[16:19:37.363]  - Number of values collected after concatenation: 2
[16:19:37.363]  - Number of values expected: 2
[16:19:37.363] Reducing values from 2 chunks ... DONE
[16:19:37.363] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:19:37.364] future_lapply() ...
[16:19:37.369] Number of chunks: 2
[16:19:37.369] getGlobalsAndPackagesXApply() ...
[16:19:37.370]  - future.globals: TRUE
[16:19:37.370] getGlobalsAndPackages() ...
[16:19:37.370] Searching for globals...
[16:19:37.371] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:37.372] Searching for globals ... DONE
[16:19:37.372] Resolving globals: FALSE
[16:19:37.372] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:37.373] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:37.373] - globals: [1] ‘FUN’
[16:19:37.373] 
[16:19:37.373] getGlobalsAndPackages() ... DONE
[16:19:37.373]  - globals found/used: [n=1] ‘FUN’
[16:19:37.373]  - needed namespaces: [n=0] 
[16:19:37.373] Finding globals ... DONE
[16:19:37.374]  - use_args: TRUE
[16:19:37.374]  - Getting '...' globals ...
[16:19:37.374] resolve() on list ...
[16:19:37.374]  recursive: 0
[16:19:37.374]  length: 1
[16:19:37.374]  elements: ‘...’
[16:19:37.374]  length: 0 (resolved future 1)
[16:19:37.375] resolve() on list ... DONE
[16:19:37.375]    - '...' content: [n=0] 
[16:19:37.375] List of 1
[16:19:37.375]  $ ...: list()
[16:19:37.375]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:37.375]  - attr(*, "where")=List of 1
[16:19:37.375]   ..$ ...:<environment: 0x563562915fd0> 
[16:19:37.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:37.375]  - attr(*, "resolved")= logi TRUE
[16:19:37.375]  - attr(*, "total_size")= num NA
[16:19:37.380]  - Getting '...' globals ... DONE
[16:19:37.380] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:37.380] List of 2
[16:19:37.380]  $ ...future.FUN:function (x)  
[16:19:37.380]  $ ...          : list()
[16:19:37.380]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:37.380]  - attr(*, "where")=List of 2
[16:19:37.380]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:37.380]   ..$ ...          :<environment: 0x563562915fd0> 
[16:19:37.380]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:37.380]  - attr(*, "resolved")= logi FALSE
[16:19:37.380]  - attr(*, "total_size")= num 4720
[16:19:37.383] Packages to be attached in all futures: [n=0] 
[16:19:37.383] getGlobalsAndPackagesXApply() ... DONE
[16:19:37.383] Number of futures (= number of chunks): 2
[16:19:37.384] Launching 2 futures (chunks) ...
[16:19:37.384] Chunk #1 of 2 ...
[16:19:37.384]  - Finding globals in 'X' for chunk #1 ...
[16:19:37.384] getGlobalsAndPackages() ...
[16:19:37.384] Searching for globals...
[16:19:37.384] 
[16:19:37.384] Searching for globals ... DONE
[16:19:37.385] - globals: [0] <none>
[16:19:37.385] getGlobalsAndPackages() ... DONE
[16:19:37.385]    + additional globals found: [n=0] 
[16:19:37.385]    + additional namespaces needed: [n=0] 
[16:19:37.385]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:37.385]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:37.385]  - seeds: <none>
[16:19:37.385]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:37.385] getGlobalsAndPackages() ...
[16:19:37.385] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:37.386] Resolving globals: FALSE
[16:19:37.386] Tweak future expression to call with '...' arguments ...
[16:19:37.386] {
[16:19:37.386]     do.call(function(...) {
[16:19:37.386]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:37.386]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:37.386]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:37.386]             on.exit(options(oopts), add = TRUE)
[16:19:37.386]         }
[16:19:37.386]         {
[16:19:37.386]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:37.386]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:37.386]                 ...future.FUN(...future.X_jj, ...)
[16:19:37.386]             })
[16:19:37.386]         }
[16:19:37.386]     }, args = future.call.arguments)
[16:19:37.386] }
[16:19:37.386] Tweak future expression to call with '...' arguments ... DONE
[16:19:37.386] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:37.386] 
[16:19:37.387] getGlobalsAndPackages() ... DONE
[16:19:37.387] run() for ‘Future’ ...
[16:19:37.387] - state: ‘created’
[16:19:37.387] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:37.391] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:37.391] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:37.391]   - Field: ‘label’
[16:19:37.391]   - Field: ‘local’
[16:19:37.391]   - Field: ‘owner’
[16:19:37.391]   - Field: ‘envir’
[16:19:37.391]   - Field: ‘workers’
[16:19:37.391]   - Field: ‘packages’
[16:19:37.391]   - Field: ‘gc’
[16:19:37.392]   - Field: ‘job’
[16:19:37.392]   - Field: ‘conditions’
[16:19:37.392]   - Field: ‘expr’
[16:19:37.392]   - Field: ‘uuid’
[16:19:37.392]   - Field: ‘seed’
[16:19:37.392]   - Field: ‘version’
[16:19:37.392]   - Field: ‘result’
[16:19:37.392]   - Field: ‘asynchronous’
[16:19:37.392]   - Field: ‘calls’
[16:19:37.392]   - Field: ‘globals’
[16:19:37.392]   - Field: ‘stdout’
[16:19:37.393]   - Field: ‘earlySignal’
[16:19:37.393]   - Field: ‘lazy’
[16:19:37.393]   - Field: ‘state’
[16:19:37.393] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:37.393] - Launch lazy future ...
[16:19:37.393] Packages needed by the future expression (n = 0): <none>
[16:19:37.393] Packages needed by future strategies (n = 0): <none>
[16:19:37.394] {
[16:19:37.394]     {
[16:19:37.394]         {
[16:19:37.394]             ...future.startTime <- base::Sys.time()
[16:19:37.394]             {
[16:19:37.394]                 {
[16:19:37.394]                   {
[16:19:37.394]                     {
[16:19:37.394]                       base::local({
[16:19:37.394]                         has_future <- base::requireNamespace("future", 
[16:19:37.394]                           quietly = TRUE)
[16:19:37.394]                         if (has_future) {
[16:19:37.394]                           ns <- base::getNamespace("future")
[16:19:37.394]                           version <- ns[[".package"]][["version"]]
[16:19:37.394]                           if (is.null(version)) 
[16:19:37.394]                             version <- utils::packageVersion("future")
[16:19:37.394]                         }
[16:19:37.394]                         else {
[16:19:37.394]                           version <- NULL
[16:19:37.394]                         }
[16:19:37.394]                         if (!has_future || version < "1.8.0") {
[16:19:37.394]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:37.394]                             "", base::R.version$version.string), 
[16:19:37.394]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:37.394]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:37.394]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:37.394]                               "release", "version")], collapse = " "), 
[16:19:37.394]                             hostname = base::Sys.info()[["nodename"]])
[16:19:37.394]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:37.394]                             info)
[16:19:37.394]                           info <- base::paste(info, collapse = "; ")
[16:19:37.394]                           if (!has_future) {
[16:19:37.394]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:37.394]                               info)
[16:19:37.394]                           }
[16:19:37.394]                           else {
[16:19:37.394]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:37.394]                               info, version)
[16:19:37.394]                           }
[16:19:37.394]                           base::stop(msg)
[16:19:37.394]                         }
[16:19:37.394]                       })
[16:19:37.394]                     }
[16:19:37.394]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:37.394]                     base::options(mc.cores = 1L)
[16:19:37.394]                   }
[16:19:37.394]                   ...future.strategy.old <- future::plan("list")
[16:19:37.394]                   options(future.plan = NULL)
[16:19:37.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:37.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:37.394]                 }
[16:19:37.394]                 ...future.workdir <- getwd()
[16:19:37.394]             }
[16:19:37.394]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:37.394]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:37.394]         }
[16:19:37.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:37.394]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:37.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:37.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:37.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:37.394]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:37.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:37.394]             base::names(...future.oldOptions))
[16:19:37.394]     }
[16:19:37.394]     if (FALSE) {
[16:19:37.394]     }
[16:19:37.394]     else {
[16:19:37.394]         if (TRUE) {
[16:19:37.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:37.394]                 open = "w")
[16:19:37.394]         }
[16:19:37.394]         else {
[16:19:37.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:37.394]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:37.394]         }
[16:19:37.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:37.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:37.394]             base::sink(type = "output", split = FALSE)
[16:19:37.394]             base::close(...future.stdout)
[16:19:37.394]         }, add = TRUE)
[16:19:37.394]     }
[16:19:37.394]     ...future.frame <- base::sys.nframe()
[16:19:37.394]     ...future.conditions <- base::list()
[16:19:37.394]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:37.394]     if (FALSE) {
[16:19:37.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:37.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:37.394]     }
[16:19:37.394]     ...future.result <- base::tryCatch({
[16:19:37.394]         base::withCallingHandlers({
[16:19:37.394]             ...future.value <- base::withVisible(base::local({
[16:19:37.394]                 withCallingHandlers({
[16:19:37.394]                   {
[16:19:37.394]                     do.call(function(...) {
[16:19:37.394]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:37.394]                       if (!identical(...future.globals.maxSize.org, 
[16:19:37.394]                         ...future.globals.maxSize)) {
[16:19:37.394]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:37.394]                         on.exit(options(oopts), add = TRUE)
[16:19:37.394]                       }
[16:19:37.394]                       {
[16:19:37.394]                         lapply(seq_along(...future.elements_ii), 
[16:19:37.394]                           FUN = function(jj) {
[16:19:37.394]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:37.394]                             ...future.FUN(...future.X_jj, ...)
[16:19:37.394]                           })
[16:19:37.394]                       }
[16:19:37.394]                     }, args = future.call.arguments)
[16:19:37.394]                   }
[16:19:37.394]                 }, immediateCondition = function(cond) {
[16:19:37.394]                   save_rds <- function (object, pathname, ...) 
[16:19:37.394]                   {
[16:19:37.394]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:37.394]                     if (file_test("-f", pathname_tmp)) {
[16:19:37.394]                       fi_tmp <- file.info(pathname_tmp)
[16:19:37.394]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:37.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:37.394]                         fi_tmp[["mtime"]])
[16:19:37.394]                     }
[16:19:37.394]                     tryCatch({
[16:19:37.394]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:37.394]                     }, error = function(ex) {
[16:19:37.394]                       msg <- conditionMessage(ex)
[16:19:37.394]                       fi_tmp <- file.info(pathname_tmp)
[16:19:37.394]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:37.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:37.394]                         fi_tmp[["mtime"]], msg)
[16:19:37.394]                       ex$message <- msg
[16:19:37.394]                       stop(ex)
[16:19:37.394]                     })
[16:19:37.394]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:37.394]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:37.394]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:37.394]                       fi_tmp <- file.info(pathname_tmp)
[16:19:37.394]                       fi <- file.info(pathname)
[16:19:37.394]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:37.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:37.394]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:37.394]                         fi[["size"]], fi[["mtime"]])
[16:19:37.394]                       stop(msg)
[16:19:37.394]                     }
[16:19:37.394]                     invisible(pathname)
[16:19:37.394]                   }
[16:19:37.394]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:37.394]                     rootPath = tempdir()) 
[16:19:37.394]                   {
[16:19:37.394]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:37.394]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:37.394]                       tmpdir = path, fileext = ".rds")
[16:19:37.394]                     save_rds(obj, file)
[16:19:37.394]                   }
[16:19:37.394]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPcako/.future/immediateConditions")
[16:19:37.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:37.394]                   {
[16:19:37.394]                     inherits <- base::inherits
[16:19:37.394]                     invokeRestart <- base::invokeRestart
[16:19:37.394]                     is.null <- base::is.null
[16:19:37.394]                     muffled <- FALSE
[16:19:37.394]                     if (inherits(cond, "message")) {
[16:19:37.394]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:37.394]                       if (muffled) 
[16:19:37.394]                         invokeRestart("muffleMessage")
[16:19:37.394]                     }
[16:19:37.394]                     else if (inherits(cond, "warning")) {
[16:19:37.394]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:37.394]                       if (muffled) 
[16:19:37.394]                         invokeRestart("muffleWarning")
[16:19:37.394]                     }
[16:19:37.394]                     else if (inherits(cond, "condition")) {
[16:19:37.394]                       if (!is.null(pattern)) {
[16:19:37.394]                         computeRestarts <- base::computeRestarts
[16:19:37.394]                         grepl <- base::grepl
[16:19:37.394]                         restarts <- computeRestarts(cond)
[16:19:37.394]                         for (restart in restarts) {
[16:19:37.394]                           name <- restart$name
[16:19:37.394]                           if (is.null(name)) 
[16:19:37.394]                             next
[16:19:37.394]                           if (!grepl(pattern, name)) 
[16:19:37.394]                             next
[16:19:37.394]                           invokeRestart(restart)
[16:19:37.394]                           muffled <- TRUE
[16:19:37.394]                           break
[16:19:37.394]                         }
[16:19:37.394]                       }
[16:19:37.394]                     }
[16:19:37.394]                     invisible(muffled)
[16:19:37.394]                   }
[16:19:37.394]                   muffleCondition(cond)
[16:19:37.394]                 })
[16:19:37.394]             }))
[16:19:37.394]             future::FutureResult(value = ...future.value$value, 
[16:19:37.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:37.394]                   ...future.rng), globalenv = if (FALSE) 
[16:19:37.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:37.394]                     ...future.globalenv.names))
[16:19:37.394]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:37.394]         }, condition = base::local({
[16:19:37.394]             c <- base::c
[16:19:37.394]             inherits <- base::inherits
[16:19:37.394]             invokeRestart <- base::invokeRestart
[16:19:37.394]             length <- base::length
[16:19:37.394]             list <- base::list
[16:19:37.394]             seq.int <- base::seq.int
[16:19:37.394]             signalCondition <- base::signalCondition
[16:19:37.394]             sys.calls <- base::sys.calls
[16:19:37.394]             `[[` <- base::`[[`
[16:19:37.394]             `+` <- base::`+`
[16:19:37.394]             `<<-` <- base::`<<-`
[16:19:37.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:37.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:37.394]                   3L)]
[16:19:37.394]             }
[16:19:37.394]             function(cond) {
[16:19:37.394]                 is_error <- inherits(cond, "error")
[16:19:37.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:37.394]                   NULL)
[16:19:37.394]                 if (is_error) {
[16:19:37.394]                   sessionInformation <- function() {
[16:19:37.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:37.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:37.394]                       search = base::search(), system = base::Sys.info())
[16:19:37.394]                   }
[16:19:37.394]                   ...future.conditions[[length(...future.conditions) + 
[16:19:37.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:37.394]                     cond$call), session = sessionInformation(), 
[16:19:37.394]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:37.394]                   signalCondition(cond)
[16:19:37.394]                 }
[16:19:37.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:37.394]                 "immediateCondition"))) {
[16:19:37.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:37.394]                   ...future.conditions[[length(...future.conditions) + 
[16:19:37.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:37.394]                   if (TRUE && !signal) {
[16:19:37.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:37.394]                     {
[16:19:37.394]                       inherits <- base::inherits
[16:19:37.394]                       invokeRestart <- base::invokeRestart
[16:19:37.394]                       is.null <- base::is.null
[16:19:37.394]                       muffled <- FALSE
[16:19:37.394]                       if (inherits(cond, "message")) {
[16:19:37.394]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:37.394]                         if (muffled) 
[16:19:37.394]                           invokeRestart("muffleMessage")
[16:19:37.394]                       }
[16:19:37.394]                       else if (inherits(cond, "warning")) {
[16:19:37.394]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:37.394]                         if (muffled) 
[16:19:37.394]                           invokeRestart("muffleWarning")
[16:19:37.394]                       }
[16:19:37.394]                       else if (inherits(cond, "condition")) {
[16:19:37.394]                         if (!is.null(pattern)) {
[16:19:37.394]                           computeRestarts <- base::computeRestarts
[16:19:37.394]                           grepl <- base::grepl
[16:19:37.394]                           restarts <- computeRestarts(cond)
[16:19:37.394]                           for (restart in restarts) {
[16:19:37.394]                             name <- restart$name
[16:19:37.394]                             if (is.null(name)) 
[16:19:37.394]                               next
[16:19:37.394]                             if (!grepl(pattern, name)) 
[16:19:37.394]                               next
[16:19:37.394]                             invokeRestart(restart)
[16:19:37.394]                             muffled <- TRUE
[16:19:37.394]                             break
[16:19:37.394]                           }
[16:19:37.394]                         }
[16:19:37.394]                       }
[16:19:37.394]                       invisible(muffled)
[16:19:37.394]                     }
[16:19:37.394]                     muffleCondition(cond, pattern = "^muffle")
[16:19:37.394]                   }
[16:19:37.394]                 }
[16:19:37.394]                 else {
[16:19:37.394]                   if (TRUE) {
[16:19:37.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:37.394]                     {
[16:19:37.394]                       inherits <- base::inherits
[16:19:37.394]                       invokeRestart <- base::invokeRestart
[16:19:37.394]                       is.null <- base::is.null
[16:19:37.394]                       muffled <- FALSE
[16:19:37.394]                       if (inherits(cond, "message")) {
[16:19:37.394]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:37.394]                         if (muffled) 
[16:19:37.394]                           invokeRestart("muffleMessage")
[16:19:37.394]                       }
[16:19:37.394]                       else if (inherits(cond, "warning")) {
[16:19:37.394]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:37.394]                         if (muffled) 
[16:19:37.394]                           invokeRestart("muffleWarning")
[16:19:37.394]                       }
[16:19:37.394]                       else if (inherits(cond, "condition")) {
[16:19:37.394]                         if (!is.null(pattern)) {
[16:19:37.394]                           computeRestarts <- base::computeRestarts
[16:19:37.394]                           grepl <- base::grepl
[16:19:37.394]                           restarts <- computeRestarts(cond)
[16:19:37.394]                           for (restart in restarts) {
[16:19:37.394]                             name <- restart$name
[16:19:37.394]                             if (is.null(name)) 
[16:19:37.394]                               next
[16:19:37.394]                             if (!grepl(pattern, name)) 
[16:19:37.394]                               next
[16:19:37.394]                             invokeRestart(restart)
[16:19:37.394]                             muffled <- TRUE
[16:19:37.394]                             break
[16:19:37.394]                           }
[16:19:37.394]                         }
[16:19:37.394]                       }
[16:19:37.394]                       invisible(muffled)
[16:19:37.394]                     }
[16:19:37.394]                     muffleCondition(cond, pattern = "^muffle")
[16:19:37.394]                   }
[16:19:37.394]                 }
[16:19:37.394]             }
[16:19:37.394]         }))
[16:19:37.394]     }, error = function(ex) {
[16:19:37.394]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:37.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:37.394]                 ...future.rng), started = ...future.startTime, 
[16:19:37.394]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:37.394]             version = "1.8"), class = "FutureResult")
[16:19:37.394]     }, finally = {
[16:19:37.394]         if (!identical(...future.workdir, getwd())) 
[16:19:37.394]             setwd(...future.workdir)
[16:19:37.394]         {
[16:19:37.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:37.394]                 ...future.oldOptions$nwarnings <- NULL
[16:19:37.394]             }
[16:19:37.394]             base::options(...future.oldOptions)
[16:19:37.394]             if (.Platform$OS.type == "windows") {
[16:19:37.394]                 old_names <- names(...future.oldEnvVars)
[16:19:37.394]                 envs <- base::Sys.getenv()
[16:19:37.394]                 names <- names(envs)
[16:19:37.394]                 common <- intersect(names, old_names)
[16:19:37.394]                 added <- setdiff(names, old_names)
[16:19:37.394]                 removed <- setdiff(old_names, names)
[16:19:37.394]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:37.394]                   envs[common]]
[16:19:37.394]                 NAMES <- toupper(changed)
[16:19:37.394]                 args <- list()
[16:19:37.394]                 for (kk in seq_along(NAMES)) {
[16:19:37.394]                   name <- changed[[kk]]
[16:19:37.394]                   NAME <- NAMES[[kk]]
[16:19:37.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:37.394]                     next
[16:19:37.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:37.394]                 }
[16:19:37.394]                 NAMES <- toupper(added)
[16:19:37.394]                 for (kk in seq_along(NAMES)) {
[16:19:37.394]                   name <- added[[kk]]
[16:19:37.394]                   NAME <- NAMES[[kk]]
[16:19:37.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:37.394]                     next
[16:19:37.394]                   args[[name]] <- ""
[16:19:37.394]                 }
[16:19:37.394]                 NAMES <- toupper(removed)
[16:19:37.394]                 for (kk in seq_along(NAMES)) {
[16:19:37.394]                   name <- removed[[kk]]
[16:19:37.394]                   NAME <- NAMES[[kk]]
[16:19:37.394]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:37.394]                     next
[16:19:37.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:37.394]                 }
[16:19:37.394]                 if (length(args) > 0) 
[16:19:37.394]                   base::do.call(base::Sys.setenv, args = args)
[16:19:37.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:37.394]             }
[16:19:37.394]             else {
[16:19:37.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:37.394]             }
[16:19:37.394]             {
[16:19:37.394]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:37.394]                   0L) {
[16:19:37.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:37.394]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:37.394]                   base::options(opts)
[16:19:37.394]                 }
[16:19:37.394]                 {
[16:19:37.394]                   {
[16:19:37.394]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:37.394]                     NULL
[16:19:37.394]                   }
[16:19:37.394]                   options(future.plan = NULL)
[16:19:37.394]                   if (is.na(NA_character_)) 
[16:19:37.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:37.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:37.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:37.394]                     .init = FALSE)
[16:19:37.394]                 }
[16:19:37.394]             }
[16:19:37.394]         }
[16:19:37.394]     })
[16:19:37.394]     if (TRUE) {
[16:19:37.394]         base::sink(type = "output", split = FALSE)
[16:19:37.394]         if (TRUE) {
[16:19:37.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:37.394]         }
[16:19:37.394]         else {
[16:19:37.394]             ...future.result["stdout"] <- base::list(NULL)
[16:19:37.394]         }
[16:19:37.394]         base::close(...future.stdout)
[16:19:37.394]         ...future.stdout <- NULL
[16:19:37.394]     }
[16:19:37.394]     ...future.result$conditions <- ...future.conditions
[16:19:37.394]     ...future.result$finished <- base::Sys.time()
[16:19:37.394]     ...future.result
[16:19:37.394] }
[16:19:37.396] assign_globals() ...
[16:19:37.396] List of 5
[16:19:37.396]  $ ...future.FUN            :function (x)  
[16:19:37.396]  $ future.call.arguments    : list()
[16:19:37.396]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:37.396]  $ ...future.elements_ii    :List of 1
[16:19:37.396]   ..$ : int 1
[16:19:37.396]  $ ...future.seeds_ii       : NULL
[16:19:37.396]  $ ...future.globals.maxSize: NULL
[16:19:37.396]  - attr(*, "where")=List of 5
[16:19:37.396]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:37.396]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:37.396]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:37.396]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:37.396]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:37.396]  - attr(*, "resolved")= logi FALSE
[16:19:37.396]  - attr(*, "total_size")= num 4720
[16:19:37.396]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:37.396]  - attr(*, "already-done")= logi TRUE
[16:19:37.401] - reassign environment for ‘...future.FUN’
[16:19:37.401] - copied ‘...future.FUN’ to environment
[16:19:37.401] - copied ‘future.call.arguments’ to environment
[16:19:37.401] - copied ‘...future.elements_ii’ to environment
[16:19:37.401] - copied ‘...future.seeds_ii’ to environment
[16:19:37.401] - copied ‘...future.globals.maxSize’ to environment
[16:19:37.401] assign_globals() ... done
[16:19:37.402] requestCore(): workers = 2
[16:19:37.403] MulticoreFuture started
[16:19:37.404] - Launch lazy future ... done
[16:19:37.404] run() for ‘MulticoreFuture’ ... done
[16:19:37.404] Created future:
[16:19:37.405] plan(): Setting new future strategy stack:
[16:19:37.405] List of future strategies:
[16:19:37.405] 1. sequential:
[16:19:37.405]    - args: function (..., envir = parent.frame())
[16:19:37.405]    - tweaked: FALSE
[16:19:37.405]    - call: NULL
[16:19:37.406] plan(): nbrOfWorkers() = 1
[16:19:37.405] MulticoreFuture:
[16:19:37.405] Label: ‘future_lapply-1’
[16:19:37.405] Expression:
[16:19:37.405] {
[16:19:37.405]     do.call(function(...) {
[16:19:37.405]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:37.405]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:37.405]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:37.405]             on.exit(options(oopts), add = TRUE)
[16:19:37.405]         }
[16:19:37.405]         {
[16:19:37.405]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:37.405]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:37.405]                 ...future.FUN(...future.X_jj, ...)
[16:19:37.405]             })
[16:19:37.405]         }
[16:19:37.405]     }, args = future.call.arguments)
[16:19:37.405] }
[16:19:37.405] Lazy evaluation: FALSE
[16:19:37.405] Asynchronous evaluation: TRUE
[16:19:37.405] Local evaluation: TRUE
[16:19:37.405] Environment: R_GlobalEnv
[16:19:37.405] Capture standard output: TRUE
[16:19:37.405] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:37.405] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:37.405] Packages: <none>
[16:19:37.405] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:37.405] Resolved: FALSE
[16:19:37.405] Value: <not collected>
[16:19:37.405] Conditions captured: <none>
[16:19:37.405] Early signaling: FALSE
[16:19:37.405] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:37.405] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:37.422] Chunk #1 of 2 ... DONE
[16:19:37.423] Chunk #2 of 2 ...
[16:19:37.423]  - Finding globals in 'X' for chunk #2 ...
[16:19:37.423] getGlobalsAndPackages() ...
[16:19:37.424] Searching for globals...
[16:19:37.425] 
[16:19:37.425] Searching for globals ... DONE
[16:19:37.426] - globals: [0] <none>
[16:19:37.426] getGlobalsAndPackages() ... DONE
[16:19:37.426]    + additional globals found: [n=0] 
[16:19:37.426]    + additional namespaces needed: [n=0] 
[16:19:37.426]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:37.426]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:37.427]  - seeds: <none>
[16:19:37.427]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:37.427] getGlobalsAndPackages() ...
[16:19:37.427] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:37.427] Resolving globals: FALSE
[16:19:37.428] Tweak future expression to call with '...' arguments ...
[16:19:37.428] {
[16:19:37.428]     do.call(function(...) {
[16:19:37.428]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:37.428]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:37.428]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:37.428]             on.exit(options(oopts), add = TRUE)
[16:19:37.428]         }
[16:19:37.428]         {
[16:19:37.428]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:37.428]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:37.428]                 ...future.FUN(...future.X_jj, ...)
[16:19:37.428]             })
[16:19:37.428]         }
[16:19:37.428]     }, args = future.call.arguments)
[16:19:37.428] }
[16:19:37.428] Tweak future expression to call with '...' arguments ... DONE
[16:19:37.429] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:37.429] 
[16:19:37.430] getGlobalsAndPackages() ... DONE
[16:19:37.430] run() for ‘Future’ ...
[16:19:37.430] - state: ‘created’
[16:19:37.431] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:37.435] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:37.436] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:37.436]   - Field: ‘label’
[16:19:37.436]   - Field: ‘local’
[16:19:37.436]   - Field: ‘owner’
[16:19:37.436]   - Field: ‘envir’
[16:19:37.436]   - Field: ‘workers’
[16:19:37.437]   - Field: ‘packages’
[16:19:37.437]   - Field: ‘gc’
[16:19:37.437]   - Field: ‘job’
[16:19:37.437]   - Field: ‘conditions’
[16:19:37.437]   - Field: ‘expr’
[16:19:37.437]   - Field: ‘uuid’
[16:19:37.437]   - Field: ‘seed’
[16:19:37.438]   - Field: ‘version’
[16:19:37.438]   - Field: ‘result’
[16:19:37.438]   - Field: ‘asynchronous’
[16:19:37.438]   - Field: ‘calls’
[16:19:37.438]   - Field: ‘globals’
[16:19:37.438]   - Field: ‘stdout’
[16:19:37.438]   - Field: ‘earlySignal’
[16:19:37.438]   - Field: ‘lazy’
[16:19:37.439]   - Field: ‘state’
[16:19:37.439] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:37.439] - Launch lazy future ...
[16:19:37.439] Packages needed by the future expression (n = 0): <none>
[16:19:37.440] Packages needed by future strategies (n = 0): <none>
[16:19:37.440] {
[16:19:37.440]     {
[16:19:37.440]         {
[16:19:37.440]             ...future.startTime <- base::Sys.time()
[16:19:37.440]             {
[16:19:37.440]                 {
[16:19:37.440]                   {
[16:19:37.440]                     {
[16:19:37.440]                       base::local({
[16:19:37.440]                         has_future <- base::requireNamespace("future", 
[16:19:37.440]                           quietly = TRUE)
[16:19:37.440]                         if (has_future) {
[16:19:37.440]                           ns <- base::getNamespace("future")
[16:19:37.440]                           version <- ns[[".package"]][["version"]]
[16:19:37.440]                           if (is.null(version)) 
[16:19:37.440]                             version <- utils::packageVersion("future")
[16:19:37.440]                         }
[16:19:37.440]                         else {
[16:19:37.440]                           version <- NULL
[16:19:37.440]                         }
[16:19:37.440]                         if (!has_future || version < "1.8.0") {
[16:19:37.440]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:37.440]                             "", base::R.version$version.string), 
[16:19:37.440]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:37.440]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:37.440]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:37.440]                               "release", "version")], collapse = " "), 
[16:19:37.440]                             hostname = base::Sys.info()[["nodename"]])
[16:19:37.440]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:37.440]                             info)
[16:19:37.440]                           info <- base::paste(info, collapse = "; ")
[16:19:37.440]                           if (!has_future) {
[16:19:37.440]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:37.440]                               info)
[16:19:37.440]                           }
[16:19:37.440]                           else {
[16:19:37.440]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:37.440]                               info, version)
[16:19:37.440]                           }
[16:19:37.440]                           base::stop(msg)
[16:19:37.440]                         }
[16:19:37.440]                       })
[16:19:37.440]                     }
[16:19:37.440]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:37.440]                     base::options(mc.cores = 1L)
[16:19:37.440]                   }
[16:19:37.440]                   ...future.strategy.old <- future::plan("list")
[16:19:37.440]                   options(future.plan = NULL)
[16:19:37.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:37.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:37.440]                 }
[16:19:37.440]                 ...future.workdir <- getwd()
[16:19:37.440]             }
[16:19:37.440]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:37.440]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:37.440]         }
[16:19:37.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:37.440]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:37.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:37.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:37.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:37.440]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:37.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:37.440]             base::names(...future.oldOptions))
[16:19:37.440]     }
[16:19:37.440]     if (FALSE) {
[16:19:37.440]     }
[16:19:37.440]     else {
[16:19:37.440]         if (TRUE) {
[16:19:37.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:37.440]                 open = "w")
[16:19:37.440]         }
[16:19:37.440]         else {
[16:19:37.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:37.440]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:37.440]         }
[16:19:37.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:37.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:37.440]             base::sink(type = "output", split = FALSE)
[16:19:37.440]             base::close(...future.stdout)
[16:19:37.440]         }, add = TRUE)
[16:19:37.440]     }
[16:19:37.440]     ...future.frame <- base::sys.nframe()
[16:19:37.440]     ...future.conditions <- base::list()
[16:19:37.440]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:37.440]     if (FALSE) {
[16:19:37.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:37.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:37.440]     }
[16:19:37.440]     ...future.result <- base::tryCatch({
[16:19:37.440]         base::withCallingHandlers({
[16:19:37.440]             ...future.value <- base::withVisible(base::local({
[16:19:37.440]                 withCallingHandlers({
[16:19:37.440]                   {
[16:19:37.440]                     do.call(function(...) {
[16:19:37.440]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:37.440]                       if (!identical(...future.globals.maxSize.org, 
[16:19:37.440]                         ...future.globals.maxSize)) {
[16:19:37.440]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:37.440]                         on.exit(options(oopts), add = TRUE)
[16:19:37.440]                       }
[16:19:37.440]                       {
[16:19:37.440]                         lapply(seq_along(...future.elements_ii), 
[16:19:37.440]                           FUN = function(jj) {
[16:19:37.440]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:37.440]                             ...future.FUN(...future.X_jj, ...)
[16:19:37.440]                           })
[16:19:37.440]                       }
[16:19:37.440]                     }, args = future.call.arguments)
[16:19:37.440]                   }
[16:19:37.440]                 }, immediateCondition = function(cond) {
[16:19:37.440]                   save_rds <- function (object, pathname, ...) 
[16:19:37.440]                   {
[16:19:37.440]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:37.440]                     if (file_test("-f", pathname_tmp)) {
[16:19:37.440]                       fi_tmp <- file.info(pathname_tmp)
[16:19:37.440]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:37.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:37.440]                         fi_tmp[["mtime"]])
[16:19:37.440]                     }
[16:19:37.440]                     tryCatch({
[16:19:37.440]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:37.440]                     }, error = function(ex) {
[16:19:37.440]                       msg <- conditionMessage(ex)
[16:19:37.440]                       fi_tmp <- file.info(pathname_tmp)
[16:19:37.440]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:37.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:37.440]                         fi_tmp[["mtime"]], msg)
[16:19:37.440]                       ex$message <- msg
[16:19:37.440]                       stop(ex)
[16:19:37.440]                     })
[16:19:37.440]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:37.440]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:37.440]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:37.440]                       fi_tmp <- file.info(pathname_tmp)
[16:19:37.440]                       fi <- file.info(pathname)
[16:19:37.440]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:37.440]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:37.440]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:37.440]                         fi[["size"]], fi[["mtime"]])
[16:19:37.440]                       stop(msg)
[16:19:37.440]                     }
[16:19:37.440]                     invisible(pathname)
[16:19:37.440]                   }
[16:19:37.440]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:37.440]                     rootPath = tempdir()) 
[16:19:37.440]                   {
[16:19:37.440]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:37.440]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:37.440]                       tmpdir = path, fileext = ".rds")
[16:19:37.440]                     save_rds(obj, file)
[16:19:37.440]                   }
[16:19:37.440]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPcako/.future/immediateConditions")
[16:19:37.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:37.440]                   {
[16:19:37.440]                     inherits <- base::inherits
[16:19:37.440]                     invokeRestart <- base::invokeRestart
[16:19:37.440]                     is.null <- base::is.null
[16:19:37.440]                     muffled <- FALSE
[16:19:37.440]                     if (inherits(cond, "message")) {
[16:19:37.440]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:37.440]                       if (muffled) 
[16:19:37.440]                         invokeRestart("muffleMessage")
[16:19:37.440]                     }
[16:19:37.440]                     else if (inherits(cond, "warning")) {
[16:19:37.440]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:37.440]                       if (muffled) 
[16:19:37.440]                         invokeRestart("muffleWarning")
[16:19:37.440]                     }
[16:19:37.440]                     else if (inherits(cond, "condition")) {
[16:19:37.440]                       if (!is.null(pattern)) {
[16:19:37.440]                         computeRestarts <- base::computeRestarts
[16:19:37.440]                         grepl <- base::grepl
[16:19:37.440]                         restarts <- computeRestarts(cond)
[16:19:37.440]                         for (restart in restarts) {
[16:19:37.440]                           name <- restart$name
[16:19:37.440]                           if (is.null(name)) 
[16:19:37.440]                             next
[16:19:37.440]                           if (!grepl(pattern, name)) 
[16:19:37.440]                             next
[16:19:37.440]                           invokeRestart(restart)
[16:19:37.440]                           muffled <- TRUE
[16:19:37.440]                           break
[16:19:37.440]                         }
[16:19:37.440]                       }
[16:19:37.440]                     }
[16:19:37.440]                     invisible(muffled)
[16:19:37.440]                   }
[16:19:37.440]                   muffleCondition(cond)
[16:19:37.440]                 })
[16:19:37.440]             }))
[16:19:37.440]             future::FutureResult(value = ...future.value$value, 
[16:19:37.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:37.440]                   ...future.rng), globalenv = if (FALSE) 
[16:19:37.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:37.440]                     ...future.globalenv.names))
[16:19:37.440]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:37.440]         }, condition = base::local({
[16:19:37.440]             c <- base::c
[16:19:37.440]             inherits <- base::inherits
[16:19:37.440]             invokeRestart <- base::invokeRestart
[16:19:37.440]             length <- base::length
[16:19:37.440]             list <- base::list
[16:19:37.440]             seq.int <- base::seq.int
[16:19:37.440]             signalCondition <- base::signalCondition
[16:19:37.440]             sys.calls <- base::sys.calls
[16:19:37.440]             `[[` <- base::`[[`
[16:19:37.440]             `+` <- base::`+`
[16:19:37.440]             `<<-` <- base::`<<-`
[16:19:37.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:37.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:37.440]                   3L)]
[16:19:37.440]             }
[16:19:37.440]             function(cond) {
[16:19:37.440]                 is_error <- inherits(cond, "error")
[16:19:37.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:37.440]                   NULL)
[16:19:37.440]                 if (is_error) {
[16:19:37.440]                   sessionInformation <- function() {
[16:19:37.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:37.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:37.440]                       search = base::search(), system = base::Sys.info())
[16:19:37.440]                   }
[16:19:37.440]                   ...future.conditions[[length(...future.conditions) + 
[16:19:37.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:37.440]                     cond$call), session = sessionInformation(), 
[16:19:37.440]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:37.440]                   signalCondition(cond)
[16:19:37.440]                 }
[16:19:37.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:37.440]                 "immediateCondition"))) {
[16:19:37.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:37.440]                   ...future.conditions[[length(...future.conditions) + 
[16:19:37.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:37.440]                   if (TRUE && !signal) {
[16:19:37.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:37.440]                     {
[16:19:37.440]                       inherits <- base::inherits
[16:19:37.440]                       invokeRestart <- base::invokeRestart
[16:19:37.440]                       is.null <- base::is.null
[16:19:37.440]                       muffled <- FALSE
[16:19:37.440]                       if (inherits(cond, "message")) {
[16:19:37.440]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:37.440]                         if (muffled) 
[16:19:37.440]                           invokeRestart("muffleMessage")
[16:19:37.440]                       }
[16:19:37.440]                       else if (inherits(cond, "warning")) {
[16:19:37.440]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:37.440]                         if (muffled) 
[16:19:37.440]                           invokeRestart("muffleWarning")
[16:19:37.440]                       }
[16:19:37.440]                       else if (inherits(cond, "condition")) {
[16:19:37.440]                         if (!is.null(pattern)) {
[16:19:37.440]                           computeRestarts <- base::computeRestarts
[16:19:37.440]                           grepl <- base::grepl
[16:19:37.440]                           restarts <- computeRestarts(cond)
[16:19:37.440]                           for (restart in restarts) {
[16:19:37.440]                             name <- restart$name
[16:19:37.440]                             if (is.null(name)) 
[16:19:37.440]                               next
[16:19:37.440]                             if (!grepl(pattern, name)) 
[16:19:37.440]                               next
[16:19:37.440]                             invokeRestart(restart)
[16:19:37.440]                             muffled <- TRUE
[16:19:37.440]                             break
[16:19:37.440]                           }
[16:19:37.440]                         }
[16:19:37.440]                       }
[16:19:37.440]                       invisible(muffled)
[16:19:37.440]                     }
[16:19:37.440]                     muffleCondition(cond, pattern = "^muffle")
[16:19:37.440]                   }
[16:19:37.440]                 }
[16:19:37.440]                 else {
[16:19:37.440]                   if (TRUE) {
[16:19:37.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:37.440]                     {
[16:19:37.440]                       inherits <- base::inherits
[16:19:37.440]                       invokeRestart <- base::invokeRestart
[16:19:37.440]                       is.null <- base::is.null
[16:19:37.440]                       muffled <- FALSE
[16:19:37.440]                       if (inherits(cond, "message")) {
[16:19:37.440]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:37.440]                         if (muffled) 
[16:19:37.440]                           invokeRestart("muffleMessage")
[16:19:37.440]                       }
[16:19:37.440]                       else if (inherits(cond, "warning")) {
[16:19:37.440]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:37.440]                         if (muffled) 
[16:19:37.440]                           invokeRestart("muffleWarning")
[16:19:37.440]                       }
[16:19:37.440]                       else if (inherits(cond, "condition")) {
[16:19:37.440]                         if (!is.null(pattern)) {
[16:19:37.440]                           computeRestarts <- base::computeRestarts
[16:19:37.440]                           grepl <- base::grepl
[16:19:37.440]                           restarts <- computeRestarts(cond)
[16:19:37.440]                           for (restart in restarts) {
[16:19:37.440]                             name <- restart$name
[16:19:37.440]                             if (is.null(name)) 
[16:19:37.440]                               next
[16:19:37.440]                             if (!grepl(pattern, name)) 
[16:19:37.440]                               next
[16:19:37.440]                             invokeRestart(restart)
[16:19:37.440]                             muffled <- TRUE
[16:19:37.440]                             break
[16:19:37.440]                           }
[16:19:37.440]                         }
[16:19:37.440]                       }
[16:19:37.440]                       invisible(muffled)
[16:19:37.440]                     }
[16:19:37.440]                     muffleCondition(cond, pattern = "^muffle")
[16:19:37.440]                   }
[16:19:37.440]                 }
[16:19:37.440]             }
[16:19:37.440]         }))
[16:19:37.440]     }, error = function(ex) {
[16:19:37.440]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:37.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:37.440]                 ...future.rng), started = ...future.startTime, 
[16:19:37.440]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:37.440]             version = "1.8"), class = "FutureResult")
[16:19:37.440]     }, finally = {
[16:19:37.440]         if (!identical(...future.workdir, getwd())) 
[16:19:37.440]             setwd(...future.workdir)
[16:19:37.440]         {
[16:19:37.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:37.440]                 ...future.oldOptions$nwarnings <- NULL
[16:19:37.440]             }
[16:19:37.440]             base::options(...future.oldOptions)
[16:19:37.440]             if (.Platform$OS.type == "windows") {
[16:19:37.440]                 old_names <- names(...future.oldEnvVars)
[16:19:37.440]                 envs <- base::Sys.getenv()
[16:19:37.440]                 names <- names(envs)
[16:19:37.440]                 common <- intersect(names, old_names)
[16:19:37.440]                 added <- setdiff(names, old_names)
[16:19:37.440]                 removed <- setdiff(old_names, names)
[16:19:37.440]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:37.440]                   envs[common]]
[16:19:37.440]                 NAMES <- toupper(changed)
[16:19:37.440]                 args <- list()
[16:19:37.440]                 for (kk in seq_along(NAMES)) {
[16:19:37.440]                   name <- changed[[kk]]
[16:19:37.440]                   NAME <- NAMES[[kk]]
[16:19:37.440]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:37.440]                     next
[16:19:37.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:37.440]                 }
[16:19:37.440]                 NAMES <- toupper(added)
[16:19:37.440]                 for (kk in seq_along(NAMES)) {
[16:19:37.440]                   name <- added[[kk]]
[16:19:37.440]                   NAME <- NAMES[[kk]]
[16:19:37.440]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:37.440]                     next
[16:19:37.440]                   args[[name]] <- ""
[16:19:37.440]                 }
[16:19:37.440]                 NAMES <- toupper(removed)
[16:19:37.440]                 for (kk in seq_along(NAMES)) {
[16:19:37.440]                   name <- removed[[kk]]
[16:19:37.440]                   NAME <- NAMES[[kk]]
[16:19:37.440]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:37.440]                     next
[16:19:37.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:37.440]                 }
[16:19:37.440]                 if (length(args) > 0) 
[16:19:37.440]                   base::do.call(base::Sys.setenv, args = args)
[16:19:37.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:37.440]             }
[16:19:37.440]             else {
[16:19:37.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:37.440]             }
[16:19:37.440]             {
[16:19:37.440]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:37.440]                   0L) {
[16:19:37.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:37.440]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:37.440]                   base::options(opts)
[16:19:37.440]                 }
[16:19:37.440]                 {
[16:19:37.440]                   {
[16:19:37.440]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:37.440]                     NULL
[16:19:37.440]                   }
[16:19:37.440]                   options(future.plan = NULL)
[16:19:37.440]                   if (is.na(NA_character_)) 
[16:19:37.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:37.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:37.440]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:37.440]                     .init = FALSE)
[16:19:37.440]                 }
[16:19:37.440]             }
[16:19:37.440]         }
[16:19:37.440]     })
[16:19:37.440]     if (TRUE) {
[16:19:37.440]         base::sink(type = "output", split = FALSE)
[16:19:37.440]         if (TRUE) {
[16:19:37.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:37.440]         }
[16:19:37.440]         else {
[16:19:37.440]             ...future.result["stdout"] <- base::list(NULL)
[16:19:37.440]         }
[16:19:37.440]         base::close(...future.stdout)
[16:19:37.440]         ...future.stdout <- NULL
[16:19:37.440]     }
[16:19:37.440]     ...future.result$conditions <- ...future.conditions
[16:19:37.440]     ...future.result$finished <- base::Sys.time()
[16:19:37.440]     ...future.result
[16:19:37.440] }
[16:19:37.443] assign_globals() ...
[16:19:37.443] List of 5
[16:19:37.443]  $ ...future.FUN            :function (x)  
[16:19:37.443]  $ future.call.arguments    : list()
[16:19:37.443]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:37.443]  $ ...future.elements_ii    :List of 1
[16:19:37.443]   ..$ : int 0
[16:19:37.443]  $ ...future.seeds_ii       : NULL
[16:19:37.443]  $ ...future.globals.maxSize: NULL
[16:19:37.443]  - attr(*, "where")=List of 5
[16:19:37.443]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:37.443]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:37.443]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:37.443]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:37.443]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:37.443]  - attr(*, "resolved")= logi FALSE
[16:19:37.443]  - attr(*, "total_size")= num 4720
[16:19:37.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:37.443]  - attr(*, "already-done")= logi TRUE
[16:19:37.450] - reassign environment for ‘...future.FUN’
[16:19:37.450] - copied ‘...future.FUN’ to environment
[16:19:37.450] - copied ‘future.call.arguments’ to environment
[16:19:37.450] - copied ‘...future.elements_ii’ to environment
[16:19:37.450] - copied ‘...future.seeds_ii’ to environment
[16:19:37.450] - copied ‘...future.globals.maxSize’ to environment
[16:19:37.450] assign_globals() ... done
[16:19:37.450] requestCore(): workers = 2
[16:19:37.453] MulticoreFuture started
[16:19:37.453] - Launch lazy future ... done
[16:19:37.453] run() for ‘MulticoreFuture’ ... done
[16:19:37.453] Created future:
[16:19:37.454] plan(): Setting new future strategy stack:
[16:19:37.454] List of future strategies:
[16:19:37.454] 1. sequential:
[16:19:37.454]    - args: function (..., envir = parent.frame())
[16:19:37.454]    - tweaked: FALSE
[16:19:37.454]    - call: NULL
[16:19:37.455] plan(): nbrOfWorkers() = 1
[16:19:37.457] plan(): Setting new future strategy stack:
[16:19:37.457] List of future strategies:
[16:19:37.457] 1. multicore:
[16:19:37.457]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:37.457]    - tweaked: FALSE
[16:19:37.457]    - call: plan(strategy)
[16:19:37.462] plan(): nbrOfWorkers() = 2
[16:19:37.454] MulticoreFuture:
[16:19:37.454] Label: ‘future_lapply-2’
[16:19:37.454] Expression:
[16:19:37.454] {
[16:19:37.454]     do.call(function(...) {
[16:19:37.454]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:37.454]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:37.454]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:37.454]             on.exit(options(oopts), add = TRUE)
[16:19:37.454]         }
[16:19:37.454]         {
[16:19:37.454]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:37.454]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:37.454]                 ...future.FUN(...future.X_jj, ...)
[16:19:37.454]             })
[16:19:37.454]         }
[16:19:37.454]     }, args = future.call.arguments)
[16:19:37.454] }
[16:19:37.454] Lazy evaluation: FALSE
[16:19:37.454] Asynchronous evaluation: TRUE
[16:19:37.454] Local evaluation: TRUE
[16:19:37.454] Environment: R_GlobalEnv
[16:19:37.454] Capture standard output: TRUE
[16:19:37.454] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:37.454] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:37.454] Packages: <none>
[16:19:37.454] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:37.454] Resolved: TRUE
[16:19:37.454] Value: <not collected>
[16:19:37.454] Conditions captured: <none>
[16:19:37.454] Early signaling: FALSE
[16:19:37.454] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:37.454] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:37.463] Chunk #2 of 2 ... DONE
[16:19:37.464] Launching 2 futures (chunks) ... DONE
[16:19:37.464] Resolving 2 futures (chunks) ...
[16:19:37.464] resolve() on list ...
[16:19:37.464]  recursive: 0
[16:19:37.464]  length: 2
[16:19:37.464] 
[16:19:37.475] Future #2
[16:19:37.475] result() for MulticoreFuture ...
[16:19:37.476] result() for MulticoreFuture ...
[16:19:37.477] result() for MulticoreFuture ... done
[16:19:37.477] result() for MulticoreFuture ... done
[16:19:37.477] result() for MulticoreFuture ...
[16:19:37.477] result() for MulticoreFuture ... done
[16:19:37.477] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:37.477] - nx: 2
[16:19:37.478] - relay: TRUE
[16:19:37.478] - stdout: TRUE
[16:19:37.478] - signal: TRUE
[16:19:37.478] - resignal: FALSE
[16:19:37.478] - force: TRUE
[16:19:37.478] - relayed: [n=2] FALSE, FALSE
[16:19:37.478] - queued futures: [n=2] FALSE, FALSE
[16:19:37.479]  - until=1
[16:19:37.479]  - relaying element #1
[16:19:37.479] - relayed: [n=2] FALSE, FALSE
[16:19:37.479] - queued futures: [n=2] FALSE, TRUE
[16:19:37.479] signalConditionsASAP(NULL, pos=2) ... done
[16:19:37.479]  length: 1 (resolved future 2)
[16:19:37.912] plan(): Setting new future strategy stack:
[16:19:37.912] List of future strategies:
[16:19:37.912] 1. multicore:
[16:19:37.912]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:37.912]    - tweaked: FALSE
[16:19:37.912]    - call: plan(strategy)
[16:19:37.918] plan(): nbrOfWorkers() = 2
[16:19:37.918] Future #1
[16:19:37.918] result() for MulticoreFuture ...
[16:19:37.922] result() for MulticoreFuture ...
[16:19:37.923] result() for MulticoreFuture ... done
[16:19:37.923] result() for MulticoreFuture ... done
[16:19:37.923] result() for MulticoreFuture ...
[16:19:37.923] result() for MulticoreFuture ... done
[16:19:37.924] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:37.924] - nx: 2
[16:19:37.924] - relay: TRUE
[16:19:37.924] - stdout: TRUE
[16:19:37.924] - signal: TRUE
[16:19:37.925] - resignal: FALSE
[16:19:37.925] - force: TRUE
[16:19:37.925] - relayed: [n=2] FALSE, FALSE
[16:19:37.925] - queued futures: [n=2] FALSE, TRUE
[16:19:37.925]  - until=1
[16:19:37.925]  - relaying element #1
[16:19:37.925] result() for MulticoreFuture ...
[16:19:37.925] result() for MulticoreFuture ... done
[16:19:37.926] result() for MulticoreFuture ...
[16:19:37.926] result() for MulticoreFuture ... done
[16:19:37.926] result() for MulticoreFuture ...
[16:19:37.926] result() for MulticoreFuture ... done
[16:19:37.926] result() for MulticoreFuture ...
[16:19:37.926] result() for MulticoreFuture ... done
[16:19:37.926] - relayed: [n=2] TRUE, FALSE
[16:19:37.926] - queued futures: [n=2] TRUE, TRUE
[16:19:37.927] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:37.927]  length: 0 (resolved future 1)
[16:19:37.927] Relaying remaining futures
[16:19:37.927] signalConditionsASAP(NULL, pos=0) ...
[16:19:37.927] - nx: 2
[16:19:37.927] - relay: TRUE
[16:19:37.927] - stdout: TRUE
[16:19:37.927] - signal: TRUE
[16:19:37.928] - resignal: FALSE
[16:19:37.928] - force: TRUE
[16:19:37.928] - relayed: [n=2] TRUE, FALSE
[16:19:37.928] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:37.928]  - relaying element #2
[16:19:37.928] result() for MulticoreFuture ...
[16:19:37.928] result() for MulticoreFuture ... done
[16:19:37.929] result() for MulticoreFuture ...
[16:19:37.929] result() for MulticoreFuture ... done
[16:19:37.929] result() for MulticoreFuture ...
[16:19:37.929] result() for MulticoreFuture ... done
[16:19:37.929] result() for MulticoreFuture ...
[16:19:37.929] result() for MulticoreFuture ... done
[16:19:37.929] - relayed: [n=2] TRUE, TRUE
[16:19:37.929] - queued futures: [n=2] TRUE, TRUE
[16:19:37.929] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:19:37.930] resolve() on list ... DONE
[16:19:37.930] result() for MulticoreFuture ...
[16:19:37.930] result() for MulticoreFuture ... done
[16:19:37.930] result() for MulticoreFuture ...
[16:19:37.930] result() for MulticoreFuture ... done
[16:19:37.930] result() for MulticoreFuture ...
[16:19:37.930] result() for MulticoreFuture ... done
[16:19:37.930] result() for MulticoreFuture ...
[16:19:37.930] result() for MulticoreFuture ... done
[16:19:37.931]  - Number of value chunks collected: 2
[16:19:37.931] Resolving 2 futures (chunks) ... DONE
[16:19:37.931] Reducing values from 2 chunks ...
[16:19:37.931]  - Number of values collected after concatenation: 2
[16:19:37.931]  - Number of values expected: 2
[16:19:37.931] Reducing values from 2 chunks ... DONE
[16:19:37.931] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:19:37.932] future_lapply() ...
[16:19:37.936] Number of chunks: 2
[16:19:37.936] getGlobalsAndPackagesXApply() ...
[16:19:37.937]  - future.globals: TRUE
[16:19:37.937] getGlobalsAndPackages() ...
[16:19:37.937] Searching for globals...
[16:19:37.938] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:37.938] Searching for globals ... DONE
[16:19:37.939] Resolving globals: FALSE
[16:19:37.939] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:37.939] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:37.940] - globals: [1] ‘FUN’
[16:19:37.940] 
[16:19:37.940] getGlobalsAndPackages() ... DONE
[16:19:37.940]  - globals found/used: [n=1] ‘FUN’
[16:19:37.940]  - needed namespaces: [n=0] 
[16:19:37.940] Finding globals ... DONE
[16:19:37.940]  - use_args: TRUE
[16:19:37.940]  - Getting '...' globals ...
[16:19:37.941] resolve() on list ...
[16:19:37.941]  recursive: 0
[16:19:37.941]  length: 1
[16:19:37.941]  elements: ‘...’
[16:19:37.941]  length: 0 (resolved future 1)
[16:19:37.941] resolve() on list ... DONE
[16:19:37.941]    - '...' content: [n=0] 
[16:19:37.942] List of 1
[16:19:37.942]  $ ...: list()
[16:19:37.942]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:37.942]  - attr(*, "where")=List of 1
[16:19:37.942]   ..$ ...:<environment: 0x56356098d258> 
[16:19:37.942]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:37.942]  - attr(*, "resolved")= logi TRUE
[16:19:37.942]  - attr(*, "total_size")= num NA
[16:19:37.944]  - Getting '...' globals ... DONE
[16:19:37.945] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:37.945] List of 2
[16:19:37.945]  $ ...future.FUN:function (x)  
[16:19:37.945]  $ ...          : list()
[16:19:37.945]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:37.945]  - attr(*, "where")=List of 2
[16:19:37.945]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:37.945]   ..$ ...          :<environment: 0x56356098d258> 
[16:19:37.945]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:37.945]  - attr(*, "resolved")= logi FALSE
[16:19:37.945]  - attr(*, "total_size")= num 4720
[16:19:37.947] Packages to be attached in all futures: [n=0] 
[16:19:37.947] getGlobalsAndPackagesXApply() ... DONE
[16:19:37.948] Number of futures (= number of chunks): 2
[16:19:37.948] Launching 2 futures (chunks) ...
[16:19:37.948] Chunk #1 of 2 ...
[16:19:37.948]  - Finding globals in 'X' for chunk #1 ...
[16:19:37.948] getGlobalsAndPackages() ...
[16:19:37.948] Searching for globals...
[16:19:37.948] 
[16:19:37.949] Searching for globals ... DONE
[16:19:37.949] - globals: [0] <none>
[16:19:37.949] getGlobalsAndPackages() ... DONE
[16:19:37.950]    + additional globals found: [n=0] 
[16:19:37.950]    + additional namespaces needed: [n=0] 
[16:19:37.950]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:37.951]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:37.951]  - seeds: <none>
[16:19:37.951]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:37.951] getGlobalsAndPackages() ...
[16:19:37.951] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:37.951] Resolving globals: FALSE
[16:19:37.951] Tweak future expression to call with '...' arguments ...
[16:19:37.951] {
[16:19:37.951]     do.call(function(...) {
[16:19:37.951]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:37.951]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:37.951]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:37.951]             on.exit(options(oopts), add = TRUE)
[16:19:37.951]         }
[16:19:37.951]         {
[16:19:37.951]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:37.951]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:37.951]                 ...future.FUN(...future.X_jj, ...)
[16:19:37.951]             })
[16:19:37.951]         }
[16:19:37.951]     }, args = future.call.arguments)
[16:19:37.951] }
[16:19:37.952] Tweak future expression to call with '...' arguments ... DONE
[16:19:37.952] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:37.952] 
[16:19:37.952] getGlobalsAndPackages() ... DONE
[16:19:37.952] run() for ‘Future’ ...
[16:19:37.953] - state: ‘created’
[16:19:37.953] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:37.956] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:37.956] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:37.956]   - Field: ‘label’
[16:19:37.957]   - Field: ‘local’
[16:19:37.957]   - Field: ‘owner’
[16:19:37.957]   - Field: ‘envir’
[16:19:37.957]   - Field: ‘workers’
[16:19:37.957]   - Field: ‘packages’
[16:19:37.957]   - Field: ‘gc’
[16:19:37.957]   - Field: ‘job’
[16:19:37.957]   - Field: ‘conditions’
[16:19:37.957]   - Field: ‘expr’
[16:19:37.957]   - Field: ‘uuid’
[16:19:37.957]   - Field: ‘seed’
[16:19:37.958]   - Field: ‘version’
[16:19:37.958]   - Field: ‘result’
[16:19:37.958]   - Field: ‘asynchronous’
[16:19:37.958]   - Field: ‘calls’
[16:19:37.958]   - Field: ‘globals’
[16:19:37.958]   - Field: ‘stdout’
[16:19:37.958]   - Field: ‘earlySignal’
[16:19:37.958]   - Field: ‘lazy’
[16:19:37.958]   - Field: ‘state’
[16:19:37.958] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:37.958] - Launch lazy future ...
[16:19:37.959] Packages needed by the future expression (n = 0): <none>
[16:19:37.959] Packages needed by future strategies (n = 0): <none>
[16:19:37.959] {
[16:19:37.959]     {
[16:19:37.959]         {
[16:19:37.959]             ...future.startTime <- base::Sys.time()
[16:19:37.959]             {
[16:19:37.959]                 {
[16:19:37.959]                   {
[16:19:37.959]                     {
[16:19:37.959]                       base::local({
[16:19:37.959]                         has_future <- base::requireNamespace("future", 
[16:19:37.959]                           quietly = TRUE)
[16:19:37.959]                         if (has_future) {
[16:19:37.959]                           ns <- base::getNamespace("future")
[16:19:37.959]                           version <- ns[[".package"]][["version"]]
[16:19:37.959]                           if (is.null(version)) 
[16:19:37.959]                             version <- utils::packageVersion("future")
[16:19:37.959]                         }
[16:19:37.959]                         else {
[16:19:37.959]                           version <- NULL
[16:19:37.959]                         }
[16:19:37.959]                         if (!has_future || version < "1.8.0") {
[16:19:37.959]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:37.959]                             "", base::R.version$version.string), 
[16:19:37.959]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:37.959]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:37.959]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:37.959]                               "release", "version")], collapse = " "), 
[16:19:37.959]                             hostname = base::Sys.info()[["nodename"]])
[16:19:37.959]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:37.959]                             info)
[16:19:37.959]                           info <- base::paste(info, collapse = "; ")
[16:19:37.959]                           if (!has_future) {
[16:19:37.959]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:37.959]                               info)
[16:19:37.959]                           }
[16:19:37.959]                           else {
[16:19:37.959]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:37.959]                               info, version)
[16:19:37.959]                           }
[16:19:37.959]                           base::stop(msg)
[16:19:37.959]                         }
[16:19:37.959]                       })
[16:19:37.959]                     }
[16:19:37.959]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:37.959]                     base::options(mc.cores = 1L)
[16:19:37.959]                   }
[16:19:37.959]                   ...future.strategy.old <- future::plan("list")
[16:19:37.959]                   options(future.plan = NULL)
[16:19:37.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:37.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:37.959]                 }
[16:19:37.959]                 ...future.workdir <- getwd()
[16:19:37.959]             }
[16:19:37.959]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:37.959]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:37.959]         }
[16:19:37.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:37.959]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:37.959]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:37.959]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:37.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:37.959]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:37.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:37.959]             base::names(...future.oldOptions))
[16:19:37.959]     }
[16:19:37.959]     if (TRUE) {
[16:19:37.959]     }
[16:19:37.959]     else {
[16:19:37.959]         if (NA) {
[16:19:37.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:37.959]                 open = "w")
[16:19:37.959]         }
[16:19:37.959]         else {
[16:19:37.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:37.959]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:37.959]         }
[16:19:37.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:37.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:37.959]             base::sink(type = "output", split = FALSE)
[16:19:37.959]             base::close(...future.stdout)
[16:19:37.959]         }, add = TRUE)
[16:19:37.959]     }
[16:19:37.959]     ...future.frame <- base::sys.nframe()
[16:19:37.959]     ...future.conditions <- base::list()
[16:19:37.959]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:37.959]     if (FALSE) {
[16:19:37.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:37.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:37.959]     }
[16:19:37.959]     ...future.result <- base::tryCatch({
[16:19:37.959]         base::withCallingHandlers({
[16:19:37.959]             ...future.value <- base::withVisible(base::local({
[16:19:37.959]                 withCallingHandlers({
[16:19:37.959]                   {
[16:19:37.959]                     do.call(function(...) {
[16:19:37.959]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:37.959]                       if (!identical(...future.globals.maxSize.org, 
[16:19:37.959]                         ...future.globals.maxSize)) {
[16:19:37.959]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:37.959]                         on.exit(options(oopts), add = TRUE)
[16:19:37.959]                       }
[16:19:37.959]                       {
[16:19:37.959]                         lapply(seq_along(...future.elements_ii), 
[16:19:37.959]                           FUN = function(jj) {
[16:19:37.959]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:37.959]                             ...future.FUN(...future.X_jj, ...)
[16:19:37.959]                           })
[16:19:37.959]                       }
[16:19:37.959]                     }, args = future.call.arguments)
[16:19:37.959]                   }
[16:19:37.959]                 }, immediateCondition = function(cond) {
[16:19:37.959]                   save_rds <- function (object, pathname, ...) 
[16:19:37.959]                   {
[16:19:37.959]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:37.959]                     if (file_test("-f", pathname_tmp)) {
[16:19:37.959]                       fi_tmp <- file.info(pathname_tmp)
[16:19:37.959]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:37.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:37.959]                         fi_tmp[["mtime"]])
[16:19:37.959]                     }
[16:19:37.959]                     tryCatch({
[16:19:37.959]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:37.959]                     }, error = function(ex) {
[16:19:37.959]                       msg <- conditionMessage(ex)
[16:19:37.959]                       fi_tmp <- file.info(pathname_tmp)
[16:19:37.959]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:37.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:37.959]                         fi_tmp[["mtime"]], msg)
[16:19:37.959]                       ex$message <- msg
[16:19:37.959]                       stop(ex)
[16:19:37.959]                     })
[16:19:37.959]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:37.959]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:37.959]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:37.959]                       fi_tmp <- file.info(pathname_tmp)
[16:19:37.959]                       fi <- file.info(pathname)
[16:19:37.959]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:37.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:37.959]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:37.959]                         fi[["size"]], fi[["mtime"]])
[16:19:37.959]                       stop(msg)
[16:19:37.959]                     }
[16:19:37.959]                     invisible(pathname)
[16:19:37.959]                   }
[16:19:37.959]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:37.959]                     rootPath = tempdir()) 
[16:19:37.959]                   {
[16:19:37.959]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:37.959]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:37.959]                       tmpdir = path, fileext = ".rds")
[16:19:37.959]                     save_rds(obj, file)
[16:19:37.959]                   }
[16:19:37.959]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPcako/.future/immediateConditions")
[16:19:37.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:37.959]                   {
[16:19:37.959]                     inherits <- base::inherits
[16:19:37.959]                     invokeRestart <- base::invokeRestart
[16:19:37.959]                     is.null <- base::is.null
[16:19:37.959]                     muffled <- FALSE
[16:19:37.959]                     if (inherits(cond, "message")) {
[16:19:37.959]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:37.959]                       if (muffled) 
[16:19:37.959]                         invokeRestart("muffleMessage")
[16:19:37.959]                     }
[16:19:37.959]                     else if (inherits(cond, "warning")) {
[16:19:37.959]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:37.959]                       if (muffled) 
[16:19:37.959]                         invokeRestart("muffleWarning")
[16:19:37.959]                     }
[16:19:37.959]                     else if (inherits(cond, "condition")) {
[16:19:37.959]                       if (!is.null(pattern)) {
[16:19:37.959]                         computeRestarts <- base::computeRestarts
[16:19:37.959]                         grepl <- base::grepl
[16:19:37.959]                         restarts <- computeRestarts(cond)
[16:19:37.959]                         for (restart in restarts) {
[16:19:37.959]                           name <- restart$name
[16:19:37.959]                           if (is.null(name)) 
[16:19:37.959]                             next
[16:19:37.959]                           if (!grepl(pattern, name)) 
[16:19:37.959]                             next
[16:19:37.959]                           invokeRestart(restart)
[16:19:37.959]                           muffled <- TRUE
[16:19:37.959]                           break
[16:19:37.959]                         }
[16:19:37.959]                       }
[16:19:37.959]                     }
[16:19:37.959]                     invisible(muffled)
[16:19:37.959]                   }
[16:19:37.959]                   muffleCondition(cond)
[16:19:37.959]                 })
[16:19:37.959]             }))
[16:19:37.959]             future::FutureResult(value = ...future.value$value, 
[16:19:37.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:37.959]                   ...future.rng), globalenv = if (FALSE) 
[16:19:37.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:37.959]                     ...future.globalenv.names))
[16:19:37.959]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:37.959]         }, condition = base::local({
[16:19:37.959]             c <- base::c
[16:19:37.959]             inherits <- base::inherits
[16:19:37.959]             invokeRestart <- base::invokeRestart
[16:19:37.959]             length <- base::length
[16:19:37.959]             list <- base::list
[16:19:37.959]             seq.int <- base::seq.int
[16:19:37.959]             signalCondition <- base::signalCondition
[16:19:37.959]             sys.calls <- base::sys.calls
[16:19:37.959]             `[[` <- base::`[[`
[16:19:37.959]             `+` <- base::`+`
[16:19:37.959]             `<<-` <- base::`<<-`
[16:19:37.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:37.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:37.959]                   3L)]
[16:19:37.959]             }
[16:19:37.959]             function(cond) {
[16:19:37.959]                 is_error <- inherits(cond, "error")
[16:19:37.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:37.959]                   NULL)
[16:19:37.959]                 if (is_error) {
[16:19:37.959]                   sessionInformation <- function() {
[16:19:37.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:37.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:37.959]                       search = base::search(), system = base::Sys.info())
[16:19:37.959]                   }
[16:19:37.959]                   ...future.conditions[[length(...future.conditions) + 
[16:19:37.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:37.959]                     cond$call), session = sessionInformation(), 
[16:19:37.959]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:37.959]                   signalCondition(cond)
[16:19:37.959]                 }
[16:19:37.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:37.959]                 "immediateCondition"))) {
[16:19:37.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:37.959]                   ...future.conditions[[length(...future.conditions) + 
[16:19:37.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:37.959]                   if (TRUE && !signal) {
[16:19:37.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:37.959]                     {
[16:19:37.959]                       inherits <- base::inherits
[16:19:37.959]                       invokeRestart <- base::invokeRestart
[16:19:37.959]                       is.null <- base::is.null
[16:19:37.959]                       muffled <- FALSE
[16:19:37.959]                       if (inherits(cond, "message")) {
[16:19:37.959]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:37.959]                         if (muffled) 
[16:19:37.959]                           invokeRestart("muffleMessage")
[16:19:37.959]                       }
[16:19:37.959]                       else if (inherits(cond, "warning")) {
[16:19:37.959]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:37.959]                         if (muffled) 
[16:19:37.959]                           invokeRestart("muffleWarning")
[16:19:37.959]                       }
[16:19:37.959]                       else if (inherits(cond, "condition")) {
[16:19:37.959]                         if (!is.null(pattern)) {
[16:19:37.959]                           computeRestarts <- base::computeRestarts
[16:19:37.959]                           grepl <- base::grepl
[16:19:37.959]                           restarts <- computeRestarts(cond)
[16:19:37.959]                           for (restart in restarts) {
[16:19:37.959]                             name <- restart$name
[16:19:37.959]                             if (is.null(name)) 
[16:19:37.959]                               next
[16:19:37.959]                             if (!grepl(pattern, name)) 
[16:19:37.959]                               next
[16:19:37.959]                             invokeRestart(restart)
[16:19:37.959]                             muffled <- TRUE
[16:19:37.959]                             break
[16:19:37.959]                           }
[16:19:37.959]                         }
[16:19:37.959]                       }
[16:19:37.959]                       invisible(muffled)
[16:19:37.959]                     }
[16:19:37.959]                     muffleCondition(cond, pattern = "^muffle")
[16:19:37.959]                   }
[16:19:37.959]                 }
[16:19:37.959]                 else {
[16:19:37.959]                   if (TRUE) {
[16:19:37.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:37.959]                     {
[16:19:37.959]                       inherits <- base::inherits
[16:19:37.959]                       invokeRestart <- base::invokeRestart
[16:19:37.959]                       is.null <- base::is.null
[16:19:37.959]                       muffled <- FALSE
[16:19:37.959]                       if (inherits(cond, "message")) {
[16:19:37.959]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:37.959]                         if (muffled) 
[16:19:37.959]                           invokeRestart("muffleMessage")
[16:19:37.959]                       }
[16:19:37.959]                       else if (inherits(cond, "warning")) {
[16:19:37.959]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:37.959]                         if (muffled) 
[16:19:37.959]                           invokeRestart("muffleWarning")
[16:19:37.959]                       }
[16:19:37.959]                       else if (inherits(cond, "condition")) {
[16:19:37.959]                         if (!is.null(pattern)) {
[16:19:37.959]                           computeRestarts <- base::computeRestarts
[16:19:37.959]                           grepl <- base::grepl
[16:19:37.959]                           restarts <- computeRestarts(cond)
[16:19:37.959]                           for (restart in restarts) {
[16:19:37.959]                             name <- restart$name
[16:19:37.959]                             if (is.null(name)) 
[16:19:37.959]                               next
[16:19:37.959]                             if (!grepl(pattern, name)) 
[16:19:37.959]                               next
[16:19:37.959]                             invokeRestart(restart)
[16:19:37.959]                             muffled <- TRUE
[16:19:37.959]                             break
[16:19:37.959]                           }
[16:19:37.959]                         }
[16:19:37.959]                       }
[16:19:37.959]                       invisible(muffled)
[16:19:37.959]                     }
[16:19:37.959]                     muffleCondition(cond, pattern = "^muffle")
[16:19:37.959]                   }
[16:19:37.959]                 }
[16:19:37.959]             }
[16:19:37.959]         }))
[16:19:37.959]     }, error = function(ex) {
[16:19:37.959]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:37.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:37.959]                 ...future.rng), started = ...future.startTime, 
[16:19:37.959]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:37.959]             version = "1.8"), class = "FutureResult")
[16:19:37.959]     }, finally = {
[16:19:37.959]         if (!identical(...future.workdir, getwd())) 
[16:19:37.959]             setwd(...future.workdir)
[16:19:37.959]         {
[16:19:37.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:37.959]                 ...future.oldOptions$nwarnings <- NULL
[16:19:37.959]             }
[16:19:37.959]             base::options(...future.oldOptions)
[16:19:37.959]             if (.Platform$OS.type == "windows") {
[16:19:37.959]                 old_names <- names(...future.oldEnvVars)
[16:19:37.959]                 envs <- base::Sys.getenv()
[16:19:37.959]                 names <- names(envs)
[16:19:37.959]                 common <- intersect(names, old_names)
[16:19:37.959]                 added <- setdiff(names, old_names)
[16:19:37.959]                 removed <- setdiff(old_names, names)
[16:19:37.959]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:37.959]                   envs[common]]
[16:19:37.959]                 NAMES <- toupper(changed)
[16:19:37.959]                 args <- list()
[16:19:37.959]                 for (kk in seq_along(NAMES)) {
[16:19:37.959]                   name <- changed[[kk]]
[16:19:37.959]                   NAME <- NAMES[[kk]]
[16:19:37.959]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:37.959]                     next
[16:19:37.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:37.959]                 }
[16:19:37.959]                 NAMES <- toupper(added)
[16:19:37.959]                 for (kk in seq_along(NAMES)) {
[16:19:37.959]                   name <- added[[kk]]
[16:19:37.959]                   NAME <- NAMES[[kk]]
[16:19:37.959]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:37.959]                     next
[16:19:37.959]                   args[[name]] <- ""
[16:19:37.959]                 }
[16:19:37.959]                 NAMES <- toupper(removed)
[16:19:37.959]                 for (kk in seq_along(NAMES)) {
[16:19:37.959]                   name <- removed[[kk]]
[16:19:37.959]                   NAME <- NAMES[[kk]]
[16:19:37.959]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:37.959]                     next
[16:19:37.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:37.959]                 }
[16:19:37.959]                 if (length(args) > 0) 
[16:19:37.959]                   base::do.call(base::Sys.setenv, args = args)
[16:19:37.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:37.959]             }
[16:19:37.959]             else {
[16:19:37.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:37.959]             }
[16:19:37.959]             {
[16:19:37.959]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:37.959]                   0L) {
[16:19:37.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:37.959]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:37.959]                   base::options(opts)
[16:19:37.959]                 }
[16:19:37.959]                 {
[16:19:37.959]                   {
[16:19:37.959]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:37.959]                     NULL
[16:19:37.959]                   }
[16:19:37.959]                   options(future.plan = NULL)
[16:19:37.959]                   if (is.na(NA_character_)) 
[16:19:37.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:37.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:37.959]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:37.959]                     .init = FALSE)
[16:19:37.959]                 }
[16:19:37.959]             }
[16:19:37.959]         }
[16:19:37.959]     })
[16:19:37.959]     if (FALSE) {
[16:19:37.959]         base::sink(type = "output", split = FALSE)
[16:19:37.959]         if (NA) {
[16:19:37.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:37.959]         }
[16:19:37.959]         else {
[16:19:37.959]             ...future.result["stdout"] <- base::list(NULL)
[16:19:37.959]         }
[16:19:37.959]         base::close(...future.stdout)
[16:19:37.959]         ...future.stdout <- NULL
[16:19:37.959]     }
[16:19:37.959]     ...future.result$conditions <- ...future.conditions
[16:19:37.959]     ...future.result$finished <- base::Sys.time()
[16:19:37.959]     ...future.result
[16:19:37.959] }
[16:19:37.961] assign_globals() ...
[16:19:37.962] List of 5
[16:19:37.962]  $ ...future.FUN            :function (x)  
[16:19:37.962]  $ future.call.arguments    : list()
[16:19:37.962]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:37.962]  $ ...future.elements_ii    :List of 1
[16:19:37.962]   ..$ : int 1
[16:19:37.962]  $ ...future.seeds_ii       : NULL
[16:19:37.962]  $ ...future.globals.maxSize: NULL
[16:19:37.962]  - attr(*, "where")=List of 5
[16:19:37.962]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:37.962]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:37.962]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:37.962]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:37.962]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:37.962]  - attr(*, "resolved")= logi FALSE
[16:19:37.962]  - attr(*, "total_size")= num 4720
[16:19:37.962]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:37.962]  - attr(*, "already-done")= logi TRUE
[16:19:37.966] - reassign environment for ‘...future.FUN’
[16:19:37.966] - copied ‘...future.FUN’ to environment
[16:19:37.966] - copied ‘future.call.arguments’ to environment
[16:19:37.966] - copied ‘...future.elements_ii’ to environment
[16:19:37.966] - copied ‘...future.seeds_ii’ to environment
[16:19:37.967] - copied ‘...future.globals.maxSize’ to environment
[16:19:37.967] assign_globals() ... done
[16:19:37.967] requestCore(): workers = 2
[16:19:37.969] MulticoreFuture started
[16:19:37.969] - Launch lazy future ... done
[16:19:37.969] run() for ‘MulticoreFuture’ ... done
[16:19:37.970] Created future:
[16:19:37.970] plan(): Setting new future strategy stack:
[16:19:37.970] List of future strategies:
[16:19:37.970] 1. sequential:
[16:19:37.970]    - args: function (..., envir = parent.frame())
[16:19:37.970]    - tweaked: FALSE
[16:19:37.970]    - call: NULL
[16:19:37.971] plan(): nbrOfWorkers() = 1
[16:19:37.970] MulticoreFuture:
[16:19:37.970] Label: ‘future_lapply-1’
[16:19:37.970] Expression:
[16:19:37.970] {
[16:19:37.970]     do.call(function(...) {
[16:19:37.970]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:37.970]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:37.970]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:37.970]             on.exit(options(oopts), add = TRUE)
[16:19:37.970]         }
[16:19:37.970]         {
[16:19:37.970]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:37.970]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:37.970]                 ...future.FUN(...future.X_jj, ...)
[16:19:37.970]             })
[16:19:37.970]         }
[16:19:37.970]     }, args = future.call.arguments)
[16:19:37.970] }
[16:19:37.970] Lazy evaluation: FALSE
[16:19:37.970] Asynchronous evaluation: TRUE
[16:19:37.970] Local evaluation: TRUE
[16:19:37.970] Environment: R_GlobalEnv
[16:19:37.970] Capture standard output: NA
[16:19:37.970] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:37.970] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:37.970] Packages: <none>
[16:19:37.970] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:37.970] Resolved: FALSE
[16:19:37.970] Value: <not collected>
[16:19:37.970] Conditions captured: <none>
[16:19:37.970] Early signaling: FALSE
[16:19:37.970] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:37.970] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:37.983] Chunk #1 of 2 ... DONE
[16:19:37.983] Chunk #2 of 2 ...
[16:19:37.983]  - Finding globals in 'X' for chunk #2 ...
[16:19:37.983] getGlobalsAndPackages() ...
[16:19:37.983] Searching for globals...
[16:19:37.984] 
[16:19:37.984] Searching for globals ... DONE
[16:19:37.984] - globals: [0] <none>
[16:19:37.984] getGlobalsAndPackages() ... DONE
[16:19:37.984]    + additional globals found: [n=0] 
[16:19:37.985]    + additional namespaces needed: [n=0] 
[16:19:37.985]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:37.985]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:37.985]  - seeds: <none>
[16:19:37.985]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:37.985] getGlobalsAndPackages() ...
[16:19:37.986] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:37.986] Resolving globals: FALSE
[16:19:37.986] Tweak future expression to call with '...' arguments ...
[16:19:37.986] {
[16:19:37.986]     do.call(function(...) {
[16:19:37.986]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:37.986]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:37.986]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:37.986]             on.exit(options(oopts), add = TRUE)
[16:19:37.986]         }
[16:19:37.986]         {
[16:19:37.986]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:37.986]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:37.986]                 ...future.FUN(...future.X_jj, ...)
[16:19:37.986]             })
[16:19:37.986]         }
[16:19:37.986]     }, args = future.call.arguments)
[16:19:37.986] }
[16:19:37.986] Tweak future expression to call with '...' arguments ... DONE
[16:19:37.987] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:37.987] 
[16:19:37.988] getGlobalsAndPackages() ... DONE
[16:19:37.988] run() for ‘Future’ ...
[16:19:37.988] - state: ‘created’
[16:19:37.989] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:37.994] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:37.994] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:37.994]   - Field: ‘label’
[16:19:37.994]   - Field: ‘local’
[16:19:37.995]   - Field: ‘owner’
[16:19:37.995]   - Field: ‘envir’
[16:19:37.995]   - Field: ‘workers’
[16:19:37.995]   - Field: ‘packages’
[16:19:37.995]   - Field: ‘gc’
[16:19:37.995]   - Field: ‘job’
[16:19:37.995]   - Field: ‘conditions’
[16:19:37.996]   - Field: ‘expr’
[16:19:37.996]   - Field: ‘uuid’
[16:19:37.996]   - Field: ‘seed’
[16:19:37.996]   - Field: ‘version’
[16:19:37.996]   - Field: ‘result’
[16:19:37.996]   - Field: ‘asynchronous’
[16:19:37.997]   - Field: ‘calls’
[16:19:38.000]   - Field: ‘globals’
[16:19:38.000]   - Field: ‘stdout’
[16:19:38.000]   - Field: ‘earlySignal’
[16:19:38.001]   - Field: ‘lazy’
[16:19:38.001]   - Field: ‘state’
[16:19:38.001] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:38.002] - Launch lazy future ...
[16:19:38.002] Packages needed by the future expression (n = 0): <none>
[16:19:38.003] Packages needed by future strategies (n = 0): <none>
[16:19:38.004] {
[16:19:38.004]     {
[16:19:38.004]         {
[16:19:38.004]             ...future.startTime <- base::Sys.time()
[16:19:38.004]             {
[16:19:38.004]                 {
[16:19:38.004]                   {
[16:19:38.004]                     {
[16:19:38.004]                       base::local({
[16:19:38.004]                         has_future <- base::requireNamespace("future", 
[16:19:38.004]                           quietly = TRUE)
[16:19:38.004]                         if (has_future) {
[16:19:38.004]                           ns <- base::getNamespace("future")
[16:19:38.004]                           version <- ns[[".package"]][["version"]]
[16:19:38.004]                           if (is.null(version)) 
[16:19:38.004]                             version <- utils::packageVersion("future")
[16:19:38.004]                         }
[16:19:38.004]                         else {
[16:19:38.004]                           version <- NULL
[16:19:38.004]                         }
[16:19:38.004]                         if (!has_future || version < "1.8.0") {
[16:19:38.004]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:38.004]                             "", base::R.version$version.string), 
[16:19:38.004]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:38.004]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:38.004]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:38.004]                               "release", "version")], collapse = " "), 
[16:19:38.004]                             hostname = base::Sys.info()[["nodename"]])
[16:19:38.004]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:38.004]                             info)
[16:19:38.004]                           info <- base::paste(info, collapse = "; ")
[16:19:38.004]                           if (!has_future) {
[16:19:38.004]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:38.004]                               info)
[16:19:38.004]                           }
[16:19:38.004]                           else {
[16:19:38.004]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:38.004]                               info, version)
[16:19:38.004]                           }
[16:19:38.004]                           base::stop(msg)
[16:19:38.004]                         }
[16:19:38.004]                       })
[16:19:38.004]                     }
[16:19:38.004]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:38.004]                     base::options(mc.cores = 1L)
[16:19:38.004]                   }
[16:19:38.004]                   ...future.strategy.old <- future::plan("list")
[16:19:38.004]                   options(future.plan = NULL)
[16:19:38.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:38.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:38.004]                 }
[16:19:38.004]                 ...future.workdir <- getwd()
[16:19:38.004]             }
[16:19:38.004]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:38.004]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:38.004]         }
[16:19:38.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:38.004]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:38.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:38.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:38.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:38.004]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:38.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:38.004]             base::names(...future.oldOptions))
[16:19:38.004]     }
[16:19:38.004]     if (TRUE) {
[16:19:38.004]     }
[16:19:38.004]     else {
[16:19:38.004]         if (NA) {
[16:19:38.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:38.004]                 open = "w")
[16:19:38.004]         }
[16:19:38.004]         else {
[16:19:38.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:38.004]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:38.004]         }
[16:19:38.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:38.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:38.004]             base::sink(type = "output", split = FALSE)
[16:19:38.004]             base::close(...future.stdout)
[16:19:38.004]         }, add = TRUE)
[16:19:38.004]     }
[16:19:38.004]     ...future.frame <- base::sys.nframe()
[16:19:38.004]     ...future.conditions <- base::list()
[16:19:38.004]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:38.004]     if (FALSE) {
[16:19:38.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:38.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:38.004]     }
[16:19:38.004]     ...future.result <- base::tryCatch({
[16:19:38.004]         base::withCallingHandlers({
[16:19:38.004]             ...future.value <- base::withVisible(base::local({
[16:19:38.004]                 withCallingHandlers({
[16:19:38.004]                   {
[16:19:38.004]                     do.call(function(...) {
[16:19:38.004]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:38.004]                       if (!identical(...future.globals.maxSize.org, 
[16:19:38.004]                         ...future.globals.maxSize)) {
[16:19:38.004]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:38.004]                         on.exit(options(oopts), add = TRUE)
[16:19:38.004]                       }
[16:19:38.004]                       {
[16:19:38.004]                         lapply(seq_along(...future.elements_ii), 
[16:19:38.004]                           FUN = function(jj) {
[16:19:38.004]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:38.004]                             ...future.FUN(...future.X_jj, ...)
[16:19:38.004]                           })
[16:19:38.004]                       }
[16:19:38.004]                     }, args = future.call.arguments)
[16:19:38.004]                   }
[16:19:38.004]                 }, immediateCondition = function(cond) {
[16:19:38.004]                   save_rds <- function (object, pathname, ...) 
[16:19:38.004]                   {
[16:19:38.004]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:38.004]                     if (file_test("-f", pathname_tmp)) {
[16:19:38.004]                       fi_tmp <- file.info(pathname_tmp)
[16:19:38.004]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:38.004]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:38.004]                         fi_tmp[["mtime"]])
[16:19:38.004]                     }
[16:19:38.004]                     tryCatch({
[16:19:38.004]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:38.004]                     }, error = function(ex) {
[16:19:38.004]                       msg <- conditionMessage(ex)
[16:19:38.004]                       fi_tmp <- file.info(pathname_tmp)
[16:19:38.004]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:38.004]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:38.004]                         fi_tmp[["mtime"]], msg)
[16:19:38.004]                       ex$message <- msg
[16:19:38.004]                       stop(ex)
[16:19:38.004]                     })
[16:19:38.004]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:38.004]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:38.004]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:38.004]                       fi_tmp <- file.info(pathname_tmp)
[16:19:38.004]                       fi <- file.info(pathname)
[16:19:38.004]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:38.004]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:38.004]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:38.004]                         fi[["size"]], fi[["mtime"]])
[16:19:38.004]                       stop(msg)
[16:19:38.004]                     }
[16:19:38.004]                     invisible(pathname)
[16:19:38.004]                   }
[16:19:38.004]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:38.004]                     rootPath = tempdir()) 
[16:19:38.004]                   {
[16:19:38.004]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:38.004]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:38.004]                       tmpdir = path, fileext = ".rds")
[16:19:38.004]                     save_rds(obj, file)
[16:19:38.004]                   }
[16:19:38.004]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPcako/.future/immediateConditions")
[16:19:38.004]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:38.004]                   {
[16:19:38.004]                     inherits <- base::inherits
[16:19:38.004]                     invokeRestart <- base::invokeRestart
[16:19:38.004]                     is.null <- base::is.null
[16:19:38.004]                     muffled <- FALSE
[16:19:38.004]                     if (inherits(cond, "message")) {
[16:19:38.004]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:38.004]                       if (muffled) 
[16:19:38.004]                         invokeRestart("muffleMessage")
[16:19:38.004]                     }
[16:19:38.004]                     else if (inherits(cond, "warning")) {
[16:19:38.004]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:38.004]                       if (muffled) 
[16:19:38.004]                         invokeRestart("muffleWarning")
[16:19:38.004]                     }
[16:19:38.004]                     else if (inherits(cond, "condition")) {
[16:19:38.004]                       if (!is.null(pattern)) {
[16:19:38.004]                         computeRestarts <- base::computeRestarts
[16:19:38.004]                         grepl <- base::grepl
[16:19:38.004]                         restarts <- computeRestarts(cond)
[16:19:38.004]                         for (restart in restarts) {
[16:19:38.004]                           name <- restart$name
[16:19:38.004]                           if (is.null(name)) 
[16:19:38.004]                             next
[16:19:38.004]                           if (!grepl(pattern, name)) 
[16:19:38.004]                             next
[16:19:38.004]                           invokeRestart(restart)
[16:19:38.004]                           muffled <- TRUE
[16:19:38.004]                           break
[16:19:38.004]                         }
[16:19:38.004]                       }
[16:19:38.004]                     }
[16:19:38.004]                     invisible(muffled)
[16:19:38.004]                   }
[16:19:38.004]                   muffleCondition(cond)
[16:19:38.004]                 })
[16:19:38.004]             }))
[16:19:38.004]             future::FutureResult(value = ...future.value$value, 
[16:19:38.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:38.004]                   ...future.rng), globalenv = if (FALSE) 
[16:19:38.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:38.004]                     ...future.globalenv.names))
[16:19:38.004]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:38.004]         }, condition = base::local({
[16:19:38.004]             c <- base::c
[16:19:38.004]             inherits <- base::inherits
[16:19:38.004]             invokeRestart <- base::invokeRestart
[16:19:38.004]             length <- base::length
[16:19:38.004]             list <- base::list
[16:19:38.004]             seq.int <- base::seq.int
[16:19:38.004]             signalCondition <- base::signalCondition
[16:19:38.004]             sys.calls <- base::sys.calls
[16:19:38.004]             `[[` <- base::`[[`
[16:19:38.004]             `+` <- base::`+`
[16:19:38.004]             `<<-` <- base::`<<-`
[16:19:38.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:38.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:38.004]                   3L)]
[16:19:38.004]             }
[16:19:38.004]             function(cond) {
[16:19:38.004]                 is_error <- inherits(cond, "error")
[16:19:38.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:38.004]                   NULL)
[16:19:38.004]                 if (is_error) {
[16:19:38.004]                   sessionInformation <- function() {
[16:19:38.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:38.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:38.004]                       search = base::search(), system = base::Sys.info())
[16:19:38.004]                   }
[16:19:38.004]                   ...future.conditions[[length(...future.conditions) + 
[16:19:38.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:38.004]                     cond$call), session = sessionInformation(), 
[16:19:38.004]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:38.004]                   signalCondition(cond)
[16:19:38.004]                 }
[16:19:38.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:38.004]                 "immediateCondition"))) {
[16:19:38.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:38.004]                   ...future.conditions[[length(...future.conditions) + 
[16:19:38.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:38.004]                   if (TRUE && !signal) {
[16:19:38.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:38.004]                     {
[16:19:38.004]                       inherits <- base::inherits
[16:19:38.004]                       invokeRestart <- base::invokeRestart
[16:19:38.004]                       is.null <- base::is.null
[16:19:38.004]                       muffled <- FALSE
[16:19:38.004]                       if (inherits(cond, "message")) {
[16:19:38.004]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:38.004]                         if (muffled) 
[16:19:38.004]                           invokeRestart("muffleMessage")
[16:19:38.004]                       }
[16:19:38.004]                       else if (inherits(cond, "warning")) {
[16:19:38.004]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:38.004]                         if (muffled) 
[16:19:38.004]                           invokeRestart("muffleWarning")
[16:19:38.004]                       }
[16:19:38.004]                       else if (inherits(cond, "condition")) {
[16:19:38.004]                         if (!is.null(pattern)) {
[16:19:38.004]                           computeRestarts <- base::computeRestarts
[16:19:38.004]                           grepl <- base::grepl
[16:19:38.004]                           restarts <- computeRestarts(cond)
[16:19:38.004]                           for (restart in restarts) {
[16:19:38.004]                             name <- restart$name
[16:19:38.004]                             if (is.null(name)) 
[16:19:38.004]                               next
[16:19:38.004]                             if (!grepl(pattern, name)) 
[16:19:38.004]                               next
[16:19:38.004]                             invokeRestart(restart)
[16:19:38.004]                             muffled <- TRUE
[16:19:38.004]                             break
[16:19:38.004]                           }
[16:19:38.004]                         }
[16:19:38.004]                       }
[16:19:38.004]                       invisible(muffled)
[16:19:38.004]                     }
[16:19:38.004]                     muffleCondition(cond, pattern = "^muffle")
[16:19:38.004]                   }
[16:19:38.004]                 }
[16:19:38.004]                 else {
[16:19:38.004]                   if (TRUE) {
[16:19:38.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:38.004]                     {
[16:19:38.004]                       inherits <- base::inherits
[16:19:38.004]                       invokeRestart <- base::invokeRestart
[16:19:38.004]                       is.null <- base::is.null
[16:19:38.004]                       muffled <- FALSE
[16:19:38.004]                       if (inherits(cond, "message")) {
[16:19:38.004]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:38.004]                         if (muffled) 
[16:19:38.004]                           invokeRestart("muffleMessage")
[16:19:38.004]                       }
[16:19:38.004]                       else if (inherits(cond, "warning")) {
[16:19:38.004]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:38.004]                         if (muffled) 
[16:19:38.004]                           invokeRestart("muffleWarning")
[16:19:38.004]                       }
[16:19:38.004]                       else if (inherits(cond, "condition")) {
[16:19:38.004]                         if (!is.null(pattern)) {
[16:19:38.004]                           computeRestarts <- base::computeRestarts
[16:19:38.004]                           grepl <- base::grepl
[16:19:38.004]                           restarts <- computeRestarts(cond)
[16:19:38.004]                           for (restart in restarts) {
[16:19:38.004]                             name <- restart$name
[16:19:38.004]                             if (is.null(name)) 
[16:19:38.004]                               next
[16:19:38.004]                             if (!grepl(pattern, name)) 
[16:19:38.004]                               next
[16:19:38.004]                             invokeRestart(restart)
[16:19:38.004]                             muffled <- TRUE
[16:19:38.004]                             break
[16:19:38.004]                           }
[16:19:38.004]                         }
[16:19:38.004]                       }
[16:19:38.004]                       invisible(muffled)
[16:19:38.004]                     }
[16:19:38.004]                     muffleCondition(cond, pattern = "^muffle")
[16:19:38.004]                   }
[16:19:38.004]                 }
[16:19:38.004]             }
[16:19:38.004]         }))
[16:19:38.004]     }, error = function(ex) {
[16:19:38.004]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:38.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:38.004]                 ...future.rng), started = ...future.startTime, 
[16:19:38.004]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:38.004]             version = "1.8"), class = "FutureResult")
[16:19:38.004]     }, finally = {
[16:19:38.004]         if (!identical(...future.workdir, getwd())) 
[16:19:38.004]             setwd(...future.workdir)
[16:19:38.004]         {
[16:19:38.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:38.004]                 ...future.oldOptions$nwarnings <- NULL
[16:19:38.004]             }
[16:19:38.004]             base::options(...future.oldOptions)
[16:19:38.004]             if (.Platform$OS.type == "windows") {
[16:19:38.004]                 old_names <- names(...future.oldEnvVars)
[16:19:38.004]                 envs <- base::Sys.getenv()
[16:19:38.004]                 names <- names(envs)
[16:19:38.004]                 common <- intersect(names, old_names)
[16:19:38.004]                 added <- setdiff(names, old_names)
[16:19:38.004]                 removed <- setdiff(old_names, names)
[16:19:38.004]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:38.004]                   envs[common]]
[16:19:38.004]                 NAMES <- toupper(changed)
[16:19:38.004]                 args <- list()
[16:19:38.004]                 for (kk in seq_along(NAMES)) {
[16:19:38.004]                   name <- changed[[kk]]
[16:19:38.004]                   NAME <- NAMES[[kk]]
[16:19:38.004]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:38.004]                     next
[16:19:38.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:38.004]                 }
[16:19:38.004]                 NAMES <- toupper(added)
[16:19:38.004]                 for (kk in seq_along(NAMES)) {
[16:19:38.004]                   name <- added[[kk]]
[16:19:38.004]                   NAME <- NAMES[[kk]]
[16:19:38.004]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:38.004]                     next
[16:19:38.004]                   args[[name]] <- ""
[16:19:38.004]                 }
[16:19:38.004]                 NAMES <- toupper(removed)
[16:19:38.004]                 for (kk in seq_along(NAMES)) {
[16:19:38.004]                   name <- removed[[kk]]
[16:19:38.004]                   NAME <- NAMES[[kk]]
[16:19:38.004]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:38.004]                     next
[16:19:38.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:38.004]                 }
[16:19:38.004]                 if (length(args) > 0) 
[16:19:38.004]                   base::do.call(base::Sys.setenv, args = args)
[16:19:38.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:38.004]             }
[16:19:38.004]             else {
[16:19:38.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:38.004]             }
[16:19:38.004]             {
[16:19:38.004]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:38.004]                   0L) {
[16:19:38.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:38.004]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:38.004]                   base::options(opts)
[16:19:38.004]                 }
[16:19:38.004]                 {
[16:19:38.004]                   {
[16:19:38.004]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:38.004]                     NULL
[16:19:38.004]                   }
[16:19:38.004]                   options(future.plan = NULL)
[16:19:38.004]                   if (is.na(NA_character_)) 
[16:19:38.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:38.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:38.004]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:38.004]                     .init = FALSE)
[16:19:38.004]                 }
[16:19:38.004]             }
[16:19:38.004]         }
[16:19:38.004]     })
[16:19:38.004]     if (FALSE) {
[16:19:38.004]         base::sink(type = "output", split = FALSE)
[16:19:38.004]         if (NA) {
[16:19:38.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:38.004]         }
[16:19:38.004]         else {
[16:19:38.004]             ...future.result["stdout"] <- base::list(NULL)
[16:19:38.004]         }
[16:19:38.004]         base::close(...future.stdout)
[16:19:38.004]         ...future.stdout <- NULL
[16:19:38.004]     }
[16:19:38.004]     ...future.result$conditions <- ...future.conditions
[16:19:38.004]     ...future.result$finished <- base::Sys.time()
[16:19:38.004]     ...future.result
[16:19:38.004] }
[16:19:38.007] assign_globals() ...
[16:19:38.007] List of 5
[16:19:38.007]  $ ...future.FUN            :function (x)  
[16:19:38.007]  $ future.call.arguments    : list()
[16:19:38.007]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:38.007]  $ ...future.elements_ii    :List of 1
[16:19:38.007]   ..$ : int 0
[16:19:38.007]  $ ...future.seeds_ii       : NULL
[16:19:38.007]  $ ...future.globals.maxSize: NULL
[16:19:38.007]  - attr(*, "where")=List of 5
[16:19:38.007]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:38.007]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[16:19:38.007]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:38.007]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:38.007]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:38.007]  - attr(*, "resolved")= logi FALSE
[16:19:38.007]  - attr(*, "total_size")= num 4720
[16:19:38.007]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:38.007]  - attr(*, "already-done")= logi TRUE
[16:19:38.014] - reassign environment for ‘...future.FUN’
[16:19:38.014] - copied ‘...future.FUN’ to environment
[16:19:38.015] - copied ‘future.call.arguments’ to environment
[16:19:38.015] - copied ‘...future.elements_ii’ to environment
[16:19:38.015] - copied ‘...future.seeds_ii’ to environment
[16:19:38.015] - copied ‘...future.globals.maxSize’ to environment
[16:19:38.015] assign_globals() ... done
[16:19:38.015] requestCore(): workers = 2
[16:19:38.017] MulticoreFuture started
[16:19:38.018] - Launch lazy future ... done
[16:19:38.018] run() for ‘MulticoreFuture’ ... done
[16:19:38.018] Created future:
[16:19:38.018] plan(): Setting new future strategy stack:
[16:19:38.019] List of future strategies:
[16:19:38.019] 1. sequential:
[16:19:38.019]    - args: function (..., envir = parent.frame())
[16:19:38.019]    - tweaked: FALSE
[16:19:38.019]    - call: NULL
[16:19:38.020] plan(): nbrOfWorkers() = 1
[16:19:38.022] plan(): Setting new future strategy stack:
[16:19:38.022] List of future strategies:
[16:19:38.022] 1. multicore:
[16:19:38.022]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:38.022]    - tweaked: FALSE
[16:19:38.022]    - call: plan(strategy)
[16:19:38.027] plan(): nbrOfWorkers() = 2
[16:19:38.018] MulticoreFuture:
[16:19:38.018] Label: ‘future_lapply-2’
[16:19:38.018] Expression:
[16:19:38.018] {
[16:19:38.018]     do.call(function(...) {
[16:19:38.018]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:38.018]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:38.018]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:38.018]             on.exit(options(oopts), add = TRUE)
[16:19:38.018]         }
[16:19:38.018]         {
[16:19:38.018]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:38.018]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:38.018]                 ...future.FUN(...future.X_jj, ...)
[16:19:38.018]             })
[16:19:38.018]         }
[16:19:38.018]     }, args = future.call.arguments)
[16:19:38.018] }
[16:19:38.018] Lazy evaluation: FALSE
[16:19:38.018] Asynchronous evaluation: TRUE
[16:19:38.018] Local evaluation: TRUE
[16:19:38.018] Environment: R_GlobalEnv
[16:19:38.018] Capture standard output: NA
[16:19:38.018] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:38.018] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:38.018] Packages: <none>
[16:19:38.018] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:38.018] Resolved: TRUE
[16:19:38.018] Value: <not collected>
[16:19:38.018] Conditions captured: <none>
[16:19:38.018] Early signaling: FALSE
[16:19:38.018] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:38.018] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:38.028] Chunk #2 of 2 ... DONE
[16:19:38.029] Launching 2 futures (chunks) ... DONE
[16:19:38.029] Resolving 2 futures (chunks) ...
[16:19:38.029] resolve() on list ...
[16:19:38.029]  recursive: 0
[16:19:38.029]  length: 2
[16:19:38.029] 
[16:19:38.040] Future #2
[16:19:38.040] result() for MulticoreFuture ...
[16:19:38.041] result() for MulticoreFuture ...
[16:19:38.041] result() for MulticoreFuture ... done
[16:19:38.042] result() for MulticoreFuture ... done
[16:19:38.042] result() for MulticoreFuture ...
[16:19:38.042] result() for MulticoreFuture ... done
[16:19:38.042] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:38.042] - nx: 2
[16:19:38.042] - relay: TRUE
[16:19:38.043] - stdout: TRUE
[16:19:38.043] - signal: TRUE
[16:19:38.043] - resignal: FALSE
[16:19:38.043] - force: TRUE
[16:19:38.043] - relayed: [n=2] FALSE, FALSE
[16:19:38.043] - queued futures: [n=2] FALSE, FALSE
[16:19:38.043]  - until=1
[16:19:38.043]  - relaying element #1
[16:19:38.044] - relayed: [n=2] FALSE, FALSE
[16:19:38.044] - queued futures: [n=2] FALSE, TRUE
[16:19:38.044] signalConditionsASAP(NULL, pos=2) ... done
[16:19:38.044]  length: 1 (resolved future 2)
[16:19:38.474] plan(): Setting new future strategy stack:
[16:19:38.474] List of future strategies:
[16:19:38.474] 1. multicore:
[16:19:38.474]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:38.474]    - tweaked: FALSE
[16:19:38.474]    - call: plan(strategy)
[16:19:38.479] plan(): nbrOfWorkers() = 2
[16:19:38.482] Future #1
[16:19:38.482] result() for MulticoreFuture ...
[16:19:38.483] result() for MulticoreFuture ...
[16:19:38.483] result() for MulticoreFuture ... done
[16:19:38.483] result() for MulticoreFuture ... done
[16:19:38.483] result() for MulticoreFuture ...
[16:19:38.484] result() for MulticoreFuture ... done
[16:19:38.484] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:38.484] - nx: 2
[16:19:38.484] - relay: TRUE
[16:19:38.484] - stdout: TRUE
[16:19:38.484] - signal: TRUE
[16:19:38.484] - resignal: FALSE
[16:19:38.484] - force: TRUE
[16:19:38.484] - relayed: [n=2] FALSE, FALSE
[16:19:38.485] - queued futures: [n=2] FALSE, TRUE
[16:19:38.485]  - until=1
[16:19:38.485]  - relaying element #1
[16:19:38.485] result() for MulticoreFuture ...
[16:19:38.485] result() for MulticoreFuture ... done
[16:19:38.485] result() for MulticoreFuture ...
[16:19:38.485] result() for MulticoreFuture ... done
[16:19:38.485] result() for MulticoreFuture ...
[16:19:38.486] result() for MulticoreFuture ... done
[16:19:38.486] result() for MulticoreFuture ...
[16:19:38.486] result() for MulticoreFuture ... done
[16:19:38.486] - relayed: [n=2] TRUE, FALSE
[16:19:38.486] - queued futures: [n=2] TRUE, TRUE
[16:19:38.486] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:38.486]  length: 0 (resolved future 1)
[16:19:38.486] Relaying remaining futures
[16:19:38.487] signalConditionsASAP(NULL, pos=0) ...
[16:19:38.487] - nx: 2
[16:19:38.487] - relay: TRUE
[16:19:38.487] - stdout: TRUE
[16:19:38.487] - signal: TRUE
[16:19:38.487] - resignal: FALSE
[16:19:38.487] - force: TRUE
[16:19:38.487] - relayed: [n=2] TRUE, FALSE
[16:19:38.487] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:38.488]  - relaying element #2
[16:19:38.488] result() for MulticoreFuture ...
[16:19:38.488] result() for MulticoreFuture ... done
[16:19:38.488] result() for MulticoreFuture ...
[16:19:38.488] result() for MulticoreFuture ... done
[16:19:38.488] result() for MulticoreFuture ...
[16:19:38.488] result() for MulticoreFuture ... done
[16:19:38.488] result() for MulticoreFuture ...
[16:19:38.488] result() for MulticoreFuture ... done
[16:19:38.489] - relayed: [n=2] TRUE, TRUE
[16:19:38.489] - queued futures: [n=2] TRUE, TRUE
[16:19:38.489] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:19:38.489] resolve() on list ... DONE
[16:19:38.489] result() for MulticoreFuture ...
[16:19:38.489] result() for MulticoreFuture ... done
[16:19:38.489] result() for MulticoreFuture ...
[16:19:38.489] result() for MulticoreFuture ... done
[16:19:38.490] result() for MulticoreFuture ...
[16:19:38.490] result() for MulticoreFuture ... done
[16:19:38.490] result() for MulticoreFuture ...
[16:19:38.490] result() for MulticoreFuture ... done
[16:19:38.490]  - Number of value chunks collected: 2
[16:19:38.490] Resolving 2 futures (chunks) ... DONE
[16:19:38.490] Reducing values from 2 chunks ...
[16:19:38.490]  - Number of values collected after concatenation: 2
[16:19:38.493]  - Number of values expected: 2
[16:19:38.493] Reducing values from 2 chunks ... DONE
[16:19:38.493] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:19:38.494] future_mapply() ...
[16:19:38.499] Number of chunks: 2
[16:19:38.499] getGlobalsAndPackagesXApply() ...
[16:19:38.499]  - future.globals: TRUE
[16:19:38.499] getGlobalsAndPackages() ...
[16:19:38.499] Searching for globals...
[16:19:38.501] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:38.501] Searching for globals ... DONE
[16:19:38.502] Resolving globals: FALSE
[16:19:38.502] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:38.502] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:38.503] - globals: [1] ‘FUN’
[16:19:38.503] 
[16:19:38.503] getGlobalsAndPackages() ... DONE
[16:19:38.503]  - globals found/used: [n=1] ‘FUN’
[16:19:38.503]  - needed namespaces: [n=0] 
[16:19:38.503] Finding globals ... DONE
[16:19:38.503] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:38.504] List of 2
[16:19:38.504]  $ ...future.FUN:function (x, y)  
[16:19:38.504]  $ MoreArgs     : NULL
[16:19:38.504]  - attr(*, "where")=List of 2
[16:19:38.504]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:38.504]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:38.504]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:38.504]  - attr(*, "resolved")= logi FALSE
[16:19:38.504]  - attr(*, "total_size")= num NA
[16:19:38.507] Packages to be attached in all futures: [n=0] 
[16:19:38.507] getGlobalsAndPackagesXApply() ... DONE
[16:19:38.507] Number of futures (= number of chunks): 2
[16:19:38.507] Launching 2 futures (chunks) ...
[16:19:38.507] Chunk #1 of 2 ...
[16:19:38.507]  - Finding globals in '...' for chunk #1 ...
[16:19:38.507] getGlobalsAndPackages() ...
[16:19:38.507] Searching for globals...
[16:19:38.508] 
[16:19:38.508] Searching for globals ... DONE
[16:19:38.508] - globals: [0] <none>
[16:19:38.508] getGlobalsAndPackages() ... DONE
[16:19:38.508]    + additional globals found: [n=0] 
[16:19:38.508]    + additional namespaces needed: [n=0] 
[16:19:38.508]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:38.508]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:38.509]  - seeds: <none>
[16:19:38.509]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:38.509] getGlobalsAndPackages() ...
[16:19:38.509] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:38.509] Resolving globals: FALSE
[16:19:38.509] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:19:38.510] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:38.510] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:38.510] 
[16:19:38.510] getGlobalsAndPackages() ... DONE
[16:19:38.511] run() for ‘Future’ ...
[16:19:38.511] - state: ‘created’
[16:19:38.511] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:38.514] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:38.514] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:38.515]   - Field: ‘label’
[16:19:38.515]   - Field: ‘local’
[16:19:38.515]   - Field: ‘owner’
[16:19:38.515]   - Field: ‘envir’
[16:19:38.515]   - Field: ‘workers’
[16:19:38.515]   - Field: ‘packages’
[16:19:38.515]   - Field: ‘gc’
[16:19:38.515]   - Field: ‘job’
[16:19:38.515]   - Field: ‘conditions’
[16:19:38.515]   - Field: ‘expr’
[16:19:38.516]   - Field: ‘uuid’
[16:19:38.516]   - Field: ‘seed’
[16:19:38.516]   - Field: ‘version’
[16:19:38.516]   - Field: ‘result’
[16:19:38.516]   - Field: ‘asynchronous’
[16:19:38.516]   - Field: ‘calls’
[16:19:38.516]   - Field: ‘globals’
[16:19:38.516]   - Field: ‘stdout’
[16:19:38.516]   - Field: ‘earlySignal’
[16:19:38.516]   - Field: ‘lazy’
[16:19:38.516]   - Field: ‘state’
[16:19:38.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:38.517] - Launch lazy future ...
[16:19:38.517] Packages needed by the future expression (n = 0): <none>
[16:19:38.517] Packages needed by future strategies (n = 0): <none>
[16:19:38.518] {
[16:19:38.518]     {
[16:19:38.518]         {
[16:19:38.518]             ...future.startTime <- base::Sys.time()
[16:19:38.518]             {
[16:19:38.518]                 {
[16:19:38.518]                   {
[16:19:38.518]                     {
[16:19:38.518]                       base::local({
[16:19:38.518]                         has_future <- base::requireNamespace("future", 
[16:19:38.518]                           quietly = TRUE)
[16:19:38.518]                         if (has_future) {
[16:19:38.518]                           ns <- base::getNamespace("future")
[16:19:38.518]                           version <- ns[[".package"]][["version"]]
[16:19:38.518]                           if (is.null(version)) 
[16:19:38.518]                             version <- utils::packageVersion("future")
[16:19:38.518]                         }
[16:19:38.518]                         else {
[16:19:38.518]                           version <- NULL
[16:19:38.518]                         }
[16:19:38.518]                         if (!has_future || version < "1.8.0") {
[16:19:38.518]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:38.518]                             "", base::R.version$version.string), 
[16:19:38.518]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:38.518]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:38.518]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:38.518]                               "release", "version")], collapse = " "), 
[16:19:38.518]                             hostname = base::Sys.info()[["nodename"]])
[16:19:38.518]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:38.518]                             info)
[16:19:38.518]                           info <- base::paste(info, collapse = "; ")
[16:19:38.518]                           if (!has_future) {
[16:19:38.518]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:38.518]                               info)
[16:19:38.518]                           }
[16:19:38.518]                           else {
[16:19:38.518]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:38.518]                               info, version)
[16:19:38.518]                           }
[16:19:38.518]                           base::stop(msg)
[16:19:38.518]                         }
[16:19:38.518]                       })
[16:19:38.518]                     }
[16:19:38.518]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:38.518]                     base::options(mc.cores = 1L)
[16:19:38.518]                   }
[16:19:38.518]                   ...future.strategy.old <- future::plan("list")
[16:19:38.518]                   options(future.plan = NULL)
[16:19:38.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:38.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:38.518]                 }
[16:19:38.518]                 ...future.workdir <- getwd()
[16:19:38.518]             }
[16:19:38.518]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:38.518]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:38.518]         }
[16:19:38.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:38.518]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:38.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:38.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:38.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:38.518]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:38.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:38.518]             base::names(...future.oldOptions))
[16:19:38.518]     }
[16:19:38.518]     if (FALSE) {
[16:19:38.518]     }
[16:19:38.518]     else {
[16:19:38.518]         if (FALSE) {
[16:19:38.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:38.518]                 open = "w")
[16:19:38.518]         }
[16:19:38.518]         else {
[16:19:38.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:38.518]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:38.518]         }
[16:19:38.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:38.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:38.518]             base::sink(type = "output", split = FALSE)
[16:19:38.518]             base::close(...future.stdout)
[16:19:38.518]         }, add = TRUE)
[16:19:38.518]     }
[16:19:38.518]     ...future.frame <- base::sys.nframe()
[16:19:38.518]     ...future.conditions <- base::list()
[16:19:38.518]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:38.518]     if (FALSE) {
[16:19:38.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:38.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:38.518]     }
[16:19:38.518]     ...future.result <- base::tryCatch({
[16:19:38.518]         base::withCallingHandlers({
[16:19:38.518]             ...future.value <- base::withVisible(base::local({
[16:19:38.518]                 withCallingHandlers({
[16:19:38.518]                   {
[16:19:38.518]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:38.518]                     if (!identical(...future.globals.maxSize.org, 
[16:19:38.518]                       ...future.globals.maxSize)) {
[16:19:38.518]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:38.518]                       on.exit(options(oopts), add = TRUE)
[16:19:38.518]                     }
[16:19:38.518]                     {
[16:19:38.518]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:38.518]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:38.518]                         USE.NAMES = FALSE)
[16:19:38.518]                       do.call(mapply, args = args)
[16:19:38.518]                     }
[16:19:38.518]                   }
[16:19:38.518]                 }, immediateCondition = function(cond) {
[16:19:38.518]                   save_rds <- function (object, pathname, ...) 
[16:19:38.518]                   {
[16:19:38.518]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:38.518]                     if (file_test("-f", pathname_tmp)) {
[16:19:38.518]                       fi_tmp <- file.info(pathname_tmp)
[16:19:38.518]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:38.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:38.518]                         fi_tmp[["mtime"]])
[16:19:38.518]                     }
[16:19:38.518]                     tryCatch({
[16:19:38.518]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:38.518]                     }, error = function(ex) {
[16:19:38.518]                       msg <- conditionMessage(ex)
[16:19:38.518]                       fi_tmp <- file.info(pathname_tmp)
[16:19:38.518]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:38.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:38.518]                         fi_tmp[["mtime"]], msg)
[16:19:38.518]                       ex$message <- msg
[16:19:38.518]                       stop(ex)
[16:19:38.518]                     })
[16:19:38.518]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:38.518]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:38.518]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:38.518]                       fi_tmp <- file.info(pathname_tmp)
[16:19:38.518]                       fi <- file.info(pathname)
[16:19:38.518]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:38.518]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:38.518]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:38.518]                         fi[["size"]], fi[["mtime"]])
[16:19:38.518]                       stop(msg)
[16:19:38.518]                     }
[16:19:38.518]                     invisible(pathname)
[16:19:38.518]                   }
[16:19:38.518]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:38.518]                     rootPath = tempdir()) 
[16:19:38.518]                   {
[16:19:38.518]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:38.518]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:38.518]                       tmpdir = path, fileext = ".rds")
[16:19:38.518]                     save_rds(obj, file)
[16:19:38.518]                   }
[16:19:38.518]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPcako/.future/immediateConditions")
[16:19:38.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:38.518]                   {
[16:19:38.518]                     inherits <- base::inherits
[16:19:38.518]                     invokeRestart <- base::invokeRestart
[16:19:38.518]                     is.null <- base::is.null
[16:19:38.518]                     muffled <- FALSE
[16:19:38.518]                     if (inherits(cond, "message")) {
[16:19:38.518]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:38.518]                       if (muffled) 
[16:19:38.518]                         invokeRestart("muffleMessage")
[16:19:38.518]                     }
[16:19:38.518]                     else if (inherits(cond, "warning")) {
[16:19:38.518]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:38.518]                       if (muffled) 
[16:19:38.518]                         invokeRestart("muffleWarning")
[16:19:38.518]                     }
[16:19:38.518]                     else if (inherits(cond, "condition")) {
[16:19:38.518]                       if (!is.null(pattern)) {
[16:19:38.518]                         computeRestarts <- base::computeRestarts
[16:19:38.518]                         grepl <- base::grepl
[16:19:38.518]                         restarts <- computeRestarts(cond)
[16:19:38.518]                         for (restart in restarts) {
[16:19:38.518]                           name <- restart$name
[16:19:38.518]                           if (is.null(name)) 
[16:19:38.518]                             next
[16:19:38.518]                           if (!grepl(pattern, name)) 
[16:19:38.518]                             next
[16:19:38.518]                           invokeRestart(restart)
[16:19:38.518]                           muffled <- TRUE
[16:19:38.518]                           break
[16:19:38.518]                         }
[16:19:38.518]                       }
[16:19:38.518]                     }
[16:19:38.518]                     invisible(muffled)
[16:19:38.518]                   }
[16:19:38.518]                   muffleCondition(cond)
[16:19:38.518]                 })
[16:19:38.518]             }))
[16:19:38.518]             future::FutureResult(value = ...future.value$value, 
[16:19:38.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:38.518]                   ...future.rng), globalenv = if (FALSE) 
[16:19:38.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:38.518]                     ...future.globalenv.names))
[16:19:38.518]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:38.518]         }, condition = base::local({
[16:19:38.518]             c <- base::c
[16:19:38.518]             inherits <- base::inherits
[16:19:38.518]             invokeRestart <- base::invokeRestart
[16:19:38.518]             length <- base::length
[16:19:38.518]             list <- base::list
[16:19:38.518]             seq.int <- base::seq.int
[16:19:38.518]             signalCondition <- base::signalCondition
[16:19:38.518]             sys.calls <- base::sys.calls
[16:19:38.518]             `[[` <- base::`[[`
[16:19:38.518]             `+` <- base::`+`
[16:19:38.518]             `<<-` <- base::`<<-`
[16:19:38.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:38.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:38.518]                   3L)]
[16:19:38.518]             }
[16:19:38.518]             function(cond) {
[16:19:38.518]                 is_error <- inherits(cond, "error")
[16:19:38.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:38.518]                   NULL)
[16:19:38.518]                 if (is_error) {
[16:19:38.518]                   sessionInformation <- function() {
[16:19:38.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:38.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:38.518]                       search = base::search(), system = base::Sys.info())
[16:19:38.518]                   }
[16:19:38.518]                   ...future.conditions[[length(...future.conditions) + 
[16:19:38.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:38.518]                     cond$call), session = sessionInformation(), 
[16:19:38.518]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:38.518]                   signalCondition(cond)
[16:19:38.518]                 }
[16:19:38.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:38.518]                 "immediateCondition"))) {
[16:19:38.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:38.518]                   ...future.conditions[[length(...future.conditions) + 
[16:19:38.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:38.518]                   if (TRUE && !signal) {
[16:19:38.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:38.518]                     {
[16:19:38.518]                       inherits <- base::inherits
[16:19:38.518]                       invokeRestart <- base::invokeRestart
[16:19:38.518]                       is.null <- base::is.null
[16:19:38.518]                       muffled <- FALSE
[16:19:38.518]                       if (inherits(cond, "message")) {
[16:19:38.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:38.518]                         if (muffled) 
[16:19:38.518]                           invokeRestart("muffleMessage")
[16:19:38.518]                       }
[16:19:38.518]                       else if (inherits(cond, "warning")) {
[16:19:38.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:38.518]                         if (muffled) 
[16:19:38.518]                           invokeRestart("muffleWarning")
[16:19:38.518]                       }
[16:19:38.518]                       else if (inherits(cond, "condition")) {
[16:19:38.518]                         if (!is.null(pattern)) {
[16:19:38.518]                           computeRestarts <- base::computeRestarts
[16:19:38.518]                           grepl <- base::grepl
[16:19:38.518]                           restarts <- computeRestarts(cond)
[16:19:38.518]                           for (restart in restarts) {
[16:19:38.518]                             name <- restart$name
[16:19:38.518]                             if (is.null(name)) 
[16:19:38.518]                               next
[16:19:38.518]                             if (!grepl(pattern, name)) 
[16:19:38.518]                               next
[16:19:38.518]                             invokeRestart(restart)
[16:19:38.518]                             muffled <- TRUE
[16:19:38.518]                             break
[16:19:38.518]                           }
[16:19:38.518]                         }
[16:19:38.518]                       }
[16:19:38.518]                       invisible(muffled)
[16:19:38.518]                     }
[16:19:38.518]                     muffleCondition(cond, pattern = "^muffle")
[16:19:38.518]                   }
[16:19:38.518]                 }
[16:19:38.518]                 else {
[16:19:38.518]                   if (TRUE) {
[16:19:38.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:38.518]                     {
[16:19:38.518]                       inherits <- base::inherits
[16:19:38.518]                       invokeRestart <- base::invokeRestart
[16:19:38.518]                       is.null <- base::is.null
[16:19:38.518]                       muffled <- FALSE
[16:19:38.518]                       if (inherits(cond, "message")) {
[16:19:38.518]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:38.518]                         if (muffled) 
[16:19:38.518]                           invokeRestart("muffleMessage")
[16:19:38.518]                       }
[16:19:38.518]                       else if (inherits(cond, "warning")) {
[16:19:38.518]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:38.518]                         if (muffled) 
[16:19:38.518]                           invokeRestart("muffleWarning")
[16:19:38.518]                       }
[16:19:38.518]                       else if (inherits(cond, "condition")) {
[16:19:38.518]                         if (!is.null(pattern)) {
[16:19:38.518]                           computeRestarts <- base::computeRestarts
[16:19:38.518]                           grepl <- base::grepl
[16:19:38.518]                           restarts <- computeRestarts(cond)
[16:19:38.518]                           for (restart in restarts) {
[16:19:38.518]                             name <- restart$name
[16:19:38.518]                             if (is.null(name)) 
[16:19:38.518]                               next
[16:19:38.518]                             if (!grepl(pattern, name)) 
[16:19:38.518]                               next
[16:19:38.518]                             invokeRestart(restart)
[16:19:38.518]                             muffled <- TRUE
[16:19:38.518]                             break
[16:19:38.518]                           }
[16:19:38.518]                         }
[16:19:38.518]                       }
[16:19:38.518]                       invisible(muffled)
[16:19:38.518]                     }
[16:19:38.518]                     muffleCondition(cond, pattern = "^muffle")
[16:19:38.518]                   }
[16:19:38.518]                 }
[16:19:38.518]             }
[16:19:38.518]         }))
[16:19:38.518]     }, error = function(ex) {
[16:19:38.518]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:38.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:38.518]                 ...future.rng), started = ...future.startTime, 
[16:19:38.518]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:38.518]             version = "1.8"), class = "FutureResult")
[16:19:38.518]     }, finally = {
[16:19:38.518]         if (!identical(...future.workdir, getwd())) 
[16:19:38.518]             setwd(...future.workdir)
[16:19:38.518]         {
[16:19:38.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:38.518]                 ...future.oldOptions$nwarnings <- NULL
[16:19:38.518]             }
[16:19:38.518]             base::options(...future.oldOptions)
[16:19:38.518]             if (.Platform$OS.type == "windows") {
[16:19:38.518]                 old_names <- names(...future.oldEnvVars)
[16:19:38.518]                 envs <- base::Sys.getenv()
[16:19:38.518]                 names <- names(envs)
[16:19:38.518]                 common <- intersect(names, old_names)
[16:19:38.518]                 added <- setdiff(names, old_names)
[16:19:38.518]                 removed <- setdiff(old_names, names)
[16:19:38.518]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:38.518]                   envs[common]]
[16:19:38.518]                 NAMES <- toupper(changed)
[16:19:38.518]                 args <- list()
[16:19:38.518]                 for (kk in seq_along(NAMES)) {
[16:19:38.518]                   name <- changed[[kk]]
[16:19:38.518]                   NAME <- NAMES[[kk]]
[16:19:38.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:38.518]                     next
[16:19:38.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:38.518]                 }
[16:19:38.518]                 NAMES <- toupper(added)
[16:19:38.518]                 for (kk in seq_along(NAMES)) {
[16:19:38.518]                   name <- added[[kk]]
[16:19:38.518]                   NAME <- NAMES[[kk]]
[16:19:38.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:38.518]                     next
[16:19:38.518]                   args[[name]] <- ""
[16:19:38.518]                 }
[16:19:38.518]                 NAMES <- toupper(removed)
[16:19:38.518]                 for (kk in seq_along(NAMES)) {
[16:19:38.518]                   name <- removed[[kk]]
[16:19:38.518]                   NAME <- NAMES[[kk]]
[16:19:38.518]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:38.518]                     next
[16:19:38.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:38.518]                 }
[16:19:38.518]                 if (length(args) > 0) 
[16:19:38.518]                   base::do.call(base::Sys.setenv, args = args)
[16:19:38.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:38.518]             }
[16:19:38.518]             else {
[16:19:38.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:38.518]             }
[16:19:38.518]             {
[16:19:38.518]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:38.518]                   0L) {
[16:19:38.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:38.518]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:38.518]                   base::options(opts)
[16:19:38.518]                 }
[16:19:38.518]                 {
[16:19:38.518]                   {
[16:19:38.518]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:38.518]                     NULL
[16:19:38.518]                   }
[16:19:38.518]                   options(future.plan = NULL)
[16:19:38.518]                   if (is.na(NA_character_)) 
[16:19:38.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:38.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:38.518]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:38.518]                     .init = FALSE)
[16:19:38.518]                 }
[16:19:38.518]             }
[16:19:38.518]         }
[16:19:38.518]     })
[16:19:38.518]     if (TRUE) {
[16:19:38.518]         base::sink(type = "output", split = FALSE)
[16:19:38.518]         if (FALSE) {
[16:19:38.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:38.518]         }
[16:19:38.518]         else {
[16:19:38.518]             ...future.result["stdout"] <- base::list(NULL)
[16:19:38.518]         }
[16:19:38.518]         base::close(...future.stdout)
[16:19:38.518]         ...future.stdout <- NULL
[16:19:38.518]     }
[16:19:38.518]     ...future.result$conditions <- ...future.conditions
[16:19:38.518]     ...future.result$finished <- base::Sys.time()
[16:19:38.518]     ...future.result
[16:19:38.518] }
[16:19:38.520] assign_globals() ...
[16:19:38.520] List of 5
[16:19:38.520]  $ ...future.FUN            :function (x, y)  
[16:19:38.520]  $ MoreArgs                 : NULL
[16:19:38.520]  $ ...future.elements_ii    :List of 2
[16:19:38.520]   ..$ :List of 1
[16:19:38.520]   .. ..$ : int 1
[16:19:38.520]   ..$ :List of 1
[16:19:38.520]   .. ..$ : int 0
[16:19:38.520]  $ ...future.seeds_ii       : NULL
[16:19:38.520]  $ ...future.globals.maxSize: NULL
[16:19:38.520]  - attr(*, "where")=List of 5
[16:19:38.520]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:38.520]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:38.520]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:38.520]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:38.520]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:38.520]  - attr(*, "resolved")= logi FALSE
[16:19:38.520]  - attr(*, "total_size")= num 6368
[16:19:38.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:38.520]  - attr(*, "already-done")= logi TRUE
[16:19:38.526] - reassign environment for ‘...future.FUN’
[16:19:38.527] - copied ‘...future.FUN’ to environment
[16:19:38.527] - copied ‘MoreArgs’ to environment
[16:19:38.527] - copied ‘...future.elements_ii’ to environment
[16:19:38.527] - copied ‘...future.seeds_ii’ to environment
[16:19:38.527] - copied ‘...future.globals.maxSize’ to environment
[16:19:38.527] assign_globals() ... done
[16:19:38.527] requestCore(): workers = 2
[16:19:38.529] MulticoreFuture started
[16:19:38.530] - Launch lazy future ... done
[16:19:38.530] run() for ‘MulticoreFuture’ ... done
[16:19:38.530] plan(): Setting new future strategy stack:
[16:19:38.531] Created future:
[16:19:38.531] List of future strategies:
[16:19:38.531] 1. sequential:
[16:19:38.531]    - args: function (..., envir = parent.frame())
[16:19:38.531]    - tweaked: FALSE
[16:19:38.531]    - call: NULL
[16:19:38.532] plan(): nbrOfWorkers() = 1
[16:19:38.531] MulticoreFuture:
[16:19:38.531] Label: ‘future_mapply-1’
[16:19:38.531] Expression:
[16:19:38.531] {
[16:19:38.531]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:38.531]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:38.531]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:38.531]         on.exit(options(oopts), add = TRUE)
[16:19:38.531]     }
[16:19:38.531]     {
[16:19:38.531]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:38.531]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:38.531]         do.call(mapply, args = args)
[16:19:38.531]     }
[16:19:38.531] }
[16:19:38.531] Lazy evaluation: FALSE
[16:19:38.531] Asynchronous evaluation: TRUE
[16:19:38.531] Local evaluation: TRUE
[16:19:38.531] Environment: R_GlobalEnv
[16:19:38.531] Capture standard output: FALSE
[16:19:38.531] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:38.531] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:38.531] Packages: <none>
[16:19:38.531] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:38.531] Resolved: FALSE
[16:19:38.531] Value: <not collected>
[16:19:38.531] Conditions captured: <none>
[16:19:38.531] Early signaling: FALSE
[16:19:38.531] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:38.531] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:38.544] Chunk #1 of 2 ... DONE
[16:19:38.544] Chunk #2 of 2 ...
[16:19:38.545]  - Finding globals in '...' for chunk #2 ...
[16:19:38.545] getGlobalsAndPackages() ...
[16:19:38.545] Searching for globals...
[16:19:38.546] 
[16:19:38.546] Searching for globals ... DONE
[16:19:38.546] - globals: [0] <none>
[16:19:38.546] getGlobalsAndPackages() ... DONE
[16:19:38.546]    + additional globals found: [n=0] 
[16:19:38.547]    + additional namespaces needed: [n=0] 
[16:19:38.547]  - Finding globals in '...' for chunk #2 ... DONE
[16:19:38.547]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:38.547]  - seeds: <none>
[16:19:38.547]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:38.547] getGlobalsAndPackages() ...
[16:19:38.548] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:38.548] Resolving globals: FALSE
[16:19:38.549] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:19:38.550] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:38.550] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:38.550] 
[16:19:38.550] getGlobalsAndPackages() ... DONE
[16:19:38.551] run() for ‘Future’ ...
[16:19:38.551] - state: ‘created’
[16:19:38.551] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:38.556] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:38.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:38.556]   - Field: ‘label’
[16:19:38.556]   - Field: ‘local’
[16:19:38.556]   - Field: ‘owner’
[16:19:38.557]   - Field: ‘envir’
[16:19:38.557]   - Field: ‘workers’
[16:19:38.557]   - Field: ‘packages’
[16:19:38.557]   - Field: ‘gc’
[16:19:38.557]   - Field: ‘job’
[16:19:38.557]   - Field: ‘conditions’
[16:19:38.557]   - Field: ‘expr’
[16:19:38.558]   - Field: ‘uuid’
[16:19:38.558]   - Field: ‘seed’
[16:19:38.558]   - Field: ‘version’
[16:19:38.558]   - Field: ‘result’
[16:19:38.558]   - Field: ‘asynchronous’
[16:19:38.558]   - Field: ‘calls’
[16:19:38.559]   - Field: ‘globals’
[16:19:38.559]   - Field: ‘stdout’
[16:19:38.559]   - Field: ‘earlySignal’
[16:19:38.559]   - Field: ‘lazy’
[16:19:38.559]   - Field: ‘state’
[16:19:38.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:38.559] - Launch lazy future ...
[16:19:38.560] Packages needed by the future expression (n = 0): <none>
[16:19:38.560] Packages needed by future strategies (n = 0): <none>
[16:19:38.561] {
[16:19:38.561]     {
[16:19:38.561]         {
[16:19:38.561]             ...future.startTime <- base::Sys.time()
[16:19:38.561]             {
[16:19:38.561]                 {
[16:19:38.561]                   {
[16:19:38.561]                     {
[16:19:38.561]                       base::local({
[16:19:38.561]                         has_future <- base::requireNamespace("future", 
[16:19:38.561]                           quietly = TRUE)
[16:19:38.561]                         if (has_future) {
[16:19:38.561]                           ns <- base::getNamespace("future")
[16:19:38.561]                           version <- ns[[".package"]][["version"]]
[16:19:38.561]                           if (is.null(version)) 
[16:19:38.561]                             version <- utils::packageVersion("future")
[16:19:38.561]                         }
[16:19:38.561]                         else {
[16:19:38.561]                           version <- NULL
[16:19:38.561]                         }
[16:19:38.561]                         if (!has_future || version < "1.8.0") {
[16:19:38.561]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:38.561]                             "", base::R.version$version.string), 
[16:19:38.561]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:38.561]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:38.561]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:38.561]                               "release", "version")], collapse = " "), 
[16:19:38.561]                             hostname = base::Sys.info()[["nodename"]])
[16:19:38.561]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:38.561]                             info)
[16:19:38.561]                           info <- base::paste(info, collapse = "; ")
[16:19:38.561]                           if (!has_future) {
[16:19:38.561]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:38.561]                               info)
[16:19:38.561]                           }
[16:19:38.561]                           else {
[16:19:38.561]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:38.561]                               info, version)
[16:19:38.561]                           }
[16:19:38.561]                           base::stop(msg)
[16:19:38.561]                         }
[16:19:38.561]                       })
[16:19:38.561]                     }
[16:19:38.561]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:38.561]                     base::options(mc.cores = 1L)
[16:19:38.561]                   }
[16:19:38.561]                   ...future.strategy.old <- future::plan("list")
[16:19:38.561]                   options(future.plan = NULL)
[16:19:38.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:38.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:38.561]                 }
[16:19:38.561]                 ...future.workdir <- getwd()
[16:19:38.561]             }
[16:19:38.561]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:38.561]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:38.561]         }
[16:19:38.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:38.561]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:38.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:38.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:38.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:38.561]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:38.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:38.561]             base::names(...future.oldOptions))
[16:19:38.561]     }
[16:19:38.561]     if (FALSE) {
[16:19:38.561]     }
[16:19:38.561]     else {
[16:19:38.561]         if (FALSE) {
[16:19:38.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:38.561]                 open = "w")
[16:19:38.561]         }
[16:19:38.561]         else {
[16:19:38.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:38.561]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:38.561]         }
[16:19:38.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:38.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:38.561]             base::sink(type = "output", split = FALSE)
[16:19:38.561]             base::close(...future.stdout)
[16:19:38.561]         }, add = TRUE)
[16:19:38.561]     }
[16:19:38.561]     ...future.frame <- base::sys.nframe()
[16:19:38.561]     ...future.conditions <- base::list()
[16:19:38.561]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:38.561]     if (FALSE) {
[16:19:38.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:38.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:38.561]     }
[16:19:38.561]     ...future.result <- base::tryCatch({
[16:19:38.561]         base::withCallingHandlers({
[16:19:38.561]             ...future.value <- base::withVisible(base::local({
[16:19:38.561]                 withCallingHandlers({
[16:19:38.561]                   {
[16:19:38.561]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:38.561]                     if (!identical(...future.globals.maxSize.org, 
[16:19:38.561]                       ...future.globals.maxSize)) {
[16:19:38.561]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:38.561]                       on.exit(options(oopts), add = TRUE)
[16:19:38.561]                     }
[16:19:38.561]                     {
[16:19:38.561]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:38.561]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:38.561]                         USE.NAMES = FALSE)
[16:19:38.561]                       do.call(mapply, args = args)
[16:19:38.561]                     }
[16:19:38.561]                   }
[16:19:38.561]                 }, immediateCondition = function(cond) {
[16:19:38.561]                   save_rds <- function (object, pathname, ...) 
[16:19:38.561]                   {
[16:19:38.561]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:38.561]                     if (file_test("-f", pathname_tmp)) {
[16:19:38.561]                       fi_tmp <- file.info(pathname_tmp)
[16:19:38.561]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:38.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:38.561]                         fi_tmp[["mtime"]])
[16:19:38.561]                     }
[16:19:38.561]                     tryCatch({
[16:19:38.561]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:38.561]                     }, error = function(ex) {
[16:19:38.561]                       msg <- conditionMessage(ex)
[16:19:38.561]                       fi_tmp <- file.info(pathname_tmp)
[16:19:38.561]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:38.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:38.561]                         fi_tmp[["mtime"]], msg)
[16:19:38.561]                       ex$message <- msg
[16:19:38.561]                       stop(ex)
[16:19:38.561]                     })
[16:19:38.561]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:38.561]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:38.561]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:38.561]                       fi_tmp <- file.info(pathname_tmp)
[16:19:38.561]                       fi <- file.info(pathname)
[16:19:38.561]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:38.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:38.561]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:38.561]                         fi[["size"]], fi[["mtime"]])
[16:19:38.561]                       stop(msg)
[16:19:38.561]                     }
[16:19:38.561]                     invisible(pathname)
[16:19:38.561]                   }
[16:19:38.561]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:38.561]                     rootPath = tempdir()) 
[16:19:38.561]                   {
[16:19:38.561]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:38.561]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:38.561]                       tmpdir = path, fileext = ".rds")
[16:19:38.561]                     save_rds(obj, file)
[16:19:38.561]                   }
[16:19:38.561]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPcako/.future/immediateConditions")
[16:19:38.561]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:38.561]                   {
[16:19:38.561]                     inherits <- base::inherits
[16:19:38.561]                     invokeRestart <- base::invokeRestart
[16:19:38.561]                     is.null <- base::is.null
[16:19:38.561]                     muffled <- FALSE
[16:19:38.561]                     if (inherits(cond, "message")) {
[16:19:38.561]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:38.561]                       if (muffled) 
[16:19:38.561]                         invokeRestart("muffleMessage")
[16:19:38.561]                     }
[16:19:38.561]                     else if (inherits(cond, "warning")) {
[16:19:38.561]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:38.561]                       if (muffled) 
[16:19:38.561]                         invokeRestart("muffleWarning")
[16:19:38.561]                     }
[16:19:38.561]                     else if (inherits(cond, "condition")) {
[16:19:38.561]                       if (!is.null(pattern)) {
[16:19:38.561]                         computeRestarts <- base::computeRestarts
[16:19:38.561]                         grepl <- base::grepl
[16:19:38.561]                         restarts <- computeRestarts(cond)
[16:19:38.561]                         for (restart in restarts) {
[16:19:38.561]                           name <- restart$name
[16:19:38.561]                           if (is.null(name)) 
[16:19:38.561]                             next
[16:19:38.561]                           if (!grepl(pattern, name)) 
[16:19:38.561]                             next
[16:19:38.561]                           invokeRestart(restart)
[16:19:38.561]                           muffled <- TRUE
[16:19:38.561]                           break
[16:19:38.561]                         }
[16:19:38.561]                       }
[16:19:38.561]                     }
[16:19:38.561]                     invisible(muffled)
[16:19:38.561]                   }
[16:19:38.561]                   muffleCondition(cond)
[16:19:38.561]                 })
[16:19:38.561]             }))
[16:19:38.561]             future::FutureResult(value = ...future.value$value, 
[16:19:38.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:38.561]                   ...future.rng), globalenv = if (FALSE) 
[16:19:38.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:38.561]                     ...future.globalenv.names))
[16:19:38.561]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:38.561]         }, condition = base::local({
[16:19:38.561]             c <- base::c
[16:19:38.561]             inherits <- base::inherits
[16:19:38.561]             invokeRestart <- base::invokeRestart
[16:19:38.561]             length <- base::length
[16:19:38.561]             list <- base::list
[16:19:38.561]             seq.int <- base::seq.int
[16:19:38.561]             signalCondition <- base::signalCondition
[16:19:38.561]             sys.calls <- base::sys.calls
[16:19:38.561]             `[[` <- base::`[[`
[16:19:38.561]             `+` <- base::`+`
[16:19:38.561]             `<<-` <- base::`<<-`
[16:19:38.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:38.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:38.561]                   3L)]
[16:19:38.561]             }
[16:19:38.561]             function(cond) {
[16:19:38.561]                 is_error <- inherits(cond, "error")
[16:19:38.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:38.561]                   NULL)
[16:19:38.561]                 if (is_error) {
[16:19:38.561]                   sessionInformation <- function() {
[16:19:38.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:38.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:38.561]                       search = base::search(), system = base::Sys.info())
[16:19:38.561]                   }
[16:19:38.561]                   ...future.conditions[[length(...future.conditions) + 
[16:19:38.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:38.561]                     cond$call), session = sessionInformation(), 
[16:19:38.561]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:38.561]                   signalCondition(cond)
[16:19:38.561]                 }
[16:19:38.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:38.561]                 "immediateCondition"))) {
[16:19:38.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:38.561]                   ...future.conditions[[length(...future.conditions) + 
[16:19:38.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:38.561]                   if (TRUE && !signal) {
[16:19:38.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:38.561]                     {
[16:19:38.561]                       inherits <- base::inherits
[16:19:38.561]                       invokeRestart <- base::invokeRestart
[16:19:38.561]                       is.null <- base::is.null
[16:19:38.561]                       muffled <- FALSE
[16:19:38.561]                       if (inherits(cond, "message")) {
[16:19:38.561]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:38.561]                         if (muffled) 
[16:19:38.561]                           invokeRestart("muffleMessage")
[16:19:38.561]                       }
[16:19:38.561]                       else if (inherits(cond, "warning")) {
[16:19:38.561]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:38.561]                         if (muffled) 
[16:19:38.561]                           invokeRestart("muffleWarning")
[16:19:38.561]                       }
[16:19:38.561]                       else if (inherits(cond, "condition")) {
[16:19:38.561]                         if (!is.null(pattern)) {
[16:19:38.561]                           computeRestarts <- base::computeRestarts
[16:19:38.561]                           grepl <- base::grepl
[16:19:38.561]                           restarts <- computeRestarts(cond)
[16:19:38.561]                           for (restart in restarts) {
[16:19:38.561]                             name <- restart$name
[16:19:38.561]                             if (is.null(name)) 
[16:19:38.561]                               next
[16:19:38.561]                             if (!grepl(pattern, name)) 
[16:19:38.561]                               next
[16:19:38.561]                             invokeRestart(restart)
[16:19:38.561]                             muffled <- TRUE
[16:19:38.561]                             break
[16:19:38.561]                           }
[16:19:38.561]                         }
[16:19:38.561]                       }
[16:19:38.561]                       invisible(muffled)
[16:19:38.561]                     }
[16:19:38.561]                     muffleCondition(cond, pattern = "^muffle")
[16:19:38.561]                   }
[16:19:38.561]                 }
[16:19:38.561]                 else {
[16:19:38.561]                   if (TRUE) {
[16:19:38.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:38.561]                     {
[16:19:38.561]                       inherits <- base::inherits
[16:19:38.561]                       invokeRestart <- base::invokeRestart
[16:19:38.561]                       is.null <- base::is.null
[16:19:38.561]                       muffled <- FALSE
[16:19:38.561]                       if (inherits(cond, "message")) {
[16:19:38.561]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:38.561]                         if (muffled) 
[16:19:38.561]                           invokeRestart("muffleMessage")
[16:19:38.561]                       }
[16:19:38.561]                       else if (inherits(cond, "warning")) {
[16:19:38.561]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:38.561]                         if (muffled) 
[16:19:38.561]                           invokeRestart("muffleWarning")
[16:19:38.561]                       }
[16:19:38.561]                       else if (inherits(cond, "condition")) {
[16:19:38.561]                         if (!is.null(pattern)) {
[16:19:38.561]                           computeRestarts <- base::computeRestarts
[16:19:38.561]                           grepl <- base::grepl
[16:19:38.561]                           restarts <- computeRestarts(cond)
[16:19:38.561]                           for (restart in restarts) {
[16:19:38.561]                             name <- restart$name
[16:19:38.561]                             if (is.null(name)) 
[16:19:38.561]                               next
[16:19:38.561]                             if (!grepl(pattern, name)) 
[16:19:38.561]                               next
[16:19:38.561]                             invokeRestart(restart)
[16:19:38.561]                             muffled <- TRUE
[16:19:38.561]                             break
[16:19:38.561]                           }
[16:19:38.561]                         }
[16:19:38.561]                       }
[16:19:38.561]                       invisible(muffled)
[16:19:38.561]                     }
[16:19:38.561]                     muffleCondition(cond, pattern = "^muffle")
[16:19:38.561]                   }
[16:19:38.561]                 }
[16:19:38.561]             }
[16:19:38.561]         }))
[16:19:38.561]     }, error = function(ex) {
[16:19:38.561]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:38.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:38.561]                 ...future.rng), started = ...future.startTime, 
[16:19:38.561]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:38.561]             version = "1.8"), class = "FutureResult")
[16:19:38.561]     }, finally = {
[16:19:38.561]         if (!identical(...future.workdir, getwd())) 
[16:19:38.561]             setwd(...future.workdir)
[16:19:38.561]         {
[16:19:38.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:38.561]                 ...future.oldOptions$nwarnings <- NULL
[16:19:38.561]             }
[16:19:38.561]             base::options(...future.oldOptions)
[16:19:38.561]             if (.Platform$OS.type == "windows") {
[16:19:38.561]                 old_names <- names(...future.oldEnvVars)
[16:19:38.561]                 envs <- base::Sys.getenv()
[16:19:38.561]                 names <- names(envs)
[16:19:38.561]                 common <- intersect(names, old_names)
[16:19:38.561]                 added <- setdiff(names, old_names)
[16:19:38.561]                 removed <- setdiff(old_names, names)
[16:19:38.561]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:38.561]                   envs[common]]
[16:19:38.561]                 NAMES <- toupper(changed)
[16:19:38.561]                 args <- list()
[16:19:38.561]                 for (kk in seq_along(NAMES)) {
[16:19:38.561]                   name <- changed[[kk]]
[16:19:38.561]                   NAME <- NAMES[[kk]]
[16:19:38.561]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:38.561]                     next
[16:19:38.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:38.561]                 }
[16:19:38.561]                 NAMES <- toupper(added)
[16:19:38.561]                 for (kk in seq_along(NAMES)) {
[16:19:38.561]                   name <- added[[kk]]
[16:19:38.561]                   NAME <- NAMES[[kk]]
[16:19:38.561]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:38.561]                     next
[16:19:38.561]                   args[[name]] <- ""
[16:19:38.561]                 }
[16:19:38.561]                 NAMES <- toupper(removed)
[16:19:38.561]                 for (kk in seq_along(NAMES)) {
[16:19:38.561]                   name <- removed[[kk]]
[16:19:38.561]                   NAME <- NAMES[[kk]]
[16:19:38.561]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:38.561]                     next
[16:19:38.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:38.561]                 }
[16:19:38.561]                 if (length(args) > 0) 
[16:19:38.561]                   base::do.call(base::Sys.setenv, args = args)
[16:19:38.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:38.561]             }
[16:19:38.561]             else {
[16:19:38.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:38.561]             }
[16:19:38.561]             {
[16:19:38.561]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:38.561]                   0L) {
[16:19:38.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:38.561]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:38.561]                   base::options(opts)
[16:19:38.561]                 }
[16:19:38.561]                 {
[16:19:38.561]                   {
[16:19:38.561]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:38.561]                     NULL
[16:19:38.561]                   }
[16:19:38.561]                   options(future.plan = NULL)
[16:19:38.561]                   if (is.na(NA_character_)) 
[16:19:38.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:38.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:38.561]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:38.561]                     .init = FALSE)
[16:19:38.561]                 }
[16:19:38.561]             }
[16:19:38.561]         }
[16:19:38.561]     })
[16:19:38.561]     if (TRUE) {
[16:19:38.561]         base::sink(type = "output", split = FALSE)
[16:19:38.561]         if (FALSE) {
[16:19:38.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:38.561]         }
[16:19:38.561]         else {
[16:19:38.561]             ...future.result["stdout"] <- base::list(NULL)
[16:19:38.561]         }
[16:19:38.561]         base::close(...future.stdout)
[16:19:38.561]         ...future.stdout <- NULL
[16:19:38.561]     }
[16:19:38.561]     ...future.result$conditions <- ...future.conditions
[16:19:38.561]     ...future.result$finished <- base::Sys.time()
[16:19:38.561]     ...future.result
[16:19:38.561] }
[16:19:38.564] assign_globals() ...
[16:19:38.564] List of 5
[16:19:38.564]  $ ...future.FUN            :function (x, y)  
[16:19:38.564]  $ MoreArgs                 : NULL
[16:19:38.564]  $ ...future.elements_ii    :List of 2
[16:19:38.564]   ..$ :List of 1
[16:19:38.564]   .. ..$ : int 0
[16:19:38.564]   ..$ :List of 1
[16:19:38.564]   .. ..$ : int 1
[16:19:38.564]  $ ...future.seeds_ii       : NULL
[16:19:38.564]  $ ...future.globals.maxSize: NULL
[16:19:38.564]  - attr(*, "where")=List of 5
[16:19:38.564]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:38.564]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:38.564]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:38.564]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:38.564]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:38.564]  - attr(*, "resolved")= logi FALSE
[16:19:38.564]  - attr(*, "total_size")= num 6368
[16:19:38.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:38.564]  - attr(*, "already-done")= logi TRUE
[16:19:38.572] - reassign environment for ‘...future.FUN’
[16:19:38.573] - copied ‘...future.FUN’ to environment
[16:19:38.573] - copied ‘MoreArgs’ to environment
[16:19:38.573] - copied ‘...future.elements_ii’ to environment
[16:19:38.573] - copied ‘...future.seeds_ii’ to environment
[16:19:38.573] - copied ‘...future.globals.maxSize’ to environment
[16:19:38.573] assign_globals() ... done
[16:19:38.573] requestCore(): workers = 2
[16:19:38.576] MulticoreFuture started
[16:19:38.576] - Launch lazy future ... done
[16:19:38.576] run() for ‘MulticoreFuture’ ... done
[16:19:38.577] Created future:
[16:19:38.577] plan(): Setting new future strategy stack:
[16:19:38.577] List of future strategies:
[16:19:38.577] 1. sequential:
[16:19:38.577]    - args: function (..., envir = parent.frame())
[16:19:38.577]    - tweaked: FALSE
[16:19:38.577]    - call: NULL
[16:19:38.578] plan(): nbrOfWorkers() = 1
[16:19:38.584] plan(): Setting new future strategy stack:
[16:19:38.584] List of future strategies:
[16:19:38.584] 1. multicore:
[16:19:38.584]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:38.584]    - tweaked: FALSE
[16:19:38.584]    - call: plan(strategy)
[16:19:38.591] plan(): nbrOfWorkers() = 2
[16:19:38.577] MulticoreFuture:
[16:19:38.577] Label: ‘future_mapply-2’
[16:19:38.577] Expression:
[16:19:38.577] {
[16:19:38.577]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:38.577]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:38.577]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:38.577]         on.exit(options(oopts), add = TRUE)
[16:19:38.577]     }
[16:19:38.577]     {
[16:19:38.577]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:38.577]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:38.577]         do.call(mapply, args = args)
[16:19:38.577]     }
[16:19:38.577] }
[16:19:38.577] Lazy evaluation: FALSE
[16:19:38.577] Asynchronous evaluation: TRUE
[16:19:38.577] Local evaluation: TRUE
[16:19:38.577] Environment: R_GlobalEnv
[16:19:38.577] Capture standard output: FALSE
[16:19:38.577] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:38.577] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:38.577] Packages: <none>
[16:19:38.577] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:38.577] Resolved: TRUE
[16:19:38.577] Value: <not collected>
[16:19:38.577] Conditions captured: <none>
[16:19:38.577] Early signaling: FALSE
[16:19:38.577] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:38.577] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:38.592] Chunk #2 of 2 ... DONE
[16:19:38.592] Launching 2 futures (chunks) ... DONE
[16:19:38.593] Resolving 2 futures (chunks) ...
[16:19:38.593] resolve() on list ...
[16:19:38.593]  recursive: 0
[16:19:38.593]  length: 2
[16:19:38.594] 
[16:19:38.604] Future #2
[16:19:38.605] result() for MulticoreFuture ...
[16:19:38.606] result() for MulticoreFuture ...
[16:19:38.606] result() for MulticoreFuture ... done
[16:19:38.606] result() for MulticoreFuture ... done
[16:19:38.606] result() for MulticoreFuture ...
[16:19:38.606] result() for MulticoreFuture ... done
[16:19:38.607] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:38.607] - nx: 2
[16:19:38.607] - relay: TRUE
[16:19:38.607] - stdout: TRUE
[16:19:38.607] - signal: TRUE
[16:19:38.607] - resignal: FALSE
[16:19:38.607] - force: TRUE
[16:19:38.608] - relayed: [n=2] FALSE, FALSE
[16:19:38.608] - queued futures: [n=2] FALSE, FALSE
[16:19:38.608]  - until=1
[16:19:38.608]  - relaying element #1
[16:19:38.608] - relayed: [n=2] FALSE, FALSE
[16:19:38.608] - queued futures: [n=2] FALSE, TRUE
[16:19:38.609] signalConditionsASAP(NULL, pos=2) ... done
[16:19:38.609]  length: 1 (resolved future 2)
[16:19:39.035] plan(): Setting new future strategy stack:
[16:19:39.035] List of future strategies:
[16:19:39.035] 1. multicore:
[16:19:39.035]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:39.035]    - tweaked: FALSE
[16:19:39.035]    - call: plan(strategy)
[16:19:39.040] plan(): nbrOfWorkers() = 2
[16:19:39.047] Future #1
[16:19:39.047] result() for MulticoreFuture ...
[16:19:39.048] result() for MulticoreFuture ...
[16:19:39.048] result() for MulticoreFuture ... done
[16:19:39.048] result() for MulticoreFuture ... done
[16:19:39.048] result() for MulticoreFuture ...
[16:19:39.048] result() for MulticoreFuture ... done
[16:19:39.048] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:39.049] - nx: 2
[16:19:39.049] - relay: TRUE
[16:19:39.049] - stdout: TRUE
[16:19:39.049] - signal: TRUE
[16:19:39.049] - resignal: FALSE
[16:19:39.049] - force: TRUE
[16:19:39.049] - relayed: [n=2] FALSE, FALSE
[16:19:39.049] - queued futures: [n=2] FALSE, TRUE
[16:19:39.049]  - until=1
[16:19:39.049]  - relaying element #1
[16:19:39.050] result() for MulticoreFuture ...
[16:19:39.050] result() for MulticoreFuture ... done
[16:19:39.050] result() for MulticoreFuture ...
[16:19:39.050] result() for MulticoreFuture ... done
[16:19:39.050] result() for MulticoreFuture ...
[16:19:39.050] result() for MulticoreFuture ... done
[16:19:39.050] result() for MulticoreFuture ...
[16:19:39.050] result() for MulticoreFuture ... done
[16:19:39.050] - relayed: [n=2] TRUE, FALSE
[16:19:39.051] - queued futures: [n=2] TRUE, TRUE
[16:19:39.051] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:39.051]  length: 0 (resolved future 1)
[16:19:39.051] Relaying remaining futures
[16:19:39.051] signalConditionsASAP(NULL, pos=0) ...
[16:19:39.051] - nx: 2
[16:19:39.051] - relay: TRUE
[16:19:39.051] - stdout: TRUE
[16:19:39.051] - signal: TRUE
[16:19:39.052] - resignal: FALSE
[16:19:39.052] - force: TRUE
[16:19:39.052] - relayed: [n=2] TRUE, FALSE
[16:19:39.052] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:39.052]  - relaying element #2
[16:19:39.052] result() for MulticoreFuture ...
[16:19:39.052] result() for MulticoreFuture ... done
[16:19:39.052] result() for MulticoreFuture ...
[16:19:39.053] result() for MulticoreFuture ... done
[16:19:39.053] result() for MulticoreFuture ...
[16:19:39.053] result() for MulticoreFuture ... done
[16:19:39.053] result() for MulticoreFuture ...
[16:19:39.053] result() for MulticoreFuture ... done
[16:19:39.053] - relayed: [n=2] TRUE, TRUE
[16:19:39.053] - queued futures: [n=2] TRUE, TRUE
[16:19:39.053] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:19:39.053] resolve() on list ... DONE
[16:19:39.054] result() for MulticoreFuture ...
[16:19:39.054] result() for MulticoreFuture ... done
[16:19:39.054] result() for MulticoreFuture ...
[16:19:39.054] result() for MulticoreFuture ... done
[16:19:39.054] result() for MulticoreFuture ...
[16:19:39.054] result() for MulticoreFuture ... done
[16:19:39.054] result() for MulticoreFuture ...
[16:19:39.054] result() for MulticoreFuture ... done
[16:19:39.054]  - Number of value chunks collected: 2
[16:19:39.055] Resolving 2 futures (chunks) ... DONE
[16:19:39.055] Reducing values from 2 chunks ...
[16:19:39.055]  - Number of values collected after concatenation: 2
[16:19:39.055]  - Number of values expected: 2
[16:19:39.055] Reducing values from 2 chunks ... DONE
[16:19:39.055] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:19:39.056] future_mapply() ...
[16:19:39.060] Number of chunks: 2
[16:19:39.060] getGlobalsAndPackagesXApply() ...
[16:19:39.060]  - future.globals: TRUE
[16:19:39.061] getGlobalsAndPackages() ...
[16:19:39.061] Searching for globals...
[16:19:39.063] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:39.063] Searching for globals ... DONE
[16:19:39.063] Resolving globals: FALSE
[16:19:39.064] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:39.064] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:39.064] - globals: [1] ‘FUN’
[16:19:39.064] 
[16:19:39.064] getGlobalsAndPackages() ... DONE
[16:19:39.064]  - globals found/used: [n=1] ‘FUN’
[16:19:39.065]  - needed namespaces: [n=0] 
[16:19:39.065] Finding globals ... DONE
[16:19:39.065] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:39.065] List of 2
[16:19:39.065]  $ ...future.FUN:function (x, y)  
[16:19:39.065]  $ MoreArgs     : NULL
[16:19:39.065]  - attr(*, "where")=List of 2
[16:19:39.065]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:39.065]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:39.065]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:39.065]  - attr(*, "resolved")= logi FALSE
[16:19:39.065]  - attr(*, "total_size")= num NA
[16:19:39.070] Packages to be attached in all futures: [n=0] 
[16:19:39.070] getGlobalsAndPackagesXApply() ... DONE
[16:19:39.070] Number of futures (= number of chunks): 2
[16:19:39.071] Launching 2 futures (chunks) ...
[16:19:39.071] Chunk #1 of 2 ...
[16:19:39.071]  - Finding globals in '...' for chunk #1 ...
[16:19:39.071] getGlobalsAndPackages() ...
[16:19:39.071] Searching for globals...
[16:19:39.071] 
[16:19:39.072] Searching for globals ... DONE
[16:19:39.072] - globals: [0] <none>
[16:19:39.072] getGlobalsAndPackages() ... DONE
[16:19:39.072]    + additional globals found: [n=0] 
[16:19:39.072]    + additional namespaces needed: [n=0] 
[16:19:39.072]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:39.072]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:39.072]  - seeds: <none>
[16:19:39.072]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:39.073] getGlobalsAndPackages() ...
[16:19:39.073] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:39.073] Resolving globals: FALSE
[16:19:39.073] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:19:39.074] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:39.074] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:39.074] 
[16:19:39.074] getGlobalsAndPackages() ... DONE
[16:19:39.074] run() for ‘Future’ ...
[16:19:39.074] - state: ‘created’
[16:19:39.075] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:39.078] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:39.078] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:39.078]   - Field: ‘label’
[16:19:39.079]   - Field: ‘local’
[16:19:39.079]   - Field: ‘owner’
[16:19:39.079]   - Field: ‘envir’
[16:19:39.079]   - Field: ‘workers’
[16:19:39.079]   - Field: ‘packages’
[16:19:39.079]   - Field: ‘gc’
[16:19:39.079]   - Field: ‘job’
[16:19:39.079]   - Field: ‘conditions’
[16:19:39.079]   - Field: ‘expr’
[16:19:39.079]   - Field: ‘uuid’
[16:19:39.080]   - Field: ‘seed’
[16:19:39.080]   - Field: ‘version’
[16:19:39.080]   - Field: ‘result’
[16:19:39.080]   - Field: ‘asynchronous’
[16:19:39.080]   - Field: ‘calls’
[16:19:39.080]   - Field: ‘globals’
[16:19:39.080]   - Field: ‘stdout’
[16:19:39.080]   - Field: ‘earlySignal’
[16:19:39.080]   - Field: ‘lazy’
[16:19:39.080]   - Field: ‘state’
[16:19:39.080] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:39.081] - Launch lazy future ...
[16:19:39.081] Packages needed by the future expression (n = 0): <none>
[16:19:39.081] Packages needed by future strategies (n = 0): <none>
[16:19:39.081] {
[16:19:39.081]     {
[16:19:39.081]         {
[16:19:39.081]             ...future.startTime <- base::Sys.time()
[16:19:39.081]             {
[16:19:39.081]                 {
[16:19:39.081]                   {
[16:19:39.081]                     {
[16:19:39.081]                       base::local({
[16:19:39.081]                         has_future <- base::requireNamespace("future", 
[16:19:39.081]                           quietly = TRUE)
[16:19:39.081]                         if (has_future) {
[16:19:39.081]                           ns <- base::getNamespace("future")
[16:19:39.081]                           version <- ns[[".package"]][["version"]]
[16:19:39.081]                           if (is.null(version)) 
[16:19:39.081]                             version <- utils::packageVersion("future")
[16:19:39.081]                         }
[16:19:39.081]                         else {
[16:19:39.081]                           version <- NULL
[16:19:39.081]                         }
[16:19:39.081]                         if (!has_future || version < "1.8.0") {
[16:19:39.081]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:39.081]                             "", base::R.version$version.string), 
[16:19:39.081]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:39.081]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:39.081]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:39.081]                               "release", "version")], collapse = " "), 
[16:19:39.081]                             hostname = base::Sys.info()[["nodename"]])
[16:19:39.081]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:39.081]                             info)
[16:19:39.081]                           info <- base::paste(info, collapse = "; ")
[16:19:39.081]                           if (!has_future) {
[16:19:39.081]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:39.081]                               info)
[16:19:39.081]                           }
[16:19:39.081]                           else {
[16:19:39.081]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:39.081]                               info, version)
[16:19:39.081]                           }
[16:19:39.081]                           base::stop(msg)
[16:19:39.081]                         }
[16:19:39.081]                       })
[16:19:39.081]                     }
[16:19:39.081]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:39.081]                     base::options(mc.cores = 1L)
[16:19:39.081]                   }
[16:19:39.081]                   ...future.strategy.old <- future::plan("list")
[16:19:39.081]                   options(future.plan = NULL)
[16:19:39.081]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:39.081]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:39.081]                 }
[16:19:39.081]                 ...future.workdir <- getwd()
[16:19:39.081]             }
[16:19:39.081]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:39.081]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:39.081]         }
[16:19:39.081]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:39.081]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:39.081]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:39.081]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:39.081]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:39.081]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:39.081]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:39.081]             base::names(...future.oldOptions))
[16:19:39.081]     }
[16:19:39.081]     if (FALSE) {
[16:19:39.081]     }
[16:19:39.081]     else {
[16:19:39.081]         if (TRUE) {
[16:19:39.081]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:39.081]                 open = "w")
[16:19:39.081]         }
[16:19:39.081]         else {
[16:19:39.081]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:39.081]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:39.081]         }
[16:19:39.081]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:39.081]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:39.081]             base::sink(type = "output", split = FALSE)
[16:19:39.081]             base::close(...future.stdout)
[16:19:39.081]         }, add = TRUE)
[16:19:39.081]     }
[16:19:39.081]     ...future.frame <- base::sys.nframe()
[16:19:39.081]     ...future.conditions <- base::list()
[16:19:39.081]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:39.081]     if (FALSE) {
[16:19:39.081]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:39.081]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:39.081]     }
[16:19:39.081]     ...future.result <- base::tryCatch({
[16:19:39.081]         base::withCallingHandlers({
[16:19:39.081]             ...future.value <- base::withVisible(base::local({
[16:19:39.081]                 withCallingHandlers({
[16:19:39.081]                   {
[16:19:39.081]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:39.081]                     if (!identical(...future.globals.maxSize.org, 
[16:19:39.081]                       ...future.globals.maxSize)) {
[16:19:39.081]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:39.081]                       on.exit(options(oopts), add = TRUE)
[16:19:39.081]                     }
[16:19:39.081]                     {
[16:19:39.081]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:39.081]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:39.081]                         USE.NAMES = FALSE)
[16:19:39.081]                       do.call(mapply, args = args)
[16:19:39.081]                     }
[16:19:39.081]                   }
[16:19:39.081]                 }, immediateCondition = function(cond) {
[16:19:39.081]                   save_rds <- function (object, pathname, ...) 
[16:19:39.081]                   {
[16:19:39.081]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:39.081]                     if (file_test("-f", pathname_tmp)) {
[16:19:39.081]                       fi_tmp <- file.info(pathname_tmp)
[16:19:39.081]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:39.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:39.081]                         fi_tmp[["mtime"]])
[16:19:39.081]                     }
[16:19:39.081]                     tryCatch({
[16:19:39.081]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:39.081]                     }, error = function(ex) {
[16:19:39.081]                       msg <- conditionMessage(ex)
[16:19:39.081]                       fi_tmp <- file.info(pathname_tmp)
[16:19:39.081]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:39.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:39.081]                         fi_tmp[["mtime"]], msg)
[16:19:39.081]                       ex$message <- msg
[16:19:39.081]                       stop(ex)
[16:19:39.081]                     })
[16:19:39.081]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:39.081]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:39.081]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:39.081]                       fi_tmp <- file.info(pathname_tmp)
[16:19:39.081]                       fi <- file.info(pathname)
[16:19:39.081]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:39.081]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:39.081]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:39.081]                         fi[["size"]], fi[["mtime"]])
[16:19:39.081]                       stop(msg)
[16:19:39.081]                     }
[16:19:39.081]                     invisible(pathname)
[16:19:39.081]                   }
[16:19:39.081]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:39.081]                     rootPath = tempdir()) 
[16:19:39.081]                   {
[16:19:39.081]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:39.081]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:39.081]                       tmpdir = path, fileext = ".rds")
[16:19:39.081]                     save_rds(obj, file)
[16:19:39.081]                   }
[16:19:39.081]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPcako/.future/immediateConditions")
[16:19:39.081]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:39.081]                   {
[16:19:39.081]                     inherits <- base::inherits
[16:19:39.081]                     invokeRestart <- base::invokeRestart
[16:19:39.081]                     is.null <- base::is.null
[16:19:39.081]                     muffled <- FALSE
[16:19:39.081]                     if (inherits(cond, "message")) {
[16:19:39.081]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:39.081]                       if (muffled) 
[16:19:39.081]                         invokeRestart("muffleMessage")
[16:19:39.081]                     }
[16:19:39.081]                     else if (inherits(cond, "warning")) {
[16:19:39.081]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:39.081]                       if (muffled) 
[16:19:39.081]                         invokeRestart("muffleWarning")
[16:19:39.081]                     }
[16:19:39.081]                     else if (inherits(cond, "condition")) {
[16:19:39.081]                       if (!is.null(pattern)) {
[16:19:39.081]                         computeRestarts <- base::computeRestarts
[16:19:39.081]                         grepl <- base::grepl
[16:19:39.081]                         restarts <- computeRestarts(cond)
[16:19:39.081]                         for (restart in restarts) {
[16:19:39.081]                           name <- restart$name
[16:19:39.081]                           if (is.null(name)) 
[16:19:39.081]                             next
[16:19:39.081]                           if (!grepl(pattern, name)) 
[16:19:39.081]                             next
[16:19:39.081]                           invokeRestart(restart)
[16:19:39.081]                           muffled <- TRUE
[16:19:39.081]                           break
[16:19:39.081]                         }
[16:19:39.081]                       }
[16:19:39.081]                     }
[16:19:39.081]                     invisible(muffled)
[16:19:39.081]                   }
[16:19:39.081]                   muffleCondition(cond)
[16:19:39.081]                 })
[16:19:39.081]             }))
[16:19:39.081]             future::FutureResult(value = ...future.value$value, 
[16:19:39.081]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:39.081]                   ...future.rng), globalenv = if (FALSE) 
[16:19:39.081]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:39.081]                     ...future.globalenv.names))
[16:19:39.081]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:39.081]         }, condition = base::local({
[16:19:39.081]             c <- base::c
[16:19:39.081]             inherits <- base::inherits
[16:19:39.081]             invokeRestart <- base::invokeRestart
[16:19:39.081]             length <- base::length
[16:19:39.081]             list <- base::list
[16:19:39.081]             seq.int <- base::seq.int
[16:19:39.081]             signalCondition <- base::signalCondition
[16:19:39.081]             sys.calls <- base::sys.calls
[16:19:39.081]             `[[` <- base::`[[`
[16:19:39.081]             `+` <- base::`+`
[16:19:39.081]             `<<-` <- base::`<<-`
[16:19:39.081]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:39.081]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:39.081]                   3L)]
[16:19:39.081]             }
[16:19:39.081]             function(cond) {
[16:19:39.081]                 is_error <- inherits(cond, "error")
[16:19:39.081]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:39.081]                   NULL)
[16:19:39.081]                 if (is_error) {
[16:19:39.081]                   sessionInformation <- function() {
[16:19:39.081]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:39.081]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:39.081]                       search = base::search(), system = base::Sys.info())
[16:19:39.081]                   }
[16:19:39.081]                   ...future.conditions[[length(...future.conditions) + 
[16:19:39.081]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:39.081]                     cond$call), session = sessionInformation(), 
[16:19:39.081]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:39.081]                   signalCondition(cond)
[16:19:39.081]                 }
[16:19:39.081]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:39.081]                 "immediateCondition"))) {
[16:19:39.081]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:39.081]                   ...future.conditions[[length(...future.conditions) + 
[16:19:39.081]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:39.081]                   if (TRUE && !signal) {
[16:19:39.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:39.081]                     {
[16:19:39.081]                       inherits <- base::inherits
[16:19:39.081]                       invokeRestart <- base::invokeRestart
[16:19:39.081]                       is.null <- base::is.null
[16:19:39.081]                       muffled <- FALSE
[16:19:39.081]                       if (inherits(cond, "message")) {
[16:19:39.081]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:39.081]                         if (muffled) 
[16:19:39.081]                           invokeRestart("muffleMessage")
[16:19:39.081]                       }
[16:19:39.081]                       else if (inherits(cond, "warning")) {
[16:19:39.081]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:39.081]                         if (muffled) 
[16:19:39.081]                           invokeRestart("muffleWarning")
[16:19:39.081]                       }
[16:19:39.081]                       else if (inherits(cond, "condition")) {
[16:19:39.081]                         if (!is.null(pattern)) {
[16:19:39.081]                           computeRestarts <- base::computeRestarts
[16:19:39.081]                           grepl <- base::grepl
[16:19:39.081]                           restarts <- computeRestarts(cond)
[16:19:39.081]                           for (restart in restarts) {
[16:19:39.081]                             name <- restart$name
[16:19:39.081]                             if (is.null(name)) 
[16:19:39.081]                               next
[16:19:39.081]                             if (!grepl(pattern, name)) 
[16:19:39.081]                               next
[16:19:39.081]                             invokeRestart(restart)
[16:19:39.081]                             muffled <- TRUE
[16:19:39.081]                             break
[16:19:39.081]                           }
[16:19:39.081]                         }
[16:19:39.081]                       }
[16:19:39.081]                       invisible(muffled)
[16:19:39.081]                     }
[16:19:39.081]                     muffleCondition(cond, pattern = "^muffle")
[16:19:39.081]                   }
[16:19:39.081]                 }
[16:19:39.081]                 else {
[16:19:39.081]                   if (TRUE) {
[16:19:39.081]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:39.081]                     {
[16:19:39.081]                       inherits <- base::inherits
[16:19:39.081]                       invokeRestart <- base::invokeRestart
[16:19:39.081]                       is.null <- base::is.null
[16:19:39.081]                       muffled <- FALSE
[16:19:39.081]                       if (inherits(cond, "message")) {
[16:19:39.081]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:39.081]                         if (muffled) 
[16:19:39.081]                           invokeRestart("muffleMessage")
[16:19:39.081]                       }
[16:19:39.081]                       else if (inherits(cond, "warning")) {
[16:19:39.081]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:39.081]                         if (muffled) 
[16:19:39.081]                           invokeRestart("muffleWarning")
[16:19:39.081]                       }
[16:19:39.081]                       else if (inherits(cond, "condition")) {
[16:19:39.081]                         if (!is.null(pattern)) {
[16:19:39.081]                           computeRestarts <- base::computeRestarts
[16:19:39.081]                           grepl <- base::grepl
[16:19:39.081]                           restarts <- computeRestarts(cond)
[16:19:39.081]                           for (restart in restarts) {
[16:19:39.081]                             name <- restart$name
[16:19:39.081]                             if (is.null(name)) 
[16:19:39.081]                               next
[16:19:39.081]                             if (!grepl(pattern, name)) 
[16:19:39.081]                               next
[16:19:39.081]                             invokeRestart(restart)
[16:19:39.081]                             muffled <- TRUE
[16:19:39.081]                             break
[16:19:39.081]                           }
[16:19:39.081]                         }
[16:19:39.081]                       }
[16:19:39.081]                       invisible(muffled)
[16:19:39.081]                     }
[16:19:39.081]                     muffleCondition(cond, pattern = "^muffle")
[16:19:39.081]                   }
[16:19:39.081]                 }
[16:19:39.081]             }
[16:19:39.081]         }))
[16:19:39.081]     }, error = function(ex) {
[16:19:39.081]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:39.081]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:39.081]                 ...future.rng), started = ...future.startTime, 
[16:19:39.081]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:39.081]             version = "1.8"), class = "FutureResult")
[16:19:39.081]     }, finally = {
[16:19:39.081]         if (!identical(...future.workdir, getwd())) 
[16:19:39.081]             setwd(...future.workdir)
[16:19:39.081]         {
[16:19:39.081]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:39.081]                 ...future.oldOptions$nwarnings <- NULL
[16:19:39.081]             }
[16:19:39.081]             base::options(...future.oldOptions)
[16:19:39.081]             if (.Platform$OS.type == "windows") {
[16:19:39.081]                 old_names <- names(...future.oldEnvVars)
[16:19:39.081]                 envs <- base::Sys.getenv()
[16:19:39.081]                 names <- names(envs)
[16:19:39.081]                 common <- intersect(names, old_names)
[16:19:39.081]                 added <- setdiff(names, old_names)
[16:19:39.081]                 removed <- setdiff(old_names, names)
[16:19:39.081]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:39.081]                   envs[common]]
[16:19:39.081]                 NAMES <- toupper(changed)
[16:19:39.081]                 args <- list()
[16:19:39.081]                 for (kk in seq_along(NAMES)) {
[16:19:39.081]                   name <- changed[[kk]]
[16:19:39.081]                   NAME <- NAMES[[kk]]
[16:19:39.081]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:39.081]                     next
[16:19:39.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:39.081]                 }
[16:19:39.081]                 NAMES <- toupper(added)
[16:19:39.081]                 for (kk in seq_along(NAMES)) {
[16:19:39.081]                   name <- added[[kk]]
[16:19:39.081]                   NAME <- NAMES[[kk]]
[16:19:39.081]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:39.081]                     next
[16:19:39.081]                   args[[name]] <- ""
[16:19:39.081]                 }
[16:19:39.081]                 NAMES <- toupper(removed)
[16:19:39.081]                 for (kk in seq_along(NAMES)) {
[16:19:39.081]                   name <- removed[[kk]]
[16:19:39.081]                   NAME <- NAMES[[kk]]
[16:19:39.081]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:39.081]                     next
[16:19:39.081]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:39.081]                 }
[16:19:39.081]                 if (length(args) > 0) 
[16:19:39.081]                   base::do.call(base::Sys.setenv, args = args)
[16:19:39.081]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:39.081]             }
[16:19:39.081]             else {
[16:19:39.081]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:39.081]             }
[16:19:39.081]             {
[16:19:39.081]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:39.081]                   0L) {
[16:19:39.081]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:39.081]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:39.081]                   base::options(opts)
[16:19:39.081]                 }
[16:19:39.081]                 {
[16:19:39.081]                   {
[16:19:39.081]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:39.081]                     NULL
[16:19:39.081]                   }
[16:19:39.081]                   options(future.plan = NULL)
[16:19:39.081]                   if (is.na(NA_character_)) 
[16:19:39.081]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:39.081]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:39.081]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:39.081]                     .init = FALSE)
[16:19:39.081]                 }
[16:19:39.081]             }
[16:19:39.081]         }
[16:19:39.081]     })
[16:19:39.081]     if (TRUE) {
[16:19:39.081]         base::sink(type = "output", split = FALSE)
[16:19:39.081]         if (TRUE) {
[16:19:39.081]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:39.081]         }
[16:19:39.081]         else {
[16:19:39.081]             ...future.result["stdout"] <- base::list(NULL)
[16:19:39.081]         }
[16:19:39.081]         base::close(...future.stdout)
[16:19:39.081]         ...future.stdout <- NULL
[16:19:39.081]     }
[16:19:39.081]     ...future.result$conditions <- ...future.conditions
[16:19:39.081]     ...future.result$finished <- base::Sys.time()
[16:19:39.081]     ...future.result
[16:19:39.081] }
[16:19:39.084] assign_globals() ...
[16:19:39.084] List of 5
[16:19:39.084]  $ ...future.FUN            :function (x, y)  
[16:19:39.084]  $ MoreArgs                 : NULL
[16:19:39.084]  $ ...future.elements_ii    :List of 2
[16:19:39.084]   ..$ :List of 1
[16:19:39.084]   .. ..$ : int 1
[16:19:39.084]   ..$ :List of 1
[16:19:39.084]   .. ..$ : int 0
[16:19:39.084]  $ ...future.seeds_ii       : NULL
[16:19:39.084]  $ ...future.globals.maxSize: NULL
[16:19:39.084]  - attr(*, "where")=List of 5
[16:19:39.084]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:39.084]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:39.084]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:39.084]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:39.084]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:39.084]  - attr(*, "resolved")= logi FALSE
[16:19:39.084]  - attr(*, "total_size")= num 6368
[16:19:39.084]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:39.084]  - attr(*, "already-done")= logi TRUE
[16:19:39.089] - reassign environment for ‘...future.FUN’
[16:19:39.089] - copied ‘...future.FUN’ to environment
[16:19:39.089] - copied ‘MoreArgs’ to environment
[16:19:39.089] - copied ‘...future.elements_ii’ to environment
[16:19:39.089] - copied ‘...future.seeds_ii’ to environment
[16:19:39.089] - copied ‘...future.globals.maxSize’ to environment
[16:19:39.089] assign_globals() ... done
[16:19:39.090] requestCore(): workers = 2
[16:19:39.092] MulticoreFuture started
[16:19:39.092] - Launch lazy future ... done
[16:19:39.093] run() for ‘MulticoreFuture’ ... done
[16:19:39.093] Created future:
[16:19:39.093] plan(): Setting new future strategy stack:
[16:19:39.094] List of future strategies:
[16:19:39.094] 1. sequential:
[16:19:39.094]    - args: function (..., envir = parent.frame())
[16:19:39.094]    - tweaked: FALSE
[16:19:39.094]    - call: NULL
[16:19:39.094] plan(): nbrOfWorkers() = 1
[16:19:39.093] MulticoreFuture:
[16:19:39.093] Label: ‘future_mapply-1’
[16:19:39.093] Expression:
[16:19:39.093] {
[16:19:39.093]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:39.093]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:39.093]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:39.093]         on.exit(options(oopts), add = TRUE)
[16:19:39.093]     }
[16:19:39.093]     {
[16:19:39.093]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:39.093]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:39.093]         do.call(mapply, args = args)
[16:19:39.093]     }
[16:19:39.093] }
[16:19:39.093] Lazy evaluation: FALSE
[16:19:39.093] Asynchronous evaluation: TRUE
[16:19:39.093] Local evaluation: TRUE
[16:19:39.093] Environment: R_GlobalEnv
[16:19:39.093] Capture standard output: TRUE
[16:19:39.093] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:39.093] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:39.093] Packages: <none>
[16:19:39.093] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:39.093] Resolved: FALSE
[16:19:39.093] Value: <not collected>
[16:19:39.093] Conditions captured: <none>
[16:19:39.093] Early signaling: FALSE
[16:19:39.093] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:39.093] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:39.106] Chunk #1 of 2 ... DONE
[16:19:39.106] Chunk #2 of 2 ...
[16:19:39.106]  - Finding globals in '...' for chunk #2 ...
[16:19:39.106] getGlobalsAndPackages() ...
[16:19:39.106] Searching for globals...
[16:19:39.107] 
[16:19:39.107] Searching for globals ... DONE
[16:19:39.107] - globals: [0] <none>
[16:19:39.108] getGlobalsAndPackages() ... DONE
[16:19:39.108]    + additional globals found: [n=0] 
[16:19:39.108]    + additional namespaces needed: [n=0] 
[16:19:39.108]  - Finding globals in '...' for chunk #2 ... DONE
[16:19:39.108]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:39.108]  - seeds: <none>
[16:19:39.109]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:39.109] getGlobalsAndPackages() ...
[16:19:39.109] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:39.109] Resolving globals: FALSE
[16:19:39.110] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:19:39.111] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:39.111] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:39.111] 
[16:19:39.111] getGlobalsAndPackages() ... DONE
[16:19:39.124] run() for ‘Future’ ...
[16:19:39.124] - state: ‘created’
[16:19:39.124] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:39.129] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:39.129] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:39.129]   - Field: ‘label’
[16:19:39.130]   - Field: ‘local’
[16:19:39.130]   - Field: ‘owner’
[16:19:39.130]   - Field: ‘envir’
[16:19:39.130]   - Field: ‘workers’
[16:19:39.130]   - Field: ‘packages’
[16:19:39.131]   - Field: ‘gc’
[16:19:39.131]   - Field: ‘job’
[16:19:39.131]   - Field: ‘conditions’
[16:19:39.131]   - Field: ‘expr’
[16:19:39.131]   - Field: ‘uuid’
[16:19:39.131]   - Field: ‘seed’
[16:19:39.131]   - Field: ‘version’
[16:19:39.132]   - Field: ‘result’
[16:19:39.132]   - Field: ‘asynchronous’
[16:19:39.132]   - Field: ‘calls’
[16:19:39.132]   - Field: ‘globals’
[16:19:39.132]   - Field: ‘stdout’
[16:19:39.132]   - Field: ‘earlySignal’
[16:19:39.132]   - Field: ‘lazy’
[16:19:39.133]   - Field: ‘state’
[16:19:39.133] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:39.133] - Launch lazy future ...
[16:19:39.133] Packages needed by the future expression (n = 0): <none>
[16:19:39.133] Packages needed by future strategies (n = 0): <none>
[16:19:39.134] {
[16:19:39.134]     {
[16:19:39.134]         {
[16:19:39.134]             ...future.startTime <- base::Sys.time()
[16:19:39.134]             {
[16:19:39.134]                 {
[16:19:39.134]                   {
[16:19:39.134]                     {
[16:19:39.134]                       base::local({
[16:19:39.134]                         has_future <- base::requireNamespace("future", 
[16:19:39.134]                           quietly = TRUE)
[16:19:39.134]                         if (has_future) {
[16:19:39.134]                           ns <- base::getNamespace("future")
[16:19:39.134]                           version <- ns[[".package"]][["version"]]
[16:19:39.134]                           if (is.null(version)) 
[16:19:39.134]                             version <- utils::packageVersion("future")
[16:19:39.134]                         }
[16:19:39.134]                         else {
[16:19:39.134]                           version <- NULL
[16:19:39.134]                         }
[16:19:39.134]                         if (!has_future || version < "1.8.0") {
[16:19:39.134]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:39.134]                             "", base::R.version$version.string), 
[16:19:39.134]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:39.134]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:39.134]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:39.134]                               "release", "version")], collapse = " "), 
[16:19:39.134]                             hostname = base::Sys.info()[["nodename"]])
[16:19:39.134]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:39.134]                             info)
[16:19:39.134]                           info <- base::paste(info, collapse = "; ")
[16:19:39.134]                           if (!has_future) {
[16:19:39.134]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:39.134]                               info)
[16:19:39.134]                           }
[16:19:39.134]                           else {
[16:19:39.134]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:39.134]                               info, version)
[16:19:39.134]                           }
[16:19:39.134]                           base::stop(msg)
[16:19:39.134]                         }
[16:19:39.134]                       })
[16:19:39.134]                     }
[16:19:39.134]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:39.134]                     base::options(mc.cores = 1L)
[16:19:39.134]                   }
[16:19:39.134]                   ...future.strategy.old <- future::plan("list")
[16:19:39.134]                   options(future.plan = NULL)
[16:19:39.134]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:39.134]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:39.134]                 }
[16:19:39.134]                 ...future.workdir <- getwd()
[16:19:39.134]             }
[16:19:39.134]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:39.134]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:39.134]         }
[16:19:39.134]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:39.134]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:39.134]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:39.134]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:39.134]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:39.134]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:39.134]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:39.134]             base::names(...future.oldOptions))
[16:19:39.134]     }
[16:19:39.134]     if (FALSE) {
[16:19:39.134]     }
[16:19:39.134]     else {
[16:19:39.134]         if (TRUE) {
[16:19:39.134]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:39.134]                 open = "w")
[16:19:39.134]         }
[16:19:39.134]         else {
[16:19:39.134]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:39.134]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:39.134]         }
[16:19:39.134]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:39.134]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:39.134]             base::sink(type = "output", split = FALSE)
[16:19:39.134]             base::close(...future.stdout)
[16:19:39.134]         }, add = TRUE)
[16:19:39.134]     }
[16:19:39.134]     ...future.frame <- base::sys.nframe()
[16:19:39.134]     ...future.conditions <- base::list()
[16:19:39.134]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:39.134]     if (FALSE) {
[16:19:39.134]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:39.134]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:39.134]     }
[16:19:39.134]     ...future.result <- base::tryCatch({
[16:19:39.134]         base::withCallingHandlers({
[16:19:39.134]             ...future.value <- base::withVisible(base::local({
[16:19:39.134]                 withCallingHandlers({
[16:19:39.134]                   {
[16:19:39.134]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:39.134]                     if (!identical(...future.globals.maxSize.org, 
[16:19:39.134]                       ...future.globals.maxSize)) {
[16:19:39.134]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:39.134]                       on.exit(options(oopts), add = TRUE)
[16:19:39.134]                     }
[16:19:39.134]                     {
[16:19:39.134]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:39.134]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:39.134]                         USE.NAMES = FALSE)
[16:19:39.134]                       do.call(mapply, args = args)
[16:19:39.134]                     }
[16:19:39.134]                   }
[16:19:39.134]                 }, immediateCondition = function(cond) {
[16:19:39.134]                   save_rds <- function (object, pathname, ...) 
[16:19:39.134]                   {
[16:19:39.134]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:39.134]                     if (file_test("-f", pathname_tmp)) {
[16:19:39.134]                       fi_tmp <- file.info(pathname_tmp)
[16:19:39.134]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:39.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:39.134]                         fi_tmp[["mtime"]])
[16:19:39.134]                     }
[16:19:39.134]                     tryCatch({
[16:19:39.134]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:39.134]                     }, error = function(ex) {
[16:19:39.134]                       msg <- conditionMessage(ex)
[16:19:39.134]                       fi_tmp <- file.info(pathname_tmp)
[16:19:39.134]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:39.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:39.134]                         fi_tmp[["mtime"]], msg)
[16:19:39.134]                       ex$message <- msg
[16:19:39.134]                       stop(ex)
[16:19:39.134]                     })
[16:19:39.134]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:39.134]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:39.134]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:39.134]                       fi_tmp <- file.info(pathname_tmp)
[16:19:39.134]                       fi <- file.info(pathname)
[16:19:39.134]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:39.134]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:39.134]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:39.134]                         fi[["size"]], fi[["mtime"]])
[16:19:39.134]                       stop(msg)
[16:19:39.134]                     }
[16:19:39.134]                     invisible(pathname)
[16:19:39.134]                   }
[16:19:39.134]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:39.134]                     rootPath = tempdir()) 
[16:19:39.134]                   {
[16:19:39.134]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:39.134]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:39.134]                       tmpdir = path, fileext = ".rds")
[16:19:39.134]                     save_rds(obj, file)
[16:19:39.134]                   }
[16:19:39.134]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPcako/.future/immediateConditions")
[16:19:39.134]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:39.134]                   {
[16:19:39.134]                     inherits <- base::inherits
[16:19:39.134]                     invokeRestart <- base::invokeRestart
[16:19:39.134]                     is.null <- base::is.null
[16:19:39.134]                     muffled <- FALSE
[16:19:39.134]                     if (inherits(cond, "message")) {
[16:19:39.134]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:39.134]                       if (muffled) 
[16:19:39.134]                         invokeRestart("muffleMessage")
[16:19:39.134]                     }
[16:19:39.134]                     else if (inherits(cond, "warning")) {
[16:19:39.134]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:39.134]                       if (muffled) 
[16:19:39.134]                         invokeRestart("muffleWarning")
[16:19:39.134]                     }
[16:19:39.134]                     else if (inherits(cond, "condition")) {
[16:19:39.134]                       if (!is.null(pattern)) {
[16:19:39.134]                         computeRestarts <- base::computeRestarts
[16:19:39.134]                         grepl <- base::grepl
[16:19:39.134]                         restarts <- computeRestarts(cond)
[16:19:39.134]                         for (restart in restarts) {
[16:19:39.134]                           name <- restart$name
[16:19:39.134]                           if (is.null(name)) 
[16:19:39.134]                             next
[16:19:39.134]                           if (!grepl(pattern, name)) 
[16:19:39.134]                             next
[16:19:39.134]                           invokeRestart(restart)
[16:19:39.134]                           muffled <- TRUE
[16:19:39.134]                           break
[16:19:39.134]                         }
[16:19:39.134]                       }
[16:19:39.134]                     }
[16:19:39.134]                     invisible(muffled)
[16:19:39.134]                   }
[16:19:39.134]                   muffleCondition(cond)
[16:19:39.134]                 })
[16:19:39.134]             }))
[16:19:39.134]             future::FutureResult(value = ...future.value$value, 
[16:19:39.134]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:39.134]                   ...future.rng), globalenv = if (FALSE) 
[16:19:39.134]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:39.134]                     ...future.globalenv.names))
[16:19:39.134]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:39.134]         }, condition = base::local({
[16:19:39.134]             c <- base::c
[16:19:39.134]             inherits <- base::inherits
[16:19:39.134]             invokeRestart <- base::invokeRestart
[16:19:39.134]             length <- base::length
[16:19:39.134]             list <- base::list
[16:19:39.134]             seq.int <- base::seq.int
[16:19:39.134]             signalCondition <- base::signalCondition
[16:19:39.134]             sys.calls <- base::sys.calls
[16:19:39.134]             `[[` <- base::`[[`
[16:19:39.134]             `+` <- base::`+`
[16:19:39.134]             `<<-` <- base::`<<-`
[16:19:39.134]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:39.134]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:39.134]                   3L)]
[16:19:39.134]             }
[16:19:39.134]             function(cond) {
[16:19:39.134]                 is_error <- inherits(cond, "error")
[16:19:39.134]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:39.134]                   NULL)
[16:19:39.134]                 if (is_error) {
[16:19:39.134]                   sessionInformation <- function() {
[16:19:39.134]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:39.134]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:39.134]                       search = base::search(), system = base::Sys.info())
[16:19:39.134]                   }
[16:19:39.134]                   ...future.conditions[[length(...future.conditions) + 
[16:19:39.134]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:39.134]                     cond$call), session = sessionInformation(), 
[16:19:39.134]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:39.134]                   signalCondition(cond)
[16:19:39.134]                 }
[16:19:39.134]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:39.134]                 "immediateCondition"))) {
[16:19:39.134]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:39.134]                   ...future.conditions[[length(...future.conditions) + 
[16:19:39.134]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:39.134]                   if (TRUE && !signal) {
[16:19:39.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:39.134]                     {
[16:19:39.134]                       inherits <- base::inherits
[16:19:39.134]                       invokeRestart <- base::invokeRestart
[16:19:39.134]                       is.null <- base::is.null
[16:19:39.134]                       muffled <- FALSE
[16:19:39.134]                       if (inherits(cond, "message")) {
[16:19:39.134]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:39.134]                         if (muffled) 
[16:19:39.134]                           invokeRestart("muffleMessage")
[16:19:39.134]                       }
[16:19:39.134]                       else if (inherits(cond, "warning")) {
[16:19:39.134]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:39.134]                         if (muffled) 
[16:19:39.134]                           invokeRestart("muffleWarning")
[16:19:39.134]                       }
[16:19:39.134]                       else if (inherits(cond, "condition")) {
[16:19:39.134]                         if (!is.null(pattern)) {
[16:19:39.134]                           computeRestarts <- base::computeRestarts
[16:19:39.134]                           grepl <- base::grepl
[16:19:39.134]                           restarts <- computeRestarts(cond)
[16:19:39.134]                           for (restart in restarts) {
[16:19:39.134]                             name <- restart$name
[16:19:39.134]                             if (is.null(name)) 
[16:19:39.134]                               next
[16:19:39.134]                             if (!grepl(pattern, name)) 
[16:19:39.134]                               next
[16:19:39.134]                             invokeRestart(restart)
[16:19:39.134]                             muffled <- TRUE
[16:19:39.134]                             break
[16:19:39.134]                           }
[16:19:39.134]                         }
[16:19:39.134]                       }
[16:19:39.134]                       invisible(muffled)
[16:19:39.134]                     }
[16:19:39.134]                     muffleCondition(cond, pattern = "^muffle")
[16:19:39.134]                   }
[16:19:39.134]                 }
[16:19:39.134]                 else {
[16:19:39.134]                   if (TRUE) {
[16:19:39.134]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:39.134]                     {
[16:19:39.134]                       inherits <- base::inherits
[16:19:39.134]                       invokeRestart <- base::invokeRestart
[16:19:39.134]                       is.null <- base::is.null
[16:19:39.134]                       muffled <- FALSE
[16:19:39.134]                       if (inherits(cond, "message")) {
[16:19:39.134]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:39.134]                         if (muffled) 
[16:19:39.134]                           invokeRestart("muffleMessage")
[16:19:39.134]                       }
[16:19:39.134]                       else if (inherits(cond, "warning")) {
[16:19:39.134]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:39.134]                         if (muffled) 
[16:19:39.134]                           invokeRestart("muffleWarning")
[16:19:39.134]                       }
[16:19:39.134]                       else if (inherits(cond, "condition")) {
[16:19:39.134]                         if (!is.null(pattern)) {
[16:19:39.134]                           computeRestarts <- base::computeRestarts
[16:19:39.134]                           grepl <- base::grepl
[16:19:39.134]                           restarts <- computeRestarts(cond)
[16:19:39.134]                           for (restart in restarts) {
[16:19:39.134]                             name <- restart$name
[16:19:39.134]                             if (is.null(name)) 
[16:19:39.134]                               next
[16:19:39.134]                             if (!grepl(pattern, name)) 
[16:19:39.134]                               next
[16:19:39.134]                             invokeRestart(restart)
[16:19:39.134]                             muffled <- TRUE
[16:19:39.134]                             break
[16:19:39.134]                           }
[16:19:39.134]                         }
[16:19:39.134]                       }
[16:19:39.134]                       invisible(muffled)
[16:19:39.134]                     }
[16:19:39.134]                     muffleCondition(cond, pattern = "^muffle")
[16:19:39.134]                   }
[16:19:39.134]                 }
[16:19:39.134]             }
[16:19:39.134]         }))
[16:19:39.134]     }, error = function(ex) {
[16:19:39.134]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:39.134]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:39.134]                 ...future.rng), started = ...future.startTime, 
[16:19:39.134]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:39.134]             version = "1.8"), class = "FutureResult")
[16:19:39.134]     }, finally = {
[16:19:39.134]         if (!identical(...future.workdir, getwd())) 
[16:19:39.134]             setwd(...future.workdir)
[16:19:39.134]         {
[16:19:39.134]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:39.134]                 ...future.oldOptions$nwarnings <- NULL
[16:19:39.134]             }
[16:19:39.134]             base::options(...future.oldOptions)
[16:19:39.134]             if (.Platform$OS.type == "windows") {
[16:19:39.134]                 old_names <- names(...future.oldEnvVars)
[16:19:39.134]                 envs <- base::Sys.getenv()
[16:19:39.134]                 names <- names(envs)
[16:19:39.134]                 common <- intersect(names, old_names)
[16:19:39.134]                 added <- setdiff(names, old_names)
[16:19:39.134]                 removed <- setdiff(old_names, names)
[16:19:39.134]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:39.134]                   envs[common]]
[16:19:39.134]                 NAMES <- toupper(changed)
[16:19:39.134]                 args <- list()
[16:19:39.134]                 for (kk in seq_along(NAMES)) {
[16:19:39.134]                   name <- changed[[kk]]
[16:19:39.134]                   NAME <- NAMES[[kk]]
[16:19:39.134]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:39.134]                     next
[16:19:39.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:39.134]                 }
[16:19:39.134]                 NAMES <- toupper(added)
[16:19:39.134]                 for (kk in seq_along(NAMES)) {
[16:19:39.134]                   name <- added[[kk]]
[16:19:39.134]                   NAME <- NAMES[[kk]]
[16:19:39.134]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:39.134]                     next
[16:19:39.134]                   args[[name]] <- ""
[16:19:39.134]                 }
[16:19:39.134]                 NAMES <- toupper(removed)
[16:19:39.134]                 for (kk in seq_along(NAMES)) {
[16:19:39.134]                   name <- removed[[kk]]
[16:19:39.134]                   NAME <- NAMES[[kk]]
[16:19:39.134]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:39.134]                     next
[16:19:39.134]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:39.134]                 }
[16:19:39.134]                 if (length(args) > 0) 
[16:19:39.134]                   base::do.call(base::Sys.setenv, args = args)
[16:19:39.134]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:39.134]             }
[16:19:39.134]             else {
[16:19:39.134]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:39.134]             }
[16:19:39.134]             {
[16:19:39.134]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:39.134]                   0L) {
[16:19:39.134]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:39.134]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:39.134]                   base::options(opts)
[16:19:39.134]                 }
[16:19:39.134]                 {
[16:19:39.134]                   {
[16:19:39.134]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:39.134]                     NULL
[16:19:39.134]                   }
[16:19:39.134]                   options(future.plan = NULL)
[16:19:39.134]                   if (is.na(NA_character_)) 
[16:19:39.134]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:39.134]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:39.134]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:39.134]                     .init = FALSE)
[16:19:39.134]                 }
[16:19:39.134]             }
[16:19:39.134]         }
[16:19:39.134]     })
[16:19:39.134]     if (TRUE) {
[16:19:39.134]         base::sink(type = "output", split = FALSE)
[16:19:39.134]         if (TRUE) {
[16:19:39.134]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:39.134]         }
[16:19:39.134]         else {
[16:19:39.134]             ...future.result["stdout"] <- base::list(NULL)
[16:19:39.134]         }
[16:19:39.134]         base::close(...future.stdout)
[16:19:39.134]         ...future.stdout <- NULL
[16:19:39.134]     }
[16:19:39.134]     ...future.result$conditions <- ...future.conditions
[16:19:39.134]     ...future.result$finished <- base::Sys.time()
[16:19:39.134]     ...future.result
[16:19:39.134] }
[16:19:39.137] assign_globals() ...
[16:19:39.137] List of 5
[16:19:39.137]  $ ...future.FUN            :function (x, y)  
[16:19:39.137]  $ MoreArgs                 : NULL
[16:19:39.137]  $ ...future.elements_ii    :List of 2
[16:19:39.137]   ..$ :List of 1
[16:19:39.137]   .. ..$ : int 0
[16:19:39.137]   ..$ :List of 1
[16:19:39.137]   .. ..$ : int 1
[16:19:39.137]  $ ...future.seeds_ii       : NULL
[16:19:39.137]  $ ...future.globals.maxSize: NULL
[16:19:39.137]  - attr(*, "where")=List of 5
[16:19:39.137]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:39.137]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:39.137]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:39.137]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:39.137]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:39.137]  - attr(*, "resolved")= logi FALSE
[16:19:39.137]  - attr(*, "total_size")= num 6368
[16:19:39.137]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:39.137]  - attr(*, "already-done")= logi TRUE
[16:19:39.144] - reassign environment for ‘...future.FUN’
[16:19:39.144] - copied ‘...future.FUN’ to environment
[16:19:39.144] - copied ‘MoreArgs’ to environment
[16:19:39.144] - copied ‘...future.elements_ii’ to environment
[16:19:39.144] - copied ‘...future.seeds_ii’ to environment
[16:19:39.144] - copied ‘...future.globals.maxSize’ to environment
[16:19:39.144] assign_globals() ... done
[16:19:39.145] requestCore(): workers = 2
[16:19:39.147] MulticoreFuture started
[16:19:39.147] - Launch lazy future ... done
[16:19:39.147] run() for ‘MulticoreFuture’ ... done
[16:19:39.148] Created future:
[16:19:39.148] plan(): Setting new future strategy stack:
[16:19:39.148] List of future strategies:
[16:19:39.148] 1. sequential:
[16:19:39.148]    - args: function (..., envir = parent.frame())
[16:19:39.148]    - tweaked: FALSE
[16:19:39.148]    - call: NULL
[16:19:39.149] plan(): nbrOfWorkers() = 1
[16:19:39.151] plan(): Setting new future strategy stack:
[16:19:39.151] List of future strategies:
[16:19:39.151] 1. multicore:
[16:19:39.151]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:39.151]    - tweaked: FALSE
[16:19:39.151]    - call: plan(strategy)
[16:19:39.157] plan(): nbrOfWorkers() = 2
[16:19:39.148] MulticoreFuture:
[16:19:39.148] Label: ‘future_mapply-2’
[16:19:39.148] Expression:
[16:19:39.148] {
[16:19:39.148]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:39.148]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:39.148]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:39.148]         on.exit(options(oopts), add = TRUE)
[16:19:39.148]     }
[16:19:39.148]     {
[16:19:39.148]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:39.148]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:39.148]         do.call(mapply, args = args)
[16:19:39.148]     }
[16:19:39.148] }
[16:19:39.148] Lazy evaluation: FALSE
[16:19:39.148] Asynchronous evaluation: TRUE
[16:19:39.148] Local evaluation: TRUE
[16:19:39.148] Environment: R_GlobalEnv
[16:19:39.148] Capture standard output: TRUE
[16:19:39.148] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:39.148] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:39.148] Packages: <none>
[16:19:39.148] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:39.148] Resolved: TRUE
[16:19:39.148] Value: <not collected>
[16:19:39.148] Conditions captured: <none>
[16:19:39.148] Early signaling: FALSE
[16:19:39.148] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:39.148] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:39.158] Chunk #2 of 2 ... DONE
[16:19:39.158] Launching 2 futures (chunks) ... DONE
[16:19:39.158] Resolving 2 futures (chunks) ...
[16:19:39.158] resolve() on list ...
[16:19:39.158]  recursive: 0
[16:19:39.158]  length: 2
[16:19:39.158] 
[16:19:39.169] Future #2
[16:19:39.169] result() for MulticoreFuture ...
[16:19:39.170] result() for MulticoreFuture ...
[16:19:39.170] result() for MulticoreFuture ... done
[16:19:39.170] result() for MulticoreFuture ... done
[16:19:39.171] result() for MulticoreFuture ...
[16:19:39.171] result() for MulticoreFuture ... done
[16:19:39.171] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:39.171] - nx: 2
[16:19:39.171] - relay: TRUE
[16:19:39.171] - stdout: TRUE
[16:19:39.171] - signal: TRUE
[16:19:39.172] - resignal: FALSE
[16:19:39.172] - force: TRUE
[16:19:39.172] - relayed: [n=2] FALSE, FALSE
[16:19:39.172] - queued futures: [n=2] FALSE, FALSE
[16:19:39.172]  - until=1
[16:19:39.172]  - relaying element #1
[16:19:39.172] - relayed: [n=2] FALSE, FALSE
[16:19:39.173] - queued futures: [n=2] FALSE, TRUE
[16:19:39.173] signalConditionsASAP(NULL, pos=2) ... done
[16:19:39.173]  length: 1 (resolved future 2)
[16:19:39.597] plan(): Setting new future strategy stack:
[16:19:39.597] List of future strategies:
[16:19:39.597] 1. multicore:
[16:19:39.597]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:39.597]    - tweaked: FALSE
[16:19:39.597]    - call: plan(strategy)
[16:19:39.602] plan(): nbrOfWorkers() = 2
[16:19:39.611] Future #1
[16:19:39.611] result() for MulticoreFuture ...
[16:19:39.612] result() for MulticoreFuture ...
[16:19:39.612] result() for MulticoreFuture ... done
[16:19:39.612] result() for MulticoreFuture ... done
[16:19:39.612] result() for MulticoreFuture ...
[16:19:39.612] result() for MulticoreFuture ... done
[16:19:39.612] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:39.613] - nx: 2
[16:19:39.613] - relay: TRUE
[16:19:39.613] - stdout: TRUE
[16:19:39.613] - signal: TRUE
[16:19:39.613] - resignal: FALSE
[16:19:39.613] - force: TRUE
[16:19:39.613] - relayed: [n=2] FALSE, FALSE
[16:19:39.613] - queued futures: [n=2] FALSE, TRUE
[16:19:39.614]  - until=1
[16:19:39.614]  - relaying element #1
[16:19:39.614] result() for MulticoreFuture ...
[16:19:39.614] result() for MulticoreFuture ... done
[16:19:39.614] result() for MulticoreFuture ...
[16:19:39.614] result() for MulticoreFuture ... done
[16:19:39.614] result() for MulticoreFuture ...
[16:19:39.614] result() for MulticoreFuture ... done
[16:19:39.614] result() for MulticoreFuture ...
[16:19:39.615] result() for MulticoreFuture ... done
[16:19:39.615] - relayed: [n=2] TRUE, FALSE
[16:19:39.615] - queued futures: [n=2] TRUE, TRUE
[16:19:39.615] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:39.615]  length: 0 (resolved future 1)
[16:19:39.615] Relaying remaining futures
[16:19:39.615] signalConditionsASAP(NULL, pos=0) ...
[16:19:39.615] - nx: 2
[16:19:39.616] - relay: TRUE
[16:19:39.616] - stdout: TRUE
[16:19:39.616] - signal: TRUE
[16:19:39.616] - resignal: FALSE
[16:19:39.618] - force: TRUE
[16:19:39.619] - relayed: [n=2] TRUE, FALSE
[16:19:39.619] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:39.619]  - relaying element #2
[16:19:39.619] result() for MulticoreFuture ...
[16:19:39.620] result() for MulticoreFuture ... done
[16:19:39.620] result() for MulticoreFuture ...
[16:19:39.620] result() for MulticoreFuture ... done
[16:19:39.620] result() for MulticoreFuture ...
[16:19:39.620] result() for MulticoreFuture ... done
[16:19:39.621] result() for MulticoreFuture ...
[16:19:39.621] result() for MulticoreFuture ... done
[16:19:39.621] - relayed: [n=2] TRUE, TRUE
[16:19:39.621] - queued futures: [n=2] TRUE, TRUE
[16:19:39.621] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:19:39.621] resolve() on list ... DONE
[16:19:39.621] result() for MulticoreFuture ...
[16:19:39.622] result() for MulticoreFuture ... done
[16:19:39.622] result() for MulticoreFuture ...
[16:19:39.622] result() for MulticoreFuture ... done
[16:19:39.622] result() for MulticoreFuture ...
[16:19:39.622] result() for MulticoreFuture ... done
[16:19:39.622] result() for MulticoreFuture ...
[16:19:39.622] result() for MulticoreFuture ... done
[16:19:39.623]  - Number of value chunks collected: 2
[16:19:39.623] Resolving 2 futures (chunks) ... DONE
[16:19:39.623] Reducing values from 2 chunks ...
[16:19:39.623]  - Number of values collected after concatenation: 2
[16:19:39.623]  - Number of values expected: 2
[16:19:39.623] Reducing values from 2 chunks ... DONE
[16:19:39.623] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:19:39.624] future_mapply() ...
[16:19:39.628] Number of chunks: 2
[16:19:39.628] getGlobalsAndPackagesXApply() ...
[16:19:39.628]  - future.globals: TRUE
[16:19:39.629] getGlobalsAndPackages() ...
[16:19:39.629] Searching for globals...
[16:19:39.631] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:39.631] Searching for globals ... DONE
[16:19:39.631] Resolving globals: FALSE
[16:19:39.631] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:39.632] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:39.632] - globals: [1] ‘FUN’
[16:19:39.632] 
[16:19:39.632] getGlobalsAndPackages() ... DONE
[16:19:39.632]  - globals found/used: [n=1] ‘FUN’
[16:19:39.632]  - needed namespaces: [n=0] 
[16:19:39.633] Finding globals ... DONE
[16:19:39.633] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:39.633] List of 2
[16:19:39.633]  $ ...future.FUN:function (x, y)  
[16:19:39.633]  $ MoreArgs     : NULL
[16:19:39.633]  - attr(*, "where")=List of 2
[16:19:39.633]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:39.633]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:39.633]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:39.633]  - attr(*, "resolved")= logi FALSE
[16:19:39.633]  - attr(*, "total_size")= num NA
[16:19:39.636] Packages to be attached in all futures: [n=0] 
[16:19:39.636] getGlobalsAndPackagesXApply() ... DONE
[16:19:39.636] Number of futures (= number of chunks): 2
[16:19:39.636] Launching 2 futures (chunks) ...
[16:19:39.636] Chunk #1 of 2 ...
[16:19:39.636]  - Finding globals in '...' for chunk #1 ...
[16:19:39.636] getGlobalsAndPackages() ...
[16:19:39.637] Searching for globals...
[16:19:39.637] 
[16:19:39.637] Searching for globals ... DONE
[16:19:39.637] - globals: [0] <none>
[16:19:39.637] getGlobalsAndPackages() ... DONE
[16:19:39.637]    + additional globals found: [n=0] 
[16:19:39.637]    + additional namespaces needed: [n=0] 
[16:19:39.637]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:39.638]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:39.638]  - seeds: <none>
[16:19:39.638]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:39.638] getGlobalsAndPackages() ...
[16:19:39.638] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:39.638] Resolving globals: FALSE
[16:19:39.638] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:19:39.639] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:39.639] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:39.639] 
[16:19:39.639] getGlobalsAndPackages() ... DONE
[16:19:39.640] run() for ‘Future’ ...
[16:19:39.640] - state: ‘created’
[16:19:39.640] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:39.643] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:39.644] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:39.644]   - Field: ‘label’
[16:19:39.644]   - Field: ‘local’
[16:19:39.644]   - Field: ‘owner’
[16:19:39.644]   - Field: ‘envir’
[16:19:39.644]   - Field: ‘workers’
[16:19:39.644]   - Field: ‘packages’
[16:19:39.645]   - Field: ‘gc’
[16:19:39.645]   - Field: ‘job’
[16:19:39.645]   - Field: ‘conditions’
[16:19:39.645]   - Field: ‘expr’
[16:19:39.645]   - Field: ‘uuid’
[16:19:39.645]   - Field: ‘seed’
[16:19:39.645]   - Field: ‘version’
[16:19:39.645]   - Field: ‘result’
[16:19:39.645]   - Field: ‘asynchronous’
[16:19:39.646]   - Field: ‘calls’
[16:19:39.646]   - Field: ‘globals’
[16:19:39.646]   - Field: ‘stdout’
[16:19:39.646]   - Field: ‘earlySignal’
[16:19:39.646]   - Field: ‘lazy’
[16:19:39.646]   - Field: ‘state’
[16:19:39.646] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:39.646] - Launch lazy future ...
[16:19:39.647] Packages needed by the future expression (n = 0): <none>
[16:19:39.647] Packages needed by future strategies (n = 0): <none>
[16:19:39.647] {
[16:19:39.647]     {
[16:19:39.647]         {
[16:19:39.647]             ...future.startTime <- base::Sys.time()
[16:19:39.647]             {
[16:19:39.647]                 {
[16:19:39.647]                   {
[16:19:39.647]                     {
[16:19:39.647]                       base::local({
[16:19:39.647]                         has_future <- base::requireNamespace("future", 
[16:19:39.647]                           quietly = TRUE)
[16:19:39.647]                         if (has_future) {
[16:19:39.647]                           ns <- base::getNamespace("future")
[16:19:39.647]                           version <- ns[[".package"]][["version"]]
[16:19:39.647]                           if (is.null(version)) 
[16:19:39.647]                             version <- utils::packageVersion("future")
[16:19:39.647]                         }
[16:19:39.647]                         else {
[16:19:39.647]                           version <- NULL
[16:19:39.647]                         }
[16:19:39.647]                         if (!has_future || version < "1.8.0") {
[16:19:39.647]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:39.647]                             "", base::R.version$version.string), 
[16:19:39.647]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:39.647]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:39.647]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:39.647]                               "release", "version")], collapse = " "), 
[16:19:39.647]                             hostname = base::Sys.info()[["nodename"]])
[16:19:39.647]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:39.647]                             info)
[16:19:39.647]                           info <- base::paste(info, collapse = "; ")
[16:19:39.647]                           if (!has_future) {
[16:19:39.647]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:39.647]                               info)
[16:19:39.647]                           }
[16:19:39.647]                           else {
[16:19:39.647]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:39.647]                               info, version)
[16:19:39.647]                           }
[16:19:39.647]                           base::stop(msg)
[16:19:39.647]                         }
[16:19:39.647]                       })
[16:19:39.647]                     }
[16:19:39.647]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:39.647]                     base::options(mc.cores = 1L)
[16:19:39.647]                   }
[16:19:39.647]                   ...future.strategy.old <- future::plan("list")
[16:19:39.647]                   options(future.plan = NULL)
[16:19:39.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:39.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:39.647]                 }
[16:19:39.647]                 ...future.workdir <- getwd()
[16:19:39.647]             }
[16:19:39.647]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:39.647]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:39.647]         }
[16:19:39.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:39.647]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:39.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:39.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:39.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:39.647]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:39.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:39.647]             base::names(...future.oldOptions))
[16:19:39.647]     }
[16:19:39.647]     if (TRUE) {
[16:19:39.647]     }
[16:19:39.647]     else {
[16:19:39.647]         if (NA) {
[16:19:39.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:39.647]                 open = "w")
[16:19:39.647]         }
[16:19:39.647]         else {
[16:19:39.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:39.647]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:39.647]         }
[16:19:39.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:39.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:39.647]             base::sink(type = "output", split = FALSE)
[16:19:39.647]             base::close(...future.stdout)
[16:19:39.647]         }, add = TRUE)
[16:19:39.647]     }
[16:19:39.647]     ...future.frame <- base::sys.nframe()
[16:19:39.647]     ...future.conditions <- base::list()
[16:19:39.647]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:39.647]     if (FALSE) {
[16:19:39.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:39.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:39.647]     }
[16:19:39.647]     ...future.result <- base::tryCatch({
[16:19:39.647]         base::withCallingHandlers({
[16:19:39.647]             ...future.value <- base::withVisible(base::local({
[16:19:39.647]                 withCallingHandlers({
[16:19:39.647]                   {
[16:19:39.647]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:39.647]                     if (!identical(...future.globals.maxSize.org, 
[16:19:39.647]                       ...future.globals.maxSize)) {
[16:19:39.647]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:39.647]                       on.exit(options(oopts), add = TRUE)
[16:19:39.647]                     }
[16:19:39.647]                     {
[16:19:39.647]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:39.647]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:39.647]                         USE.NAMES = FALSE)
[16:19:39.647]                       do.call(mapply, args = args)
[16:19:39.647]                     }
[16:19:39.647]                   }
[16:19:39.647]                 }, immediateCondition = function(cond) {
[16:19:39.647]                   save_rds <- function (object, pathname, ...) 
[16:19:39.647]                   {
[16:19:39.647]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:39.647]                     if (file_test("-f", pathname_tmp)) {
[16:19:39.647]                       fi_tmp <- file.info(pathname_tmp)
[16:19:39.647]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:39.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:39.647]                         fi_tmp[["mtime"]])
[16:19:39.647]                     }
[16:19:39.647]                     tryCatch({
[16:19:39.647]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:39.647]                     }, error = function(ex) {
[16:19:39.647]                       msg <- conditionMessage(ex)
[16:19:39.647]                       fi_tmp <- file.info(pathname_tmp)
[16:19:39.647]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:39.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:39.647]                         fi_tmp[["mtime"]], msg)
[16:19:39.647]                       ex$message <- msg
[16:19:39.647]                       stop(ex)
[16:19:39.647]                     })
[16:19:39.647]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:39.647]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:39.647]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:39.647]                       fi_tmp <- file.info(pathname_tmp)
[16:19:39.647]                       fi <- file.info(pathname)
[16:19:39.647]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:39.647]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:39.647]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:39.647]                         fi[["size"]], fi[["mtime"]])
[16:19:39.647]                       stop(msg)
[16:19:39.647]                     }
[16:19:39.647]                     invisible(pathname)
[16:19:39.647]                   }
[16:19:39.647]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:39.647]                     rootPath = tempdir()) 
[16:19:39.647]                   {
[16:19:39.647]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:39.647]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:39.647]                       tmpdir = path, fileext = ".rds")
[16:19:39.647]                     save_rds(obj, file)
[16:19:39.647]                   }
[16:19:39.647]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPcako/.future/immediateConditions")
[16:19:39.647]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:39.647]                   {
[16:19:39.647]                     inherits <- base::inherits
[16:19:39.647]                     invokeRestart <- base::invokeRestart
[16:19:39.647]                     is.null <- base::is.null
[16:19:39.647]                     muffled <- FALSE
[16:19:39.647]                     if (inherits(cond, "message")) {
[16:19:39.647]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:39.647]                       if (muffled) 
[16:19:39.647]                         invokeRestart("muffleMessage")
[16:19:39.647]                     }
[16:19:39.647]                     else if (inherits(cond, "warning")) {
[16:19:39.647]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:39.647]                       if (muffled) 
[16:19:39.647]                         invokeRestart("muffleWarning")
[16:19:39.647]                     }
[16:19:39.647]                     else if (inherits(cond, "condition")) {
[16:19:39.647]                       if (!is.null(pattern)) {
[16:19:39.647]                         computeRestarts <- base::computeRestarts
[16:19:39.647]                         grepl <- base::grepl
[16:19:39.647]                         restarts <- computeRestarts(cond)
[16:19:39.647]                         for (restart in restarts) {
[16:19:39.647]                           name <- restart$name
[16:19:39.647]                           if (is.null(name)) 
[16:19:39.647]                             next
[16:19:39.647]                           if (!grepl(pattern, name)) 
[16:19:39.647]                             next
[16:19:39.647]                           invokeRestart(restart)
[16:19:39.647]                           muffled <- TRUE
[16:19:39.647]                           break
[16:19:39.647]                         }
[16:19:39.647]                       }
[16:19:39.647]                     }
[16:19:39.647]                     invisible(muffled)
[16:19:39.647]                   }
[16:19:39.647]                   muffleCondition(cond)
[16:19:39.647]                 })
[16:19:39.647]             }))
[16:19:39.647]             future::FutureResult(value = ...future.value$value, 
[16:19:39.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:39.647]                   ...future.rng), globalenv = if (FALSE) 
[16:19:39.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:39.647]                     ...future.globalenv.names))
[16:19:39.647]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:39.647]         }, condition = base::local({
[16:19:39.647]             c <- base::c
[16:19:39.647]             inherits <- base::inherits
[16:19:39.647]             invokeRestart <- base::invokeRestart
[16:19:39.647]             length <- base::length
[16:19:39.647]             list <- base::list
[16:19:39.647]             seq.int <- base::seq.int
[16:19:39.647]             signalCondition <- base::signalCondition
[16:19:39.647]             sys.calls <- base::sys.calls
[16:19:39.647]             `[[` <- base::`[[`
[16:19:39.647]             `+` <- base::`+`
[16:19:39.647]             `<<-` <- base::`<<-`
[16:19:39.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:39.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:39.647]                   3L)]
[16:19:39.647]             }
[16:19:39.647]             function(cond) {
[16:19:39.647]                 is_error <- inherits(cond, "error")
[16:19:39.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:39.647]                   NULL)
[16:19:39.647]                 if (is_error) {
[16:19:39.647]                   sessionInformation <- function() {
[16:19:39.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:39.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:39.647]                       search = base::search(), system = base::Sys.info())
[16:19:39.647]                   }
[16:19:39.647]                   ...future.conditions[[length(...future.conditions) + 
[16:19:39.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:39.647]                     cond$call), session = sessionInformation(), 
[16:19:39.647]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:39.647]                   signalCondition(cond)
[16:19:39.647]                 }
[16:19:39.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:39.647]                 "immediateCondition"))) {
[16:19:39.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:39.647]                   ...future.conditions[[length(...future.conditions) + 
[16:19:39.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:39.647]                   if (TRUE && !signal) {
[16:19:39.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:39.647]                     {
[16:19:39.647]                       inherits <- base::inherits
[16:19:39.647]                       invokeRestart <- base::invokeRestart
[16:19:39.647]                       is.null <- base::is.null
[16:19:39.647]                       muffled <- FALSE
[16:19:39.647]                       if (inherits(cond, "message")) {
[16:19:39.647]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:39.647]                         if (muffled) 
[16:19:39.647]                           invokeRestart("muffleMessage")
[16:19:39.647]                       }
[16:19:39.647]                       else if (inherits(cond, "warning")) {
[16:19:39.647]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:39.647]                         if (muffled) 
[16:19:39.647]                           invokeRestart("muffleWarning")
[16:19:39.647]                       }
[16:19:39.647]                       else if (inherits(cond, "condition")) {
[16:19:39.647]                         if (!is.null(pattern)) {
[16:19:39.647]                           computeRestarts <- base::computeRestarts
[16:19:39.647]                           grepl <- base::grepl
[16:19:39.647]                           restarts <- computeRestarts(cond)
[16:19:39.647]                           for (restart in restarts) {
[16:19:39.647]                             name <- restart$name
[16:19:39.647]                             if (is.null(name)) 
[16:19:39.647]                               next
[16:19:39.647]                             if (!grepl(pattern, name)) 
[16:19:39.647]                               next
[16:19:39.647]                             invokeRestart(restart)
[16:19:39.647]                             muffled <- TRUE
[16:19:39.647]                             break
[16:19:39.647]                           }
[16:19:39.647]                         }
[16:19:39.647]                       }
[16:19:39.647]                       invisible(muffled)
[16:19:39.647]                     }
[16:19:39.647]                     muffleCondition(cond, pattern = "^muffle")
[16:19:39.647]                   }
[16:19:39.647]                 }
[16:19:39.647]                 else {
[16:19:39.647]                   if (TRUE) {
[16:19:39.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:39.647]                     {
[16:19:39.647]                       inherits <- base::inherits
[16:19:39.647]                       invokeRestart <- base::invokeRestart
[16:19:39.647]                       is.null <- base::is.null
[16:19:39.647]                       muffled <- FALSE
[16:19:39.647]                       if (inherits(cond, "message")) {
[16:19:39.647]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:39.647]                         if (muffled) 
[16:19:39.647]                           invokeRestart("muffleMessage")
[16:19:39.647]                       }
[16:19:39.647]                       else if (inherits(cond, "warning")) {
[16:19:39.647]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:39.647]                         if (muffled) 
[16:19:39.647]                           invokeRestart("muffleWarning")
[16:19:39.647]                       }
[16:19:39.647]                       else if (inherits(cond, "condition")) {
[16:19:39.647]                         if (!is.null(pattern)) {
[16:19:39.647]                           computeRestarts <- base::computeRestarts
[16:19:39.647]                           grepl <- base::grepl
[16:19:39.647]                           restarts <- computeRestarts(cond)
[16:19:39.647]                           for (restart in restarts) {
[16:19:39.647]                             name <- restart$name
[16:19:39.647]                             if (is.null(name)) 
[16:19:39.647]                               next
[16:19:39.647]                             if (!grepl(pattern, name)) 
[16:19:39.647]                               next
[16:19:39.647]                             invokeRestart(restart)
[16:19:39.647]                             muffled <- TRUE
[16:19:39.647]                             break
[16:19:39.647]                           }
[16:19:39.647]                         }
[16:19:39.647]                       }
[16:19:39.647]                       invisible(muffled)
[16:19:39.647]                     }
[16:19:39.647]                     muffleCondition(cond, pattern = "^muffle")
[16:19:39.647]                   }
[16:19:39.647]                 }
[16:19:39.647]             }
[16:19:39.647]         }))
[16:19:39.647]     }, error = function(ex) {
[16:19:39.647]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:39.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:39.647]                 ...future.rng), started = ...future.startTime, 
[16:19:39.647]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:39.647]             version = "1.8"), class = "FutureResult")
[16:19:39.647]     }, finally = {
[16:19:39.647]         if (!identical(...future.workdir, getwd())) 
[16:19:39.647]             setwd(...future.workdir)
[16:19:39.647]         {
[16:19:39.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:39.647]                 ...future.oldOptions$nwarnings <- NULL
[16:19:39.647]             }
[16:19:39.647]             base::options(...future.oldOptions)
[16:19:39.647]             if (.Platform$OS.type == "windows") {
[16:19:39.647]                 old_names <- names(...future.oldEnvVars)
[16:19:39.647]                 envs <- base::Sys.getenv()
[16:19:39.647]                 names <- names(envs)
[16:19:39.647]                 common <- intersect(names, old_names)
[16:19:39.647]                 added <- setdiff(names, old_names)
[16:19:39.647]                 removed <- setdiff(old_names, names)
[16:19:39.647]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:39.647]                   envs[common]]
[16:19:39.647]                 NAMES <- toupper(changed)
[16:19:39.647]                 args <- list()
[16:19:39.647]                 for (kk in seq_along(NAMES)) {
[16:19:39.647]                   name <- changed[[kk]]
[16:19:39.647]                   NAME <- NAMES[[kk]]
[16:19:39.647]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:39.647]                     next
[16:19:39.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:39.647]                 }
[16:19:39.647]                 NAMES <- toupper(added)
[16:19:39.647]                 for (kk in seq_along(NAMES)) {
[16:19:39.647]                   name <- added[[kk]]
[16:19:39.647]                   NAME <- NAMES[[kk]]
[16:19:39.647]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:39.647]                     next
[16:19:39.647]                   args[[name]] <- ""
[16:19:39.647]                 }
[16:19:39.647]                 NAMES <- toupper(removed)
[16:19:39.647]                 for (kk in seq_along(NAMES)) {
[16:19:39.647]                   name <- removed[[kk]]
[16:19:39.647]                   NAME <- NAMES[[kk]]
[16:19:39.647]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:39.647]                     next
[16:19:39.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:39.647]                 }
[16:19:39.647]                 if (length(args) > 0) 
[16:19:39.647]                   base::do.call(base::Sys.setenv, args = args)
[16:19:39.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:39.647]             }
[16:19:39.647]             else {
[16:19:39.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:39.647]             }
[16:19:39.647]             {
[16:19:39.647]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:39.647]                   0L) {
[16:19:39.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:39.647]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:39.647]                   base::options(opts)
[16:19:39.647]                 }
[16:19:39.647]                 {
[16:19:39.647]                   {
[16:19:39.647]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:39.647]                     NULL
[16:19:39.647]                   }
[16:19:39.647]                   options(future.plan = NULL)
[16:19:39.647]                   if (is.na(NA_character_)) 
[16:19:39.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:39.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:39.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:39.647]                     .init = FALSE)
[16:19:39.647]                 }
[16:19:39.647]             }
[16:19:39.647]         }
[16:19:39.647]     })
[16:19:39.647]     if (FALSE) {
[16:19:39.647]         base::sink(type = "output", split = FALSE)
[16:19:39.647]         if (NA) {
[16:19:39.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:39.647]         }
[16:19:39.647]         else {
[16:19:39.647]             ...future.result["stdout"] <- base::list(NULL)
[16:19:39.647]         }
[16:19:39.647]         base::close(...future.stdout)
[16:19:39.647]         ...future.stdout <- NULL
[16:19:39.647]     }
[16:19:39.647]     ...future.result$conditions <- ...future.conditions
[16:19:39.647]     ...future.result$finished <- base::Sys.time()
[16:19:39.647]     ...future.result
[16:19:39.647] }
[16:19:39.649] assign_globals() ...
[16:19:39.650] List of 5
[16:19:39.650]  $ ...future.FUN            :function (x, y)  
[16:19:39.650]  $ MoreArgs                 : NULL
[16:19:39.650]  $ ...future.elements_ii    :List of 2
[16:19:39.650]   ..$ :List of 1
[16:19:39.650]   .. ..$ : int 1
[16:19:39.650]   ..$ :List of 1
[16:19:39.650]   .. ..$ : int 0
[16:19:39.650]  $ ...future.seeds_ii       : NULL
[16:19:39.650]  $ ...future.globals.maxSize: NULL
[16:19:39.650]  - attr(*, "where")=List of 5
[16:19:39.650]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:39.650]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:39.650]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:39.650]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:39.650]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:39.650]  - attr(*, "resolved")= logi FALSE
[16:19:39.650]  - attr(*, "total_size")= num 6368
[16:19:39.650]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:39.650]  - attr(*, "already-done")= logi TRUE
[16:19:39.657] - reassign environment for ‘...future.FUN’
[16:19:39.657] - copied ‘...future.FUN’ to environment
[16:19:39.657] - copied ‘MoreArgs’ to environment
[16:19:39.657] - copied ‘...future.elements_ii’ to environment
[16:19:39.657] - copied ‘...future.seeds_ii’ to environment
[16:19:39.657] - copied ‘...future.globals.maxSize’ to environment
[16:19:39.657] assign_globals() ... done
[16:19:39.657] requestCore(): workers = 2
[16:19:39.659] MulticoreFuture started
[16:19:39.660] - Launch lazy future ... done
[16:19:39.660] run() for ‘MulticoreFuture’ ... done
[16:19:39.661] Created future:
[16:19:39.661] plan(): Setting new future strategy stack:
[16:19:39.661] List of future strategies:
[16:19:39.661] 1. sequential:
[16:19:39.661]    - args: function (..., envir = parent.frame())
[16:19:39.661]    - tweaked: FALSE
[16:19:39.661]    - call: NULL
[16:19:39.662] plan(): nbrOfWorkers() = 1
[16:19:39.661] MulticoreFuture:
[16:19:39.661] Label: ‘future_mapply-1’
[16:19:39.661] Expression:
[16:19:39.661] {
[16:19:39.661]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:39.661]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:39.661]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:39.661]         on.exit(options(oopts), add = TRUE)
[16:19:39.661]     }
[16:19:39.661]     {
[16:19:39.661]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:39.661]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:39.661]         do.call(mapply, args = args)
[16:19:39.661]     }
[16:19:39.661] }
[16:19:39.661] Lazy evaluation: FALSE
[16:19:39.661] Asynchronous evaluation: TRUE
[16:19:39.661] Local evaluation: TRUE
[16:19:39.661] Environment: R_GlobalEnv
[16:19:39.661] Capture standard output: NA
[16:19:39.661] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:39.661] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:39.661] Packages: <none>
[16:19:39.661] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:39.661] Resolved: FALSE
[16:19:39.661] Value: <not collected>
[16:19:39.661] Conditions captured: <none>
[16:19:39.661] Early signaling: FALSE
[16:19:39.661] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:39.661] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:39.674] Chunk #1 of 2 ... DONE
[16:19:39.674] Chunk #2 of 2 ...
[16:19:39.675]  - Finding globals in '...' for chunk #2 ...
[16:19:39.675] getGlobalsAndPackages() ...
[16:19:39.675] Searching for globals...
[16:19:39.676] 
[16:19:39.676] Searching for globals ... DONE
[16:19:39.676] - globals: [0] <none>
[16:19:39.676] getGlobalsAndPackages() ... DONE
[16:19:39.676]    + additional globals found: [n=0] 
[16:19:39.676]    + additional namespaces needed: [n=0] 
[16:19:39.677]  - Finding globals in '...' for chunk #2 ... DONE
[16:19:39.677]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:39.677]  - seeds: <none>
[16:19:39.677]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:39.677] getGlobalsAndPackages() ...
[16:19:39.677] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:39.678] Resolving globals: FALSE
[16:19:39.679] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:19:39.679] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:39.680] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:39.680] 
[16:19:39.680] getGlobalsAndPackages() ... DONE
[16:19:39.680] run() for ‘Future’ ...
[16:19:39.681] - state: ‘created’
[16:19:39.681] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[16:19:39.686] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:39.686] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[16:19:39.687]   - Field: ‘label’
[16:19:39.687]   - Field: ‘local’
[16:19:39.687]   - Field: ‘owner’
[16:19:39.687]   - Field: ‘envir’
[16:19:39.687]   - Field: ‘workers’
[16:19:39.687]   - Field: ‘packages’
[16:19:39.687]   - Field: ‘gc’
[16:19:39.688]   - Field: ‘job’
[16:19:39.688]   - Field: ‘conditions’
[16:19:39.688]   - Field: ‘expr’
[16:19:39.688]   - Field: ‘uuid’
[16:19:39.688]   - Field: ‘seed’
[16:19:39.688]   - Field: ‘version’
[16:19:39.689]   - Field: ‘result’
[16:19:39.689]   - Field: ‘asynchronous’
[16:19:39.689]   - Field: ‘calls’
[16:19:39.689]   - Field: ‘globals’
[16:19:39.689]   - Field: ‘stdout’
[16:19:39.689]   - Field: ‘earlySignal’
[16:19:39.689]   - Field: ‘lazy’
[16:19:39.690]   - Field: ‘state’
[16:19:39.690] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[16:19:39.690] - Launch lazy future ...
[16:19:39.690] Packages needed by the future expression (n = 0): <none>
[16:19:39.690] Packages needed by future strategies (n = 0): <none>
[16:19:39.691] {
[16:19:39.691]     {
[16:19:39.691]         {
[16:19:39.691]             ...future.startTime <- base::Sys.time()
[16:19:39.691]             {
[16:19:39.691]                 {
[16:19:39.691]                   {
[16:19:39.691]                     {
[16:19:39.691]                       base::local({
[16:19:39.691]                         has_future <- base::requireNamespace("future", 
[16:19:39.691]                           quietly = TRUE)
[16:19:39.691]                         if (has_future) {
[16:19:39.691]                           ns <- base::getNamespace("future")
[16:19:39.691]                           version <- ns[[".package"]][["version"]]
[16:19:39.691]                           if (is.null(version)) 
[16:19:39.691]                             version <- utils::packageVersion("future")
[16:19:39.691]                         }
[16:19:39.691]                         else {
[16:19:39.691]                           version <- NULL
[16:19:39.691]                         }
[16:19:39.691]                         if (!has_future || version < "1.8.0") {
[16:19:39.691]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:39.691]                             "", base::R.version$version.string), 
[16:19:39.691]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:39.691]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:39.691]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:39.691]                               "release", "version")], collapse = " "), 
[16:19:39.691]                             hostname = base::Sys.info()[["nodename"]])
[16:19:39.691]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:39.691]                             info)
[16:19:39.691]                           info <- base::paste(info, collapse = "; ")
[16:19:39.691]                           if (!has_future) {
[16:19:39.691]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:39.691]                               info)
[16:19:39.691]                           }
[16:19:39.691]                           else {
[16:19:39.691]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:39.691]                               info, version)
[16:19:39.691]                           }
[16:19:39.691]                           base::stop(msg)
[16:19:39.691]                         }
[16:19:39.691]                       })
[16:19:39.691]                     }
[16:19:39.691]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:39.691]                     base::options(mc.cores = 1L)
[16:19:39.691]                   }
[16:19:39.691]                   ...future.strategy.old <- future::plan("list")
[16:19:39.691]                   options(future.plan = NULL)
[16:19:39.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:39.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:39.691]                 }
[16:19:39.691]                 ...future.workdir <- getwd()
[16:19:39.691]             }
[16:19:39.691]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:39.691]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:39.691]         }
[16:19:39.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:39.691]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:39.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:39.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:39.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:39.691]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:39.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:39.691]             base::names(...future.oldOptions))
[16:19:39.691]     }
[16:19:39.691]     if (TRUE) {
[16:19:39.691]     }
[16:19:39.691]     else {
[16:19:39.691]         if (NA) {
[16:19:39.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:39.691]                 open = "w")
[16:19:39.691]         }
[16:19:39.691]         else {
[16:19:39.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:39.691]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:39.691]         }
[16:19:39.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:39.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:39.691]             base::sink(type = "output", split = FALSE)
[16:19:39.691]             base::close(...future.stdout)
[16:19:39.691]         }, add = TRUE)
[16:19:39.691]     }
[16:19:39.691]     ...future.frame <- base::sys.nframe()
[16:19:39.691]     ...future.conditions <- base::list()
[16:19:39.691]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:39.691]     if (FALSE) {
[16:19:39.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:39.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:39.691]     }
[16:19:39.691]     ...future.result <- base::tryCatch({
[16:19:39.691]         base::withCallingHandlers({
[16:19:39.691]             ...future.value <- base::withVisible(base::local({
[16:19:39.691]                 withCallingHandlers({
[16:19:39.691]                   {
[16:19:39.691]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:39.691]                     if (!identical(...future.globals.maxSize.org, 
[16:19:39.691]                       ...future.globals.maxSize)) {
[16:19:39.691]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:39.691]                       on.exit(options(oopts), add = TRUE)
[16:19:39.691]                     }
[16:19:39.691]                     {
[16:19:39.691]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:39.691]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:39.691]                         USE.NAMES = FALSE)
[16:19:39.691]                       do.call(mapply, args = args)
[16:19:39.691]                     }
[16:19:39.691]                   }
[16:19:39.691]                 }, immediateCondition = function(cond) {
[16:19:39.691]                   save_rds <- function (object, pathname, ...) 
[16:19:39.691]                   {
[16:19:39.691]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[16:19:39.691]                     if (file_test("-f", pathname_tmp)) {
[16:19:39.691]                       fi_tmp <- file.info(pathname_tmp)
[16:19:39.691]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[16:19:39.691]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:39.691]                         fi_tmp[["mtime"]])
[16:19:39.691]                     }
[16:19:39.691]                     tryCatch({
[16:19:39.691]                       saveRDS(object, file = pathname_tmp, ...)
[16:19:39.691]                     }, error = function(ex) {
[16:19:39.691]                       msg <- conditionMessage(ex)
[16:19:39.691]                       fi_tmp <- file.info(pathname_tmp)
[16:19:39.691]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[16:19:39.691]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:39.691]                         fi_tmp[["mtime"]], msg)
[16:19:39.691]                       ex$message <- msg
[16:19:39.691]                       stop(ex)
[16:19:39.691]                     })
[16:19:39.691]                     stopifnot(file_test("-f", pathname_tmp))
[16:19:39.691]                     res <- file.rename(from = pathname_tmp, to = pathname)
[16:19:39.691]                     if (!res || file_test("-f", pathname_tmp)) {
[16:19:39.691]                       fi_tmp <- file.info(pathname_tmp)
[16:19:39.691]                       fi <- file.info(pathname)
[16:19:39.691]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[16:19:39.691]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[16:19:39.691]                         fi_tmp[["mtime"]], sQuote(pathname), 
[16:19:39.691]                         fi[["size"]], fi[["mtime"]])
[16:19:39.691]                       stop(msg)
[16:19:39.691]                     }
[16:19:39.691]                     invisible(pathname)
[16:19:39.691]                   }
[16:19:39.691]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[16:19:39.691]                     rootPath = tempdir()) 
[16:19:39.691]                   {
[16:19:39.691]                     obj <- list(time = Sys.time(), condition = cond)
[16:19:39.691]                     file <- tempfile(pattern = class(cond)[1], 
[16:19:39.691]                       tmpdir = path, fileext = ".rds")
[16:19:39.691]                     save_rds(obj, file)
[16:19:39.691]                   }
[16:19:39.691]                   saveImmediateCondition(cond, path = "/tmp/RtmpmPcako/.future/immediateConditions")
[16:19:39.691]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:39.691]                   {
[16:19:39.691]                     inherits <- base::inherits
[16:19:39.691]                     invokeRestart <- base::invokeRestart
[16:19:39.691]                     is.null <- base::is.null
[16:19:39.691]                     muffled <- FALSE
[16:19:39.691]                     if (inherits(cond, "message")) {
[16:19:39.691]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:39.691]                       if (muffled) 
[16:19:39.691]                         invokeRestart("muffleMessage")
[16:19:39.691]                     }
[16:19:39.691]                     else if (inherits(cond, "warning")) {
[16:19:39.691]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:39.691]                       if (muffled) 
[16:19:39.691]                         invokeRestart("muffleWarning")
[16:19:39.691]                     }
[16:19:39.691]                     else if (inherits(cond, "condition")) {
[16:19:39.691]                       if (!is.null(pattern)) {
[16:19:39.691]                         computeRestarts <- base::computeRestarts
[16:19:39.691]                         grepl <- base::grepl
[16:19:39.691]                         restarts <- computeRestarts(cond)
[16:19:39.691]                         for (restart in restarts) {
[16:19:39.691]                           name <- restart$name
[16:19:39.691]                           if (is.null(name)) 
[16:19:39.691]                             next
[16:19:39.691]                           if (!grepl(pattern, name)) 
[16:19:39.691]                             next
[16:19:39.691]                           invokeRestart(restart)
[16:19:39.691]                           muffled <- TRUE
[16:19:39.691]                           break
[16:19:39.691]                         }
[16:19:39.691]                       }
[16:19:39.691]                     }
[16:19:39.691]                     invisible(muffled)
[16:19:39.691]                   }
[16:19:39.691]                   muffleCondition(cond)
[16:19:39.691]                 })
[16:19:39.691]             }))
[16:19:39.691]             future::FutureResult(value = ...future.value$value, 
[16:19:39.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:39.691]                   ...future.rng), globalenv = if (FALSE) 
[16:19:39.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:39.691]                     ...future.globalenv.names))
[16:19:39.691]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:39.691]         }, condition = base::local({
[16:19:39.691]             c <- base::c
[16:19:39.691]             inherits <- base::inherits
[16:19:39.691]             invokeRestart <- base::invokeRestart
[16:19:39.691]             length <- base::length
[16:19:39.691]             list <- base::list
[16:19:39.691]             seq.int <- base::seq.int
[16:19:39.691]             signalCondition <- base::signalCondition
[16:19:39.691]             sys.calls <- base::sys.calls
[16:19:39.691]             `[[` <- base::`[[`
[16:19:39.691]             `+` <- base::`+`
[16:19:39.691]             `<<-` <- base::`<<-`
[16:19:39.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:39.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:39.691]                   3L)]
[16:19:39.691]             }
[16:19:39.691]             function(cond) {
[16:19:39.691]                 is_error <- inherits(cond, "error")
[16:19:39.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:39.691]                   NULL)
[16:19:39.691]                 if (is_error) {
[16:19:39.691]                   sessionInformation <- function() {
[16:19:39.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:39.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:39.691]                       search = base::search(), system = base::Sys.info())
[16:19:39.691]                   }
[16:19:39.691]                   ...future.conditions[[length(...future.conditions) + 
[16:19:39.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:39.691]                     cond$call), session = sessionInformation(), 
[16:19:39.691]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:39.691]                   signalCondition(cond)
[16:19:39.691]                 }
[16:19:39.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:39.691]                 "immediateCondition"))) {
[16:19:39.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:39.691]                   ...future.conditions[[length(...future.conditions) + 
[16:19:39.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:39.691]                   if (TRUE && !signal) {
[16:19:39.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:39.691]                     {
[16:19:39.691]                       inherits <- base::inherits
[16:19:39.691]                       invokeRestart <- base::invokeRestart
[16:19:39.691]                       is.null <- base::is.null
[16:19:39.691]                       muffled <- FALSE
[16:19:39.691]                       if (inherits(cond, "message")) {
[16:19:39.691]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:39.691]                         if (muffled) 
[16:19:39.691]                           invokeRestart("muffleMessage")
[16:19:39.691]                       }
[16:19:39.691]                       else if (inherits(cond, "warning")) {
[16:19:39.691]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:39.691]                         if (muffled) 
[16:19:39.691]                           invokeRestart("muffleWarning")
[16:19:39.691]                       }
[16:19:39.691]                       else if (inherits(cond, "condition")) {
[16:19:39.691]                         if (!is.null(pattern)) {
[16:19:39.691]                           computeRestarts <- base::computeRestarts
[16:19:39.691]                           grepl <- base::grepl
[16:19:39.691]                           restarts <- computeRestarts(cond)
[16:19:39.691]                           for (restart in restarts) {
[16:19:39.691]                             name <- restart$name
[16:19:39.691]                             if (is.null(name)) 
[16:19:39.691]                               next
[16:19:39.691]                             if (!grepl(pattern, name)) 
[16:19:39.691]                               next
[16:19:39.691]                             invokeRestart(restart)
[16:19:39.691]                             muffled <- TRUE
[16:19:39.691]                             break
[16:19:39.691]                           }
[16:19:39.691]                         }
[16:19:39.691]                       }
[16:19:39.691]                       invisible(muffled)
[16:19:39.691]                     }
[16:19:39.691]                     muffleCondition(cond, pattern = "^muffle")
[16:19:39.691]                   }
[16:19:39.691]                 }
[16:19:39.691]                 else {
[16:19:39.691]                   if (TRUE) {
[16:19:39.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:39.691]                     {
[16:19:39.691]                       inherits <- base::inherits
[16:19:39.691]                       invokeRestart <- base::invokeRestart
[16:19:39.691]                       is.null <- base::is.null
[16:19:39.691]                       muffled <- FALSE
[16:19:39.691]                       if (inherits(cond, "message")) {
[16:19:39.691]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:39.691]                         if (muffled) 
[16:19:39.691]                           invokeRestart("muffleMessage")
[16:19:39.691]                       }
[16:19:39.691]                       else if (inherits(cond, "warning")) {
[16:19:39.691]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:39.691]                         if (muffled) 
[16:19:39.691]                           invokeRestart("muffleWarning")
[16:19:39.691]                       }
[16:19:39.691]                       else if (inherits(cond, "condition")) {
[16:19:39.691]                         if (!is.null(pattern)) {
[16:19:39.691]                           computeRestarts <- base::computeRestarts
[16:19:39.691]                           grepl <- base::grepl
[16:19:39.691]                           restarts <- computeRestarts(cond)
[16:19:39.691]                           for (restart in restarts) {
[16:19:39.691]                             name <- restart$name
[16:19:39.691]                             if (is.null(name)) 
[16:19:39.691]                               next
[16:19:39.691]                             if (!grepl(pattern, name)) 
[16:19:39.691]                               next
[16:19:39.691]                             invokeRestart(restart)
[16:19:39.691]                             muffled <- TRUE
[16:19:39.691]                             break
[16:19:39.691]                           }
[16:19:39.691]                         }
[16:19:39.691]                       }
[16:19:39.691]                       invisible(muffled)
[16:19:39.691]                     }
[16:19:39.691]                     muffleCondition(cond, pattern = "^muffle")
[16:19:39.691]                   }
[16:19:39.691]                 }
[16:19:39.691]             }
[16:19:39.691]         }))
[16:19:39.691]     }, error = function(ex) {
[16:19:39.691]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:39.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:39.691]                 ...future.rng), started = ...future.startTime, 
[16:19:39.691]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:39.691]             version = "1.8"), class = "FutureResult")
[16:19:39.691]     }, finally = {
[16:19:39.691]         if (!identical(...future.workdir, getwd())) 
[16:19:39.691]             setwd(...future.workdir)
[16:19:39.691]         {
[16:19:39.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:39.691]                 ...future.oldOptions$nwarnings <- NULL
[16:19:39.691]             }
[16:19:39.691]             base::options(...future.oldOptions)
[16:19:39.691]             if (.Platform$OS.type == "windows") {
[16:19:39.691]                 old_names <- names(...future.oldEnvVars)
[16:19:39.691]                 envs <- base::Sys.getenv()
[16:19:39.691]                 names <- names(envs)
[16:19:39.691]                 common <- intersect(names, old_names)
[16:19:39.691]                 added <- setdiff(names, old_names)
[16:19:39.691]                 removed <- setdiff(old_names, names)
[16:19:39.691]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:39.691]                   envs[common]]
[16:19:39.691]                 NAMES <- toupper(changed)
[16:19:39.691]                 args <- list()
[16:19:39.691]                 for (kk in seq_along(NAMES)) {
[16:19:39.691]                   name <- changed[[kk]]
[16:19:39.691]                   NAME <- NAMES[[kk]]
[16:19:39.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:39.691]                     next
[16:19:39.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:39.691]                 }
[16:19:39.691]                 NAMES <- toupper(added)
[16:19:39.691]                 for (kk in seq_along(NAMES)) {
[16:19:39.691]                   name <- added[[kk]]
[16:19:39.691]                   NAME <- NAMES[[kk]]
[16:19:39.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:39.691]                     next
[16:19:39.691]                   args[[name]] <- ""
[16:19:39.691]                 }
[16:19:39.691]                 NAMES <- toupper(removed)
[16:19:39.691]                 for (kk in seq_along(NAMES)) {
[16:19:39.691]                   name <- removed[[kk]]
[16:19:39.691]                   NAME <- NAMES[[kk]]
[16:19:39.691]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:39.691]                     next
[16:19:39.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:39.691]                 }
[16:19:39.691]                 if (length(args) > 0) 
[16:19:39.691]                   base::do.call(base::Sys.setenv, args = args)
[16:19:39.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:39.691]             }
[16:19:39.691]             else {
[16:19:39.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:39.691]             }
[16:19:39.691]             {
[16:19:39.691]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:39.691]                   0L) {
[16:19:39.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:39.691]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:39.691]                   base::options(opts)
[16:19:39.691]                 }
[16:19:39.691]                 {
[16:19:39.691]                   {
[16:19:39.691]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:39.691]                     NULL
[16:19:39.691]                   }
[16:19:39.691]                   options(future.plan = NULL)
[16:19:39.691]                   if (is.na(NA_character_)) 
[16:19:39.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:39.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:39.691]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:39.691]                     .init = FALSE)
[16:19:39.691]                 }
[16:19:39.691]             }
[16:19:39.691]         }
[16:19:39.691]     })
[16:19:39.691]     if (FALSE) {
[16:19:39.691]         base::sink(type = "output", split = FALSE)
[16:19:39.691]         if (NA) {
[16:19:39.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:39.691]         }
[16:19:39.691]         else {
[16:19:39.691]             ...future.result["stdout"] <- base::list(NULL)
[16:19:39.691]         }
[16:19:39.691]         base::close(...future.stdout)
[16:19:39.691]         ...future.stdout <- NULL
[16:19:39.691]     }
[16:19:39.691]     ...future.result$conditions <- ...future.conditions
[16:19:39.691]     ...future.result$finished <- base::Sys.time()
[16:19:39.691]     ...future.result
[16:19:39.691] }
[16:19:39.695] assign_globals() ...
[16:19:39.695] List of 5
[16:19:39.695]  $ ...future.FUN            :function (x, y)  
[16:19:39.695]  $ MoreArgs                 : NULL
[16:19:39.695]  $ ...future.elements_ii    :List of 2
[16:19:39.695]   ..$ :List of 1
[16:19:39.695]   .. ..$ : int 0
[16:19:39.695]   ..$ :List of 1
[16:19:39.695]   .. ..$ : int 1
[16:19:39.695]  $ ...future.seeds_ii       : NULL
[16:19:39.695]  $ ...future.globals.maxSize: NULL
[16:19:39.695]  - attr(*, "where")=List of 5
[16:19:39.695]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[16:19:39.695]   ..$ MoreArgs                 :<environment: R_EmptyEnv> 
[16:19:39.695]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[16:19:39.695]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[16:19:39.695]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[16:19:39.695]  - attr(*, "resolved")= logi FALSE
[16:19:39.695]  - attr(*, "total_size")= num 6368
[16:19:39.695]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:39.695]  - attr(*, "already-done")= logi TRUE
[16:19:39.703] - reassign environment for ‘...future.FUN’
[16:19:39.703] - copied ‘...future.FUN’ to environment
[16:19:39.703] - copied ‘MoreArgs’ to environment
[16:19:39.703] - copied ‘...future.elements_ii’ to environment
[16:19:39.704] - copied ‘...future.seeds_ii’ to environment
[16:19:39.706] - copied ‘...future.globals.maxSize’ to environment
[16:19:39.706] assign_globals() ... done
[16:19:39.706] requestCore(): workers = 2
[16:19:39.709] MulticoreFuture started
[16:19:39.710] - Launch lazy future ... done
[16:19:39.710] run() for ‘MulticoreFuture’ ... done
[16:19:39.711] plan(): Setting new future strategy stack:
[16:19:39.711] Created future:
[16:19:39.711] List of future strategies:
[16:19:39.711] 1. sequential:
[16:19:39.711]    - args: function (..., envir = parent.frame())
[16:19:39.711]    - tweaked: FALSE
[16:19:39.711]    - call: NULL
[16:19:39.712] plan(): nbrOfWorkers() = 1
[16:19:39.715] plan(): Setting new future strategy stack:
[16:19:39.715] List of future strategies:
[16:19:39.715] 1. multicore:
[16:19:39.715]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:39.715]    - tweaked: FALSE
[16:19:39.715]    - call: plan(strategy)
[16:19:39.722] plan(): nbrOfWorkers() = 2
[16:19:39.711] MulticoreFuture:
[16:19:39.711] Label: ‘future_mapply-2’
[16:19:39.711] Expression:
[16:19:39.711] {
[16:19:39.711]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:39.711]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:39.711]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:39.711]         on.exit(options(oopts), add = TRUE)
[16:19:39.711]     }
[16:19:39.711]     {
[16:19:39.711]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:39.711]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:39.711]         do.call(mapply, args = args)
[16:19:39.711]     }
[16:19:39.711] }
[16:19:39.711] Lazy evaluation: FALSE
[16:19:39.711] Asynchronous evaluation: TRUE
[16:19:39.711] Local evaluation: TRUE
[16:19:39.711] Environment: R_GlobalEnv
[16:19:39.711] Capture standard output: NA
[16:19:39.711] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:39.711] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:39.711] Packages: <none>
[16:19:39.711] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:39.711] Resolved: TRUE
[16:19:39.711] Value: <not collected>
[16:19:39.711] Conditions captured: <none>
[16:19:39.711] Early signaling: FALSE
[16:19:39.711] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:39.711] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:39.723] Chunk #2 of 2 ... DONE
[16:19:39.724] Launching 2 futures (chunks) ... DONE
[16:19:39.724] Resolving 2 futures (chunks) ...
[16:19:39.724] resolve() on list ...
[16:19:39.724]  recursive: 0
[16:19:39.725]  length: 2
[16:19:39.725] 
[16:19:39.736] Future #2
[16:19:39.736] result() for MulticoreFuture ...
[16:19:39.737] result() for MulticoreFuture ...
[16:19:39.737] result() for MulticoreFuture ... done
[16:19:39.737] result() for MulticoreFuture ... done
[16:19:39.738] result() for MulticoreFuture ...
[16:19:39.738] result() for MulticoreFuture ... done
[16:19:39.738] signalConditionsASAP(MulticoreFuture, pos=2) ...
[16:19:39.738] - nx: 2
[16:19:39.738] - relay: TRUE
[16:19:39.738] - stdout: TRUE
[16:19:39.739] - signal: TRUE
[16:19:39.739] - resignal: FALSE
[16:19:39.739] - force: TRUE
[16:19:39.739] - relayed: [n=2] FALSE, FALSE
[16:19:39.739] - queued futures: [n=2] FALSE, FALSE
[16:19:39.739]  - until=1
[16:19:39.740]  - relaying element #1
[16:19:39.740] - relayed: [n=2] FALSE, FALSE
[16:19:39.740] - queued futures: [n=2] FALSE, TRUE
[16:19:39.740] signalConditionsASAP(NULL, pos=2) ... done
[16:19:39.740]  length: 1 (resolved future 2)
[16:19:40.165] plan(): Setting new future strategy stack:
[16:19:40.165] List of future strategies:
[16:19:40.165] 1. multicore:
[16:19:40.165]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[16:19:40.165]    - tweaked: FALSE
[16:19:40.165]    - call: plan(strategy)
[16:19:40.170] plan(): nbrOfWorkers() = 2
[16:19:40.178] Future #1
[16:19:40.179] result() for MulticoreFuture ...
[16:19:40.179] result() for MulticoreFuture ...
[16:19:40.180] result() for MulticoreFuture ... done
[16:19:40.180] result() for MulticoreFuture ... done
[16:19:40.180] result() for MulticoreFuture ...
[16:19:40.180] result() for MulticoreFuture ... done
[16:19:40.180] signalConditionsASAP(MulticoreFuture, pos=1) ...
[16:19:40.180] - nx: 2
[16:19:40.180] - relay: TRUE
[16:19:40.180] - stdout: TRUE
[16:19:40.181] - signal: TRUE
[16:19:40.181] - resignal: FALSE
[16:19:40.181] - force: TRUE
[16:19:40.181] - relayed: [n=2] FALSE, FALSE
[16:19:40.181] - queued futures: [n=2] FALSE, TRUE
[16:19:40.181]  - until=1
[16:19:40.181]  - relaying element #1
[16:19:40.182] result() for MulticoreFuture ...
[16:19:40.182] result() for MulticoreFuture ... done
[16:19:40.182] result() for MulticoreFuture ...
[16:19:40.182] result() for MulticoreFuture ... done
[16:19:40.182] result() for MulticoreFuture ...
[16:19:40.182] result() for MulticoreFuture ... done
[16:19:40.182] result() for MulticoreFuture ...
[16:19:40.182] result() for MulticoreFuture ... done
[16:19:40.182] - relayed: [n=2] TRUE, FALSE
[16:19:40.183] - queued futures: [n=2] TRUE, TRUE
[16:19:40.183] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[16:19:40.183]  length: 0 (resolved future 1)
[16:19:40.183] Relaying remaining futures
[16:19:40.183] signalConditionsASAP(NULL, pos=0) ...
[16:19:40.183] - nx: 2
[16:19:40.183] - relay: TRUE
[16:19:40.183] - stdout: TRUE
[16:19:40.183] - signal: TRUE
[16:19:40.184] - resignal: FALSE
[16:19:40.184] - force: TRUE
[16:19:40.184] - relayed: [n=2] TRUE, FALSE
[16:19:40.184] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:40.184]  - relaying element #2
[16:19:40.184] result() for MulticoreFuture ...
[16:19:40.184] result() for MulticoreFuture ... done
[16:19:40.184] result() for MulticoreFuture ...
[16:19:40.184] result() for MulticoreFuture ... done
[16:19:40.185] result() for MulticoreFuture ...
[16:19:40.185] result() for MulticoreFuture ... done
[16:19:40.185] result() for MulticoreFuture ...
[16:19:40.185] result() for MulticoreFuture ... done
[16:19:40.185] - relayed: [n=2] TRUE, TRUE
[16:19:40.185] - queued futures: [n=2] TRUE, TRUE
[16:19:40.185] signalConditionsASAP(MulticoreFuture, pos=0) ... done
[16:19:40.185] resolve() on list ... DONE
[16:19:40.185] result() for MulticoreFuture ...
[16:19:40.186] result() for MulticoreFuture ... done
[16:19:40.186] result() for MulticoreFuture ...
[16:19:40.186] result() for MulticoreFuture ... done
[16:19:40.186] result() for MulticoreFuture ...
[16:19:40.186] result() for MulticoreFuture ... done
[16:19:40.186] result() for MulticoreFuture ...
[16:19:40.186] result() for MulticoreFuture ... done
[16:19:40.186]  - Number of value chunks collected: 2
[16:19:40.186] Resolving 2 futures (chunks) ... DONE
[16:19:40.187] Reducing values from 2 chunks ...
[16:19:40.187]  - Number of values collected after concatenation: 2
[16:19:40.187]  - Number of values expected: 2
[16:19:40.187] Reducing values from 2 chunks ... DONE
[16:19:40.187] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multicore') ... DONE
* plan('multisession') ...
[16:19:40.188] plan(): Setting new future strategy stack:
[16:19:40.188] List of future strategies:
[16:19:40.188] 1. multisession:
[16:19:40.188]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:40.188]    - tweaked: FALSE
[16:19:40.188]    - call: plan(strategy)
[16:19:40.188] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[16:19:40.188] multisession:
[16:19:40.188] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[16:19:40.188] - tweaked: FALSE
[16:19:40.188] - call: plan(strategy)
[16:19:40.195] getGlobalsAndPackages() ...
[16:19:40.195] Not searching for globals
[16:19:40.195] - globals: [0] <none>
[16:19:40.195] getGlobalsAndPackages() ... DONE
[16:19:40.196] [local output] makeClusterPSOCK() ...
[16:19:40.238] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[16:19:40.239] [local output] Base port: 11632
[16:19:40.239] [local output] Getting setup options for 2 cluster nodes ...
[16:19:40.239] [local output]  - Node 1 of 2 ...
[16:19:40.240] [local output] localMachine=TRUE => revtunnel=FALSE

[16:19:40.240] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpmPcako/worker.rank=1.parallelly.parent=77222.12da653a5c729.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpmPcako/worker.rank=1.parallelly.parent=77222.12da653a5c729.pid")'’
[16:19:40.428] - Possible to infer worker's PID: TRUE
[16:19:40.429] [local output] Rscript port: 11632

[16:19:40.429] [local output]  - Node 2 of 2 ...
[16:19:40.429] [local output] localMachine=TRUE => revtunnel=FALSE

[16:19:40.430] [local output] Rscript port: 11632

[16:19:40.430] [local output] Getting setup options for 2 cluster nodes ... done
[16:19:40.430] [local output]  - Parallel setup requested for some PSOCK nodes
[16:19:40.431] [local output] Setting up PSOCK nodes in parallel
[16:19:40.431] List of 36
[16:19:40.431]  $ worker          : chr "localhost"
[16:19:40.431]   ..- attr(*, "localhost")= logi TRUE
[16:19:40.431]  $ master          : chr "localhost"
[16:19:40.431]  $ port            : int 11632
[16:19:40.431]  $ connectTimeout  : num 120
[16:19:40.431]  $ timeout         : num 2592000
[16:19:40.431]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[16:19:40.431]  $ homogeneous     : logi TRUE
[16:19:40.431]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[16:19:40.431]  $ rscript_envs    : NULL
[16:19:40.431]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:19:40.431]  $ rscript_startup : NULL
[16:19:40.431]  $ rscript_sh      : chr "sh"
[16:19:40.431]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:19:40.431]  $ methods         : logi TRUE
[16:19:40.431]  $ socketOptions   : chr "no-delay"
[16:19:40.431]  $ useXDR          : logi FALSE
[16:19:40.431]  $ outfile         : chr "/dev/null"
[16:19:40.431]  $ renice          : int NA
[16:19:40.431]  $ rshcmd          : NULL
[16:19:40.431]  $ user            : chr(0) 
[16:19:40.431]  $ revtunnel       : logi FALSE
[16:19:40.431]  $ rshlogfile      : NULL
[16:19:40.431]  $ rshopts         : chr(0) 
[16:19:40.431]  $ rank            : int 1
[16:19:40.431]  $ manual          : logi FALSE
[16:19:40.431]  $ dryrun          : logi FALSE
[16:19:40.431]  $ quiet           : logi FALSE
[16:19:40.431]  $ setup_strategy  : chr "parallel"
[16:19:40.431]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:19:40.431]  $ pidfile         : chr "/tmp/RtmpmPcako/worker.rank=1.parallelly.parent=77222.12da653a5c729.pid"
[16:19:40.431]  $ rshcmd_label    : NULL
[16:19:40.431]  $ rsh_call        : NULL
[16:19:40.431]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[16:19:40.431]  $ localMachine    : logi TRUE
[16:19:40.431]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[16:19:40.431]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[16:19:40.431]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[16:19:40.431]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[16:19:40.431]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[16:19:40.431]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[16:19:40.431]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[16:19:40.431]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[16:19:40.431]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[16:19:40.431]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[16:19:40.431]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[16:19:40.431]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[16:19:40.431]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[16:19:40.431]  $ arguments       :List of 28
[16:19:40.431]   ..$ worker          : chr "localhost"
[16:19:40.431]   ..$ master          : NULL
[16:19:40.431]   ..$ port            : int 11632
[16:19:40.431]   ..$ connectTimeout  : num 120
[16:19:40.431]   ..$ timeout         : num 2592000
[16:19:40.431]   ..$ rscript         : NULL
[16:19:40.431]   ..$ homogeneous     : NULL
[16:19:40.431]   ..$ rscript_args    : NULL
[16:19:40.431]   ..$ rscript_envs    : NULL
[16:19:40.431]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[16:19:40.431]   ..$ rscript_startup : NULL
[16:19:40.431]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[16:19:40.431]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[16:19:40.431]   ..$ methods         : logi TRUE
[16:19:40.431]   ..$ socketOptions   : chr "no-delay"
[16:19:40.431]   ..$ useXDR          : logi FALSE
[16:19:40.431]   ..$ outfile         : chr "/dev/null"
[16:19:40.431]   ..$ renice          : int NA
[16:19:40.431]   ..$ rshcmd          : NULL
[16:19:40.431]   ..$ user            : NULL
[16:19:40.431]   ..$ revtunnel       : logi NA
[16:19:40.431]   ..$ rshlogfile      : NULL
[16:19:40.431]   ..$ rshopts         : NULL
[16:19:40.431]   ..$ rank            : int 1
[16:19:40.431]   ..$ manual          : logi FALSE
[16:19:40.431]   ..$ dryrun          : logi FALSE
[16:19:40.431]   ..$ quiet           : logi FALSE
[16:19:40.431]   ..$ setup_strategy  : chr "parallel"
[16:19:40.431]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[16:19:40.448] [local output] System call to launch all workers:
[16:19:40.448] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpmPcako/worker.rank=1.parallelly.parent=77222.12da653a5c729.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11632 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[16:19:40.448] [local output] Starting PSOCK main server
[16:19:40.454] [local output] Workers launched
[16:19:40.454] [local output] Waiting for workers to connect back
[16:19:40.454]  - [local output] 0 workers out of 2 ready
[16:19:40.719]  - [local output] 0 workers out of 2 ready
[16:19:40.719]  - [local output] 1 workers out of 2 ready
[16:19:40.720]  - [local output] 1 workers out of 2 ready
[16:19:40.721]  - [local output] 2 workers out of 2 ready
[16:19:40.721] [local output] Launching of workers completed
[16:19:40.721] [local output] Collecting session information from workers
[16:19:40.722] [local output]  - Worker #1 of 2
[16:19:40.723] [local output]  - Worker #2 of 2
[16:19:40.723] [local output] makeClusterPSOCK() ... done
[16:19:40.734] Packages needed by the future expression (n = 0): <none>
[16:19:40.735] Packages needed by future strategies (n = 0): <none>
[16:19:40.735] {
[16:19:40.735]     {
[16:19:40.735]         {
[16:19:40.735]             ...future.startTime <- base::Sys.time()
[16:19:40.735]             {
[16:19:40.735]                 {
[16:19:40.735]                   {
[16:19:40.735]                     {
[16:19:40.735]                       base::local({
[16:19:40.735]                         has_future <- base::requireNamespace("future", 
[16:19:40.735]                           quietly = TRUE)
[16:19:40.735]                         if (has_future) {
[16:19:40.735]                           ns <- base::getNamespace("future")
[16:19:40.735]                           version <- ns[[".package"]][["version"]]
[16:19:40.735]                           if (is.null(version)) 
[16:19:40.735]                             version <- utils::packageVersion("future")
[16:19:40.735]                         }
[16:19:40.735]                         else {
[16:19:40.735]                           version <- NULL
[16:19:40.735]                         }
[16:19:40.735]                         if (!has_future || version < "1.8.0") {
[16:19:40.735]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:40.735]                             "", base::R.version$version.string), 
[16:19:40.735]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:40.735]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:40.735]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:40.735]                               "release", "version")], collapse = " "), 
[16:19:40.735]                             hostname = base::Sys.info()[["nodename"]])
[16:19:40.735]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:40.735]                             info)
[16:19:40.735]                           info <- base::paste(info, collapse = "; ")
[16:19:40.735]                           if (!has_future) {
[16:19:40.735]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:40.735]                               info)
[16:19:40.735]                           }
[16:19:40.735]                           else {
[16:19:40.735]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:40.735]                               info, version)
[16:19:40.735]                           }
[16:19:40.735]                           base::stop(msg)
[16:19:40.735]                         }
[16:19:40.735]                       })
[16:19:40.735]                     }
[16:19:40.735]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:40.735]                     base::options(mc.cores = 1L)
[16:19:40.735]                   }
[16:19:40.735]                   ...future.strategy.old <- future::plan("list")
[16:19:40.735]                   options(future.plan = NULL)
[16:19:40.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:40.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:40.735]                 }
[16:19:40.735]                 ...future.workdir <- getwd()
[16:19:40.735]             }
[16:19:40.735]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:40.735]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:40.735]         }
[16:19:40.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:40.735]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[16:19:40.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:40.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:40.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:40.735]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:40.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:40.735]             base::names(...future.oldOptions))
[16:19:40.735]     }
[16:19:40.735]     if (FALSE) {
[16:19:40.735]     }
[16:19:40.735]     else {
[16:19:40.735]         if (TRUE) {
[16:19:40.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:40.735]                 open = "w")
[16:19:40.735]         }
[16:19:40.735]         else {
[16:19:40.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:40.735]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:40.735]         }
[16:19:40.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:40.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:40.735]             base::sink(type = "output", split = FALSE)
[16:19:40.735]             base::close(...future.stdout)
[16:19:40.735]         }, add = TRUE)
[16:19:40.735]     }
[16:19:40.735]     ...future.frame <- base::sys.nframe()
[16:19:40.735]     ...future.conditions <- base::list()
[16:19:40.735]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:40.735]     if (FALSE) {
[16:19:40.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:40.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:40.735]     }
[16:19:40.735]     ...future.result <- base::tryCatch({
[16:19:40.735]         base::withCallingHandlers({
[16:19:40.735]             ...future.value <- base::withVisible(base::local({
[16:19:40.735]                 ...future.makeSendCondition <- base::local({
[16:19:40.735]                   sendCondition <- NULL
[16:19:40.735]                   function(frame = 1L) {
[16:19:40.735]                     if (is.function(sendCondition)) 
[16:19:40.735]                       return(sendCondition)
[16:19:40.735]                     ns <- getNamespace("parallel")
[16:19:40.735]                     if (exists("sendData", mode = "function", 
[16:19:40.735]                       envir = ns)) {
[16:19:40.735]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:40.735]                         envir = ns)
[16:19:40.735]                       envir <- sys.frame(frame)
[16:19:40.735]                       master <- NULL
[16:19:40.735]                       while (!identical(envir, .GlobalEnv) && 
[16:19:40.735]                         !identical(envir, emptyenv())) {
[16:19:40.735]                         if (exists("master", mode = "list", envir = envir, 
[16:19:40.735]                           inherits = FALSE)) {
[16:19:40.735]                           master <- get("master", mode = "list", 
[16:19:40.735]                             envir = envir, inherits = FALSE)
[16:19:40.735]                           if (inherits(master, c("SOCKnode", 
[16:19:40.735]                             "SOCK0node"))) {
[16:19:40.735]                             sendCondition <<- function(cond) {
[16:19:40.735]                               data <- list(type = "VALUE", value = cond, 
[16:19:40.735]                                 success = TRUE)
[16:19:40.735]                               parallel_sendData(master, data)
[16:19:40.735]                             }
[16:19:40.735]                             return(sendCondition)
[16:19:40.735]                           }
[16:19:40.735]                         }
[16:19:40.735]                         frame <- frame + 1L
[16:19:40.735]                         envir <- sys.frame(frame)
[16:19:40.735]                       }
[16:19:40.735]                     }
[16:19:40.735]                     sendCondition <<- function(cond) NULL
[16:19:40.735]                   }
[16:19:40.735]                 })
[16:19:40.735]                 withCallingHandlers({
[16:19:40.735]                   NA
[16:19:40.735]                 }, immediateCondition = function(cond) {
[16:19:40.735]                   sendCondition <- ...future.makeSendCondition()
[16:19:40.735]                   sendCondition(cond)
[16:19:40.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:40.735]                   {
[16:19:40.735]                     inherits <- base::inherits
[16:19:40.735]                     invokeRestart <- base::invokeRestart
[16:19:40.735]                     is.null <- base::is.null
[16:19:40.735]                     muffled <- FALSE
[16:19:40.735]                     if (inherits(cond, "message")) {
[16:19:40.735]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:40.735]                       if (muffled) 
[16:19:40.735]                         invokeRestart("muffleMessage")
[16:19:40.735]                     }
[16:19:40.735]                     else if (inherits(cond, "warning")) {
[16:19:40.735]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:40.735]                       if (muffled) 
[16:19:40.735]                         invokeRestart("muffleWarning")
[16:19:40.735]                     }
[16:19:40.735]                     else if (inherits(cond, "condition")) {
[16:19:40.735]                       if (!is.null(pattern)) {
[16:19:40.735]                         computeRestarts <- base::computeRestarts
[16:19:40.735]                         grepl <- base::grepl
[16:19:40.735]                         restarts <- computeRestarts(cond)
[16:19:40.735]                         for (restart in restarts) {
[16:19:40.735]                           name <- restart$name
[16:19:40.735]                           if (is.null(name)) 
[16:19:40.735]                             next
[16:19:40.735]                           if (!grepl(pattern, name)) 
[16:19:40.735]                             next
[16:19:40.735]                           invokeRestart(restart)
[16:19:40.735]                           muffled <- TRUE
[16:19:40.735]                           break
[16:19:40.735]                         }
[16:19:40.735]                       }
[16:19:40.735]                     }
[16:19:40.735]                     invisible(muffled)
[16:19:40.735]                   }
[16:19:40.735]                   muffleCondition(cond)
[16:19:40.735]                 })
[16:19:40.735]             }))
[16:19:40.735]             future::FutureResult(value = ...future.value$value, 
[16:19:40.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:40.735]                   ...future.rng), globalenv = if (FALSE) 
[16:19:40.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:40.735]                     ...future.globalenv.names))
[16:19:40.735]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:40.735]         }, condition = base::local({
[16:19:40.735]             c <- base::c
[16:19:40.735]             inherits <- base::inherits
[16:19:40.735]             invokeRestart <- base::invokeRestart
[16:19:40.735]             length <- base::length
[16:19:40.735]             list <- base::list
[16:19:40.735]             seq.int <- base::seq.int
[16:19:40.735]             signalCondition <- base::signalCondition
[16:19:40.735]             sys.calls <- base::sys.calls
[16:19:40.735]             `[[` <- base::`[[`
[16:19:40.735]             `+` <- base::`+`
[16:19:40.735]             `<<-` <- base::`<<-`
[16:19:40.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:40.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:40.735]                   3L)]
[16:19:40.735]             }
[16:19:40.735]             function(cond) {
[16:19:40.735]                 is_error <- inherits(cond, "error")
[16:19:40.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:40.735]                   NULL)
[16:19:40.735]                 if (is_error) {
[16:19:40.735]                   sessionInformation <- function() {
[16:19:40.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:40.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:40.735]                       search = base::search(), system = base::Sys.info())
[16:19:40.735]                   }
[16:19:40.735]                   ...future.conditions[[length(...future.conditions) + 
[16:19:40.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:40.735]                     cond$call), session = sessionInformation(), 
[16:19:40.735]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:40.735]                   signalCondition(cond)
[16:19:40.735]                 }
[16:19:40.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:40.735]                 "immediateCondition"))) {
[16:19:40.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:40.735]                   ...future.conditions[[length(...future.conditions) + 
[16:19:40.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:40.735]                   if (TRUE && !signal) {
[16:19:40.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:40.735]                     {
[16:19:40.735]                       inherits <- base::inherits
[16:19:40.735]                       invokeRestart <- base::invokeRestart
[16:19:40.735]                       is.null <- base::is.null
[16:19:40.735]                       muffled <- FALSE
[16:19:40.735]                       if (inherits(cond, "message")) {
[16:19:40.735]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:40.735]                         if (muffled) 
[16:19:40.735]                           invokeRestart("muffleMessage")
[16:19:40.735]                       }
[16:19:40.735]                       else if (inherits(cond, "warning")) {
[16:19:40.735]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:40.735]                         if (muffled) 
[16:19:40.735]                           invokeRestart("muffleWarning")
[16:19:40.735]                       }
[16:19:40.735]                       else if (inherits(cond, "condition")) {
[16:19:40.735]                         if (!is.null(pattern)) {
[16:19:40.735]                           computeRestarts <- base::computeRestarts
[16:19:40.735]                           grepl <- base::grepl
[16:19:40.735]                           restarts <- computeRestarts(cond)
[16:19:40.735]                           for (restart in restarts) {
[16:19:40.735]                             name <- restart$name
[16:19:40.735]                             if (is.null(name)) 
[16:19:40.735]                               next
[16:19:40.735]                             if (!grepl(pattern, name)) 
[16:19:40.735]                               next
[16:19:40.735]                             invokeRestart(restart)
[16:19:40.735]                             muffled <- TRUE
[16:19:40.735]                             break
[16:19:40.735]                           }
[16:19:40.735]                         }
[16:19:40.735]                       }
[16:19:40.735]                       invisible(muffled)
[16:19:40.735]                     }
[16:19:40.735]                     muffleCondition(cond, pattern = "^muffle")
[16:19:40.735]                   }
[16:19:40.735]                 }
[16:19:40.735]                 else {
[16:19:40.735]                   if (TRUE) {
[16:19:40.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:40.735]                     {
[16:19:40.735]                       inherits <- base::inherits
[16:19:40.735]                       invokeRestart <- base::invokeRestart
[16:19:40.735]                       is.null <- base::is.null
[16:19:40.735]                       muffled <- FALSE
[16:19:40.735]                       if (inherits(cond, "message")) {
[16:19:40.735]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:40.735]                         if (muffled) 
[16:19:40.735]                           invokeRestart("muffleMessage")
[16:19:40.735]                       }
[16:19:40.735]                       else if (inherits(cond, "warning")) {
[16:19:40.735]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:40.735]                         if (muffled) 
[16:19:40.735]                           invokeRestart("muffleWarning")
[16:19:40.735]                       }
[16:19:40.735]                       else if (inherits(cond, "condition")) {
[16:19:40.735]                         if (!is.null(pattern)) {
[16:19:40.735]                           computeRestarts <- base::computeRestarts
[16:19:40.735]                           grepl <- base::grepl
[16:19:40.735]                           restarts <- computeRestarts(cond)
[16:19:40.735]                           for (restart in restarts) {
[16:19:40.735]                             name <- restart$name
[16:19:40.735]                             if (is.null(name)) 
[16:19:40.735]                               next
[16:19:40.735]                             if (!grepl(pattern, name)) 
[16:19:40.735]                               next
[16:19:40.735]                             invokeRestart(restart)
[16:19:40.735]                             muffled <- TRUE
[16:19:40.735]                             break
[16:19:40.735]                           }
[16:19:40.735]                         }
[16:19:40.735]                       }
[16:19:40.735]                       invisible(muffled)
[16:19:40.735]                     }
[16:19:40.735]                     muffleCondition(cond, pattern = "^muffle")
[16:19:40.735]                   }
[16:19:40.735]                 }
[16:19:40.735]             }
[16:19:40.735]         }))
[16:19:40.735]     }, error = function(ex) {
[16:19:40.735]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:40.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:40.735]                 ...future.rng), started = ...future.startTime, 
[16:19:40.735]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:40.735]             version = "1.8"), class = "FutureResult")
[16:19:40.735]     }, finally = {
[16:19:40.735]         if (!identical(...future.workdir, getwd())) 
[16:19:40.735]             setwd(...future.workdir)
[16:19:40.735]         {
[16:19:40.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:40.735]                 ...future.oldOptions$nwarnings <- NULL
[16:19:40.735]             }
[16:19:40.735]             base::options(...future.oldOptions)
[16:19:40.735]             if (.Platform$OS.type == "windows") {
[16:19:40.735]                 old_names <- names(...future.oldEnvVars)
[16:19:40.735]                 envs <- base::Sys.getenv()
[16:19:40.735]                 names <- names(envs)
[16:19:40.735]                 common <- intersect(names, old_names)
[16:19:40.735]                 added <- setdiff(names, old_names)
[16:19:40.735]                 removed <- setdiff(old_names, names)
[16:19:40.735]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:40.735]                   envs[common]]
[16:19:40.735]                 NAMES <- toupper(changed)
[16:19:40.735]                 args <- list()
[16:19:40.735]                 for (kk in seq_along(NAMES)) {
[16:19:40.735]                   name <- changed[[kk]]
[16:19:40.735]                   NAME <- NAMES[[kk]]
[16:19:40.735]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:40.735]                     next
[16:19:40.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:40.735]                 }
[16:19:40.735]                 NAMES <- toupper(added)
[16:19:40.735]                 for (kk in seq_along(NAMES)) {
[16:19:40.735]                   name <- added[[kk]]
[16:19:40.735]                   NAME <- NAMES[[kk]]
[16:19:40.735]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:40.735]                     next
[16:19:40.735]                   args[[name]] <- ""
[16:19:40.735]                 }
[16:19:40.735]                 NAMES <- toupper(removed)
[16:19:40.735]                 for (kk in seq_along(NAMES)) {
[16:19:40.735]                   name <- removed[[kk]]
[16:19:40.735]                   NAME <- NAMES[[kk]]
[16:19:40.735]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:40.735]                     next
[16:19:40.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:40.735]                 }
[16:19:40.735]                 if (length(args) > 0) 
[16:19:40.735]                   base::do.call(base::Sys.setenv, args = args)
[16:19:40.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:40.735]             }
[16:19:40.735]             else {
[16:19:40.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:40.735]             }
[16:19:40.735]             {
[16:19:40.735]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:40.735]                   0L) {
[16:19:40.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:40.735]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:40.735]                   base::options(opts)
[16:19:40.735]                 }
[16:19:40.735]                 {
[16:19:40.735]                   {
[16:19:40.735]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:40.735]                     NULL
[16:19:40.735]                   }
[16:19:40.735]                   options(future.plan = NULL)
[16:19:40.735]                   if (is.na(NA_character_)) 
[16:19:40.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:40.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:40.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:40.735]                     .init = FALSE)
[16:19:40.735]                 }
[16:19:40.735]             }
[16:19:40.735]         }
[16:19:40.735]     })
[16:19:40.735]     if (TRUE) {
[16:19:40.735]         base::sink(type = "output", split = FALSE)
[16:19:40.735]         if (TRUE) {
[16:19:40.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:40.735]         }
[16:19:40.735]         else {
[16:19:40.735]             ...future.result["stdout"] <- base::list(NULL)
[16:19:40.735]         }
[16:19:40.735]         base::close(...future.stdout)
[16:19:40.735]         ...future.stdout <- NULL
[16:19:40.735]     }
[16:19:40.735]     ...future.result$conditions <- ...future.conditions
[16:19:40.735]     ...future.result$finished <- base::Sys.time()
[16:19:40.735]     ...future.result
[16:19:40.735] }
[16:19:40.789] MultisessionFuture started
[16:19:40.789] result() for ClusterFuture ...
[16:19:40.790] receiveMessageFromWorker() for ClusterFuture ...
[16:19:40.790] - Validating connection of MultisessionFuture
[16:19:40.823] - received message: FutureResult
[16:19:40.823] - Received FutureResult
[16:19:40.823] - Erased future from FutureRegistry
[16:19:40.823] result() for ClusterFuture ...
[16:19:40.823] - result already collected: FutureResult
[16:19:40.823] result() for ClusterFuture ... done
[16:19:40.823] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:40.824] result() for ClusterFuture ... done
[16:19:40.824] result() for ClusterFuture ...
[16:19:40.824] - result already collected: FutureResult
[16:19:40.824] result() for ClusterFuture ... done
[16:19:40.824] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[16:19:40.828] plan(): nbrOfWorkers() = 2
* future_lapply(x, ..., future.stdout = FALSE) ...
[16:19:40.828] future_lapply() ...
[16:19:40.833] Number of chunks: 2
[16:19:40.833] getGlobalsAndPackagesXApply() ...
[16:19:40.833]  - future.globals: TRUE
[16:19:40.833] getGlobalsAndPackages() ...
[16:19:40.833] Searching for globals...
[16:19:40.835] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:40.835] Searching for globals ... DONE
[16:19:40.835] Resolving globals: FALSE
[16:19:40.836] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:40.836] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:40.837] - globals: [1] ‘FUN’
[16:19:40.837] 
[16:19:40.837] getGlobalsAndPackages() ... DONE
[16:19:40.837]  - globals found/used: [n=1] ‘FUN’
[16:19:40.837]  - needed namespaces: [n=0] 
[16:19:40.837] Finding globals ... DONE
[16:19:40.837]  - use_args: TRUE
[16:19:40.837]  - Getting '...' globals ...
[16:19:40.838] resolve() on list ...
[16:19:40.838]  recursive: 0
[16:19:40.838]  length: 1
[16:19:40.838]  elements: ‘...’
[16:19:40.838]  length: 0 (resolved future 1)
[16:19:40.838] resolve() on list ... DONE
[16:19:40.839]    - '...' content: [n=0] 
[16:19:40.839] List of 1
[16:19:40.839]  $ ...: list()
[16:19:40.839]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:40.839]  - attr(*, "where")=List of 1
[16:19:40.839]   ..$ ...:<environment: 0x563563c9ed90> 
[16:19:40.839]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:40.839]  - attr(*, "resolved")= logi TRUE
[16:19:40.839]  - attr(*, "total_size")= num NA
[16:19:40.842]  - Getting '...' globals ... DONE
[16:19:40.842] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:40.842] List of 2
[16:19:40.842]  $ ...future.FUN:function (x)  
[16:19:40.842]  $ ...          : list()
[16:19:40.842]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:40.842]  - attr(*, "where")=List of 2
[16:19:40.842]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:40.842]   ..$ ...          :<environment: 0x563563c9ed90> 
[16:19:40.842]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:40.842]  - attr(*, "resolved")= logi FALSE
[16:19:40.842]  - attr(*, "total_size")= num 4720
[16:19:40.846] Packages to be attached in all futures: [n=0] 
[16:19:40.846] getGlobalsAndPackagesXApply() ... DONE
[16:19:40.846] Number of futures (= number of chunks): 2
[16:19:40.846] Launching 2 futures (chunks) ...
[16:19:40.846] Chunk #1 of 2 ...
[16:19:40.846]  - Finding globals in 'X' for chunk #1 ...
[16:19:40.846] getGlobalsAndPackages() ...
[16:19:40.847] Searching for globals...
[16:19:40.847] 
[16:19:40.847] Searching for globals ... DONE
[16:19:40.847] - globals: [0] <none>
[16:19:40.847] getGlobalsAndPackages() ... DONE
[16:19:40.847]    + additional globals found: [n=0] 
[16:19:40.847]    + additional namespaces needed: [n=0] 
[16:19:40.848]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:40.848]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:40.848]  - seeds: <none>
[16:19:40.848]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:40.848] getGlobalsAndPackages() ...
[16:19:40.848] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:40.848] Resolving globals: FALSE
[16:19:40.848] Tweak future expression to call with '...' arguments ...
[16:19:40.849] {
[16:19:40.849]     do.call(function(...) {
[16:19:40.849]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:40.849]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:40.849]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:40.849]             on.exit(options(oopts), add = TRUE)
[16:19:40.849]         }
[16:19:40.849]         {
[16:19:40.849]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:40.849]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:40.849]                 ...future.FUN(...future.X_jj, ...)
[16:19:40.849]             })
[16:19:40.849]         }
[16:19:40.849]     }, args = future.call.arguments)
[16:19:40.849] }
[16:19:40.849] Tweak future expression to call with '...' arguments ... DONE
[16:19:40.849] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:40.849] 
[16:19:40.850] getGlobalsAndPackages() ... DONE
[16:19:40.850] run() for ‘Future’ ...
[16:19:40.850] - state: ‘created’
[16:19:40.850] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:40.864] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:40.865] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:40.865]   - Field: ‘node’
[16:19:40.865]   - Field: ‘label’
[16:19:40.865]   - Field: ‘local’
[16:19:40.865]   - Field: ‘owner’
[16:19:40.865]   - Field: ‘envir’
[16:19:40.865]   - Field: ‘workers’
[16:19:40.865]   - Field: ‘packages’
[16:19:40.865]   - Field: ‘gc’
[16:19:40.866]   - Field: ‘conditions’
[16:19:40.866]   - Field: ‘persistent’
[16:19:40.866]   - Field: ‘expr’
[16:19:40.866]   - Field: ‘uuid’
[16:19:40.866]   - Field: ‘seed’
[16:19:40.866]   - Field: ‘version’
[16:19:40.866]   - Field: ‘result’
[16:19:40.866]   - Field: ‘asynchronous’
[16:19:40.866]   - Field: ‘calls’
[16:19:40.867]   - Field: ‘globals’
[16:19:40.867]   - Field: ‘stdout’
[16:19:40.867]   - Field: ‘earlySignal’
[16:19:40.867]   - Field: ‘lazy’
[16:19:40.867]   - Field: ‘state’
[16:19:40.867] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:40.867] - Launch lazy future ...
[16:19:40.868] Packages needed by the future expression (n = 0): <none>
[16:19:40.868] Packages needed by future strategies (n = 0): <none>
[16:19:40.868] {
[16:19:40.868]     {
[16:19:40.868]         {
[16:19:40.868]             ...future.startTime <- base::Sys.time()
[16:19:40.868]             {
[16:19:40.868]                 {
[16:19:40.868]                   {
[16:19:40.868]                     {
[16:19:40.868]                       base::local({
[16:19:40.868]                         has_future <- base::requireNamespace("future", 
[16:19:40.868]                           quietly = TRUE)
[16:19:40.868]                         if (has_future) {
[16:19:40.868]                           ns <- base::getNamespace("future")
[16:19:40.868]                           version <- ns[[".package"]][["version"]]
[16:19:40.868]                           if (is.null(version)) 
[16:19:40.868]                             version <- utils::packageVersion("future")
[16:19:40.868]                         }
[16:19:40.868]                         else {
[16:19:40.868]                           version <- NULL
[16:19:40.868]                         }
[16:19:40.868]                         if (!has_future || version < "1.8.0") {
[16:19:40.868]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:40.868]                             "", base::R.version$version.string), 
[16:19:40.868]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:40.868]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:40.868]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:40.868]                               "release", "version")], collapse = " "), 
[16:19:40.868]                             hostname = base::Sys.info()[["nodename"]])
[16:19:40.868]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:40.868]                             info)
[16:19:40.868]                           info <- base::paste(info, collapse = "; ")
[16:19:40.868]                           if (!has_future) {
[16:19:40.868]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:40.868]                               info)
[16:19:40.868]                           }
[16:19:40.868]                           else {
[16:19:40.868]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:40.868]                               info, version)
[16:19:40.868]                           }
[16:19:40.868]                           base::stop(msg)
[16:19:40.868]                         }
[16:19:40.868]                       })
[16:19:40.868]                     }
[16:19:40.868]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:40.868]                     base::options(mc.cores = 1L)
[16:19:40.868]                   }
[16:19:40.868]                   ...future.strategy.old <- future::plan("list")
[16:19:40.868]                   options(future.plan = NULL)
[16:19:40.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:40.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:40.868]                 }
[16:19:40.868]                 ...future.workdir <- getwd()
[16:19:40.868]             }
[16:19:40.868]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:40.868]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:40.868]         }
[16:19:40.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:40.868]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:40.868]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:40.868]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:40.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:40.868]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:40.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:40.868]             base::names(...future.oldOptions))
[16:19:40.868]     }
[16:19:40.868]     if (FALSE) {
[16:19:40.868]     }
[16:19:40.868]     else {
[16:19:40.868]         if (FALSE) {
[16:19:40.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:40.868]                 open = "w")
[16:19:40.868]         }
[16:19:40.868]         else {
[16:19:40.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:40.868]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:40.868]         }
[16:19:40.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:40.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:40.868]             base::sink(type = "output", split = FALSE)
[16:19:40.868]             base::close(...future.stdout)
[16:19:40.868]         }, add = TRUE)
[16:19:40.868]     }
[16:19:40.868]     ...future.frame <- base::sys.nframe()
[16:19:40.868]     ...future.conditions <- base::list()
[16:19:40.868]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:40.868]     if (FALSE) {
[16:19:40.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:40.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:40.868]     }
[16:19:40.868]     ...future.result <- base::tryCatch({
[16:19:40.868]         base::withCallingHandlers({
[16:19:40.868]             ...future.value <- base::withVisible(base::local({
[16:19:40.868]                 ...future.makeSendCondition <- base::local({
[16:19:40.868]                   sendCondition <- NULL
[16:19:40.868]                   function(frame = 1L) {
[16:19:40.868]                     if (is.function(sendCondition)) 
[16:19:40.868]                       return(sendCondition)
[16:19:40.868]                     ns <- getNamespace("parallel")
[16:19:40.868]                     if (exists("sendData", mode = "function", 
[16:19:40.868]                       envir = ns)) {
[16:19:40.868]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:40.868]                         envir = ns)
[16:19:40.868]                       envir <- sys.frame(frame)
[16:19:40.868]                       master <- NULL
[16:19:40.868]                       while (!identical(envir, .GlobalEnv) && 
[16:19:40.868]                         !identical(envir, emptyenv())) {
[16:19:40.868]                         if (exists("master", mode = "list", envir = envir, 
[16:19:40.868]                           inherits = FALSE)) {
[16:19:40.868]                           master <- get("master", mode = "list", 
[16:19:40.868]                             envir = envir, inherits = FALSE)
[16:19:40.868]                           if (inherits(master, c("SOCKnode", 
[16:19:40.868]                             "SOCK0node"))) {
[16:19:40.868]                             sendCondition <<- function(cond) {
[16:19:40.868]                               data <- list(type = "VALUE", value = cond, 
[16:19:40.868]                                 success = TRUE)
[16:19:40.868]                               parallel_sendData(master, data)
[16:19:40.868]                             }
[16:19:40.868]                             return(sendCondition)
[16:19:40.868]                           }
[16:19:40.868]                         }
[16:19:40.868]                         frame <- frame + 1L
[16:19:40.868]                         envir <- sys.frame(frame)
[16:19:40.868]                       }
[16:19:40.868]                     }
[16:19:40.868]                     sendCondition <<- function(cond) NULL
[16:19:40.868]                   }
[16:19:40.868]                 })
[16:19:40.868]                 withCallingHandlers({
[16:19:40.868]                   {
[16:19:40.868]                     do.call(function(...) {
[16:19:40.868]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:40.868]                       if (!identical(...future.globals.maxSize.org, 
[16:19:40.868]                         ...future.globals.maxSize)) {
[16:19:40.868]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:40.868]                         on.exit(options(oopts), add = TRUE)
[16:19:40.868]                       }
[16:19:40.868]                       {
[16:19:40.868]                         lapply(seq_along(...future.elements_ii), 
[16:19:40.868]                           FUN = function(jj) {
[16:19:40.868]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:40.868]                             ...future.FUN(...future.X_jj, ...)
[16:19:40.868]                           })
[16:19:40.868]                       }
[16:19:40.868]                     }, args = future.call.arguments)
[16:19:40.868]                   }
[16:19:40.868]                 }, immediateCondition = function(cond) {
[16:19:40.868]                   sendCondition <- ...future.makeSendCondition()
[16:19:40.868]                   sendCondition(cond)
[16:19:40.868]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:40.868]                   {
[16:19:40.868]                     inherits <- base::inherits
[16:19:40.868]                     invokeRestart <- base::invokeRestart
[16:19:40.868]                     is.null <- base::is.null
[16:19:40.868]                     muffled <- FALSE
[16:19:40.868]                     if (inherits(cond, "message")) {
[16:19:40.868]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:40.868]                       if (muffled) 
[16:19:40.868]                         invokeRestart("muffleMessage")
[16:19:40.868]                     }
[16:19:40.868]                     else if (inherits(cond, "warning")) {
[16:19:40.868]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:40.868]                       if (muffled) 
[16:19:40.868]                         invokeRestart("muffleWarning")
[16:19:40.868]                     }
[16:19:40.868]                     else if (inherits(cond, "condition")) {
[16:19:40.868]                       if (!is.null(pattern)) {
[16:19:40.868]                         computeRestarts <- base::computeRestarts
[16:19:40.868]                         grepl <- base::grepl
[16:19:40.868]                         restarts <- computeRestarts(cond)
[16:19:40.868]                         for (restart in restarts) {
[16:19:40.868]                           name <- restart$name
[16:19:40.868]                           if (is.null(name)) 
[16:19:40.868]                             next
[16:19:40.868]                           if (!grepl(pattern, name)) 
[16:19:40.868]                             next
[16:19:40.868]                           invokeRestart(restart)
[16:19:40.868]                           muffled <- TRUE
[16:19:40.868]                           break
[16:19:40.868]                         }
[16:19:40.868]                       }
[16:19:40.868]                     }
[16:19:40.868]                     invisible(muffled)
[16:19:40.868]                   }
[16:19:40.868]                   muffleCondition(cond)
[16:19:40.868]                 })
[16:19:40.868]             }))
[16:19:40.868]             future::FutureResult(value = ...future.value$value, 
[16:19:40.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:40.868]                   ...future.rng), globalenv = if (FALSE) 
[16:19:40.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:40.868]                     ...future.globalenv.names))
[16:19:40.868]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:40.868]         }, condition = base::local({
[16:19:40.868]             c <- base::c
[16:19:40.868]             inherits <- base::inherits
[16:19:40.868]             invokeRestart <- base::invokeRestart
[16:19:40.868]             length <- base::length
[16:19:40.868]             list <- base::list
[16:19:40.868]             seq.int <- base::seq.int
[16:19:40.868]             signalCondition <- base::signalCondition
[16:19:40.868]             sys.calls <- base::sys.calls
[16:19:40.868]             `[[` <- base::`[[`
[16:19:40.868]             `+` <- base::`+`
[16:19:40.868]             `<<-` <- base::`<<-`
[16:19:40.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:40.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:40.868]                   3L)]
[16:19:40.868]             }
[16:19:40.868]             function(cond) {
[16:19:40.868]                 is_error <- inherits(cond, "error")
[16:19:40.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:40.868]                   NULL)
[16:19:40.868]                 if (is_error) {
[16:19:40.868]                   sessionInformation <- function() {
[16:19:40.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:40.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:40.868]                       search = base::search(), system = base::Sys.info())
[16:19:40.868]                   }
[16:19:40.868]                   ...future.conditions[[length(...future.conditions) + 
[16:19:40.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:40.868]                     cond$call), session = sessionInformation(), 
[16:19:40.868]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:40.868]                   signalCondition(cond)
[16:19:40.868]                 }
[16:19:40.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:40.868]                 "immediateCondition"))) {
[16:19:40.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:40.868]                   ...future.conditions[[length(...future.conditions) + 
[16:19:40.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:40.868]                   if (TRUE && !signal) {
[16:19:40.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:40.868]                     {
[16:19:40.868]                       inherits <- base::inherits
[16:19:40.868]                       invokeRestart <- base::invokeRestart
[16:19:40.868]                       is.null <- base::is.null
[16:19:40.868]                       muffled <- FALSE
[16:19:40.868]                       if (inherits(cond, "message")) {
[16:19:40.868]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:40.868]                         if (muffled) 
[16:19:40.868]                           invokeRestart("muffleMessage")
[16:19:40.868]                       }
[16:19:40.868]                       else if (inherits(cond, "warning")) {
[16:19:40.868]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:40.868]                         if (muffled) 
[16:19:40.868]                           invokeRestart("muffleWarning")
[16:19:40.868]                       }
[16:19:40.868]                       else if (inherits(cond, "condition")) {
[16:19:40.868]                         if (!is.null(pattern)) {
[16:19:40.868]                           computeRestarts <- base::computeRestarts
[16:19:40.868]                           grepl <- base::grepl
[16:19:40.868]                           restarts <- computeRestarts(cond)
[16:19:40.868]                           for (restart in restarts) {
[16:19:40.868]                             name <- restart$name
[16:19:40.868]                             if (is.null(name)) 
[16:19:40.868]                               next
[16:19:40.868]                             if (!grepl(pattern, name)) 
[16:19:40.868]                               next
[16:19:40.868]                             invokeRestart(restart)
[16:19:40.868]                             muffled <- TRUE
[16:19:40.868]                             break
[16:19:40.868]                           }
[16:19:40.868]                         }
[16:19:40.868]                       }
[16:19:40.868]                       invisible(muffled)
[16:19:40.868]                     }
[16:19:40.868]                     muffleCondition(cond, pattern = "^muffle")
[16:19:40.868]                   }
[16:19:40.868]                 }
[16:19:40.868]                 else {
[16:19:40.868]                   if (TRUE) {
[16:19:40.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:40.868]                     {
[16:19:40.868]                       inherits <- base::inherits
[16:19:40.868]                       invokeRestart <- base::invokeRestart
[16:19:40.868]                       is.null <- base::is.null
[16:19:40.868]                       muffled <- FALSE
[16:19:40.868]                       if (inherits(cond, "message")) {
[16:19:40.868]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:40.868]                         if (muffled) 
[16:19:40.868]                           invokeRestart("muffleMessage")
[16:19:40.868]                       }
[16:19:40.868]                       else if (inherits(cond, "warning")) {
[16:19:40.868]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:40.868]                         if (muffled) 
[16:19:40.868]                           invokeRestart("muffleWarning")
[16:19:40.868]                       }
[16:19:40.868]                       else if (inherits(cond, "condition")) {
[16:19:40.868]                         if (!is.null(pattern)) {
[16:19:40.868]                           computeRestarts <- base::computeRestarts
[16:19:40.868]                           grepl <- base::grepl
[16:19:40.868]                           restarts <- computeRestarts(cond)
[16:19:40.868]                           for (restart in restarts) {
[16:19:40.868]                             name <- restart$name
[16:19:40.868]                             if (is.null(name)) 
[16:19:40.868]                               next
[16:19:40.868]                             if (!grepl(pattern, name)) 
[16:19:40.868]                               next
[16:19:40.868]                             invokeRestart(restart)
[16:19:40.868]                             muffled <- TRUE
[16:19:40.868]                             break
[16:19:40.868]                           }
[16:19:40.868]                         }
[16:19:40.868]                       }
[16:19:40.868]                       invisible(muffled)
[16:19:40.868]                     }
[16:19:40.868]                     muffleCondition(cond, pattern = "^muffle")
[16:19:40.868]                   }
[16:19:40.868]                 }
[16:19:40.868]             }
[16:19:40.868]         }))
[16:19:40.868]     }, error = function(ex) {
[16:19:40.868]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:40.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:40.868]                 ...future.rng), started = ...future.startTime, 
[16:19:40.868]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:40.868]             version = "1.8"), class = "FutureResult")
[16:19:40.868]     }, finally = {
[16:19:40.868]         if (!identical(...future.workdir, getwd())) 
[16:19:40.868]             setwd(...future.workdir)
[16:19:40.868]         {
[16:19:40.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:40.868]                 ...future.oldOptions$nwarnings <- NULL
[16:19:40.868]             }
[16:19:40.868]             base::options(...future.oldOptions)
[16:19:40.868]             if (.Platform$OS.type == "windows") {
[16:19:40.868]                 old_names <- names(...future.oldEnvVars)
[16:19:40.868]                 envs <- base::Sys.getenv()
[16:19:40.868]                 names <- names(envs)
[16:19:40.868]                 common <- intersect(names, old_names)
[16:19:40.868]                 added <- setdiff(names, old_names)
[16:19:40.868]                 removed <- setdiff(old_names, names)
[16:19:40.868]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:40.868]                   envs[common]]
[16:19:40.868]                 NAMES <- toupper(changed)
[16:19:40.868]                 args <- list()
[16:19:40.868]                 for (kk in seq_along(NAMES)) {
[16:19:40.868]                   name <- changed[[kk]]
[16:19:40.868]                   NAME <- NAMES[[kk]]
[16:19:40.868]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:40.868]                     next
[16:19:40.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:40.868]                 }
[16:19:40.868]                 NAMES <- toupper(added)
[16:19:40.868]                 for (kk in seq_along(NAMES)) {
[16:19:40.868]                   name <- added[[kk]]
[16:19:40.868]                   NAME <- NAMES[[kk]]
[16:19:40.868]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:40.868]                     next
[16:19:40.868]                   args[[name]] <- ""
[16:19:40.868]                 }
[16:19:40.868]                 NAMES <- toupper(removed)
[16:19:40.868]                 for (kk in seq_along(NAMES)) {
[16:19:40.868]                   name <- removed[[kk]]
[16:19:40.868]                   NAME <- NAMES[[kk]]
[16:19:40.868]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:40.868]                     next
[16:19:40.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:40.868]                 }
[16:19:40.868]                 if (length(args) > 0) 
[16:19:40.868]                   base::do.call(base::Sys.setenv, args = args)
[16:19:40.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:40.868]             }
[16:19:40.868]             else {
[16:19:40.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:40.868]             }
[16:19:40.868]             {
[16:19:40.868]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:40.868]                   0L) {
[16:19:40.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:40.868]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:40.868]                   base::options(opts)
[16:19:40.868]                 }
[16:19:40.868]                 {
[16:19:40.868]                   {
[16:19:40.868]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:40.868]                     NULL
[16:19:40.868]                   }
[16:19:40.868]                   options(future.plan = NULL)
[16:19:40.868]                   if (is.na(NA_character_)) 
[16:19:40.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:40.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:40.868]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:40.868]                     .init = FALSE)
[16:19:40.868]                 }
[16:19:40.868]             }
[16:19:40.868]         }
[16:19:40.868]     })
[16:19:40.868]     if (TRUE) {
[16:19:40.868]         base::sink(type = "output", split = FALSE)
[16:19:40.868]         if (FALSE) {
[16:19:40.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:40.868]         }
[16:19:40.868]         else {
[16:19:40.868]             ...future.result["stdout"] <- base::list(NULL)
[16:19:40.868]         }
[16:19:40.868]         base::close(...future.stdout)
[16:19:40.868]         ...future.stdout <- NULL
[16:19:40.868]     }
[16:19:40.868]     ...future.result$conditions <- ...future.conditions
[16:19:40.868]     ...future.result$finished <- base::Sys.time()
[16:19:40.868]     ...future.result
[16:19:40.868] }
[16:19:40.871] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[16:19:40.872] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[16:19:40.872] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[16:19:40.872] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:40.873] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:40.873] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:19:40.873] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:19:40.874] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:40.874] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:40.874] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:40.875] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:40.875] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[16:19:40.875] MultisessionFuture started
[16:19:40.876] - Launch lazy future ... done
[16:19:40.876] run() for ‘MultisessionFuture’ ... done
[16:19:40.876] Created future:
[16:19:40.876] MultisessionFuture:
[16:19:40.876] Label: ‘future_lapply-1’
[16:19:40.876] Expression:
[16:19:40.876] {
[16:19:40.876]     do.call(function(...) {
[16:19:40.876]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:40.876]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:40.876]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:40.876]             on.exit(options(oopts), add = TRUE)
[16:19:40.876]         }
[16:19:40.876]         {
[16:19:40.876]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:40.876]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:40.876]                 ...future.FUN(...future.X_jj, ...)
[16:19:40.876]             })
[16:19:40.876]         }
[16:19:40.876]     }, args = future.call.arguments)
[16:19:40.876] }
[16:19:40.876] Lazy evaluation: FALSE
[16:19:40.876] Asynchronous evaluation: TRUE
[16:19:40.876] Local evaluation: TRUE
[16:19:40.876] Environment: R_GlobalEnv
[16:19:40.876] Capture standard output: FALSE
[16:19:40.876] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:40.876] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:40.876] Packages: <none>
[16:19:40.876] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:40.876] Resolved: FALSE
[16:19:40.876] Value: <not collected>
[16:19:40.876] Conditions captured: <none>
[16:19:40.876] Early signaling: FALSE
[16:19:40.876] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:40.876] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:40.888] Chunk #1 of 2 ... DONE
[16:19:40.888] Chunk #2 of 2 ...
[16:19:40.888]  - Finding globals in 'X' for chunk #2 ...
[16:19:40.889] getGlobalsAndPackages() ...
[16:19:40.889] Searching for globals...
[16:19:40.889] 
[16:19:40.889] Searching for globals ... DONE
[16:19:40.889] - globals: [0] <none>
[16:19:40.889] getGlobalsAndPackages() ... DONE
[16:19:40.890]    + additional globals found: [n=0] 
[16:19:40.890]    + additional namespaces needed: [n=0] 
[16:19:40.890]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:40.890]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:40.890]  - seeds: <none>
[16:19:40.890]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:40.890] getGlobalsAndPackages() ...
[16:19:40.890] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:40.891] Resolving globals: FALSE
[16:19:40.891] Tweak future expression to call with '...' arguments ...
[16:19:40.891] {
[16:19:40.891]     do.call(function(...) {
[16:19:40.891]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:40.891]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:40.891]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:40.891]             on.exit(options(oopts), add = TRUE)
[16:19:40.891]         }
[16:19:40.891]         {
[16:19:40.891]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:40.891]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:40.891]                 ...future.FUN(...future.X_jj, ...)
[16:19:40.891]             })
[16:19:40.891]         }
[16:19:40.891]     }, args = future.call.arguments)
[16:19:40.891] }
[16:19:40.891] Tweak future expression to call with '...' arguments ... DONE
[16:19:40.891] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:40.892] 
[16:19:40.892] getGlobalsAndPackages() ... DONE
[16:19:40.892] run() for ‘Future’ ...
[16:19:40.892] - state: ‘created’
[16:19:40.892] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:40.906] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:40.907] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:40.907]   - Field: ‘node’
[16:19:40.907]   - Field: ‘label’
[16:19:40.907]   - Field: ‘local’
[16:19:40.907]   - Field: ‘owner’
[16:19:40.907]   - Field: ‘envir’
[16:19:40.907]   - Field: ‘workers’
[16:19:40.907]   - Field: ‘packages’
[16:19:40.907]   - Field: ‘gc’
[16:19:40.907]   - Field: ‘conditions’
[16:19:40.908]   - Field: ‘persistent’
[16:19:40.908]   - Field: ‘expr’
[16:19:40.908]   - Field: ‘uuid’
[16:19:40.908]   - Field: ‘seed’
[16:19:40.908]   - Field: ‘version’
[16:19:40.908]   - Field: ‘result’
[16:19:40.908]   - Field: ‘asynchronous’
[16:19:40.908]   - Field: ‘calls’
[16:19:40.908]   - Field: ‘globals’
[16:19:40.909]   - Field: ‘stdout’
[16:19:40.909]   - Field: ‘earlySignal’
[16:19:40.909]   - Field: ‘lazy’
[16:19:40.909]   - Field: ‘state’
[16:19:40.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:40.909] - Launch lazy future ...
[16:19:40.909] Packages needed by the future expression (n = 0): <none>
[16:19:40.910] Packages needed by future strategies (n = 0): <none>
[16:19:40.910] {
[16:19:40.910]     {
[16:19:40.910]         {
[16:19:40.910]             ...future.startTime <- base::Sys.time()
[16:19:40.910]             {
[16:19:40.910]                 {
[16:19:40.910]                   {
[16:19:40.910]                     {
[16:19:40.910]                       base::local({
[16:19:40.910]                         has_future <- base::requireNamespace("future", 
[16:19:40.910]                           quietly = TRUE)
[16:19:40.910]                         if (has_future) {
[16:19:40.910]                           ns <- base::getNamespace("future")
[16:19:40.910]                           version <- ns[[".package"]][["version"]]
[16:19:40.910]                           if (is.null(version)) 
[16:19:40.910]                             version <- utils::packageVersion("future")
[16:19:40.910]                         }
[16:19:40.910]                         else {
[16:19:40.910]                           version <- NULL
[16:19:40.910]                         }
[16:19:40.910]                         if (!has_future || version < "1.8.0") {
[16:19:40.910]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:40.910]                             "", base::R.version$version.string), 
[16:19:40.910]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:40.910]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:40.910]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:40.910]                               "release", "version")], collapse = " "), 
[16:19:40.910]                             hostname = base::Sys.info()[["nodename"]])
[16:19:40.910]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:40.910]                             info)
[16:19:40.910]                           info <- base::paste(info, collapse = "; ")
[16:19:40.910]                           if (!has_future) {
[16:19:40.910]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:40.910]                               info)
[16:19:40.910]                           }
[16:19:40.910]                           else {
[16:19:40.910]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:40.910]                               info, version)
[16:19:40.910]                           }
[16:19:40.910]                           base::stop(msg)
[16:19:40.910]                         }
[16:19:40.910]                       })
[16:19:40.910]                     }
[16:19:40.910]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:40.910]                     base::options(mc.cores = 1L)
[16:19:40.910]                   }
[16:19:40.910]                   ...future.strategy.old <- future::plan("list")
[16:19:40.910]                   options(future.plan = NULL)
[16:19:40.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:40.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:40.910]                 }
[16:19:40.910]                 ...future.workdir <- getwd()
[16:19:40.910]             }
[16:19:40.910]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:40.910]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:40.910]         }
[16:19:40.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:40.910]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:40.910]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:40.910]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:40.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:40.910]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:40.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:40.910]             base::names(...future.oldOptions))
[16:19:40.910]     }
[16:19:40.910]     if (FALSE) {
[16:19:40.910]     }
[16:19:40.910]     else {
[16:19:40.910]         if (FALSE) {
[16:19:40.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:40.910]                 open = "w")
[16:19:40.910]         }
[16:19:40.910]         else {
[16:19:40.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:40.910]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:40.910]         }
[16:19:40.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:40.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:40.910]             base::sink(type = "output", split = FALSE)
[16:19:40.910]             base::close(...future.stdout)
[16:19:40.910]         }, add = TRUE)
[16:19:40.910]     }
[16:19:40.910]     ...future.frame <- base::sys.nframe()
[16:19:40.910]     ...future.conditions <- base::list()
[16:19:40.910]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:40.910]     if (FALSE) {
[16:19:40.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:40.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:40.910]     }
[16:19:40.910]     ...future.result <- base::tryCatch({
[16:19:40.910]         base::withCallingHandlers({
[16:19:40.910]             ...future.value <- base::withVisible(base::local({
[16:19:40.910]                 ...future.makeSendCondition <- base::local({
[16:19:40.910]                   sendCondition <- NULL
[16:19:40.910]                   function(frame = 1L) {
[16:19:40.910]                     if (is.function(sendCondition)) 
[16:19:40.910]                       return(sendCondition)
[16:19:40.910]                     ns <- getNamespace("parallel")
[16:19:40.910]                     if (exists("sendData", mode = "function", 
[16:19:40.910]                       envir = ns)) {
[16:19:40.910]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:40.910]                         envir = ns)
[16:19:40.910]                       envir <- sys.frame(frame)
[16:19:40.910]                       master <- NULL
[16:19:40.910]                       while (!identical(envir, .GlobalEnv) && 
[16:19:40.910]                         !identical(envir, emptyenv())) {
[16:19:40.910]                         if (exists("master", mode = "list", envir = envir, 
[16:19:40.910]                           inherits = FALSE)) {
[16:19:40.910]                           master <- get("master", mode = "list", 
[16:19:40.910]                             envir = envir, inherits = FALSE)
[16:19:40.910]                           if (inherits(master, c("SOCKnode", 
[16:19:40.910]                             "SOCK0node"))) {
[16:19:40.910]                             sendCondition <<- function(cond) {
[16:19:40.910]                               data <- list(type = "VALUE", value = cond, 
[16:19:40.910]                                 success = TRUE)
[16:19:40.910]                               parallel_sendData(master, data)
[16:19:40.910]                             }
[16:19:40.910]                             return(sendCondition)
[16:19:40.910]                           }
[16:19:40.910]                         }
[16:19:40.910]                         frame <- frame + 1L
[16:19:40.910]                         envir <- sys.frame(frame)
[16:19:40.910]                       }
[16:19:40.910]                     }
[16:19:40.910]                     sendCondition <<- function(cond) NULL
[16:19:40.910]                   }
[16:19:40.910]                 })
[16:19:40.910]                 withCallingHandlers({
[16:19:40.910]                   {
[16:19:40.910]                     do.call(function(...) {
[16:19:40.910]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:40.910]                       if (!identical(...future.globals.maxSize.org, 
[16:19:40.910]                         ...future.globals.maxSize)) {
[16:19:40.910]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:40.910]                         on.exit(options(oopts), add = TRUE)
[16:19:40.910]                       }
[16:19:40.910]                       {
[16:19:40.910]                         lapply(seq_along(...future.elements_ii), 
[16:19:40.910]                           FUN = function(jj) {
[16:19:40.910]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:40.910]                             ...future.FUN(...future.X_jj, ...)
[16:19:40.910]                           })
[16:19:40.910]                       }
[16:19:40.910]                     }, args = future.call.arguments)
[16:19:40.910]                   }
[16:19:40.910]                 }, immediateCondition = function(cond) {
[16:19:40.910]                   sendCondition <- ...future.makeSendCondition()
[16:19:40.910]                   sendCondition(cond)
[16:19:40.910]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:40.910]                   {
[16:19:40.910]                     inherits <- base::inherits
[16:19:40.910]                     invokeRestart <- base::invokeRestart
[16:19:40.910]                     is.null <- base::is.null
[16:19:40.910]                     muffled <- FALSE
[16:19:40.910]                     if (inherits(cond, "message")) {
[16:19:40.910]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:40.910]                       if (muffled) 
[16:19:40.910]                         invokeRestart("muffleMessage")
[16:19:40.910]                     }
[16:19:40.910]                     else if (inherits(cond, "warning")) {
[16:19:40.910]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:40.910]                       if (muffled) 
[16:19:40.910]                         invokeRestart("muffleWarning")
[16:19:40.910]                     }
[16:19:40.910]                     else if (inherits(cond, "condition")) {
[16:19:40.910]                       if (!is.null(pattern)) {
[16:19:40.910]                         computeRestarts <- base::computeRestarts
[16:19:40.910]                         grepl <- base::grepl
[16:19:40.910]                         restarts <- computeRestarts(cond)
[16:19:40.910]                         for (restart in restarts) {
[16:19:40.910]                           name <- restart$name
[16:19:40.910]                           if (is.null(name)) 
[16:19:40.910]                             next
[16:19:40.910]                           if (!grepl(pattern, name)) 
[16:19:40.910]                             next
[16:19:40.910]                           invokeRestart(restart)
[16:19:40.910]                           muffled <- TRUE
[16:19:40.910]                           break
[16:19:40.910]                         }
[16:19:40.910]                       }
[16:19:40.910]                     }
[16:19:40.910]                     invisible(muffled)
[16:19:40.910]                   }
[16:19:40.910]                   muffleCondition(cond)
[16:19:40.910]                 })
[16:19:40.910]             }))
[16:19:40.910]             future::FutureResult(value = ...future.value$value, 
[16:19:40.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:40.910]                   ...future.rng), globalenv = if (FALSE) 
[16:19:40.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:40.910]                     ...future.globalenv.names))
[16:19:40.910]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:40.910]         }, condition = base::local({
[16:19:40.910]             c <- base::c
[16:19:40.910]             inherits <- base::inherits
[16:19:40.910]             invokeRestart <- base::invokeRestart
[16:19:40.910]             length <- base::length
[16:19:40.910]             list <- base::list
[16:19:40.910]             seq.int <- base::seq.int
[16:19:40.910]             signalCondition <- base::signalCondition
[16:19:40.910]             sys.calls <- base::sys.calls
[16:19:40.910]             `[[` <- base::`[[`
[16:19:40.910]             `+` <- base::`+`
[16:19:40.910]             `<<-` <- base::`<<-`
[16:19:40.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:40.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:40.910]                   3L)]
[16:19:40.910]             }
[16:19:40.910]             function(cond) {
[16:19:40.910]                 is_error <- inherits(cond, "error")
[16:19:40.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:40.910]                   NULL)
[16:19:40.910]                 if (is_error) {
[16:19:40.910]                   sessionInformation <- function() {
[16:19:40.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:40.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:40.910]                       search = base::search(), system = base::Sys.info())
[16:19:40.910]                   }
[16:19:40.910]                   ...future.conditions[[length(...future.conditions) + 
[16:19:40.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:40.910]                     cond$call), session = sessionInformation(), 
[16:19:40.910]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:40.910]                   signalCondition(cond)
[16:19:40.910]                 }
[16:19:40.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:40.910]                 "immediateCondition"))) {
[16:19:40.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:40.910]                   ...future.conditions[[length(...future.conditions) + 
[16:19:40.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:40.910]                   if (TRUE && !signal) {
[16:19:40.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:40.910]                     {
[16:19:40.910]                       inherits <- base::inherits
[16:19:40.910]                       invokeRestart <- base::invokeRestart
[16:19:40.910]                       is.null <- base::is.null
[16:19:40.910]                       muffled <- FALSE
[16:19:40.910]                       if (inherits(cond, "message")) {
[16:19:40.910]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:40.910]                         if (muffled) 
[16:19:40.910]                           invokeRestart("muffleMessage")
[16:19:40.910]                       }
[16:19:40.910]                       else if (inherits(cond, "warning")) {
[16:19:40.910]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:40.910]                         if (muffled) 
[16:19:40.910]                           invokeRestart("muffleWarning")
[16:19:40.910]                       }
[16:19:40.910]                       else if (inherits(cond, "condition")) {
[16:19:40.910]                         if (!is.null(pattern)) {
[16:19:40.910]                           computeRestarts <- base::computeRestarts
[16:19:40.910]                           grepl <- base::grepl
[16:19:40.910]                           restarts <- computeRestarts(cond)
[16:19:40.910]                           for (restart in restarts) {
[16:19:40.910]                             name <- restart$name
[16:19:40.910]                             if (is.null(name)) 
[16:19:40.910]                               next
[16:19:40.910]                             if (!grepl(pattern, name)) 
[16:19:40.910]                               next
[16:19:40.910]                             invokeRestart(restart)
[16:19:40.910]                             muffled <- TRUE
[16:19:40.910]                             break
[16:19:40.910]                           }
[16:19:40.910]                         }
[16:19:40.910]                       }
[16:19:40.910]                       invisible(muffled)
[16:19:40.910]                     }
[16:19:40.910]                     muffleCondition(cond, pattern = "^muffle")
[16:19:40.910]                   }
[16:19:40.910]                 }
[16:19:40.910]                 else {
[16:19:40.910]                   if (TRUE) {
[16:19:40.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:40.910]                     {
[16:19:40.910]                       inherits <- base::inherits
[16:19:40.910]                       invokeRestart <- base::invokeRestart
[16:19:40.910]                       is.null <- base::is.null
[16:19:40.910]                       muffled <- FALSE
[16:19:40.910]                       if (inherits(cond, "message")) {
[16:19:40.910]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:40.910]                         if (muffled) 
[16:19:40.910]                           invokeRestart("muffleMessage")
[16:19:40.910]                       }
[16:19:40.910]                       else if (inherits(cond, "warning")) {
[16:19:40.910]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:40.910]                         if (muffled) 
[16:19:40.910]                           invokeRestart("muffleWarning")
[16:19:40.910]                       }
[16:19:40.910]                       else if (inherits(cond, "condition")) {
[16:19:40.910]                         if (!is.null(pattern)) {
[16:19:40.910]                           computeRestarts <- base::computeRestarts
[16:19:40.910]                           grepl <- base::grepl
[16:19:40.910]                           restarts <- computeRestarts(cond)
[16:19:40.910]                           for (restart in restarts) {
[16:19:40.910]                             name <- restart$name
[16:19:40.910]                             if (is.null(name)) 
[16:19:40.910]                               next
[16:19:40.910]                             if (!grepl(pattern, name)) 
[16:19:40.910]                               next
[16:19:40.910]                             invokeRestart(restart)
[16:19:40.910]                             muffled <- TRUE
[16:19:40.910]                             break
[16:19:40.910]                           }
[16:19:40.910]                         }
[16:19:40.910]                       }
[16:19:40.910]                       invisible(muffled)
[16:19:40.910]                     }
[16:19:40.910]                     muffleCondition(cond, pattern = "^muffle")
[16:19:40.910]                   }
[16:19:40.910]                 }
[16:19:40.910]             }
[16:19:40.910]         }))
[16:19:40.910]     }, error = function(ex) {
[16:19:40.910]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:40.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:40.910]                 ...future.rng), started = ...future.startTime, 
[16:19:40.910]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:40.910]             version = "1.8"), class = "FutureResult")
[16:19:40.910]     }, finally = {
[16:19:40.910]         if (!identical(...future.workdir, getwd())) 
[16:19:40.910]             setwd(...future.workdir)
[16:19:40.910]         {
[16:19:40.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:40.910]                 ...future.oldOptions$nwarnings <- NULL
[16:19:40.910]             }
[16:19:40.910]             base::options(...future.oldOptions)
[16:19:40.910]             if (.Platform$OS.type == "windows") {
[16:19:40.910]                 old_names <- names(...future.oldEnvVars)
[16:19:40.910]                 envs <- base::Sys.getenv()
[16:19:40.910]                 names <- names(envs)
[16:19:40.910]                 common <- intersect(names, old_names)
[16:19:40.910]                 added <- setdiff(names, old_names)
[16:19:40.910]                 removed <- setdiff(old_names, names)
[16:19:40.910]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:40.910]                   envs[common]]
[16:19:40.910]                 NAMES <- toupper(changed)
[16:19:40.910]                 args <- list()
[16:19:40.910]                 for (kk in seq_along(NAMES)) {
[16:19:40.910]                   name <- changed[[kk]]
[16:19:40.910]                   NAME <- NAMES[[kk]]
[16:19:40.910]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:40.910]                     next
[16:19:40.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:40.910]                 }
[16:19:40.910]                 NAMES <- toupper(added)
[16:19:40.910]                 for (kk in seq_along(NAMES)) {
[16:19:40.910]                   name <- added[[kk]]
[16:19:40.910]                   NAME <- NAMES[[kk]]
[16:19:40.910]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:40.910]                     next
[16:19:40.910]                   args[[name]] <- ""
[16:19:40.910]                 }
[16:19:40.910]                 NAMES <- toupper(removed)
[16:19:40.910]                 for (kk in seq_along(NAMES)) {
[16:19:40.910]                   name <- removed[[kk]]
[16:19:40.910]                   NAME <- NAMES[[kk]]
[16:19:40.910]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:40.910]                     next
[16:19:40.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:40.910]                 }
[16:19:40.910]                 if (length(args) > 0) 
[16:19:40.910]                   base::do.call(base::Sys.setenv, args = args)
[16:19:40.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:40.910]             }
[16:19:40.910]             else {
[16:19:40.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:40.910]             }
[16:19:40.910]             {
[16:19:40.910]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:40.910]                   0L) {
[16:19:40.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:40.910]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:40.910]                   base::options(opts)
[16:19:40.910]                 }
[16:19:40.910]                 {
[16:19:40.910]                   {
[16:19:40.910]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:40.910]                     NULL
[16:19:40.910]                   }
[16:19:40.910]                   options(future.plan = NULL)
[16:19:40.910]                   if (is.na(NA_character_)) 
[16:19:40.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:40.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:40.910]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:40.910]                     .init = FALSE)
[16:19:40.910]                 }
[16:19:40.910]             }
[16:19:40.910]         }
[16:19:40.910]     })
[16:19:40.910]     if (TRUE) {
[16:19:40.910]         base::sink(type = "output", split = FALSE)
[16:19:40.910]         if (FALSE) {
[16:19:40.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:40.910]         }
[16:19:40.910]         else {
[16:19:40.910]             ...future.result["stdout"] <- base::list(NULL)
[16:19:40.910]         }
[16:19:40.910]         base::close(...future.stdout)
[16:19:40.910]         ...future.stdout <- NULL
[16:19:40.910]     }
[16:19:40.910]     ...future.result$conditions <- ...future.conditions
[16:19:40.910]     ...future.result$finished <- base::Sys.time()
[16:19:40.910]     ...future.result
[16:19:40.910] }
[16:19:40.963] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[16:19:40.963] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[16:19:40.964] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[16:19:40.964] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:19:40.964] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:19:40.965] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:19:40.965] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:19:40.965] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:40.965] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:40.966] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:40.966] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:40.966] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[16:19:40.967] MultisessionFuture started
[16:19:40.967] - Launch lazy future ... done
[16:19:40.967] run() for ‘MultisessionFuture’ ... done
[16:19:40.967] Created future:
[16:19:40.967] MultisessionFuture:
[16:19:40.967] Label: ‘future_lapply-2’
[16:19:40.967] Expression:
[16:19:40.967] {
[16:19:40.967]     do.call(function(...) {
[16:19:40.967]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:40.967]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:40.967]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:40.967]             on.exit(options(oopts), add = TRUE)
[16:19:40.967]         }
[16:19:40.967]         {
[16:19:40.967]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:40.967]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:40.967]                 ...future.FUN(...future.X_jj, ...)
[16:19:40.967]             })
[16:19:40.967]         }
[16:19:40.967]     }, args = future.call.arguments)
[16:19:40.967] }
[16:19:40.967] Lazy evaluation: FALSE
[16:19:40.967] Asynchronous evaluation: TRUE
[16:19:40.967] Local evaluation: TRUE
[16:19:40.967] Environment: R_GlobalEnv
[16:19:40.967] Capture standard output: FALSE
[16:19:40.967] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:40.967] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:40.967] Packages: <none>
[16:19:40.967] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:40.967] Resolved: FALSE
[16:19:40.967] Value: <not collected>
[16:19:40.967] Conditions captured: <none>
[16:19:40.967] Early signaling: FALSE
[16:19:40.967] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:40.967] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:40.979] Chunk #2 of 2 ... DONE
[16:19:40.979] Launching 2 futures (chunks) ... DONE
[16:19:40.979] Resolving 2 futures (chunks) ...
[16:19:40.980] resolve() on list ...
[16:19:40.980]  recursive: 0
[16:19:40.982]  length: 2
[16:19:40.982] 
[16:19:41.055] receiveMessageFromWorker() for ClusterFuture ...
[16:19:41.055] - Validating connection of MultisessionFuture
[16:19:41.056] - received message: FutureResult
[16:19:41.056] - Received FutureResult
[16:19:41.056] - Erased future from FutureRegistry
[16:19:41.056] result() for ClusterFuture ...
[16:19:41.056] - result already collected: FutureResult
[16:19:41.056] result() for ClusterFuture ... done
[16:19:41.056] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:41.056] Future #2
[16:19:41.056] result() for ClusterFuture ...
[16:19:41.057] - result already collected: FutureResult
[16:19:41.057] result() for ClusterFuture ... done
[16:19:41.057] result() for ClusterFuture ...
[16:19:41.057] - result already collected: FutureResult
[16:19:41.057] result() for ClusterFuture ... done
[16:19:41.057] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:41.057] - nx: 2
[16:19:41.057] - relay: TRUE
[16:19:41.057] - stdout: TRUE
[16:19:41.057] - signal: TRUE
[16:19:41.057] - resignal: FALSE
[16:19:41.057] - force: TRUE
[16:19:41.058] - relayed: [n=2] FALSE, FALSE
[16:19:41.058] - queued futures: [n=2] FALSE, FALSE
[16:19:41.058]  - until=1
[16:19:41.058]  - relaying element #1
[16:19:41.058] - relayed: [n=2] FALSE, FALSE
[16:19:41.058] - queued futures: [n=2] FALSE, TRUE
[16:19:41.058] signalConditionsASAP(NULL, pos=2) ... done
[16:19:41.058]  length: 1 (resolved future 2)
[16:19:41.422] receiveMessageFromWorker() for ClusterFuture ...
[16:19:41.423] - Validating connection of MultisessionFuture
[16:19:41.423] - received message: FutureResult
[16:19:41.423] - Received FutureResult
[16:19:41.423] - Erased future from FutureRegistry
[16:19:41.423] result() for ClusterFuture ...
[16:19:41.423] - result already collected: FutureResult
[16:19:41.423] result() for ClusterFuture ... done
[16:19:41.423] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:41.424] Future #1
[16:19:41.424] result() for ClusterFuture ...
[16:19:41.424] - result already collected: FutureResult
[16:19:41.424] result() for ClusterFuture ... done
[16:19:41.424] result() for ClusterFuture ...
[16:19:41.424] - result already collected: FutureResult
[16:19:41.424] result() for ClusterFuture ... done
[16:19:41.424] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:41.424] - nx: 2
[16:19:41.424] - relay: TRUE
[16:19:41.425] - stdout: TRUE
[16:19:41.425] - signal: TRUE
[16:19:41.425] - resignal: FALSE
[16:19:41.425] - force: TRUE
[16:19:41.425] - relayed: [n=2] FALSE, FALSE
[16:19:41.425] - queued futures: [n=2] FALSE, TRUE
[16:19:41.425]  - until=1
[16:19:41.425]  - relaying element #1
[16:19:41.425] result() for ClusterFuture ...
[16:19:41.425] - result already collected: FutureResult
[16:19:41.425] result() for ClusterFuture ... done
[16:19:41.425] result() for ClusterFuture ...
[16:19:41.426] - result already collected: FutureResult
[16:19:41.426] result() for ClusterFuture ... done
[16:19:41.426] result() for ClusterFuture ...
[16:19:41.426] - result already collected: FutureResult
[16:19:41.426] result() for ClusterFuture ... done
[16:19:41.426] result() for ClusterFuture ...
[16:19:41.426] - result already collected: FutureResult
[16:19:41.426] result() for ClusterFuture ... done
[16:19:41.426] - relayed: [n=2] TRUE, FALSE
[16:19:41.426] - queued futures: [n=2] TRUE, TRUE
[16:19:41.426] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:41.427]  length: 0 (resolved future 1)
[16:19:41.427] Relaying remaining futures
[16:19:41.427] signalConditionsASAP(NULL, pos=0) ...
[16:19:41.427] - nx: 2
[16:19:41.427] - relay: TRUE
[16:19:41.427] - stdout: TRUE
[16:19:41.427] - signal: TRUE
[16:19:41.427] - resignal: FALSE
[16:19:41.427] - force: TRUE
[16:19:41.427] - relayed: [n=2] TRUE, FALSE
[16:19:41.427] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:41.427]  - relaying element #2
[16:19:41.428] result() for ClusterFuture ...
[16:19:41.428] - result already collected: FutureResult
[16:19:41.428] result() for ClusterFuture ... done
[16:19:41.428] result() for ClusterFuture ...
[16:19:41.428] - result already collected: FutureResult
[16:19:41.428] result() for ClusterFuture ... done
[16:19:41.428] result() for ClusterFuture ...
[16:19:41.428] - result already collected: FutureResult
[16:19:41.428] result() for ClusterFuture ... done
[16:19:41.428] result() for ClusterFuture ...
[16:19:41.428] - result already collected: FutureResult
[16:19:41.429] result() for ClusterFuture ... done
[16:19:41.429] - relayed: [n=2] TRUE, TRUE
[16:19:41.429] - queued futures: [n=2] TRUE, TRUE
[16:19:41.429] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:19:41.429] resolve() on list ... DONE
[16:19:41.429] result() for ClusterFuture ...
[16:19:41.429] - result already collected: FutureResult
[16:19:41.429] result() for ClusterFuture ... done
[16:19:41.429] result() for ClusterFuture ...
[16:19:41.429] - result already collected: FutureResult
[16:19:41.429] result() for ClusterFuture ... done
[16:19:41.429] result() for ClusterFuture ...
[16:19:41.430] - result already collected: FutureResult
[16:19:41.430] result() for ClusterFuture ... done
[16:19:41.430] result() for ClusterFuture ...
[16:19:41.430] - result already collected: FutureResult
[16:19:41.430] result() for ClusterFuture ... done
[16:19:41.430]  - Number of value chunks collected: 2
[16:19:41.430] Resolving 2 futures (chunks) ... DONE
[16:19:41.430] Reducing values from 2 chunks ...
[16:19:41.430]  - Number of values collected after concatenation: 2
[16:19:41.430]  - Number of values expected: 2
[16:19:41.430] Reducing values from 2 chunks ... DONE
[16:19:41.431] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = FALSE) ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ...
[16:19:41.431] future_lapply() ...
[16:19:41.435] Number of chunks: 2
[16:19:41.435] getGlobalsAndPackagesXApply() ...
[16:19:41.435]  - future.globals: TRUE
[16:19:41.436] getGlobalsAndPackages() ...
[16:19:41.436] Searching for globals...
[16:19:41.437] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:41.437] Searching for globals ... DONE
[16:19:41.437] Resolving globals: FALSE
[16:19:41.438] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:41.438] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:41.438] - globals: [1] ‘FUN’
[16:19:41.438] 
[16:19:41.438] getGlobalsAndPackages() ... DONE
[16:19:41.439]  - globals found/used: [n=1] ‘FUN’
[16:19:41.439]  - needed namespaces: [n=0] 
[16:19:41.439] Finding globals ... DONE
[16:19:41.439]  - use_args: TRUE
[16:19:41.439]  - Getting '...' globals ...
[16:19:41.439] resolve() on list ...
[16:19:41.439]  recursive: 0
[16:19:41.439]  length: 1
[16:19:41.439]  elements: ‘...’
[16:19:41.440]  length: 0 (resolved future 1)
[16:19:41.440] resolve() on list ... DONE
[16:19:41.440]    - '...' content: [n=0] 
[16:19:41.440] List of 1
[16:19:41.440]  $ ...: list()
[16:19:41.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:41.440]  - attr(*, "where")=List of 1
[16:19:41.440]   ..$ ...:<environment: 0x5635620d2200> 
[16:19:41.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:41.440]  - attr(*, "resolved")= logi TRUE
[16:19:41.440]  - attr(*, "total_size")= num NA
[16:19:41.442]  - Getting '...' globals ... DONE
[16:19:41.443] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:41.443] List of 2
[16:19:41.443]  $ ...future.FUN:function (x)  
[16:19:41.443]  $ ...          : list()
[16:19:41.443]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:41.443]  - attr(*, "where")=List of 2
[16:19:41.443]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:41.443]   ..$ ...          :<environment: 0x5635620d2200> 
[16:19:41.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:41.443]  - attr(*, "resolved")= logi FALSE
[16:19:41.443]  - attr(*, "total_size")= num 4720
[16:19:41.445] Packages to be attached in all futures: [n=0] 
[16:19:41.445] getGlobalsAndPackagesXApply() ... DONE
[16:19:41.446] Number of futures (= number of chunks): 2
[16:19:41.446] Launching 2 futures (chunks) ...
[16:19:41.446] Chunk #1 of 2 ...
[16:19:41.446]  - Finding globals in 'X' for chunk #1 ...
[16:19:41.446] getGlobalsAndPackages() ...
[16:19:41.446] Searching for globals...
[16:19:41.446] 
[16:19:41.446] Searching for globals ... DONE
[16:19:41.447] - globals: [0] <none>
[16:19:41.447] getGlobalsAndPackages() ... DONE
[16:19:41.447]    + additional globals found: [n=0] 
[16:19:41.447]    + additional namespaces needed: [n=0] 
[16:19:41.447]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:41.447]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:41.447]  - seeds: <none>
[16:19:41.447]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:41.447] getGlobalsAndPackages() ...
[16:19:41.447] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:41.448] Resolving globals: FALSE
[16:19:41.448] Tweak future expression to call with '...' arguments ...
[16:19:41.448] {
[16:19:41.448]     do.call(function(...) {
[16:19:41.448]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:41.448]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:41.448]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:41.448]             on.exit(options(oopts), add = TRUE)
[16:19:41.448]         }
[16:19:41.448]         {
[16:19:41.448]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:41.448]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:41.448]                 ...future.FUN(...future.X_jj, ...)
[16:19:41.448]             })
[16:19:41.448]         }
[16:19:41.448]     }, args = future.call.arguments)
[16:19:41.448] }
[16:19:41.448] Tweak future expression to call with '...' arguments ... DONE
[16:19:41.448] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:41.449] 
[16:19:41.449] getGlobalsAndPackages() ... DONE
[16:19:41.449] run() for ‘Future’ ...
[16:19:41.449] - state: ‘created’
[16:19:41.449] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:41.463] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:41.463] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:41.463]   - Field: ‘node’
[16:19:41.463]   - Field: ‘label’
[16:19:41.463]   - Field: ‘local’
[16:19:41.463]   - Field: ‘owner’
[16:19:41.463]   - Field: ‘envir’
[16:19:41.463]   - Field: ‘workers’
[16:19:41.464]   - Field: ‘packages’
[16:19:41.464]   - Field: ‘gc’
[16:19:41.464]   - Field: ‘conditions’
[16:19:41.464]   - Field: ‘persistent’
[16:19:41.464]   - Field: ‘expr’
[16:19:41.464]   - Field: ‘uuid’
[16:19:41.464]   - Field: ‘seed’
[16:19:41.464]   - Field: ‘version’
[16:19:41.464]   - Field: ‘result’
[16:19:41.464]   - Field: ‘asynchronous’
[16:19:41.464]   - Field: ‘calls’
[16:19:41.465]   - Field: ‘globals’
[16:19:41.465]   - Field: ‘stdout’
[16:19:41.465]   - Field: ‘earlySignal’
[16:19:41.465]   - Field: ‘lazy’
[16:19:41.465]   - Field: ‘state’
[16:19:41.465] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:41.465] - Launch lazy future ...
[16:19:41.465] Packages needed by the future expression (n = 0): <none>
[16:19:41.466] Packages needed by future strategies (n = 0): <none>
[16:19:41.466] {
[16:19:41.466]     {
[16:19:41.466]         {
[16:19:41.466]             ...future.startTime <- base::Sys.time()
[16:19:41.466]             {
[16:19:41.466]                 {
[16:19:41.466]                   {
[16:19:41.466]                     {
[16:19:41.466]                       base::local({
[16:19:41.466]                         has_future <- base::requireNamespace("future", 
[16:19:41.466]                           quietly = TRUE)
[16:19:41.466]                         if (has_future) {
[16:19:41.466]                           ns <- base::getNamespace("future")
[16:19:41.466]                           version <- ns[[".package"]][["version"]]
[16:19:41.466]                           if (is.null(version)) 
[16:19:41.466]                             version <- utils::packageVersion("future")
[16:19:41.466]                         }
[16:19:41.466]                         else {
[16:19:41.466]                           version <- NULL
[16:19:41.466]                         }
[16:19:41.466]                         if (!has_future || version < "1.8.0") {
[16:19:41.466]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:41.466]                             "", base::R.version$version.string), 
[16:19:41.466]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:41.466]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:41.466]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:41.466]                               "release", "version")], collapse = " "), 
[16:19:41.466]                             hostname = base::Sys.info()[["nodename"]])
[16:19:41.466]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:41.466]                             info)
[16:19:41.466]                           info <- base::paste(info, collapse = "; ")
[16:19:41.466]                           if (!has_future) {
[16:19:41.466]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:41.466]                               info)
[16:19:41.466]                           }
[16:19:41.466]                           else {
[16:19:41.466]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:41.466]                               info, version)
[16:19:41.466]                           }
[16:19:41.466]                           base::stop(msg)
[16:19:41.466]                         }
[16:19:41.466]                       })
[16:19:41.466]                     }
[16:19:41.466]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:41.466]                     base::options(mc.cores = 1L)
[16:19:41.466]                   }
[16:19:41.466]                   ...future.strategy.old <- future::plan("list")
[16:19:41.466]                   options(future.plan = NULL)
[16:19:41.466]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:41.466]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:41.466]                 }
[16:19:41.466]                 ...future.workdir <- getwd()
[16:19:41.466]             }
[16:19:41.466]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:41.466]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:41.466]         }
[16:19:41.466]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:41.466]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:41.466]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:41.466]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:41.466]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:41.466]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:41.466]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:41.466]             base::names(...future.oldOptions))
[16:19:41.466]     }
[16:19:41.466]     if (FALSE) {
[16:19:41.466]     }
[16:19:41.466]     else {
[16:19:41.466]         if (TRUE) {
[16:19:41.466]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:41.466]                 open = "w")
[16:19:41.466]         }
[16:19:41.466]         else {
[16:19:41.466]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:41.466]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:41.466]         }
[16:19:41.466]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:41.466]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:41.466]             base::sink(type = "output", split = FALSE)
[16:19:41.466]             base::close(...future.stdout)
[16:19:41.466]         }, add = TRUE)
[16:19:41.466]     }
[16:19:41.466]     ...future.frame <- base::sys.nframe()
[16:19:41.466]     ...future.conditions <- base::list()
[16:19:41.466]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:41.466]     if (FALSE) {
[16:19:41.466]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:41.466]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:41.466]     }
[16:19:41.466]     ...future.result <- base::tryCatch({
[16:19:41.466]         base::withCallingHandlers({
[16:19:41.466]             ...future.value <- base::withVisible(base::local({
[16:19:41.466]                 ...future.makeSendCondition <- base::local({
[16:19:41.466]                   sendCondition <- NULL
[16:19:41.466]                   function(frame = 1L) {
[16:19:41.466]                     if (is.function(sendCondition)) 
[16:19:41.466]                       return(sendCondition)
[16:19:41.466]                     ns <- getNamespace("parallel")
[16:19:41.466]                     if (exists("sendData", mode = "function", 
[16:19:41.466]                       envir = ns)) {
[16:19:41.466]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:41.466]                         envir = ns)
[16:19:41.466]                       envir <- sys.frame(frame)
[16:19:41.466]                       master <- NULL
[16:19:41.466]                       while (!identical(envir, .GlobalEnv) && 
[16:19:41.466]                         !identical(envir, emptyenv())) {
[16:19:41.466]                         if (exists("master", mode = "list", envir = envir, 
[16:19:41.466]                           inherits = FALSE)) {
[16:19:41.466]                           master <- get("master", mode = "list", 
[16:19:41.466]                             envir = envir, inherits = FALSE)
[16:19:41.466]                           if (inherits(master, c("SOCKnode", 
[16:19:41.466]                             "SOCK0node"))) {
[16:19:41.466]                             sendCondition <<- function(cond) {
[16:19:41.466]                               data <- list(type = "VALUE", value = cond, 
[16:19:41.466]                                 success = TRUE)
[16:19:41.466]                               parallel_sendData(master, data)
[16:19:41.466]                             }
[16:19:41.466]                             return(sendCondition)
[16:19:41.466]                           }
[16:19:41.466]                         }
[16:19:41.466]                         frame <- frame + 1L
[16:19:41.466]                         envir <- sys.frame(frame)
[16:19:41.466]                       }
[16:19:41.466]                     }
[16:19:41.466]                     sendCondition <<- function(cond) NULL
[16:19:41.466]                   }
[16:19:41.466]                 })
[16:19:41.466]                 withCallingHandlers({
[16:19:41.466]                   {
[16:19:41.466]                     do.call(function(...) {
[16:19:41.466]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:41.466]                       if (!identical(...future.globals.maxSize.org, 
[16:19:41.466]                         ...future.globals.maxSize)) {
[16:19:41.466]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:41.466]                         on.exit(options(oopts), add = TRUE)
[16:19:41.466]                       }
[16:19:41.466]                       {
[16:19:41.466]                         lapply(seq_along(...future.elements_ii), 
[16:19:41.466]                           FUN = function(jj) {
[16:19:41.466]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:41.466]                             ...future.FUN(...future.X_jj, ...)
[16:19:41.466]                           })
[16:19:41.466]                       }
[16:19:41.466]                     }, args = future.call.arguments)
[16:19:41.466]                   }
[16:19:41.466]                 }, immediateCondition = function(cond) {
[16:19:41.466]                   sendCondition <- ...future.makeSendCondition()
[16:19:41.466]                   sendCondition(cond)
[16:19:41.466]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:41.466]                   {
[16:19:41.466]                     inherits <- base::inherits
[16:19:41.466]                     invokeRestart <- base::invokeRestart
[16:19:41.466]                     is.null <- base::is.null
[16:19:41.466]                     muffled <- FALSE
[16:19:41.466]                     if (inherits(cond, "message")) {
[16:19:41.466]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:41.466]                       if (muffled) 
[16:19:41.466]                         invokeRestart("muffleMessage")
[16:19:41.466]                     }
[16:19:41.466]                     else if (inherits(cond, "warning")) {
[16:19:41.466]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:41.466]                       if (muffled) 
[16:19:41.466]                         invokeRestart("muffleWarning")
[16:19:41.466]                     }
[16:19:41.466]                     else if (inherits(cond, "condition")) {
[16:19:41.466]                       if (!is.null(pattern)) {
[16:19:41.466]                         computeRestarts <- base::computeRestarts
[16:19:41.466]                         grepl <- base::grepl
[16:19:41.466]                         restarts <- computeRestarts(cond)
[16:19:41.466]                         for (restart in restarts) {
[16:19:41.466]                           name <- restart$name
[16:19:41.466]                           if (is.null(name)) 
[16:19:41.466]                             next
[16:19:41.466]                           if (!grepl(pattern, name)) 
[16:19:41.466]                             next
[16:19:41.466]                           invokeRestart(restart)
[16:19:41.466]                           muffled <- TRUE
[16:19:41.466]                           break
[16:19:41.466]                         }
[16:19:41.466]                       }
[16:19:41.466]                     }
[16:19:41.466]                     invisible(muffled)
[16:19:41.466]                   }
[16:19:41.466]                   muffleCondition(cond)
[16:19:41.466]                 })
[16:19:41.466]             }))
[16:19:41.466]             future::FutureResult(value = ...future.value$value, 
[16:19:41.466]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:41.466]                   ...future.rng), globalenv = if (FALSE) 
[16:19:41.466]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:41.466]                     ...future.globalenv.names))
[16:19:41.466]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:41.466]         }, condition = base::local({
[16:19:41.466]             c <- base::c
[16:19:41.466]             inherits <- base::inherits
[16:19:41.466]             invokeRestart <- base::invokeRestart
[16:19:41.466]             length <- base::length
[16:19:41.466]             list <- base::list
[16:19:41.466]             seq.int <- base::seq.int
[16:19:41.466]             signalCondition <- base::signalCondition
[16:19:41.466]             sys.calls <- base::sys.calls
[16:19:41.466]             `[[` <- base::`[[`
[16:19:41.466]             `+` <- base::`+`
[16:19:41.466]             `<<-` <- base::`<<-`
[16:19:41.466]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:41.466]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:41.466]                   3L)]
[16:19:41.466]             }
[16:19:41.466]             function(cond) {
[16:19:41.466]                 is_error <- inherits(cond, "error")
[16:19:41.466]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:41.466]                   NULL)
[16:19:41.466]                 if (is_error) {
[16:19:41.466]                   sessionInformation <- function() {
[16:19:41.466]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:41.466]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:41.466]                       search = base::search(), system = base::Sys.info())
[16:19:41.466]                   }
[16:19:41.466]                   ...future.conditions[[length(...future.conditions) + 
[16:19:41.466]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:41.466]                     cond$call), session = sessionInformation(), 
[16:19:41.466]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:41.466]                   signalCondition(cond)
[16:19:41.466]                 }
[16:19:41.466]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:41.466]                 "immediateCondition"))) {
[16:19:41.466]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:41.466]                   ...future.conditions[[length(...future.conditions) + 
[16:19:41.466]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:41.466]                   if (TRUE && !signal) {
[16:19:41.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:41.466]                     {
[16:19:41.466]                       inherits <- base::inherits
[16:19:41.466]                       invokeRestart <- base::invokeRestart
[16:19:41.466]                       is.null <- base::is.null
[16:19:41.466]                       muffled <- FALSE
[16:19:41.466]                       if (inherits(cond, "message")) {
[16:19:41.466]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:41.466]                         if (muffled) 
[16:19:41.466]                           invokeRestart("muffleMessage")
[16:19:41.466]                       }
[16:19:41.466]                       else if (inherits(cond, "warning")) {
[16:19:41.466]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:41.466]                         if (muffled) 
[16:19:41.466]                           invokeRestart("muffleWarning")
[16:19:41.466]                       }
[16:19:41.466]                       else if (inherits(cond, "condition")) {
[16:19:41.466]                         if (!is.null(pattern)) {
[16:19:41.466]                           computeRestarts <- base::computeRestarts
[16:19:41.466]                           grepl <- base::grepl
[16:19:41.466]                           restarts <- computeRestarts(cond)
[16:19:41.466]                           for (restart in restarts) {
[16:19:41.466]                             name <- restart$name
[16:19:41.466]                             if (is.null(name)) 
[16:19:41.466]                               next
[16:19:41.466]                             if (!grepl(pattern, name)) 
[16:19:41.466]                               next
[16:19:41.466]                             invokeRestart(restart)
[16:19:41.466]                             muffled <- TRUE
[16:19:41.466]                             break
[16:19:41.466]                           }
[16:19:41.466]                         }
[16:19:41.466]                       }
[16:19:41.466]                       invisible(muffled)
[16:19:41.466]                     }
[16:19:41.466]                     muffleCondition(cond, pattern = "^muffle")
[16:19:41.466]                   }
[16:19:41.466]                 }
[16:19:41.466]                 else {
[16:19:41.466]                   if (TRUE) {
[16:19:41.466]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:41.466]                     {
[16:19:41.466]                       inherits <- base::inherits
[16:19:41.466]                       invokeRestart <- base::invokeRestart
[16:19:41.466]                       is.null <- base::is.null
[16:19:41.466]                       muffled <- FALSE
[16:19:41.466]                       if (inherits(cond, "message")) {
[16:19:41.466]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:41.466]                         if (muffled) 
[16:19:41.466]                           invokeRestart("muffleMessage")
[16:19:41.466]                       }
[16:19:41.466]                       else if (inherits(cond, "warning")) {
[16:19:41.466]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:41.466]                         if (muffled) 
[16:19:41.466]                           invokeRestart("muffleWarning")
[16:19:41.466]                       }
[16:19:41.466]                       else if (inherits(cond, "condition")) {
[16:19:41.466]                         if (!is.null(pattern)) {
[16:19:41.466]                           computeRestarts <- base::computeRestarts
[16:19:41.466]                           grepl <- base::grepl
[16:19:41.466]                           restarts <- computeRestarts(cond)
[16:19:41.466]                           for (restart in restarts) {
[16:19:41.466]                             name <- restart$name
[16:19:41.466]                             if (is.null(name)) 
[16:19:41.466]                               next
[16:19:41.466]                             if (!grepl(pattern, name)) 
[16:19:41.466]                               next
[16:19:41.466]                             invokeRestart(restart)
[16:19:41.466]                             muffled <- TRUE
[16:19:41.466]                             break
[16:19:41.466]                           }
[16:19:41.466]                         }
[16:19:41.466]                       }
[16:19:41.466]                       invisible(muffled)
[16:19:41.466]                     }
[16:19:41.466]                     muffleCondition(cond, pattern = "^muffle")
[16:19:41.466]                   }
[16:19:41.466]                 }
[16:19:41.466]             }
[16:19:41.466]         }))
[16:19:41.466]     }, error = function(ex) {
[16:19:41.466]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:41.466]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:41.466]                 ...future.rng), started = ...future.startTime, 
[16:19:41.466]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:41.466]             version = "1.8"), class = "FutureResult")
[16:19:41.466]     }, finally = {
[16:19:41.466]         if (!identical(...future.workdir, getwd())) 
[16:19:41.466]             setwd(...future.workdir)
[16:19:41.466]         {
[16:19:41.466]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:41.466]                 ...future.oldOptions$nwarnings <- NULL
[16:19:41.466]             }
[16:19:41.466]             base::options(...future.oldOptions)
[16:19:41.466]             if (.Platform$OS.type == "windows") {
[16:19:41.466]                 old_names <- names(...future.oldEnvVars)
[16:19:41.466]                 envs <- base::Sys.getenv()
[16:19:41.466]                 names <- names(envs)
[16:19:41.466]                 common <- intersect(names, old_names)
[16:19:41.466]                 added <- setdiff(names, old_names)
[16:19:41.466]                 removed <- setdiff(old_names, names)
[16:19:41.466]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:41.466]                   envs[common]]
[16:19:41.466]                 NAMES <- toupper(changed)
[16:19:41.466]                 args <- list()
[16:19:41.466]                 for (kk in seq_along(NAMES)) {
[16:19:41.466]                   name <- changed[[kk]]
[16:19:41.466]                   NAME <- NAMES[[kk]]
[16:19:41.466]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:41.466]                     next
[16:19:41.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:41.466]                 }
[16:19:41.466]                 NAMES <- toupper(added)
[16:19:41.466]                 for (kk in seq_along(NAMES)) {
[16:19:41.466]                   name <- added[[kk]]
[16:19:41.466]                   NAME <- NAMES[[kk]]
[16:19:41.466]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:41.466]                     next
[16:19:41.466]                   args[[name]] <- ""
[16:19:41.466]                 }
[16:19:41.466]                 NAMES <- toupper(removed)
[16:19:41.466]                 for (kk in seq_along(NAMES)) {
[16:19:41.466]                   name <- removed[[kk]]
[16:19:41.466]                   NAME <- NAMES[[kk]]
[16:19:41.466]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:41.466]                     next
[16:19:41.466]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:41.466]                 }
[16:19:41.466]                 if (length(args) > 0) 
[16:19:41.466]                   base::do.call(base::Sys.setenv, args = args)
[16:19:41.466]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:41.466]             }
[16:19:41.466]             else {
[16:19:41.466]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:41.466]             }
[16:19:41.466]             {
[16:19:41.466]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:41.466]                   0L) {
[16:19:41.466]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:41.466]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:41.466]                   base::options(opts)
[16:19:41.466]                 }
[16:19:41.466]                 {
[16:19:41.466]                   {
[16:19:41.466]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:41.466]                     NULL
[16:19:41.466]                   }
[16:19:41.466]                   options(future.plan = NULL)
[16:19:41.466]                   if (is.na(NA_character_)) 
[16:19:41.466]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:41.466]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:41.466]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:41.466]                     .init = FALSE)
[16:19:41.466]                 }
[16:19:41.466]             }
[16:19:41.466]         }
[16:19:41.466]     })
[16:19:41.466]     if (TRUE) {
[16:19:41.466]         base::sink(type = "output", split = FALSE)
[16:19:41.466]         if (TRUE) {
[16:19:41.466]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:41.466]         }
[16:19:41.466]         else {
[16:19:41.466]             ...future.result["stdout"] <- base::list(NULL)
[16:19:41.466]         }
[16:19:41.466]         base::close(...future.stdout)
[16:19:41.466]         ...future.stdout <- NULL
[16:19:41.466]     }
[16:19:41.466]     ...future.result$conditions <- ...future.conditions
[16:19:41.466]     ...future.result$finished <- base::Sys.time()
[16:19:41.466]     ...future.result
[16:19:41.466] }
[16:19:41.469] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[16:19:41.469] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[16:19:41.469] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[16:19:41.469] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:41.470] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:41.470] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:19:41.470] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:19:41.470] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:41.471] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:41.471] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:41.471] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:41.471] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[16:19:41.472] MultisessionFuture started
[16:19:41.472] - Launch lazy future ... done
[16:19:41.472] run() for ‘MultisessionFuture’ ... done
[16:19:41.472] Created future:
[16:19:41.472] MultisessionFuture:
[16:19:41.472] Label: ‘future_lapply-1’
[16:19:41.472] Expression:
[16:19:41.472] {
[16:19:41.472]     do.call(function(...) {
[16:19:41.472]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:41.472]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:41.472]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:41.472]             on.exit(options(oopts), add = TRUE)
[16:19:41.472]         }
[16:19:41.472]         {
[16:19:41.472]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:41.472]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:41.472]                 ...future.FUN(...future.X_jj, ...)
[16:19:41.472]             })
[16:19:41.472]         }
[16:19:41.472]     }, args = future.call.arguments)
[16:19:41.472] }
[16:19:41.472] Lazy evaluation: FALSE
[16:19:41.472] Asynchronous evaluation: TRUE
[16:19:41.472] Local evaluation: TRUE
[16:19:41.472] Environment: R_GlobalEnv
[16:19:41.472] Capture standard output: TRUE
[16:19:41.472] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:41.472] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:41.472] Packages: <none>
[16:19:41.472] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:41.472] Resolved: FALSE
[16:19:41.472] Value: <not collected>
[16:19:41.472] Conditions captured: <none>
[16:19:41.472] Early signaling: FALSE
[16:19:41.472] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:41.472] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:41.483] Chunk #1 of 2 ... DONE
[16:19:41.484] Chunk #2 of 2 ...
[16:19:41.484]  - Finding globals in 'X' for chunk #2 ...
[16:19:41.484] getGlobalsAndPackages() ...
[16:19:41.484] Searching for globals...
[16:19:41.484] 
[16:19:41.484] Searching for globals ... DONE
[16:19:41.484] - globals: [0] <none>
[16:19:41.484] getGlobalsAndPackages() ... DONE
[16:19:41.485]    + additional globals found: [n=0] 
[16:19:41.485]    + additional namespaces needed: [n=0] 
[16:19:41.485]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:41.485]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:41.485]  - seeds: <none>
[16:19:41.485]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:41.485] getGlobalsAndPackages() ...
[16:19:41.485] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:41.485] Resolving globals: FALSE
[16:19:41.485] Tweak future expression to call with '...' arguments ...
[16:19:41.486] {
[16:19:41.486]     do.call(function(...) {
[16:19:41.486]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:41.486]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:41.486]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:41.486]             on.exit(options(oopts), add = TRUE)
[16:19:41.486]         }
[16:19:41.486]         {
[16:19:41.486]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:41.486]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:41.486]                 ...future.FUN(...future.X_jj, ...)
[16:19:41.486]             })
[16:19:41.486]         }
[16:19:41.486]     }, args = future.call.arguments)
[16:19:41.486] }
[16:19:41.486] Tweak future expression to call with '...' arguments ... DONE
[16:19:41.486] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:41.486] 
[16:19:41.486] getGlobalsAndPackages() ... DONE
[16:19:41.487] run() for ‘Future’ ...
[16:19:41.487] - state: ‘created’
[16:19:41.487] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:41.500] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:41.500] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:41.501]   - Field: ‘node’
[16:19:41.501]   - Field: ‘label’
[16:19:41.501]   - Field: ‘local’
[16:19:41.501]   - Field: ‘owner’
[16:19:41.501]   - Field: ‘envir’
[16:19:41.501]   - Field: ‘workers’
[16:19:41.501]   - Field: ‘packages’
[16:19:41.501]   - Field: ‘gc’
[16:19:41.501]   - Field: ‘conditions’
[16:19:41.501]   - Field: ‘persistent’
[16:19:41.501]   - Field: ‘expr’
[16:19:41.502]   - Field: ‘uuid’
[16:19:41.502]   - Field: ‘seed’
[16:19:41.502]   - Field: ‘version’
[16:19:41.502]   - Field: ‘result’
[16:19:41.502]   - Field: ‘asynchronous’
[16:19:41.502]   - Field: ‘calls’
[16:19:41.502]   - Field: ‘globals’
[16:19:41.502]   - Field: ‘stdout’
[16:19:41.502]   - Field: ‘earlySignal’
[16:19:41.502]   - Field: ‘lazy’
[16:19:41.502]   - Field: ‘state’
[16:19:41.503] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:41.503] - Launch lazy future ...
[16:19:41.503] Packages needed by the future expression (n = 0): <none>
[16:19:41.503] Packages needed by future strategies (n = 0): <none>
[16:19:41.503] {
[16:19:41.503]     {
[16:19:41.503]         {
[16:19:41.503]             ...future.startTime <- base::Sys.time()
[16:19:41.503]             {
[16:19:41.503]                 {
[16:19:41.503]                   {
[16:19:41.503]                     {
[16:19:41.503]                       base::local({
[16:19:41.503]                         has_future <- base::requireNamespace("future", 
[16:19:41.503]                           quietly = TRUE)
[16:19:41.503]                         if (has_future) {
[16:19:41.503]                           ns <- base::getNamespace("future")
[16:19:41.503]                           version <- ns[[".package"]][["version"]]
[16:19:41.503]                           if (is.null(version)) 
[16:19:41.503]                             version <- utils::packageVersion("future")
[16:19:41.503]                         }
[16:19:41.503]                         else {
[16:19:41.503]                           version <- NULL
[16:19:41.503]                         }
[16:19:41.503]                         if (!has_future || version < "1.8.0") {
[16:19:41.503]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:41.503]                             "", base::R.version$version.string), 
[16:19:41.503]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:41.503]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:41.503]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:41.503]                               "release", "version")], collapse = " "), 
[16:19:41.503]                             hostname = base::Sys.info()[["nodename"]])
[16:19:41.503]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:41.503]                             info)
[16:19:41.503]                           info <- base::paste(info, collapse = "; ")
[16:19:41.503]                           if (!has_future) {
[16:19:41.503]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:41.503]                               info)
[16:19:41.503]                           }
[16:19:41.503]                           else {
[16:19:41.503]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:41.503]                               info, version)
[16:19:41.503]                           }
[16:19:41.503]                           base::stop(msg)
[16:19:41.503]                         }
[16:19:41.503]                       })
[16:19:41.503]                     }
[16:19:41.503]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:41.503]                     base::options(mc.cores = 1L)
[16:19:41.503]                   }
[16:19:41.503]                   ...future.strategy.old <- future::plan("list")
[16:19:41.503]                   options(future.plan = NULL)
[16:19:41.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:41.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:41.503]                 }
[16:19:41.503]                 ...future.workdir <- getwd()
[16:19:41.503]             }
[16:19:41.503]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:41.503]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:41.503]         }
[16:19:41.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:41.503]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:41.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:41.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:41.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:41.503]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:41.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:41.503]             base::names(...future.oldOptions))
[16:19:41.503]     }
[16:19:41.503]     if (FALSE) {
[16:19:41.503]     }
[16:19:41.503]     else {
[16:19:41.503]         if (TRUE) {
[16:19:41.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:41.503]                 open = "w")
[16:19:41.503]         }
[16:19:41.503]         else {
[16:19:41.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:41.503]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:41.503]         }
[16:19:41.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:41.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:41.503]             base::sink(type = "output", split = FALSE)
[16:19:41.503]             base::close(...future.stdout)
[16:19:41.503]         }, add = TRUE)
[16:19:41.503]     }
[16:19:41.503]     ...future.frame <- base::sys.nframe()
[16:19:41.503]     ...future.conditions <- base::list()
[16:19:41.503]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:41.503]     if (FALSE) {
[16:19:41.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:41.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:41.503]     }
[16:19:41.503]     ...future.result <- base::tryCatch({
[16:19:41.503]         base::withCallingHandlers({
[16:19:41.503]             ...future.value <- base::withVisible(base::local({
[16:19:41.503]                 ...future.makeSendCondition <- base::local({
[16:19:41.503]                   sendCondition <- NULL
[16:19:41.503]                   function(frame = 1L) {
[16:19:41.503]                     if (is.function(sendCondition)) 
[16:19:41.503]                       return(sendCondition)
[16:19:41.503]                     ns <- getNamespace("parallel")
[16:19:41.503]                     if (exists("sendData", mode = "function", 
[16:19:41.503]                       envir = ns)) {
[16:19:41.503]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:41.503]                         envir = ns)
[16:19:41.503]                       envir <- sys.frame(frame)
[16:19:41.503]                       master <- NULL
[16:19:41.503]                       while (!identical(envir, .GlobalEnv) && 
[16:19:41.503]                         !identical(envir, emptyenv())) {
[16:19:41.503]                         if (exists("master", mode = "list", envir = envir, 
[16:19:41.503]                           inherits = FALSE)) {
[16:19:41.503]                           master <- get("master", mode = "list", 
[16:19:41.503]                             envir = envir, inherits = FALSE)
[16:19:41.503]                           if (inherits(master, c("SOCKnode", 
[16:19:41.503]                             "SOCK0node"))) {
[16:19:41.503]                             sendCondition <<- function(cond) {
[16:19:41.503]                               data <- list(type = "VALUE", value = cond, 
[16:19:41.503]                                 success = TRUE)
[16:19:41.503]                               parallel_sendData(master, data)
[16:19:41.503]                             }
[16:19:41.503]                             return(sendCondition)
[16:19:41.503]                           }
[16:19:41.503]                         }
[16:19:41.503]                         frame <- frame + 1L
[16:19:41.503]                         envir <- sys.frame(frame)
[16:19:41.503]                       }
[16:19:41.503]                     }
[16:19:41.503]                     sendCondition <<- function(cond) NULL
[16:19:41.503]                   }
[16:19:41.503]                 })
[16:19:41.503]                 withCallingHandlers({
[16:19:41.503]                   {
[16:19:41.503]                     do.call(function(...) {
[16:19:41.503]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:41.503]                       if (!identical(...future.globals.maxSize.org, 
[16:19:41.503]                         ...future.globals.maxSize)) {
[16:19:41.503]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:41.503]                         on.exit(options(oopts), add = TRUE)
[16:19:41.503]                       }
[16:19:41.503]                       {
[16:19:41.503]                         lapply(seq_along(...future.elements_ii), 
[16:19:41.503]                           FUN = function(jj) {
[16:19:41.503]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:41.503]                             ...future.FUN(...future.X_jj, ...)
[16:19:41.503]                           })
[16:19:41.503]                       }
[16:19:41.503]                     }, args = future.call.arguments)
[16:19:41.503]                   }
[16:19:41.503]                 }, immediateCondition = function(cond) {
[16:19:41.503]                   sendCondition <- ...future.makeSendCondition()
[16:19:41.503]                   sendCondition(cond)
[16:19:41.503]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:41.503]                   {
[16:19:41.503]                     inherits <- base::inherits
[16:19:41.503]                     invokeRestart <- base::invokeRestart
[16:19:41.503]                     is.null <- base::is.null
[16:19:41.503]                     muffled <- FALSE
[16:19:41.503]                     if (inherits(cond, "message")) {
[16:19:41.503]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:41.503]                       if (muffled) 
[16:19:41.503]                         invokeRestart("muffleMessage")
[16:19:41.503]                     }
[16:19:41.503]                     else if (inherits(cond, "warning")) {
[16:19:41.503]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:41.503]                       if (muffled) 
[16:19:41.503]                         invokeRestart("muffleWarning")
[16:19:41.503]                     }
[16:19:41.503]                     else if (inherits(cond, "condition")) {
[16:19:41.503]                       if (!is.null(pattern)) {
[16:19:41.503]                         computeRestarts <- base::computeRestarts
[16:19:41.503]                         grepl <- base::grepl
[16:19:41.503]                         restarts <- computeRestarts(cond)
[16:19:41.503]                         for (restart in restarts) {
[16:19:41.503]                           name <- restart$name
[16:19:41.503]                           if (is.null(name)) 
[16:19:41.503]                             next
[16:19:41.503]                           if (!grepl(pattern, name)) 
[16:19:41.503]                             next
[16:19:41.503]                           invokeRestart(restart)
[16:19:41.503]                           muffled <- TRUE
[16:19:41.503]                           break
[16:19:41.503]                         }
[16:19:41.503]                       }
[16:19:41.503]                     }
[16:19:41.503]                     invisible(muffled)
[16:19:41.503]                   }
[16:19:41.503]                   muffleCondition(cond)
[16:19:41.503]                 })
[16:19:41.503]             }))
[16:19:41.503]             future::FutureResult(value = ...future.value$value, 
[16:19:41.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:41.503]                   ...future.rng), globalenv = if (FALSE) 
[16:19:41.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:41.503]                     ...future.globalenv.names))
[16:19:41.503]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:41.503]         }, condition = base::local({
[16:19:41.503]             c <- base::c
[16:19:41.503]             inherits <- base::inherits
[16:19:41.503]             invokeRestart <- base::invokeRestart
[16:19:41.503]             length <- base::length
[16:19:41.503]             list <- base::list
[16:19:41.503]             seq.int <- base::seq.int
[16:19:41.503]             signalCondition <- base::signalCondition
[16:19:41.503]             sys.calls <- base::sys.calls
[16:19:41.503]             `[[` <- base::`[[`
[16:19:41.503]             `+` <- base::`+`
[16:19:41.503]             `<<-` <- base::`<<-`
[16:19:41.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:41.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:41.503]                   3L)]
[16:19:41.503]             }
[16:19:41.503]             function(cond) {
[16:19:41.503]                 is_error <- inherits(cond, "error")
[16:19:41.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:41.503]                   NULL)
[16:19:41.503]                 if (is_error) {
[16:19:41.503]                   sessionInformation <- function() {
[16:19:41.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:41.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:41.503]                       search = base::search(), system = base::Sys.info())
[16:19:41.503]                   }
[16:19:41.503]                   ...future.conditions[[length(...future.conditions) + 
[16:19:41.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:41.503]                     cond$call), session = sessionInformation(), 
[16:19:41.503]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:41.503]                   signalCondition(cond)
[16:19:41.503]                 }
[16:19:41.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:41.503]                 "immediateCondition"))) {
[16:19:41.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:41.503]                   ...future.conditions[[length(...future.conditions) + 
[16:19:41.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:41.503]                   if (TRUE && !signal) {
[16:19:41.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:41.503]                     {
[16:19:41.503]                       inherits <- base::inherits
[16:19:41.503]                       invokeRestart <- base::invokeRestart
[16:19:41.503]                       is.null <- base::is.null
[16:19:41.503]                       muffled <- FALSE
[16:19:41.503]                       if (inherits(cond, "message")) {
[16:19:41.503]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:41.503]                         if (muffled) 
[16:19:41.503]                           invokeRestart("muffleMessage")
[16:19:41.503]                       }
[16:19:41.503]                       else if (inherits(cond, "warning")) {
[16:19:41.503]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:41.503]                         if (muffled) 
[16:19:41.503]                           invokeRestart("muffleWarning")
[16:19:41.503]                       }
[16:19:41.503]                       else if (inherits(cond, "condition")) {
[16:19:41.503]                         if (!is.null(pattern)) {
[16:19:41.503]                           computeRestarts <- base::computeRestarts
[16:19:41.503]                           grepl <- base::grepl
[16:19:41.503]                           restarts <- computeRestarts(cond)
[16:19:41.503]                           for (restart in restarts) {
[16:19:41.503]                             name <- restart$name
[16:19:41.503]                             if (is.null(name)) 
[16:19:41.503]                               next
[16:19:41.503]                             if (!grepl(pattern, name)) 
[16:19:41.503]                               next
[16:19:41.503]                             invokeRestart(restart)
[16:19:41.503]                             muffled <- TRUE
[16:19:41.503]                             break
[16:19:41.503]                           }
[16:19:41.503]                         }
[16:19:41.503]                       }
[16:19:41.503]                       invisible(muffled)
[16:19:41.503]                     }
[16:19:41.503]                     muffleCondition(cond, pattern = "^muffle")
[16:19:41.503]                   }
[16:19:41.503]                 }
[16:19:41.503]                 else {
[16:19:41.503]                   if (TRUE) {
[16:19:41.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:41.503]                     {
[16:19:41.503]                       inherits <- base::inherits
[16:19:41.503]                       invokeRestart <- base::invokeRestart
[16:19:41.503]                       is.null <- base::is.null
[16:19:41.503]                       muffled <- FALSE
[16:19:41.503]                       if (inherits(cond, "message")) {
[16:19:41.503]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:41.503]                         if (muffled) 
[16:19:41.503]                           invokeRestart("muffleMessage")
[16:19:41.503]                       }
[16:19:41.503]                       else if (inherits(cond, "warning")) {
[16:19:41.503]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:41.503]                         if (muffled) 
[16:19:41.503]                           invokeRestart("muffleWarning")
[16:19:41.503]                       }
[16:19:41.503]                       else if (inherits(cond, "condition")) {
[16:19:41.503]                         if (!is.null(pattern)) {
[16:19:41.503]                           computeRestarts <- base::computeRestarts
[16:19:41.503]                           grepl <- base::grepl
[16:19:41.503]                           restarts <- computeRestarts(cond)
[16:19:41.503]                           for (restart in restarts) {
[16:19:41.503]                             name <- restart$name
[16:19:41.503]                             if (is.null(name)) 
[16:19:41.503]                               next
[16:19:41.503]                             if (!grepl(pattern, name)) 
[16:19:41.503]                               next
[16:19:41.503]                             invokeRestart(restart)
[16:19:41.503]                             muffled <- TRUE
[16:19:41.503]                             break
[16:19:41.503]                           }
[16:19:41.503]                         }
[16:19:41.503]                       }
[16:19:41.503]                       invisible(muffled)
[16:19:41.503]                     }
[16:19:41.503]                     muffleCondition(cond, pattern = "^muffle")
[16:19:41.503]                   }
[16:19:41.503]                 }
[16:19:41.503]             }
[16:19:41.503]         }))
[16:19:41.503]     }, error = function(ex) {
[16:19:41.503]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:41.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:41.503]                 ...future.rng), started = ...future.startTime, 
[16:19:41.503]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:41.503]             version = "1.8"), class = "FutureResult")
[16:19:41.503]     }, finally = {
[16:19:41.503]         if (!identical(...future.workdir, getwd())) 
[16:19:41.503]             setwd(...future.workdir)
[16:19:41.503]         {
[16:19:41.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:41.503]                 ...future.oldOptions$nwarnings <- NULL
[16:19:41.503]             }
[16:19:41.503]             base::options(...future.oldOptions)
[16:19:41.503]             if (.Platform$OS.type == "windows") {
[16:19:41.503]                 old_names <- names(...future.oldEnvVars)
[16:19:41.503]                 envs <- base::Sys.getenv()
[16:19:41.503]                 names <- names(envs)
[16:19:41.503]                 common <- intersect(names, old_names)
[16:19:41.503]                 added <- setdiff(names, old_names)
[16:19:41.503]                 removed <- setdiff(old_names, names)
[16:19:41.503]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:41.503]                   envs[common]]
[16:19:41.503]                 NAMES <- toupper(changed)
[16:19:41.503]                 args <- list()
[16:19:41.503]                 for (kk in seq_along(NAMES)) {
[16:19:41.503]                   name <- changed[[kk]]
[16:19:41.503]                   NAME <- NAMES[[kk]]
[16:19:41.503]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:41.503]                     next
[16:19:41.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:41.503]                 }
[16:19:41.503]                 NAMES <- toupper(added)
[16:19:41.503]                 for (kk in seq_along(NAMES)) {
[16:19:41.503]                   name <- added[[kk]]
[16:19:41.503]                   NAME <- NAMES[[kk]]
[16:19:41.503]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:41.503]                     next
[16:19:41.503]                   args[[name]] <- ""
[16:19:41.503]                 }
[16:19:41.503]                 NAMES <- toupper(removed)
[16:19:41.503]                 for (kk in seq_along(NAMES)) {
[16:19:41.503]                   name <- removed[[kk]]
[16:19:41.503]                   NAME <- NAMES[[kk]]
[16:19:41.503]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:41.503]                     next
[16:19:41.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:41.503]                 }
[16:19:41.503]                 if (length(args) > 0) 
[16:19:41.503]                   base::do.call(base::Sys.setenv, args = args)
[16:19:41.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:41.503]             }
[16:19:41.503]             else {
[16:19:41.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:41.503]             }
[16:19:41.503]             {
[16:19:41.503]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:41.503]                   0L) {
[16:19:41.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:41.503]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:41.503]                   base::options(opts)
[16:19:41.503]                 }
[16:19:41.503]                 {
[16:19:41.503]                   {
[16:19:41.503]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:41.503]                     NULL
[16:19:41.503]                   }
[16:19:41.503]                   options(future.plan = NULL)
[16:19:41.503]                   if (is.na(NA_character_)) 
[16:19:41.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:41.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:41.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:41.503]                     .init = FALSE)
[16:19:41.503]                 }
[16:19:41.503]             }
[16:19:41.503]         }
[16:19:41.503]     })
[16:19:41.503]     if (TRUE) {
[16:19:41.503]         base::sink(type = "output", split = FALSE)
[16:19:41.503]         if (TRUE) {
[16:19:41.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:41.503]         }
[16:19:41.503]         else {
[16:19:41.503]             ...future.result["stdout"] <- base::list(NULL)
[16:19:41.503]         }
[16:19:41.503]         base::close(...future.stdout)
[16:19:41.503]         ...future.stdout <- NULL
[16:19:41.503]     }
[16:19:41.503]     ...future.result$conditions <- ...future.conditions
[16:19:41.503]     ...future.result$finished <- base::Sys.time()
[16:19:41.503]     ...future.result
[16:19:41.503] }
[16:19:41.506] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[16:19:41.506] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[16:19:41.507] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[16:19:41.507] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:19:41.507] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:19:41.507] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:19:41.508] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:19:41.508] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:41.508] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:41.508] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:41.509] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:41.509] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[16:19:41.509] MultisessionFuture started
[16:19:41.510] - Launch lazy future ... done
[16:19:41.510] run() for ‘MultisessionFuture’ ... done
[16:19:41.510] Created future:
[16:19:41.510] MultisessionFuture:
[16:19:41.510] Label: ‘future_lapply-2’
[16:19:41.510] Expression:
[16:19:41.510] {
[16:19:41.510]     do.call(function(...) {
[16:19:41.510]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:41.510]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:41.510]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:41.510]             on.exit(options(oopts), add = TRUE)
[16:19:41.510]         }
[16:19:41.510]         {
[16:19:41.510]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:41.510]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:41.510]                 ...future.FUN(...future.X_jj, ...)
[16:19:41.510]             })
[16:19:41.510]         }
[16:19:41.510]     }, args = future.call.arguments)
[16:19:41.510] }
[16:19:41.510] Lazy evaluation: FALSE
[16:19:41.510] Asynchronous evaluation: TRUE
[16:19:41.510] Local evaluation: TRUE
[16:19:41.510] Environment: R_GlobalEnv
[16:19:41.510] Capture standard output: TRUE
[16:19:41.510] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:41.510] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:41.510] Packages: <none>
[16:19:41.510] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:41.510] Resolved: FALSE
[16:19:41.510] Value: <not collected>
[16:19:41.510] Conditions captured: <none>
[16:19:41.510] Early signaling: FALSE
[16:19:41.510] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:41.510] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:41.522] Chunk #2 of 2 ... DONE
[16:19:41.522] Launching 2 futures (chunks) ... DONE
[16:19:41.522] Resolving 2 futures (chunks) ...
[16:19:41.522] resolve() on list ...
[16:19:41.522]  recursive: 0
[16:19:41.522]  length: 2
[16:19:41.522] 
[16:19:41.564] receiveMessageFromWorker() for ClusterFuture ...
[16:19:41.565] - Validating connection of MultisessionFuture
[16:19:41.565] - received message: FutureResult
[16:19:41.565] - Received FutureResult
[16:19:41.565] - Erased future from FutureRegistry
[16:19:41.565] result() for ClusterFuture ...
[16:19:41.565] - result already collected: FutureResult
[16:19:41.565] result() for ClusterFuture ... done
[16:19:41.565] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:41.565] Future #2
[16:19:41.566] result() for ClusterFuture ...
[16:19:41.566] - result already collected: FutureResult
[16:19:41.566] result() for ClusterFuture ... done
[16:19:41.566] result() for ClusterFuture ...
[16:19:41.566] - result already collected: FutureResult
[16:19:41.566] result() for ClusterFuture ... done
[16:19:41.566] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:41.566] - nx: 2
[16:19:41.566] - relay: TRUE
[16:19:41.566] - stdout: TRUE
[16:19:41.566] - signal: TRUE
[16:19:41.566] - resignal: FALSE
[16:19:41.567] - force: TRUE
[16:19:41.567] - relayed: [n=2] FALSE, FALSE
[16:19:41.567] - queued futures: [n=2] FALSE, FALSE
[16:19:41.567]  - until=1
[16:19:41.567]  - relaying element #1
[16:19:41.567] - relayed: [n=2] FALSE, FALSE
[16:19:41.567] - queued futures: [n=2] FALSE, TRUE
[16:19:41.567] signalConditionsASAP(NULL, pos=2) ... done
[16:19:41.567]  length: 1 (resolved future 2)
[16:19:42.019] receiveMessageFromWorker() for ClusterFuture ...
[16:19:42.019] - Validating connection of MultisessionFuture
[16:19:42.020] - received message: FutureResult
[16:19:42.020] - Received FutureResult
[16:19:42.020] - Erased future from FutureRegistry
[16:19:42.020] result() for ClusterFuture ...
[16:19:42.020] - result already collected: FutureResult
[16:19:42.020] result() for ClusterFuture ... done
[16:19:42.020] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:42.020] Future #1
[16:19:42.021] result() for ClusterFuture ...
[16:19:42.021] - result already collected: FutureResult
[16:19:42.021] result() for ClusterFuture ... done
[16:19:42.021] result() for ClusterFuture ...
[16:19:42.021] - result already collected: FutureResult
[16:19:42.021] result() for ClusterFuture ... done
[16:19:42.021] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:42.021] - nx: 2
[16:19:42.021] - relay: TRUE
[16:19:42.021] - stdout: TRUE
[16:19:42.021] - signal: TRUE
[16:19:42.022] - resignal: FALSE
[16:19:42.022] - force: TRUE
[16:19:42.022] - relayed: [n=2] FALSE, FALSE
[16:19:42.022] - queued futures: [n=2] FALSE, TRUE
[16:19:42.022]  - until=1
[16:19:42.022]  - relaying element #1
[16:19:42.022] result() for ClusterFuture ...
[16:19:42.022] - result already collected: FutureResult
[16:19:42.022] result() for ClusterFuture ... done
[16:19:42.022] result() for ClusterFuture ...
[16:19:42.022] - result already collected: FutureResult
[16:19:42.022] result() for ClusterFuture ... done
[16:19:42.023] result() for ClusterFuture ...
[16:19:42.023] - result already collected: FutureResult
[16:19:42.023] result() for ClusterFuture ... done
[16:19:42.023] result() for ClusterFuture ...
[16:19:42.023] - result already collected: FutureResult
[16:19:42.023] result() for ClusterFuture ... done
[16:19:42.023] - relayed: [n=2] TRUE, FALSE
[16:19:42.023] - queued futures: [n=2] TRUE, TRUE
[16:19:42.023] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:42.023]  length: 0 (resolved future 1)
[16:19:42.023] Relaying remaining futures
[16:19:42.024] signalConditionsASAP(NULL, pos=0) ...
[16:19:42.024] - nx: 2
[16:19:42.024] - relay: TRUE
[16:19:42.026] - stdout: TRUE
[16:19:42.026] - signal: TRUE
[16:19:42.026] - resignal: FALSE
[16:19:42.026] - force: TRUE
[16:19:42.026] - relayed: [n=2] TRUE, FALSE
[16:19:42.026] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:42.026]  - relaying element #2
[16:19:42.026] result() for ClusterFuture ...
[16:19:42.027] - result already collected: FutureResult
[16:19:42.027] result() for ClusterFuture ... done
[16:19:42.027] result() for ClusterFuture ...
[16:19:42.027] - result already collected: FutureResult
[16:19:42.027] result() for ClusterFuture ... done
[16:19:42.027] result() for ClusterFuture ...
[16:19:42.027] - result already collected: FutureResult
[16:19:42.027] result() for ClusterFuture ... done
[16:19:42.027] result() for ClusterFuture ...
[16:19:42.027] - result already collected: FutureResult
[16:19:42.027] result() for ClusterFuture ... done
[16:19:42.027] - relayed: [n=2] TRUE, TRUE
[16:19:42.028] - queued futures: [n=2] TRUE, TRUE
[16:19:42.028] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:19:42.028] resolve() on list ... DONE
[16:19:42.028] result() for ClusterFuture ...
[16:19:42.028] - result already collected: FutureResult
[16:19:42.028] result() for ClusterFuture ... done
[16:19:42.028] result() for ClusterFuture ...
[16:19:42.028] - result already collected: FutureResult
[16:19:42.028] result() for ClusterFuture ... done
[16:19:42.028] result() for ClusterFuture ...
[16:19:42.028] - result already collected: FutureResult
[16:19:42.029] result() for ClusterFuture ... done
[16:19:42.029] result() for ClusterFuture ...
[16:19:42.029] - result already collected: FutureResult
[16:19:42.029] result() for ClusterFuture ... done
[16:19:42.029]  - Number of value chunks collected: 2
[16:19:42.029] Resolving 2 futures (chunks) ... DONE
[16:19:42.029] Reducing values from 2 chunks ...
[16:19:42.029]  - Number of values collected after concatenation: 2
[16:19:42.029]  - Number of values expected: 2
[16:19:42.029] Reducing values from 2 chunks ... DONE
[16:19:42.029] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = TRUE) ... DONE
* future_lapply(x, ..., future.stdout = NA) ...
[16:19:42.030] future_lapply() ...
[16:19:42.034] Number of chunks: 2
[16:19:42.035] getGlobalsAndPackagesXApply() ...
[16:19:42.035]  - future.globals: TRUE
[16:19:42.035] getGlobalsAndPackages() ...
[16:19:42.035] Searching for globals...
[16:19:42.036] - globals found: [5] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’
[16:19:42.037] Searching for globals ... DONE
[16:19:42.037] Resolving globals: FALSE
[16:19:42.037] The total size of the 1 globals is 4.61 KiB (4720 bytes)
[16:19:42.037] The total size of the 1 globals exported for future expression (‘FUN()’) is 4.61 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.61 KiB of class ‘function’)
[16:19:42.038] - globals: [1] ‘FUN’
[16:19:42.038] 
[16:19:42.038] getGlobalsAndPackages() ... DONE
[16:19:42.038]  - globals found/used: [n=1] ‘FUN’
[16:19:42.038]  - needed namespaces: [n=0] 
[16:19:42.038] Finding globals ... DONE
[16:19:42.038]  - use_args: TRUE
[16:19:42.038]  - Getting '...' globals ...
[16:19:42.039] resolve() on list ...
[16:19:42.039]  recursive: 0
[16:19:42.039]  length: 1
[16:19:42.039]  elements: ‘...’
[16:19:42.039]  length: 0 (resolved future 1)
[16:19:42.039] resolve() on list ... DONE
[16:19:42.039]    - '...' content: [n=0] 
[16:19:42.039] List of 1
[16:19:42.039]  $ ...: list()
[16:19:42.039]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:42.039]  - attr(*, "where")=List of 1
[16:19:42.039]   ..$ ...:<environment: 0x563562f74600> 
[16:19:42.039]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:42.039]  - attr(*, "resolved")= logi TRUE
[16:19:42.039]  - attr(*, "total_size")= num NA
[16:19:42.042]  - Getting '...' globals ... DONE
[16:19:42.042] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[16:19:42.042] List of 2
[16:19:42.042]  $ ...future.FUN:function (x)  
[16:19:42.042]  $ ...          : list()
[16:19:42.042]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[16:19:42.042]  - attr(*, "where")=List of 2
[16:19:42.042]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:42.042]   ..$ ...          :<environment: 0x563562f74600> 
[16:19:42.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:42.042]  - attr(*, "resolved")= logi FALSE
[16:19:42.042]  - attr(*, "total_size")= num 4720
[16:19:42.045] Packages to be attached in all futures: [n=0] 
[16:19:42.045] getGlobalsAndPackagesXApply() ... DONE
[16:19:42.045] Number of futures (= number of chunks): 2
[16:19:42.045] Launching 2 futures (chunks) ...
[16:19:42.045] Chunk #1 of 2 ...
[16:19:42.045]  - Finding globals in 'X' for chunk #1 ...
[16:19:42.045] getGlobalsAndPackages() ...
[16:19:42.045] Searching for globals...
[16:19:42.046] 
[16:19:42.046] Searching for globals ... DONE
[16:19:42.046] - globals: [0] <none>
[16:19:42.046] getGlobalsAndPackages() ... DONE
[16:19:42.046]    + additional globals found: [n=0] 
[16:19:42.046]    + additional namespaces needed: [n=0] 
[16:19:42.046]  - Finding globals in 'X' for chunk #1 ... DONE
[16:19:42.046]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:42.046]  - seeds: <none>
[16:19:42.046]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:42.047] getGlobalsAndPackages() ...
[16:19:42.047] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:42.047] Resolving globals: FALSE
[16:19:42.047] Tweak future expression to call with '...' arguments ...
[16:19:42.047] {
[16:19:42.047]     do.call(function(...) {
[16:19:42.047]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:42.047]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:42.047]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:42.047]             on.exit(options(oopts), add = TRUE)
[16:19:42.047]         }
[16:19:42.047]         {
[16:19:42.047]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:42.047]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:42.047]                 ...future.FUN(...future.X_jj, ...)
[16:19:42.047]             })
[16:19:42.047]         }
[16:19:42.047]     }, args = future.call.arguments)
[16:19:42.047] }
[16:19:42.047] Tweak future expression to call with '...' arguments ... DONE
[16:19:42.048] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:42.048] 
[16:19:42.048] getGlobalsAndPackages() ... DONE
[16:19:42.048] run() for ‘Future’ ...
[16:19:42.048] - state: ‘created’
[16:19:42.048] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:42.063] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:42.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:42.063]   - Field: ‘node’
[16:19:42.063]   - Field: ‘label’
[16:19:42.063]   - Field: ‘local’
[16:19:42.063]   - Field: ‘owner’
[16:19:42.063]   - Field: ‘envir’
[16:19:42.063]   - Field: ‘workers’
[16:19:42.064]   - Field: ‘packages’
[16:19:42.064]   - Field: ‘gc’
[16:19:42.064]   - Field: ‘conditions’
[16:19:42.064]   - Field: ‘persistent’
[16:19:42.064]   - Field: ‘expr’
[16:19:42.064]   - Field: ‘uuid’
[16:19:42.064]   - Field: ‘seed’
[16:19:42.064]   - Field: ‘version’
[16:19:42.064]   - Field: ‘result’
[16:19:42.064]   - Field: ‘asynchronous’
[16:19:42.065]   - Field: ‘calls’
[16:19:42.065]   - Field: ‘globals’
[16:19:42.065]   - Field: ‘stdout’
[16:19:42.065]   - Field: ‘earlySignal’
[16:19:42.065]   - Field: ‘lazy’
[16:19:42.065]   - Field: ‘state’
[16:19:42.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:42.065] - Launch lazy future ...
[16:19:42.065] Packages needed by the future expression (n = 0): <none>
[16:19:42.066] Packages needed by future strategies (n = 0): <none>
[16:19:42.066] {
[16:19:42.066]     {
[16:19:42.066]         {
[16:19:42.066]             ...future.startTime <- base::Sys.time()
[16:19:42.066]             {
[16:19:42.066]                 {
[16:19:42.066]                   {
[16:19:42.066]                     {
[16:19:42.066]                       base::local({
[16:19:42.066]                         has_future <- base::requireNamespace("future", 
[16:19:42.066]                           quietly = TRUE)
[16:19:42.066]                         if (has_future) {
[16:19:42.066]                           ns <- base::getNamespace("future")
[16:19:42.066]                           version <- ns[[".package"]][["version"]]
[16:19:42.066]                           if (is.null(version)) 
[16:19:42.066]                             version <- utils::packageVersion("future")
[16:19:42.066]                         }
[16:19:42.066]                         else {
[16:19:42.066]                           version <- NULL
[16:19:42.066]                         }
[16:19:42.066]                         if (!has_future || version < "1.8.0") {
[16:19:42.066]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:42.066]                             "", base::R.version$version.string), 
[16:19:42.066]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:42.066]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:42.066]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:42.066]                               "release", "version")], collapse = " "), 
[16:19:42.066]                             hostname = base::Sys.info()[["nodename"]])
[16:19:42.066]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:42.066]                             info)
[16:19:42.066]                           info <- base::paste(info, collapse = "; ")
[16:19:42.066]                           if (!has_future) {
[16:19:42.066]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:42.066]                               info)
[16:19:42.066]                           }
[16:19:42.066]                           else {
[16:19:42.066]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:42.066]                               info, version)
[16:19:42.066]                           }
[16:19:42.066]                           base::stop(msg)
[16:19:42.066]                         }
[16:19:42.066]                       })
[16:19:42.066]                     }
[16:19:42.066]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:42.066]                     base::options(mc.cores = 1L)
[16:19:42.066]                   }
[16:19:42.066]                   ...future.strategy.old <- future::plan("list")
[16:19:42.066]                   options(future.plan = NULL)
[16:19:42.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:42.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:42.066]                 }
[16:19:42.066]                 ...future.workdir <- getwd()
[16:19:42.066]             }
[16:19:42.066]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:42.066]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:42.066]         }
[16:19:42.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:42.066]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:42.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:42.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:42.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:42.066]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:42.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:42.066]             base::names(...future.oldOptions))
[16:19:42.066]     }
[16:19:42.066]     if (TRUE) {
[16:19:42.066]     }
[16:19:42.066]     else {
[16:19:42.066]         if (NA) {
[16:19:42.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:42.066]                 open = "w")
[16:19:42.066]         }
[16:19:42.066]         else {
[16:19:42.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:42.066]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:42.066]         }
[16:19:42.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:42.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:42.066]             base::sink(type = "output", split = FALSE)
[16:19:42.066]             base::close(...future.stdout)
[16:19:42.066]         }, add = TRUE)
[16:19:42.066]     }
[16:19:42.066]     ...future.frame <- base::sys.nframe()
[16:19:42.066]     ...future.conditions <- base::list()
[16:19:42.066]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:42.066]     if (FALSE) {
[16:19:42.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:42.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:42.066]     }
[16:19:42.066]     ...future.result <- base::tryCatch({
[16:19:42.066]         base::withCallingHandlers({
[16:19:42.066]             ...future.value <- base::withVisible(base::local({
[16:19:42.066]                 ...future.makeSendCondition <- base::local({
[16:19:42.066]                   sendCondition <- NULL
[16:19:42.066]                   function(frame = 1L) {
[16:19:42.066]                     if (is.function(sendCondition)) 
[16:19:42.066]                       return(sendCondition)
[16:19:42.066]                     ns <- getNamespace("parallel")
[16:19:42.066]                     if (exists("sendData", mode = "function", 
[16:19:42.066]                       envir = ns)) {
[16:19:42.066]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:42.066]                         envir = ns)
[16:19:42.066]                       envir <- sys.frame(frame)
[16:19:42.066]                       master <- NULL
[16:19:42.066]                       while (!identical(envir, .GlobalEnv) && 
[16:19:42.066]                         !identical(envir, emptyenv())) {
[16:19:42.066]                         if (exists("master", mode = "list", envir = envir, 
[16:19:42.066]                           inherits = FALSE)) {
[16:19:42.066]                           master <- get("master", mode = "list", 
[16:19:42.066]                             envir = envir, inherits = FALSE)
[16:19:42.066]                           if (inherits(master, c("SOCKnode", 
[16:19:42.066]                             "SOCK0node"))) {
[16:19:42.066]                             sendCondition <<- function(cond) {
[16:19:42.066]                               data <- list(type = "VALUE", value = cond, 
[16:19:42.066]                                 success = TRUE)
[16:19:42.066]                               parallel_sendData(master, data)
[16:19:42.066]                             }
[16:19:42.066]                             return(sendCondition)
[16:19:42.066]                           }
[16:19:42.066]                         }
[16:19:42.066]                         frame <- frame + 1L
[16:19:42.066]                         envir <- sys.frame(frame)
[16:19:42.066]                       }
[16:19:42.066]                     }
[16:19:42.066]                     sendCondition <<- function(cond) NULL
[16:19:42.066]                   }
[16:19:42.066]                 })
[16:19:42.066]                 withCallingHandlers({
[16:19:42.066]                   {
[16:19:42.066]                     do.call(function(...) {
[16:19:42.066]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:42.066]                       if (!identical(...future.globals.maxSize.org, 
[16:19:42.066]                         ...future.globals.maxSize)) {
[16:19:42.066]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:42.066]                         on.exit(options(oopts), add = TRUE)
[16:19:42.066]                       }
[16:19:42.066]                       {
[16:19:42.066]                         lapply(seq_along(...future.elements_ii), 
[16:19:42.066]                           FUN = function(jj) {
[16:19:42.066]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:42.066]                             ...future.FUN(...future.X_jj, ...)
[16:19:42.066]                           })
[16:19:42.066]                       }
[16:19:42.066]                     }, args = future.call.arguments)
[16:19:42.066]                   }
[16:19:42.066]                 }, immediateCondition = function(cond) {
[16:19:42.066]                   sendCondition <- ...future.makeSendCondition()
[16:19:42.066]                   sendCondition(cond)
[16:19:42.066]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:42.066]                   {
[16:19:42.066]                     inherits <- base::inherits
[16:19:42.066]                     invokeRestart <- base::invokeRestart
[16:19:42.066]                     is.null <- base::is.null
[16:19:42.066]                     muffled <- FALSE
[16:19:42.066]                     if (inherits(cond, "message")) {
[16:19:42.066]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:42.066]                       if (muffled) 
[16:19:42.066]                         invokeRestart("muffleMessage")
[16:19:42.066]                     }
[16:19:42.066]                     else if (inherits(cond, "warning")) {
[16:19:42.066]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:42.066]                       if (muffled) 
[16:19:42.066]                         invokeRestart("muffleWarning")
[16:19:42.066]                     }
[16:19:42.066]                     else if (inherits(cond, "condition")) {
[16:19:42.066]                       if (!is.null(pattern)) {
[16:19:42.066]                         computeRestarts <- base::computeRestarts
[16:19:42.066]                         grepl <- base::grepl
[16:19:42.066]                         restarts <- computeRestarts(cond)
[16:19:42.066]                         for (restart in restarts) {
[16:19:42.066]                           name <- restart$name
[16:19:42.066]                           if (is.null(name)) 
[16:19:42.066]                             next
[16:19:42.066]                           if (!grepl(pattern, name)) 
[16:19:42.066]                             next
[16:19:42.066]                           invokeRestart(restart)
[16:19:42.066]                           muffled <- TRUE
[16:19:42.066]                           break
[16:19:42.066]                         }
[16:19:42.066]                       }
[16:19:42.066]                     }
[16:19:42.066]                     invisible(muffled)
[16:19:42.066]                   }
[16:19:42.066]                   muffleCondition(cond)
[16:19:42.066]                 })
[16:19:42.066]             }))
[16:19:42.066]             future::FutureResult(value = ...future.value$value, 
[16:19:42.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:42.066]                   ...future.rng), globalenv = if (FALSE) 
[16:19:42.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:42.066]                     ...future.globalenv.names))
[16:19:42.066]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:42.066]         }, condition = base::local({
[16:19:42.066]             c <- base::c
[16:19:42.066]             inherits <- base::inherits
[16:19:42.066]             invokeRestart <- base::invokeRestart
[16:19:42.066]             length <- base::length
[16:19:42.066]             list <- base::list
[16:19:42.066]             seq.int <- base::seq.int
[16:19:42.066]             signalCondition <- base::signalCondition
[16:19:42.066]             sys.calls <- base::sys.calls
[16:19:42.066]             `[[` <- base::`[[`
[16:19:42.066]             `+` <- base::`+`
[16:19:42.066]             `<<-` <- base::`<<-`
[16:19:42.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:42.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:42.066]                   3L)]
[16:19:42.066]             }
[16:19:42.066]             function(cond) {
[16:19:42.066]                 is_error <- inherits(cond, "error")
[16:19:42.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:42.066]                   NULL)
[16:19:42.066]                 if (is_error) {
[16:19:42.066]                   sessionInformation <- function() {
[16:19:42.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:42.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:42.066]                       search = base::search(), system = base::Sys.info())
[16:19:42.066]                   }
[16:19:42.066]                   ...future.conditions[[length(...future.conditions) + 
[16:19:42.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:42.066]                     cond$call), session = sessionInformation(), 
[16:19:42.066]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:42.066]                   signalCondition(cond)
[16:19:42.066]                 }
[16:19:42.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:42.066]                 "immediateCondition"))) {
[16:19:42.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:42.066]                   ...future.conditions[[length(...future.conditions) + 
[16:19:42.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:42.066]                   if (TRUE && !signal) {
[16:19:42.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:42.066]                     {
[16:19:42.066]                       inherits <- base::inherits
[16:19:42.066]                       invokeRestart <- base::invokeRestart
[16:19:42.066]                       is.null <- base::is.null
[16:19:42.066]                       muffled <- FALSE
[16:19:42.066]                       if (inherits(cond, "message")) {
[16:19:42.066]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:42.066]                         if (muffled) 
[16:19:42.066]                           invokeRestart("muffleMessage")
[16:19:42.066]                       }
[16:19:42.066]                       else if (inherits(cond, "warning")) {
[16:19:42.066]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:42.066]                         if (muffled) 
[16:19:42.066]                           invokeRestart("muffleWarning")
[16:19:42.066]                       }
[16:19:42.066]                       else if (inherits(cond, "condition")) {
[16:19:42.066]                         if (!is.null(pattern)) {
[16:19:42.066]                           computeRestarts <- base::computeRestarts
[16:19:42.066]                           grepl <- base::grepl
[16:19:42.066]                           restarts <- computeRestarts(cond)
[16:19:42.066]                           for (restart in restarts) {
[16:19:42.066]                             name <- restart$name
[16:19:42.066]                             if (is.null(name)) 
[16:19:42.066]                               next
[16:19:42.066]                             if (!grepl(pattern, name)) 
[16:19:42.066]                               next
[16:19:42.066]                             invokeRestart(restart)
[16:19:42.066]                             muffled <- TRUE
[16:19:42.066]                             break
[16:19:42.066]                           }
[16:19:42.066]                         }
[16:19:42.066]                       }
[16:19:42.066]                       invisible(muffled)
[16:19:42.066]                     }
[16:19:42.066]                     muffleCondition(cond, pattern = "^muffle")
[16:19:42.066]                   }
[16:19:42.066]                 }
[16:19:42.066]                 else {
[16:19:42.066]                   if (TRUE) {
[16:19:42.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:42.066]                     {
[16:19:42.066]                       inherits <- base::inherits
[16:19:42.066]                       invokeRestart <- base::invokeRestart
[16:19:42.066]                       is.null <- base::is.null
[16:19:42.066]                       muffled <- FALSE
[16:19:42.066]                       if (inherits(cond, "message")) {
[16:19:42.066]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:42.066]                         if (muffled) 
[16:19:42.066]                           invokeRestart("muffleMessage")
[16:19:42.066]                       }
[16:19:42.066]                       else if (inherits(cond, "warning")) {
[16:19:42.066]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:42.066]                         if (muffled) 
[16:19:42.066]                           invokeRestart("muffleWarning")
[16:19:42.066]                       }
[16:19:42.066]                       else if (inherits(cond, "condition")) {
[16:19:42.066]                         if (!is.null(pattern)) {
[16:19:42.066]                           computeRestarts <- base::computeRestarts
[16:19:42.066]                           grepl <- base::grepl
[16:19:42.066]                           restarts <- computeRestarts(cond)
[16:19:42.066]                           for (restart in restarts) {
[16:19:42.066]                             name <- restart$name
[16:19:42.066]                             if (is.null(name)) 
[16:19:42.066]                               next
[16:19:42.066]                             if (!grepl(pattern, name)) 
[16:19:42.066]                               next
[16:19:42.066]                             invokeRestart(restart)
[16:19:42.066]                             muffled <- TRUE
[16:19:42.066]                             break
[16:19:42.066]                           }
[16:19:42.066]                         }
[16:19:42.066]                       }
[16:19:42.066]                       invisible(muffled)
[16:19:42.066]                     }
[16:19:42.066]                     muffleCondition(cond, pattern = "^muffle")
[16:19:42.066]                   }
[16:19:42.066]                 }
[16:19:42.066]             }
[16:19:42.066]         }))
[16:19:42.066]     }, error = function(ex) {
[16:19:42.066]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:42.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:42.066]                 ...future.rng), started = ...future.startTime, 
[16:19:42.066]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:42.066]             version = "1.8"), class = "FutureResult")
[16:19:42.066]     }, finally = {
[16:19:42.066]         if (!identical(...future.workdir, getwd())) 
[16:19:42.066]             setwd(...future.workdir)
[16:19:42.066]         {
[16:19:42.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:42.066]                 ...future.oldOptions$nwarnings <- NULL
[16:19:42.066]             }
[16:19:42.066]             base::options(...future.oldOptions)
[16:19:42.066]             if (.Platform$OS.type == "windows") {
[16:19:42.066]                 old_names <- names(...future.oldEnvVars)
[16:19:42.066]                 envs <- base::Sys.getenv()
[16:19:42.066]                 names <- names(envs)
[16:19:42.066]                 common <- intersect(names, old_names)
[16:19:42.066]                 added <- setdiff(names, old_names)
[16:19:42.066]                 removed <- setdiff(old_names, names)
[16:19:42.066]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:42.066]                   envs[common]]
[16:19:42.066]                 NAMES <- toupper(changed)
[16:19:42.066]                 args <- list()
[16:19:42.066]                 for (kk in seq_along(NAMES)) {
[16:19:42.066]                   name <- changed[[kk]]
[16:19:42.066]                   NAME <- NAMES[[kk]]
[16:19:42.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:42.066]                     next
[16:19:42.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:42.066]                 }
[16:19:42.066]                 NAMES <- toupper(added)
[16:19:42.066]                 for (kk in seq_along(NAMES)) {
[16:19:42.066]                   name <- added[[kk]]
[16:19:42.066]                   NAME <- NAMES[[kk]]
[16:19:42.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:42.066]                     next
[16:19:42.066]                   args[[name]] <- ""
[16:19:42.066]                 }
[16:19:42.066]                 NAMES <- toupper(removed)
[16:19:42.066]                 for (kk in seq_along(NAMES)) {
[16:19:42.066]                   name <- removed[[kk]]
[16:19:42.066]                   NAME <- NAMES[[kk]]
[16:19:42.066]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:42.066]                     next
[16:19:42.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:42.066]                 }
[16:19:42.066]                 if (length(args) > 0) 
[16:19:42.066]                   base::do.call(base::Sys.setenv, args = args)
[16:19:42.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:42.066]             }
[16:19:42.066]             else {
[16:19:42.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:42.066]             }
[16:19:42.066]             {
[16:19:42.066]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:42.066]                   0L) {
[16:19:42.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:42.066]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:42.066]                   base::options(opts)
[16:19:42.066]                 }
[16:19:42.066]                 {
[16:19:42.066]                   {
[16:19:42.066]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:42.066]                     NULL
[16:19:42.066]                   }
[16:19:42.066]                   options(future.plan = NULL)
[16:19:42.066]                   if (is.na(NA_character_)) 
[16:19:42.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:42.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:42.066]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:42.066]                     .init = FALSE)
[16:19:42.066]                 }
[16:19:42.066]             }
[16:19:42.066]         }
[16:19:42.066]     })
[16:19:42.066]     if (FALSE) {
[16:19:42.066]         base::sink(type = "output", split = FALSE)
[16:19:42.066]         if (NA) {
[16:19:42.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:42.066]         }
[16:19:42.066]         else {
[16:19:42.066]             ...future.result["stdout"] <- base::list(NULL)
[16:19:42.066]         }
[16:19:42.066]         base::close(...future.stdout)
[16:19:42.066]         ...future.stdout <- NULL
[16:19:42.066]     }
[16:19:42.066]     ...future.result$conditions <- ...future.conditions
[16:19:42.066]     ...future.result$finished <- base::Sys.time()
[16:19:42.066]     ...future.result
[16:19:42.066] }
[16:19:42.069] Exporting 5 global objects (4.61 KiB) to cluster node #1 ...
[16:19:42.069] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ...
[16:19:42.069] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #1 ... DONE
[16:19:42.069] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[16:19:42.070] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[16:19:42.070] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[16:19:42.070] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[16:19:42.070] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:42.071] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:42.071] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:42.071] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:42.071] Exporting 5 global objects (4.61 KiB) to cluster node #1 ... DONE
[16:19:42.071] MultisessionFuture started
[16:19:42.072] - Launch lazy future ... done
[16:19:42.072] run() for ‘MultisessionFuture’ ... done
[16:19:42.072] Created future:
[16:19:42.072] MultisessionFuture:
[16:19:42.072] Label: ‘future_lapply-1’
[16:19:42.072] Expression:
[16:19:42.072] {
[16:19:42.072]     do.call(function(...) {
[16:19:42.072]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:42.072]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:42.072]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:42.072]             on.exit(options(oopts), add = TRUE)
[16:19:42.072]         }
[16:19:42.072]         {
[16:19:42.072]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:42.072]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:42.072]                 ...future.FUN(...future.X_jj, ...)
[16:19:42.072]             })
[16:19:42.072]         }
[16:19:42.072]     }, args = future.call.arguments)
[16:19:42.072] }
[16:19:42.072] Lazy evaluation: FALSE
[16:19:42.072] Asynchronous evaluation: TRUE
[16:19:42.072] Local evaluation: TRUE
[16:19:42.072] Environment: R_GlobalEnv
[16:19:42.072] Capture standard output: NA
[16:19:42.072] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:42.072] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:42.072] Packages: <none>
[16:19:42.072] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:42.072] Resolved: FALSE
[16:19:42.072] Value: <not collected>
[16:19:42.072] Conditions captured: <none>
[16:19:42.072] Early signaling: FALSE
[16:19:42.072] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:42.072] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:42.083] Chunk #1 of 2 ... DONE
[16:19:42.084] Chunk #2 of 2 ...
[16:19:42.084]  - Finding globals in 'X' for chunk #2 ...
[16:19:42.084] getGlobalsAndPackages() ...
[16:19:42.084] Searching for globals...
[16:19:42.084] 
[16:19:42.084] Searching for globals ... DONE
[16:19:42.084] - globals: [0] <none>
[16:19:42.085] getGlobalsAndPackages() ... DONE
[16:19:42.085]    + additional globals found: [n=0] 
[16:19:42.085]    + additional namespaces needed: [n=0] 
[16:19:42.085]  - Finding globals in 'X' for chunk #2 ... DONE
[16:19:42.085]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:42.085]  - seeds: <none>
[16:19:42.085]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:42.085] getGlobalsAndPackages() ...
[16:19:42.085] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:42.085] Resolving globals: FALSE
[16:19:42.085] Tweak future expression to call with '...' arguments ...
[16:19:42.086] {
[16:19:42.086]     do.call(function(...) {
[16:19:42.086]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:42.086]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:42.086]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:42.086]             on.exit(options(oopts), add = TRUE)
[16:19:42.086]         }
[16:19:42.086]         {
[16:19:42.086]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:42.086]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:42.086]                 ...future.FUN(...future.X_jj, ...)
[16:19:42.086]             })
[16:19:42.086]         }
[16:19:42.086]     }, args = future.call.arguments)
[16:19:42.086] }
[16:19:42.086] Tweak future expression to call with '...' arguments ... DONE
[16:19:42.086] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:42.086] 
[16:19:42.086] getGlobalsAndPackages() ... DONE
[16:19:42.087] run() for ‘Future’ ...
[16:19:42.087] - state: ‘created’
[16:19:42.087] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:42.100] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:42.100] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:42.100]   - Field: ‘node’
[16:19:42.101]   - Field: ‘label’
[16:19:42.101]   - Field: ‘local’
[16:19:42.101]   - Field: ‘owner’
[16:19:42.101]   - Field: ‘envir’
[16:19:42.101]   - Field: ‘workers’
[16:19:42.101]   - Field: ‘packages’
[16:19:42.101]   - Field: ‘gc’
[16:19:42.101]   - Field: ‘conditions’
[16:19:42.101]   - Field: ‘persistent’
[16:19:42.101]   - Field: ‘expr’
[16:19:42.102]   - Field: ‘uuid’
[16:19:42.102]   - Field: ‘seed’
[16:19:42.102]   - Field: ‘version’
[16:19:42.102]   - Field: ‘result’
[16:19:42.102]   - Field: ‘asynchronous’
[16:19:42.102]   - Field: ‘calls’
[16:19:42.102]   - Field: ‘globals’
[16:19:42.102]   - Field: ‘stdout’
[16:19:42.102]   - Field: ‘earlySignal’
[16:19:42.102]   - Field: ‘lazy’
[16:19:42.102]   - Field: ‘state’
[16:19:42.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:42.103] - Launch lazy future ...
[16:19:42.103] Packages needed by the future expression (n = 0): <none>
[16:19:42.103] Packages needed by future strategies (n = 0): <none>
[16:19:42.103] {
[16:19:42.103]     {
[16:19:42.103]         {
[16:19:42.103]             ...future.startTime <- base::Sys.time()
[16:19:42.103]             {
[16:19:42.103]                 {
[16:19:42.103]                   {
[16:19:42.103]                     {
[16:19:42.103]                       base::local({
[16:19:42.103]                         has_future <- base::requireNamespace("future", 
[16:19:42.103]                           quietly = TRUE)
[16:19:42.103]                         if (has_future) {
[16:19:42.103]                           ns <- base::getNamespace("future")
[16:19:42.103]                           version <- ns[[".package"]][["version"]]
[16:19:42.103]                           if (is.null(version)) 
[16:19:42.103]                             version <- utils::packageVersion("future")
[16:19:42.103]                         }
[16:19:42.103]                         else {
[16:19:42.103]                           version <- NULL
[16:19:42.103]                         }
[16:19:42.103]                         if (!has_future || version < "1.8.0") {
[16:19:42.103]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:42.103]                             "", base::R.version$version.string), 
[16:19:42.103]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:42.103]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:42.103]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:42.103]                               "release", "version")], collapse = " "), 
[16:19:42.103]                             hostname = base::Sys.info()[["nodename"]])
[16:19:42.103]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:42.103]                             info)
[16:19:42.103]                           info <- base::paste(info, collapse = "; ")
[16:19:42.103]                           if (!has_future) {
[16:19:42.103]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:42.103]                               info)
[16:19:42.103]                           }
[16:19:42.103]                           else {
[16:19:42.103]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:42.103]                               info, version)
[16:19:42.103]                           }
[16:19:42.103]                           base::stop(msg)
[16:19:42.103]                         }
[16:19:42.103]                       })
[16:19:42.103]                     }
[16:19:42.103]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:42.103]                     base::options(mc.cores = 1L)
[16:19:42.103]                   }
[16:19:42.103]                   ...future.strategy.old <- future::plan("list")
[16:19:42.103]                   options(future.plan = NULL)
[16:19:42.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:42.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:42.103]                 }
[16:19:42.103]                 ...future.workdir <- getwd()
[16:19:42.103]             }
[16:19:42.103]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:42.103]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:42.103]         }
[16:19:42.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:42.103]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:42.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:42.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:42.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:42.103]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:42.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:42.103]             base::names(...future.oldOptions))
[16:19:42.103]     }
[16:19:42.103]     if (TRUE) {
[16:19:42.103]     }
[16:19:42.103]     else {
[16:19:42.103]         if (NA) {
[16:19:42.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:42.103]                 open = "w")
[16:19:42.103]         }
[16:19:42.103]         else {
[16:19:42.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:42.103]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:42.103]         }
[16:19:42.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:42.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:42.103]             base::sink(type = "output", split = FALSE)
[16:19:42.103]             base::close(...future.stdout)
[16:19:42.103]         }, add = TRUE)
[16:19:42.103]     }
[16:19:42.103]     ...future.frame <- base::sys.nframe()
[16:19:42.103]     ...future.conditions <- base::list()
[16:19:42.103]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:42.103]     if (FALSE) {
[16:19:42.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:42.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:42.103]     }
[16:19:42.103]     ...future.result <- base::tryCatch({
[16:19:42.103]         base::withCallingHandlers({
[16:19:42.103]             ...future.value <- base::withVisible(base::local({
[16:19:42.103]                 ...future.makeSendCondition <- base::local({
[16:19:42.103]                   sendCondition <- NULL
[16:19:42.103]                   function(frame = 1L) {
[16:19:42.103]                     if (is.function(sendCondition)) 
[16:19:42.103]                       return(sendCondition)
[16:19:42.103]                     ns <- getNamespace("parallel")
[16:19:42.103]                     if (exists("sendData", mode = "function", 
[16:19:42.103]                       envir = ns)) {
[16:19:42.103]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:42.103]                         envir = ns)
[16:19:42.103]                       envir <- sys.frame(frame)
[16:19:42.103]                       master <- NULL
[16:19:42.103]                       while (!identical(envir, .GlobalEnv) && 
[16:19:42.103]                         !identical(envir, emptyenv())) {
[16:19:42.103]                         if (exists("master", mode = "list", envir = envir, 
[16:19:42.103]                           inherits = FALSE)) {
[16:19:42.103]                           master <- get("master", mode = "list", 
[16:19:42.103]                             envir = envir, inherits = FALSE)
[16:19:42.103]                           if (inherits(master, c("SOCKnode", 
[16:19:42.103]                             "SOCK0node"))) {
[16:19:42.103]                             sendCondition <<- function(cond) {
[16:19:42.103]                               data <- list(type = "VALUE", value = cond, 
[16:19:42.103]                                 success = TRUE)
[16:19:42.103]                               parallel_sendData(master, data)
[16:19:42.103]                             }
[16:19:42.103]                             return(sendCondition)
[16:19:42.103]                           }
[16:19:42.103]                         }
[16:19:42.103]                         frame <- frame + 1L
[16:19:42.103]                         envir <- sys.frame(frame)
[16:19:42.103]                       }
[16:19:42.103]                     }
[16:19:42.103]                     sendCondition <<- function(cond) NULL
[16:19:42.103]                   }
[16:19:42.103]                 })
[16:19:42.103]                 withCallingHandlers({
[16:19:42.103]                   {
[16:19:42.103]                     do.call(function(...) {
[16:19:42.103]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:42.103]                       if (!identical(...future.globals.maxSize.org, 
[16:19:42.103]                         ...future.globals.maxSize)) {
[16:19:42.103]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:42.103]                         on.exit(options(oopts), add = TRUE)
[16:19:42.103]                       }
[16:19:42.103]                       {
[16:19:42.103]                         lapply(seq_along(...future.elements_ii), 
[16:19:42.103]                           FUN = function(jj) {
[16:19:42.103]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:42.103]                             ...future.FUN(...future.X_jj, ...)
[16:19:42.103]                           })
[16:19:42.103]                       }
[16:19:42.103]                     }, args = future.call.arguments)
[16:19:42.103]                   }
[16:19:42.103]                 }, immediateCondition = function(cond) {
[16:19:42.103]                   sendCondition <- ...future.makeSendCondition()
[16:19:42.103]                   sendCondition(cond)
[16:19:42.103]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:42.103]                   {
[16:19:42.103]                     inherits <- base::inherits
[16:19:42.103]                     invokeRestart <- base::invokeRestart
[16:19:42.103]                     is.null <- base::is.null
[16:19:42.103]                     muffled <- FALSE
[16:19:42.103]                     if (inherits(cond, "message")) {
[16:19:42.103]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:42.103]                       if (muffled) 
[16:19:42.103]                         invokeRestart("muffleMessage")
[16:19:42.103]                     }
[16:19:42.103]                     else if (inherits(cond, "warning")) {
[16:19:42.103]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:42.103]                       if (muffled) 
[16:19:42.103]                         invokeRestart("muffleWarning")
[16:19:42.103]                     }
[16:19:42.103]                     else if (inherits(cond, "condition")) {
[16:19:42.103]                       if (!is.null(pattern)) {
[16:19:42.103]                         computeRestarts <- base::computeRestarts
[16:19:42.103]                         grepl <- base::grepl
[16:19:42.103]                         restarts <- computeRestarts(cond)
[16:19:42.103]                         for (restart in restarts) {
[16:19:42.103]                           name <- restart$name
[16:19:42.103]                           if (is.null(name)) 
[16:19:42.103]                             next
[16:19:42.103]                           if (!grepl(pattern, name)) 
[16:19:42.103]                             next
[16:19:42.103]                           invokeRestart(restart)
[16:19:42.103]                           muffled <- TRUE
[16:19:42.103]                           break
[16:19:42.103]                         }
[16:19:42.103]                       }
[16:19:42.103]                     }
[16:19:42.103]                     invisible(muffled)
[16:19:42.103]                   }
[16:19:42.103]                   muffleCondition(cond)
[16:19:42.103]                 })
[16:19:42.103]             }))
[16:19:42.103]             future::FutureResult(value = ...future.value$value, 
[16:19:42.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:42.103]                   ...future.rng), globalenv = if (FALSE) 
[16:19:42.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:42.103]                     ...future.globalenv.names))
[16:19:42.103]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:42.103]         }, condition = base::local({
[16:19:42.103]             c <- base::c
[16:19:42.103]             inherits <- base::inherits
[16:19:42.103]             invokeRestart <- base::invokeRestart
[16:19:42.103]             length <- base::length
[16:19:42.103]             list <- base::list
[16:19:42.103]             seq.int <- base::seq.int
[16:19:42.103]             signalCondition <- base::signalCondition
[16:19:42.103]             sys.calls <- base::sys.calls
[16:19:42.103]             `[[` <- base::`[[`
[16:19:42.103]             `+` <- base::`+`
[16:19:42.103]             `<<-` <- base::`<<-`
[16:19:42.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:42.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:42.103]                   3L)]
[16:19:42.103]             }
[16:19:42.103]             function(cond) {
[16:19:42.103]                 is_error <- inherits(cond, "error")
[16:19:42.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:42.103]                   NULL)
[16:19:42.103]                 if (is_error) {
[16:19:42.103]                   sessionInformation <- function() {
[16:19:42.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:42.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:42.103]                       search = base::search(), system = base::Sys.info())
[16:19:42.103]                   }
[16:19:42.103]                   ...future.conditions[[length(...future.conditions) + 
[16:19:42.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:42.103]                     cond$call), session = sessionInformation(), 
[16:19:42.103]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:42.103]                   signalCondition(cond)
[16:19:42.103]                 }
[16:19:42.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:42.103]                 "immediateCondition"))) {
[16:19:42.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:42.103]                   ...future.conditions[[length(...future.conditions) + 
[16:19:42.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:42.103]                   if (TRUE && !signal) {
[16:19:42.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:42.103]                     {
[16:19:42.103]                       inherits <- base::inherits
[16:19:42.103]                       invokeRestart <- base::invokeRestart
[16:19:42.103]                       is.null <- base::is.null
[16:19:42.103]                       muffled <- FALSE
[16:19:42.103]                       if (inherits(cond, "message")) {
[16:19:42.103]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:42.103]                         if (muffled) 
[16:19:42.103]                           invokeRestart("muffleMessage")
[16:19:42.103]                       }
[16:19:42.103]                       else if (inherits(cond, "warning")) {
[16:19:42.103]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:42.103]                         if (muffled) 
[16:19:42.103]                           invokeRestart("muffleWarning")
[16:19:42.103]                       }
[16:19:42.103]                       else if (inherits(cond, "condition")) {
[16:19:42.103]                         if (!is.null(pattern)) {
[16:19:42.103]                           computeRestarts <- base::computeRestarts
[16:19:42.103]                           grepl <- base::grepl
[16:19:42.103]                           restarts <- computeRestarts(cond)
[16:19:42.103]                           for (restart in restarts) {
[16:19:42.103]                             name <- restart$name
[16:19:42.103]                             if (is.null(name)) 
[16:19:42.103]                               next
[16:19:42.103]                             if (!grepl(pattern, name)) 
[16:19:42.103]                               next
[16:19:42.103]                             invokeRestart(restart)
[16:19:42.103]                             muffled <- TRUE
[16:19:42.103]                             break
[16:19:42.103]                           }
[16:19:42.103]                         }
[16:19:42.103]                       }
[16:19:42.103]                       invisible(muffled)
[16:19:42.103]                     }
[16:19:42.103]                     muffleCondition(cond, pattern = "^muffle")
[16:19:42.103]                   }
[16:19:42.103]                 }
[16:19:42.103]                 else {
[16:19:42.103]                   if (TRUE) {
[16:19:42.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:42.103]                     {
[16:19:42.103]                       inherits <- base::inherits
[16:19:42.103]                       invokeRestart <- base::invokeRestart
[16:19:42.103]                       is.null <- base::is.null
[16:19:42.103]                       muffled <- FALSE
[16:19:42.103]                       if (inherits(cond, "message")) {
[16:19:42.103]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:42.103]                         if (muffled) 
[16:19:42.103]                           invokeRestart("muffleMessage")
[16:19:42.103]                       }
[16:19:42.103]                       else if (inherits(cond, "warning")) {
[16:19:42.103]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:42.103]                         if (muffled) 
[16:19:42.103]                           invokeRestart("muffleWarning")
[16:19:42.103]                       }
[16:19:42.103]                       else if (inherits(cond, "condition")) {
[16:19:42.103]                         if (!is.null(pattern)) {
[16:19:42.103]                           computeRestarts <- base::computeRestarts
[16:19:42.103]                           grepl <- base::grepl
[16:19:42.103]                           restarts <- computeRestarts(cond)
[16:19:42.103]                           for (restart in restarts) {
[16:19:42.103]                             name <- restart$name
[16:19:42.103]                             if (is.null(name)) 
[16:19:42.103]                               next
[16:19:42.103]                             if (!grepl(pattern, name)) 
[16:19:42.103]                               next
[16:19:42.103]                             invokeRestart(restart)
[16:19:42.103]                             muffled <- TRUE
[16:19:42.103]                             break
[16:19:42.103]                           }
[16:19:42.103]                         }
[16:19:42.103]                       }
[16:19:42.103]                       invisible(muffled)
[16:19:42.103]                     }
[16:19:42.103]                     muffleCondition(cond, pattern = "^muffle")
[16:19:42.103]                   }
[16:19:42.103]                 }
[16:19:42.103]             }
[16:19:42.103]         }))
[16:19:42.103]     }, error = function(ex) {
[16:19:42.103]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:42.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:42.103]                 ...future.rng), started = ...future.startTime, 
[16:19:42.103]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:42.103]             version = "1.8"), class = "FutureResult")
[16:19:42.103]     }, finally = {
[16:19:42.103]         if (!identical(...future.workdir, getwd())) 
[16:19:42.103]             setwd(...future.workdir)
[16:19:42.103]         {
[16:19:42.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:42.103]                 ...future.oldOptions$nwarnings <- NULL
[16:19:42.103]             }
[16:19:42.103]             base::options(...future.oldOptions)
[16:19:42.103]             if (.Platform$OS.type == "windows") {
[16:19:42.103]                 old_names <- names(...future.oldEnvVars)
[16:19:42.103]                 envs <- base::Sys.getenv()
[16:19:42.103]                 names <- names(envs)
[16:19:42.103]                 common <- intersect(names, old_names)
[16:19:42.103]                 added <- setdiff(names, old_names)
[16:19:42.103]                 removed <- setdiff(old_names, names)
[16:19:42.103]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:42.103]                   envs[common]]
[16:19:42.103]                 NAMES <- toupper(changed)
[16:19:42.103]                 args <- list()
[16:19:42.103]                 for (kk in seq_along(NAMES)) {
[16:19:42.103]                   name <- changed[[kk]]
[16:19:42.103]                   NAME <- NAMES[[kk]]
[16:19:42.103]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:42.103]                     next
[16:19:42.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:42.103]                 }
[16:19:42.103]                 NAMES <- toupper(added)
[16:19:42.103]                 for (kk in seq_along(NAMES)) {
[16:19:42.103]                   name <- added[[kk]]
[16:19:42.103]                   NAME <- NAMES[[kk]]
[16:19:42.103]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:42.103]                     next
[16:19:42.103]                   args[[name]] <- ""
[16:19:42.103]                 }
[16:19:42.103]                 NAMES <- toupper(removed)
[16:19:42.103]                 for (kk in seq_along(NAMES)) {
[16:19:42.103]                   name <- removed[[kk]]
[16:19:42.103]                   NAME <- NAMES[[kk]]
[16:19:42.103]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:42.103]                     next
[16:19:42.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:42.103]                 }
[16:19:42.103]                 if (length(args) > 0) 
[16:19:42.103]                   base::do.call(base::Sys.setenv, args = args)
[16:19:42.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:42.103]             }
[16:19:42.103]             else {
[16:19:42.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:42.103]             }
[16:19:42.103]             {
[16:19:42.103]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:42.103]                   0L) {
[16:19:42.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:42.103]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:42.103]                   base::options(opts)
[16:19:42.103]                 }
[16:19:42.103]                 {
[16:19:42.103]                   {
[16:19:42.103]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:42.103]                     NULL
[16:19:42.103]                   }
[16:19:42.103]                   options(future.plan = NULL)
[16:19:42.103]                   if (is.na(NA_character_)) 
[16:19:42.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:42.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:42.103]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:42.103]                     .init = FALSE)
[16:19:42.103]                 }
[16:19:42.103]             }
[16:19:42.103]         }
[16:19:42.103]     })
[16:19:42.103]     if (FALSE) {
[16:19:42.103]         base::sink(type = "output", split = FALSE)
[16:19:42.103]         if (NA) {
[16:19:42.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:42.103]         }
[16:19:42.103]         else {
[16:19:42.103]             ...future.result["stdout"] <- base::list(NULL)
[16:19:42.103]         }
[16:19:42.103]         base::close(...future.stdout)
[16:19:42.103]         ...future.stdout <- NULL
[16:19:42.103]     }
[16:19:42.103]     ...future.result$conditions <- ...future.conditions
[16:19:42.103]     ...future.result$finished <- base::Sys.time()
[16:19:42.103]     ...future.result
[16:19:42.103] }
[16:19:42.106] Exporting 5 global objects (4.61 KiB) to cluster node #2 ...
[16:19:42.106] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ...
[16:19:42.106] Exporting ‘...future.FUN’ (4.61 KiB) to cluster node #2 ... DONE
[16:19:42.107] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[16:19:42.107] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[16:19:42.107] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ...
[16:19:42.107] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #2 ... DONE
[16:19:42.108] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:42.108] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:42.108] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:42.108] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:42.108] Exporting 5 global objects (4.61 KiB) to cluster node #2 ... DONE
[16:19:42.109] MultisessionFuture started
[16:19:42.109] - Launch lazy future ... done
[16:19:42.109] run() for ‘MultisessionFuture’ ... done
[16:19:42.109] Created future:
[16:19:42.109] MultisessionFuture:
[16:19:42.109] Label: ‘future_lapply-2’
[16:19:42.109] Expression:
[16:19:42.109] {
[16:19:42.109]     do.call(function(...) {
[16:19:42.109]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:42.109]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:42.109]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:42.109]             on.exit(options(oopts), add = TRUE)
[16:19:42.109]         }
[16:19:42.109]         {
[16:19:42.109]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[16:19:42.109]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[16:19:42.109]                 ...future.FUN(...future.X_jj, ...)
[16:19:42.109]             })
[16:19:42.109]         }
[16:19:42.109]     }, args = future.call.arguments)
[16:19:42.109] }
[16:19:42.109] Lazy evaluation: FALSE
[16:19:42.109] Asynchronous evaluation: TRUE
[16:19:42.109] Local evaluation: TRUE
[16:19:42.109] Environment: R_GlobalEnv
[16:19:42.109] Capture standard output: NA
[16:19:42.109] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:42.109] Globals: 5 objects totaling 4.66 KiB (function ‘...future.FUN’ of 4.61 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 56 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:42.109] Packages: <none>
[16:19:42.109] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:42.109] Resolved: FALSE
[16:19:42.109] Value: <not collected>
[16:19:42.109] Conditions captured: <none>
[16:19:42.109] Early signaling: FALSE
[16:19:42.109] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:42.109] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:42.121] Chunk #2 of 2 ... DONE
[16:19:42.121] Launching 2 futures (chunks) ... DONE
[16:19:42.121] Resolving 2 futures (chunks) ...
[16:19:42.121] resolve() on list ...
[16:19:42.121]  recursive: 0
[16:19:42.121]  length: 2
[16:19:42.121] 
[16:19:42.163] receiveMessageFromWorker() for ClusterFuture ...
[16:19:42.164] - Validating connection of MultisessionFuture
[16:19:42.164] - received message: FutureResult
[16:19:42.164] - Received FutureResult
[16:19:42.164] - Erased future from FutureRegistry
[16:19:42.164] result() for ClusterFuture ...
[16:19:42.164] - result already collected: FutureResult
[16:19:42.164] result() for ClusterFuture ... done
[16:19:42.164] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:42.164] Future #2
[16:19:42.165] result() for ClusterFuture ...
[16:19:42.165] - result already collected: FutureResult
[16:19:42.165] result() for ClusterFuture ... done
[16:19:42.165] result() for ClusterFuture ...
[16:19:42.165] - result already collected: FutureResult
[16:19:42.165] result() for ClusterFuture ... done
[16:19:42.165] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:42.165] - nx: 2
[16:19:42.165] - relay: TRUE
[16:19:42.165] - stdout: TRUE
[16:19:42.165] - signal: TRUE
[16:19:42.166] - resignal: FALSE
[16:19:42.166] - force: TRUE
[16:19:42.166] - relayed: [n=2] FALSE, FALSE
[16:19:42.166] - queued futures: [n=2] FALSE, FALSE
[16:19:42.166]  - until=1
[16:19:42.166]  - relaying element #1
[16:19:42.166] - relayed: [n=2] FALSE, FALSE
[16:19:42.166] - queued futures: [n=2] FALSE, TRUE
[16:19:42.166] signalConditionsASAP(NULL, pos=2) ... done
[16:19:42.166]  length: 1 (resolved future 2)
[16:19:42.619] receiveMessageFromWorker() for ClusterFuture ...
[16:19:42.619] - Validating connection of MultisessionFuture
[16:19:42.619] - received message: FutureResult
[16:19:42.619] - Received FutureResult
[16:19:42.619] - Erased future from FutureRegistry
[16:19:42.620] result() for ClusterFuture ...
[16:19:42.620] - result already collected: FutureResult
[16:19:42.620] result() for ClusterFuture ... done
[16:19:42.620] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:42.620] Future #1
[16:19:42.620] result() for ClusterFuture ...
[16:19:42.620] - result already collected: FutureResult
[16:19:42.620] result() for ClusterFuture ... done
[16:19:42.620] result() for ClusterFuture ...
[16:19:42.620] - result already collected: FutureResult
[16:19:42.620] result() for ClusterFuture ... done
[16:19:42.621] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:42.621] - nx: 2
[16:19:42.621] - relay: TRUE
[16:19:42.621] - stdout: TRUE
[16:19:42.621] - signal: TRUE
[16:19:42.621] - resignal: FALSE
[16:19:42.621] - force: TRUE
[16:19:42.621] - relayed: [n=2] FALSE, FALSE
[16:19:42.621] - queued futures: [n=2] FALSE, TRUE
[16:19:42.621]  - until=1
[16:19:42.621]  - relaying element #1
[16:19:42.621] result() for ClusterFuture ...
[16:19:42.622] - result already collected: FutureResult
[16:19:42.622] result() for ClusterFuture ... done
[16:19:42.622] result() for ClusterFuture ...
[16:19:42.622] - result already collected: FutureResult
[16:19:42.622] result() for ClusterFuture ... done
[16:19:42.622] result() for ClusterFuture ...
[16:19:42.622] - result already collected: FutureResult
[16:19:42.622] result() for ClusterFuture ... done
[16:19:42.622] result() for ClusterFuture ...
[16:19:42.622] - result already collected: FutureResult
[16:19:42.622] result() for ClusterFuture ... done
[16:19:42.623] - relayed: [n=2] TRUE, FALSE
[16:19:42.623] - queued futures: [n=2] TRUE, TRUE
[16:19:42.623] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:42.623]  length: 0 (resolved future 1)
[16:19:42.623] Relaying remaining futures
[16:19:42.623] signalConditionsASAP(NULL, pos=0) ...
[16:19:42.623] - nx: 2
[16:19:42.623] - relay: TRUE
[16:19:42.623] - stdout: TRUE
[16:19:42.623] - signal: TRUE
[16:19:42.623] - resignal: FALSE
[16:19:42.623] - force: TRUE
[16:19:42.624] - relayed: [n=2] TRUE, FALSE
[16:19:42.624] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:42.624]  - relaying element #2
[16:19:42.624] result() for ClusterFuture ...
[16:19:42.624] - result already collected: FutureResult
[16:19:42.624] result() for ClusterFuture ... done
[16:19:42.624] result() for ClusterFuture ...
[16:19:42.624] - result already collected: FutureResult
[16:19:42.624] result() for ClusterFuture ... done
[16:19:42.624] result() for ClusterFuture ...
[16:19:42.625] - result already collected: FutureResult
[16:19:42.625] result() for ClusterFuture ... done
[16:19:42.625] result() for ClusterFuture ...
[16:19:42.625] - result already collected: FutureResult
[16:19:42.625] result() for ClusterFuture ... done
[16:19:42.625] - relayed: [n=2] TRUE, TRUE
[16:19:42.625] - queued futures: [n=2] TRUE, TRUE
[16:19:42.625] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:19:42.625] resolve() on list ... DONE
[16:19:42.625] result() for ClusterFuture ...
[16:19:42.625] - result already collected: FutureResult
[16:19:42.625] result() for ClusterFuture ... done
[16:19:42.626] result() for ClusterFuture ...
[16:19:42.626] - result already collected: FutureResult
[16:19:42.626] result() for ClusterFuture ... done
[16:19:42.626] result() for ClusterFuture ...
[16:19:42.626] - result already collected: FutureResult
[16:19:42.626] result() for ClusterFuture ... done
[16:19:42.626] result() for ClusterFuture ...
[16:19:42.626] - result already collected: FutureResult
[16:19:42.626] result() for ClusterFuture ... done
[16:19:42.626]  - Number of value chunks collected: 2
[16:19:42.626] Resolving 2 futures (chunks) ... DONE
[16:19:42.627] Reducing values from 2 chunks ...
[16:19:42.627]  - Number of values collected after concatenation: 2
[16:19:42.627]  - Number of values expected: 2
[16:19:42.627] Reducing values from 2 chunks ... DONE
[16:19:42.627] future_lapply() ... DONE
* future_lapply(x, ..., future.stdout = NA) ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ...
[16:19:42.627] future_mapply() ...
[16:19:42.631] Number of chunks: 2
[16:19:42.631] getGlobalsAndPackagesXApply() ...
[16:19:42.631]  - future.globals: TRUE
[16:19:42.632] getGlobalsAndPackages() ...
[16:19:42.632] Searching for globals...
[16:19:42.633] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:42.633] Searching for globals ... DONE
[16:19:42.633] Resolving globals: FALSE
[16:19:42.634] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:42.634] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:42.634] - globals: [1] ‘FUN’
[16:19:42.634] 
[16:19:42.635] getGlobalsAndPackages() ... DONE
[16:19:42.635]  - globals found/used: [n=1] ‘FUN’
[16:19:42.635]  - needed namespaces: [n=0] 
[16:19:42.635] Finding globals ... DONE
[16:19:42.635] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:42.635] List of 2
[16:19:42.635]  $ ...future.FUN:function (x, y)  
[16:19:42.635]  $ MoreArgs     : NULL
[16:19:42.635]  - attr(*, "where")=List of 2
[16:19:42.635]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:42.635]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:42.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:42.635]  - attr(*, "resolved")= logi FALSE
[16:19:42.635]  - attr(*, "total_size")= num NA
[16:19:42.638] Packages to be attached in all futures: [n=0] 
[16:19:42.638] getGlobalsAndPackagesXApply() ... DONE
[16:19:42.638] Number of futures (= number of chunks): 2
[16:19:42.638] Launching 2 futures (chunks) ...
[16:19:42.638] Chunk #1 of 2 ...
[16:19:42.638]  - Finding globals in '...' for chunk #1 ...
[16:19:42.638] getGlobalsAndPackages() ...
[16:19:42.638] Searching for globals...
[16:19:42.639] 
[16:19:42.639] Searching for globals ... DONE
[16:19:42.639] - globals: [0] <none>
[16:19:42.641] getGlobalsAndPackages() ... DONE
[16:19:42.641]    + additional globals found: [n=0] 
[16:19:42.641]    + additional namespaces needed: [n=0] 
[16:19:42.641]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:42.641]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:42.641]  - seeds: <none>
[16:19:42.641]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:42.642] getGlobalsAndPackages() ...
[16:19:42.642] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:42.642] Resolving globals: FALSE
[16:19:42.642] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:19:42.643] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:42.643] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:42.643] 
[16:19:42.643] getGlobalsAndPackages() ... DONE
[16:19:42.643] run() for ‘Future’ ...
[16:19:42.643] - state: ‘created’
[16:19:42.644] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:42.657] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:42.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:42.657]   - Field: ‘node’
[16:19:42.657]   - Field: ‘label’
[16:19:42.657]   - Field: ‘local’
[16:19:42.657]   - Field: ‘owner’
[16:19:42.658]   - Field: ‘envir’
[16:19:42.658]   - Field: ‘workers’
[16:19:42.658]   - Field: ‘packages’
[16:19:42.658]   - Field: ‘gc’
[16:19:42.658]   - Field: ‘conditions’
[16:19:42.658]   - Field: ‘persistent’
[16:19:42.658]   - Field: ‘expr’
[16:19:42.658]   - Field: ‘uuid’
[16:19:42.658]   - Field: ‘seed’
[16:19:42.658]   - Field: ‘version’
[16:19:42.658]   - Field: ‘result’
[16:19:42.659]   - Field: ‘asynchronous’
[16:19:42.659]   - Field: ‘calls’
[16:19:42.659]   - Field: ‘globals’
[16:19:42.659]   - Field: ‘stdout’
[16:19:42.659]   - Field: ‘earlySignal’
[16:19:42.659]   - Field: ‘lazy’
[16:19:42.659]   - Field: ‘state’
[16:19:42.659] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:42.659] - Launch lazy future ...
[16:19:42.659] Packages needed by the future expression (n = 0): <none>
[16:19:42.660] Packages needed by future strategies (n = 0): <none>
[16:19:42.660] {
[16:19:42.660]     {
[16:19:42.660]         {
[16:19:42.660]             ...future.startTime <- base::Sys.time()
[16:19:42.660]             {
[16:19:42.660]                 {
[16:19:42.660]                   {
[16:19:42.660]                     {
[16:19:42.660]                       base::local({
[16:19:42.660]                         has_future <- base::requireNamespace("future", 
[16:19:42.660]                           quietly = TRUE)
[16:19:42.660]                         if (has_future) {
[16:19:42.660]                           ns <- base::getNamespace("future")
[16:19:42.660]                           version <- ns[[".package"]][["version"]]
[16:19:42.660]                           if (is.null(version)) 
[16:19:42.660]                             version <- utils::packageVersion("future")
[16:19:42.660]                         }
[16:19:42.660]                         else {
[16:19:42.660]                           version <- NULL
[16:19:42.660]                         }
[16:19:42.660]                         if (!has_future || version < "1.8.0") {
[16:19:42.660]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:42.660]                             "", base::R.version$version.string), 
[16:19:42.660]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:42.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:42.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:42.660]                               "release", "version")], collapse = " "), 
[16:19:42.660]                             hostname = base::Sys.info()[["nodename"]])
[16:19:42.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:42.660]                             info)
[16:19:42.660]                           info <- base::paste(info, collapse = "; ")
[16:19:42.660]                           if (!has_future) {
[16:19:42.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:42.660]                               info)
[16:19:42.660]                           }
[16:19:42.660]                           else {
[16:19:42.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:42.660]                               info, version)
[16:19:42.660]                           }
[16:19:42.660]                           base::stop(msg)
[16:19:42.660]                         }
[16:19:42.660]                       })
[16:19:42.660]                     }
[16:19:42.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:42.660]                     base::options(mc.cores = 1L)
[16:19:42.660]                   }
[16:19:42.660]                   ...future.strategy.old <- future::plan("list")
[16:19:42.660]                   options(future.plan = NULL)
[16:19:42.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:42.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:42.660]                 }
[16:19:42.660]                 ...future.workdir <- getwd()
[16:19:42.660]             }
[16:19:42.660]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:42.660]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:42.660]         }
[16:19:42.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:42.660]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:42.660]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:42.660]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:42.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:42.660]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:42.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:42.660]             base::names(...future.oldOptions))
[16:19:42.660]     }
[16:19:42.660]     if (FALSE) {
[16:19:42.660]     }
[16:19:42.660]     else {
[16:19:42.660]         if (FALSE) {
[16:19:42.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:42.660]                 open = "w")
[16:19:42.660]         }
[16:19:42.660]         else {
[16:19:42.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:42.660]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:42.660]         }
[16:19:42.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:42.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:42.660]             base::sink(type = "output", split = FALSE)
[16:19:42.660]             base::close(...future.stdout)
[16:19:42.660]         }, add = TRUE)
[16:19:42.660]     }
[16:19:42.660]     ...future.frame <- base::sys.nframe()
[16:19:42.660]     ...future.conditions <- base::list()
[16:19:42.660]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:42.660]     if (FALSE) {
[16:19:42.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:42.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:42.660]     }
[16:19:42.660]     ...future.result <- base::tryCatch({
[16:19:42.660]         base::withCallingHandlers({
[16:19:42.660]             ...future.value <- base::withVisible(base::local({
[16:19:42.660]                 ...future.makeSendCondition <- base::local({
[16:19:42.660]                   sendCondition <- NULL
[16:19:42.660]                   function(frame = 1L) {
[16:19:42.660]                     if (is.function(sendCondition)) 
[16:19:42.660]                       return(sendCondition)
[16:19:42.660]                     ns <- getNamespace("parallel")
[16:19:42.660]                     if (exists("sendData", mode = "function", 
[16:19:42.660]                       envir = ns)) {
[16:19:42.660]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:42.660]                         envir = ns)
[16:19:42.660]                       envir <- sys.frame(frame)
[16:19:42.660]                       master <- NULL
[16:19:42.660]                       while (!identical(envir, .GlobalEnv) && 
[16:19:42.660]                         !identical(envir, emptyenv())) {
[16:19:42.660]                         if (exists("master", mode = "list", envir = envir, 
[16:19:42.660]                           inherits = FALSE)) {
[16:19:42.660]                           master <- get("master", mode = "list", 
[16:19:42.660]                             envir = envir, inherits = FALSE)
[16:19:42.660]                           if (inherits(master, c("SOCKnode", 
[16:19:42.660]                             "SOCK0node"))) {
[16:19:42.660]                             sendCondition <<- function(cond) {
[16:19:42.660]                               data <- list(type = "VALUE", value = cond, 
[16:19:42.660]                                 success = TRUE)
[16:19:42.660]                               parallel_sendData(master, data)
[16:19:42.660]                             }
[16:19:42.660]                             return(sendCondition)
[16:19:42.660]                           }
[16:19:42.660]                         }
[16:19:42.660]                         frame <- frame + 1L
[16:19:42.660]                         envir <- sys.frame(frame)
[16:19:42.660]                       }
[16:19:42.660]                     }
[16:19:42.660]                     sendCondition <<- function(cond) NULL
[16:19:42.660]                   }
[16:19:42.660]                 })
[16:19:42.660]                 withCallingHandlers({
[16:19:42.660]                   {
[16:19:42.660]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:42.660]                     if (!identical(...future.globals.maxSize.org, 
[16:19:42.660]                       ...future.globals.maxSize)) {
[16:19:42.660]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:42.660]                       on.exit(options(oopts), add = TRUE)
[16:19:42.660]                     }
[16:19:42.660]                     {
[16:19:42.660]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:42.660]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:42.660]                         USE.NAMES = FALSE)
[16:19:42.660]                       do.call(mapply, args = args)
[16:19:42.660]                     }
[16:19:42.660]                   }
[16:19:42.660]                 }, immediateCondition = function(cond) {
[16:19:42.660]                   sendCondition <- ...future.makeSendCondition()
[16:19:42.660]                   sendCondition(cond)
[16:19:42.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:42.660]                   {
[16:19:42.660]                     inherits <- base::inherits
[16:19:42.660]                     invokeRestart <- base::invokeRestart
[16:19:42.660]                     is.null <- base::is.null
[16:19:42.660]                     muffled <- FALSE
[16:19:42.660]                     if (inherits(cond, "message")) {
[16:19:42.660]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:42.660]                       if (muffled) 
[16:19:42.660]                         invokeRestart("muffleMessage")
[16:19:42.660]                     }
[16:19:42.660]                     else if (inherits(cond, "warning")) {
[16:19:42.660]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:42.660]                       if (muffled) 
[16:19:42.660]                         invokeRestart("muffleWarning")
[16:19:42.660]                     }
[16:19:42.660]                     else if (inherits(cond, "condition")) {
[16:19:42.660]                       if (!is.null(pattern)) {
[16:19:42.660]                         computeRestarts <- base::computeRestarts
[16:19:42.660]                         grepl <- base::grepl
[16:19:42.660]                         restarts <- computeRestarts(cond)
[16:19:42.660]                         for (restart in restarts) {
[16:19:42.660]                           name <- restart$name
[16:19:42.660]                           if (is.null(name)) 
[16:19:42.660]                             next
[16:19:42.660]                           if (!grepl(pattern, name)) 
[16:19:42.660]                             next
[16:19:42.660]                           invokeRestart(restart)
[16:19:42.660]                           muffled <- TRUE
[16:19:42.660]                           break
[16:19:42.660]                         }
[16:19:42.660]                       }
[16:19:42.660]                     }
[16:19:42.660]                     invisible(muffled)
[16:19:42.660]                   }
[16:19:42.660]                   muffleCondition(cond)
[16:19:42.660]                 })
[16:19:42.660]             }))
[16:19:42.660]             future::FutureResult(value = ...future.value$value, 
[16:19:42.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:42.660]                   ...future.rng), globalenv = if (FALSE) 
[16:19:42.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:42.660]                     ...future.globalenv.names))
[16:19:42.660]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:42.660]         }, condition = base::local({
[16:19:42.660]             c <- base::c
[16:19:42.660]             inherits <- base::inherits
[16:19:42.660]             invokeRestart <- base::invokeRestart
[16:19:42.660]             length <- base::length
[16:19:42.660]             list <- base::list
[16:19:42.660]             seq.int <- base::seq.int
[16:19:42.660]             signalCondition <- base::signalCondition
[16:19:42.660]             sys.calls <- base::sys.calls
[16:19:42.660]             `[[` <- base::`[[`
[16:19:42.660]             `+` <- base::`+`
[16:19:42.660]             `<<-` <- base::`<<-`
[16:19:42.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:42.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:42.660]                   3L)]
[16:19:42.660]             }
[16:19:42.660]             function(cond) {
[16:19:42.660]                 is_error <- inherits(cond, "error")
[16:19:42.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:42.660]                   NULL)
[16:19:42.660]                 if (is_error) {
[16:19:42.660]                   sessionInformation <- function() {
[16:19:42.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:42.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:42.660]                       search = base::search(), system = base::Sys.info())
[16:19:42.660]                   }
[16:19:42.660]                   ...future.conditions[[length(...future.conditions) + 
[16:19:42.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:42.660]                     cond$call), session = sessionInformation(), 
[16:19:42.660]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:42.660]                   signalCondition(cond)
[16:19:42.660]                 }
[16:19:42.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:42.660]                 "immediateCondition"))) {
[16:19:42.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:42.660]                   ...future.conditions[[length(...future.conditions) + 
[16:19:42.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:42.660]                   if (TRUE && !signal) {
[16:19:42.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:42.660]                     {
[16:19:42.660]                       inherits <- base::inherits
[16:19:42.660]                       invokeRestart <- base::invokeRestart
[16:19:42.660]                       is.null <- base::is.null
[16:19:42.660]                       muffled <- FALSE
[16:19:42.660]                       if (inherits(cond, "message")) {
[16:19:42.660]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:42.660]                         if (muffled) 
[16:19:42.660]                           invokeRestart("muffleMessage")
[16:19:42.660]                       }
[16:19:42.660]                       else if (inherits(cond, "warning")) {
[16:19:42.660]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:42.660]                         if (muffled) 
[16:19:42.660]                           invokeRestart("muffleWarning")
[16:19:42.660]                       }
[16:19:42.660]                       else if (inherits(cond, "condition")) {
[16:19:42.660]                         if (!is.null(pattern)) {
[16:19:42.660]                           computeRestarts <- base::computeRestarts
[16:19:42.660]                           grepl <- base::grepl
[16:19:42.660]                           restarts <- computeRestarts(cond)
[16:19:42.660]                           for (restart in restarts) {
[16:19:42.660]                             name <- restart$name
[16:19:42.660]                             if (is.null(name)) 
[16:19:42.660]                               next
[16:19:42.660]                             if (!grepl(pattern, name)) 
[16:19:42.660]                               next
[16:19:42.660]                             invokeRestart(restart)
[16:19:42.660]                             muffled <- TRUE
[16:19:42.660]                             break
[16:19:42.660]                           }
[16:19:42.660]                         }
[16:19:42.660]                       }
[16:19:42.660]                       invisible(muffled)
[16:19:42.660]                     }
[16:19:42.660]                     muffleCondition(cond, pattern = "^muffle")
[16:19:42.660]                   }
[16:19:42.660]                 }
[16:19:42.660]                 else {
[16:19:42.660]                   if (TRUE) {
[16:19:42.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:42.660]                     {
[16:19:42.660]                       inherits <- base::inherits
[16:19:42.660]                       invokeRestart <- base::invokeRestart
[16:19:42.660]                       is.null <- base::is.null
[16:19:42.660]                       muffled <- FALSE
[16:19:42.660]                       if (inherits(cond, "message")) {
[16:19:42.660]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:42.660]                         if (muffled) 
[16:19:42.660]                           invokeRestart("muffleMessage")
[16:19:42.660]                       }
[16:19:42.660]                       else if (inherits(cond, "warning")) {
[16:19:42.660]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:42.660]                         if (muffled) 
[16:19:42.660]                           invokeRestart("muffleWarning")
[16:19:42.660]                       }
[16:19:42.660]                       else if (inherits(cond, "condition")) {
[16:19:42.660]                         if (!is.null(pattern)) {
[16:19:42.660]                           computeRestarts <- base::computeRestarts
[16:19:42.660]                           grepl <- base::grepl
[16:19:42.660]                           restarts <- computeRestarts(cond)
[16:19:42.660]                           for (restart in restarts) {
[16:19:42.660]                             name <- restart$name
[16:19:42.660]                             if (is.null(name)) 
[16:19:42.660]                               next
[16:19:42.660]                             if (!grepl(pattern, name)) 
[16:19:42.660]                               next
[16:19:42.660]                             invokeRestart(restart)
[16:19:42.660]                             muffled <- TRUE
[16:19:42.660]                             break
[16:19:42.660]                           }
[16:19:42.660]                         }
[16:19:42.660]                       }
[16:19:42.660]                       invisible(muffled)
[16:19:42.660]                     }
[16:19:42.660]                     muffleCondition(cond, pattern = "^muffle")
[16:19:42.660]                   }
[16:19:42.660]                 }
[16:19:42.660]             }
[16:19:42.660]         }))
[16:19:42.660]     }, error = function(ex) {
[16:19:42.660]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:42.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:42.660]                 ...future.rng), started = ...future.startTime, 
[16:19:42.660]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:42.660]             version = "1.8"), class = "FutureResult")
[16:19:42.660]     }, finally = {
[16:19:42.660]         if (!identical(...future.workdir, getwd())) 
[16:19:42.660]             setwd(...future.workdir)
[16:19:42.660]         {
[16:19:42.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:42.660]                 ...future.oldOptions$nwarnings <- NULL
[16:19:42.660]             }
[16:19:42.660]             base::options(...future.oldOptions)
[16:19:42.660]             if (.Platform$OS.type == "windows") {
[16:19:42.660]                 old_names <- names(...future.oldEnvVars)
[16:19:42.660]                 envs <- base::Sys.getenv()
[16:19:42.660]                 names <- names(envs)
[16:19:42.660]                 common <- intersect(names, old_names)
[16:19:42.660]                 added <- setdiff(names, old_names)
[16:19:42.660]                 removed <- setdiff(old_names, names)
[16:19:42.660]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:42.660]                   envs[common]]
[16:19:42.660]                 NAMES <- toupper(changed)
[16:19:42.660]                 args <- list()
[16:19:42.660]                 for (kk in seq_along(NAMES)) {
[16:19:42.660]                   name <- changed[[kk]]
[16:19:42.660]                   NAME <- NAMES[[kk]]
[16:19:42.660]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:42.660]                     next
[16:19:42.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:42.660]                 }
[16:19:42.660]                 NAMES <- toupper(added)
[16:19:42.660]                 for (kk in seq_along(NAMES)) {
[16:19:42.660]                   name <- added[[kk]]
[16:19:42.660]                   NAME <- NAMES[[kk]]
[16:19:42.660]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:42.660]                     next
[16:19:42.660]                   args[[name]] <- ""
[16:19:42.660]                 }
[16:19:42.660]                 NAMES <- toupper(removed)
[16:19:42.660]                 for (kk in seq_along(NAMES)) {
[16:19:42.660]                   name <- removed[[kk]]
[16:19:42.660]                   NAME <- NAMES[[kk]]
[16:19:42.660]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:42.660]                     next
[16:19:42.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:42.660]                 }
[16:19:42.660]                 if (length(args) > 0) 
[16:19:42.660]                   base::do.call(base::Sys.setenv, args = args)
[16:19:42.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:42.660]             }
[16:19:42.660]             else {
[16:19:42.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:42.660]             }
[16:19:42.660]             {
[16:19:42.660]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:42.660]                   0L) {
[16:19:42.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:42.660]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:42.660]                   base::options(opts)
[16:19:42.660]                 }
[16:19:42.660]                 {
[16:19:42.660]                   {
[16:19:42.660]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:42.660]                     NULL
[16:19:42.660]                   }
[16:19:42.660]                   options(future.plan = NULL)
[16:19:42.660]                   if (is.na(NA_character_)) 
[16:19:42.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:42.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:42.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:42.660]                     .init = FALSE)
[16:19:42.660]                 }
[16:19:42.660]             }
[16:19:42.660]         }
[16:19:42.660]     })
[16:19:42.660]     if (TRUE) {
[16:19:42.660]         base::sink(type = "output", split = FALSE)
[16:19:42.660]         if (FALSE) {
[16:19:42.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:42.660]         }
[16:19:42.660]         else {
[16:19:42.660]             ...future.result["stdout"] <- base::list(NULL)
[16:19:42.660]         }
[16:19:42.660]         base::close(...future.stdout)
[16:19:42.660]         ...future.stdout <- NULL
[16:19:42.660]     }
[16:19:42.660]     ...future.result$conditions <- ...future.conditions
[16:19:42.660]     ...future.result$finished <- base::Sys.time()
[16:19:42.660]     ...future.result
[16:19:42.660] }
[16:19:42.663] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[16:19:42.663] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[16:19:42.663] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[16:19:42.663] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:19:42.664] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:19:42.664] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:19:42.664] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:19:42.664] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:42.665] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:42.665] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:42.665] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:42.665] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[16:19:42.666] MultisessionFuture started
[16:19:42.666] - Launch lazy future ... done
[16:19:42.666] run() for ‘MultisessionFuture’ ... done
[16:19:42.666] Created future:
[16:19:42.666] MultisessionFuture:
[16:19:42.666] Label: ‘future_mapply-1’
[16:19:42.666] Expression:
[16:19:42.666] {
[16:19:42.666]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:42.666]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:42.666]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:42.666]         on.exit(options(oopts), add = TRUE)
[16:19:42.666]     }
[16:19:42.666]     {
[16:19:42.666]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:42.666]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:42.666]         do.call(mapply, args = args)
[16:19:42.666]     }
[16:19:42.666] }
[16:19:42.666] Lazy evaluation: FALSE
[16:19:42.666] Asynchronous evaluation: TRUE
[16:19:42.666] Local evaluation: TRUE
[16:19:42.666] Environment: R_GlobalEnv
[16:19:42.666] Capture standard output: FALSE
[16:19:42.666] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:42.666] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:42.666] Packages: <none>
[16:19:42.666] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:42.666] Resolved: FALSE
[16:19:42.666] Value: <not collected>
[16:19:42.666] Conditions captured: <none>
[16:19:42.666] Early signaling: FALSE
[16:19:42.666] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:42.666] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:42.677] Chunk #1 of 2 ... DONE
[16:19:42.678] Chunk #2 of 2 ...
[16:19:42.678]  - Finding globals in '...' for chunk #2 ...
[16:19:42.678] getGlobalsAndPackages() ...
[16:19:42.678] Searching for globals...
[16:19:42.678] 
[16:19:42.678] Searching for globals ... DONE
[16:19:42.678] - globals: [0] <none>
[16:19:42.678] getGlobalsAndPackages() ... DONE
[16:19:42.679]    + additional globals found: [n=0] 
[16:19:42.679]    + additional namespaces needed: [n=0] 
[16:19:42.679]  - Finding globals in '...' for chunk #2 ... DONE
[16:19:42.679]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:42.679]  - seeds: <none>
[16:19:42.679]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:42.679] getGlobalsAndPackages() ...
[16:19:42.679] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:42.679] Resolving globals: FALSE
[16:19:42.680] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:19:42.680] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:42.680] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:42.681] 
[16:19:42.681] getGlobalsAndPackages() ... DONE
[16:19:42.681] run() for ‘Future’ ...
[16:19:42.681] - state: ‘created’
[16:19:42.681] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:42.695] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:42.696] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:42.696]   - Field: ‘node’
[16:19:42.696]   - Field: ‘label’
[16:19:42.696]   - Field: ‘local’
[16:19:42.696]   - Field: ‘owner’
[16:19:42.696]   - Field: ‘envir’
[16:19:42.696]   - Field: ‘workers’
[16:19:42.696]   - Field: ‘packages’
[16:19:42.696]   - Field: ‘gc’
[16:19:42.696]   - Field: ‘conditions’
[16:19:42.697]   - Field: ‘persistent’
[16:19:42.697]   - Field: ‘expr’
[16:19:42.697]   - Field: ‘uuid’
[16:19:42.697]   - Field: ‘seed’
[16:19:42.697]   - Field: ‘version’
[16:19:42.697]   - Field: ‘result’
[16:19:42.697]   - Field: ‘asynchronous’
[16:19:42.697]   - Field: ‘calls’
[16:19:42.697]   - Field: ‘globals’
[16:19:42.697]   - Field: ‘stdout’
[16:19:42.698]   - Field: ‘earlySignal’
[16:19:42.698]   - Field: ‘lazy’
[16:19:42.698]   - Field: ‘state’
[16:19:42.698] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:42.698] - Launch lazy future ...
[16:19:42.698] Packages needed by the future expression (n = 0): <none>
[16:19:42.698] Packages needed by future strategies (n = 0): <none>
[16:19:42.699] {
[16:19:42.699]     {
[16:19:42.699]         {
[16:19:42.699]             ...future.startTime <- base::Sys.time()
[16:19:42.699]             {
[16:19:42.699]                 {
[16:19:42.699]                   {
[16:19:42.699]                     {
[16:19:42.699]                       base::local({
[16:19:42.699]                         has_future <- base::requireNamespace("future", 
[16:19:42.699]                           quietly = TRUE)
[16:19:42.699]                         if (has_future) {
[16:19:42.699]                           ns <- base::getNamespace("future")
[16:19:42.699]                           version <- ns[[".package"]][["version"]]
[16:19:42.699]                           if (is.null(version)) 
[16:19:42.699]                             version <- utils::packageVersion("future")
[16:19:42.699]                         }
[16:19:42.699]                         else {
[16:19:42.699]                           version <- NULL
[16:19:42.699]                         }
[16:19:42.699]                         if (!has_future || version < "1.8.0") {
[16:19:42.699]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:42.699]                             "", base::R.version$version.string), 
[16:19:42.699]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:42.699]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:42.699]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:42.699]                               "release", "version")], collapse = " "), 
[16:19:42.699]                             hostname = base::Sys.info()[["nodename"]])
[16:19:42.699]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:42.699]                             info)
[16:19:42.699]                           info <- base::paste(info, collapse = "; ")
[16:19:42.699]                           if (!has_future) {
[16:19:42.699]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:42.699]                               info)
[16:19:42.699]                           }
[16:19:42.699]                           else {
[16:19:42.699]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:42.699]                               info, version)
[16:19:42.699]                           }
[16:19:42.699]                           base::stop(msg)
[16:19:42.699]                         }
[16:19:42.699]                       })
[16:19:42.699]                     }
[16:19:42.699]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:42.699]                     base::options(mc.cores = 1L)
[16:19:42.699]                   }
[16:19:42.699]                   ...future.strategy.old <- future::plan("list")
[16:19:42.699]                   options(future.plan = NULL)
[16:19:42.699]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:42.699]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:42.699]                 }
[16:19:42.699]                 ...future.workdir <- getwd()
[16:19:42.699]             }
[16:19:42.699]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:42.699]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:42.699]         }
[16:19:42.699]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:42.699]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:42.699]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:42.699]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:42.699]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:42.699]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:42.699]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:42.699]             base::names(...future.oldOptions))
[16:19:42.699]     }
[16:19:42.699]     if (FALSE) {
[16:19:42.699]     }
[16:19:42.699]     else {
[16:19:42.699]         if (FALSE) {
[16:19:42.699]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:42.699]                 open = "w")
[16:19:42.699]         }
[16:19:42.699]         else {
[16:19:42.699]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:42.699]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:42.699]         }
[16:19:42.699]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:42.699]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:42.699]             base::sink(type = "output", split = FALSE)
[16:19:42.699]             base::close(...future.stdout)
[16:19:42.699]         }, add = TRUE)
[16:19:42.699]     }
[16:19:42.699]     ...future.frame <- base::sys.nframe()
[16:19:42.699]     ...future.conditions <- base::list()
[16:19:42.699]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:42.699]     if (FALSE) {
[16:19:42.699]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:42.699]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:42.699]     }
[16:19:42.699]     ...future.result <- base::tryCatch({
[16:19:42.699]         base::withCallingHandlers({
[16:19:42.699]             ...future.value <- base::withVisible(base::local({
[16:19:42.699]                 ...future.makeSendCondition <- base::local({
[16:19:42.699]                   sendCondition <- NULL
[16:19:42.699]                   function(frame = 1L) {
[16:19:42.699]                     if (is.function(sendCondition)) 
[16:19:42.699]                       return(sendCondition)
[16:19:42.699]                     ns <- getNamespace("parallel")
[16:19:42.699]                     if (exists("sendData", mode = "function", 
[16:19:42.699]                       envir = ns)) {
[16:19:42.699]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:42.699]                         envir = ns)
[16:19:42.699]                       envir <- sys.frame(frame)
[16:19:42.699]                       master <- NULL
[16:19:42.699]                       while (!identical(envir, .GlobalEnv) && 
[16:19:42.699]                         !identical(envir, emptyenv())) {
[16:19:42.699]                         if (exists("master", mode = "list", envir = envir, 
[16:19:42.699]                           inherits = FALSE)) {
[16:19:42.699]                           master <- get("master", mode = "list", 
[16:19:42.699]                             envir = envir, inherits = FALSE)
[16:19:42.699]                           if (inherits(master, c("SOCKnode", 
[16:19:42.699]                             "SOCK0node"))) {
[16:19:42.699]                             sendCondition <<- function(cond) {
[16:19:42.699]                               data <- list(type = "VALUE", value = cond, 
[16:19:42.699]                                 success = TRUE)
[16:19:42.699]                               parallel_sendData(master, data)
[16:19:42.699]                             }
[16:19:42.699]                             return(sendCondition)
[16:19:42.699]                           }
[16:19:42.699]                         }
[16:19:42.699]                         frame <- frame + 1L
[16:19:42.699]                         envir <- sys.frame(frame)
[16:19:42.699]                       }
[16:19:42.699]                     }
[16:19:42.699]                     sendCondition <<- function(cond) NULL
[16:19:42.699]                   }
[16:19:42.699]                 })
[16:19:42.699]                 withCallingHandlers({
[16:19:42.699]                   {
[16:19:42.699]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:42.699]                     if (!identical(...future.globals.maxSize.org, 
[16:19:42.699]                       ...future.globals.maxSize)) {
[16:19:42.699]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:42.699]                       on.exit(options(oopts), add = TRUE)
[16:19:42.699]                     }
[16:19:42.699]                     {
[16:19:42.699]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:42.699]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:42.699]                         USE.NAMES = FALSE)
[16:19:42.699]                       do.call(mapply, args = args)
[16:19:42.699]                     }
[16:19:42.699]                   }
[16:19:42.699]                 }, immediateCondition = function(cond) {
[16:19:42.699]                   sendCondition <- ...future.makeSendCondition()
[16:19:42.699]                   sendCondition(cond)
[16:19:42.699]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:42.699]                   {
[16:19:42.699]                     inherits <- base::inherits
[16:19:42.699]                     invokeRestart <- base::invokeRestart
[16:19:42.699]                     is.null <- base::is.null
[16:19:42.699]                     muffled <- FALSE
[16:19:42.699]                     if (inherits(cond, "message")) {
[16:19:42.699]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:42.699]                       if (muffled) 
[16:19:42.699]                         invokeRestart("muffleMessage")
[16:19:42.699]                     }
[16:19:42.699]                     else if (inherits(cond, "warning")) {
[16:19:42.699]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:42.699]                       if (muffled) 
[16:19:42.699]                         invokeRestart("muffleWarning")
[16:19:42.699]                     }
[16:19:42.699]                     else if (inherits(cond, "condition")) {
[16:19:42.699]                       if (!is.null(pattern)) {
[16:19:42.699]                         computeRestarts <- base::computeRestarts
[16:19:42.699]                         grepl <- base::grepl
[16:19:42.699]                         restarts <- computeRestarts(cond)
[16:19:42.699]                         for (restart in restarts) {
[16:19:42.699]                           name <- restart$name
[16:19:42.699]                           if (is.null(name)) 
[16:19:42.699]                             next
[16:19:42.699]                           if (!grepl(pattern, name)) 
[16:19:42.699]                             next
[16:19:42.699]                           invokeRestart(restart)
[16:19:42.699]                           muffled <- TRUE
[16:19:42.699]                           break
[16:19:42.699]                         }
[16:19:42.699]                       }
[16:19:42.699]                     }
[16:19:42.699]                     invisible(muffled)
[16:19:42.699]                   }
[16:19:42.699]                   muffleCondition(cond)
[16:19:42.699]                 })
[16:19:42.699]             }))
[16:19:42.699]             future::FutureResult(value = ...future.value$value, 
[16:19:42.699]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:42.699]                   ...future.rng), globalenv = if (FALSE) 
[16:19:42.699]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:42.699]                     ...future.globalenv.names))
[16:19:42.699]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:42.699]         }, condition = base::local({
[16:19:42.699]             c <- base::c
[16:19:42.699]             inherits <- base::inherits
[16:19:42.699]             invokeRestart <- base::invokeRestart
[16:19:42.699]             length <- base::length
[16:19:42.699]             list <- base::list
[16:19:42.699]             seq.int <- base::seq.int
[16:19:42.699]             signalCondition <- base::signalCondition
[16:19:42.699]             sys.calls <- base::sys.calls
[16:19:42.699]             `[[` <- base::`[[`
[16:19:42.699]             `+` <- base::`+`
[16:19:42.699]             `<<-` <- base::`<<-`
[16:19:42.699]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:42.699]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:42.699]                   3L)]
[16:19:42.699]             }
[16:19:42.699]             function(cond) {
[16:19:42.699]                 is_error <- inherits(cond, "error")
[16:19:42.699]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:42.699]                   NULL)
[16:19:42.699]                 if (is_error) {
[16:19:42.699]                   sessionInformation <- function() {
[16:19:42.699]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:42.699]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:42.699]                       search = base::search(), system = base::Sys.info())
[16:19:42.699]                   }
[16:19:42.699]                   ...future.conditions[[length(...future.conditions) + 
[16:19:42.699]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:42.699]                     cond$call), session = sessionInformation(), 
[16:19:42.699]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:42.699]                   signalCondition(cond)
[16:19:42.699]                 }
[16:19:42.699]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:42.699]                 "immediateCondition"))) {
[16:19:42.699]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:42.699]                   ...future.conditions[[length(...future.conditions) + 
[16:19:42.699]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:42.699]                   if (TRUE && !signal) {
[16:19:42.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:42.699]                     {
[16:19:42.699]                       inherits <- base::inherits
[16:19:42.699]                       invokeRestart <- base::invokeRestart
[16:19:42.699]                       is.null <- base::is.null
[16:19:42.699]                       muffled <- FALSE
[16:19:42.699]                       if (inherits(cond, "message")) {
[16:19:42.699]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:42.699]                         if (muffled) 
[16:19:42.699]                           invokeRestart("muffleMessage")
[16:19:42.699]                       }
[16:19:42.699]                       else if (inherits(cond, "warning")) {
[16:19:42.699]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:42.699]                         if (muffled) 
[16:19:42.699]                           invokeRestart("muffleWarning")
[16:19:42.699]                       }
[16:19:42.699]                       else if (inherits(cond, "condition")) {
[16:19:42.699]                         if (!is.null(pattern)) {
[16:19:42.699]                           computeRestarts <- base::computeRestarts
[16:19:42.699]                           grepl <- base::grepl
[16:19:42.699]                           restarts <- computeRestarts(cond)
[16:19:42.699]                           for (restart in restarts) {
[16:19:42.699]                             name <- restart$name
[16:19:42.699]                             if (is.null(name)) 
[16:19:42.699]                               next
[16:19:42.699]                             if (!grepl(pattern, name)) 
[16:19:42.699]                               next
[16:19:42.699]                             invokeRestart(restart)
[16:19:42.699]                             muffled <- TRUE
[16:19:42.699]                             break
[16:19:42.699]                           }
[16:19:42.699]                         }
[16:19:42.699]                       }
[16:19:42.699]                       invisible(muffled)
[16:19:42.699]                     }
[16:19:42.699]                     muffleCondition(cond, pattern = "^muffle")
[16:19:42.699]                   }
[16:19:42.699]                 }
[16:19:42.699]                 else {
[16:19:42.699]                   if (TRUE) {
[16:19:42.699]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:42.699]                     {
[16:19:42.699]                       inherits <- base::inherits
[16:19:42.699]                       invokeRestart <- base::invokeRestart
[16:19:42.699]                       is.null <- base::is.null
[16:19:42.699]                       muffled <- FALSE
[16:19:42.699]                       if (inherits(cond, "message")) {
[16:19:42.699]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:42.699]                         if (muffled) 
[16:19:42.699]                           invokeRestart("muffleMessage")
[16:19:42.699]                       }
[16:19:42.699]                       else if (inherits(cond, "warning")) {
[16:19:42.699]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:42.699]                         if (muffled) 
[16:19:42.699]                           invokeRestart("muffleWarning")
[16:19:42.699]                       }
[16:19:42.699]                       else if (inherits(cond, "condition")) {
[16:19:42.699]                         if (!is.null(pattern)) {
[16:19:42.699]                           computeRestarts <- base::computeRestarts
[16:19:42.699]                           grepl <- base::grepl
[16:19:42.699]                           restarts <- computeRestarts(cond)
[16:19:42.699]                           for (restart in restarts) {
[16:19:42.699]                             name <- restart$name
[16:19:42.699]                             if (is.null(name)) 
[16:19:42.699]                               next
[16:19:42.699]                             if (!grepl(pattern, name)) 
[16:19:42.699]                               next
[16:19:42.699]                             invokeRestart(restart)
[16:19:42.699]                             muffled <- TRUE
[16:19:42.699]                             break
[16:19:42.699]                           }
[16:19:42.699]                         }
[16:19:42.699]                       }
[16:19:42.699]                       invisible(muffled)
[16:19:42.699]                     }
[16:19:42.699]                     muffleCondition(cond, pattern = "^muffle")
[16:19:42.699]                   }
[16:19:42.699]                 }
[16:19:42.699]             }
[16:19:42.699]         }))
[16:19:42.699]     }, error = function(ex) {
[16:19:42.699]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:42.699]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:42.699]                 ...future.rng), started = ...future.startTime, 
[16:19:42.699]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:42.699]             version = "1.8"), class = "FutureResult")
[16:19:42.699]     }, finally = {
[16:19:42.699]         if (!identical(...future.workdir, getwd())) 
[16:19:42.699]             setwd(...future.workdir)
[16:19:42.699]         {
[16:19:42.699]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:42.699]                 ...future.oldOptions$nwarnings <- NULL
[16:19:42.699]             }
[16:19:42.699]             base::options(...future.oldOptions)
[16:19:42.699]             if (.Platform$OS.type == "windows") {
[16:19:42.699]                 old_names <- names(...future.oldEnvVars)
[16:19:42.699]                 envs <- base::Sys.getenv()
[16:19:42.699]                 names <- names(envs)
[16:19:42.699]                 common <- intersect(names, old_names)
[16:19:42.699]                 added <- setdiff(names, old_names)
[16:19:42.699]                 removed <- setdiff(old_names, names)
[16:19:42.699]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:42.699]                   envs[common]]
[16:19:42.699]                 NAMES <- toupper(changed)
[16:19:42.699]                 args <- list()
[16:19:42.699]                 for (kk in seq_along(NAMES)) {
[16:19:42.699]                   name <- changed[[kk]]
[16:19:42.699]                   NAME <- NAMES[[kk]]
[16:19:42.699]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:42.699]                     next
[16:19:42.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:42.699]                 }
[16:19:42.699]                 NAMES <- toupper(added)
[16:19:42.699]                 for (kk in seq_along(NAMES)) {
[16:19:42.699]                   name <- added[[kk]]
[16:19:42.699]                   NAME <- NAMES[[kk]]
[16:19:42.699]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:42.699]                     next
[16:19:42.699]                   args[[name]] <- ""
[16:19:42.699]                 }
[16:19:42.699]                 NAMES <- toupper(removed)
[16:19:42.699]                 for (kk in seq_along(NAMES)) {
[16:19:42.699]                   name <- removed[[kk]]
[16:19:42.699]                   NAME <- NAMES[[kk]]
[16:19:42.699]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:42.699]                     next
[16:19:42.699]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:42.699]                 }
[16:19:42.699]                 if (length(args) > 0) 
[16:19:42.699]                   base::do.call(base::Sys.setenv, args = args)
[16:19:42.699]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:42.699]             }
[16:19:42.699]             else {
[16:19:42.699]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:42.699]             }
[16:19:42.699]             {
[16:19:42.699]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:42.699]                   0L) {
[16:19:42.699]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:42.699]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:42.699]                   base::options(opts)
[16:19:42.699]                 }
[16:19:42.699]                 {
[16:19:42.699]                   {
[16:19:42.699]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:42.699]                     NULL
[16:19:42.699]                   }
[16:19:42.699]                   options(future.plan = NULL)
[16:19:42.699]                   if (is.na(NA_character_)) 
[16:19:42.699]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:42.699]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:42.699]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:42.699]                     .init = FALSE)
[16:19:42.699]                 }
[16:19:42.699]             }
[16:19:42.699]         }
[16:19:42.699]     })
[16:19:42.699]     if (TRUE) {
[16:19:42.699]         base::sink(type = "output", split = FALSE)
[16:19:42.699]         if (FALSE) {
[16:19:42.699]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:42.699]         }
[16:19:42.699]         else {
[16:19:42.699]             ...future.result["stdout"] <- base::list(NULL)
[16:19:42.699]         }
[16:19:42.699]         base::close(...future.stdout)
[16:19:42.699]         ...future.stdout <- NULL
[16:19:42.699]     }
[16:19:42.699]     ...future.result$conditions <- ...future.conditions
[16:19:42.699]     ...future.result$finished <- base::Sys.time()
[16:19:42.699]     ...future.result
[16:19:42.699] }
[16:19:42.701] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[16:19:42.702] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[16:19:42.702] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[16:19:42.702] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:19:42.703] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:19:42.703] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:19:42.703] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:19:42.703] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:42.704] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:42.704] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:42.704] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:42.704] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[16:19:42.705] MultisessionFuture started
[16:19:42.705] - Launch lazy future ... done
[16:19:42.705] run() for ‘MultisessionFuture’ ... done
[16:19:42.705] Created future:
[16:19:42.705] MultisessionFuture:
[16:19:42.705] Label: ‘future_mapply-2’
[16:19:42.705] Expression:
[16:19:42.705] {
[16:19:42.705]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:42.705]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:42.705]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:42.705]         on.exit(options(oopts), add = TRUE)
[16:19:42.705]     }
[16:19:42.705]     {
[16:19:42.705]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:42.705]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:42.705]         do.call(mapply, args = args)
[16:19:42.705]     }
[16:19:42.705] }
[16:19:42.705] Lazy evaluation: FALSE
[16:19:42.705] Asynchronous evaluation: TRUE
[16:19:42.705] Local evaluation: TRUE
[16:19:42.705] Environment: R_GlobalEnv
[16:19:42.705] Capture standard output: FALSE
[16:19:42.705] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:42.705] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:42.705] Packages: <none>
[16:19:42.705] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:42.705] Resolved: FALSE
[16:19:42.705] Value: <not collected>
[16:19:42.705] Conditions captured: <none>
[16:19:42.705] Early signaling: FALSE
[16:19:42.705] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:42.705] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:42.717] Chunk #2 of 2 ... DONE
[16:19:42.717] Launching 2 futures (chunks) ... DONE
[16:19:42.717] Resolving 2 futures (chunks) ...
[16:19:42.717] resolve() on list ...
[16:19:42.717]  recursive: 0
[16:19:42.717]  length: 2
[16:19:42.718] 
[16:19:42.760] receiveMessageFromWorker() for ClusterFuture ...
[16:19:42.760] - Validating connection of MultisessionFuture
[16:19:42.760] - received message: FutureResult
[16:19:42.760] - Received FutureResult
[16:19:42.761] - Erased future from FutureRegistry
[16:19:42.761] result() for ClusterFuture ...
[16:19:42.761] - result already collected: FutureResult
[16:19:42.761] result() for ClusterFuture ... done
[16:19:42.761] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:42.761] Future #2
[16:19:42.761] result() for ClusterFuture ...
[16:19:42.761] - result already collected: FutureResult
[16:19:42.761] result() for ClusterFuture ... done
[16:19:42.761] result() for ClusterFuture ...
[16:19:42.762] - result already collected: FutureResult
[16:19:42.762] result() for ClusterFuture ... done
[16:19:42.762] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:42.762] - nx: 2
[16:19:42.762] - relay: TRUE
[16:19:42.762] - stdout: TRUE
[16:19:42.762] - signal: TRUE
[16:19:42.762] - resignal: FALSE
[16:19:42.762] - force: TRUE
[16:19:42.762] - relayed: [n=2] FALSE, FALSE
[16:19:42.762] - queued futures: [n=2] FALSE, FALSE
[16:19:42.763]  - until=1
[16:19:42.763]  - relaying element #1
[16:19:42.763] - relayed: [n=2] FALSE, FALSE
[16:19:42.763] - queued futures: [n=2] FALSE, TRUE
[16:19:42.763] signalConditionsASAP(NULL, pos=2) ... done
[16:19:42.763]  length: 1 (resolved future 2)
[16:19:43.211] receiveMessageFromWorker() for ClusterFuture ...
[16:19:43.211] - Validating connection of MultisessionFuture
[16:19:43.211] - received message: FutureResult
[16:19:43.211] - Received FutureResult
[16:19:43.211] - Erased future from FutureRegistry
[16:19:43.212] result() for ClusterFuture ...
[16:19:43.212] - result already collected: FutureResult
[16:19:43.212] result() for ClusterFuture ... done
[16:19:43.212] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:43.212] Future #1
[16:19:43.212] result() for ClusterFuture ...
[16:19:43.212] - result already collected: FutureResult
[16:19:43.212] result() for ClusterFuture ... done
[16:19:43.212] result() for ClusterFuture ...
[16:19:43.212] - result already collected: FutureResult
[16:19:43.213] result() for ClusterFuture ... done
[16:19:43.213] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:43.213] - nx: 2
[16:19:43.213] - relay: TRUE
[16:19:43.213] - stdout: TRUE
[16:19:43.213] - signal: TRUE
[16:19:43.213] - resignal: FALSE
[16:19:43.213] - force: TRUE
[16:19:43.213] - relayed: [n=2] FALSE, FALSE
[16:19:43.213] - queued futures: [n=2] FALSE, TRUE
[16:19:43.213]  - until=1
[16:19:43.214]  - relaying element #1
[16:19:43.214] result() for ClusterFuture ...
[16:19:43.214] - result already collected: FutureResult
[16:19:43.214] result() for ClusterFuture ... done
[16:19:43.214] result() for ClusterFuture ...
[16:19:43.214] - result already collected: FutureResult
[16:19:43.214] result() for ClusterFuture ... done
[16:19:43.214] result() for ClusterFuture ...
[16:19:43.214] - result already collected: FutureResult
[16:19:43.214] result() for ClusterFuture ... done
[16:19:43.214] result() for ClusterFuture ...
[16:19:43.215] - result already collected: FutureResult
[16:19:43.215] result() for ClusterFuture ... done
[16:19:43.215] - relayed: [n=2] TRUE, FALSE
[16:19:43.215] - queued futures: [n=2] TRUE, TRUE
[16:19:43.215] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:43.215]  length: 0 (resolved future 1)
[16:19:43.215] Relaying remaining futures
[16:19:43.215] signalConditionsASAP(NULL, pos=0) ...
[16:19:43.215] - nx: 2
[16:19:43.215] - relay: TRUE
[16:19:43.215] - stdout: TRUE
[16:19:43.215] - signal: TRUE
[16:19:43.216] - resignal: FALSE
[16:19:43.216] - force: TRUE
[16:19:43.216] - relayed: [n=2] TRUE, FALSE
[16:19:43.216] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:43.216]  - relaying element #2
[16:19:43.216] result() for ClusterFuture ...
[16:19:43.216] - result already collected: FutureResult
[16:19:43.216] result() for ClusterFuture ... done
[16:19:43.216] result() for ClusterFuture ...
[16:19:43.216] - result already collected: FutureResult
[16:19:43.217] result() for ClusterFuture ... done
[16:19:43.217] result() for ClusterFuture ...
[16:19:43.217] - result already collected: FutureResult
[16:19:43.217] result() for ClusterFuture ... done
[16:19:43.217] result() for ClusterFuture ...
[16:19:43.217] - result already collected: FutureResult
[16:19:43.217] result() for ClusterFuture ... done
[16:19:43.217] - relayed: [n=2] TRUE, TRUE
[16:19:43.217] - queued futures: [n=2] TRUE, TRUE
[16:19:43.217] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:19:43.217] resolve() on list ... DONE
[16:19:43.218] result() for ClusterFuture ...
[16:19:43.218] - result already collected: FutureResult
[16:19:43.218] result() for ClusterFuture ... done
[16:19:43.218] result() for ClusterFuture ...
[16:19:43.218] - result already collected: FutureResult
[16:19:43.218] result() for ClusterFuture ... done
[16:19:43.218] result() for ClusterFuture ...
[16:19:43.218] - result already collected: FutureResult
[16:19:43.218] result() for ClusterFuture ... done
[16:19:43.218] result() for ClusterFuture ...
[16:19:43.218] - result already collected: FutureResult
[16:19:43.218] result() for ClusterFuture ... done
[16:19:43.219]  - Number of value chunks collected: 2
[16:19:43.219] Resolving 2 futures (chunks) ... DONE
[16:19:43.219] Reducing values from 2 chunks ...
[16:19:43.219]  - Number of values collected after concatenation: 2
[16:19:43.219]  - Number of values expected: 2
[16:19:43.219] Reducing values from 2 chunks ... DONE
[16:19:43.219] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = FALSE) ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ...
[16:19:43.220] future_mapply() ...
[16:19:43.224] Number of chunks: 2
[16:19:43.224] getGlobalsAndPackagesXApply() ...
[16:19:43.224]  - future.globals: TRUE
[16:19:43.224] getGlobalsAndPackages() ...
[16:19:43.224] Searching for globals...
[16:19:43.226] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:43.226] Searching for globals ... DONE
[16:19:43.226] Resolving globals: FALSE
[16:19:43.227] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:43.227] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:43.227] - globals: [1] ‘FUN’
[16:19:43.227] 
[16:19:43.227] getGlobalsAndPackages() ... DONE
[16:19:43.227]  - globals found/used: [n=1] ‘FUN’
[16:19:43.227]  - needed namespaces: [n=0] 
[16:19:43.228] Finding globals ... DONE
[16:19:43.228] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:43.228] List of 2
[16:19:43.228]  $ ...future.FUN:function (x, y)  
[16:19:43.228]  $ MoreArgs     : NULL
[16:19:43.228]  - attr(*, "where")=List of 2
[16:19:43.228]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:43.228]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:43.228]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:43.228]  - attr(*, "resolved")= logi FALSE
[16:19:43.228]  - attr(*, "total_size")= num NA
[16:19:43.230] Packages to be attached in all futures: [n=0] 
[16:19:43.231] getGlobalsAndPackagesXApply() ... DONE
[16:19:43.231] Number of futures (= number of chunks): 2
[16:19:43.231] Launching 2 futures (chunks) ...
[16:19:43.231] Chunk #1 of 2 ...
[16:19:43.231]  - Finding globals in '...' for chunk #1 ...
[16:19:43.231] getGlobalsAndPackages() ...
[16:19:43.231] Searching for globals...
[16:19:43.232] 
[16:19:43.232] Searching for globals ... DONE
[16:19:43.232] - globals: [0] <none>
[16:19:43.232] getGlobalsAndPackages() ... DONE
[16:19:43.232]    + additional globals found: [n=0] 
[16:19:43.232]    + additional namespaces needed: [n=0] 
[16:19:43.232]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:43.232]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:43.232]  - seeds: <none>
[16:19:43.232]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:43.233] getGlobalsAndPackages() ...
[16:19:43.233] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:43.233] Resolving globals: FALSE
[16:19:43.233] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:19:43.234] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:43.234] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:43.234] 
[16:19:43.234] getGlobalsAndPackages() ... DONE
[16:19:43.234] run() for ‘Future’ ...
[16:19:43.234] - state: ‘created’
[16:19:43.234] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:43.248] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:43.248] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:43.248]   - Field: ‘node’
[16:19:43.248]   - Field: ‘label’
[16:19:43.249]   - Field: ‘local’
[16:19:43.249]   - Field: ‘owner’
[16:19:43.249]   - Field: ‘envir’
[16:19:43.249]   - Field: ‘workers’
[16:19:43.249]   - Field: ‘packages’
[16:19:43.249]   - Field: ‘gc’
[16:19:43.249]   - Field: ‘conditions’
[16:19:43.249]   - Field: ‘persistent’
[16:19:43.249]   - Field: ‘expr’
[16:19:43.249]   - Field: ‘uuid’
[16:19:43.249]   - Field: ‘seed’
[16:19:43.250]   - Field: ‘version’
[16:19:43.250]   - Field: ‘result’
[16:19:43.250]   - Field: ‘asynchronous’
[16:19:43.250]   - Field: ‘calls’
[16:19:43.250]   - Field: ‘globals’
[16:19:43.250]   - Field: ‘stdout’
[16:19:43.250]   - Field: ‘earlySignal’
[16:19:43.250]   - Field: ‘lazy’
[16:19:43.250]   - Field: ‘state’
[16:19:43.250] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:43.250] - Launch lazy future ...
[16:19:43.251] Packages needed by the future expression (n = 0): <none>
[16:19:43.251] Packages needed by future strategies (n = 0): <none>
[16:19:43.251] {
[16:19:43.251]     {
[16:19:43.251]         {
[16:19:43.251]             ...future.startTime <- base::Sys.time()
[16:19:43.251]             {
[16:19:43.251]                 {
[16:19:43.251]                   {
[16:19:43.251]                     {
[16:19:43.251]                       base::local({
[16:19:43.251]                         has_future <- base::requireNamespace("future", 
[16:19:43.251]                           quietly = TRUE)
[16:19:43.251]                         if (has_future) {
[16:19:43.251]                           ns <- base::getNamespace("future")
[16:19:43.251]                           version <- ns[[".package"]][["version"]]
[16:19:43.251]                           if (is.null(version)) 
[16:19:43.251]                             version <- utils::packageVersion("future")
[16:19:43.251]                         }
[16:19:43.251]                         else {
[16:19:43.251]                           version <- NULL
[16:19:43.251]                         }
[16:19:43.251]                         if (!has_future || version < "1.8.0") {
[16:19:43.251]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:43.251]                             "", base::R.version$version.string), 
[16:19:43.251]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:43.251]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:43.251]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:43.251]                               "release", "version")], collapse = " "), 
[16:19:43.251]                             hostname = base::Sys.info()[["nodename"]])
[16:19:43.251]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:43.251]                             info)
[16:19:43.251]                           info <- base::paste(info, collapse = "; ")
[16:19:43.251]                           if (!has_future) {
[16:19:43.251]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:43.251]                               info)
[16:19:43.251]                           }
[16:19:43.251]                           else {
[16:19:43.251]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:43.251]                               info, version)
[16:19:43.251]                           }
[16:19:43.251]                           base::stop(msg)
[16:19:43.251]                         }
[16:19:43.251]                       })
[16:19:43.251]                     }
[16:19:43.251]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:43.251]                     base::options(mc.cores = 1L)
[16:19:43.251]                   }
[16:19:43.251]                   ...future.strategy.old <- future::plan("list")
[16:19:43.251]                   options(future.plan = NULL)
[16:19:43.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:43.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:43.251]                 }
[16:19:43.251]                 ...future.workdir <- getwd()
[16:19:43.251]             }
[16:19:43.251]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:43.251]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:43.251]         }
[16:19:43.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:43.251]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:43.251]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:43.251]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:43.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:43.251]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:43.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:43.251]             base::names(...future.oldOptions))
[16:19:43.251]     }
[16:19:43.251]     if (FALSE) {
[16:19:43.251]     }
[16:19:43.251]     else {
[16:19:43.251]         if (TRUE) {
[16:19:43.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:43.251]                 open = "w")
[16:19:43.251]         }
[16:19:43.251]         else {
[16:19:43.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:43.251]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:43.251]         }
[16:19:43.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:43.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:43.251]             base::sink(type = "output", split = FALSE)
[16:19:43.251]             base::close(...future.stdout)
[16:19:43.251]         }, add = TRUE)
[16:19:43.251]     }
[16:19:43.251]     ...future.frame <- base::sys.nframe()
[16:19:43.251]     ...future.conditions <- base::list()
[16:19:43.251]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:43.251]     if (FALSE) {
[16:19:43.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:43.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:43.251]     }
[16:19:43.251]     ...future.result <- base::tryCatch({
[16:19:43.251]         base::withCallingHandlers({
[16:19:43.251]             ...future.value <- base::withVisible(base::local({
[16:19:43.251]                 ...future.makeSendCondition <- base::local({
[16:19:43.251]                   sendCondition <- NULL
[16:19:43.251]                   function(frame = 1L) {
[16:19:43.251]                     if (is.function(sendCondition)) 
[16:19:43.251]                       return(sendCondition)
[16:19:43.251]                     ns <- getNamespace("parallel")
[16:19:43.251]                     if (exists("sendData", mode = "function", 
[16:19:43.251]                       envir = ns)) {
[16:19:43.251]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:43.251]                         envir = ns)
[16:19:43.251]                       envir <- sys.frame(frame)
[16:19:43.251]                       master <- NULL
[16:19:43.251]                       while (!identical(envir, .GlobalEnv) && 
[16:19:43.251]                         !identical(envir, emptyenv())) {
[16:19:43.251]                         if (exists("master", mode = "list", envir = envir, 
[16:19:43.251]                           inherits = FALSE)) {
[16:19:43.251]                           master <- get("master", mode = "list", 
[16:19:43.251]                             envir = envir, inherits = FALSE)
[16:19:43.251]                           if (inherits(master, c("SOCKnode", 
[16:19:43.251]                             "SOCK0node"))) {
[16:19:43.251]                             sendCondition <<- function(cond) {
[16:19:43.251]                               data <- list(type = "VALUE", value = cond, 
[16:19:43.251]                                 success = TRUE)
[16:19:43.251]                               parallel_sendData(master, data)
[16:19:43.251]                             }
[16:19:43.251]                             return(sendCondition)
[16:19:43.251]                           }
[16:19:43.251]                         }
[16:19:43.251]                         frame <- frame + 1L
[16:19:43.251]                         envir <- sys.frame(frame)
[16:19:43.251]                       }
[16:19:43.251]                     }
[16:19:43.251]                     sendCondition <<- function(cond) NULL
[16:19:43.251]                   }
[16:19:43.251]                 })
[16:19:43.251]                 withCallingHandlers({
[16:19:43.251]                   {
[16:19:43.251]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:43.251]                     if (!identical(...future.globals.maxSize.org, 
[16:19:43.251]                       ...future.globals.maxSize)) {
[16:19:43.251]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:43.251]                       on.exit(options(oopts), add = TRUE)
[16:19:43.251]                     }
[16:19:43.251]                     {
[16:19:43.251]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:43.251]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:43.251]                         USE.NAMES = FALSE)
[16:19:43.251]                       do.call(mapply, args = args)
[16:19:43.251]                     }
[16:19:43.251]                   }
[16:19:43.251]                 }, immediateCondition = function(cond) {
[16:19:43.251]                   sendCondition <- ...future.makeSendCondition()
[16:19:43.251]                   sendCondition(cond)
[16:19:43.251]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:43.251]                   {
[16:19:43.251]                     inherits <- base::inherits
[16:19:43.251]                     invokeRestart <- base::invokeRestart
[16:19:43.251]                     is.null <- base::is.null
[16:19:43.251]                     muffled <- FALSE
[16:19:43.251]                     if (inherits(cond, "message")) {
[16:19:43.251]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:43.251]                       if (muffled) 
[16:19:43.251]                         invokeRestart("muffleMessage")
[16:19:43.251]                     }
[16:19:43.251]                     else if (inherits(cond, "warning")) {
[16:19:43.251]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:43.251]                       if (muffled) 
[16:19:43.251]                         invokeRestart("muffleWarning")
[16:19:43.251]                     }
[16:19:43.251]                     else if (inherits(cond, "condition")) {
[16:19:43.251]                       if (!is.null(pattern)) {
[16:19:43.251]                         computeRestarts <- base::computeRestarts
[16:19:43.251]                         grepl <- base::grepl
[16:19:43.251]                         restarts <- computeRestarts(cond)
[16:19:43.251]                         for (restart in restarts) {
[16:19:43.251]                           name <- restart$name
[16:19:43.251]                           if (is.null(name)) 
[16:19:43.251]                             next
[16:19:43.251]                           if (!grepl(pattern, name)) 
[16:19:43.251]                             next
[16:19:43.251]                           invokeRestart(restart)
[16:19:43.251]                           muffled <- TRUE
[16:19:43.251]                           break
[16:19:43.251]                         }
[16:19:43.251]                       }
[16:19:43.251]                     }
[16:19:43.251]                     invisible(muffled)
[16:19:43.251]                   }
[16:19:43.251]                   muffleCondition(cond)
[16:19:43.251]                 })
[16:19:43.251]             }))
[16:19:43.251]             future::FutureResult(value = ...future.value$value, 
[16:19:43.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:43.251]                   ...future.rng), globalenv = if (FALSE) 
[16:19:43.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:43.251]                     ...future.globalenv.names))
[16:19:43.251]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:43.251]         }, condition = base::local({
[16:19:43.251]             c <- base::c
[16:19:43.251]             inherits <- base::inherits
[16:19:43.251]             invokeRestart <- base::invokeRestart
[16:19:43.251]             length <- base::length
[16:19:43.251]             list <- base::list
[16:19:43.251]             seq.int <- base::seq.int
[16:19:43.251]             signalCondition <- base::signalCondition
[16:19:43.251]             sys.calls <- base::sys.calls
[16:19:43.251]             `[[` <- base::`[[`
[16:19:43.251]             `+` <- base::`+`
[16:19:43.251]             `<<-` <- base::`<<-`
[16:19:43.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:43.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:43.251]                   3L)]
[16:19:43.251]             }
[16:19:43.251]             function(cond) {
[16:19:43.251]                 is_error <- inherits(cond, "error")
[16:19:43.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:43.251]                   NULL)
[16:19:43.251]                 if (is_error) {
[16:19:43.251]                   sessionInformation <- function() {
[16:19:43.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:43.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:43.251]                       search = base::search(), system = base::Sys.info())
[16:19:43.251]                   }
[16:19:43.251]                   ...future.conditions[[length(...future.conditions) + 
[16:19:43.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:43.251]                     cond$call), session = sessionInformation(), 
[16:19:43.251]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:43.251]                   signalCondition(cond)
[16:19:43.251]                 }
[16:19:43.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:43.251]                 "immediateCondition"))) {
[16:19:43.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:43.251]                   ...future.conditions[[length(...future.conditions) + 
[16:19:43.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:43.251]                   if (TRUE && !signal) {
[16:19:43.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:43.251]                     {
[16:19:43.251]                       inherits <- base::inherits
[16:19:43.251]                       invokeRestart <- base::invokeRestart
[16:19:43.251]                       is.null <- base::is.null
[16:19:43.251]                       muffled <- FALSE
[16:19:43.251]                       if (inherits(cond, "message")) {
[16:19:43.251]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:43.251]                         if (muffled) 
[16:19:43.251]                           invokeRestart("muffleMessage")
[16:19:43.251]                       }
[16:19:43.251]                       else if (inherits(cond, "warning")) {
[16:19:43.251]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:43.251]                         if (muffled) 
[16:19:43.251]                           invokeRestart("muffleWarning")
[16:19:43.251]                       }
[16:19:43.251]                       else if (inherits(cond, "condition")) {
[16:19:43.251]                         if (!is.null(pattern)) {
[16:19:43.251]                           computeRestarts <- base::computeRestarts
[16:19:43.251]                           grepl <- base::grepl
[16:19:43.251]                           restarts <- computeRestarts(cond)
[16:19:43.251]                           for (restart in restarts) {
[16:19:43.251]                             name <- restart$name
[16:19:43.251]                             if (is.null(name)) 
[16:19:43.251]                               next
[16:19:43.251]                             if (!grepl(pattern, name)) 
[16:19:43.251]                               next
[16:19:43.251]                             invokeRestart(restart)
[16:19:43.251]                             muffled <- TRUE
[16:19:43.251]                             break
[16:19:43.251]                           }
[16:19:43.251]                         }
[16:19:43.251]                       }
[16:19:43.251]                       invisible(muffled)
[16:19:43.251]                     }
[16:19:43.251]                     muffleCondition(cond, pattern = "^muffle")
[16:19:43.251]                   }
[16:19:43.251]                 }
[16:19:43.251]                 else {
[16:19:43.251]                   if (TRUE) {
[16:19:43.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:43.251]                     {
[16:19:43.251]                       inherits <- base::inherits
[16:19:43.251]                       invokeRestart <- base::invokeRestart
[16:19:43.251]                       is.null <- base::is.null
[16:19:43.251]                       muffled <- FALSE
[16:19:43.251]                       if (inherits(cond, "message")) {
[16:19:43.251]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:43.251]                         if (muffled) 
[16:19:43.251]                           invokeRestart("muffleMessage")
[16:19:43.251]                       }
[16:19:43.251]                       else if (inherits(cond, "warning")) {
[16:19:43.251]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:43.251]                         if (muffled) 
[16:19:43.251]                           invokeRestart("muffleWarning")
[16:19:43.251]                       }
[16:19:43.251]                       else if (inherits(cond, "condition")) {
[16:19:43.251]                         if (!is.null(pattern)) {
[16:19:43.251]                           computeRestarts <- base::computeRestarts
[16:19:43.251]                           grepl <- base::grepl
[16:19:43.251]                           restarts <- computeRestarts(cond)
[16:19:43.251]                           for (restart in restarts) {
[16:19:43.251]                             name <- restart$name
[16:19:43.251]                             if (is.null(name)) 
[16:19:43.251]                               next
[16:19:43.251]                             if (!grepl(pattern, name)) 
[16:19:43.251]                               next
[16:19:43.251]                             invokeRestart(restart)
[16:19:43.251]                             muffled <- TRUE
[16:19:43.251]                             break
[16:19:43.251]                           }
[16:19:43.251]                         }
[16:19:43.251]                       }
[16:19:43.251]                       invisible(muffled)
[16:19:43.251]                     }
[16:19:43.251]                     muffleCondition(cond, pattern = "^muffle")
[16:19:43.251]                   }
[16:19:43.251]                 }
[16:19:43.251]             }
[16:19:43.251]         }))
[16:19:43.251]     }, error = function(ex) {
[16:19:43.251]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:43.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:43.251]                 ...future.rng), started = ...future.startTime, 
[16:19:43.251]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:43.251]             version = "1.8"), class = "FutureResult")
[16:19:43.251]     }, finally = {
[16:19:43.251]         if (!identical(...future.workdir, getwd())) 
[16:19:43.251]             setwd(...future.workdir)
[16:19:43.251]         {
[16:19:43.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:43.251]                 ...future.oldOptions$nwarnings <- NULL
[16:19:43.251]             }
[16:19:43.251]             base::options(...future.oldOptions)
[16:19:43.251]             if (.Platform$OS.type == "windows") {
[16:19:43.251]                 old_names <- names(...future.oldEnvVars)
[16:19:43.251]                 envs <- base::Sys.getenv()
[16:19:43.251]                 names <- names(envs)
[16:19:43.251]                 common <- intersect(names, old_names)
[16:19:43.251]                 added <- setdiff(names, old_names)
[16:19:43.251]                 removed <- setdiff(old_names, names)
[16:19:43.251]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:43.251]                   envs[common]]
[16:19:43.251]                 NAMES <- toupper(changed)
[16:19:43.251]                 args <- list()
[16:19:43.251]                 for (kk in seq_along(NAMES)) {
[16:19:43.251]                   name <- changed[[kk]]
[16:19:43.251]                   NAME <- NAMES[[kk]]
[16:19:43.251]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:43.251]                     next
[16:19:43.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:43.251]                 }
[16:19:43.251]                 NAMES <- toupper(added)
[16:19:43.251]                 for (kk in seq_along(NAMES)) {
[16:19:43.251]                   name <- added[[kk]]
[16:19:43.251]                   NAME <- NAMES[[kk]]
[16:19:43.251]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:43.251]                     next
[16:19:43.251]                   args[[name]] <- ""
[16:19:43.251]                 }
[16:19:43.251]                 NAMES <- toupper(removed)
[16:19:43.251]                 for (kk in seq_along(NAMES)) {
[16:19:43.251]                   name <- removed[[kk]]
[16:19:43.251]                   NAME <- NAMES[[kk]]
[16:19:43.251]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:43.251]                     next
[16:19:43.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:43.251]                 }
[16:19:43.251]                 if (length(args) > 0) 
[16:19:43.251]                   base::do.call(base::Sys.setenv, args = args)
[16:19:43.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:43.251]             }
[16:19:43.251]             else {
[16:19:43.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:43.251]             }
[16:19:43.251]             {
[16:19:43.251]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:43.251]                   0L) {
[16:19:43.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:43.251]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:43.251]                   base::options(opts)
[16:19:43.251]                 }
[16:19:43.251]                 {
[16:19:43.251]                   {
[16:19:43.251]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:43.251]                     NULL
[16:19:43.251]                   }
[16:19:43.251]                   options(future.plan = NULL)
[16:19:43.251]                   if (is.na(NA_character_)) 
[16:19:43.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:43.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:43.251]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:43.251]                     .init = FALSE)
[16:19:43.251]                 }
[16:19:43.251]             }
[16:19:43.251]         }
[16:19:43.251]     })
[16:19:43.251]     if (TRUE) {
[16:19:43.251]         base::sink(type = "output", split = FALSE)
[16:19:43.251]         if (TRUE) {
[16:19:43.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:43.251]         }
[16:19:43.251]         else {
[16:19:43.251]             ...future.result["stdout"] <- base::list(NULL)
[16:19:43.251]         }
[16:19:43.251]         base::close(...future.stdout)
[16:19:43.251]         ...future.stdout <- NULL
[16:19:43.251]     }
[16:19:43.251]     ...future.result$conditions <- ...future.conditions
[16:19:43.251]     ...future.result$finished <- base::Sys.time()
[16:19:43.251]     ...future.result
[16:19:43.251] }
[16:19:43.254] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[16:19:43.254] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[16:19:43.255] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[16:19:43.255] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:19:43.255] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:19:43.255] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:19:43.256] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:19:43.256] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:43.256] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:43.256] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:43.257] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:43.257] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[16:19:43.257] MultisessionFuture started
[16:19:43.257] - Launch lazy future ... done
[16:19:43.258] run() for ‘MultisessionFuture’ ... done
[16:19:43.258] Created future:
[16:19:43.258] MultisessionFuture:
[16:19:43.258] Label: ‘future_mapply-1’
[16:19:43.258] Expression:
[16:19:43.258] {
[16:19:43.258]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:43.258]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:43.258]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:43.258]         on.exit(options(oopts), add = TRUE)
[16:19:43.258]     }
[16:19:43.258]     {
[16:19:43.258]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:43.258]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:43.258]         do.call(mapply, args = args)
[16:19:43.258]     }
[16:19:43.258] }
[16:19:43.258] Lazy evaluation: FALSE
[16:19:43.258] Asynchronous evaluation: TRUE
[16:19:43.258] Local evaluation: TRUE
[16:19:43.258] Environment: R_GlobalEnv
[16:19:43.258] Capture standard output: TRUE
[16:19:43.258] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:43.258] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:43.258] Packages: <none>
[16:19:43.258] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:43.258] Resolved: FALSE
[16:19:43.258] Value: <not collected>
[16:19:43.258] Conditions captured: <none>
[16:19:43.258] Early signaling: FALSE
[16:19:43.258] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:43.258] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:43.269] Chunk #1 of 2 ... DONE
[16:19:43.269] Chunk #2 of 2 ...
[16:19:43.270]  - Finding globals in '...' for chunk #2 ...
[16:19:43.270] getGlobalsAndPackages() ...
[16:19:43.270] Searching for globals...
[16:19:43.270] 
[16:19:43.270] Searching for globals ... DONE
[16:19:43.270] - globals: [0] <none>
[16:19:43.270] getGlobalsAndPackages() ... DONE
[16:19:43.271]    + additional globals found: [n=0] 
[16:19:43.271]    + additional namespaces needed: [n=0] 
[16:19:43.271]  - Finding globals in '...' for chunk #2 ... DONE
[16:19:43.271]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:43.271]  - seeds: <none>
[16:19:43.271]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:43.271] getGlobalsAndPackages() ...
[16:19:43.271] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:43.271] Resolving globals: FALSE
[16:19:43.272] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:19:43.272] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:43.272] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:43.273] 
[16:19:43.273] getGlobalsAndPackages() ... DONE
[16:19:43.273] run() for ‘Future’ ...
[16:19:43.273] - state: ‘created’
[16:19:43.273] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:43.289] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:43.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:43.290]   - Field: ‘node’
[16:19:43.290]   - Field: ‘label’
[16:19:43.290]   - Field: ‘local’
[16:19:43.290]   - Field: ‘owner’
[16:19:43.290]   - Field: ‘envir’
[16:19:43.290]   - Field: ‘workers’
[16:19:43.290]   - Field: ‘packages’
[16:19:43.290]   - Field: ‘gc’
[16:19:43.290]   - Field: ‘conditions’
[16:19:43.290]   - Field: ‘persistent’
[16:19:43.291]   - Field: ‘expr’
[16:19:43.291]   - Field: ‘uuid’
[16:19:43.291]   - Field: ‘seed’
[16:19:43.291]   - Field: ‘version’
[16:19:43.291]   - Field: ‘result’
[16:19:43.291]   - Field: ‘asynchronous’
[16:19:43.291]   - Field: ‘calls’
[16:19:43.291]   - Field: ‘globals’
[16:19:43.291]   - Field: ‘stdout’
[16:19:43.291]   - Field: ‘earlySignal’
[16:19:43.291]   - Field: ‘lazy’
[16:19:43.292]   - Field: ‘state’
[16:19:43.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:43.292] - Launch lazy future ...
[16:19:43.292] Packages needed by the future expression (n = 0): <none>
[16:19:43.292] Packages needed by future strategies (n = 0): <none>
[16:19:43.293] {
[16:19:43.293]     {
[16:19:43.293]         {
[16:19:43.293]             ...future.startTime <- base::Sys.time()
[16:19:43.293]             {
[16:19:43.293]                 {
[16:19:43.293]                   {
[16:19:43.293]                     {
[16:19:43.293]                       base::local({
[16:19:43.293]                         has_future <- base::requireNamespace("future", 
[16:19:43.293]                           quietly = TRUE)
[16:19:43.293]                         if (has_future) {
[16:19:43.293]                           ns <- base::getNamespace("future")
[16:19:43.293]                           version <- ns[[".package"]][["version"]]
[16:19:43.293]                           if (is.null(version)) 
[16:19:43.293]                             version <- utils::packageVersion("future")
[16:19:43.293]                         }
[16:19:43.293]                         else {
[16:19:43.293]                           version <- NULL
[16:19:43.293]                         }
[16:19:43.293]                         if (!has_future || version < "1.8.0") {
[16:19:43.293]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:43.293]                             "", base::R.version$version.string), 
[16:19:43.293]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:43.293]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:43.293]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:43.293]                               "release", "version")], collapse = " "), 
[16:19:43.293]                             hostname = base::Sys.info()[["nodename"]])
[16:19:43.293]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:43.293]                             info)
[16:19:43.293]                           info <- base::paste(info, collapse = "; ")
[16:19:43.293]                           if (!has_future) {
[16:19:43.293]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:43.293]                               info)
[16:19:43.293]                           }
[16:19:43.293]                           else {
[16:19:43.293]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:43.293]                               info, version)
[16:19:43.293]                           }
[16:19:43.293]                           base::stop(msg)
[16:19:43.293]                         }
[16:19:43.293]                       })
[16:19:43.293]                     }
[16:19:43.293]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:43.293]                     base::options(mc.cores = 1L)
[16:19:43.293]                   }
[16:19:43.293]                   ...future.strategy.old <- future::plan("list")
[16:19:43.293]                   options(future.plan = NULL)
[16:19:43.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:43.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:43.293]                 }
[16:19:43.293]                 ...future.workdir <- getwd()
[16:19:43.293]             }
[16:19:43.293]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:43.293]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:43.293]         }
[16:19:43.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:43.293]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:43.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:43.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:43.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:43.293]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:43.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:43.293]             base::names(...future.oldOptions))
[16:19:43.293]     }
[16:19:43.293]     if (FALSE) {
[16:19:43.293]     }
[16:19:43.293]     else {
[16:19:43.293]         if (TRUE) {
[16:19:43.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:43.293]                 open = "w")
[16:19:43.293]         }
[16:19:43.293]         else {
[16:19:43.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:43.293]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:43.293]         }
[16:19:43.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:43.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:43.293]             base::sink(type = "output", split = FALSE)
[16:19:43.293]             base::close(...future.stdout)
[16:19:43.293]         }, add = TRUE)
[16:19:43.293]     }
[16:19:43.293]     ...future.frame <- base::sys.nframe()
[16:19:43.293]     ...future.conditions <- base::list()
[16:19:43.293]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:43.293]     if (FALSE) {
[16:19:43.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:43.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:43.293]     }
[16:19:43.293]     ...future.result <- base::tryCatch({
[16:19:43.293]         base::withCallingHandlers({
[16:19:43.293]             ...future.value <- base::withVisible(base::local({
[16:19:43.293]                 ...future.makeSendCondition <- base::local({
[16:19:43.293]                   sendCondition <- NULL
[16:19:43.293]                   function(frame = 1L) {
[16:19:43.293]                     if (is.function(sendCondition)) 
[16:19:43.293]                       return(sendCondition)
[16:19:43.293]                     ns <- getNamespace("parallel")
[16:19:43.293]                     if (exists("sendData", mode = "function", 
[16:19:43.293]                       envir = ns)) {
[16:19:43.293]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:43.293]                         envir = ns)
[16:19:43.293]                       envir <- sys.frame(frame)
[16:19:43.293]                       master <- NULL
[16:19:43.293]                       while (!identical(envir, .GlobalEnv) && 
[16:19:43.293]                         !identical(envir, emptyenv())) {
[16:19:43.293]                         if (exists("master", mode = "list", envir = envir, 
[16:19:43.293]                           inherits = FALSE)) {
[16:19:43.293]                           master <- get("master", mode = "list", 
[16:19:43.293]                             envir = envir, inherits = FALSE)
[16:19:43.293]                           if (inherits(master, c("SOCKnode", 
[16:19:43.293]                             "SOCK0node"))) {
[16:19:43.293]                             sendCondition <<- function(cond) {
[16:19:43.293]                               data <- list(type = "VALUE", value = cond, 
[16:19:43.293]                                 success = TRUE)
[16:19:43.293]                               parallel_sendData(master, data)
[16:19:43.293]                             }
[16:19:43.293]                             return(sendCondition)
[16:19:43.293]                           }
[16:19:43.293]                         }
[16:19:43.293]                         frame <- frame + 1L
[16:19:43.293]                         envir <- sys.frame(frame)
[16:19:43.293]                       }
[16:19:43.293]                     }
[16:19:43.293]                     sendCondition <<- function(cond) NULL
[16:19:43.293]                   }
[16:19:43.293]                 })
[16:19:43.293]                 withCallingHandlers({
[16:19:43.293]                   {
[16:19:43.293]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:43.293]                     if (!identical(...future.globals.maxSize.org, 
[16:19:43.293]                       ...future.globals.maxSize)) {
[16:19:43.293]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:43.293]                       on.exit(options(oopts), add = TRUE)
[16:19:43.293]                     }
[16:19:43.293]                     {
[16:19:43.293]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:43.293]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:43.293]                         USE.NAMES = FALSE)
[16:19:43.293]                       do.call(mapply, args = args)
[16:19:43.293]                     }
[16:19:43.293]                   }
[16:19:43.293]                 }, immediateCondition = function(cond) {
[16:19:43.293]                   sendCondition <- ...future.makeSendCondition()
[16:19:43.293]                   sendCondition(cond)
[16:19:43.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:43.293]                   {
[16:19:43.293]                     inherits <- base::inherits
[16:19:43.293]                     invokeRestart <- base::invokeRestart
[16:19:43.293]                     is.null <- base::is.null
[16:19:43.293]                     muffled <- FALSE
[16:19:43.293]                     if (inherits(cond, "message")) {
[16:19:43.293]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:43.293]                       if (muffled) 
[16:19:43.293]                         invokeRestart("muffleMessage")
[16:19:43.293]                     }
[16:19:43.293]                     else if (inherits(cond, "warning")) {
[16:19:43.293]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:43.293]                       if (muffled) 
[16:19:43.293]                         invokeRestart("muffleWarning")
[16:19:43.293]                     }
[16:19:43.293]                     else if (inherits(cond, "condition")) {
[16:19:43.293]                       if (!is.null(pattern)) {
[16:19:43.293]                         computeRestarts <- base::computeRestarts
[16:19:43.293]                         grepl <- base::grepl
[16:19:43.293]                         restarts <- computeRestarts(cond)
[16:19:43.293]                         for (restart in restarts) {
[16:19:43.293]                           name <- restart$name
[16:19:43.293]                           if (is.null(name)) 
[16:19:43.293]                             next
[16:19:43.293]                           if (!grepl(pattern, name)) 
[16:19:43.293]                             next
[16:19:43.293]                           invokeRestart(restart)
[16:19:43.293]                           muffled <- TRUE
[16:19:43.293]                           break
[16:19:43.293]                         }
[16:19:43.293]                       }
[16:19:43.293]                     }
[16:19:43.293]                     invisible(muffled)
[16:19:43.293]                   }
[16:19:43.293]                   muffleCondition(cond)
[16:19:43.293]                 })
[16:19:43.293]             }))
[16:19:43.293]             future::FutureResult(value = ...future.value$value, 
[16:19:43.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:43.293]                   ...future.rng), globalenv = if (FALSE) 
[16:19:43.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:43.293]                     ...future.globalenv.names))
[16:19:43.293]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:43.293]         }, condition = base::local({
[16:19:43.293]             c <- base::c
[16:19:43.293]             inherits <- base::inherits
[16:19:43.293]             invokeRestart <- base::invokeRestart
[16:19:43.293]             length <- base::length
[16:19:43.293]             list <- base::list
[16:19:43.293]             seq.int <- base::seq.int
[16:19:43.293]             signalCondition <- base::signalCondition
[16:19:43.293]             sys.calls <- base::sys.calls
[16:19:43.293]             `[[` <- base::`[[`
[16:19:43.293]             `+` <- base::`+`
[16:19:43.293]             `<<-` <- base::`<<-`
[16:19:43.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:43.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:43.293]                   3L)]
[16:19:43.293]             }
[16:19:43.293]             function(cond) {
[16:19:43.293]                 is_error <- inherits(cond, "error")
[16:19:43.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:43.293]                   NULL)
[16:19:43.293]                 if (is_error) {
[16:19:43.293]                   sessionInformation <- function() {
[16:19:43.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:43.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:43.293]                       search = base::search(), system = base::Sys.info())
[16:19:43.293]                   }
[16:19:43.293]                   ...future.conditions[[length(...future.conditions) + 
[16:19:43.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:43.293]                     cond$call), session = sessionInformation(), 
[16:19:43.293]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:43.293]                   signalCondition(cond)
[16:19:43.293]                 }
[16:19:43.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:43.293]                 "immediateCondition"))) {
[16:19:43.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:43.293]                   ...future.conditions[[length(...future.conditions) + 
[16:19:43.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:43.293]                   if (TRUE && !signal) {
[16:19:43.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:43.293]                     {
[16:19:43.293]                       inherits <- base::inherits
[16:19:43.293]                       invokeRestart <- base::invokeRestart
[16:19:43.293]                       is.null <- base::is.null
[16:19:43.293]                       muffled <- FALSE
[16:19:43.293]                       if (inherits(cond, "message")) {
[16:19:43.293]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:43.293]                         if (muffled) 
[16:19:43.293]                           invokeRestart("muffleMessage")
[16:19:43.293]                       }
[16:19:43.293]                       else if (inherits(cond, "warning")) {
[16:19:43.293]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:43.293]                         if (muffled) 
[16:19:43.293]                           invokeRestart("muffleWarning")
[16:19:43.293]                       }
[16:19:43.293]                       else if (inherits(cond, "condition")) {
[16:19:43.293]                         if (!is.null(pattern)) {
[16:19:43.293]                           computeRestarts <- base::computeRestarts
[16:19:43.293]                           grepl <- base::grepl
[16:19:43.293]                           restarts <- computeRestarts(cond)
[16:19:43.293]                           for (restart in restarts) {
[16:19:43.293]                             name <- restart$name
[16:19:43.293]                             if (is.null(name)) 
[16:19:43.293]                               next
[16:19:43.293]                             if (!grepl(pattern, name)) 
[16:19:43.293]                               next
[16:19:43.293]                             invokeRestart(restart)
[16:19:43.293]                             muffled <- TRUE
[16:19:43.293]                             break
[16:19:43.293]                           }
[16:19:43.293]                         }
[16:19:43.293]                       }
[16:19:43.293]                       invisible(muffled)
[16:19:43.293]                     }
[16:19:43.293]                     muffleCondition(cond, pattern = "^muffle")
[16:19:43.293]                   }
[16:19:43.293]                 }
[16:19:43.293]                 else {
[16:19:43.293]                   if (TRUE) {
[16:19:43.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:43.293]                     {
[16:19:43.293]                       inherits <- base::inherits
[16:19:43.293]                       invokeRestart <- base::invokeRestart
[16:19:43.293]                       is.null <- base::is.null
[16:19:43.293]                       muffled <- FALSE
[16:19:43.293]                       if (inherits(cond, "message")) {
[16:19:43.293]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:43.293]                         if (muffled) 
[16:19:43.293]                           invokeRestart("muffleMessage")
[16:19:43.293]                       }
[16:19:43.293]                       else if (inherits(cond, "warning")) {
[16:19:43.293]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:43.293]                         if (muffled) 
[16:19:43.293]                           invokeRestart("muffleWarning")
[16:19:43.293]                       }
[16:19:43.293]                       else if (inherits(cond, "condition")) {
[16:19:43.293]                         if (!is.null(pattern)) {
[16:19:43.293]                           computeRestarts <- base::computeRestarts
[16:19:43.293]                           grepl <- base::grepl
[16:19:43.293]                           restarts <- computeRestarts(cond)
[16:19:43.293]                           for (restart in restarts) {
[16:19:43.293]                             name <- restart$name
[16:19:43.293]                             if (is.null(name)) 
[16:19:43.293]                               next
[16:19:43.293]                             if (!grepl(pattern, name)) 
[16:19:43.293]                               next
[16:19:43.293]                             invokeRestart(restart)
[16:19:43.293]                             muffled <- TRUE
[16:19:43.293]                             break
[16:19:43.293]                           }
[16:19:43.293]                         }
[16:19:43.293]                       }
[16:19:43.293]                       invisible(muffled)
[16:19:43.293]                     }
[16:19:43.293]                     muffleCondition(cond, pattern = "^muffle")
[16:19:43.293]                   }
[16:19:43.293]                 }
[16:19:43.293]             }
[16:19:43.293]         }))
[16:19:43.293]     }, error = function(ex) {
[16:19:43.293]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:43.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:43.293]                 ...future.rng), started = ...future.startTime, 
[16:19:43.293]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:43.293]             version = "1.8"), class = "FutureResult")
[16:19:43.293]     }, finally = {
[16:19:43.293]         if (!identical(...future.workdir, getwd())) 
[16:19:43.293]             setwd(...future.workdir)
[16:19:43.293]         {
[16:19:43.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:43.293]                 ...future.oldOptions$nwarnings <- NULL
[16:19:43.293]             }
[16:19:43.293]             base::options(...future.oldOptions)
[16:19:43.293]             if (.Platform$OS.type == "windows") {
[16:19:43.293]                 old_names <- names(...future.oldEnvVars)
[16:19:43.293]                 envs <- base::Sys.getenv()
[16:19:43.293]                 names <- names(envs)
[16:19:43.293]                 common <- intersect(names, old_names)
[16:19:43.293]                 added <- setdiff(names, old_names)
[16:19:43.293]                 removed <- setdiff(old_names, names)
[16:19:43.293]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:43.293]                   envs[common]]
[16:19:43.293]                 NAMES <- toupper(changed)
[16:19:43.293]                 args <- list()
[16:19:43.293]                 for (kk in seq_along(NAMES)) {
[16:19:43.293]                   name <- changed[[kk]]
[16:19:43.293]                   NAME <- NAMES[[kk]]
[16:19:43.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:43.293]                     next
[16:19:43.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:43.293]                 }
[16:19:43.293]                 NAMES <- toupper(added)
[16:19:43.293]                 for (kk in seq_along(NAMES)) {
[16:19:43.293]                   name <- added[[kk]]
[16:19:43.293]                   NAME <- NAMES[[kk]]
[16:19:43.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:43.293]                     next
[16:19:43.293]                   args[[name]] <- ""
[16:19:43.293]                 }
[16:19:43.293]                 NAMES <- toupper(removed)
[16:19:43.293]                 for (kk in seq_along(NAMES)) {
[16:19:43.293]                   name <- removed[[kk]]
[16:19:43.293]                   NAME <- NAMES[[kk]]
[16:19:43.293]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:43.293]                     next
[16:19:43.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:43.293]                 }
[16:19:43.293]                 if (length(args) > 0) 
[16:19:43.293]                   base::do.call(base::Sys.setenv, args = args)
[16:19:43.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:43.293]             }
[16:19:43.293]             else {
[16:19:43.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:43.293]             }
[16:19:43.293]             {
[16:19:43.293]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:43.293]                   0L) {
[16:19:43.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:43.293]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:43.293]                   base::options(opts)
[16:19:43.293]                 }
[16:19:43.293]                 {
[16:19:43.293]                   {
[16:19:43.293]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:43.293]                     NULL
[16:19:43.293]                   }
[16:19:43.293]                   options(future.plan = NULL)
[16:19:43.293]                   if (is.na(NA_character_)) 
[16:19:43.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:43.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:43.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:43.293]                     .init = FALSE)
[16:19:43.293]                 }
[16:19:43.293]             }
[16:19:43.293]         }
[16:19:43.293]     })
[16:19:43.293]     if (TRUE) {
[16:19:43.293]         base::sink(type = "output", split = FALSE)
[16:19:43.293]         if (TRUE) {
[16:19:43.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:43.293]         }
[16:19:43.293]         else {
[16:19:43.293]             ...future.result["stdout"] <- base::list(NULL)
[16:19:43.293]         }
[16:19:43.293]         base::close(...future.stdout)
[16:19:43.293]         ...future.stdout <- NULL
[16:19:43.293]     }
[16:19:43.293]     ...future.result$conditions <- ...future.conditions
[16:19:43.293]     ...future.result$finished <- base::Sys.time()
[16:19:43.293]     ...future.result
[16:19:43.293] }
[16:19:43.295] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[16:19:43.295] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[16:19:43.296] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[16:19:43.296] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:19:43.296] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:19:43.297] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:19:43.297] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:19:43.297] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:43.297] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:43.298] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:43.298] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:43.298] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[16:19:43.299] MultisessionFuture started
[16:19:43.299] - Launch lazy future ... done
[16:19:43.299] run() for ‘MultisessionFuture’ ... done
[16:19:43.299] Created future:
[16:19:43.299] MultisessionFuture:
[16:19:43.299] Label: ‘future_mapply-2’
[16:19:43.299] Expression:
[16:19:43.299] {
[16:19:43.299]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:43.299]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:43.299]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:43.299]         on.exit(options(oopts), add = TRUE)
[16:19:43.299]     }
[16:19:43.299]     {
[16:19:43.299]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:43.299]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:43.299]         do.call(mapply, args = args)
[16:19:43.299]     }
[16:19:43.299] }
[16:19:43.299] Lazy evaluation: FALSE
[16:19:43.299] Asynchronous evaluation: TRUE
[16:19:43.299] Local evaluation: TRUE
[16:19:43.299] Environment: R_GlobalEnv
[16:19:43.299] Capture standard output: TRUE
[16:19:43.299] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:43.299] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:43.299] Packages: <none>
[16:19:43.299] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:43.299] Resolved: FALSE
[16:19:43.299] Value: <not collected>
[16:19:43.299] Conditions captured: <none>
[16:19:43.299] Early signaling: FALSE
[16:19:43.299] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:43.299] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:43.311] Chunk #2 of 2 ... DONE
[16:19:43.311] Launching 2 futures (chunks) ... DONE
[16:19:43.311] Resolving 2 futures (chunks) ...
[16:19:43.311] resolve() on list ...
[16:19:43.311]  recursive: 0
[16:19:43.311]  length: 2
[16:19:43.311] 
[16:19:43.353] receiveMessageFromWorker() for ClusterFuture ...
[16:19:43.353] - Validating connection of MultisessionFuture
[16:19:43.353] - received message: FutureResult
[16:19:43.354] - Received FutureResult
[16:19:43.354] - Erased future from FutureRegistry
[16:19:43.354] result() for ClusterFuture ...
[16:19:43.354] - result already collected: FutureResult
[16:19:43.354] result() for ClusterFuture ... done
[16:19:43.354] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:43.354] Future #2
[16:19:43.354] result() for ClusterFuture ...
[16:19:43.354] - result already collected: FutureResult
[16:19:43.355] result() for ClusterFuture ... done
[16:19:43.355] result() for ClusterFuture ...
[16:19:43.355] - result already collected: FutureResult
[16:19:43.355] result() for ClusterFuture ... done
[16:19:43.355] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:43.355] - nx: 2
[16:19:43.355] - relay: TRUE
[16:19:43.355] - stdout: TRUE
[16:19:43.355] - signal: TRUE
[16:19:43.355] - resignal: FALSE
[16:19:43.355] - force: TRUE
[16:19:43.356] - relayed: [n=2] FALSE, FALSE
[16:19:43.356] - queued futures: [n=2] FALSE, FALSE
[16:19:43.356]  - until=1
[16:19:43.356]  - relaying element #1
[16:19:43.356] - relayed: [n=2] FALSE, FALSE
[16:19:43.356] - queued futures: [n=2] FALSE, TRUE
[16:19:43.356] signalConditionsASAP(NULL, pos=2) ... done
[16:19:43.356]  length: 1 (resolved future 2)
[16:19:43.803] receiveMessageFromWorker() for ClusterFuture ...
[16:19:43.803] - Validating connection of MultisessionFuture
[16:19:43.803] - received message: FutureResult
[16:19:43.803] - Received FutureResult
[16:19:43.803] - Erased future from FutureRegistry
[16:19:43.803] result() for ClusterFuture ...
[16:19:43.804] - result already collected: FutureResult
[16:19:43.804] result() for ClusterFuture ... done
[16:19:43.804] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:43.804] Future #1
[16:19:43.804] result() for ClusterFuture ...
[16:19:43.804] - result already collected: FutureResult
[16:19:43.804] result() for ClusterFuture ... done
[16:19:43.804] result() for ClusterFuture ...
[16:19:43.804] - result already collected: FutureResult
[16:19:43.804] result() for ClusterFuture ... done
[16:19:43.805] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:43.805] - nx: 2
[16:19:43.805] - relay: TRUE
[16:19:43.805] - stdout: TRUE
[16:19:43.805] - signal: TRUE
[16:19:43.805] - resignal: FALSE
[16:19:43.805] - force: TRUE
[16:19:43.805] - relayed: [n=2] FALSE, FALSE
[16:19:43.805] - queued futures: [n=2] FALSE, TRUE
[16:19:43.805]  - until=1
[16:19:43.805]  - relaying element #1
[16:19:43.806] result() for ClusterFuture ...
[16:19:43.806] - result already collected: FutureResult
[16:19:43.806] result() for ClusterFuture ... done
[16:19:43.806] result() for ClusterFuture ...
[16:19:43.806] - result already collected: FutureResult
[16:19:43.806] result() for ClusterFuture ... done
[16:19:43.806] result() for ClusterFuture ...
[16:19:43.806] - result already collected: FutureResult
[16:19:43.806] result() for ClusterFuture ... done
[16:19:43.806] result() for ClusterFuture ...
[16:19:43.806] - result already collected: FutureResult
[16:19:43.807] result() for ClusterFuture ... done
[16:19:43.807] - relayed: [n=2] TRUE, FALSE
[16:19:43.807] - queued futures: [n=2] TRUE, TRUE
[16:19:43.807] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:43.807]  length: 0 (resolved future 1)
[16:19:43.807] Relaying remaining futures
[16:19:43.807] signalConditionsASAP(NULL, pos=0) ...
[16:19:43.807] - nx: 2
[16:19:43.807] - relay: TRUE
[16:19:43.807] - stdout: TRUE
[16:19:43.807] - signal: TRUE
[16:19:43.808] - resignal: FALSE
[16:19:43.808] - force: TRUE
[16:19:43.808] - relayed: [n=2] TRUE, FALSE
[16:19:43.808] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:43.808]  - relaying element #2
[16:19:43.808] result() for ClusterFuture ...
[16:19:43.808] - result already collected: FutureResult
[16:19:43.808] result() for ClusterFuture ... done
[16:19:43.808] result() for ClusterFuture ...
[16:19:43.808] - result already collected: FutureResult
[16:19:43.808] result() for ClusterFuture ... done
[16:19:43.809] result() for ClusterFuture ...
[16:19:43.809] - result already collected: FutureResult
[16:19:43.809] result() for ClusterFuture ... done
[16:19:43.809] result() for ClusterFuture ...
[16:19:43.809] - result already collected: FutureResult
[16:19:43.809] result() for ClusterFuture ... done
[16:19:43.809] - relayed: [n=2] TRUE, TRUE
[16:19:43.809] - queued futures: [n=2] TRUE, TRUE
[16:19:43.809] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:19:43.809] resolve() on list ... DONE
[16:19:43.809] result() for ClusterFuture ...
[16:19:43.810] - result already collected: FutureResult
[16:19:43.810] result() for ClusterFuture ... done
[16:19:43.810] result() for ClusterFuture ...
[16:19:43.810] - result already collected: FutureResult
[16:19:43.810] result() for ClusterFuture ... done
[16:19:43.810] result() for ClusterFuture ...
[16:19:43.810] - result already collected: FutureResult
[16:19:43.810] result() for ClusterFuture ... done
[16:19:43.810] result() for ClusterFuture ...
[16:19:43.810] - result already collected: FutureResult
[16:19:43.810] result() for ClusterFuture ... done
[16:19:43.811]  - Number of value chunks collected: 2
[16:19:43.811] Resolving 2 futures (chunks) ... DONE
[16:19:43.811] Reducing values from 2 chunks ...
[16:19:43.811]  - Number of values collected after concatenation: 2
[16:19:43.811]  - Number of values expected: 2
[16:19:43.811] Reducing values from 2 chunks ... DONE
[16:19:43.811] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = TRUE) ... DONE
* future_mapply(x, ..., future.stdout = NA) ...
[16:19:43.811] future_mapply() ...
[16:19:43.815] Number of chunks: 2
[16:19:43.815] getGlobalsAndPackagesXApply() ...
[16:19:43.816]  - future.globals: TRUE
[16:19:43.816] getGlobalsAndPackages() ...
[16:19:43.816] Searching for globals...
[16:19:43.817] - globals found: [6] ‘FUN’, ‘{’, ‘Sys.sleep’, ‘/’, ‘print’, ‘list’
[16:19:43.817] Searching for globals ... DONE
[16:19:43.818] Resolving globals: FALSE
[16:19:43.818] The total size of the 1 globals is 6.11 KiB (6256 bytes)
[16:19:43.818] The total size of the 1 globals exported for future expression (‘FUN()’) is 6.11 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (6.11 KiB of class ‘function’)
[16:19:43.818] - globals: [1] ‘FUN’
[16:19:43.819] 
[16:19:43.819] getGlobalsAndPackages() ... DONE
[16:19:43.819]  - globals found/used: [n=1] ‘FUN’
[16:19:43.819]  - needed namespaces: [n=0] 
[16:19:43.819] Finding globals ... DONE
[16:19:43.819] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[16:19:43.819] List of 2
[16:19:43.819]  $ ...future.FUN:function (x, y)  
[16:19:43.819]  $ MoreArgs     : NULL
[16:19:43.819]  - attr(*, "where")=List of 2
[16:19:43.819]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[16:19:43.819]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[16:19:43.819]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[16:19:43.819]  - attr(*, "resolved")= logi FALSE
[16:19:43.819]  - attr(*, "total_size")= num NA
[16:19:43.822] Packages to be attached in all futures: [n=0] 
[16:19:43.822] getGlobalsAndPackagesXApply() ... DONE
[16:19:43.822] Number of futures (= number of chunks): 2
[16:19:43.822] Launching 2 futures (chunks) ...
[16:19:43.822] Chunk #1 of 2 ...
[16:19:43.822]  - Finding globals in '...' for chunk #1 ...
[16:19:43.822] getGlobalsAndPackages() ...
[16:19:43.822] Searching for globals...
[16:19:43.823] 
[16:19:43.823] Searching for globals ... DONE
[16:19:43.823] - globals: [0] <none>
[16:19:43.823] getGlobalsAndPackages() ... DONE
[16:19:43.823]    + additional globals found: [n=0] 
[16:19:43.823]    + additional namespaces needed: [n=0] 
[16:19:43.823]  - Finding globals in '...' for chunk #1 ... DONE
[16:19:43.823]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:43.824]  - seeds: <none>
[16:19:43.824]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:43.824] getGlobalsAndPackages() ...
[16:19:43.824] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:43.824] Resolving globals: FALSE
[16:19:43.824] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:19:43.825] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:43.825] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:43.825] 
[16:19:43.825] getGlobalsAndPackages() ... DONE
[16:19:43.825] run() for ‘Future’ ...
[16:19:43.826] - state: ‘created’
[16:19:43.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:43.839] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:43.839] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:43.840]   - Field: ‘node’
[16:19:43.840]   - Field: ‘label’
[16:19:43.840]   - Field: ‘local’
[16:19:43.840]   - Field: ‘owner’
[16:19:43.840]   - Field: ‘envir’
[16:19:43.840]   - Field: ‘workers’
[16:19:43.840]   - Field: ‘packages’
[16:19:43.840]   - Field: ‘gc’
[16:19:43.840]   - Field: ‘conditions’
[16:19:43.840]   - Field: ‘persistent’
[16:19:43.841]   - Field: ‘expr’
[16:19:43.841]   - Field: ‘uuid’
[16:19:43.841]   - Field: ‘seed’
[16:19:43.841]   - Field: ‘version’
[16:19:43.841]   - Field: ‘result’
[16:19:43.841]   - Field: ‘asynchronous’
[16:19:43.841]   - Field: ‘calls’
[16:19:43.841]   - Field: ‘globals’
[16:19:43.841]   - Field: ‘stdout’
[16:19:43.841]   - Field: ‘earlySignal’
[16:19:43.841]   - Field: ‘lazy’
[16:19:43.842]   - Field: ‘state’
[16:19:43.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:43.842] - Launch lazy future ...
[16:19:43.842] Packages needed by the future expression (n = 0): <none>
[16:19:43.842] Packages needed by future strategies (n = 0): <none>
[16:19:43.843] {
[16:19:43.843]     {
[16:19:43.843]         {
[16:19:43.843]             ...future.startTime <- base::Sys.time()
[16:19:43.843]             {
[16:19:43.843]                 {
[16:19:43.843]                   {
[16:19:43.843]                     {
[16:19:43.843]                       base::local({
[16:19:43.843]                         has_future <- base::requireNamespace("future", 
[16:19:43.843]                           quietly = TRUE)
[16:19:43.843]                         if (has_future) {
[16:19:43.843]                           ns <- base::getNamespace("future")
[16:19:43.843]                           version <- ns[[".package"]][["version"]]
[16:19:43.843]                           if (is.null(version)) 
[16:19:43.843]                             version <- utils::packageVersion("future")
[16:19:43.843]                         }
[16:19:43.843]                         else {
[16:19:43.843]                           version <- NULL
[16:19:43.843]                         }
[16:19:43.843]                         if (!has_future || version < "1.8.0") {
[16:19:43.843]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:43.843]                             "", base::R.version$version.string), 
[16:19:43.843]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:43.843]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:43.843]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:43.843]                               "release", "version")], collapse = " "), 
[16:19:43.843]                             hostname = base::Sys.info()[["nodename"]])
[16:19:43.843]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:43.843]                             info)
[16:19:43.843]                           info <- base::paste(info, collapse = "; ")
[16:19:43.843]                           if (!has_future) {
[16:19:43.843]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:43.843]                               info)
[16:19:43.843]                           }
[16:19:43.843]                           else {
[16:19:43.843]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:43.843]                               info, version)
[16:19:43.843]                           }
[16:19:43.843]                           base::stop(msg)
[16:19:43.843]                         }
[16:19:43.843]                       })
[16:19:43.843]                     }
[16:19:43.843]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:43.843]                     base::options(mc.cores = 1L)
[16:19:43.843]                   }
[16:19:43.843]                   ...future.strategy.old <- future::plan("list")
[16:19:43.843]                   options(future.plan = NULL)
[16:19:43.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:43.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:43.843]                 }
[16:19:43.843]                 ...future.workdir <- getwd()
[16:19:43.843]             }
[16:19:43.843]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:43.843]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:43.843]         }
[16:19:43.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:43.843]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:43.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:43.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:43.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:43.843]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:43.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:43.843]             base::names(...future.oldOptions))
[16:19:43.843]     }
[16:19:43.843]     if (TRUE) {
[16:19:43.843]     }
[16:19:43.843]     else {
[16:19:43.843]         if (NA) {
[16:19:43.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:43.843]                 open = "w")
[16:19:43.843]         }
[16:19:43.843]         else {
[16:19:43.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:43.843]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:43.843]         }
[16:19:43.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:43.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:43.843]             base::sink(type = "output", split = FALSE)
[16:19:43.843]             base::close(...future.stdout)
[16:19:43.843]         }, add = TRUE)
[16:19:43.843]     }
[16:19:43.843]     ...future.frame <- base::sys.nframe()
[16:19:43.843]     ...future.conditions <- base::list()
[16:19:43.843]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:43.843]     if (FALSE) {
[16:19:43.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:43.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:43.843]     }
[16:19:43.843]     ...future.result <- base::tryCatch({
[16:19:43.843]         base::withCallingHandlers({
[16:19:43.843]             ...future.value <- base::withVisible(base::local({
[16:19:43.843]                 ...future.makeSendCondition <- base::local({
[16:19:43.843]                   sendCondition <- NULL
[16:19:43.843]                   function(frame = 1L) {
[16:19:43.843]                     if (is.function(sendCondition)) 
[16:19:43.843]                       return(sendCondition)
[16:19:43.843]                     ns <- getNamespace("parallel")
[16:19:43.843]                     if (exists("sendData", mode = "function", 
[16:19:43.843]                       envir = ns)) {
[16:19:43.843]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:43.843]                         envir = ns)
[16:19:43.843]                       envir <- sys.frame(frame)
[16:19:43.843]                       master <- NULL
[16:19:43.843]                       while (!identical(envir, .GlobalEnv) && 
[16:19:43.843]                         !identical(envir, emptyenv())) {
[16:19:43.843]                         if (exists("master", mode = "list", envir = envir, 
[16:19:43.843]                           inherits = FALSE)) {
[16:19:43.843]                           master <- get("master", mode = "list", 
[16:19:43.843]                             envir = envir, inherits = FALSE)
[16:19:43.843]                           if (inherits(master, c("SOCKnode", 
[16:19:43.843]                             "SOCK0node"))) {
[16:19:43.843]                             sendCondition <<- function(cond) {
[16:19:43.843]                               data <- list(type = "VALUE", value = cond, 
[16:19:43.843]                                 success = TRUE)
[16:19:43.843]                               parallel_sendData(master, data)
[16:19:43.843]                             }
[16:19:43.843]                             return(sendCondition)
[16:19:43.843]                           }
[16:19:43.843]                         }
[16:19:43.843]                         frame <- frame + 1L
[16:19:43.843]                         envir <- sys.frame(frame)
[16:19:43.843]                       }
[16:19:43.843]                     }
[16:19:43.843]                     sendCondition <<- function(cond) NULL
[16:19:43.843]                   }
[16:19:43.843]                 })
[16:19:43.843]                 withCallingHandlers({
[16:19:43.843]                   {
[16:19:43.843]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:43.843]                     if (!identical(...future.globals.maxSize.org, 
[16:19:43.843]                       ...future.globals.maxSize)) {
[16:19:43.843]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:43.843]                       on.exit(options(oopts), add = TRUE)
[16:19:43.843]                     }
[16:19:43.843]                     {
[16:19:43.843]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:43.843]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:43.843]                         USE.NAMES = FALSE)
[16:19:43.843]                       do.call(mapply, args = args)
[16:19:43.843]                     }
[16:19:43.843]                   }
[16:19:43.843]                 }, immediateCondition = function(cond) {
[16:19:43.843]                   sendCondition <- ...future.makeSendCondition()
[16:19:43.843]                   sendCondition(cond)
[16:19:43.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:43.843]                   {
[16:19:43.843]                     inherits <- base::inherits
[16:19:43.843]                     invokeRestart <- base::invokeRestart
[16:19:43.843]                     is.null <- base::is.null
[16:19:43.843]                     muffled <- FALSE
[16:19:43.843]                     if (inherits(cond, "message")) {
[16:19:43.843]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:43.843]                       if (muffled) 
[16:19:43.843]                         invokeRestart("muffleMessage")
[16:19:43.843]                     }
[16:19:43.843]                     else if (inherits(cond, "warning")) {
[16:19:43.843]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:43.843]                       if (muffled) 
[16:19:43.843]                         invokeRestart("muffleWarning")
[16:19:43.843]                     }
[16:19:43.843]                     else if (inherits(cond, "condition")) {
[16:19:43.843]                       if (!is.null(pattern)) {
[16:19:43.843]                         computeRestarts <- base::computeRestarts
[16:19:43.843]                         grepl <- base::grepl
[16:19:43.843]                         restarts <- computeRestarts(cond)
[16:19:43.843]                         for (restart in restarts) {
[16:19:43.843]                           name <- restart$name
[16:19:43.843]                           if (is.null(name)) 
[16:19:43.843]                             next
[16:19:43.843]                           if (!grepl(pattern, name)) 
[16:19:43.843]                             next
[16:19:43.843]                           invokeRestart(restart)
[16:19:43.843]                           muffled <- TRUE
[16:19:43.843]                           break
[16:19:43.843]                         }
[16:19:43.843]                       }
[16:19:43.843]                     }
[16:19:43.843]                     invisible(muffled)
[16:19:43.843]                   }
[16:19:43.843]                   muffleCondition(cond)
[16:19:43.843]                 })
[16:19:43.843]             }))
[16:19:43.843]             future::FutureResult(value = ...future.value$value, 
[16:19:43.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:43.843]                   ...future.rng), globalenv = if (FALSE) 
[16:19:43.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:43.843]                     ...future.globalenv.names))
[16:19:43.843]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:43.843]         }, condition = base::local({
[16:19:43.843]             c <- base::c
[16:19:43.843]             inherits <- base::inherits
[16:19:43.843]             invokeRestart <- base::invokeRestart
[16:19:43.843]             length <- base::length
[16:19:43.843]             list <- base::list
[16:19:43.843]             seq.int <- base::seq.int
[16:19:43.843]             signalCondition <- base::signalCondition
[16:19:43.843]             sys.calls <- base::sys.calls
[16:19:43.843]             `[[` <- base::`[[`
[16:19:43.843]             `+` <- base::`+`
[16:19:43.843]             `<<-` <- base::`<<-`
[16:19:43.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:43.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:43.843]                   3L)]
[16:19:43.843]             }
[16:19:43.843]             function(cond) {
[16:19:43.843]                 is_error <- inherits(cond, "error")
[16:19:43.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:43.843]                   NULL)
[16:19:43.843]                 if (is_error) {
[16:19:43.843]                   sessionInformation <- function() {
[16:19:43.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:43.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:43.843]                       search = base::search(), system = base::Sys.info())
[16:19:43.843]                   }
[16:19:43.843]                   ...future.conditions[[length(...future.conditions) + 
[16:19:43.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:43.843]                     cond$call), session = sessionInformation(), 
[16:19:43.843]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:43.843]                   signalCondition(cond)
[16:19:43.843]                 }
[16:19:43.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:43.843]                 "immediateCondition"))) {
[16:19:43.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:43.843]                   ...future.conditions[[length(...future.conditions) + 
[16:19:43.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:43.843]                   if (TRUE && !signal) {
[16:19:43.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:43.843]                     {
[16:19:43.843]                       inherits <- base::inherits
[16:19:43.843]                       invokeRestart <- base::invokeRestart
[16:19:43.843]                       is.null <- base::is.null
[16:19:43.843]                       muffled <- FALSE
[16:19:43.843]                       if (inherits(cond, "message")) {
[16:19:43.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:43.843]                         if (muffled) 
[16:19:43.843]                           invokeRestart("muffleMessage")
[16:19:43.843]                       }
[16:19:43.843]                       else if (inherits(cond, "warning")) {
[16:19:43.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:43.843]                         if (muffled) 
[16:19:43.843]                           invokeRestart("muffleWarning")
[16:19:43.843]                       }
[16:19:43.843]                       else if (inherits(cond, "condition")) {
[16:19:43.843]                         if (!is.null(pattern)) {
[16:19:43.843]                           computeRestarts <- base::computeRestarts
[16:19:43.843]                           grepl <- base::grepl
[16:19:43.843]                           restarts <- computeRestarts(cond)
[16:19:43.843]                           for (restart in restarts) {
[16:19:43.843]                             name <- restart$name
[16:19:43.843]                             if (is.null(name)) 
[16:19:43.843]                               next
[16:19:43.843]                             if (!grepl(pattern, name)) 
[16:19:43.843]                               next
[16:19:43.843]                             invokeRestart(restart)
[16:19:43.843]                             muffled <- TRUE
[16:19:43.843]                             break
[16:19:43.843]                           }
[16:19:43.843]                         }
[16:19:43.843]                       }
[16:19:43.843]                       invisible(muffled)
[16:19:43.843]                     }
[16:19:43.843]                     muffleCondition(cond, pattern = "^muffle")
[16:19:43.843]                   }
[16:19:43.843]                 }
[16:19:43.843]                 else {
[16:19:43.843]                   if (TRUE) {
[16:19:43.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:43.843]                     {
[16:19:43.843]                       inherits <- base::inherits
[16:19:43.843]                       invokeRestart <- base::invokeRestart
[16:19:43.843]                       is.null <- base::is.null
[16:19:43.843]                       muffled <- FALSE
[16:19:43.843]                       if (inherits(cond, "message")) {
[16:19:43.843]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:43.843]                         if (muffled) 
[16:19:43.843]                           invokeRestart("muffleMessage")
[16:19:43.843]                       }
[16:19:43.843]                       else if (inherits(cond, "warning")) {
[16:19:43.843]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:43.843]                         if (muffled) 
[16:19:43.843]                           invokeRestart("muffleWarning")
[16:19:43.843]                       }
[16:19:43.843]                       else if (inherits(cond, "condition")) {
[16:19:43.843]                         if (!is.null(pattern)) {
[16:19:43.843]                           computeRestarts <- base::computeRestarts
[16:19:43.843]                           grepl <- base::grepl
[16:19:43.843]                           restarts <- computeRestarts(cond)
[16:19:43.843]                           for (restart in restarts) {
[16:19:43.843]                             name <- restart$name
[16:19:43.843]                             if (is.null(name)) 
[16:19:43.843]                               next
[16:19:43.843]                             if (!grepl(pattern, name)) 
[16:19:43.843]                               next
[16:19:43.843]                             invokeRestart(restart)
[16:19:43.843]                             muffled <- TRUE
[16:19:43.843]                             break
[16:19:43.843]                           }
[16:19:43.843]                         }
[16:19:43.843]                       }
[16:19:43.843]                       invisible(muffled)
[16:19:43.843]                     }
[16:19:43.843]                     muffleCondition(cond, pattern = "^muffle")
[16:19:43.843]                   }
[16:19:43.843]                 }
[16:19:43.843]             }
[16:19:43.843]         }))
[16:19:43.843]     }, error = function(ex) {
[16:19:43.843]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:43.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:43.843]                 ...future.rng), started = ...future.startTime, 
[16:19:43.843]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:43.843]             version = "1.8"), class = "FutureResult")
[16:19:43.843]     }, finally = {
[16:19:43.843]         if (!identical(...future.workdir, getwd())) 
[16:19:43.843]             setwd(...future.workdir)
[16:19:43.843]         {
[16:19:43.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:43.843]                 ...future.oldOptions$nwarnings <- NULL
[16:19:43.843]             }
[16:19:43.843]             base::options(...future.oldOptions)
[16:19:43.843]             if (.Platform$OS.type == "windows") {
[16:19:43.843]                 old_names <- names(...future.oldEnvVars)
[16:19:43.843]                 envs <- base::Sys.getenv()
[16:19:43.843]                 names <- names(envs)
[16:19:43.843]                 common <- intersect(names, old_names)
[16:19:43.843]                 added <- setdiff(names, old_names)
[16:19:43.843]                 removed <- setdiff(old_names, names)
[16:19:43.843]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:43.843]                   envs[common]]
[16:19:43.843]                 NAMES <- toupper(changed)
[16:19:43.843]                 args <- list()
[16:19:43.843]                 for (kk in seq_along(NAMES)) {
[16:19:43.843]                   name <- changed[[kk]]
[16:19:43.843]                   NAME <- NAMES[[kk]]
[16:19:43.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:43.843]                     next
[16:19:43.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:43.843]                 }
[16:19:43.843]                 NAMES <- toupper(added)
[16:19:43.843]                 for (kk in seq_along(NAMES)) {
[16:19:43.843]                   name <- added[[kk]]
[16:19:43.843]                   NAME <- NAMES[[kk]]
[16:19:43.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:43.843]                     next
[16:19:43.843]                   args[[name]] <- ""
[16:19:43.843]                 }
[16:19:43.843]                 NAMES <- toupper(removed)
[16:19:43.843]                 for (kk in seq_along(NAMES)) {
[16:19:43.843]                   name <- removed[[kk]]
[16:19:43.843]                   NAME <- NAMES[[kk]]
[16:19:43.843]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:43.843]                     next
[16:19:43.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:43.843]                 }
[16:19:43.843]                 if (length(args) > 0) 
[16:19:43.843]                   base::do.call(base::Sys.setenv, args = args)
[16:19:43.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:43.843]             }
[16:19:43.843]             else {
[16:19:43.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:43.843]             }
[16:19:43.843]             {
[16:19:43.843]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:43.843]                   0L) {
[16:19:43.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:43.843]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:43.843]                   base::options(opts)
[16:19:43.843]                 }
[16:19:43.843]                 {
[16:19:43.843]                   {
[16:19:43.843]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:43.843]                     NULL
[16:19:43.843]                   }
[16:19:43.843]                   options(future.plan = NULL)
[16:19:43.843]                   if (is.na(NA_character_)) 
[16:19:43.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:43.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:43.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:43.843]                     .init = FALSE)
[16:19:43.843]                 }
[16:19:43.843]             }
[16:19:43.843]         }
[16:19:43.843]     })
[16:19:43.843]     if (FALSE) {
[16:19:43.843]         base::sink(type = "output", split = FALSE)
[16:19:43.843]         if (NA) {
[16:19:43.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:43.843]         }
[16:19:43.843]         else {
[16:19:43.843]             ...future.result["stdout"] <- base::list(NULL)
[16:19:43.843]         }
[16:19:43.843]         base::close(...future.stdout)
[16:19:43.843]         ...future.stdout <- NULL
[16:19:43.843]     }
[16:19:43.843]     ...future.result$conditions <- ...future.conditions
[16:19:43.843]     ...future.result$finished <- base::Sys.time()
[16:19:43.843]     ...future.result
[16:19:43.843] }
[16:19:43.845] Exporting 5 global objects (6.22 KiB) to cluster node #1 ...
[16:19:43.845] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ...
[16:19:43.846] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #1 ... DONE
[16:19:43.846] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ...
[16:19:43.846] Exporting ‘MoreArgs’ (0 bytes) to cluster node #1 ... DONE
[16:19:43.846] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[16:19:43.847] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[16:19:43.847] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[16:19:43.847] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[16:19:43.847] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[16:19:43.847] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[16:19:43.848] Exporting 5 global objects (6.22 KiB) to cluster node #1 ... DONE
[16:19:43.848] MultisessionFuture started
[16:19:43.848] - Launch lazy future ... done
[16:19:43.848] run() for ‘MultisessionFuture’ ... done
[16:19:43.848] Created future:
[16:19:43.848] MultisessionFuture:
[16:19:43.848] Label: ‘future_mapply-1’
[16:19:43.848] Expression:
[16:19:43.848] {
[16:19:43.848]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:43.848]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:43.848]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:43.848]         on.exit(options(oopts), add = TRUE)
[16:19:43.848]     }
[16:19:43.848]     {
[16:19:43.848]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:43.848]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:43.848]         do.call(mapply, args = args)
[16:19:43.848]     }
[16:19:43.848] }
[16:19:43.848] Lazy evaluation: FALSE
[16:19:43.848] Asynchronous evaluation: TRUE
[16:19:43.848] Local evaluation: TRUE
[16:19:43.848] Environment: R_GlobalEnv
[16:19:43.848] Capture standard output: NA
[16:19:43.848] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:43.848] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:43.848] Packages: <none>
[16:19:43.848] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:43.848] Resolved: FALSE
[16:19:43.848] Value: <not collected>
[16:19:43.848] Conditions captured: <none>
[16:19:43.848] Early signaling: FALSE
[16:19:43.848] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:43.848] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:43.860] Chunk #1 of 2 ... DONE
[16:19:43.860] Chunk #2 of 2 ...
[16:19:43.860]  - Finding globals in '...' for chunk #2 ...
[16:19:43.860] getGlobalsAndPackages() ...
[16:19:43.860] Searching for globals...
[16:19:43.861] 
[16:19:43.861] Searching for globals ... DONE
[16:19:43.861] - globals: [0] <none>
[16:19:43.861] getGlobalsAndPackages() ... DONE
[16:19:43.861]    + additional globals found: [n=0] 
[16:19:43.861]    + additional namespaces needed: [n=0] 
[16:19:43.861]  - Finding globals in '...' for chunk #2 ... DONE
[16:19:43.861]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[16:19:43.861]  - seeds: <none>
[16:19:43.862]  - All globals exported: [n=5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:43.862] getGlobalsAndPackages() ...
[16:19:43.862] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:43.862] Resolving globals: FALSE
[16:19:43.862] The total size of the 5 globals is 6.22 KiB (6368 bytes)
[16:19:43.863] The total size of the 5 globals exported for future expression (‘{; ...future.globals.maxSize.org <- getOption("future.globals.maxSize"); if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {; oopts <- options(future.globals.maxSize = ...future.globals.maxSize); on.exit(options(oopts), add = TRUE); }; ...; do.call(mapply, args = args); }; }’) is 6.22 KiB.. This exceeds the maximum allowed size of 0.98 GiB (option 'future.globals.maxSize'). The three largest globals are ‘...future.FUN’ (6.11 KiB of class ‘function’), ‘...future.elements_ii’ (112 bytes of class ‘list’) and ‘MoreArgs’ (0 bytes of class ‘NULL’)
[16:19:43.863] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[16:19:43.863] 
[16:19:43.863] getGlobalsAndPackages() ... DONE
[16:19:43.863] run() for ‘Future’ ...
[16:19:43.863] - state: ‘created’
[16:19:43.864] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[16:19:43.877] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:43.877] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[16:19:43.877]   - Field: ‘node’
[16:19:43.877]   - Field: ‘label’
[16:19:43.877]   - Field: ‘local’
[16:19:43.878]   - Field: ‘owner’
[16:19:43.878]   - Field: ‘envir’
[16:19:43.878]   - Field: ‘workers’
[16:19:43.878]   - Field: ‘packages’
[16:19:43.878]   - Field: ‘gc’
[16:19:43.878]   - Field: ‘conditions’
[16:19:43.878]   - Field: ‘persistent’
[16:19:43.878]   - Field: ‘expr’
[16:19:43.878]   - Field: ‘uuid’
[16:19:43.878]   - Field: ‘seed’
[16:19:43.878]   - Field: ‘version’
[16:19:43.879]   - Field: ‘result’
[16:19:43.879]   - Field: ‘asynchronous’
[16:19:43.879]   - Field: ‘calls’
[16:19:43.879]   - Field: ‘globals’
[16:19:43.879]   - Field: ‘stdout’
[16:19:43.879]   - Field: ‘earlySignal’
[16:19:43.879]   - Field: ‘lazy’
[16:19:43.879]   - Field: ‘state’
[16:19:43.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[16:19:43.879] - Launch lazy future ...
[16:19:43.880] Packages needed by the future expression (n = 0): <none>
[16:19:43.880] Packages needed by future strategies (n = 0): <none>
[16:19:43.880] {
[16:19:43.880]     {
[16:19:43.880]         {
[16:19:43.880]             ...future.startTime <- base::Sys.time()
[16:19:43.880]             {
[16:19:43.880]                 {
[16:19:43.880]                   {
[16:19:43.880]                     {
[16:19:43.880]                       base::local({
[16:19:43.880]                         has_future <- base::requireNamespace("future", 
[16:19:43.880]                           quietly = TRUE)
[16:19:43.880]                         if (has_future) {
[16:19:43.880]                           ns <- base::getNamespace("future")
[16:19:43.880]                           version <- ns[[".package"]][["version"]]
[16:19:43.880]                           if (is.null(version)) 
[16:19:43.880]                             version <- utils::packageVersion("future")
[16:19:43.880]                         }
[16:19:43.880]                         else {
[16:19:43.880]                           version <- NULL
[16:19:43.880]                         }
[16:19:43.880]                         if (!has_future || version < "1.8.0") {
[16:19:43.880]                           info <- base::c(r_version = base::gsub("R version ", 
[16:19:43.880]                             "", base::R.version$version.string), 
[16:19:43.880]                             platform = base::sprintf("%s (%s-bit)", 
[16:19:43.880]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[16:19:43.880]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[16:19:43.880]                               "release", "version")], collapse = " "), 
[16:19:43.880]                             hostname = base::Sys.info()[["nodename"]])
[16:19:43.880]                           info <- base::sprintf("%s: %s", base::names(info), 
[16:19:43.880]                             info)
[16:19:43.880]                           info <- base::paste(info, collapse = "; ")
[16:19:43.880]                           if (!has_future) {
[16:19:43.880]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[16:19:43.880]                               info)
[16:19:43.880]                           }
[16:19:43.880]                           else {
[16:19:43.880]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[16:19:43.880]                               info, version)
[16:19:43.880]                           }
[16:19:43.880]                           base::stop(msg)
[16:19:43.880]                         }
[16:19:43.880]                       })
[16:19:43.880]                     }
[16:19:43.880]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[16:19:43.880]                     base::options(mc.cores = 1L)
[16:19:43.880]                   }
[16:19:43.880]                   ...future.strategy.old <- future::plan("list")
[16:19:43.880]                   options(future.plan = NULL)
[16:19:43.880]                   Sys.unsetenv("R_FUTURE_PLAN")
[16:19:43.880]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[16:19:43.880]                 }
[16:19:43.880]                 ...future.workdir <- getwd()
[16:19:43.880]             }
[16:19:43.880]             ...future.oldOptions <- base::as.list(base::.Options)
[16:19:43.880]             ...future.oldEnvVars <- base::Sys.getenv()
[16:19:43.880]         }
[16:19:43.880]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[16:19:43.880]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[16:19:43.880]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[16:19:43.880]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[16:19:43.880]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[16:19:43.880]             future.stdout.windows.reencode = NULL, width = 80L)
[16:19:43.880]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[16:19:43.880]             base::names(...future.oldOptions))
[16:19:43.880]     }
[16:19:43.880]     if (TRUE) {
[16:19:43.880]     }
[16:19:43.880]     else {
[16:19:43.880]         if (NA) {
[16:19:43.880]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[16:19:43.880]                 open = "w")
[16:19:43.880]         }
[16:19:43.880]         else {
[16:19:43.880]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[16:19:43.880]                 windows = "NUL", "/dev/null"), open = "w")
[16:19:43.880]         }
[16:19:43.880]         base::sink(...future.stdout, type = "output", split = FALSE)
[16:19:43.880]         base::on.exit(if (!base::is.null(...future.stdout)) {
[16:19:43.880]             base::sink(type = "output", split = FALSE)
[16:19:43.880]             base::close(...future.stdout)
[16:19:43.880]         }, add = TRUE)
[16:19:43.880]     }
[16:19:43.880]     ...future.frame <- base::sys.nframe()
[16:19:43.880]     ...future.conditions <- base::list()
[16:19:43.880]     ...future.rng <- base::globalenv()$.Random.seed
[16:19:43.880]     if (FALSE) {
[16:19:43.880]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[16:19:43.880]             "...future.value", "...future.globalenv.names", ".Random.seed")
[16:19:43.880]     }
[16:19:43.880]     ...future.result <- base::tryCatch({
[16:19:43.880]         base::withCallingHandlers({
[16:19:43.880]             ...future.value <- base::withVisible(base::local({
[16:19:43.880]                 ...future.makeSendCondition <- base::local({
[16:19:43.880]                   sendCondition <- NULL
[16:19:43.880]                   function(frame = 1L) {
[16:19:43.880]                     if (is.function(sendCondition)) 
[16:19:43.880]                       return(sendCondition)
[16:19:43.880]                     ns <- getNamespace("parallel")
[16:19:43.880]                     if (exists("sendData", mode = "function", 
[16:19:43.880]                       envir = ns)) {
[16:19:43.880]                       parallel_sendData <- get("sendData", mode = "function", 
[16:19:43.880]                         envir = ns)
[16:19:43.880]                       envir <- sys.frame(frame)
[16:19:43.880]                       master <- NULL
[16:19:43.880]                       while (!identical(envir, .GlobalEnv) && 
[16:19:43.880]                         !identical(envir, emptyenv())) {
[16:19:43.880]                         if (exists("master", mode = "list", envir = envir, 
[16:19:43.880]                           inherits = FALSE)) {
[16:19:43.880]                           master <- get("master", mode = "list", 
[16:19:43.880]                             envir = envir, inherits = FALSE)
[16:19:43.880]                           if (inherits(master, c("SOCKnode", 
[16:19:43.880]                             "SOCK0node"))) {
[16:19:43.880]                             sendCondition <<- function(cond) {
[16:19:43.880]                               data <- list(type = "VALUE", value = cond, 
[16:19:43.880]                                 success = TRUE)
[16:19:43.880]                               parallel_sendData(master, data)
[16:19:43.880]                             }
[16:19:43.880]                             return(sendCondition)
[16:19:43.880]                           }
[16:19:43.880]                         }
[16:19:43.880]                         frame <- frame + 1L
[16:19:43.880]                         envir <- sys.frame(frame)
[16:19:43.880]                       }
[16:19:43.880]                     }
[16:19:43.880]                     sendCondition <<- function(cond) NULL
[16:19:43.880]                   }
[16:19:43.880]                 })
[16:19:43.880]                 withCallingHandlers({
[16:19:43.880]                   {
[16:19:43.880]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:43.880]                     if (!identical(...future.globals.maxSize.org, 
[16:19:43.880]                       ...future.globals.maxSize)) {
[16:19:43.880]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:43.880]                       on.exit(options(oopts), add = TRUE)
[16:19:43.880]                     }
[16:19:43.880]                     {
[16:19:43.880]                       args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:43.880]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[16:19:43.880]                         USE.NAMES = FALSE)
[16:19:43.880]                       do.call(mapply, args = args)
[16:19:43.880]                     }
[16:19:43.880]                   }
[16:19:43.880]                 }, immediateCondition = function(cond) {
[16:19:43.880]                   sendCondition <- ...future.makeSendCondition()
[16:19:43.880]                   sendCondition(cond)
[16:19:43.880]                   muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:43.880]                   {
[16:19:43.880]                     inherits <- base::inherits
[16:19:43.880]                     invokeRestart <- base::invokeRestart
[16:19:43.880]                     is.null <- base::is.null
[16:19:43.880]                     muffled <- FALSE
[16:19:43.880]                     if (inherits(cond, "message")) {
[16:19:43.880]                       muffled <- grepl(pattern, "muffleMessage")
[16:19:43.880]                       if (muffled) 
[16:19:43.880]                         invokeRestart("muffleMessage")
[16:19:43.880]                     }
[16:19:43.880]                     else if (inherits(cond, "warning")) {
[16:19:43.880]                       muffled <- grepl(pattern, "muffleWarning")
[16:19:43.880]                       if (muffled) 
[16:19:43.880]                         invokeRestart("muffleWarning")
[16:19:43.880]                     }
[16:19:43.880]                     else if (inherits(cond, "condition")) {
[16:19:43.880]                       if (!is.null(pattern)) {
[16:19:43.880]                         computeRestarts <- base::computeRestarts
[16:19:43.880]                         grepl <- base::grepl
[16:19:43.880]                         restarts <- computeRestarts(cond)
[16:19:43.880]                         for (restart in restarts) {
[16:19:43.880]                           name <- restart$name
[16:19:43.880]                           if (is.null(name)) 
[16:19:43.880]                             next
[16:19:43.880]                           if (!grepl(pattern, name)) 
[16:19:43.880]                             next
[16:19:43.880]                           invokeRestart(restart)
[16:19:43.880]                           muffled <- TRUE
[16:19:43.880]                           break
[16:19:43.880]                         }
[16:19:43.880]                       }
[16:19:43.880]                     }
[16:19:43.880]                     invisible(muffled)
[16:19:43.880]                   }
[16:19:43.880]                   muffleCondition(cond)
[16:19:43.880]                 })
[16:19:43.880]             }))
[16:19:43.880]             future::FutureResult(value = ...future.value$value, 
[16:19:43.880]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:43.880]                   ...future.rng), globalenv = if (FALSE) 
[16:19:43.880]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[16:19:43.880]                     ...future.globalenv.names))
[16:19:43.880]                 else NULL, started = ...future.startTime, version = "1.8")
[16:19:43.880]         }, condition = base::local({
[16:19:43.880]             c <- base::c
[16:19:43.880]             inherits <- base::inherits
[16:19:43.880]             invokeRestart <- base::invokeRestart
[16:19:43.880]             length <- base::length
[16:19:43.880]             list <- base::list
[16:19:43.880]             seq.int <- base::seq.int
[16:19:43.880]             signalCondition <- base::signalCondition
[16:19:43.880]             sys.calls <- base::sys.calls
[16:19:43.880]             `[[` <- base::`[[`
[16:19:43.880]             `+` <- base::`+`
[16:19:43.880]             `<<-` <- base::`<<-`
[16:19:43.880]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[16:19:43.880]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[16:19:43.880]                   3L)]
[16:19:43.880]             }
[16:19:43.880]             function(cond) {
[16:19:43.880]                 is_error <- inherits(cond, "error")
[16:19:43.880]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[16:19:43.880]                   NULL)
[16:19:43.880]                 if (is_error) {
[16:19:43.880]                   sessionInformation <- function() {
[16:19:43.880]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[16:19:43.880]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[16:19:43.880]                       search = base::search(), system = base::Sys.info())
[16:19:43.880]                   }
[16:19:43.880]                   ...future.conditions[[length(...future.conditions) + 
[16:19:43.880]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[16:19:43.880]                     cond$call), session = sessionInformation(), 
[16:19:43.880]                     timestamp = base::Sys.time(), signaled = 0L)
[16:19:43.880]                   signalCondition(cond)
[16:19:43.880]                 }
[16:19:43.880]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[16:19:43.880]                 "immediateCondition"))) {
[16:19:43.880]                   signal <- TRUE && inherits(cond, "immediateCondition")
[16:19:43.880]                   ...future.conditions[[length(...future.conditions) + 
[16:19:43.880]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[16:19:43.880]                   if (TRUE && !signal) {
[16:19:43.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:43.880]                     {
[16:19:43.880]                       inherits <- base::inherits
[16:19:43.880]                       invokeRestart <- base::invokeRestart
[16:19:43.880]                       is.null <- base::is.null
[16:19:43.880]                       muffled <- FALSE
[16:19:43.880]                       if (inherits(cond, "message")) {
[16:19:43.880]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:43.880]                         if (muffled) 
[16:19:43.880]                           invokeRestart("muffleMessage")
[16:19:43.880]                       }
[16:19:43.880]                       else if (inherits(cond, "warning")) {
[16:19:43.880]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:43.880]                         if (muffled) 
[16:19:43.880]                           invokeRestart("muffleWarning")
[16:19:43.880]                       }
[16:19:43.880]                       else if (inherits(cond, "condition")) {
[16:19:43.880]                         if (!is.null(pattern)) {
[16:19:43.880]                           computeRestarts <- base::computeRestarts
[16:19:43.880]                           grepl <- base::grepl
[16:19:43.880]                           restarts <- computeRestarts(cond)
[16:19:43.880]                           for (restart in restarts) {
[16:19:43.880]                             name <- restart$name
[16:19:43.880]                             if (is.null(name)) 
[16:19:43.880]                               next
[16:19:43.880]                             if (!grepl(pattern, name)) 
[16:19:43.880]                               next
[16:19:43.880]                             invokeRestart(restart)
[16:19:43.880]                             muffled <- TRUE
[16:19:43.880]                             break
[16:19:43.880]                           }
[16:19:43.880]                         }
[16:19:43.880]                       }
[16:19:43.880]                       invisible(muffled)
[16:19:43.880]                     }
[16:19:43.880]                     muffleCondition(cond, pattern = "^muffle")
[16:19:43.880]                   }
[16:19:43.880]                 }
[16:19:43.880]                 else {
[16:19:43.880]                   if (TRUE) {
[16:19:43.880]                     muffleCondition <- function (cond, pattern = "^muffle") 
[16:19:43.880]                     {
[16:19:43.880]                       inherits <- base::inherits
[16:19:43.880]                       invokeRestart <- base::invokeRestart
[16:19:43.880]                       is.null <- base::is.null
[16:19:43.880]                       muffled <- FALSE
[16:19:43.880]                       if (inherits(cond, "message")) {
[16:19:43.880]                         muffled <- grepl(pattern, "muffleMessage")
[16:19:43.880]                         if (muffled) 
[16:19:43.880]                           invokeRestart("muffleMessage")
[16:19:43.880]                       }
[16:19:43.880]                       else if (inherits(cond, "warning")) {
[16:19:43.880]                         muffled <- grepl(pattern, "muffleWarning")
[16:19:43.880]                         if (muffled) 
[16:19:43.880]                           invokeRestart("muffleWarning")
[16:19:43.880]                       }
[16:19:43.880]                       else if (inherits(cond, "condition")) {
[16:19:43.880]                         if (!is.null(pattern)) {
[16:19:43.880]                           computeRestarts <- base::computeRestarts
[16:19:43.880]                           grepl <- base::grepl
[16:19:43.880]                           restarts <- computeRestarts(cond)
[16:19:43.880]                           for (restart in restarts) {
[16:19:43.880]                             name <- restart$name
[16:19:43.880]                             if (is.null(name)) 
[16:19:43.880]                               next
[16:19:43.880]                             if (!grepl(pattern, name)) 
[16:19:43.880]                               next
[16:19:43.880]                             invokeRestart(restart)
[16:19:43.880]                             muffled <- TRUE
[16:19:43.880]                             break
[16:19:43.880]                           }
[16:19:43.880]                         }
[16:19:43.880]                       }
[16:19:43.880]                       invisible(muffled)
[16:19:43.880]                     }
[16:19:43.880]                     muffleCondition(cond, pattern = "^muffle")
[16:19:43.880]                   }
[16:19:43.880]                 }
[16:19:43.880]             }
[16:19:43.880]         }))
[16:19:43.880]     }, error = function(ex) {
[16:19:43.880]         base::structure(base::list(value = NULL, visible = NULL, 
[16:19:43.880]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[16:19:43.880]                 ...future.rng), started = ...future.startTime, 
[16:19:43.880]             finished = Sys.time(), session_uuid = NA_character_, 
[16:19:43.880]             version = "1.8"), class = "FutureResult")
[16:19:43.880]     }, finally = {
[16:19:43.880]         if (!identical(...future.workdir, getwd())) 
[16:19:43.880]             setwd(...future.workdir)
[16:19:43.880]         {
[16:19:43.880]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[16:19:43.880]                 ...future.oldOptions$nwarnings <- NULL
[16:19:43.880]             }
[16:19:43.880]             base::options(...future.oldOptions)
[16:19:43.880]             if (.Platform$OS.type == "windows") {
[16:19:43.880]                 old_names <- names(...future.oldEnvVars)
[16:19:43.880]                 envs <- base::Sys.getenv()
[16:19:43.880]                 names <- names(envs)
[16:19:43.880]                 common <- intersect(names, old_names)
[16:19:43.880]                 added <- setdiff(names, old_names)
[16:19:43.880]                 removed <- setdiff(old_names, names)
[16:19:43.880]                 changed <- common[...future.oldEnvVars[common] != 
[16:19:43.880]                   envs[common]]
[16:19:43.880]                 NAMES <- toupper(changed)
[16:19:43.880]                 args <- list()
[16:19:43.880]                 for (kk in seq_along(NAMES)) {
[16:19:43.880]                   name <- changed[[kk]]
[16:19:43.880]                   NAME <- NAMES[[kk]]
[16:19:43.880]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:43.880]                     next
[16:19:43.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:43.880]                 }
[16:19:43.880]                 NAMES <- toupper(added)
[16:19:43.880]                 for (kk in seq_along(NAMES)) {
[16:19:43.880]                   name <- added[[kk]]
[16:19:43.880]                   NAME <- NAMES[[kk]]
[16:19:43.880]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:43.880]                     next
[16:19:43.880]                   args[[name]] <- ""
[16:19:43.880]                 }
[16:19:43.880]                 NAMES <- toupper(removed)
[16:19:43.880]                 for (kk in seq_along(NAMES)) {
[16:19:43.880]                   name <- removed[[kk]]
[16:19:43.880]                   NAME <- NAMES[[kk]]
[16:19:43.880]                   if (name != NAME && is.element(NAME, old_names)) 
[16:19:43.880]                     next
[16:19:43.880]                   args[[name]] <- ...future.oldEnvVars[[name]]
[16:19:43.880]                 }
[16:19:43.880]                 if (length(args) > 0) 
[16:19:43.880]                   base::do.call(base::Sys.setenv, args = args)
[16:19:43.880]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[16:19:43.880]             }
[16:19:43.880]             else {
[16:19:43.880]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[16:19:43.880]             }
[16:19:43.880]             {
[16:19:43.880]                 if (base::length(...future.futureOptionsAdded) > 
[16:19:43.880]                   0L) {
[16:19:43.880]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[16:19:43.880]                   base::names(opts) <- ...future.futureOptionsAdded
[16:19:43.880]                   base::options(opts)
[16:19:43.880]                 }
[16:19:43.880]                 {
[16:19:43.880]                   {
[16:19:43.880]                     base::options(mc.cores = ...future.mc.cores.old)
[16:19:43.880]                     NULL
[16:19:43.880]                   }
[16:19:43.880]                   options(future.plan = NULL)
[16:19:43.880]                   if (is.na(NA_character_)) 
[16:19:43.880]                     Sys.unsetenv("R_FUTURE_PLAN")
[16:19:43.880]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[16:19:43.880]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[16:19:43.880]                     .init = FALSE)
[16:19:43.880]                 }
[16:19:43.880]             }
[16:19:43.880]         }
[16:19:43.880]     })
[16:19:43.880]     if (FALSE) {
[16:19:43.880]         base::sink(type = "output", split = FALSE)
[16:19:43.880]         if (NA) {
[16:19:43.880]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[16:19:43.880]         }
[16:19:43.880]         else {
[16:19:43.880]             ...future.result["stdout"] <- base::list(NULL)
[16:19:43.880]         }
[16:19:43.880]         base::close(...future.stdout)
[16:19:43.880]         ...future.stdout <- NULL
[16:19:43.880]     }
[16:19:43.880]     ...future.result$conditions <- ...future.conditions
[16:19:43.880]     ...future.result$finished <- base::Sys.time()
[16:19:43.880]     ...future.result
[16:19:43.880] }
[16:19:43.883] Exporting 5 global objects (6.22 KiB) to cluster node #2 ...
[16:19:43.883] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ...
[16:19:43.883] Exporting ‘...future.FUN’ (6.11 KiB) to cluster node #2 ... DONE
[16:19:43.884] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ...
[16:19:43.884] Exporting ‘MoreArgs’ (0 bytes) to cluster node #2 ... DONE
[16:19:43.884] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[16:19:43.884] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[16:19:43.885] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[16:19:43.885] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[16:19:43.885] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[16:19:43.885] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[16:19:43.886] Exporting 5 global objects (6.22 KiB) to cluster node #2 ... DONE
[16:19:43.886] MultisessionFuture started
[16:19:43.886] - Launch lazy future ... done
[16:19:43.886] run() for ‘MultisessionFuture’ ... done
[16:19:43.887] Created future:
[16:19:43.887] MultisessionFuture:
[16:19:43.887] Label: ‘future_mapply-2’
[16:19:43.887] Expression:
[16:19:43.887] {
[16:19:43.887]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[16:19:43.887]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[16:19:43.887]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[16:19:43.887]         on.exit(options(oopts), add = TRUE)
[16:19:43.887]     }
[16:19:43.887]     {
[16:19:43.887]         args <- c(list(FUN = ...future.FUN), ...future.elements_ii, 
[16:19:43.887]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[16:19:43.887]         do.call(mapply, args = args)
[16:19:43.887]     }
[16:19:43.887] }
[16:19:43.887] Lazy evaluation: FALSE
[16:19:43.887] Asynchronous evaluation: TRUE
[16:19:43.887] Local evaluation: TRUE
[16:19:43.887] Environment: R_GlobalEnv
[16:19:43.887] Capture standard output: NA
[16:19:43.887] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[16:19:43.887] Globals: 5 objects totaling 6.22 KiB (function ‘...future.FUN’ of 6.11 KiB, NULL ‘MoreArgs’ of 0 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[16:19:43.887] Packages: <none>
[16:19:43.887] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[16:19:43.887] Resolved: FALSE
[16:19:43.887] Value: <not collected>
[16:19:43.887] Conditions captured: <none>
[16:19:43.887] Early signaling: FALSE
[16:19:43.887] Owner process: e1ad31f9-6774-468d-cb2f-b238c34dda3a
[16:19:43.887] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[16:19:43.898] Chunk #2 of 2 ... DONE
[16:19:43.898] Launching 2 futures (chunks) ... DONE
[16:19:43.898] Resolving 2 futures (chunks) ...
[16:19:43.898] resolve() on list ...
[16:19:43.899]  recursive: 0
[16:19:43.899]  length: 2
[16:19:43.899] 
[16:19:43.941] receiveMessageFromWorker() for ClusterFuture ...
[16:19:43.941] - Validating connection of MultisessionFuture
[16:19:43.941] - received message: FutureResult
[16:19:43.941] - Received FutureResult
[16:19:43.941] - Erased future from FutureRegistry
[16:19:43.941] result() for ClusterFuture ...
[16:19:43.941] - result already collected: FutureResult
[16:19:43.941] result() for ClusterFuture ... done
[16:19:43.942] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:43.942] Future #2
[16:19:43.942] result() for ClusterFuture ...
[16:19:43.942] - result already collected: FutureResult
[16:19:43.942] result() for ClusterFuture ... done
[16:19:43.942] result() for ClusterFuture ...
[16:19:43.942] - result already collected: FutureResult
[16:19:43.942] result() for ClusterFuture ... done
[16:19:43.942] signalConditionsASAP(MultisessionFuture, pos=2) ...
[16:19:43.942] - nx: 2
[16:19:43.942] - relay: TRUE
[16:19:43.943] - stdout: TRUE
[16:19:43.943] - signal: TRUE
[16:19:43.943] - resignal: FALSE
[16:19:43.943] - force: TRUE
[16:19:43.943] - relayed: [n=2] FALSE, FALSE
[16:19:43.943] - queued futures: [n=2] FALSE, FALSE
[16:19:43.943]  - until=1
[16:19:43.943]  - relaying element #1
[16:19:43.943] - relayed: [n=2] FALSE, FALSE
[16:19:43.943] - queued futures: [n=2] FALSE, TRUE
[16:19:43.943] signalConditionsASAP(NULL, pos=2) ... done
[16:19:43.943]  length: 1 (resolved future 2)
[16:19:44.394] receiveMessageFromWorker() for ClusterFuture ...
[16:19:44.395] - Validating connection of MultisessionFuture
[16:19:44.395] - received message: FutureResult
[16:19:44.395] - Received FutureResult
[16:19:44.395] - Erased future from FutureRegistry
[16:19:44.395] result() for ClusterFuture ...
[16:19:44.395] - result already collected: FutureResult
[16:19:44.395] result() for ClusterFuture ... done
[16:19:44.396] receiveMessageFromWorker() for ClusterFuture ... done
[16:19:44.396] Future #1
[16:19:44.396] result() for ClusterFuture ...
[16:19:44.396] - result already collected: FutureResult
[16:19:44.396] result() for ClusterFuture ... done
[16:19:44.396] result() for ClusterFuture ...
[16:19:44.396] - result already collected: FutureResult
[16:19:44.396] result() for ClusterFuture ... done
[16:19:44.396] signalConditionsASAP(MultisessionFuture, pos=1) ...
[16:19:44.396] - nx: 2
[16:19:44.396] - relay: TRUE
[16:19:44.396] - stdout: TRUE
[16:19:44.397] - signal: TRUE
[16:19:44.397] - resignal: FALSE
[16:19:44.397] - force: TRUE
[16:19:44.397] - relayed: [n=2] FALSE, FALSE
[16:19:44.397] - queued futures: [n=2] FALSE, TRUE
[16:19:44.397]  - until=1
[16:19:44.397]  - relaying element #1
[16:19:44.397] result() for ClusterFuture ...
[16:19:44.397] - result already collected: FutureResult
[16:19:44.397] result() for ClusterFuture ... done
[16:19:44.397] result() for ClusterFuture ...
[16:19:44.398] - result already collected: FutureResult
[16:19:44.398] result() for ClusterFuture ... done
[16:19:44.398] result() for ClusterFuture ...
[16:19:44.398] - result already collected: FutureResult
[16:19:44.398] result() for ClusterFuture ... done
[16:19:44.398] result() for ClusterFuture ...
[16:19:44.398] - result already collected: FutureResult
[16:19:44.398] result() for ClusterFuture ... done
[16:19:44.398] - relayed: [n=2] TRUE, FALSE
[16:19:44.398] - queued futures: [n=2] TRUE, TRUE
[16:19:44.398] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[16:19:44.399]  length: 0 (resolved future 1)
[16:19:44.399] Relaying remaining futures
[16:19:44.399] signalConditionsASAP(NULL, pos=0) ...
[16:19:44.399] - nx: 2
[16:19:44.399] - relay: TRUE
[16:19:44.399] - stdout: TRUE
[16:19:44.399] - signal: TRUE
[16:19:44.399] - resignal: FALSE
[16:19:44.399] - force: TRUE
[16:19:44.399] - relayed: [n=2] TRUE, FALSE
[16:19:44.399] - queued futures: [n=2] TRUE, TRUE
 - flush all
[16:19:44.399]  - relaying element #2
[16:19:44.400] result() for ClusterFuture ...
[16:19:44.400] - result already collected: FutureResult
[16:19:44.400] result() for ClusterFuture ... done
[16:19:44.400] result() for ClusterFuture ...
[16:19:44.400] - result already collected: FutureResult
[16:19:44.400] result() for ClusterFuture ... done
[16:19:44.400] result() for ClusterFuture ...
[16:19:44.400] - result already collected: FutureResult
[16:19:44.400] result() for ClusterFuture ... done
[16:19:44.400] result() for ClusterFuture ...
[16:19:44.400] - result already collected: FutureResult
[16:19:44.401] result() for ClusterFuture ... done
[16:19:44.401] - relayed: [n=2] TRUE, TRUE
[16:19:44.401] - queued futures: [n=2] TRUE, TRUE
[16:19:44.401] signalConditionsASAP(MultisessionFuture, pos=0) ... done
[16:19:44.401] resolve() on list ... DONE
[16:19:44.401] result() for ClusterFuture ...
[16:19:44.401] - result already collected: FutureResult
[16:19:44.401] result() for ClusterFuture ... done
[16:19:44.401] result() for ClusterFuture ...
[16:19:44.401] - result already collected: FutureResult
[16:19:44.401] result() for ClusterFuture ... done
[16:19:44.401] result() for ClusterFuture ...
[16:19:44.402] - result already collected: FutureResult
[16:19:44.402] result() for ClusterFuture ... done
[16:19:44.402] result() for ClusterFuture ...
[16:19:44.402] - result already collected: FutureResult
[16:19:44.402] result() for ClusterFuture ... done
[16:19:44.402]  - Number of value chunks collected: 2
[16:19:44.402] Resolving 2 futures (chunks) ... DONE
[16:19:44.402] Reducing values from 2 chunks ...
[16:19:44.402]  - Number of values collected after concatenation: 2
[16:19:44.402]  - Number of values expected: 2
[16:19:44.402] Reducing values from 2 chunks ... DONE
[16:19:44.403] future_mapply() ... DONE
* future_mapply(x, ..., future.stdout = NA) ... DONE
* plan('multisession') ... DONE
  - Testing with 2 cores ... DONE
> 
> message("*** future_*apply() and 'future.stdout' ... DONE")
*** future_*apply() and 'future.stdout' ... DONE
> 
> source("incl/end.R")
[16:19:44.403] plan(): Setting new future strategy stack:
[16:19:44.404] List of future strategies:
[16:19:44.404] 1. FutureStrategy:
[16:19:44.404]    - args: function (..., envir = parent.frame())
[16:19:44.404]    - tweaked: FALSE
[16:19:44.404]    - call: future::plan(oplan)
[16:19:44.404] plan(): nbrOfWorkers() = 1
> 
