
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[13:35:05.621] plan(): Setting new future strategy stack:
[13:35:05.621] List of future strategies:
[13:35:05.621] 1. sequential:
[13:35:05.621]    - args: function (..., envir = parent.frame())
[13:35:05.621]    - tweaked: FALSE
[13:35:05.621]    - call: future::plan("sequential")
[13:35:05.634] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[13:35:05.734] plan(): Setting new future strategy stack:
[13:35:05.734] List of future strategies:
[13:35:05.734] 1. sequential:
[13:35:05.734]    - args: function (..., envir = parent.frame())
[13:35:05.734]    - tweaked: FALSE
[13:35:05.734]    - call: plan(strategy)
[13:35:05.745] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[13:35:05.750] future_lapply() ...
[13:35:05.756] Number of chunks: 1
[13:35:05.756] getGlobalsAndPackagesXApply() ...
[13:35:05.756]  - future.globals: TRUE
[13:35:05.757] getGlobalsAndPackages() ...
[13:35:05.757] Searching for globals...
[13:35:05.761] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:05.761] Searching for globals ... DONE
[13:35:05.761] Resolving globals: FALSE
[13:35:05.763] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[13:35:05.763] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:05.763] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:05.764] - packages: [1] ‘future.apply’
[13:35:05.764] getGlobalsAndPackages() ... DONE
[13:35:05.764]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:05.764]  - needed namespaces: [n=1] ‘future.apply’
[13:35:05.764] Finding globals ... DONE
[13:35:05.764]  - use_args: TRUE
[13:35:05.764]  - Getting '...' globals ...
[13:35:05.765] resolve() on list ...
[13:35:05.765]  recursive: 0
[13:35:05.765]  length: 1
[13:35:05.765]  elements: ‘...’
[13:35:05.766]  length: 0 (resolved future 1)
[13:35:05.766] resolve() on list ... DONE
[13:35:05.766]    - '...' content: [n=0] 
[13:35:05.766] List of 1
[13:35:05.766]  $ ...: list()
[13:35:05.766]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.766]  - attr(*, "where")=List of 1
[13:35:05.766]   ..$ ...:<environment: 0x5574ceffab28> 
[13:35:05.766]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.766]  - attr(*, "resolved")= logi TRUE
[13:35:05.766]  - attr(*, "total_size")= num NA
[13:35:05.768]  - Getting '...' globals ... DONE
[13:35:05.769] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:05.769] List of 8
[13:35:05.769]  $ ...future.FUN:function (x, ...)  
[13:35:05.769]  $ x_FUN        :function (x)  
[13:35:05.769]  $ times        : int 1
[13:35:05.769]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:05.769]  $ stop_if_not  :function (...)  
[13:35:05.769]  $ dim          : NULL
[13:35:05.769]  $ valid_types  : chr "character"
[13:35:05.769]  $ ...          : list()
[13:35:05.769]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.769]  - attr(*, "where")=List of 8
[13:35:05.769]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:05.769]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:05.769]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:05.769]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:05.769]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:05.769]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:05.769]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:05.769]   ..$ ...          :<environment: 0x5574ceffab28> 
[13:35:05.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.769]  - attr(*, "resolved")= logi FALSE
[13:35:05.769]  - attr(*, "total_size")= num 94208
[13:35:05.776] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:05.776] getGlobalsAndPackagesXApply() ... DONE
[13:35:05.776] Number of futures (= number of chunks): 1
[13:35:05.776] Launching 1 futures (chunks) ...
[13:35:05.776] Chunk #1 of 1 ...
[13:35:05.777]  - Finding globals in 'X' for chunk #1 ...
[13:35:05.777] getGlobalsAndPackages() ...
[13:35:05.777] Searching for globals...
[13:35:05.777] 
[13:35:05.777] Searching for globals ... DONE
[13:35:05.777] - globals: [0] <none>
[13:35:05.777] getGlobalsAndPackages() ... DONE
[13:35:05.778]    + additional globals found: [n=0] 
[13:35:05.778]    + additional namespaces needed: [n=0] 
[13:35:05.778]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:05.778]  - seeds: <none>
[13:35:05.778]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.778] getGlobalsAndPackages() ...
[13:35:05.778] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.778] Resolving globals: FALSE
[13:35:05.778] Tweak future expression to call with '...' arguments ...
[13:35:05.779] {
[13:35:05.779]     do.call(function(...) {
[13:35:05.779]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.779]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:05.779]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.779]             on.exit(options(oopts), add = TRUE)
[13:35:05.779]         }
[13:35:05.779]         {
[13:35:05.779]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:05.779]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.779]                 ...future.FUN(...future.X_jj, ...)
[13:35:05.779]             })
[13:35:05.779]         }
[13:35:05.779]     }, args = future.call.arguments)
[13:35:05.779] }
[13:35:05.779] Tweak future expression to call with '...' arguments ... DONE
[13:35:05.779] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.779] - packages: [1] ‘future.apply’
[13:35:05.780] getGlobalsAndPackages() ... DONE
[13:35:05.780] run() for ‘Future’ ...
[13:35:05.780] - state: ‘created’
[13:35:05.781] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:05.781] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:05.781] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:05.781]   - Field: ‘label’
[13:35:05.781]   - Field: ‘local’
[13:35:05.781]   - Field: ‘owner’
[13:35:05.781]   - Field: ‘envir’
[13:35:05.782]   - Field: ‘packages’
[13:35:05.782]   - Field: ‘gc’
[13:35:05.782]   - Field: ‘conditions’
[13:35:05.782]   - Field: ‘expr’
[13:35:05.782]   - Field: ‘uuid’
[13:35:05.782]   - Field: ‘seed’
[13:35:05.782]   - Field: ‘version’
[13:35:05.782]   - Field: ‘result’
[13:35:05.782]   - Field: ‘asynchronous’
[13:35:05.782]   - Field: ‘calls’
[13:35:05.782]   - Field: ‘globals’
[13:35:05.783]   - Field: ‘stdout’
[13:35:05.783]   - Field: ‘earlySignal’
[13:35:05.783]   - Field: ‘lazy’
[13:35:05.783]   - Field: ‘state’
[13:35:05.783] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:05.783] - Launch lazy future ...
[13:35:05.784] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:05.784] Packages needed by future strategies (n = 0): <none>
[13:35:05.785] {
[13:35:05.785]     {
[13:35:05.785]         {
[13:35:05.785]             ...future.startTime <- base::Sys.time()
[13:35:05.785]             {
[13:35:05.785]                 {
[13:35:05.785]                   {
[13:35:05.785]                     {
[13:35:05.785]                       base::local({
[13:35:05.785]                         has_future <- base::requireNamespace("future", 
[13:35:05.785]                           quietly = TRUE)
[13:35:05.785]                         if (has_future) {
[13:35:05.785]                           ns <- base::getNamespace("future")
[13:35:05.785]                           version <- ns[[".package"]][["version"]]
[13:35:05.785]                           if (is.null(version)) 
[13:35:05.785]                             version <- utils::packageVersion("future")
[13:35:05.785]                         }
[13:35:05.785]                         else {
[13:35:05.785]                           version <- NULL
[13:35:05.785]                         }
[13:35:05.785]                         if (!has_future || version < "1.8.0") {
[13:35:05.785]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:05.785]                             "", base::R.version$version.string), 
[13:35:05.785]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:05.785]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:05.785]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:05.785]                               "release", "version")], collapse = " "), 
[13:35:05.785]                             hostname = base::Sys.info()[["nodename"]])
[13:35:05.785]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:05.785]                             info)
[13:35:05.785]                           info <- base::paste(info, collapse = "; ")
[13:35:05.785]                           if (!has_future) {
[13:35:05.785]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:05.785]                               info)
[13:35:05.785]                           }
[13:35:05.785]                           else {
[13:35:05.785]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:05.785]                               info, version)
[13:35:05.785]                           }
[13:35:05.785]                           base::stop(msg)
[13:35:05.785]                         }
[13:35:05.785]                       })
[13:35:05.785]                     }
[13:35:05.785]                     base::local({
[13:35:05.785]                       for (pkg in "future.apply") {
[13:35:05.785]                         base::loadNamespace(pkg)
[13:35:05.785]                         base::library(pkg, character.only = TRUE)
[13:35:05.785]                       }
[13:35:05.785]                     })
[13:35:05.785]                   }
[13:35:05.785]                   ...future.strategy.old <- future::plan("list")
[13:35:05.785]                   options(future.plan = NULL)
[13:35:05.785]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:05.785]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:05.785]                 }
[13:35:05.785]                 ...future.workdir <- getwd()
[13:35:05.785]             }
[13:35:05.785]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:05.785]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:05.785]         }
[13:35:05.785]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:05.785]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:05.785]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:05.785]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:05.785]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:05.785]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:05.785]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:05.785]             base::names(...future.oldOptions))
[13:35:05.785]     }
[13:35:05.785]     if (FALSE) {
[13:35:05.785]     }
[13:35:05.785]     else {
[13:35:05.785]         if (TRUE) {
[13:35:05.785]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:05.785]                 open = "w")
[13:35:05.785]         }
[13:35:05.785]         else {
[13:35:05.785]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:05.785]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:05.785]         }
[13:35:05.785]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:05.785]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:05.785]             base::sink(type = "output", split = FALSE)
[13:35:05.785]             base::close(...future.stdout)
[13:35:05.785]         }, add = TRUE)
[13:35:05.785]     }
[13:35:05.785]     ...future.frame <- base::sys.nframe()
[13:35:05.785]     ...future.conditions <- base::list()
[13:35:05.785]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:05.785]     if (FALSE) {
[13:35:05.785]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:05.785]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:05.785]     }
[13:35:05.785]     ...future.result <- base::tryCatch({
[13:35:05.785]         base::withCallingHandlers({
[13:35:05.785]             ...future.value <- base::withVisible(base::local({
[13:35:05.785]                 do.call(function(...) {
[13:35:05.785]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.785]                   if (!identical(...future.globals.maxSize.org, 
[13:35:05.785]                     ...future.globals.maxSize)) {
[13:35:05.785]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.785]                     on.exit(options(oopts), add = TRUE)
[13:35:05.785]                   }
[13:35:05.785]                   {
[13:35:05.785]                     lapply(seq_along(...future.elements_ii), 
[13:35:05.785]                       FUN = function(jj) {
[13:35:05.785]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.785]                         ...future.FUN(...future.X_jj, ...)
[13:35:05.785]                       })
[13:35:05.785]                   }
[13:35:05.785]                 }, args = future.call.arguments)
[13:35:05.785]             }))
[13:35:05.785]             future::FutureResult(value = ...future.value$value, 
[13:35:05.785]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:05.785]                   ...future.rng), globalenv = if (FALSE) 
[13:35:05.785]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:05.785]                     ...future.globalenv.names))
[13:35:05.785]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:05.785]         }, condition = base::local({
[13:35:05.785]             c <- base::c
[13:35:05.785]             inherits <- base::inherits
[13:35:05.785]             invokeRestart <- base::invokeRestart
[13:35:05.785]             length <- base::length
[13:35:05.785]             list <- base::list
[13:35:05.785]             seq.int <- base::seq.int
[13:35:05.785]             signalCondition <- base::signalCondition
[13:35:05.785]             sys.calls <- base::sys.calls
[13:35:05.785]             `[[` <- base::`[[`
[13:35:05.785]             `+` <- base::`+`
[13:35:05.785]             `<<-` <- base::`<<-`
[13:35:05.785]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:05.785]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:05.785]                   3L)]
[13:35:05.785]             }
[13:35:05.785]             function(cond) {
[13:35:05.785]                 is_error <- inherits(cond, "error")
[13:35:05.785]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:05.785]                   NULL)
[13:35:05.785]                 if (is_error) {
[13:35:05.785]                   sessionInformation <- function() {
[13:35:05.785]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:05.785]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:05.785]                       search = base::search(), system = base::Sys.info())
[13:35:05.785]                   }
[13:35:05.785]                   ...future.conditions[[length(...future.conditions) + 
[13:35:05.785]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:05.785]                     cond$call), session = sessionInformation(), 
[13:35:05.785]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:05.785]                   signalCondition(cond)
[13:35:05.785]                 }
[13:35:05.785]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:05.785]                 "immediateCondition"))) {
[13:35:05.785]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:05.785]                   ...future.conditions[[length(...future.conditions) + 
[13:35:05.785]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:05.785]                   if (TRUE && !signal) {
[13:35:05.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:05.785]                     {
[13:35:05.785]                       inherits <- base::inherits
[13:35:05.785]                       invokeRestart <- base::invokeRestart
[13:35:05.785]                       is.null <- base::is.null
[13:35:05.785]                       muffled <- FALSE
[13:35:05.785]                       if (inherits(cond, "message")) {
[13:35:05.785]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:05.785]                         if (muffled) 
[13:35:05.785]                           invokeRestart("muffleMessage")
[13:35:05.785]                       }
[13:35:05.785]                       else if (inherits(cond, "warning")) {
[13:35:05.785]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:05.785]                         if (muffled) 
[13:35:05.785]                           invokeRestart("muffleWarning")
[13:35:05.785]                       }
[13:35:05.785]                       else if (inherits(cond, "condition")) {
[13:35:05.785]                         if (!is.null(pattern)) {
[13:35:05.785]                           computeRestarts <- base::computeRestarts
[13:35:05.785]                           grepl <- base::grepl
[13:35:05.785]                           restarts <- computeRestarts(cond)
[13:35:05.785]                           for (restart in restarts) {
[13:35:05.785]                             name <- restart$name
[13:35:05.785]                             if (is.null(name)) 
[13:35:05.785]                               next
[13:35:05.785]                             if (!grepl(pattern, name)) 
[13:35:05.785]                               next
[13:35:05.785]                             invokeRestart(restart)
[13:35:05.785]                             muffled <- TRUE
[13:35:05.785]                             break
[13:35:05.785]                           }
[13:35:05.785]                         }
[13:35:05.785]                       }
[13:35:05.785]                       invisible(muffled)
[13:35:05.785]                     }
[13:35:05.785]                     muffleCondition(cond, pattern = "^muffle")
[13:35:05.785]                   }
[13:35:05.785]                 }
[13:35:05.785]                 else {
[13:35:05.785]                   if (TRUE) {
[13:35:05.785]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:05.785]                     {
[13:35:05.785]                       inherits <- base::inherits
[13:35:05.785]                       invokeRestart <- base::invokeRestart
[13:35:05.785]                       is.null <- base::is.null
[13:35:05.785]                       muffled <- FALSE
[13:35:05.785]                       if (inherits(cond, "message")) {
[13:35:05.785]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:05.785]                         if (muffled) 
[13:35:05.785]                           invokeRestart("muffleMessage")
[13:35:05.785]                       }
[13:35:05.785]                       else if (inherits(cond, "warning")) {
[13:35:05.785]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:05.785]                         if (muffled) 
[13:35:05.785]                           invokeRestart("muffleWarning")
[13:35:05.785]                       }
[13:35:05.785]                       else if (inherits(cond, "condition")) {
[13:35:05.785]                         if (!is.null(pattern)) {
[13:35:05.785]                           computeRestarts <- base::computeRestarts
[13:35:05.785]                           grepl <- base::grepl
[13:35:05.785]                           restarts <- computeRestarts(cond)
[13:35:05.785]                           for (restart in restarts) {
[13:35:05.785]                             name <- restart$name
[13:35:05.785]                             if (is.null(name)) 
[13:35:05.785]                               next
[13:35:05.785]                             if (!grepl(pattern, name)) 
[13:35:05.785]                               next
[13:35:05.785]                             invokeRestart(restart)
[13:35:05.785]                             muffled <- TRUE
[13:35:05.785]                             break
[13:35:05.785]                           }
[13:35:05.785]                         }
[13:35:05.785]                       }
[13:35:05.785]                       invisible(muffled)
[13:35:05.785]                     }
[13:35:05.785]                     muffleCondition(cond, pattern = "^muffle")
[13:35:05.785]                   }
[13:35:05.785]                 }
[13:35:05.785]             }
[13:35:05.785]         }))
[13:35:05.785]     }, error = function(ex) {
[13:35:05.785]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:05.785]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:05.785]                 ...future.rng), started = ...future.startTime, 
[13:35:05.785]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:05.785]             version = "1.8"), class = "FutureResult")
[13:35:05.785]     }, finally = {
[13:35:05.785]         if (!identical(...future.workdir, getwd())) 
[13:35:05.785]             setwd(...future.workdir)
[13:35:05.785]         {
[13:35:05.785]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:05.785]                 ...future.oldOptions$nwarnings <- NULL
[13:35:05.785]             }
[13:35:05.785]             base::options(...future.oldOptions)
[13:35:05.785]             if (.Platform$OS.type == "windows") {
[13:35:05.785]                 old_names <- names(...future.oldEnvVars)
[13:35:05.785]                 envs <- base::Sys.getenv()
[13:35:05.785]                 names <- names(envs)
[13:35:05.785]                 common <- intersect(names, old_names)
[13:35:05.785]                 added <- setdiff(names, old_names)
[13:35:05.785]                 removed <- setdiff(old_names, names)
[13:35:05.785]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:05.785]                   envs[common]]
[13:35:05.785]                 NAMES <- toupper(changed)
[13:35:05.785]                 args <- list()
[13:35:05.785]                 for (kk in seq_along(NAMES)) {
[13:35:05.785]                   name <- changed[[kk]]
[13:35:05.785]                   NAME <- NAMES[[kk]]
[13:35:05.785]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.785]                     next
[13:35:05.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:05.785]                 }
[13:35:05.785]                 NAMES <- toupper(added)
[13:35:05.785]                 for (kk in seq_along(NAMES)) {
[13:35:05.785]                   name <- added[[kk]]
[13:35:05.785]                   NAME <- NAMES[[kk]]
[13:35:05.785]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.785]                     next
[13:35:05.785]                   args[[name]] <- ""
[13:35:05.785]                 }
[13:35:05.785]                 NAMES <- toupper(removed)
[13:35:05.785]                 for (kk in seq_along(NAMES)) {
[13:35:05.785]                   name <- removed[[kk]]
[13:35:05.785]                   NAME <- NAMES[[kk]]
[13:35:05.785]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.785]                     next
[13:35:05.785]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:05.785]                 }
[13:35:05.785]                 if (length(args) > 0) 
[13:35:05.785]                   base::do.call(base::Sys.setenv, args = args)
[13:35:05.785]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:05.785]             }
[13:35:05.785]             else {
[13:35:05.785]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:05.785]             }
[13:35:05.785]             {
[13:35:05.785]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:05.785]                   0L) {
[13:35:05.785]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:05.785]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:05.785]                   base::options(opts)
[13:35:05.785]                 }
[13:35:05.785]                 {
[13:35:05.785]                   {
[13:35:05.785]                     NULL
[13:35:05.785]                     RNGkind("Mersenne-Twister")
[13:35:05.785]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:05.785]                       inherits = FALSE)
[13:35:05.785]                   }
[13:35:05.785]                   options(future.plan = NULL)
[13:35:05.785]                   if (is.na(NA_character_)) 
[13:35:05.785]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:05.785]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:05.785]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:05.785]                     .init = FALSE)
[13:35:05.785]                 }
[13:35:05.785]             }
[13:35:05.785]         }
[13:35:05.785]     })
[13:35:05.785]     if (TRUE) {
[13:35:05.785]         base::sink(type = "output", split = FALSE)
[13:35:05.785]         if (TRUE) {
[13:35:05.785]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:05.785]         }
[13:35:05.785]         else {
[13:35:05.785]             ...future.result["stdout"] <- base::list(NULL)
[13:35:05.785]         }
[13:35:05.785]         base::close(...future.stdout)
[13:35:05.785]         ...future.stdout <- NULL
[13:35:05.785]     }
[13:35:05.785]     ...future.result$conditions <- ...future.conditions
[13:35:05.785]     ...future.result$finished <- base::Sys.time()
[13:35:05.785]     ...future.result
[13:35:05.785] }
[13:35:05.787] assign_globals() ...
[13:35:05.787] List of 11
[13:35:05.787]  $ ...future.FUN            :function (x, ...)  
[13:35:05.787]  $ x_FUN                    :function (x)  
[13:35:05.787]  $ times                    : int 1
[13:35:05.787]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:05.787]  $ stop_if_not              :function (...)  
[13:35:05.787]  $ dim                      : NULL
[13:35:05.787]  $ valid_types              : chr "character"
[13:35:05.787]  $ future.call.arguments    : list()
[13:35:05.787]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.787]  $ ...future.elements_ii    :List of 2
[13:35:05.787]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:35:05.787]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[13:35:05.787]  $ ...future.seeds_ii       : NULL
[13:35:05.787]  $ ...future.globals.maxSize: NULL
[13:35:05.787]  - attr(*, "where")=List of 11
[13:35:05.787]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:05.787]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:05.787]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:05.787]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:05.787]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:05.787]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:05.787]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:05.787]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:05.787]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:05.787]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:05.787]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:05.787]  - attr(*, "resolved")= logi FALSE
[13:35:05.787]  - attr(*, "total_size")= num 94208
[13:35:05.787]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.787]  - attr(*, "already-done")= logi TRUE
[13:35:05.794] - copied ‘...future.FUN’ to environment
[13:35:05.794] - copied ‘x_FUN’ to environment
[13:35:05.794] - copied ‘times’ to environment
[13:35:05.794] - copied ‘stopf’ to environment
[13:35:05.794] - copied ‘stop_if_not’ to environment
[13:35:05.794] - copied ‘dim’ to environment
[13:35:05.795] - copied ‘valid_types’ to environment
[13:35:05.795] - copied ‘future.call.arguments’ to environment
[13:35:05.795] - copied ‘...future.elements_ii’ to environment
[13:35:05.795] - copied ‘...future.seeds_ii’ to environment
[13:35:05.795] - copied ‘...future.globals.maxSize’ to environment
[13:35:05.795] assign_globals() ... done
[13:35:05.795] plan(): Setting new future strategy stack:
[13:35:05.796] List of future strategies:
[13:35:05.796] 1. sequential:
[13:35:05.796]    - args: function (..., envir = parent.frame())
[13:35:05.796]    - tweaked: FALSE
[13:35:05.796]    - call: NULL
[13:35:05.796] plan(): nbrOfWorkers() = 1
[13:35:05.797] plan(): Setting new future strategy stack:
[13:35:05.797] List of future strategies:
[13:35:05.797] 1. sequential:
[13:35:05.797]    - args: function (..., envir = parent.frame())
[13:35:05.797]    - tweaked: FALSE
[13:35:05.797]    - call: plan(strategy)
[13:35:05.798] plan(): nbrOfWorkers() = 1
[13:35:05.798] SequentialFuture started (and completed)
[13:35:05.798] - Launch lazy future ... done
[13:35:05.798] run() for ‘SequentialFuture’ ... done
[13:35:05.798] Created future:
[13:35:05.799] SequentialFuture:
[13:35:05.799] Label: ‘future_vapply-1’
[13:35:05.799] Expression:
[13:35:05.799] {
[13:35:05.799]     do.call(function(...) {
[13:35:05.799]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.799]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:05.799]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.799]             on.exit(options(oopts), add = TRUE)
[13:35:05.799]         }
[13:35:05.799]         {
[13:35:05.799]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:05.799]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.799]                 ...future.FUN(...future.X_jj, ...)
[13:35:05.799]             })
[13:35:05.799]         }
[13:35:05.799]     }, args = future.call.arguments)
[13:35:05.799] }
[13:35:05.799] Lazy evaluation: FALSE
[13:35:05.799] Asynchronous evaluation: FALSE
[13:35:05.799] Local evaluation: TRUE
[13:35:05.799] Environment: R_GlobalEnv
[13:35:05.799] Capture standard output: TRUE
[13:35:05.799] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:05.799] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:05.799] Packages: 1 packages (‘future.apply’)
[13:35:05.799] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:05.799] Resolved: TRUE
[13:35:05.799] Value: 232 bytes of class ‘list’
[13:35:05.799] Early signaling: FALSE
[13:35:05.799] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:05.799] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:05.800] Chunk #1 of 1 ... DONE
[13:35:05.800] Launching 1 futures (chunks) ... DONE
[13:35:05.800] Resolving 1 futures (chunks) ...
[13:35:05.800] resolve() on list ...
[13:35:05.801]  recursive: 0
[13:35:05.801]  length: 1
[13:35:05.801] 
[13:35:05.801] resolved() for ‘SequentialFuture’ ...
[13:35:05.801] - state: ‘finished’
[13:35:05.801] - run: TRUE
[13:35:05.801] - result: ‘FutureResult’
[13:35:05.801] resolved() for ‘SequentialFuture’ ... done
[13:35:05.803] Future #1
[13:35:05.804] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:05.804] - nx: 1
[13:35:05.804] - relay: TRUE
[13:35:05.804] - stdout: TRUE
[13:35:05.804] - signal: TRUE
[13:35:05.804] - resignal: FALSE
[13:35:05.804] - force: TRUE
[13:35:05.804] - relayed: [n=1] FALSE
[13:35:05.804] - queued futures: [n=1] FALSE
[13:35:05.804]  - until=1
[13:35:05.804]  - relaying element #1
[13:35:05.805] - relayed: [n=1] TRUE
[13:35:05.805] - queued futures: [n=1] TRUE
[13:35:05.805] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:05.805]  length: 0 (resolved future 1)
[13:35:05.805] Relaying remaining futures
[13:35:05.805] signalConditionsASAP(NULL, pos=0) ...
[13:35:05.805] - nx: 1
[13:35:05.805] - relay: TRUE
[13:35:05.806] - stdout: TRUE
[13:35:05.806] - signal: TRUE
[13:35:05.806] - resignal: FALSE
[13:35:05.806] - force: TRUE
[13:35:05.806] - relayed: [n=1] TRUE
[13:35:05.806] - queued futures: [n=1] TRUE
 - flush all
[13:35:05.806] - relayed: [n=1] TRUE
[13:35:05.806] - queued futures: [n=1] TRUE
[13:35:05.806] signalConditionsASAP(NULL, pos=0) ... done
[13:35:05.806] resolve() on list ... DONE
[13:35:05.807]  - Number of value chunks collected: 1
[13:35:05.807] Resolving 1 futures (chunks) ... DONE
[13:35:05.807] Reducing values from 1 chunks ...
[13:35:05.807]  - Number of values collected after concatenation: 2
[13:35:05.807]  - Number of values expected: 2
[13:35:05.807] Reducing values from 1 chunks ... DONE
[13:35:05.807] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[13:35:05.808] future_lapply() ...
[13:35:05.810] Number of chunks: 1
[13:35:05.810] getGlobalsAndPackagesXApply() ...
[13:35:05.810]  - future.globals: TRUE
[13:35:05.810] getGlobalsAndPackages() ...
[13:35:05.810] Searching for globals...
[13:35:05.813] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[13:35:05.814] Searching for globals ... DONE
[13:35:05.814] Resolving globals: FALSE
[13:35:05.815] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[13:35:05.815] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:05.815] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:05.815] - packages: [1] ‘future.apply’
[13:35:05.815] getGlobalsAndPackages() ... DONE
[13:35:05.815]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:05.815]  - needed namespaces: [n=1] ‘future.apply’
[13:35:05.816] Finding globals ... DONE
[13:35:05.816]  - use_args: TRUE
[13:35:05.816]  - Getting '...' globals ...
[13:35:05.816] resolve() on list ...
[13:35:05.816]  recursive: 0
[13:35:05.816]  length: 1
[13:35:05.816]  elements: ‘...’
[13:35:05.816]  length: 0 (resolved future 1)
[13:35:05.816] resolve() on list ... DONE
[13:35:05.817]    - '...' content: [n=0] 
[13:35:05.817] List of 1
[13:35:05.817]  $ ...: list()
[13:35:05.817]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.817]  - attr(*, "where")=List of 1
[13:35:05.817]   ..$ ...:<environment: 0x5574cfc5c600> 
[13:35:05.817]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.817]  - attr(*, "resolved")= logi TRUE
[13:35:05.817]  - attr(*, "total_size")= num NA
[13:35:05.819]  - Getting '...' globals ... DONE
[13:35:05.819] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:05.819] List of 8
[13:35:05.819]  $ ...future.FUN:function (x, ...)  
[13:35:05.819]  $ x_FUN        :function (x)  
[13:35:05.819]  $ times        : int 0
[13:35:05.819]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:05.819]  $ stop_if_not  :function (...)  
[13:35:05.819]  $ dim          : NULL
[13:35:05.819]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:05.819]  $ ...          : list()
[13:35:05.819]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.819]  - attr(*, "where")=List of 8
[13:35:05.819]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:05.819]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:05.819]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:05.819]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:05.819]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:05.819]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:05.819]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:05.819]   ..$ ...          :<environment: 0x5574cfc5c600> 
[13:35:05.819]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.819]  - attr(*, "resolved")= logi FALSE
[13:35:05.819]  - attr(*, "total_size")= num 95472
[13:35:05.826] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:05.826] getGlobalsAndPackagesXApply() ... DONE
[13:35:05.826] Number of futures (= number of chunks): 1
[13:35:05.826] Launching 1 futures (chunks) ...
[13:35:05.826] Chunk #1 of 1 ...
[13:35:05.826]  - Finding globals in 'X' for chunk #1 ...
[13:35:05.826] getGlobalsAndPackages() ...
[13:35:05.826] Searching for globals...
[13:35:05.827] 
[13:35:05.827] Searching for globals ... DONE
[13:35:05.827] - globals: [0] <none>
[13:35:05.827] getGlobalsAndPackages() ... DONE
[13:35:05.827]    + additional globals found: [n=0] 
[13:35:05.827]    + additional namespaces needed: [n=0] 
[13:35:05.827]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:05.827]  - seeds: <none>
[13:35:05.827]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.827] getGlobalsAndPackages() ...
[13:35:05.828] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.828] Resolving globals: FALSE
[13:35:05.828] Tweak future expression to call with '...' arguments ...
[13:35:05.828] {
[13:35:05.828]     do.call(function(...) {
[13:35:05.828]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.828]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:05.828]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.828]             on.exit(options(oopts), add = TRUE)
[13:35:05.828]         }
[13:35:05.828]         {
[13:35:05.828]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:05.828]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.828]                 ...future.FUN(...future.X_jj, ...)
[13:35:05.828]             })
[13:35:05.828]         }
[13:35:05.828]     }, args = future.call.arguments)
[13:35:05.828] }
[13:35:05.828] Tweak future expression to call with '...' arguments ... DONE
[13:35:05.829] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.829] - packages: [1] ‘future.apply’
[13:35:05.829] getGlobalsAndPackages() ... DONE
[13:35:05.829] run() for ‘Future’ ...
[13:35:05.829] - state: ‘created’
[13:35:05.829] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:05.830] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:05.830] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:05.830]   - Field: ‘label’
[13:35:05.830]   - Field: ‘local’
[13:35:05.830]   - Field: ‘owner’
[13:35:05.830]   - Field: ‘envir’
[13:35:05.830]   - Field: ‘packages’
[13:35:05.830]   - Field: ‘gc’
[13:35:05.830]   - Field: ‘conditions’
[13:35:05.830]   - Field: ‘expr’
[13:35:05.831]   - Field: ‘uuid’
[13:35:05.831]   - Field: ‘seed’
[13:35:05.831]   - Field: ‘version’
[13:35:05.831]   - Field: ‘result’
[13:35:05.831]   - Field: ‘asynchronous’
[13:35:05.831]   - Field: ‘calls’
[13:35:05.831]   - Field: ‘globals’
[13:35:05.831]   - Field: ‘stdout’
[13:35:05.831]   - Field: ‘earlySignal’
[13:35:05.831]   - Field: ‘lazy’
[13:35:05.831]   - Field: ‘state’
[13:35:05.832] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:05.832] - Launch lazy future ...
[13:35:05.832] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:05.832] Packages needed by future strategies (n = 0): <none>
[13:35:05.832] {
[13:35:05.832]     {
[13:35:05.832]         {
[13:35:05.832]             ...future.startTime <- base::Sys.time()
[13:35:05.832]             {
[13:35:05.832]                 {
[13:35:05.832]                   {
[13:35:05.832]                     {
[13:35:05.832]                       base::local({
[13:35:05.832]                         has_future <- base::requireNamespace("future", 
[13:35:05.832]                           quietly = TRUE)
[13:35:05.832]                         if (has_future) {
[13:35:05.832]                           ns <- base::getNamespace("future")
[13:35:05.832]                           version <- ns[[".package"]][["version"]]
[13:35:05.832]                           if (is.null(version)) 
[13:35:05.832]                             version <- utils::packageVersion("future")
[13:35:05.832]                         }
[13:35:05.832]                         else {
[13:35:05.832]                           version <- NULL
[13:35:05.832]                         }
[13:35:05.832]                         if (!has_future || version < "1.8.0") {
[13:35:05.832]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:05.832]                             "", base::R.version$version.string), 
[13:35:05.832]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:05.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:05.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:05.832]                               "release", "version")], collapse = " "), 
[13:35:05.832]                             hostname = base::Sys.info()[["nodename"]])
[13:35:05.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:05.832]                             info)
[13:35:05.832]                           info <- base::paste(info, collapse = "; ")
[13:35:05.832]                           if (!has_future) {
[13:35:05.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:05.832]                               info)
[13:35:05.832]                           }
[13:35:05.832]                           else {
[13:35:05.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:05.832]                               info, version)
[13:35:05.832]                           }
[13:35:05.832]                           base::stop(msg)
[13:35:05.832]                         }
[13:35:05.832]                       })
[13:35:05.832]                     }
[13:35:05.832]                     base::local({
[13:35:05.832]                       for (pkg in "future.apply") {
[13:35:05.832]                         base::loadNamespace(pkg)
[13:35:05.832]                         base::library(pkg, character.only = TRUE)
[13:35:05.832]                       }
[13:35:05.832]                     })
[13:35:05.832]                   }
[13:35:05.832]                   ...future.strategy.old <- future::plan("list")
[13:35:05.832]                   options(future.plan = NULL)
[13:35:05.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:05.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:05.832]                 }
[13:35:05.832]                 ...future.workdir <- getwd()
[13:35:05.832]             }
[13:35:05.832]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:05.832]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:05.832]         }
[13:35:05.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:05.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:05.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:05.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:05.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:05.832]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:05.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:05.832]             base::names(...future.oldOptions))
[13:35:05.832]     }
[13:35:05.832]     if (FALSE) {
[13:35:05.832]     }
[13:35:05.832]     else {
[13:35:05.832]         if (TRUE) {
[13:35:05.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:05.832]                 open = "w")
[13:35:05.832]         }
[13:35:05.832]         else {
[13:35:05.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:05.832]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:05.832]         }
[13:35:05.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:05.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:05.832]             base::sink(type = "output", split = FALSE)
[13:35:05.832]             base::close(...future.stdout)
[13:35:05.832]         }, add = TRUE)
[13:35:05.832]     }
[13:35:05.832]     ...future.frame <- base::sys.nframe()
[13:35:05.832]     ...future.conditions <- base::list()
[13:35:05.832]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:05.832]     if (FALSE) {
[13:35:05.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:05.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:05.832]     }
[13:35:05.832]     ...future.result <- base::tryCatch({
[13:35:05.832]         base::withCallingHandlers({
[13:35:05.832]             ...future.value <- base::withVisible(base::local({
[13:35:05.832]                 do.call(function(...) {
[13:35:05.832]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.832]                   if (!identical(...future.globals.maxSize.org, 
[13:35:05.832]                     ...future.globals.maxSize)) {
[13:35:05.832]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.832]                     on.exit(options(oopts), add = TRUE)
[13:35:05.832]                   }
[13:35:05.832]                   {
[13:35:05.832]                     lapply(seq_along(...future.elements_ii), 
[13:35:05.832]                       FUN = function(jj) {
[13:35:05.832]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.832]                         ...future.FUN(...future.X_jj, ...)
[13:35:05.832]                       })
[13:35:05.832]                   }
[13:35:05.832]                 }, args = future.call.arguments)
[13:35:05.832]             }))
[13:35:05.832]             future::FutureResult(value = ...future.value$value, 
[13:35:05.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:05.832]                   ...future.rng), globalenv = if (FALSE) 
[13:35:05.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:05.832]                     ...future.globalenv.names))
[13:35:05.832]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:05.832]         }, condition = base::local({
[13:35:05.832]             c <- base::c
[13:35:05.832]             inherits <- base::inherits
[13:35:05.832]             invokeRestart <- base::invokeRestart
[13:35:05.832]             length <- base::length
[13:35:05.832]             list <- base::list
[13:35:05.832]             seq.int <- base::seq.int
[13:35:05.832]             signalCondition <- base::signalCondition
[13:35:05.832]             sys.calls <- base::sys.calls
[13:35:05.832]             `[[` <- base::`[[`
[13:35:05.832]             `+` <- base::`+`
[13:35:05.832]             `<<-` <- base::`<<-`
[13:35:05.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:05.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:05.832]                   3L)]
[13:35:05.832]             }
[13:35:05.832]             function(cond) {
[13:35:05.832]                 is_error <- inherits(cond, "error")
[13:35:05.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:05.832]                   NULL)
[13:35:05.832]                 if (is_error) {
[13:35:05.832]                   sessionInformation <- function() {
[13:35:05.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:05.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:05.832]                       search = base::search(), system = base::Sys.info())
[13:35:05.832]                   }
[13:35:05.832]                   ...future.conditions[[length(...future.conditions) + 
[13:35:05.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:05.832]                     cond$call), session = sessionInformation(), 
[13:35:05.832]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:05.832]                   signalCondition(cond)
[13:35:05.832]                 }
[13:35:05.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:05.832]                 "immediateCondition"))) {
[13:35:05.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:05.832]                   ...future.conditions[[length(...future.conditions) + 
[13:35:05.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:05.832]                   if (TRUE && !signal) {
[13:35:05.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:05.832]                     {
[13:35:05.832]                       inherits <- base::inherits
[13:35:05.832]                       invokeRestart <- base::invokeRestart
[13:35:05.832]                       is.null <- base::is.null
[13:35:05.832]                       muffled <- FALSE
[13:35:05.832]                       if (inherits(cond, "message")) {
[13:35:05.832]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:05.832]                         if (muffled) 
[13:35:05.832]                           invokeRestart("muffleMessage")
[13:35:05.832]                       }
[13:35:05.832]                       else if (inherits(cond, "warning")) {
[13:35:05.832]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:05.832]                         if (muffled) 
[13:35:05.832]                           invokeRestart("muffleWarning")
[13:35:05.832]                       }
[13:35:05.832]                       else if (inherits(cond, "condition")) {
[13:35:05.832]                         if (!is.null(pattern)) {
[13:35:05.832]                           computeRestarts <- base::computeRestarts
[13:35:05.832]                           grepl <- base::grepl
[13:35:05.832]                           restarts <- computeRestarts(cond)
[13:35:05.832]                           for (restart in restarts) {
[13:35:05.832]                             name <- restart$name
[13:35:05.832]                             if (is.null(name)) 
[13:35:05.832]                               next
[13:35:05.832]                             if (!grepl(pattern, name)) 
[13:35:05.832]                               next
[13:35:05.832]                             invokeRestart(restart)
[13:35:05.832]                             muffled <- TRUE
[13:35:05.832]                             break
[13:35:05.832]                           }
[13:35:05.832]                         }
[13:35:05.832]                       }
[13:35:05.832]                       invisible(muffled)
[13:35:05.832]                     }
[13:35:05.832]                     muffleCondition(cond, pattern = "^muffle")
[13:35:05.832]                   }
[13:35:05.832]                 }
[13:35:05.832]                 else {
[13:35:05.832]                   if (TRUE) {
[13:35:05.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:05.832]                     {
[13:35:05.832]                       inherits <- base::inherits
[13:35:05.832]                       invokeRestart <- base::invokeRestart
[13:35:05.832]                       is.null <- base::is.null
[13:35:05.832]                       muffled <- FALSE
[13:35:05.832]                       if (inherits(cond, "message")) {
[13:35:05.832]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:05.832]                         if (muffled) 
[13:35:05.832]                           invokeRestart("muffleMessage")
[13:35:05.832]                       }
[13:35:05.832]                       else if (inherits(cond, "warning")) {
[13:35:05.832]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:05.832]                         if (muffled) 
[13:35:05.832]                           invokeRestart("muffleWarning")
[13:35:05.832]                       }
[13:35:05.832]                       else if (inherits(cond, "condition")) {
[13:35:05.832]                         if (!is.null(pattern)) {
[13:35:05.832]                           computeRestarts <- base::computeRestarts
[13:35:05.832]                           grepl <- base::grepl
[13:35:05.832]                           restarts <- computeRestarts(cond)
[13:35:05.832]                           for (restart in restarts) {
[13:35:05.832]                             name <- restart$name
[13:35:05.832]                             if (is.null(name)) 
[13:35:05.832]                               next
[13:35:05.832]                             if (!grepl(pattern, name)) 
[13:35:05.832]                               next
[13:35:05.832]                             invokeRestart(restart)
[13:35:05.832]                             muffled <- TRUE
[13:35:05.832]                             break
[13:35:05.832]                           }
[13:35:05.832]                         }
[13:35:05.832]                       }
[13:35:05.832]                       invisible(muffled)
[13:35:05.832]                     }
[13:35:05.832]                     muffleCondition(cond, pattern = "^muffle")
[13:35:05.832]                   }
[13:35:05.832]                 }
[13:35:05.832]             }
[13:35:05.832]         }))
[13:35:05.832]     }, error = function(ex) {
[13:35:05.832]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:05.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:05.832]                 ...future.rng), started = ...future.startTime, 
[13:35:05.832]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:05.832]             version = "1.8"), class = "FutureResult")
[13:35:05.832]     }, finally = {
[13:35:05.832]         if (!identical(...future.workdir, getwd())) 
[13:35:05.832]             setwd(...future.workdir)
[13:35:05.832]         {
[13:35:05.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:05.832]                 ...future.oldOptions$nwarnings <- NULL
[13:35:05.832]             }
[13:35:05.832]             base::options(...future.oldOptions)
[13:35:05.832]             if (.Platform$OS.type == "windows") {
[13:35:05.832]                 old_names <- names(...future.oldEnvVars)
[13:35:05.832]                 envs <- base::Sys.getenv()
[13:35:05.832]                 names <- names(envs)
[13:35:05.832]                 common <- intersect(names, old_names)
[13:35:05.832]                 added <- setdiff(names, old_names)
[13:35:05.832]                 removed <- setdiff(old_names, names)
[13:35:05.832]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:05.832]                   envs[common]]
[13:35:05.832]                 NAMES <- toupper(changed)
[13:35:05.832]                 args <- list()
[13:35:05.832]                 for (kk in seq_along(NAMES)) {
[13:35:05.832]                   name <- changed[[kk]]
[13:35:05.832]                   NAME <- NAMES[[kk]]
[13:35:05.832]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.832]                     next
[13:35:05.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:05.832]                 }
[13:35:05.832]                 NAMES <- toupper(added)
[13:35:05.832]                 for (kk in seq_along(NAMES)) {
[13:35:05.832]                   name <- added[[kk]]
[13:35:05.832]                   NAME <- NAMES[[kk]]
[13:35:05.832]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.832]                     next
[13:35:05.832]                   args[[name]] <- ""
[13:35:05.832]                 }
[13:35:05.832]                 NAMES <- toupper(removed)
[13:35:05.832]                 for (kk in seq_along(NAMES)) {
[13:35:05.832]                   name <- removed[[kk]]
[13:35:05.832]                   NAME <- NAMES[[kk]]
[13:35:05.832]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.832]                     next
[13:35:05.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:05.832]                 }
[13:35:05.832]                 if (length(args) > 0) 
[13:35:05.832]                   base::do.call(base::Sys.setenv, args = args)
[13:35:05.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:05.832]             }
[13:35:05.832]             else {
[13:35:05.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:05.832]             }
[13:35:05.832]             {
[13:35:05.832]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:05.832]                   0L) {
[13:35:05.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:05.832]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:05.832]                   base::options(opts)
[13:35:05.832]                 }
[13:35:05.832]                 {
[13:35:05.832]                   {
[13:35:05.832]                     NULL
[13:35:05.832]                     RNGkind("Mersenne-Twister")
[13:35:05.832]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:05.832]                       inherits = FALSE)
[13:35:05.832]                   }
[13:35:05.832]                   options(future.plan = NULL)
[13:35:05.832]                   if (is.na(NA_character_)) 
[13:35:05.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:05.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:05.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:05.832]                     .init = FALSE)
[13:35:05.832]                 }
[13:35:05.832]             }
[13:35:05.832]         }
[13:35:05.832]     })
[13:35:05.832]     if (TRUE) {
[13:35:05.832]         base::sink(type = "output", split = FALSE)
[13:35:05.832]         if (TRUE) {
[13:35:05.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:05.832]         }
[13:35:05.832]         else {
[13:35:05.832]             ...future.result["stdout"] <- base::list(NULL)
[13:35:05.832]         }
[13:35:05.832]         base::close(...future.stdout)
[13:35:05.832]         ...future.stdout <- NULL
[13:35:05.832]     }
[13:35:05.832]     ...future.result$conditions <- ...future.conditions
[13:35:05.832]     ...future.result$finished <- base::Sys.time()
[13:35:05.832]     ...future.result
[13:35:05.832] }
[13:35:05.834] assign_globals() ...
[13:35:05.834] List of 11
[13:35:05.834]  $ ...future.FUN            :function (x, ...)  
[13:35:05.834]  $ x_FUN                    :function (x)  
[13:35:05.834]  $ times                    : int 0
[13:35:05.834]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:05.834]  $ stop_if_not              :function (...)  
[13:35:05.834]  $ dim                      : NULL
[13:35:05.834]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:05.834]  $ future.call.arguments    : list()
[13:35:05.834]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.834]  $ ...future.elements_ii    :List of 10
[13:35:05.834]   ..$ : int 1
[13:35:05.834]   ..$ : int 2
[13:35:05.834]   ..$ : int 3
[13:35:05.834]   ..$ : int 4
[13:35:05.834]   ..$ : int 5
[13:35:05.834]   ..$ : int 6
[13:35:05.834]   ..$ : int 7
[13:35:05.834]   ..$ : int 8
[13:35:05.834]   ..$ : int 9
[13:35:05.834]   ..$ : int 10
[13:35:05.834]  $ ...future.seeds_ii       : NULL
[13:35:05.834]  $ ...future.globals.maxSize: NULL
[13:35:05.834]  - attr(*, "where")=List of 11
[13:35:05.834]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:05.834]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:05.834]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:05.834]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:05.834]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:05.834]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:05.834]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:05.834]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:05.834]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:05.834]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:05.834]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:05.834]  - attr(*, "resolved")= logi FALSE
[13:35:05.834]  - attr(*, "total_size")= num 95472
[13:35:05.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.834]  - attr(*, "already-done")= logi TRUE
[13:35:05.843] - copied ‘...future.FUN’ to environment
[13:35:05.843] - reassign environment for ‘x_FUN’
[13:35:05.843] - copied ‘x_FUN’ to environment
[13:35:05.843] - copied ‘times’ to environment
[13:35:05.844] - copied ‘stopf’ to environment
[13:35:05.844] - copied ‘stop_if_not’ to environment
[13:35:05.844] - copied ‘dim’ to environment
[13:35:05.844] - copied ‘valid_types’ to environment
[13:35:05.844] - copied ‘future.call.arguments’ to environment
[13:35:05.844] - copied ‘...future.elements_ii’ to environment
[13:35:05.844] - copied ‘...future.seeds_ii’ to environment
[13:35:05.844] - copied ‘...future.globals.maxSize’ to environment
[13:35:05.844] assign_globals() ... done
[13:35:05.845] plan(): Setting new future strategy stack:
[13:35:05.845] List of future strategies:
[13:35:05.845] 1. sequential:
[13:35:05.845]    - args: function (..., envir = parent.frame())
[13:35:05.845]    - tweaked: FALSE
[13:35:05.845]    - call: NULL
[13:35:05.845] plan(): nbrOfWorkers() = 1
[13:35:05.847] plan(): Setting new future strategy stack:
[13:35:05.847] List of future strategies:
[13:35:05.847] 1. sequential:
[13:35:05.847]    - args: function (..., envir = parent.frame())
[13:35:05.847]    - tweaked: FALSE
[13:35:05.847]    - call: plan(strategy)
[13:35:05.847] plan(): nbrOfWorkers() = 1
[13:35:05.848] SequentialFuture started (and completed)
[13:35:05.848] - Launch lazy future ... done
[13:35:05.848] run() for ‘SequentialFuture’ ... done
[13:35:05.848] Created future:
[13:35:05.848] SequentialFuture:
[13:35:05.848] Label: ‘future_vapply-1’
[13:35:05.848] Expression:
[13:35:05.848] {
[13:35:05.848]     do.call(function(...) {
[13:35:05.848]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.848]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:05.848]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.848]             on.exit(options(oopts), add = TRUE)
[13:35:05.848]         }
[13:35:05.848]         {
[13:35:05.848]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:05.848]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.848]                 ...future.FUN(...future.X_jj, ...)
[13:35:05.848]             })
[13:35:05.848]         }
[13:35:05.848]     }, args = future.call.arguments)
[13:35:05.848] }
[13:35:05.848] Lazy evaluation: FALSE
[13:35:05.848] Asynchronous evaluation: FALSE
[13:35:05.848] Local evaluation: TRUE
[13:35:05.848] Environment: R_GlobalEnv
[13:35:05.848] Capture standard output: TRUE
[13:35:05.848] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:05.848] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:05.848] Packages: 1 packages (‘future.apply’)
[13:35:05.848] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:05.848] Resolved: TRUE
[13:35:05.848] Value: 480 bytes of class ‘list’
[13:35:05.848] Early signaling: FALSE
[13:35:05.848] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:05.848] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:05.849] Chunk #1 of 1 ... DONE
[13:35:05.849] Launching 1 futures (chunks) ... DONE
[13:35:05.849] Resolving 1 futures (chunks) ...
[13:35:05.849] resolve() on list ...
[13:35:05.849]  recursive: 0
[13:35:05.849]  length: 1
[13:35:05.850] 
[13:35:05.850] resolved() for ‘SequentialFuture’ ...
[13:35:05.850] - state: ‘finished’
[13:35:05.850] - run: TRUE
[13:35:05.850] - result: ‘FutureResult’
[13:35:05.850] resolved() for ‘SequentialFuture’ ... done
[13:35:05.850] Future #1
[13:35:05.850] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:05.850] - nx: 1
[13:35:05.850] - relay: TRUE
[13:35:05.851] - stdout: TRUE
[13:35:05.851] - signal: TRUE
[13:35:05.851] - resignal: FALSE
[13:35:05.851] - force: TRUE
[13:35:05.851] - relayed: [n=1] FALSE
[13:35:05.851] - queued futures: [n=1] FALSE
[13:35:05.851]  - until=1
[13:35:05.851]  - relaying element #1
[13:35:05.851] - relayed: [n=1] TRUE
[13:35:05.851] - queued futures: [n=1] TRUE
[13:35:05.851] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:05.852]  length: 0 (resolved future 1)
[13:35:05.852] Relaying remaining futures
[13:35:05.852] signalConditionsASAP(NULL, pos=0) ...
[13:35:05.852] - nx: 1
[13:35:05.852] - relay: TRUE
[13:35:05.852] - stdout: TRUE
[13:35:05.852] - signal: TRUE
[13:35:05.852] - resignal: FALSE
[13:35:05.852] - force: TRUE
[13:35:05.852] - relayed: [n=1] TRUE
[13:35:05.852] - queued futures: [n=1] TRUE
 - flush all
[13:35:05.852] - relayed: [n=1] TRUE
[13:35:05.853] - queued futures: [n=1] TRUE
[13:35:05.853] signalConditionsASAP(NULL, pos=0) ... done
[13:35:05.853] resolve() on list ... DONE
[13:35:05.853]  - Number of value chunks collected: 1
[13:35:05.853] Resolving 1 futures (chunks) ... DONE
[13:35:05.853] Reducing values from 1 chunks ...
[13:35:05.853]  - Number of values collected after concatenation: 10
[13:35:05.853]  - Number of values expected: 10
[13:35:05.853] Reducing values from 1 chunks ... DONE
[13:35:05.853] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[13:35:05.854] future_lapply() ...
[13:35:05.856] Number of chunks: 1
[13:35:05.856] getGlobalsAndPackagesXApply() ...
[13:35:05.856]  - future.globals: TRUE
[13:35:05.856] getGlobalsAndPackages() ...
[13:35:05.856] Searching for globals...
[13:35:05.859] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[13:35:05.859] Searching for globals ... DONE
[13:35:05.860] Resolving globals: FALSE
[13:35:05.860] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[13:35:05.861] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:05.861] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:05.861] - packages: [1] ‘future.apply’
[13:35:05.861] getGlobalsAndPackages() ... DONE
[13:35:05.861]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:05.861]  - needed namespaces: [n=1] ‘future.apply’
[13:35:05.861] Finding globals ... DONE
[13:35:05.861]  - use_args: TRUE
[13:35:05.861]  - Getting '...' globals ...
[13:35:05.862] resolve() on list ...
[13:35:05.862]  recursive: 0
[13:35:05.862]  length: 1
[13:35:05.862]  elements: ‘...’
[13:35:05.862]  length: 0 (resolved future 1)
[13:35:05.862] resolve() on list ... DONE
[13:35:05.862]    - '...' content: [n=0] 
[13:35:05.862] List of 1
[13:35:05.862]  $ ...: list()
[13:35:05.862]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.862]  - attr(*, "where")=List of 1
[13:35:05.862]   ..$ ...:<environment: 0x5574d00cf818> 
[13:35:05.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.862]  - attr(*, "resolved")= logi TRUE
[13:35:05.862]  - attr(*, "total_size")= num NA
[13:35:05.865]  - Getting '...' globals ... DONE
[13:35:05.865] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:05.865] List of 8
[13:35:05.865]  $ ...future.FUN:function (x, ...)  
[13:35:05.865]  $ x_FUN        :function (x)  
[13:35:05.865]  $ times        : int 0
[13:35:05.865]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:05.865]  $ stop_if_not  :function (...)  
[13:35:05.865]  $ dim          : NULL
[13:35:05.865]  $ valid_types  : chr [1:2] "logical" "integer"
[13:35:05.865]  $ ...          : list()
[13:35:05.865]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.865]  - attr(*, "where")=List of 8
[13:35:05.865]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:05.865]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:05.865]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:05.865]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:05.865]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:05.865]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:05.865]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:05.865]   ..$ ...          :<environment: 0x5574d00cf818> 
[13:35:05.865]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.865]  - attr(*, "resolved")= logi FALSE
[13:35:05.865]  - attr(*, "total_size")= num 95400
[13:35:05.871] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:05.871] getGlobalsAndPackagesXApply() ... DONE
[13:35:05.871] Number of futures (= number of chunks): 1
[13:35:05.871] Launching 1 futures (chunks) ...
[13:35:05.871] Chunk #1 of 1 ...
[13:35:05.872]  - Finding globals in 'X' for chunk #1 ...
[13:35:05.872] getGlobalsAndPackages() ...
[13:35:05.872] Searching for globals...
[13:35:05.872] 
[13:35:05.872] Searching for globals ... DONE
[13:35:05.872] - globals: [0] <none>
[13:35:05.872] getGlobalsAndPackages() ... DONE
[13:35:05.872]    + additional globals found: [n=0] 
[13:35:05.872]    + additional namespaces needed: [n=0] 
[13:35:05.872]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:05.873]  - seeds: <none>
[13:35:05.873]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.873] getGlobalsAndPackages() ...
[13:35:05.873] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.873] Resolving globals: FALSE
[13:35:05.873] Tweak future expression to call with '...' arguments ...
[13:35:05.873] {
[13:35:05.873]     do.call(function(...) {
[13:35:05.873]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.873]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:05.873]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.873]             on.exit(options(oopts), add = TRUE)
[13:35:05.873]         }
[13:35:05.873]         {
[13:35:05.873]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:05.873]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.873]                 ...future.FUN(...future.X_jj, ...)
[13:35:05.873]             })
[13:35:05.873]         }
[13:35:05.873]     }, args = future.call.arguments)
[13:35:05.873] }
[13:35:05.873] Tweak future expression to call with '...' arguments ... DONE
[13:35:05.874] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.874] - packages: [1] ‘future.apply’
[13:35:05.874] getGlobalsAndPackages() ... DONE
[13:35:05.874] run() for ‘Future’ ...
[13:35:05.874] - state: ‘created’
[13:35:05.875] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:05.875] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:05.875] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:05.875]   - Field: ‘label’
[13:35:05.875]   - Field: ‘local’
[13:35:05.875]   - Field: ‘owner’
[13:35:05.875]   - Field: ‘envir’
[13:35:05.875]   - Field: ‘packages’
[13:35:05.875]   - Field: ‘gc’
[13:35:05.876]   - Field: ‘conditions’
[13:35:05.876]   - Field: ‘expr’
[13:35:05.876]   - Field: ‘uuid’
[13:35:05.876]   - Field: ‘seed’
[13:35:05.876]   - Field: ‘version’
[13:35:05.876]   - Field: ‘result’
[13:35:05.876]   - Field: ‘asynchronous’
[13:35:05.876]   - Field: ‘calls’
[13:35:05.876]   - Field: ‘globals’
[13:35:05.876]   - Field: ‘stdout’
[13:35:05.876]   - Field: ‘earlySignal’
[13:35:05.876]   - Field: ‘lazy’
[13:35:05.877]   - Field: ‘state’
[13:35:05.877] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:05.877] - Launch lazy future ...
[13:35:05.877] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:05.877] Packages needed by future strategies (n = 0): <none>
[13:35:05.877] {
[13:35:05.877]     {
[13:35:05.877]         {
[13:35:05.877]             ...future.startTime <- base::Sys.time()
[13:35:05.877]             {
[13:35:05.877]                 {
[13:35:05.877]                   {
[13:35:05.877]                     {
[13:35:05.877]                       base::local({
[13:35:05.877]                         has_future <- base::requireNamespace("future", 
[13:35:05.877]                           quietly = TRUE)
[13:35:05.877]                         if (has_future) {
[13:35:05.877]                           ns <- base::getNamespace("future")
[13:35:05.877]                           version <- ns[[".package"]][["version"]]
[13:35:05.877]                           if (is.null(version)) 
[13:35:05.877]                             version <- utils::packageVersion("future")
[13:35:05.877]                         }
[13:35:05.877]                         else {
[13:35:05.877]                           version <- NULL
[13:35:05.877]                         }
[13:35:05.877]                         if (!has_future || version < "1.8.0") {
[13:35:05.877]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:05.877]                             "", base::R.version$version.string), 
[13:35:05.877]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:05.877]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:05.877]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:05.877]                               "release", "version")], collapse = " "), 
[13:35:05.877]                             hostname = base::Sys.info()[["nodename"]])
[13:35:05.877]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:05.877]                             info)
[13:35:05.877]                           info <- base::paste(info, collapse = "; ")
[13:35:05.877]                           if (!has_future) {
[13:35:05.877]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:05.877]                               info)
[13:35:05.877]                           }
[13:35:05.877]                           else {
[13:35:05.877]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:05.877]                               info, version)
[13:35:05.877]                           }
[13:35:05.877]                           base::stop(msg)
[13:35:05.877]                         }
[13:35:05.877]                       })
[13:35:05.877]                     }
[13:35:05.877]                     base::local({
[13:35:05.877]                       for (pkg in "future.apply") {
[13:35:05.877]                         base::loadNamespace(pkg)
[13:35:05.877]                         base::library(pkg, character.only = TRUE)
[13:35:05.877]                       }
[13:35:05.877]                     })
[13:35:05.877]                   }
[13:35:05.877]                   ...future.strategy.old <- future::plan("list")
[13:35:05.877]                   options(future.plan = NULL)
[13:35:05.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:05.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:05.877]                 }
[13:35:05.877]                 ...future.workdir <- getwd()
[13:35:05.877]             }
[13:35:05.877]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:05.877]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:05.877]         }
[13:35:05.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:05.877]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:05.877]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:05.877]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:05.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:05.877]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:05.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:05.877]             base::names(...future.oldOptions))
[13:35:05.877]     }
[13:35:05.877]     if (FALSE) {
[13:35:05.877]     }
[13:35:05.877]     else {
[13:35:05.877]         if (TRUE) {
[13:35:05.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:05.877]                 open = "w")
[13:35:05.877]         }
[13:35:05.877]         else {
[13:35:05.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:05.877]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:05.877]         }
[13:35:05.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:05.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:05.877]             base::sink(type = "output", split = FALSE)
[13:35:05.877]             base::close(...future.stdout)
[13:35:05.877]         }, add = TRUE)
[13:35:05.877]     }
[13:35:05.877]     ...future.frame <- base::sys.nframe()
[13:35:05.877]     ...future.conditions <- base::list()
[13:35:05.877]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:05.877]     if (FALSE) {
[13:35:05.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:05.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:05.877]     }
[13:35:05.877]     ...future.result <- base::tryCatch({
[13:35:05.877]         base::withCallingHandlers({
[13:35:05.877]             ...future.value <- base::withVisible(base::local({
[13:35:05.877]                 do.call(function(...) {
[13:35:05.877]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.877]                   if (!identical(...future.globals.maxSize.org, 
[13:35:05.877]                     ...future.globals.maxSize)) {
[13:35:05.877]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.877]                     on.exit(options(oopts), add = TRUE)
[13:35:05.877]                   }
[13:35:05.877]                   {
[13:35:05.877]                     lapply(seq_along(...future.elements_ii), 
[13:35:05.877]                       FUN = function(jj) {
[13:35:05.877]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.877]                         ...future.FUN(...future.X_jj, ...)
[13:35:05.877]                       })
[13:35:05.877]                   }
[13:35:05.877]                 }, args = future.call.arguments)
[13:35:05.877]             }))
[13:35:05.877]             future::FutureResult(value = ...future.value$value, 
[13:35:05.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:05.877]                   ...future.rng), globalenv = if (FALSE) 
[13:35:05.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:05.877]                     ...future.globalenv.names))
[13:35:05.877]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:05.877]         }, condition = base::local({
[13:35:05.877]             c <- base::c
[13:35:05.877]             inherits <- base::inherits
[13:35:05.877]             invokeRestart <- base::invokeRestart
[13:35:05.877]             length <- base::length
[13:35:05.877]             list <- base::list
[13:35:05.877]             seq.int <- base::seq.int
[13:35:05.877]             signalCondition <- base::signalCondition
[13:35:05.877]             sys.calls <- base::sys.calls
[13:35:05.877]             `[[` <- base::`[[`
[13:35:05.877]             `+` <- base::`+`
[13:35:05.877]             `<<-` <- base::`<<-`
[13:35:05.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:05.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:05.877]                   3L)]
[13:35:05.877]             }
[13:35:05.877]             function(cond) {
[13:35:05.877]                 is_error <- inherits(cond, "error")
[13:35:05.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:05.877]                   NULL)
[13:35:05.877]                 if (is_error) {
[13:35:05.877]                   sessionInformation <- function() {
[13:35:05.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:05.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:05.877]                       search = base::search(), system = base::Sys.info())
[13:35:05.877]                   }
[13:35:05.877]                   ...future.conditions[[length(...future.conditions) + 
[13:35:05.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:05.877]                     cond$call), session = sessionInformation(), 
[13:35:05.877]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:05.877]                   signalCondition(cond)
[13:35:05.877]                 }
[13:35:05.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:05.877]                 "immediateCondition"))) {
[13:35:05.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:05.877]                   ...future.conditions[[length(...future.conditions) + 
[13:35:05.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:05.877]                   if (TRUE && !signal) {
[13:35:05.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:05.877]                     {
[13:35:05.877]                       inherits <- base::inherits
[13:35:05.877]                       invokeRestart <- base::invokeRestart
[13:35:05.877]                       is.null <- base::is.null
[13:35:05.877]                       muffled <- FALSE
[13:35:05.877]                       if (inherits(cond, "message")) {
[13:35:05.877]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:05.877]                         if (muffled) 
[13:35:05.877]                           invokeRestart("muffleMessage")
[13:35:05.877]                       }
[13:35:05.877]                       else if (inherits(cond, "warning")) {
[13:35:05.877]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:05.877]                         if (muffled) 
[13:35:05.877]                           invokeRestart("muffleWarning")
[13:35:05.877]                       }
[13:35:05.877]                       else if (inherits(cond, "condition")) {
[13:35:05.877]                         if (!is.null(pattern)) {
[13:35:05.877]                           computeRestarts <- base::computeRestarts
[13:35:05.877]                           grepl <- base::grepl
[13:35:05.877]                           restarts <- computeRestarts(cond)
[13:35:05.877]                           for (restart in restarts) {
[13:35:05.877]                             name <- restart$name
[13:35:05.877]                             if (is.null(name)) 
[13:35:05.877]                               next
[13:35:05.877]                             if (!grepl(pattern, name)) 
[13:35:05.877]                               next
[13:35:05.877]                             invokeRestart(restart)
[13:35:05.877]                             muffled <- TRUE
[13:35:05.877]                             break
[13:35:05.877]                           }
[13:35:05.877]                         }
[13:35:05.877]                       }
[13:35:05.877]                       invisible(muffled)
[13:35:05.877]                     }
[13:35:05.877]                     muffleCondition(cond, pattern = "^muffle")
[13:35:05.877]                   }
[13:35:05.877]                 }
[13:35:05.877]                 else {
[13:35:05.877]                   if (TRUE) {
[13:35:05.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:05.877]                     {
[13:35:05.877]                       inherits <- base::inherits
[13:35:05.877]                       invokeRestart <- base::invokeRestart
[13:35:05.877]                       is.null <- base::is.null
[13:35:05.877]                       muffled <- FALSE
[13:35:05.877]                       if (inherits(cond, "message")) {
[13:35:05.877]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:05.877]                         if (muffled) 
[13:35:05.877]                           invokeRestart("muffleMessage")
[13:35:05.877]                       }
[13:35:05.877]                       else if (inherits(cond, "warning")) {
[13:35:05.877]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:05.877]                         if (muffled) 
[13:35:05.877]                           invokeRestart("muffleWarning")
[13:35:05.877]                       }
[13:35:05.877]                       else if (inherits(cond, "condition")) {
[13:35:05.877]                         if (!is.null(pattern)) {
[13:35:05.877]                           computeRestarts <- base::computeRestarts
[13:35:05.877]                           grepl <- base::grepl
[13:35:05.877]                           restarts <- computeRestarts(cond)
[13:35:05.877]                           for (restart in restarts) {
[13:35:05.877]                             name <- restart$name
[13:35:05.877]                             if (is.null(name)) 
[13:35:05.877]                               next
[13:35:05.877]                             if (!grepl(pattern, name)) 
[13:35:05.877]                               next
[13:35:05.877]                             invokeRestart(restart)
[13:35:05.877]                             muffled <- TRUE
[13:35:05.877]                             break
[13:35:05.877]                           }
[13:35:05.877]                         }
[13:35:05.877]                       }
[13:35:05.877]                       invisible(muffled)
[13:35:05.877]                     }
[13:35:05.877]                     muffleCondition(cond, pattern = "^muffle")
[13:35:05.877]                   }
[13:35:05.877]                 }
[13:35:05.877]             }
[13:35:05.877]         }))
[13:35:05.877]     }, error = function(ex) {
[13:35:05.877]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:05.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:05.877]                 ...future.rng), started = ...future.startTime, 
[13:35:05.877]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:05.877]             version = "1.8"), class = "FutureResult")
[13:35:05.877]     }, finally = {
[13:35:05.877]         if (!identical(...future.workdir, getwd())) 
[13:35:05.877]             setwd(...future.workdir)
[13:35:05.877]         {
[13:35:05.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:05.877]                 ...future.oldOptions$nwarnings <- NULL
[13:35:05.877]             }
[13:35:05.877]             base::options(...future.oldOptions)
[13:35:05.877]             if (.Platform$OS.type == "windows") {
[13:35:05.877]                 old_names <- names(...future.oldEnvVars)
[13:35:05.877]                 envs <- base::Sys.getenv()
[13:35:05.877]                 names <- names(envs)
[13:35:05.877]                 common <- intersect(names, old_names)
[13:35:05.877]                 added <- setdiff(names, old_names)
[13:35:05.877]                 removed <- setdiff(old_names, names)
[13:35:05.877]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:05.877]                   envs[common]]
[13:35:05.877]                 NAMES <- toupper(changed)
[13:35:05.877]                 args <- list()
[13:35:05.877]                 for (kk in seq_along(NAMES)) {
[13:35:05.877]                   name <- changed[[kk]]
[13:35:05.877]                   NAME <- NAMES[[kk]]
[13:35:05.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.877]                     next
[13:35:05.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:05.877]                 }
[13:35:05.877]                 NAMES <- toupper(added)
[13:35:05.877]                 for (kk in seq_along(NAMES)) {
[13:35:05.877]                   name <- added[[kk]]
[13:35:05.877]                   NAME <- NAMES[[kk]]
[13:35:05.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.877]                     next
[13:35:05.877]                   args[[name]] <- ""
[13:35:05.877]                 }
[13:35:05.877]                 NAMES <- toupper(removed)
[13:35:05.877]                 for (kk in seq_along(NAMES)) {
[13:35:05.877]                   name <- removed[[kk]]
[13:35:05.877]                   NAME <- NAMES[[kk]]
[13:35:05.877]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.877]                     next
[13:35:05.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:05.877]                 }
[13:35:05.877]                 if (length(args) > 0) 
[13:35:05.877]                   base::do.call(base::Sys.setenv, args = args)
[13:35:05.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:05.877]             }
[13:35:05.877]             else {
[13:35:05.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:05.877]             }
[13:35:05.877]             {
[13:35:05.877]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:05.877]                   0L) {
[13:35:05.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:05.877]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:05.877]                   base::options(opts)
[13:35:05.877]                 }
[13:35:05.877]                 {
[13:35:05.877]                   {
[13:35:05.877]                     NULL
[13:35:05.877]                     RNGkind("Mersenne-Twister")
[13:35:05.877]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:05.877]                       inherits = FALSE)
[13:35:05.877]                   }
[13:35:05.877]                   options(future.plan = NULL)
[13:35:05.877]                   if (is.na(NA_character_)) 
[13:35:05.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:05.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:05.877]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:05.877]                     .init = FALSE)
[13:35:05.877]                 }
[13:35:05.877]             }
[13:35:05.877]         }
[13:35:05.877]     })
[13:35:05.877]     if (TRUE) {
[13:35:05.877]         base::sink(type = "output", split = FALSE)
[13:35:05.877]         if (TRUE) {
[13:35:05.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:05.877]         }
[13:35:05.877]         else {
[13:35:05.877]             ...future.result["stdout"] <- base::list(NULL)
[13:35:05.877]         }
[13:35:05.877]         base::close(...future.stdout)
[13:35:05.877]         ...future.stdout <- NULL
[13:35:05.877]     }
[13:35:05.877]     ...future.result$conditions <- ...future.conditions
[13:35:05.877]     ...future.result$finished <- base::Sys.time()
[13:35:05.877]     ...future.result
[13:35:05.877] }
[13:35:05.879] assign_globals() ...
[13:35:05.879] List of 11
[13:35:05.879]  $ ...future.FUN            :function (x, ...)  
[13:35:05.879]  $ x_FUN                    :function (x)  
[13:35:05.879]  $ times                    : int 0
[13:35:05.879]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:05.879]  $ stop_if_not              :function (...)  
[13:35:05.879]  $ dim                      : NULL
[13:35:05.879]  $ valid_types              : chr [1:2] "logical" "integer"
[13:35:05.879]  $ future.call.arguments    : list()
[13:35:05.879]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.879]  $ ...future.elements_ii    :List of 10
[13:35:05.879]   ..$ : int 1
[13:35:05.879]   ..$ : int 2
[13:35:05.879]   ..$ : int 3
[13:35:05.879]   ..$ : int 4
[13:35:05.879]   ..$ : int 5
[13:35:05.879]   ..$ : int 6
[13:35:05.879]   ..$ : int 7
[13:35:05.879]   ..$ : int 8
[13:35:05.879]   ..$ : int 9
[13:35:05.879]   ..$ : int 10
[13:35:05.879]  $ ...future.seeds_ii       : NULL
[13:35:05.879]  $ ...future.globals.maxSize: NULL
[13:35:05.879]  - attr(*, "where")=List of 11
[13:35:05.879]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:05.879]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:05.879]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:05.879]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:05.879]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:05.879]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:05.879]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:05.879]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:05.879]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:05.879]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:05.879]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:05.879]  - attr(*, "resolved")= logi FALSE
[13:35:05.879]  - attr(*, "total_size")= num 95400
[13:35:05.879]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.879]  - attr(*, "already-done")= logi TRUE
[13:35:05.889] - copied ‘...future.FUN’ to environment
[13:35:05.889] - reassign environment for ‘x_FUN’
[13:35:05.889] - copied ‘x_FUN’ to environment
[13:35:05.890] - copied ‘times’ to environment
[13:35:05.890] - copied ‘stopf’ to environment
[13:35:05.890] - copied ‘stop_if_not’ to environment
[13:35:05.890] - copied ‘dim’ to environment
[13:35:05.890] - copied ‘valid_types’ to environment
[13:35:05.890] - copied ‘future.call.arguments’ to environment
[13:35:05.890] - copied ‘...future.elements_ii’ to environment
[13:35:05.890] - copied ‘...future.seeds_ii’ to environment
[13:35:05.890] - copied ‘...future.globals.maxSize’ to environment
[13:35:05.890] assign_globals() ... done
[13:35:05.891] plan(): Setting new future strategy stack:
[13:35:05.891] List of future strategies:
[13:35:05.891] 1. sequential:
[13:35:05.891]    - args: function (..., envir = parent.frame())
[13:35:05.891]    - tweaked: FALSE
[13:35:05.891]    - call: NULL
[13:35:05.891] plan(): nbrOfWorkers() = 1
[13:35:05.892] plan(): Setting new future strategy stack:
[13:35:05.892] List of future strategies:
[13:35:05.892] 1. sequential:
[13:35:05.892]    - args: function (..., envir = parent.frame())
[13:35:05.892]    - tweaked: FALSE
[13:35:05.892]    - call: plan(strategy)
[13:35:05.892] plan(): nbrOfWorkers() = 1
[13:35:05.892] SequentialFuture started (and completed)
[13:35:05.893] - Launch lazy future ... done
[13:35:05.893] run() for ‘SequentialFuture’ ... done
[13:35:05.893] Created future:
[13:35:05.893] SequentialFuture:
[13:35:05.893] Label: ‘future_vapply-1’
[13:35:05.893] Expression:
[13:35:05.893] {
[13:35:05.893]     do.call(function(...) {
[13:35:05.893]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.893]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:05.893]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.893]             on.exit(options(oopts), add = TRUE)
[13:35:05.893]         }
[13:35:05.893]         {
[13:35:05.893]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:05.893]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.893]                 ...future.FUN(...future.X_jj, ...)
[13:35:05.893]             })
[13:35:05.893]         }
[13:35:05.893]     }, args = future.call.arguments)
[13:35:05.893] }
[13:35:05.893] Lazy evaluation: FALSE
[13:35:05.893] Asynchronous evaluation: FALSE
[13:35:05.893] Local evaluation: TRUE
[13:35:05.893] Environment: R_GlobalEnv
[13:35:05.893] Capture standard output: TRUE
[13:35:05.893] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:05.893] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:05.893] Packages: 1 packages (‘future.apply’)
[13:35:05.893] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:05.893] Resolved: TRUE
[13:35:05.893] Value: 480 bytes of class ‘list’
[13:35:05.893] Early signaling: FALSE
[13:35:05.893] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:05.893] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:05.894] Chunk #1 of 1 ... DONE
[13:35:05.894] Launching 1 futures (chunks) ... DONE
[13:35:05.894] Resolving 1 futures (chunks) ...
[13:35:05.894] resolve() on list ...
[13:35:05.894]  recursive: 0
[13:35:05.894]  length: 1
[13:35:05.894] 
[13:35:05.895] resolved() for ‘SequentialFuture’ ...
[13:35:05.895] - state: ‘finished’
[13:35:05.895] - run: TRUE
[13:35:05.895] - result: ‘FutureResult’
[13:35:05.895] resolved() for ‘SequentialFuture’ ... done
[13:35:05.895] Future #1
[13:35:05.895] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:05.895] - nx: 1
[13:35:05.895] - relay: TRUE
[13:35:05.895] - stdout: TRUE
[13:35:05.895] - signal: TRUE
[13:35:05.895] - resignal: FALSE
[13:35:05.896] - force: TRUE
[13:35:05.896] - relayed: [n=1] FALSE
[13:35:05.896] - queued futures: [n=1] FALSE
[13:35:05.896]  - until=1
[13:35:05.896]  - relaying element #1
[13:35:05.896] - relayed: [n=1] TRUE
[13:35:05.896] - queued futures: [n=1] TRUE
[13:35:05.896] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:05.896]  length: 0 (resolved future 1)
[13:35:05.896] Relaying remaining futures
[13:35:05.896] signalConditionsASAP(NULL, pos=0) ...
[13:35:05.897] - nx: 1
[13:35:05.897] - relay: TRUE
[13:35:05.897] - stdout: TRUE
[13:35:05.897] - signal: TRUE
[13:35:05.897] - resignal: FALSE
[13:35:05.897] - force: TRUE
[13:35:05.897] - relayed: [n=1] TRUE
[13:35:05.897] - queued futures: [n=1] TRUE
 - flush all
[13:35:05.897] - relayed: [n=1] TRUE
[13:35:05.897] - queued futures: [n=1] TRUE
[13:35:05.897] signalConditionsASAP(NULL, pos=0) ... done
[13:35:05.897] resolve() on list ... DONE
[13:35:05.898]  - Number of value chunks collected: 1
[13:35:05.898] Resolving 1 futures (chunks) ... DONE
[13:35:05.898] Reducing values from 1 chunks ...
[13:35:05.898]  - Number of values collected after concatenation: 10
[13:35:05.898]  - Number of values expected: 10
[13:35:05.898] Reducing values from 1 chunks ... DONE
[13:35:05.898] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[13:35:05.899] future_lapply() ...
[13:35:05.900] Number of chunks: 1
[13:35:05.900] getGlobalsAndPackagesXApply() ...
[13:35:05.901]  - future.globals: TRUE
[13:35:05.901] getGlobalsAndPackages() ...
[13:35:05.901] Searching for globals...
[13:35:05.903] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:05.903] Searching for globals ... DONE
[13:35:05.904] Resolving globals: FALSE
[13:35:05.904] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[13:35:05.905] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:05.905] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:05.905] - packages: [1] ‘future.apply’
[13:35:05.905] getGlobalsAndPackages() ... DONE
[13:35:05.905]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:05.905]  - needed namespaces: [n=1] ‘future.apply’
[13:35:05.905] Finding globals ... DONE
[13:35:05.905]  - use_args: TRUE
[13:35:05.905]  - Getting '...' globals ...
[13:35:05.906] resolve() on list ...
[13:35:05.906]  recursive: 0
[13:35:05.906]  length: 1
[13:35:05.906]  elements: ‘...’
[13:35:05.906]  length: 0 (resolved future 1)
[13:35:05.906] resolve() on list ... DONE
[13:35:05.906]    - '...' content: [n=0] 
[13:35:05.906] List of 1
[13:35:05.906]  $ ...: list()
[13:35:05.906]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.906]  - attr(*, "where")=List of 1
[13:35:05.906]   ..$ ...:<environment: 0x5574d07ad0e0> 
[13:35:05.906]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.906]  - attr(*, "resolved")= logi TRUE
[13:35:05.906]  - attr(*, "total_size")= num NA
[13:35:05.910]  - Getting '...' globals ... DONE
[13:35:05.910] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:05.910] List of 8
[13:35:05.910]  $ ...future.FUN:function (x, ...)  
[13:35:05.910]  $ x_FUN        :function (x)  
[13:35:05.910]  $ times        : int 1
[13:35:05.910]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:05.910]  $ stop_if_not  :function (...)  
[13:35:05.910]  $ dim          : NULL
[13:35:05.910]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:05.910]  $ ...          : list()
[13:35:05.910]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.910]  - attr(*, "where")=List of 8
[13:35:05.910]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:05.910]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:05.910]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:05.910]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:05.910]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:05.910]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:05.910]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:05.910]   ..$ ...          :<environment: 0x5574d07ad0e0> 
[13:35:05.910]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.910]  - attr(*, "resolved")= logi FALSE
[13:35:05.910]  - attr(*, "total_size")= num 94336
[13:35:05.915] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:05.915] getGlobalsAndPackagesXApply() ... DONE
[13:35:05.915] Number of futures (= number of chunks): 1
[13:35:05.915] Launching 1 futures (chunks) ...
[13:35:05.915] Chunk #1 of 1 ...
[13:35:05.915]  - Finding globals in 'X' for chunk #1 ...
[13:35:05.915] getGlobalsAndPackages() ...
[13:35:05.916] Searching for globals...
[13:35:05.916] 
[13:35:05.916] Searching for globals ... DONE
[13:35:05.916] - globals: [0] <none>
[13:35:05.916] getGlobalsAndPackages() ... DONE
[13:35:05.916]    + additional globals found: [n=0] 
[13:35:05.916]    + additional namespaces needed: [n=0] 
[13:35:05.916]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:05.916]  - seeds: <none>
[13:35:05.916]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.917] getGlobalsAndPackages() ...
[13:35:05.917] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.917] Resolving globals: FALSE
[13:35:05.917] Tweak future expression to call with '...' arguments ...
[13:35:05.917] {
[13:35:05.917]     do.call(function(...) {
[13:35:05.917]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.917]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:05.917]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.917]             on.exit(options(oopts), add = TRUE)
[13:35:05.917]         }
[13:35:05.917]         {
[13:35:05.917]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:05.917]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.917]                 ...future.FUN(...future.X_jj, ...)
[13:35:05.917]             })
[13:35:05.917]         }
[13:35:05.917]     }, args = future.call.arguments)
[13:35:05.917] }
[13:35:05.917] Tweak future expression to call with '...' arguments ... DONE
[13:35:05.918] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.918] - packages: [1] ‘future.apply’
[13:35:05.918] getGlobalsAndPackages() ... DONE
[13:35:05.918] run() for ‘Future’ ...
[13:35:05.918] - state: ‘created’
[13:35:05.918] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:05.919] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:05.919] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:05.919]   - Field: ‘label’
[13:35:05.919]   - Field: ‘local’
[13:35:05.919]   - Field: ‘owner’
[13:35:05.919]   - Field: ‘envir’
[13:35:05.919]   - Field: ‘packages’
[13:35:05.919]   - Field: ‘gc’
[13:35:05.919]   - Field: ‘conditions’
[13:35:05.919]   - Field: ‘expr’
[13:35:05.919]   - Field: ‘uuid’
[13:35:05.920]   - Field: ‘seed’
[13:35:05.920]   - Field: ‘version’
[13:35:05.920]   - Field: ‘result’
[13:35:05.920]   - Field: ‘asynchronous’
[13:35:05.920]   - Field: ‘calls’
[13:35:05.920]   - Field: ‘globals’
[13:35:05.920]   - Field: ‘stdout’
[13:35:05.920]   - Field: ‘earlySignal’
[13:35:05.920]   - Field: ‘lazy’
[13:35:05.920]   - Field: ‘state’
[13:35:05.920] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:05.920] - Launch lazy future ...
[13:35:05.921] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:05.921] Packages needed by future strategies (n = 0): <none>
[13:35:05.921] {
[13:35:05.921]     {
[13:35:05.921]         {
[13:35:05.921]             ...future.startTime <- base::Sys.time()
[13:35:05.921]             {
[13:35:05.921]                 {
[13:35:05.921]                   {
[13:35:05.921]                     {
[13:35:05.921]                       base::local({
[13:35:05.921]                         has_future <- base::requireNamespace("future", 
[13:35:05.921]                           quietly = TRUE)
[13:35:05.921]                         if (has_future) {
[13:35:05.921]                           ns <- base::getNamespace("future")
[13:35:05.921]                           version <- ns[[".package"]][["version"]]
[13:35:05.921]                           if (is.null(version)) 
[13:35:05.921]                             version <- utils::packageVersion("future")
[13:35:05.921]                         }
[13:35:05.921]                         else {
[13:35:05.921]                           version <- NULL
[13:35:05.921]                         }
[13:35:05.921]                         if (!has_future || version < "1.8.0") {
[13:35:05.921]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:05.921]                             "", base::R.version$version.string), 
[13:35:05.921]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:05.921]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:05.921]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:05.921]                               "release", "version")], collapse = " "), 
[13:35:05.921]                             hostname = base::Sys.info()[["nodename"]])
[13:35:05.921]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:05.921]                             info)
[13:35:05.921]                           info <- base::paste(info, collapse = "; ")
[13:35:05.921]                           if (!has_future) {
[13:35:05.921]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:05.921]                               info)
[13:35:05.921]                           }
[13:35:05.921]                           else {
[13:35:05.921]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:05.921]                               info, version)
[13:35:05.921]                           }
[13:35:05.921]                           base::stop(msg)
[13:35:05.921]                         }
[13:35:05.921]                       })
[13:35:05.921]                     }
[13:35:05.921]                     base::local({
[13:35:05.921]                       for (pkg in "future.apply") {
[13:35:05.921]                         base::loadNamespace(pkg)
[13:35:05.921]                         base::library(pkg, character.only = TRUE)
[13:35:05.921]                       }
[13:35:05.921]                     })
[13:35:05.921]                   }
[13:35:05.921]                   ...future.strategy.old <- future::plan("list")
[13:35:05.921]                   options(future.plan = NULL)
[13:35:05.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:05.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:05.921]                 }
[13:35:05.921]                 ...future.workdir <- getwd()
[13:35:05.921]             }
[13:35:05.921]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:05.921]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:05.921]         }
[13:35:05.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:05.921]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:05.921]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:05.921]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:05.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:05.921]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:05.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:05.921]             base::names(...future.oldOptions))
[13:35:05.921]     }
[13:35:05.921]     if (FALSE) {
[13:35:05.921]     }
[13:35:05.921]     else {
[13:35:05.921]         if (TRUE) {
[13:35:05.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:05.921]                 open = "w")
[13:35:05.921]         }
[13:35:05.921]         else {
[13:35:05.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:05.921]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:05.921]         }
[13:35:05.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:05.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:05.921]             base::sink(type = "output", split = FALSE)
[13:35:05.921]             base::close(...future.stdout)
[13:35:05.921]         }, add = TRUE)
[13:35:05.921]     }
[13:35:05.921]     ...future.frame <- base::sys.nframe()
[13:35:05.921]     ...future.conditions <- base::list()
[13:35:05.921]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:05.921]     if (FALSE) {
[13:35:05.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:05.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:05.921]     }
[13:35:05.921]     ...future.result <- base::tryCatch({
[13:35:05.921]         base::withCallingHandlers({
[13:35:05.921]             ...future.value <- base::withVisible(base::local({
[13:35:05.921]                 do.call(function(...) {
[13:35:05.921]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.921]                   if (!identical(...future.globals.maxSize.org, 
[13:35:05.921]                     ...future.globals.maxSize)) {
[13:35:05.921]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.921]                     on.exit(options(oopts), add = TRUE)
[13:35:05.921]                   }
[13:35:05.921]                   {
[13:35:05.921]                     lapply(seq_along(...future.elements_ii), 
[13:35:05.921]                       FUN = function(jj) {
[13:35:05.921]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.921]                         ...future.FUN(...future.X_jj, ...)
[13:35:05.921]                       })
[13:35:05.921]                   }
[13:35:05.921]                 }, args = future.call.arguments)
[13:35:05.921]             }))
[13:35:05.921]             future::FutureResult(value = ...future.value$value, 
[13:35:05.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:05.921]                   ...future.rng), globalenv = if (FALSE) 
[13:35:05.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:05.921]                     ...future.globalenv.names))
[13:35:05.921]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:05.921]         }, condition = base::local({
[13:35:05.921]             c <- base::c
[13:35:05.921]             inherits <- base::inherits
[13:35:05.921]             invokeRestart <- base::invokeRestart
[13:35:05.921]             length <- base::length
[13:35:05.921]             list <- base::list
[13:35:05.921]             seq.int <- base::seq.int
[13:35:05.921]             signalCondition <- base::signalCondition
[13:35:05.921]             sys.calls <- base::sys.calls
[13:35:05.921]             `[[` <- base::`[[`
[13:35:05.921]             `+` <- base::`+`
[13:35:05.921]             `<<-` <- base::`<<-`
[13:35:05.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:05.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:05.921]                   3L)]
[13:35:05.921]             }
[13:35:05.921]             function(cond) {
[13:35:05.921]                 is_error <- inherits(cond, "error")
[13:35:05.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:05.921]                   NULL)
[13:35:05.921]                 if (is_error) {
[13:35:05.921]                   sessionInformation <- function() {
[13:35:05.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:05.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:05.921]                       search = base::search(), system = base::Sys.info())
[13:35:05.921]                   }
[13:35:05.921]                   ...future.conditions[[length(...future.conditions) + 
[13:35:05.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:05.921]                     cond$call), session = sessionInformation(), 
[13:35:05.921]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:05.921]                   signalCondition(cond)
[13:35:05.921]                 }
[13:35:05.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:05.921]                 "immediateCondition"))) {
[13:35:05.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:05.921]                   ...future.conditions[[length(...future.conditions) + 
[13:35:05.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:05.921]                   if (TRUE && !signal) {
[13:35:05.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:05.921]                     {
[13:35:05.921]                       inherits <- base::inherits
[13:35:05.921]                       invokeRestart <- base::invokeRestart
[13:35:05.921]                       is.null <- base::is.null
[13:35:05.921]                       muffled <- FALSE
[13:35:05.921]                       if (inherits(cond, "message")) {
[13:35:05.921]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:05.921]                         if (muffled) 
[13:35:05.921]                           invokeRestart("muffleMessage")
[13:35:05.921]                       }
[13:35:05.921]                       else if (inherits(cond, "warning")) {
[13:35:05.921]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:05.921]                         if (muffled) 
[13:35:05.921]                           invokeRestart("muffleWarning")
[13:35:05.921]                       }
[13:35:05.921]                       else if (inherits(cond, "condition")) {
[13:35:05.921]                         if (!is.null(pattern)) {
[13:35:05.921]                           computeRestarts <- base::computeRestarts
[13:35:05.921]                           grepl <- base::grepl
[13:35:05.921]                           restarts <- computeRestarts(cond)
[13:35:05.921]                           for (restart in restarts) {
[13:35:05.921]                             name <- restart$name
[13:35:05.921]                             if (is.null(name)) 
[13:35:05.921]                               next
[13:35:05.921]                             if (!grepl(pattern, name)) 
[13:35:05.921]                               next
[13:35:05.921]                             invokeRestart(restart)
[13:35:05.921]                             muffled <- TRUE
[13:35:05.921]                             break
[13:35:05.921]                           }
[13:35:05.921]                         }
[13:35:05.921]                       }
[13:35:05.921]                       invisible(muffled)
[13:35:05.921]                     }
[13:35:05.921]                     muffleCondition(cond, pattern = "^muffle")
[13:35:05.921]                   }
[13:35:05.921]                 }
[13:35:05.921]                 else {
[13:35:05.921]                   if (TRUE) {
[13:35:05.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:05.921]                     {
[13:35:05.921]                       inherits <- base::inherits
[13:35:05.921]                       invokeRestart <- base::invokeRestart
[13:35:05.921]                       is.null <- base::is.null
[13:35:05.921]                       muffled <- FALSE
[13:35:05.921]                       if (inherits(cond, "message")) {
[13:35:05.921]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:05.921]                         if (muffled) 
[13:35:05.921]                           invokeRestart("muffleMessage")
[13:35:05.921]                       }
[13:35:05.921]                       else if (inherits(cond, "warning")) {
[13:35:05.921]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:05.921]                         if (muffled) 
[13:35:05.921]                           invokeRestart("muffleWarning")
[13:35:05.921]                       }
[13:35:05.921]                       else if (inherits(cond, "condition")) {
[13:35:05.921]                         if (!is.null(pattern)) {
[13:35:05.921]                           computeRestarts <- base::computeRestarts
[13:35:05.921]                           grepl <- base::grepl
[13:35:05.921]                           restarts <- computeRestarts(cond)
[13:35:05.921]                           for (restart in restarts) {
[13:35:05.921]                             name <- restart$name
[13:35:05.921]                             if (is.null(name)) 
[13:35:05.921]                               next
[13:35:05.921]                             if (!grepl(pattern, name)) 
[13:35:05.921]                               next
[13:35:05.921]                             invokeRestart(restart)
[13:35:05.921]                             muffled <- TRUE
[13:35:05.921]                             break
[13:35:05.921]                           }
[13:35:05.921]                         }
[13:35:05.921]                       }
[13:35:05.921]                       invisible(muffled)
[13:35:05.921]                     }
[13:35:05.921]                     muffleCondition(cond, pattern = "^muffle")
[13:35:05.921]                   }
[13:35:05.921]                 }
[13:35:05.921]             }
[13:35:05.921]         }))
[13:35:05.921]     }, error = function(ex) {
[13:35:05.921]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:05.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:05.921]                 ...future.rng), started = ...future.startTime, 
[13:35:05.921]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:05.921]             version = "1.8"), class = "FutureResult")
[13:35:05.921]     }, finally = {
[13:35:05.921]         if (!identical(...future.workdir, getwd())) 
[13:35:05.921]             setwd(...future.workdir)
[13:35:05.921]         {
[13:35:05.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:05.921]                 ...future.oldOptions$nwarnings <- NULL
[13:35:05.921]             }
[13:35:05.921]             base::options(...future.oldOptions)
[13:35:05.921]             if (.Platform$OS.type == "windows") {
[13:35:05.921]                 old_names <- names(...future.oldEnvVars)
[13:35:05.921]                 envs <- base::Sys.getenv()
[13:35:05.921]                 names <- names(envs)
[13:35:05.921]                 common <- intersect(names, old_names)
[13:35:05.921]                 added <- setdiff(names, old_names)
[13:35:05.921]                 removed <- setdiff(old_names, names)
[13:35:05.921]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:05.921]                   envs[common]]
[13:35:05.921]                 NAMES <- toupper(changed)
[13:35:05.921]                 args <- list()
[13:35:05.921]                 for (kk in seq_along(NAMES)) {
[13:35:05.921]                   name <- changed[[kk]]
[13:35:05.921]                   NAME <- NAMES[[kk]]
[13:35:05.921]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.921]                     next
[13:35:05.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:05.921]                 }
[13:35:05.921]                 NAMES <- toupper(added)
[13:35:05.921]                 for (kk in seq_along(NAMES)) {
[13:35:05.921]                   name <- added[[kk]]
[13:35:05.921]                   NAME <- NAMES[[kk]]
[13:35:05.921]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.921]                     next
[13:35:05.921]                   args[[name]] <- ""
[13:35:05.921]                 }
[13:35:05.921]                 NAMES <- toupper(removed)
[13:35:05.921]                 for (kk in seq_along(NAMES)) {
[13:35:05.921]                   name <- removed[[kk]]
[13:35:05.921]                   NAME <- NAMES[[kk]]
[13:35:05.921]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.921]                     next
[13:35:05.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:05.921]                 }
[13:35:05.921]                 if (length(args) > 0) 
[13:35:05.921]                   base::do.call(base::Sys.setenv, args = args)
[13:35:05.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:05.921]             }
[13:35:05.921]             else {
[13:35:05.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:05.921]             }
[13:35:05.921]             {
[13:35:05.921]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:05.921]                   0L) {
[13:35:05.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:05.921]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:05.921]                   base::options(opts)
[13:35:05.921]                 }
[13:35:05.921]                 {
[13:35:05.921]                   {
[13:35:05.921]                     NULL
[13:35:05.921]                     RNGkind("Mersenne-Twister")
[13:35:05.921]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:05.921]                       inherits = FALSE)
[13:35:05.921]                   }
[13:35:05.921]                   options(future.plan = NULL)
[13:35:05.921]                   if (is.na(NA_character_)) 
[13:35:05.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:05.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:05.921]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:05.921]                     .init = FALSE)
[13:35:05.921]                 }
[13:35:05.921]             }
[13:35:05.921]         }
[13:35:05.921]     })
[13:35:05.921]     if (TRUE) {
[13:35:05.921]         base::sink(type = "output", split = FALSE)
[13:35:05.921]         if (TRUE) {
[13:35:05.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:05.921]         }
[13:35:05.921]         else {
[13:35:05.921]             ...future.result["stdout"] <- base::list(NULL)
[13:35:05.921]         }
[13:35:05.921]         base::close(...future.stdout)
[13:35:05.921]         ...future.stdout <- NULL
[13:35:05.921]     }
[13:35:05.921]     ...future.result$conditions <- ...future.conditions
[13:35:05.921]     ...future.result$finished <- base::Sys.time()
[13:35:05.921]     ...future.result
[13:35:05.921] }
[13:35:05.923] assign_globals() ...
[13:35:05.923] List of 11
[13:35:05.923]  $ ...future.FUN            :function (x, ...)  
[13:35:05.923]  $ x_FUN                    :function (x)  
[13:35:05.923]  $ times                    : int 1
[13:35:05.923]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:05.923]  $ stop_if_not              :function (...)  
[13:35:05.923]  $ dim                      : NULL
[13:35:05.923]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:05.923]  $ future.call.arguments    : list()
[13:35:05.923]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.923]  $ ...future.elements_ii    :List of 10
[13:35:05.923]   ..$ : int 1
[13:35:05.923]   ..$ : int 2
[13:35:05.923]   ..$ : int 3
[13:35:05.923]   ..$ : int 4
[13:35:05.923]   ..$ : int 5
[13:35:05.923]   ..$ : int 6
[13:35:05.923]   ..$ : int 7
[13:35:05.923]   ..$ : int 8
[13:35:05.923]   ..$ : int 9
[13:35:05.923]   ..$ : int 10
[13:35:05.923]  $ ...future.seeds_ii       : NULL
[13:35:05.923]  $ ...future.globals.maxSize: NULL
[13:35:05.923]  - attr(*, "where")=List of 11
[13:35:05.923]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:05.923]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:05.923]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:05.923]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:05.923]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:05.923]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:05.923]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:05.923]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:05.923]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:05.923]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:05.923]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:05.923]  - attr(*, "resolved")= logi FALSE
[13:35:05.923]  - attr(*, "total_size")= num 94336
[13:35:05.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.923]  - attr(*, "already-done")= logi TRUE
[13:35:05.933] - copied ‘...future.FUN’ to environment
[13:35:05.933] - copied ‘x_FUN’ to environment
[13:35:05.933] - copied ‘times’ to environment
[13:35:05.933] - copied ‘stopf’ to environment
[13:35:05.933] - copied ‘stop_if_not’ to environment
[13:35:05.933] - copied ‘dim’ to environment
[13:35:05.933] - copied ‘valid_types’ to environment
[13:35:05.933] - copied ‘future.call.arguments’ to environment
[13:35:05.934] - copied ‘...future.elements_ii’ to environment
[13:35:05.934] - copied ‘...future.seeds_ii’ to environment
[13:35:05.934] - copied ‘...future.globals.maxSize’ to environment
[13:35:05.934] assign_globals() ... done
[13:35:05.934] plan(): Setting new future strategy stack:
[13:35:05.934] List of future strategies:
[13:35:05.934] 1. sequential:
[13:35:05.934]    - args: function (..., envir = parent.frame())
[13:35:05.934]    - tweaked: FALSE
[13:35:05.934]    - call: NULL
[13:35:05.935] plan(): nbrOfWorkers() = 1
[13:35:05.935] plan(): Setting new future strategy stack:
[13:35:05.935] List of future strategies:
[13:35:05.935] 1. sequential:
[13:35:05.935]    - args: function (..., envir = parent.frame())
[13:35:05.935]    - tweaked: FALSE
[13:35:05.935]    - call: plan(strategy)
[13:35:05.936] plan(): nbrOfWorkers() = 1
[13:35:05.936] SequentialFuture started (and completed)
[13:35:05.936] - Launch lazy future ... done
[13:35:05.936] run() for ‘SequentialFuture’ ... done
[13:35:05.936] Created future:
[13:35:05.936] SequentialFuture:
[13:35:05.936] Label: ‘future_vapply-1’
[13:35:05.936] Expression:
[13:35:05.936] {
[13:35:05.936]     do.call(function(...) {
[13:35:05.936]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.936]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:05.936]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.936]             on.exit(options(oopts), add = TRUE)
[13:35:05.936]         }
[13:35:05.936]         {
[13:35:05.936]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:05.936]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.936]                 ...future.FUN(...future.X_jj, ...)
[13:35:05.936]             })
[13:35:05.936]         }
[13:35:05.936]     }, args = future.call.arguments)
[13:35:05.936] }
[13:35:05.936] Lazy evaluation: FALSE
[13:35:05.936] Asynchronous evaluation: FALSE
[13:35:05.936] Local evaluation: TRUE
[13:35:05.936] Environment: R_GlobalEnv
[13:35:05.936] Capture standard output: TRUE
[13:35:05.936] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:05.936] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:05.936] Packages: 1 packages (‘future.apply’)
[13:35:05.936] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:05.936] Resolved: TRUE
[13:35:05.936] Value: 560 bytes of class ‘list’
[13:35:05.936] Early signaling: FALSE
[13:35:05.936] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:05.936] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:05.937] Chunk #1 of 1 ... DONE
[13:35:05.937] Launching 1 futures (chunks) ... DONE
[13:35:05.937] Resolving 1 futures (chunks) ...
[13:35:05.938] resolve() on list ...
[13:35:05.938]  recursive: 0
[13:35:05.938]  length: 1
[13:35:05.938] 
[13:35:05.938] resolved() for ‘SequentialFuture’ ...
[13:35:05.938] - state: ‘finished’
[13:35:05.938] - run: TRUE
[13:35:05.938] - result: ‘FutureResult’
[13:35:05.938] resolved() for ‘SequentialFuture’ ... done
[13:35:05.938] Future #1
[13:35:05.939] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:05.939] - nx: 1
[13:35:05.939] - relay: TRUE
[13:35:05.939] - stdout: TRUE
[13:35:05.939] - signal: TRUE
[13:35:05.939] - resignal: FALSE
[13:35:05.939] - force: TRUE
[13:35:05.939] - relayed: [n=1] FALSE
[13:35:05.939] - queued futures: [n=1] FALSE
[13:35:05.939]  - until=1
[13:35:05.939]  - relaying element #1
[13:35:05.939] - relayed: [n=1] TRUE
[13:35:05.940] - queued futures: [n=1] TRUE
[13:35:05.940] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:05.940]  length: 0 (resolved future 1)
[13:35:05.940] Relaying remaining futures
[13:35:05.940] signalConditionsASAP(NULL, pos=0) ...
[13:35:05.940] - nx: 1
[13:35:05.940] - relay: TRUE
[13:35:05.940] - stdout: TRUE
[13:35:05.940] - signal: TRUE
[13:35:05.940] - resignal: FALSE
[13:35:05.940] - force: TRUE
[13:35:05.940] - relayed: [n=1] TRUE
[13:35:05.940] - queued futures: [n=1] TRUE
 - flush all
[13:35:05.941] - relayed: [n=1] TRUE
[13:35:05.941] - queued futures: [n=1] TRUE
[13:35:05.941] signalConditionsASAP(NULL, pos=0) ... done
[13:35:05.941] resolve() on list ... DONE
[13:35:05.941]  - Number of value chunks collected: 1
[13:35:05.941] Resolving 1 futures (chunks) ... DONE
[13:35:05.941] Reducing values from 1 chunks ...
[13:35:05.941]  - Number of values collected after concatenation: 10
[13:35:05.941]  - Number of values expected: 10
[13:35:05.941] Reducing values from 1 chunks ... DONE
[13:35:05.942] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[13:35:05.942] future_lapply() ...
[13:35:05.944] Number of chunks: 1
[13:35:05.944] getGlobalsAndPackagesXApply() ...
[13:35:05.944]  - future.globals: TRUE
[13:35:05.944] getGlobalsAndPackages() ...
[13:35:05.944] Searching for globals...
[13:35:05.948] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[13:35:05.948] Searching for globals ... DONE
[13:35:05.948] Resolving globals: FALSE
[13:35:05.949] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[13:35:05.950] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:05.950] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:05.950] - packages: [1] ‘future.apply’
[13:35:05.950] getGlobalsAndPackages() ... DONE
[13:35:05.950]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:05.950]  - needed namespaces: [n=1] ‘future.apply’
[13:35:05.950] Finding globals ... DONE
[13:35:05.950]  - use_args: TRUE
[13:35:05.950]  - Getting '...' globals ...
[13:35:05.951] resolve() on list ...
[13:35:05.951]  recursive: 0
[13:35:05.951]  length: 1
[13:35:05.951]  elements: ‘...’
[13:35:05.951]  length: 0 (resolved future 1)
[13:35:05.951] resolve() on list ... DONE
[13:35:05.951]    - '...' content: [n=0] 
[13:35:05.951] List of 1
[13:35:05.951]  $ ...: list()
[13:35:05.951]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.951]  - attr(*, "where")=List of 1
[13:35:05.951]   ..$ ...:<environment: 0x5574d0a34368> 
[13:35:05.951]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.951]  - attr(*, "resolved")= logi TRUE
[13:35:05.951]  - attr(*, "total_size")= num NA
[13:35:05.954]  - Getting '...' globals ... DONE
[13:35:05.954] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:05.954] List of 8
[13:35:05.954]  $ ...future.FUN:function (x, ...)  
[13:35:05.954]  $ x_FUN        :function (x)  
[13:35:05.954]  $ times        : int 2
[13:35:05.954]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:05.954]  $ stop_if_not  :function (...)  
[13:35:05.954]  $ dim          : NULL
[13:35:05.954]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:05.954]  $ ...          : list()
[13:35:05.954]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.954]  - attr(*, "where")=List of 8
[13:35:05.954]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:05.954]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:05.954]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:05.954]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:05.954]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:05.954]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:05.954]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:05.954]   ..$ ...          :<environment: 0x5574d0a34368> 
[13:35:05.954]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.954]  - attr(*, "resolved")= logi FALSE
[13:35:05.954]  - attr(*, "total_size")= num 96456
[13:35:05.959] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:05.959] getGlobalsAndPackagesXApply() ... DONE
[13:35:05.959] Number of futures (= number of chunks): 1
[13:35:05.959] Launching 1 futures (chunks) ...
[13:35:05.959] Chunk #1 of 1 ...
[13:35:05.959]  - Finding globals in 'X' for chunk #1 ...
[13:35:05.959] getGlobalsAndPackages() ...
[13:35:05.959] Searching for globals...
[13:35:05.960] 
[13:35:05.960] Searching for globals ... DONE
[13:35:05.960] - globals: [0] <none>
[13:35:05.960] getGlobalsAndPackages() ... DONE
[13:35:05.960]    + additional globals found: [n=0] 
[13:35:05.960]    + additional namespaces needed: [n=0] 
[13:35:05.960]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:05.960]  - seeds: <none>
[13:35:05.960]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.960] getGlobalsAndPackages() ...
[13:35:05.960] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.961] Resolving globals: FALSE
[13:35:05.961] Tweak future expression to call with '...' arguments ...
[13:35:05.961] {
[13:35:05.961]     do.call(function(...) {
[13:35:05.961]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.961]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:05.961]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.961]             on.exit(options(oopts), add = TRUE)
[13:35:05.961]         }
[13:35:05.961]         {
[13:35:05.961]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:05.961]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.961]                 ...future.FUN(...future.X_jj, ...)
[13:35:05.961]             })
[13:35:05.961]         }
[13:35:05.961]     }, args = future.call.arguments)
[13:35:05.961] }
[13:35:05.961] Tweak future expression to call with '...' arguments ... DONE
[13:35:05.961] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:05.962] - packages: [1] ‘future.apply’
[13:35:05.962] getGlobalsAndPackages() ... DONE
[13:35:05.962] run() for ‘Future’ ...
[13:35:05.962] - state: ‘created’
[13:35:05.962] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:05.962] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:05.963] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:05.963]   - Field: ‘label’
[13:35:05.963]   - Field: ‘local’
[13:35:05.963]   - Field: ‘owner’
[13:35:05.963]   - Field: ‘envir’
[13:35:05.963]   - Field: ‘packages’
[13:35:05.963]   - Field: ‘gc’
[13:35:05.963]   - Field: ‘conditions’
[13:35:05.963]   - Field: ‘expr’
[13:35:05.963]   - Field: ‘uuid’
[13:35:05.963]   - Field: ‘seed’
[13:35:05.964]   - Field: ‘version’
[13:35:05.964]   - Field: ‘result’
[13:35:05.964]   - Field: ‘asynchronous’
[13:35:05.964]   - Field: ‘calls’
[13:35:05.964]   - Field: ‘globals’
[13:35:05.964]   - Field: ‘stdout’
[13:35:05.964]   - Field: ‘earlySignal’
[13:35:05.964]   - Field: ‘lazy’
[13:35:05.964]   - Field: ‘state’
[13:35:05.964] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:05.964] - Launch lazy future ...
[13:35:05.965] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:05.965] Packages needed by future strategies (n = 0): <none>
[13:35:05.966] {
[13:35:05.966]     {
[13:35:05.966]         {
[13:35:05.966]             ...future.startTime <- base::Sys.time()
[13:35:05.966]             {
[13:35:05.966]                 {
[13:35:05.966]                   {
[13:35:05.966]                     {
[13:35:05.966]                       base::local({
[13:35:05.966]                         has_future <- base::requireNamespace("future", 
[13:35:05.966]                           quietly = TRUE)
[13:35:05.966]                         if (has_future) {
[13:35:05.966]                           ns <- base::getNamespace("future")
[13:35:05.966]                           version <- ns[[".package"]][["version"]]
[13:35:05.966]                           if (is.null(version)) 
[13:35:05.966]                             version <- utils::packageVersion("future")
[13:35:05.966]                         }
[13:35:05.966]                         else {
[13:35:05.966]                           version <- NULL
[13:35:05.966]                         }
[13:35:05.966]                         if (!has_future || version < "1.8.0") {
[13:35:05.966]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:05.966]                             "", base::R.version$version.string), 
[13:35:05.966]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:05.966]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:05.966]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:05.966]                               "release", "version")], collapse = " "), 
[13:35:05.966]                             hostname = base::Sys.info()[["nodename"]])
[13:35:05.966]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:05.966]                             info)
[13:35:05.966]                           info <- base::paste(info, collapse = "; ")
[13:35:05.966]                           if (!has_future) {
[13:35:05.966]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:05.966]                               info)
[13:35:05.966]                           }
[13:35:05.966]                           else {
[13:35:05.966]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:05.966]                               info, version)
[13:35:05.966]                           }
[13:35:05.966]                           base::stop(msg)
[13:35:05.966]                         }
[13:35:05.966]                       })
[13:35:05.966]                     }
[13:35:05.966]                     base::local({
[13:35:05.966]                       for (pkg in "future.apply") {
[13:35:05.966]                         base::loadNamespace(pkg)
[13:35:05.966]                         base::library(pkg, character.only = TRUE)
[13:35:05.966]                       }
[13:35:05.966]                     })
[13:35:05.966]                   }
[13:35:05.966]                   ...future.strategy.old <- future::plan("list")
[13:35:05.966]                   options(future.plan = NULL)
[13:35:05.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:05.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:05.966]                 }
[13:35:05.966]                 ...future.workdir <- getwd()
[13:35:05.966]             }
[13:35:05.966]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:05.966]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:05.966]         }
[13:35:05.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:05.966]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:05.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:05.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:05.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:05.966]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:05.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:05.966]             base::names(...future.oldOptions))
[13:35:05.966]     }
[13:35:05.966]     if (FALSE) {
[13:35:05.966]     }
[13:35:05.966]     else {
[13:35:05.966]         if (TRUE) {
[13:35:05.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:05.966]                 open = "w")
[13:35:05.966]         }
[13:35:05.966]         else {
[13:35:05.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:05.966]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:05.966]         }
[13:35:05.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:05.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:05.966]             base::sink(type = "output", split = FALSE)
[13:35:05.966]             base::close(...future.stdout)
[13:35:05.966]         }, add = TRUE)
[13:35:05.966]     }
[13:35:05.966]     ...future.frame <- base::sys.nframe()
[13:35:05.966]     ...future.conditions <- base::list()
[13:35:05.966]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:05.966]     if (FALSE) {
[13:35:05.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:05.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:05.966]     }
[13:35:05.966]     ...future.result <- base::tryCatch({
[13:35:05.966]         base::withCallingHandlers({
[13:35:05.966]             ...future.value <- base::withVisible(base::local({
[13:35:05.966]                 do.call(function(...) {
[13:35:05.966]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.966]                   if (!identical(...future.globals.maxSize.org, 
[13:35:05.966]                     ...future.globals.maxSize)) {
[13:35:05.966]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.966]                     on.exit(options(oopts), add = TRUE)
[13:35:05.966]                   }
[13:35:05.966]                   {
[13:35:05.966]                     lapply(seq_along(...future.elements_ii), 
[13:35:05.966]                       FUN = function(jj) {
[13:35:05.966]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.966]                         ...future.FUN(...future.X_jj, ...)
[13:35:05.966]                       })
[13:35:05.966]                   }
[13:35:05.966]                 }, args = future.call.arguments)
[13:35:05.966]             }))
[13:35:05.966]             future::FutureResult(value = ...future.value$value, 
[13:35:05.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:05.966]                   ...future.rng), globalenv = if (FALSE) 
[13:35:05.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:05.966]                     ...future.globalenv.names))
[13:35:05.966]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:05.966]         }, condition = base::local({
[13:35:05.966]             c <- base::c
[13:35:05.966]             inherits <- base::inherits
[13:35:05.966]             invokeRestart <- base::invokeRestart
[13:35:05.966]             length <- base::length
[13:35:05.966]             list <- base::list
[13:35:05.966]             seq.int <- base::seq.int
[13:35:05.966]             signalCondition <- base::signalCondition
[13:35:05.966]             sys.calls <- base::sys.calls
[13:35:05.966]             `[[` <- base::`[[`
[13:35:05.966]             `+` <- base::`+`
[13:35:05.966]             `<<-` <- base::`<<-`
[13:35:05.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:05.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:05.966]                   3L)]
[13:35:05.966]             }
[13:35:05.966]             function(cond) {
[13:35:05.966]                 is_error <- inherits(cond, "error")
[13:35:05.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:05.966]                   NULL)
[13:35:05.966]                 if (is_error) {
[13:35:05.966]                   sessionInformation <- function() {
[13:35:05.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:05.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:05.966]                       search = base::search(), system = base::Sys.info())
[13:35:05.966]                   }
[13:35:05.966]                   ...future.conditions[[length(...future.conditions) + 
[13:35:05.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:05.966]                     cond$call), session = sessionInformation(), 
[13:35:05.966]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:05.966]                   signalCondition(cond)
[13:35:05.966]                 }
[13:35:05.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:05.966]                 "immediateCondition"))) {
[13:35:05.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:05.966]                   ...future.conditions[[length(...future.conditions) + 
[13:35:05.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:05.966]                   if (TRUE && !signal) {
[13:35:05.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:05.966]                     {
[13:35:05.966]                       inherits <- base::inherits
[13:35:05.966]                       invokeRestart <- base::invokeRestart
[13:35:05.966]                       is.null <- base::is.null
[13:35:05.966]                       muffled <- FALSE
[13:35:05.966]                       if (inherits(cond, "message")) {
[13:35:05.966]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:05.966]                         if (muffled) 
[13:35:05.966]                           invokeRestart("muffleMessage")
[13:35:05.966]                       }
[13:35:05.966]                       else if (inherits(cond, "warning")) {
[13:35:05.966]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:05.966]                         if (muffled) 
[13:35:05.966]                           invokeRestart("muffleWarning")
[13:35:05.966]                       }
[13:35:05.966]                       else if (inherits(cond, "condition")) {
[13:35:05.966]                         if (!is.null(pattern)) {
[13:35:05.966]                           computeRestarts <- base::computeRestarts
[13:35:05.966]                           grepl <- base::grepl
[13:35:05.966]                           restarts <- computeRestarts(cond)
[13:35:05.966]                           for (restart in restarts) {
[13:35:05.966]                             name <- restart$name
[13:35:05.966]                             if (is.null(name)) 
[13:35:05.966]                               next
[13:35:05.966]                             if (!grepl(pattern, name)) 
[13:35:05.966]                               next
[13:35:05.966]                             invokeRestart(restart)
[13:35:05.966]                             muffled <- TRUE
[13:35:05.966]                             break
[13:35:05.966]                           }
[13:35:05.966]                         }
[13:35:05.966]                       }
[13:35:05.966]                       invisible(muffled)
[13:35:05.966]                     }
[13:35:05.966]                     muffleCondition(cond, pattern = "^muffle")
[13:35:05.966]                   }
[13:35:05.966]                 }
[13:35:05.966]                 else {
[13:35:05.966]                   if (TRUE) {
[13:35:05.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:05.966]                     {
[13:35:05.966]                       inherits <- base::inherits
[13:35:05.966]                       invokeRestart <- base::invokeRestart
[13:35:05.966]                       is.null <- base::is.null
[13:35:05.966]                       muffled <- FALSE
[13:35:05.966]                       if (inherits(cond, "message")) {
[13:35:05.966]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:05.966]                         if (muffled) 
[13:35:05.966]                           invokeRestart("muffleMessage")
[13:35:05.966]                       }
[13:35:05.966]                       else if (inherits(cond, "warning")) {
[13:35:05.966]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:05.966]                         if (muffled) 
[13:35:05.966]                           invokeRestart("muffleWarning")
[13:35:05.966]                       }
[13:35:05.966]                       else if (inherits(cond, "condition")) {
[13:35:05.966]                         if (!is.null(pattern)) {
[13:35:05.966]                           computeRestarts <- base::computeRestarts
[13:35:05.966]                           grepl <- base::grepl
[13:35:05.966]                           restarts <- computeRestarts(cond)
[13:35:05.966]                           for (restart in restarts) {
[13:35:05.966]                             name <- restart$name
[13:35:05.966]                             if (is.null(name)) 
[13:35:05.966]                               next
[13:35:05.966]                             if (!grepl(pattern, name)) 
[13:35:05.966]                               next
[13:35:05.966]                             invokeRestart(restart)
[13:35:05.966]                             muffled <- TRUE
[13:35:05.966]                             break
[13:35:05.966]                           }
[13:35:05.966]                         }
[13:35:05.966]                       }
[13:35:05.966]                       invisible(muffled)
[13:35:05.966]                     }
[13:35:05.966]                     muffleCondition(cond, pattern = "^muffle")
[13:35:05.966]                   }
[13:35:05.966]                 }
[13:35:05.966]             }
[13:35:05.966]         }))
[13:35:05.966]     }, error = function(ex) {
[13:35:05.966]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:05.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:05.966]                 ...future.rng), started = ...future.startTime, 
[13:35:05.966]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:05.966]             version = "1.8"), class = "FutureResult")
[13:35:05.966]     }, finally = {
[13:35:05.966]         if (!identical(...future.workdir, getwd())) 
[13:35:05.966]             setwd(...future.workdir)
[13:35:05.966]         {
[13:35:05.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:05.966]                 ...future.oldOptions$nwarnings <- NULL
[13:35:05.966]             }
[13:35:05.966]             base::options(...future.oldOptions)
[13:35:05.966]             if (.Platform$OS.type == "windows") {
[13:35:05.966]                 old_names <- names(...future.oldEnvVars)
[13:35:05.966]                 envs <- base::Sys.getenv()
[13:35:05.966]                 names <- names(envs)
[13:35:05.966]                 common <- intersect(names, old_names)
[13:35:05.966]                 added <- setdiff(names, old_names)
[13:35:05.966]                 removed <- setdiff(old_names, names)
[13:35:05.966]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:05.966]                   envs[common]]
[13:35:05.966]                 NAMES <- toupper(changed)
[13:35:05.966]                 args <- list()
[13:35:05.966]                 for (kk in seq_along(NAMES)) {
[13:35:05.966]                   name <- changed[[kk]]
[13:35:05.966]                   NAME <- NAMES[[kk]]
[13:35:05.966]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.966]                     next
[13:35:05.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:05.966]                 }
[13:35:05.966]                 NAMES <- toupper(added)
[13:35:05.966]                 for (kk in seq_along(NAMES)) {
[13:35:05.966]                   name <- added[[kk]]
[13:35:05.966]                   NAME <- NAMES[[kk]]
[13:35:05.966]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.966]                     next
[13:35:05.966]                   args[[name]] <- ""
[13:35:05.966]                 }
[13:35:05.966]                 NAMES <- toupper(removed)
[13:35:05.966]                 for (kk in seq_along(NAMES)) {
[13:35:05.966]                   name <- removed[[kk]]
[13:35:05.966]                   NAME <- NAMES[[kk]]
[13:35:05.966]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:05.966]                     next
[13:35:05.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:05.966]                 }
[13:35:05.966]                 if (length(args) > 0) 
[13:35:05.966]                   base::do.call(base::Sys.setenv, args = args)
[13:35:05.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:05.966]             }
[13:35:05.966]             else {
[13:35:05.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:05.966]             }
[13:35:05.966]             {
[13:35:05.966]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:05.966]                   0L) {
[13:35:05.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:05.966]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:05.966]                   base::options(opts)
[13:35:05.966]                 }
[13:35:05.966]                 {
[13:35:05.966]                   {
[13:35:05.966]                     NULL
[13:35:05.966]                     RNGkind("Mersenne-Twister")
[13:35:05.966]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:05.966]                       inherits = FALSE)
[13:35:05.966]                   }
[13:35:05.966]                   options(future.plan = NULL)
[13:35:05.966]                   if (is.na(NA_character_)) 
[13:35:05.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:05.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:05.966]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:05.966]                     .init = FALSE)
[13:35:05.966]                 }
[13:35:05.966]             }
[13:35:05.966]         }
[13:35:05.966]     })
[13:35:05.966]     if (TRUE) {
[13:35:05.966]         base::sink(type = "output", split = FALSE)
[13:35:05.966]         if (TRUE) {
[13:35:05.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:05.966]         }
[13:35:05.966]         else {
[13:35:05.966]             ...future.result["stdout"] <- base::list(NULL)
[13:35:05.966]         }
[13:35:05.966]         base::close(...future.stdout)
[13:35:05.966]         ...future.stdout <- NULL
[13:35:05.966]     }
[13:35:05.966]     ...future.result$conditions <- ...future.conditions
[13:35:05.966]     ...future.result$finished <- base::Sys.time()
[13:35:05.966]     ...future.result
[13:35:05.966] }
[13:35:05.968] assign_globals() ...
[13:35:05.968] List of 11
[13:35:05.968]  $ ...future.FUN            :function (x, ...)  
[13:35:05.968]  $ x_FUN                    :function (x)  
[13:35:05.968]  $ times                    : int 2
[13:35:05.968]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:05.968]  $ stop_if_not              :function (...)  
[13:35:05.968]  $ dim                      : NULL
[13:35:05.968]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:05.968]  $ future.call.arguments    : list()
[13:35:05.968]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.968]  $ ...future.elements_ii    :List of 10
[13:35:05.968]   ..$ : int 1
[13:35:05.968]   ..$ : int 2
[13:35:05.968]   ..$ : int 3
[13:35:05.968]   ..$ : int 4
[13:35:05.968]   ..$ : int 5
[13:35:05.968]   ..$ : int 6
[13:35:05.968]   ..$ : int 7
[13:35:05.968]   ..$ : int 8
[13:35:05.968]   ..$ : int 9
[13:35:05.968]   ..$ : int 10
[13:35:05.968]  $ ...future.seeds_ii       : NULL
[13:35:05.968]  $ ...future.globals.maxSize: NULL
[13:35:05.968]  - attr(*, "where")=List of 11
[13:35:05.968]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:05.968]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:05.968]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:05.968]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:05.968]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:05.968]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:05.968]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:05.968]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:05.968]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:05.968]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:05.968]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:05.968]  - attr(*, "resolved")= logi FALSE
[13:35:05.968]  - attr(*, "total_size")= num 96456
[13:35:05.968]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.968]  - attr(*, "already-done")= logi TRUE
[13:35:05.977] - copied ‘...future.FUN’ to environment
[13:35:05.977] - reassign environment for ‘x_FUN’
[13:35:05.977] - copied ‘x_FUN’ to environment
[13:35:05.977] - copied ‘times’ to environment
[13:35:05.977] - copied ‘stopf’ to environment
[13:35:05.977] - copied ‘stop_if_not’ to environment
[13:35:05.977] - copied ‘dim’ to environment
[13:35:05.977] - copied ‘valid_types’ to environment
[13:35:05.977] - copied ‘future.call.arguments’ to environment
[13:35:05.977] - copied ‘...future.elements_ii’ to environment
[13:35:05.978] - copied ‘...future.seeds_ii’ to environment
[13:35:05.978] - copied ‘...future.globals.maxSize’ to environment
[13:35:05.978] assign_globals() ... done
[13:35:05.978] plan(): Setting new future strategy stack:
[13:35:05.978] List of future strategies:
[13:35:05.978] 1. sequential:
[13:35:05.978]    - args: function (..., envir = parent.frame())
[13:35:05.978]    - tweaked: FALSE
[13:35:05.978]    - call: NULL
[13:35:05.978] plan(): nbrOfWorkers() = 1
[13:35:05.979] plan(): Setting new future strategy stack:
[13:35:05.979] List of future strategies:
[13:35:05.979] 1. sequential:
[13:35:05.979]    - args: function (..., envir = parent.frame())
[13:35:05.979]    - tweaked: FALSE
[13:35:05.979]    - call: plan(strategy)
[13:35:05.980] plan(): nbrOfWorkers() = 1
[13:35:05.980] SequentialFuture started (and completed)
[13:35:05.980] - Launch lazy future ... done
[13:35:05.980] run() for ‘SequentialFuture’ ... done
[13:35:05.980] Created future:
[13:35:05.980] SequentialFuture:
[13:35:05.980] Label: ‘future_vapply-1’
[13:35:05.980] Expression:
[13:35:05.980] {
[13:35:05.980]     do.call(function(...) {
[13:35:05.980]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:05.980]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:05.980]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:05.980]             on.exit(options(oopts), add = TRUE)
[13:35:05.980]         }
[13:35:05.980]         {
[13:35:05.980]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:05.980]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:05.980]                 ...future.FUN(...future.X_jj, ...)
[13:35:05.980]             })
[13:35:05.980]         }
[13:35:05.980]     }, args = future.call.arguments)
[13:35:05.980] }
[13:35:05.980] Lazy evaluation: FALSE
[13:35:05.980] Asynchronous evaluation: FALSE
[13:35:05.980] Local evaluation: TRUE
[13:35:05.980] Environment: R_GlobalEnv
[13:35:05.980] Capture standard output: TRUE
[13:35:05.980] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:05.980] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:05.980] Packages: 1 packages (‘future.apply’)
[13:35:05.980] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:05.980] Resolved: TRUE
[13:35:05.980] Value: 640 bytes of class ‘list’
[13:35:05.980] Early signaling: FALSE
[13:35:05.980] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:05.980] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:05.981] Chunk #1 of 1 ... DONE
[13:35:05.981] Launching 1 futures (chunks) ... DONE
[13:35:05.981] Resolving 1 futures (chunks) ...
[13:35:05.982] resolve() on list ...
[13:35:05.982]  recursive: 0
[13:35:05.982]  length: 1
[13:35:05.982] 
[13:35:05.982] resolved() for ‘SequentialFuture’ ...
[13:35:05.982] - state: ‘finished’
[13:35:05.982] - run: TRUE
[13:35:05.982] - result: ‘FutureResult’
[13:35:05.982] resolved() for ‘SequentialFuture’ ... done
[13:35:05.982] Future #1
[13:35:05.982] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:05.983] - nx: 1
[13:35:05.983] - relay: TRUE
[13:35:05.983] - stdout: TRUE
[13:35:05.983] - signal: TRUE
[13:35:05.983] - resignal: FALSE
[13:35:05.983] - force: TRUE
[13:35:05.983] - relayed: [n=1] FALSE
[13:35:05.983] - queued futures: [n=1] FALSE
[13:35:05.983]  - until=1
[13:35:05.983]  - relaying element #1
[13:35:05.983] - relayed: [n=1] TRUE
[13:35:05.984] - queued futures: [n=1] TRUE
[13:35:05.984] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:05.984]  length: 0 (resolved future 1)
[13:35:05.984] Relaying remaining futures
[13:35:05.984] signalConditionsASAP(NULL, pos=0) ...
[13:35:05.984] - nx: 1
[13:35:05.984] - relay: TRUE
[13:35:05.984] - stdout: TRUE
[13:35:05.984] - signal: TRUE
[13:35:05.984] - resignal: FALSE
[13:35:05.984] - force: TRUE
[13:35:05.984] - relayed: [n=1] TRUE
[13:35:05.984] - queued futures: [n=1] TRUE
 - flush all
[13:35:05.985] - relayed: [n=1] TRUE
[13:35:05.985] - queued futures: [n=1] TRUE
[13:35:05.985] signalConditionsASAP(NULL, pos=0) ... done
[13:35:05.985] resolve() on list ... DONE
[13:35:05.985]  - Number of value chunks collected: 1
[13:35:05.985] Resolving 1 futures (chunks) ... DONE
[13:35:05.986] Reducing values from 1 chunks ...
[13:35:05.986]  - Number of values collected after concatenation: 10
[13:35:05.986]  - Number of values expected: 10
[13:35:05.986] Reducing values from 1 chunks ... DONE
[13:35:05.986] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:35:05.987] future_lapply() ...
[13:35:05.989] Number of chunks: 1
[13:35:05.989] getGlobalsAndPackagesXApply() ...
[13:35:05.989]  - future.globals: TRUE
[13:35:05.989] getGlobalsAndPackages() ...
[13:35:05.989] Searching for globals...
[13:35:05.992] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:35:05.992] Searching for globals ... DONE
[13:35:05.993] Resolving globals: FALSE
[13:35:05.993] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[13:35:05.994] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:05.994] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:05.994] - packages: [1] ‘future.apply’
[13:35:05.994] getGlobalsAndPackages() ... DONE
[13:35:05.994]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:05.994]  - needed namespaces: [n=1] ‘future.apply’
[13:35:05.994] Finding globals ... DONE
[13:35:05.994]  - use_args: TRUE
[13:35:05.995]  - Getting '...' globals ...
[13:35:05.995] resolve() on list ...
[13:35:05.995]  recursive: 0
[13:35:05.995]  length: 1
[13:35:05.995]  elements: ‘...’
[13:35:05.995]  length: 0 (resolved future 1)
[13:35:05.995] resolve() on list ... DONE
[13:35:05.995]    - '...' content: [n=0] 
[13:35:05.995] List of 1
[13:35:05.995]  $ ...: list()
[13:35:05.995]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.995]  - attr(*, "where")=List of 1
[13:35:05.995]   ..$ ...:<environment: 0x5574cf540e58> 
[13:35:05.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.995]  - attr(*, "resolved")= logi TRUE
[13:35:05.995]  - attr(*, "total_size")= num NA
[13:35:05.998]  - Getting '...' globals ... DONE
[13:35:05.998] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:05.998] List of 8
[13:35:05.998]  $ ...future.FUN:function (x, ...)  
[13:35:05.998]  $ x_FUN        :function (x)  
[13:35:05.998]  $ times        : int 4
[13:35:05.998]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:05.998]  $ stop_if_not  :function (...)  
[13:35:05.998]  $ dim          : int [1:2] 2 2
[13:35:05.998]  $ valid_types  : chr [1:2] "logical" "integer"
[13:35:05.998]  $ ...          : list()
[13:35:05.998]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:05.998]  - attr(*, "where")=List of 8
[13:35:05.998]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:05.998]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:05.998]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:05.998]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:05.998]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:05.998]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:05.998]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:05.998]   ..$ ...          :<environment: 0x5574cf540e58> 
[13:35:05.998]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:05.998]  - attr(*, "resolved")= logi FALSE
[13:35:05.998]  - attr(*, "total_size")= num 97232
[13:35:06.003] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:06.003] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.003] Number of futures (= number of chunks): 1
[13:35:06.003] Launching 1 futures (chunks) ...
[13:35:06.003] Chunk #1 of 1 ...
[13:35:06.003]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.004] getGlobalsAndPackages() ...
[13:35:06.004] Searching for globals...
[13:35:06.005] 
[13:35:06.005] Searching for globals ... DONE
[13:35:06.005] - globals: [0] <none>
[13:35:06.005] getGlobalsAndPackages() ... DONE
[13:35:06.005]    + additional globals found: [n=0] 
[13:35:06.005]    + additional namespaces needed: [n=0] 
[13:35:06.005]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.005]  - seeds: <none>
[13:35:06.005]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.005] getGlobalsAndPackages() ...
[13:35:06.006] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.006] Resolving globals: FALSE
[13:35:06.006] Tweak future expression to call with '...' arguments ...
[13:35:06.006] {
[13:35:06.006]     do.call(function(...) {
[13:35:06.006]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.006]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.006]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.006]             on.exit(options(oopts), add = TRUE)
[13:35:06.006]         }
[13:35:06.006]         {
[13:35:06.006]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.006]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.006]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.006]             })
[13:35:06.006]         }
[13:35:06.006]     }, args = future.call.arguments)
[13:35:06.006] }
[13:35:06.006] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.007] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.007] - packages: [1] ‘future.apply’
[13:35:06.007] getGlobalsAndPackages() ... DONE
[13:35:06.007] run() for ‘Future’ ...
[13:35:06.007] - state: ‘created’
[13:35:06.007] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:06.008] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:06.008]   - Field: ‘label’
[13:35:06.008]   - Field: ‘local’
[13:35:06.008]   - Field: ‘owner’
[13:35:06.008]   - Field: ‘envir’
[13:35:06.008]   - Field: ‘packages’
[13:35:06.008]   - Field: ‘gc’
[13:35:06.008]   - Field: ‘conditions’
[13:35:06.008]   - Field: ‘expr’
[13:35:06.008]   - Field: ‘uuid’
[13:35:06.009]   - Field: ‘seed’
[13:35:06.009]   - Field: ‘version’
[13:35:06.009]   - Field: ‘result’
[13:35:06.009]   - Field: ‘asynchronous’
[13:35:06.009]   - Field: ‘calls’
[13:35:06.009]   - Field: ‘globals’
[13:35:06.009]   - Field: ‘stdout’
[13:35:06.009]   - Field: ‘earlySignal’
[13:35:06.009]   - Field: ‘lazy’
[13:35:06.009]   - Field: ‘state’
[13:35:06.009] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:06.009] - Launch lazy future ...
[13:35:06.010] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.010] Packages needed by future strategies (n = 0): <none>
[13:35:06.010] {
[13:35:06.010]     {
[13:35:06.010]         {
[13:35:06.010]             ...future.startTime <- base::Sys.time()
[13:35:06.010]             {
[13:35:06.010]                 {
[13:35:06.010]                   {
[13:35:06.010]                     {
[13:35:06.010]                       base::local({
[13:35:06.010]                         has_future <- base::requireNamespace("future", 
[13:35:06.010]                           quietly = TRUE)
[13:35:06.010]                         if (has_future) {
[13:35:06.010]                           ns <- base::getNamespace("future")
[13:35:06.010]                           version <- ns[[".package"]][["version"]]
[13:35:06.010]                           if (is.null(version)) 
[13:35:06.010]                             version <- utils::packageVersion("future")
[13:35:06.010]                         }
[13:35:06.010]                         else {
[13:35:06.010]                           version <- NULL
[13:35:06.010]                         }
[13:35:06.010]                         if (!has_future || version < "1.8.0") {
[13:35:06.010]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.010]                             "", base::R.version$version.string), 
[13:35:06.010]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:06.010]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:06.010]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.010]                               "release", "version")], collapse = " "), 
[13:35:06.010]                             hostname = base::Sys.info()[["nodename"]])
[13:35:06.010]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.010]                             info)
[13:35:06.010]                           info <- base::paste(info, collapse = "; ")
[13:35:06.010]                           if (!has_future) {
[13:35:06.010]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.010]                               info)
[13:35:06.010]                           }
[13:35:06.010]                           else {
[13:35:06.010]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.010]                               info, version)
[13:35:06.010]                           }
[13:35:06.010]                           base::stop(msg)
[13:35:06.010]                         }
[13:35:06.010]                       })
[13:35:06.010]                     }
[13:35:06.010]                     base::local({
[13:35:06.010]                       for (pkg in "future.apply") {
[13:35:06.010]                         base::loadNamespace(pkg)
[13:35:06.010]                         base::library(pkg, character.only = TRUE)
[13:35:06.010]                       }
[13:35:06.010]                     })
[13:35:06.010]                   }
[13:35:06.010]                   ...future.strategy.old <- future::plan("list")
[13:35:06.010]                   options(future.plan = NULL)
[13:35:06.010]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.010]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.010]                 }
[13:35:06.010]                 ...future.workdir <- getwd()
[13:35:06.010]             }
[13:35:06.010]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.010]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.010]         }
[13:35:06.010]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.010]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:06.010]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.010]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.010]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.010]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.010]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.010]             base::names(...future.oldOptions))
[13:35:06.010]     }
[13:35:06.010]     if (FALSE) {
[13:35:06.010]     }
[13:35:06.010]     else {
[13:35:06.010]         if (TRUE) {
[13:35:06.010]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.010]                 open = "w")
[13:35:06.010]         }
[13:35:06.010]         else {
[13:35:06.010]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.010]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.010]         }
[13:35:06.010]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.010]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.010]             base::sink(type = "output", split = FALSE)
[13:35:06.010]             base::close(...future.stdout)
[13:35:06.010]         }, add = TRUE)
[13:35:06.010]     }
[13:35:06.010]     ...future.frame <- base::sys.nframe()
[13:35:06.010]     ...future.conditions <- base::list()
[13:35:06.010]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.010]     if (FALSE) {
[13:35:06.010]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.010]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.010]     }
[13:35:06.010]     ...future.result <- base::tryCatch({
[13:35:06.010]         base::withCallingHandlers({
[13:35:06.010]             ...future.value <- base::withVisible(base::local({
[13:35:06.010]                 do.call(function(...) {
[13:35:06.010]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.010]                   if (!identical(...future.globals.maxSize.org, 
[13:35:06.010]                     ...future.globals.maxSize)) {
[13:35:06.010]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.010]                     on.exit(options(oopts), add = TRUE)
[13:35:06.010]                   }
[13:35:06.010]                   {
[13:35:06.010]                     lapply(seq_along(...future.elements_ii), 
[13:35:06.010]                       FUN = function(jj) {
[13:35:06.010]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.010]                         ...future.FUN(...future.X_jj, ...)
[13:35:06.010]                       })
[13:35:06.010]                   }
[13:35:06.010]                 }, args = future.call.arguments)
[13:35:06.010]             }))
[13:35:06.010]             future::FutureResult(value = ...future.value$value, 
[13:35:06.010]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.010]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.010]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.010]                     ...future.globalenv.names))
[13:35:06.010]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.010]         }, condition = base::local({
[13:35:06.010]             c <- base::c
[13:35:06.010]             inherits <- base::inherits
[13:35:06.010]             invokeRestart <- base::invokeRestart
[13:35:06.010]             length <- base::length
[13:35:06.010]             list <- base::list
[13:35:06.010]             seq.int <- base::seq.int
[13:35:06.010]             signalCondition <- base::signalCondition
[13:35:06.010]             sys.calls <- base::sys.calls
[13:35:06.010]             `[[` <- base::`[[`
[13:35:06.010]             `+` <- base::`+`
[13:35:06.010]             `<<-` <- base::`<<-`
[13:35:06.010]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.010]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.010]                   3L)]
[13:35:06.010]             }
[13:35:06.010]             function(cond) {
[13:35:06.010]                 is_error <- inherits(cond, "error")
[13:35:06.010]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.010]                   NULL)
[13:35:06.010]                 if (is_error) {
[13:35:06.010]                   sessionInformation <- function() {
[13:35:06.010]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.010]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.010]                       search = base::search(), system = base::Sys.info())
[13:35:06.010]                   }
[13:35:06.010]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.010]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.010]                     cond$call), session = sessionInformation(), 
[13:35:06.010]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.010]                   signalCondition(cond)
[13:35:06.010]                 }
[13:35:06.010]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.010]                 "immediateCondition"))) {
[13:35:06.010]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.010]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.010]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.010]                   if (TRUE && !signal) {
[13:35:06.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.010]                     {
[13:35:06.010]                       inherits <- base::inherits
[13:35:06.010]                       invokeRestart <- base::invokeRestart
[13:35:06.010]                       is.null <- base::is.null
[13:35:06.010]                       muffled <- FALSE
[13:35:06.010]                       if (inherits(cond, "message")) {
[13:35:06.010]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.010]                         if (muffled) 
[13:35:06.010]                           invokeRestart("muffleMessage")
[13:35:06.010]                       }
[13:35:06.010]                       else if (inherits(cond, "warning")) {
[13:35:06.010]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.010]                         if (muffled) 
[13:35:06.010]                           invokeRestart("muffleWarning")
[13:35:06.010]                       }
[13:35:06.010]                       else if (inherits(cond, "condition")) {
[13:35:06.010]                         if (!is.null(pattern)) {
[13:35:06.010]                           computeRestarts <- base::computeRestarts
[13:35:06.010]                           grepl <- base::grepl
[13:35:06.010]                           restarts <- computeRestarts(cond)
[13:35:06.010]                           for (restart in restarts) {
[13:35:06.010]                             name <- restart$name
[13:35:06.010]                             if (is.null(name)) 
[13:35:06.010]                               next
[13:35:06.010]                             if (!grepl(pattern, name)) 
[13:35:06.010]                               next
[13:35:06.010]                             invokeRestart(restart)
[13:35:06.010]                             muffled <- TRUE
[13:35:06.010]                             break
[13:35:06.010]                           }
[13:35:06.010]                         }
[13:35:06.010]                       }
[13:35:06.010]                       invisible(muffled)
[13:35:06.010]                     }
[13:35:06.010]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.010]                   }
[13:35:06.010]                 }
[13:35:06.010]                 else {
[13:35:06.010]                   if (TRUE) {
[13:35:06.010]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.010]                     {
[13:35:06.010]                       inherits <- base::inherits
[13:35:06.010]                       invokeRestart <- base::invokeRestart
[13:35:06.010]                       is.null <- base::is.null
[13:35:06.010]                       muffled <- FALSE
[13:35:06.010]                       if (inherits(cond, "message")) {
[13:35:06.010]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.010]                         if (muffled) 
[13:35:06.010]                           invokeRestart("muffleMessage")
[13:35:06.010]                       }
[13:35:06.010]                       else if (inherits(cond, "warning")) {
[13:35:06.010]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.010]                         if (muffled) 
[13:35:06.010]                           invokeRestart("muffleWarning")
[13:35:06.010]                       }
[13:35:06.010]                       else if (inherits(cond, "condition")) {
[13:35:06.010]                         if (!is.null(pattern)) {
[13:35:06.010]                           computeRestarts <- base::computeRestarts
[13:35:06.010]                           grepl <- base::grepl
[13:35:06.010]                           restarts <- computeRestarts(cond)
[13:35:06.010]                           for (restart in restarts) {
[13:35:06.010]                             name <- restart$name
[13:35:06.010]                             if (is.null(name)) 
[13:35:06.010]                               next
[13:35:06.010]                             if (!grepl(pattern, name)) 
[13:35:06.010]                               next
[13:35:06.010]                             invokeRestart(restart)
[13:35:06.010]                             muffled <- TRUE
[13:35:06.010]                             break
[13:35:06.010]                           }
[13:35:06.010]                         }
[13:35:06.010]                       }
[13:35:06.010]                       invisible(muffled)
[13:35:06.010]                     }
[13:35:06.010]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.010]                   }
[13:35:06.010]                 }
[13:35:06.010]             }
[13:35:06.010]         }))
[13:35:06.010]     }, error = function(ex) {
[13:35:06.010]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.010]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.010]                 ...future.rng), started = ...future.startTime, 
[13:35:06.010]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.010]             version = "1.8"), class = "FutureResult")
[13:35:06.010]     }, finally = {
[13:35:06.010]         if (!identical(...future.workdir, getwd())) 
[13:35:06.010]             setwd(...future.workdir)
[13:35:06.010]         {
[13:35:06.010]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.010]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.010]             }
[13:35:06.010]             base::options(...future.oldOptions)
[13:35:06.010]             if (.Platform$OS.type == "windows") {
[13:35:06.010]                 old_names <- names(...future.oldEnvVars)
[13:35:06.010]                 envs <- base::Sys.getenv()
[13:35:06.010]                 names <- names(envs)
[13:35:06.010]                 common <- intersect(names, old_names)
[13:35:06.010]                 added <- setdiff(names, old_names)
[13:35:06.010]                 removed <- setdiff(old_names, names)
[13:35:06.010]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.010]                   envs[common]]
[13:35:06.010]                 NAMES <- toupper(changed)
[13:35:06.010]                 args <- list()
[13:35:06.010]                 for (kk in seq_along(NAMES)) {
[13:35:06.010]                   name <- changed[[kk]]
[13:35:06.010]                   NAME <- NAMES[[kk]]
[13:35:06.010]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.010]                     next
[13:35:06.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.010]                 }
[13:35:06.010]                 NAMES <- toupper(added)
[13:35:06.010]                 for (kk in seq_along(NAMES)) {
[13:35:06.010]                   name <- added[[kk]]
[13:35:06.010]                   NAME <- NAMES[[kk]]
[13:35:06.010]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.010]                     next
[13:35:06.010]                   args[[name]] <- ""
[13:35:06.010]                 }
[13:35:06.010]                 NAMES <- toupper(removed)
[13:35:06.010]                 for (kk in seq_along(NAMES)) {
[13:35:06.010]                   name <- removed[[kk]]
[13:35:06.010]                   NAME <- NAMES[[kk]]
[13:35:06.010]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.010]                     next
[13:35:06.010]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.010]                 }
[13:35:06.010]                 if (length(args) > 0) 
[13:35:06.010]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.010]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.010]             }
[13:35:06.010]             else {
[13:35:06.010]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.010]             }
[13:35:06.010]             {
[13:35:06.010]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.010]                   0L) {
[13:35:06.010]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.010]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.010]                   base::options(opts)
[13:35:06.010]                 }
[13:35:06.010]                 {
[13:35:06.010]                   {
[13:35:06.010]                     NULL
[13:35:06.010]                     RNGkind("Mersenne-Twister")
[13:35:06.010]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:06.010]                       inherits = FALSE)
[13:35:06.010]                   }
[13:35:06.010]                   options(future.plan = NULL)
[13:35:06.010]                   if (is.na(NA_character_)) 
[13:35:06.010]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.010]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.010]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.010]                     .init = FALSE)
[13:35:06.010]                 }
[13:35:06.010]             }
[13:35:06.010]         }
[13:35:06.010]     })
[13:35:06.010]     if (TRUE) {
[13:35:06.010]         base::sink(type = "output", split = FALSE)
[13:35:06.010]         if (TRUE) {
[13:35:06.010]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.010]         }
[13:35:06.010]         else {
[13:35:06.010]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.010]         }
[13:35:06.010]         base::close(...future.stdout)
[13:35:06.010]         ...future.stdout <- NULL
[13:35:06.010]     }
[13:35:06.010]     ...future.result$conditions <- ...future.conditions
[13:35:06.010]     ...future.result$finished <- base::Sys.time()
[13:35:06.010]     ...future.result
[13:35:06.010] }
[13:35:06.012] assign_globals() ...
[13:35:06.012] List of 11
[13:35:06.012]  $ ...future.FUN            :function (x, ...)  
[13:35:06.012]  $ x_FUN                    :function (x)  
[13:35:06.012]  $ times                    : int 4
[13:35:06.012]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.012]  $ stop_if_not              :function (...)  
[13:35:06.012]  $ dim                      : int [1:2] 2 2
[13:35:06.012]  $ valid_types              : chr [1:2] "logical" "integer"
[13:35:06.012]  $ future.call.arguments    : list()
[13:35:06.012]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.012]  $ ...future.elements_ii    :List of 10
[13:35:06.012]   ..$ : int 1
[13:35:06.012]   ..$ : int 2
[13:35:06.012]   ..$ : int 3
[13:35:06.012]   ..$ : int 4
[13:35:06.012]   ..$ : int 5
[13:35:06.012]   ..$ : int 6
[13:35:06.012]   ..$ : int 7
[13:35:06.012]   ..$ : int 8
[13:35:06.012]   ..$ : int 9
[13:35:06.012]   ..$ : int 10
[13:35:06.012]  $ ...future.seeds_ii       : NULL
[13:35:06.012]  $ ...future.globals.maxSize: NULL
[13:35:06.012]  - attr(*, "where")=List of 11
[13:35:06.012]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.012]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.012]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.012]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.012]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.012]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.012]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.012]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.012]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.012]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.012]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.012]  - attr(*, "resolved")= logi FALSE
[13:35:06.012]  - attr(*, "total_size")= num 97232
[13:35:06.012]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.012]  - attr(*, "already-done")= logi TRUE
[13:35:06.021] - copied ‘...future.FUN’ to environment
[13:35:06.021] - reassign environment for ‘x_FUN’
[13:35:06.021] - copied ‘x_FUN’ to environment
[13:35:06.021] - copied ‘times’ to environment
[13:35:06.021] - copied ‘stopf’ to environment
[13:35:06.022] - copied ‘stop_if_not’ to environment
[13:35:06.022] - copied ‘dim’ to environment
[13:35:06.022] - copied ‘valid_types’ to environment
[13:35:06.022] - copied ‘future.call.arguments’ to environment
[13:35:06.022] - copied ‘...future.elements_ii’ to environment
[13:35:06.022] - copied ‘...future.seeds_ii’ to environment
[13:35:06.022] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.022] assign_globals() ... done
[13:35:06.023] plan(): Setting new future strategy stack:
[13:35:06.023] List of future strategies:
[13:35:06.023] 1. sequential:
[13:35:06.023]    - args: function (..., envir = parent.frame())
[13:35:06.023]    - tweaked: FALSE
[13:35:06.023]    - call: NULL
[13:35:06.023] plan(): nbrOfWorkers() = 1
[13:35:06.025] plan(): Setting new future strategy stack:
[13:35:06.025] List of future strategies:
[13:35:06.025] 1. sequential:
[13:35:06.025]    - args: function (..., envir = parent.frame())
[13:35:06.025]    - tweaked: FALSE
[13:35:06.025]    - call: plan(strategy)
[13:35:06.025] plan(): nbrOfWorkers() = 1
[13:35:06.025] SequentialFuture started (and completed)
[13:35:06.026] - Launch lazy future ... done
[13:35:06.026] run() for ‘SequentialFuture’ ... done
[13:35:06.026] Created future:
[13:35:06.026] SequentialFuture:
[13:35:06.026] Label: ‘future_vapply-1’
[13:35:06.026] Expression:
[13:35:06.026] {
[13:35:06.026]     do.call(function(...) {
[13:35:06.026]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.026]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.026]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.026]             on.exit(options(oopts), add = TRUE)
[13:35:06.026]         }
[13:35:06.026]         {
[13:35:06.026]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.026]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.026]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.026]             })
[13:35:06.026]         }
[13:35:06.026]     }, args = future.call.arguments)
[13:35:06.026] }
[13:35:06.026] Lazy evaluation: FALSE
[13:35:06.026] Asynchronous evaluation: FALSE
[13:35:06.026] Local evaluation: TRUE
[13:35:06.026] Environment: R_GlobalEnv
[13:35:06.026] Capture standard output: TRUE
[13:35:06.026] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.026] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.026] Packages: 1 packages (‘future.apply’)
[13:35:06.026] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.026] Resolved: TRUE
[13:35:06.026] Value: 2.27 KiB of class ‘list’
[13:35:06.026] Early signaling: FALSE
[13:35:06.026] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.026] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.027] Chunk #1 of 1 ... DONE
[13:35:06.027] Launching 1 futures (chunks) ... DONE
[13:35:06.027] Resolving 1 futures (chunks) ...
[13:35:06.027] resolve() on list ...
[13:35:06.027]  recursive: 0
[13:35:06.028]  length: 1
[13:35:06.028] 
[13:35:06.028] resolved() for ‘SequentialFuture’ ...
[13:35:06.028] - state: ‘finished’
[13:35:06.028] - run: TRUE
[13:35:06.028] - result: ‘FutureResult’
[13:35:06.028] resolved() for ‘SequentialFuture’ ... done
[13:35:06.028] Future #1
[13:35:06.028] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:06.028] - nx: 1
[13:35:06.028] - relay: TRUE
[13:35:06.029] - stdout: TRUE
[13:35:06.029] - signal: TRUE
[13:35:06.029] - resignal: FALSE
[13:35:06.029] - force: TRUE
[13:35:06.029] - relayed: [n=1] FALSE
[13:35:06.029] - queued futures: [n=1] FALSE
[13:35:06.029]  - until=1
[13:35:06.029]  - relaying element #1
[13:35:06.029] - relayed: [n=1] TRUE
[13:35:06.029] - queued futures: [n=1] TRUE
[13:35:06.029] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:06.030]  length: 0 (resolved future 1)
[13:35:06.030] Relaying remaining futures
[13:35:06.030] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.030] - nx: 1
[13:35:06.030] - relay: TRUE
[13:35:06.030] - stdout: TRUE
[13:35:06.030] - signal: TRUE
[13:35:06.030] - resignal: FALSE
[13:35:06.030] - force: TRUE
[13:35:06.030] - relayed: [n=1] TRUE
[13:35:06.030] - queued futures: [n=1] TRUE
 - flush all
[13:35:06.031] - relayed: [n=1] TRUE
[13:35:06.031] - queued futures: [n=1] TRUE
[13:35:06.031] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.031] resolve() on list ... DONE
[13:35:06.031]  - Number of value chunks collected: 1
[13:35:06.031] Resolving 1 futures (chunks) ... DONE
[13:35:06.031] Reducing values from 1 chunks ...
[13:35:06.031]  - Number of values collected after concatenation: 10
[13:35:06.031]  - Number of values expected: 10
[13:35:06.031] Reducing values from 1 chunks ... DONE
[13:35:06.031] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:35:06.032] future_lapply() ...
[13:35:06.034] Number of chunks: 1
[13:35:06.034] getGlobalsAndPackagesXApply() ...
[13:35:06.034]  - future.globals: TRUE
[13:35:06.034] getGlobalsAndPackages() ...
[13:35:06.034] Searching for globals...
[13:35:06.037] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:35:06.037] Searching for globals ... DONE
[13:35:06.037] Resolving globals: FALSE
[13:35:06.038] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[13:35:06.039] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:06.039] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.039] - packages: [1] ‘future.apply’
[13:35:06.039] getGlobalsAndPackages() ... DONE
[13:35:06.039]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.039]  - needed namespaces: [n=1] ‘future.apply’
[13:35:06.039] Finding globals ... DONE
[13:35:06.039]  - use_args: TRUE
[13:35:06.039]  - Getting '...' globals ...
[13:35:06.040] resolve() on list ...
[13:35:06.040]  recursive: 0
[13:35:06.040]  length: 1
[13:35:06.040]  elements: ‘...’
[13:35:06.040]  length: 0 (resolved future 1)
[13:35:06.040] resolve() on list ... DONE
[13:35:06.040]    - '...' content: [n=0] 
[13:35:06.040] List of 1
[13:35:06.040]  $ ...: list()
[13:35:06.040]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.040]  - attr(*, "where")=List of 1
[13:35:06.040]   ..$ ...:<environment: 0x5574d00b1b18> 
[13:35:06.040]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.040]  - attr(*, "resolved")= logi TRUE
[13:35:06.040]  - attr(*, "total_size")= num NA
[13:35:06.043]  - Getting '...' globals ... DONE
[13:35:06.043] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:06.043] List of 8
[13:35:06.043]  $ ...future.FUN:function (x, ...)  
[13:35:06.043]  $ x_FUN        :function (x)  
[13:35:06.043]  $ times        : int 4
[13:35:06.043]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.043]  $ stop_if_not  :function (...)  
[13:35:06.043]  $ dim          : int [1:2] 2 2
[13:35:06.043]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:06.043]  $ ...          : list()
[13:35:06.043]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.043]  - attr(*, "where")=List of 8
[13:35:06.043]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.043]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:06.043]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:06.043]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:06.043]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:06.043]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:06.043]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:06.043]   ..$ ...          :<environment: 0x5574d00b1b18> 
[13:35:06.043]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.043]  - attr(*, "resolved")= logi FALSE
[13:35:06.043]  - attr(*, "total_size")= num 97304
[13:35:06.049] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:06.049] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.049] Number of futures (= number of chunks): 1
[13:35:06.050] Launching 1 futures (chunks) ...
[13:35:06.050] Chunk #1 of 1 ...
[13:35:06.050]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.050] getGlobalsAndPackages() ...
[13:35:06.050] Searching for globals...
[13:35:06.050] 
[13:35:06.050] Searching for globals ... DONE
[13:35:06.050] - globals: [0] <none>
[13:35:06.050] getGlobalsAndPackages() ... DONE
[13:35:06.050]    + additional globals found: [n=0] 
[13:35:06.051]    + additional namespaces needed: [n=0] 
[13:35:06.051]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.051]  - seeds: <none>
[13:35:06.051]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.051] getGlobalsAndPackages() ...
[13:35:06.051] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.051] Resolving globals: FALSE
[13:35:06.051] Tweak future expression to call with '...' arguments ...
[13:35:06.051] {
[13:35:06.051]     do.call(function(...) {
[13:35:06.051]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.051]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.051]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.051]             on.exit(options(oopts), add = TRUE)
[13:35:06.051]         }
[13:35:06.051]         {
[13:35:06.051]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.051]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.051]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.051]             })
[13:35:06.051]         }
[13:35:06.051]     }, args = future.call.arguments)
[13:35:06.051] }
[13:35:06.052] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.052] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.052] - packages: [1] ‘future.apply’
[13:35:06.052] getGlobalsAndPackages() ... DONE
[13:35:06.053] run() for ‘Future’ ...
[13:35:06.053] - state: ‘created’
[13:35:06.053] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:06.053] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.053] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:06.053]   - Field: ‘label’
[13:35:06.053]   - Field: ‘local’
[13:35:06.053]   - Field: ‘owner’
[13:35:06.053]   - Field: ‘envir’
[13:35:06.054]   - Field: ‘packages’
[13:35:06.054]   - Field: ‘gc’
[13:35:06.054]   - Field: ‘conditions’
[13:35:06.054]   - Field: ‘expr’
[13:35:06.054]   - Field: ‘uuid’
[13:35:06.054]   - Field: ‘seed’
[13:35:06.054]   - Field: ‘version’
[13:35:06.054]   - Field: ‘result’
[13:35:06.054]   - Field: ‘asynchronous’
[13:35:06.054]   - Field: ‘calls’
[13:35:06.054]   - Field: ‘globals’
[13:35:06.055]   - Field: ‘stdout’
[13:35:06.055]   - Field: ‘earlySignal’
[13:35:06.055]   - Field: ‘lazy’
[13:35:06.055]   - Field: ‘state’
[13:35:06.055] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:06.055] - Launch lazy future ...
[13:35:06.055] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.055] Packages needed by future strategies (n = 0): <none>
[13:35:06.056] {
[13:35:06.056]     {
[13:35:06.056]         {
[13:35:06.056]             ...future.startTime <- base::Sys.time()
[13:35:06.056]             {
[13:35:06.056]                 {
[13:35:06.056]                   {
[13:35:06.056]                     {
[13:35:06.056]                       base::local({
[13:35:06.056]                         has_future <- base::requireNamespace("future", 
[13:35:06.056]                           quietly = TRUE)
[13:35:06.056]                         if (has_future) {
[13:35:06.056]                           ns <- base::getNamespace("future")
[13:35:06.056]                           version <- ns[[".package"]][["version"]]
[13:35:06.056]                           if (is.null(version)) 
[13:35:06.056]                             version <- utils::packageVersion("future")
[13:35:06.056]                         }
[13:35:06.056]                         else {
[13:35:06.056]                           version <- NULL
[13:35:06.056]                         }
[13:35:06.056]                         if (!has_future || version < "1.8.0") {
[13:35:06.056]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.056]                             "", base::R.version$version.string), 
[13:35:06.056]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:06.056]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:06.056]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.056]                               "release", "version")], collapse = " "), 
[13:35:06.056]                             hostname = base::Sys.info()[["nodename"]])
[13:35:06.056]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.056]                             info)
[13:35:06.056]                           info <- base::paste(info, collapse = "; ")
[13:35:06.056]                           if (!has_future) {
[13:35:06.056]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.056]                               info)
[13:35:06.056]                           }
[13:35:06.056]                           else {
[13:35:06.056]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.056]                               info, version)
[13:35:06.056]                           }
[13:35:06.056]                           base::stop(msg)
[13:35:06.056]                         }
[13:35:06.056]                       })
[13:35:06.056]                     }
[13:35:06.056]                     base::local({
[13:35:06.056]                       for (pkg in "future.apply") {
[13:35:06.056]                         base::loadNamespace(pkg)
[13:35:06.056]                         base::library(pkg, character.only = TRUE)
[13:35:06.056]                       }
[13:35:06.056]                     })
[13:35:06.056]                   }
[13:35:06.056]                   ...future.strategy.old <- future::plan("list")
[13:35:06.056]                   options(future.plan = NULL)
[13:35:06.056]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.056]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.056]                 }
[13:35:06.056]                 ...future.workdir <- getwd()
[13:35:06.056]             }
[13:35:06.056]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.056]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.056]         }
[13:35:06.056]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.056]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:06.056]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.056]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.056]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.056]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.056]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.056]             base::names(...future.oldOptions))
[13:35:06.056]     }
[13:35:06.056]     if (FALSE) {
[13:35:06.056]     }
[13:35:06.056]     else {
[13:35:06.056]         if (TRUE) {
[13:35:06.056]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.056]                 open = "w")
[13:35:06.056]         }
[13:35:06.056]         else {
[13:35:06.056]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.056]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.056]         }
[13:35:06.056]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.056]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.056]             base::sink(type = "output", split = FALSE)
[13:35:06.056]             base::close(...future.stdout)
[13:35:06.056]         }, add = TRUE)
[13:35:06.056]     }
[13:35:06.056]     ...future.frame <- base::sys.nframe()
[13:35:06.056]     ...future.conditions <- base::list()
[13:35:06.056]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.056]     if (FALSE) {
[13:35:06.056]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.056]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.056]     }
[13:35:06.056]     ...future.result <- base::tryCatch({
[13:35:06.056]         base::withCallingHandlers({
[13:35:06.056]             ...future.value <- base::withVisible(base::local({
[13:35:06.056]                 do.call(function(...) {
[13:35:06.056]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.056]                   if (!identical(...future.globals.maxSize.org, 
[13:35:06.056]                     ...future.globals.maxSize)) {
[13:35:06.056]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.056]                     on.exit(options(oopts), add = TRUE)
[13:35:06.056]                   }
[13:35:06.056]                   {
[13:35:06.056]                     lapply(seq_along(...future.elements_ii), 
[13:35:06.056]                       FUN = function(jj) {
[13:35:06.056]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.056]                         ...future.FUN(...future.X_jj, ...)
[13:35:06.056]                       })
[13:35:06.056]                   }
[13:35:06.056]                 }, args = future.call.arguments)
[13:35:06.056]             }))
[13:35:06.056]             future::FutureResult(value = ...future.value$value, 
[13:35:06.056]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.056]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.056]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.056]                     ...future.globalenv.names))
[13:35:06.056]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.056]         }, condition = base::local({
[13:35:06.056]             c <- base::c
[13:35:06.056]             inherits <- base::inherits
[13:35:06.056]             invokeRestart <- base::invokeRestart
[13:35:06.056]             length <- base::length
[13:35:06.056]             list <- base::list
[13:35:06.056]             seq.int <- base::seq.int
[13:35:06.056]             signalCondition <- base::signalCondition
[13:35:06.056]             sys.calls <- base::sys.calls
[13:35:06.056]             `[[` <- base::`[[`
[13:35:06.056]             `+` <- base::`+`
[13:35:06.056]             `<<-` <- base::`<<-`
[13:35:06.056]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.056]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.056]                   3L)]
[13:35:06.056]             }
[13:35:06.056]             function(cond) {
[13:35:06.056]                 is_error <- inherits(cond, "error")
[13:35:06.056]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.056]                   NULL)
[13:35:06.056]                 if (is_error) {
[13:35:06.056]                   sessionInformation <- function() {
[13:35:06.056]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.056]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.056]                       search = base::search(), system = base::Sys.info())
[13:35:06.056]                   }
[13:35:06.056]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.056]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.056]                     cond$call), session = sessionInformation(), 
[13:35:06.056]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.056]                   signalCondition(cond)
[13:35:06.056]                 }
[13:35:06.056]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.056]                 "immediateCondition"))) {
[13:35:06.056]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.056]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.056]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.056]                   if (TRUE && !signal) {
[13:35:06.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.056]                     {
[13:35:06.056]                       inherits <- base::inherits
[13:35:06.056]                       invokeRestart <- base::invokeRestart
[13:35:06.056]                       is.null <- base::is.null
[13:35:06.056]                       muffled <- FALSE
[13:35:06.056]                       if (inherits(cond, "message")) {
[13:35:06.056]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.056]                         if (muffled) 
[13:35:06.056]                           invokeRestart("muffleMessage")
[13:35:06.056]                       }
[13:35:06.056]                       else if (inherits(cond, "warning")) {
[13:35:06.056]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.056]                         if (muffled) 
[13:35:06.056]                           invokeRestart("muffleWarning")
[13:35:06.056]                       }
[13:35:06.056]                       else if (inherits(cond, "condition")) {
[13:35:06.056]                         if (!is.null(pattern)) {
[13:35:06.056]                           computeRestarts <- base::computeRestarts
[13:35:06.056]                           grepl <- base::grepl
[13:35:06.056]                           restarts <- computeRestarts(cond)
[13:35:06.056]                           for (restart in restarts) {
[13:35:06.056]                             name <- restart$name
[13:35:06.056]                             if (is.null(name)) 
[13:35:06.056]                               next
[13:35:06.056]                             if (!grepl(pattern, name)) 
[13:35:06.056]                               next
[13:35:06.056]                             invokeRestart(restart)
[13:35:06.056]                             muffled <- TRUE
[13:35:06.056]                             break
[13:35:06.056]                           }
[13:35:06.056]                         }
[13:35:06.056]                       }
[13:35:06.056]                       invisible(muffled)
[13:35:06.056]                     }
[13:35:06.056]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.056]                   }
[13:35:06.056]                 }
[13:35:06.056]                 else {
[13:35:06.056]                   if (TRUE) {
[13:35:06.056]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.056]                     {
[13:35:06.056]                       inherits <- base::inherits
[13:35:06.056]                       invokeRestart <- base::invokeRestart
[13:35:06.056]                       is.null <- base::is.null
[13:35:06.056]                       muffled <- FALSE
[13:35:06.056]                       if (inherits(cond, "message")) {
[13:35:06.056]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.056]                         if (muffled) 
[13:35:06.056]                           invokeRestart("muffleMessage")
[13:35:06.056]                       }
[13:35:06.056]                       else if (inherits(cond, "warning")) {
[13:35:06.056]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.056]                         if (muffled) 
[13:35:06.056]                           invokeRestart("muffleWarning")
[13:35:06.056]                       }
[13:35:06.056]                       else if (inherits(cond, "condition")) {
[13:35:06.056]                         if (!is.null(pattern)) {
[13:35:06.056]                           computeRestarts <- base::computeRestarts
[13:35:06.056]                           grepl <- base::grepl
[13:35:06.056]                           restarts <- computeRestarts(cond)
[13:35:06.056]                           for (restart in restarts) {
[13:35:06.056]                             name <- restart$name
[13:35:06.056]                             if (is.null(name)) 
[13:35:06.056]                               next
[13:35:06.056]                             if (!grepl(pattern, name)) 
[13:35:06.056]                               next
[13:35:06.056]                             invokeRestart(restart)
[13:35:06.056]                             muffled <- TRUE
[13:35:06.056]                             break
[13:35:06.056]                           }
[13:35:06.056]                         }
[13:35:06.056]                       }
[13:35:06.056]                       invisible(muffled)
[13:35:06.056]                     }
[13:35:06.056]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.056]                   }
[13:35:06.056]                 }
[13:35:06.056]             }
[13:35:06.056]         }))
[13:35:06.056]     }, error = function(ex) {
[13:35:06.056]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.056]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.056]                 ...future.rng), started = ...future.startTime, 
[13:35:06.056]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.056]             version = "1.8"), class = "FutureResult")
[13:35:06.056]     }, finally = {
[13:35:06.056]         if (!identical(...future.workdir, getwd())) 
[13:35:06.056]             setwd(...future.workdir)
[13:35:06.056]         {
[13:35:06.056]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.056]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.056]             }
[13:35:06.056]             base::options(...future.oldOptions)
[13:35:06.056]             if (.Platform$OS.type == "windows") {
[13:35:06.056]                 old_names <- names(...future.oldEnvVars)
[13:35:06.056]                 envs <- base::Sys.getenv()
[13:35:06.056]                 names <- names(envs)
[13:35:06.056]                 common <- intersect(names, old_names)
[13:35:06.056]                 added <- setdiff(names, old_names)
[13:35:06.056]                 removed <- setdiff(old_names, names)
[13:35:06.056]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.056]                   envs[common]]
[13:35:06.056]                 NAMES <- toupper(changed)
[13:35:06.056]                 args <- list()
[13:35:06.056]                 for (kk in seq_along(NAMES)) {
[13:35:06.056]                   name <- changed[[kk]]
[13:35:06.056]                   NAME <- NAMES[[kk]]
[13:35:06.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.056]                     next
[13:35:06.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.056]                 }
[13:35:06.056]                 NAMES <- toupper(added)
[13:35:06.056]                 for (kk in seq_along(NAMES)) {
[13:35:06.056]                   name <- added[[kk]]
[13:35:06.056]                   NAME <- NAMES[[kk]]
[13:35:06.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.056]                     next
[13:35:06.056]                   args[[name]] <- ""
[13:35:06.056]                 }
[13:35:06.056]                 NAMES <- toupper(removed)
[13:35:06.056]                 for (kk in seq_along(NAMES)) {
[13:35:06.056]                   name <- removed[[kk]]
[13:35:06.056]                   NAME <- NAMES[[kk]]
[13:35:06.056]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.056]                     next
[13:35:06.056]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.056]                 }
[13:35:06.056]                 if (length(args) > 0) 
[13:35:06.056]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.056]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.056]             }
[13:35:06.056]             else {
[13:35:06.056]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.056]             }
[13:35:06.056]             {
[13:35:06.056]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.056]                   0L) {
[13:35:06.056]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.056]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.056]                   base::options(opts)
[13:35:06.056]                 }
[13:35:06.056]                 {
[13:35:06.056]                   {
[13:35:06.056]                     NULL
[13:35:06.056]                     RNGkind("Mersenne-Twister")
[13:35:06.056]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:06.056]                       inherits = FALSE)
[13:35:06.056]                   }
[13:35:06.056]                   options(future.plan = NULL)
[13:35:06.056]                   if (is.na(NA_character_)) 
[13:35:06.056]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.056]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.056]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.056]                     .init = FALSE)
[13:35:06.056]                 }
[13:35:06.056]             }
[13:35:06.056]         }
[13:35:06.056]     })
[13:35:06.056]     if (TRUE) {
[13:35:06.056]         base::sink(type = "output", split = FALSE)
[13:35:06.056]         if (TRUE) {
[13:35:06.056]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.056]         }
[13:35:06.056]         else {
[13:35:06.056]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.056]         }
[13:35:06.056]         base::close(...future.stdout)
[13:35:06.056]         ...future.stdout <- NULL
[13:35:06.056]     }
[13:35:06.056]     ...future.result$conditions <- ...future.conditions
[13:35:06.056]     ...future.result$finished <- base::Sys.time()
[13:35:06.056]     ...future.result
[13:35:06.056] }
[13:35:06.057] assign_globals() ...
[13:35:06.058] List of 11
[13:35:06.058]  $ ...future.FUN            :function (x, ...)  
[13:35:06.058]  $ x_FUN                    :function (x)  
[13:35:06.058]  $ times                    : int 4
[13:35:06.058]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.058]  $ stop_if_not              :function (...)  
[13:35:06.058]  $ dim                      : int [1:2] 2 2
[13:35:06.058]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:06.058]  $ future.call.arguments    : list()
[13:35:06.058]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.058]  $ ...future.elements_ii    :List of 10
[13:35:06.058]   ..$ : int 1
[13:35:06.058]   ..$ : int 2
[13:35:06.058]   ..$ : int 3
[13:35:06.058]   ..$ : int 4
[13:35:06.058]   ..$ : int 5
[13:35:06.058]   ..$ : int 6
[13:35:06.058]   ..$ : int 7
[13:35:06.058]   ..$ : int 8
[13:35:06.058]   ..$ : int 9
[13:35:06.058]   ..$ : int 10
[13:35:06.058]  $ ...future.seeds_ii       : NULL
[13:35:06.058]  $ ...future.globals.maxSize: NULL
[13:35:06.058]  - attr(*, "where")=List of 11
[13:35:06.058]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.058]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.058]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.058]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.058]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.058]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.058]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.058]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.058]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.058]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.058]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.058]  - attr(*, "resolved")= logi FALSE
[13:35:06.058]  - attr(*, "total_size")= num 97304
[13:35:06.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.058]  - attr(*, "already-done")= logi TRUE
[13:35:06.092] - copied ‘...future.FUN’ to environment
[13:35:06.092] - reassign environment for ‘x_FUN’
[13:35:06.092] - copied ‘x_FUN’ to environment
[13:35:06.092] - copied ‘times’ to environment
[13:35:06.092] - copied ‘stopf’ to environment
[13:35:06.092] - copied ‘stop_if_not’ to environment
[13:35:06.092] - copied ‘dim’ to environment
[13:35:06.092] - copied ‘valid_types’ to environment
[13:35:06.092] - copied ‘future.call.arguments’ to environment
[13:35:06.092] - copied ‘...future.elements_ii’ to environment
[13:35:06.092] - copied ‘...future.seeds_ii’ to environment
[13:35:06.093] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.093] assign_globals() ... done
[13:35:06.093] plan(): Setting new future strategy stack:
[13:35:06.093] List of future strategies:
[13:35:06.093] 1. sequential:
[13:35:06.093]    - args: function (..., envir = parent.frame())
[13:35:06.093]    - tweaked: FALSE
[13:35:06.093]    - call: NULL
[13:35:06.093] plan(): nbrOfWorkers() = 1
[13:35:06.094] plan(): Setting new future strategy stack:
[13:35:06.094] List of future strategies:
[13:35:06.094] 1. sequential:
[13:35:06.094]    - args: function (..., envir = parent.frame())
[13:35:06.094]    - tweaked: FALSE
[13:35:06.094]    - call: plan(strategy)
[13:35:06.095] plan(): nbrOfWorkers() = 1
[13:35:06.095] SequentialFuture started (and completed)
[13:35:06.095] - Launch lazy future ... done
[13:35:06.095] run() for ‘SequentialFuture’ ... done
[13:35:06.095] Created future:
[13:35:06.095] SequentialFuture:
[13:35:06.095] Label: ‘future_vapply-1’
[13:35:06.095] Expression:
[13:35:06.095] {
[13:35:06.095]     do.call(function(...) {
[13:35:06.095]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.095]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.095]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.095]             on.exit(options(oopts), add = TRUE)
[13:35:06.095]         }
[13:35:06.095]         {
[13:35:06.095]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.095]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.095]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.095]             })
[13:35:06.095]         }
[13:35:06.095]     }, args = future.call.arguments)
[13:35:06.095] }
[13:35:06.095] Lazy evaluation: FALSE
[13:35:06.095] Asynchronous evaluation: FALSE
[13:35:06.095] Local evaluation: TRUE
[13:35:06.095] Environment: R_GlobalEnv
[13:35:06.095] Capture standard output: TRUE
[13:35:06.095] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.095] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.095] Packages: 1 packages (‘future.apply’)
[13:35:06.095] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.095] Resolved: TRUE
[13:35:06.095] Value: 2.27 KiB of class ‘list’
[13:35:06.095] Early signaling: FALSE
[13:35:06.095] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.095] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.096] Chunk #1 of 1 ... DONE
[13:35:06.096] Launching 1 futures (chunks) ... DONE
[13:35:06.097] Resolving 1 futures (chunks) ...
[13:35:06.097] resolve() on list ...
[13:35:06.097]  recursive: 0
[13:35:06.097]  length: 1
[13:35:06.097] 
[13:35:06.097] resolved() for ‘SequentialFuture’ ...
[13:35:06.097] - state: ‘finished’
[13:35:06.097] - run: TRUE
[13:35:06.097] - result: ‘FutureResult’
[13:35:06.097] resolved() for ‘SequentialFuture’ ... done
[13:35:06.097] Future #1
[13:35:06.098] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:06.098] - nx: 1
[13:35:06.098] - relay: TRUE
[13:35:06.098] - stdout: TRUE
[13:35:06.098] - signal: TRUE
[13:35:06.098] - resignal: FALSE
[13:35:06.098] - force: TRUE
[13:35:06.098] - relayed: [n=1] FALSE
[13:35:06.098] - queued futures: [n=1] FALSE
[13:35:06.098]  - until=1
[13:35:06.098]  - relaying element #1
[13:35:06.099] - relayed: [n=1] TRUE
[13:35:06.099] - queued futures: [n=1] TRUE
[13:35:06.099] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:06.099]  length: 0 (resolved future 1)
[13:35:06.099] Relaying remaining futures
[13:35:06.099] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.099] - nx: 1
[13:35:06.099] - relay: TRUE
[13:35:06.099] - stdout: TRUE
[13:35:06.099] - signal: TRUE
[13:35:06.099] - resignal: FALSE
[13:35:06.100] - force: TRUE
[13:35:06.100] - relayed: [n=1] TRUE
[13:35:06.100] - queued futures: [n=1] TRUE
 - flush all
[13:35:06.100] - relayed: [n=1] TRUE
[13:35:06.100] - queued futures: [n=1] TRUE
[13:35:06.100] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.100] resolve() on list ... DONE
[13:35:06.100]  - Number of value chunks collected: 1
[13:35:06.100] Resolving 1 futures (chunks) ... DONE
[13:35:06.100] Reducing values from 1 chunks ...
[13:35:06.101]  - Number of values collected after concatenation: 10
[13:35:06.101]  - Number of values expected: 10
[13:35:06.101] Reducing values from 1 chunks ... DONE
[13:35:06.101] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[13:35:06.103] future_lapply() ...
[13:35:06.104] Number of chunks: 1
[13:35:06.104] getGlobalsAndPackagesXApply() ...
[13:35:06.104]  - future.globals: TRUE
[13:35:06.104] getGlobalsAndPackages() ...
[13:35:06.105] Searching for globals...
[13:35:06.108] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[13:35:06.108] Searching for globals ... DONE
[13:35:06.108] Resolving globals: FALSE
[13:35:06.110] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[13:35:06.110] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:06.111] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.111] - packages: [1] ‘future.apply’
[13:35:06.111] getGlobalsAndPackages() ... DONE
[13:35:06.111]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.111]  - needed namespaces: [n=1] ‘future.apply’
[13:35:06.111] Finding globals ... DONE
[13:35:06.111]  - use_args: TRUE
[13:35:06.111]  - Getting '...' globals ...
[13:35:06.112] resolve() on list ...
[13:35:06.112]  recursive: 0
[13:35:06.112]  length: 1
[13:35:06.112]  elements: ‘...’
[13:35:06.112]  length: 0 (resolved future 1)
[13:35:06.112] resolve() on list ... DONE
[13:35:06.112]    - '...' content: [n=0] 
[13:35:06.112] List of 1
[13:35:06.112]  $ ...: list()
[13:35:06.112]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.112]  - attr(*, "where")=List of 1
[13:35:06.112]   ..$ ...:<environment: 0x5574d0924098> 
[13:35:06.112]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.112]  - attr(*, "resolved")= logi TRUE
[13:35:06.112]  - attr(*, "total_size")= num NA
[13:35:06.114]  - Getting '...' globals ... DONE
[13:35:06.115] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:06.115] List of 8
[13:35:06.115]  $ ...future.FUN:function (x, ...)  
[13:35:06.115]  $ x_FUN        :function (x)  
[13:35:06.115]  $ times        : int 4
[13:35:06.115]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.115]  $ stop_if_not  :function (...)  
[13:35:06.115]  $ dim          : int [1:2] 2 2
[13:35:06.115]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:06.115]  $ ...          : list()
[13:35:06.115]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.115]  - attr(*, "where")=List of 8
[13:35:06.115]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.115]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:06.115]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:06.115]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:06.115]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:06.115]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:06.115]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:06.115]   ..$ ...          :<environment: 0x5574d0924098> 
[13:35:06.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.115]  - attr(*, "resolved")= logi FALSE
[13:35:06.115]  - attr(*, "total_size")= num 105552
[13:35:06.120] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:06.120] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.120] Number of futures (= number of chunks): 1
[13:35:06.120] Launching 1 futures (chunks) ...
[13:35:06.120] Chunk #1 of 1 ...
[13:35:06.120]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.121] getGlobalsAndPackages() ...
[13:35:06.121] Searching for globals...
[13:35:06.121] 
[13:35:06.121] Searching for globals ... DONE
[13:35:06.121] - globals: [0] <none>
[13:35:06.121] getGlobalsAndPackages() ... DONE
[13:35:06.121]    + additional globals found: [n=0] 
[13:35:06.121]    + additional namespaces needed: [n=0] 
[13:35:06.121]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.121]  - seeds: <none>
[13:35:06.122]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.122] getGlobalsAndPackages() ...
[13:35:06.122] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.122] Resolving globals: FALSE
[13:35:06.122] Tweak future expression to call with '...' arguments ...
[13:35:06.122] {
[13:35:06.122]     do.call(function(...) {
[13:35:06.122]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.122]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.122]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.122]             on.exit(options(oopts), add = TRUE)
[13:35:06.122]         }
[13:35:06.122]         {
[13:35:06.122]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.122]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.122]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.122]             })
[13:35:06.122]         }
[13:35:06.122]     }, args = future.call.arguments)
[13:35:06.122] }
[13:35:06.122] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.123] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.123] - packages: [1] ‘future.apply’
[13:35:06.123] getGlobalsAndPackages() ... DONE
[13:35:06.123] run() for ‘Future’ ...
[13:35:06.123] - state: ‘created’
[13:35:06.123] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:06.124] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.124] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:06.124]   - Field: ‘label’
[13:35:06.124]   - Field: ‘local’
[13:35:06.124]   - Field: ‘owner’
[13:35:06.124]   - Field: ‘envir’
[13:35:06.124]   - Field: ‘packages’
[13:35:06.124]   - Field: ‘gc’
[13:35:06.124]   - Field: ‘conditions’
[13:35:06.125]   - Field: ‘expr’
[13:35:06.125]   - Field: ‘uuid’
[13:35:06.125]   - Field: ‘seed’
[13:35:06.125]   - Field: ‘version’
[13:35:06.125]   - Field: ‘result’
[13:35:06.125]   - Field: ‘asynchronous’
[13:35:06.125]   - Field: ‘calls’
[13:35:06.125]   - Field: ‘globals’
[13:35:06.125]   - Field: ‘stdout’
[13:35:06.125]   - Field: ‘earlySignal’
[13:35:06.125]   - Field: ‘lazy’
[13:35:06.126]   - Field: ‘state’
[13:35:06.126] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:06.126] - Launch lazy future ...
[13:35:06.126] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.126] Packages needed by future strategies (n = 0): <none>
[13:35:06.126] {
[13:35:06.126]     {
[13:35:06.126]         {
[13:35:06.126]             ...future.startTime <- base::Sys.time()
[13:35:06.126]             {
[13:35:06.126]                 {
[13:35:06.126]                   {
[13:35:06.126]                     {
[13:35:06.126]                       base::local({
[13:35:06.126]                         has_future <- base::requireNamespace("future", 
[13:35:06.126]                           quietly = TRUE)
[13:35:06.126]                         if (has_future) {
[13:35:06.126]                           ns <- base::getNamespace("future")
[13:35:06.126]                           version <- ns[[".package"]][["version"]]
[13:35:06.126]                           if (is.null(version)) 
[13:35:06.126]                             version <- utils::packageVersion("future")
[13:35:06.126]                         }
[13:35:06.126]                         else {
[13:35:06.126]                           version <- NULL
[13:35:06.126]                         }
[13:35:06.126]                         if (!has_future || version < "1.8.0") {
[13:35:06.126]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.126]                             "", base::R.version$version.string), 
[13:35:06.126]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:06.126]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:06.126]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.126]                               "release", "version")], collapse = " "), 
[13:35:06.126]                             hostname = base::Sys.info()[["nodename"]])
[13:35:06.126]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.126]                             info)
[13:35:06.126]                           info <- base::paste(info, collapse = "; ")
[13:35:06.126]                           if (!has_future) {
[13:35:06.126]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.126]                               info)
[13:35:06.126]                           }
[13:35:06.126]                           else {
[13:35:06.126]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.126]                               info, version)
[13:35:06.126]                           }
[13:35:06.126]                           base::stop(msg)
[13:35:06.126]                         }
[13:35:06.126]                       })
[13:35:06.126]                     }
[13:35:06.126]                     base::local({
[13:35:06.126]                       for (pkg in "future.apply") {
[13:35:06.126]                         base::loadNamespace(pkg)
[13:35:06.126]                         base::library(pkg, character.only = TRUE)
[13:35:06.126]                       }
[13:35:06.126]                     })
[13:35:06.126]                   }
[13:35:06.126]                   ...future.strategy.old <- future::plan("list")
[13:35:06.126]                   options(future.plan = NULL)
[13:35:06.126]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.126]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.126]                 }
[13:35:06.126]                 ...future.workdir <- getwd()
[13:35:06.126]             }
[13:35:06.126]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.126]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.126]         }
[13:35:06.126]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.126]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:06.126]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.126]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.126]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.126]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.126]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.126]             base::names(...future.oldOptions))
[13:35:06.126]     }
[13:35:06.126]     if (FALSE) {
[13:35:06.126]     }
[13:35:06.126]     else {
[13:35:06.126]         if (TRUE) {
[13:35:06.126]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.126]                 open = "w")
[13:35:06.126]         }
[13:35:06.126]         else {
[13:35:06.126]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.126]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.126]         }
[13:35:06.126]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.126]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.126]             base::sink(type = "output", split = FALSE)
[13:35:06.126]             base::close(...future.stdout)
[13:35:06.126]         }, add = TRUE)
[13:35:06.126]     }
[13:35:06.126]     ...future.frame <- base::sys.nframe()
[13:35:06.126]     ...future.conditions <- base::list()
[13:35:06.126]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.126]     if (FALSE) {
[13:35:06.126]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.126]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.126]     }
[13:35:06.126]     ...future.result <- base::tryCatch({
[13:35:06.126]         base::withCallingHandlers({
[13:35:06.126]             ...future.value <- base::withVisible(base::local({
[13:35:06.126]                 do.call(function(...) {
[13:35:06.126]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.126]                   if (!identical(...future.globals.maxSize.org, 
[13:35:06.126]                     ...future.globals.maxSize)) {
[13:35:06.126]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.126]                     on.exit(options(oopts), add = TRUE)
[13:35:06.126]                   }
[13:35:06.126]                   {
[13:35:06.126]                     lapply(seq_along(...future.elements_ii), 
[13:35:06.126]                       FUN = function(jj) {
[13:35:06.126]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.126]                         ...future.FUN(...future.X_jj, ...)
[13:35:06.126]                       })
[13:35:06.126]                   }
[13:35:06.126]                 }, args = future.call.arguments)
[13:35:06.126]             }))
[13:35:06.126]             future::FutureResult(value = ...future.value$value, 
[13:35:06.126]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.126]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.126]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.126]                     ...future.globalenv.names))
[13:35:06.126]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.126]         }, condition = base::local({
[13:35:06.126]             c <- base::c
[13:35:06.126]             inherits <- base::inherits
[13:35:06.126]             invokeRestart <- base::invokeRestart
[13:35:06.126]             length <- base::length
[13:35:06.126]             list <- base::list
[13:35:06.126]             seq.int <- base::seq.int
[13:35:06.126]             signalCondition <- base::signalCondition
[13:35:06.126]             sys.calls <- base::sys.calls
[13:35:06.126]             `[[` <- base::`[[`
[13:35:06.126]             `+` <- base::`+`
[13:35:06.126]             `<<-` <- base::`<<-`
[13:35:06.126]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.126]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.126]                   3L)]
[13:35:06.126]             }
[13:35:06.126]             function(cond) {
[13:35:06.126]                 is_error <- inherits(cond, "error")
[13:35:06.126]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.126]                   NULL)
[13:35:06.126]                 if (is_error) {
[13:35:06.126]                   sessionInformation <- function() {
[13:35:06.126]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.126]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.126]                       search = base::search(), system = base::Sys.info())
[13:35:06.126]                   }
[13:35:06.126]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.126]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.126]                     cond$call), session = sessionInformation(), 
[13:35:06.126]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.126]                   signalCondition(cond)
[13:35:06.126]                 }
[13:35:06.126]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.126]                 "immediateCondition"))) {
[13:35:06.126]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.126]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.126]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.126]                   if (TRUE && !signal) {
[13:35:06.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.126]                     {
[13:35:06.126]                       inherits <- base::inherits
[13:35:06.126]                       invokeRestart <- base::invokeRestart
[13:35:06.126]                       is.null <- base::is.null
[13:35:06.126]                       muffled <- FALSE
[13:35:06.126]                       if (inherits(cond, "message")) {
[13:35:06.126]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.126]                         if (muffled) 
[13:35:06.126]                           invokeRestart("muffleMessage")
[13:35:06.126]                       }
[13:35:06.126]                       else if (inherits(cond, "warning")) {
[13:35:06.126]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.126]                         if (muffled) 
[13:35:06.126]                           invokeRestart("muffleWarning")
[13:35:06.126]                       }
[13:35:06.126]                       else if (inherits(cond, "condition")) {
[13:35:06.126]                         if (!is.null(pattern)) {
[13:35:06.126]                           computeRestarts <- base::computeRestarts
[13:35:06.126]                           grepl <- base::grepl
[13:35:06.126]                           restarts <- computeRestarts(cond)
[13:35:06.126]                           for (restart in restarts) {
[13:35:06.126]                             name <- restart$name
[13:35:06.126]                             if (is.null(name)) 
[13:35:06.126]                               next
[13:35:06.126]                             if (!grepl(pattern, name)) 
[13:35:06.126]                               next
[13:35:06.126]                             invokeRestart(restart)
[13:35:06.126]                             muffled <- TRUE
[13:35:06.126]                             break
[13:35:06.126]                           }
[13:35:06.126]                         }
[13:35:06.126]                       }
[13:35:06.126]                       invisible(muffled)
[13:35:06.126]                     }
[13:35:06.126]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.126]                   }
[13:35:06.126]                 }
[13:35:06.126]                 else {
[13:35:06.126]                   if (TRUE) {
[13:35:06.126]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.126]                     {
[13:35:06.126]                       inherits <- base::inherits
[13:35:06.126]                       invokeRestart <- base::invokeRestart
[13:35:06.126]                       is.null <- base::is.null
[13:35:06.126]                       muffled <- FALSE
[13:35:06.126]                       if (inherits(cond, "message")) {
[13:35:06.126]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.126]                         if (muffled) 
[13:35:06.126]                           invokeRestart("muffleMessage")
[13:35:06.126]                       }
[13:35:06.126]                       else if (inherits(cond, "warning")) {
[13:35:06.126]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.126]                         if (muffled) 
[13:35:06.126]                           invokeRestart("muffleWarning")
[13:35:06.126]                       }
[13:35:06.126]                       else if (inherits(cond, "condition")) {
[13:35:06.126]                         if (!is.null(pattern)) {
[13:35:06.126]                           computeRestarts <- base::computeRestarts
[13:35:06.126]                           grepl <- base::grepl
[13:35:06.126]                           restarts <- computeRestarts(cond)
[13:35:06.126]                           for (restart in restarts) {
[13:35:06.126]                             name <- restart$name
[13:35:06.126]                             if (is.null(name)) 
[13:35:06.126]                               next
[13:35:06.126]                             if (!grepl(pattern, name)) 
[13:35:06.126]                               next
[13:35:06.126]                             invokeRestart(restart)
[13:35:06.126]                             muffled <- TRUE
[13:35:06.126]                             break
[13:35:06.126]                           }
[13:35:06.126]                         }
[13:35:06.126]                       }
[13:35:06.126]                       invisible(muffled)
[13:35:06.126]                     }
[13:35:06.126]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.126]                   }
[13:35:06.126]                 }
[13:35:06.126]             }
[13:35:06.126]         }))
[13:35:06.126]     }, error = function(ex) {
[13:35:06.126]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.126]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.126]                 ...future.rng), started = ...future.startTime, 
[13:35:06.126]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.126]             version = "1.8"), class = "FutureResult")
[13:35:06.126]     }, finally = {
[13:35:06.126]         if (!identical(...future.workdir, getwd())) 
[13:35:06.126]             setwd(...future.workdir)
[13:35:06.126]         {
[13:35:06.126]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.126]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.126]             }
[13:35:06.126]             base::options(...future.oldOptions)
[13:35:06.126]             if (.Platform$OS.type == "windows") {
[13:35:06.126]                 old_names <- names(...future.oldEnvVars)
[13:35:06.126]                 envs <- base::Sys.getenv()
[13:35:06.126]                 names <- names(envs)
[13:35:06.126]                 common <- intersect(names, old_names)
[13:35:06.126]                 added <- setdiff(names, old_names)
[13:35:06.126]                 removed <- setdiff(old_names, names)
[13:35:06.126]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.126]                   envs[common]]
[13:35:06.126]                 NAMES <- toupper(changed)
[13:35:06.126]                 args <- list()
[13:35:06.126]                 for (kk in seq_along(NAMES)) {
[13:35:06.126]                   name <- changed[[kk]]
[13:35:06.126]                   NAME <- NAMES[[kk]]
[13:35:06.126]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.126]                     next
[13:35:06.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.126]                 }
[13:35:06.126]                 NAMES <- toupper(added)
[13:35:06.126]                 for (kk in seq_along(NAMES)) {
[13:35:06.126]                   name <- added[[kk]]
[13:35:06.126]                   NAME <- NAMES[[kk]]
[13:35:06.126]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.126]                     next
[13:35:06.126]                   args[[name]] <- ""
[13:35:06.126]                 }
[13:35:06.126]                 NAMES <- toupper(removed)
[13:35:06.126]                 for (kk in seq_along(NAMES)) {
[13:35:06.126]                   name <- removed[[kk]]
[13:35:06.126]                   NAME <- NAMES[[kk]]
[13:35:06.126]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.126]                     next
[13:35:06.126]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.126]                 }
[13:35:06.126]                 if (length(args) > 0) 
[13:35:06.126]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.126]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.126]             }
[13:35:06.126]             else {
[13:35:06.126]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.126]             }
[13:35:06.126]             {
[13:35:06.126]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.126]                   0L) {
[13:35:06.126]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.126]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.126]                   base::options(opts)
[13:35:06.126]                 }
[13:35:06.126]                 {
[13:35:06.126]                   {
[13:35:06.126]                     NULL
[13:35:06.126]                     RNGkind("Mersenne-Twister")
[13:35:06.126]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:06.126]                       inherits = FALSE)
[13:35:06.126]                   }
[13:35:06.126]                   options(future.plan = NULL)
[13:35:06.126]                   if (is.na(NA_character_)) 
[13:35:06.126]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.126]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.126]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.126]                     .init = FALSE)
[13:35:06.126]                 }
[13:35:06.126]             }
[13:35:06.126]         }
[13:35:06.126]     })
[13:35:06.126]     if (TRUE) {
[13:35:06.126]         base::sink(type = "output", split = FALSE)
[13:35:06.126]         if (TRUE) {
[13:35:06.126]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.126]         }
[13:35:06.126]         else {
[13:35:06.126]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.126]         }
[13:35:06.126]         base::close(...future.stdout)
[13:35:06.126]         ...future.stdout <- NULL
[13:35:06.126]     }
[13:35:06.126]     ...future.result$conditions <- ...future.conditions
[13:35:06.126]     ...future.result$finished <- base::Sys.time()
[13:35:06.126]     ...future.result
[13:35:06.126] }
[13:35:06.128] assign_globals() ...
[13:35:06.128] List of 11
[13:35:06.128]  $ ...future.FUN            :function (x, ...)  
[13:35:06.128]  $ x_FUN                    :function (x)  
[13:35:06.128]  $ times                    : int 4
[13:35:06.128]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.128]  $ stop_if_not              :function (...)  
[13:35:06.128]  $ dim                      : int [1:2] 2 2
[13:35:06.128]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:06.128]  $ future.call.arguments    : list()
[13:35:06.128]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.128]  $ ...future.elements_ii    :List of 10
[13:35:06.128]   ..$ : int 1
[13:35:06.128]   ..$ : int 2
[13:35:06.128]   ..$ : int 3
[13:35:06.128]   ..$ : int 4
[13:35:06.128]   ..$ : int 5
[13:35:06.128]   ..$ : int 6
[13:35:06.128]   ..$ : int 7
[13:35:06.128]   ..$ : int 8
[13:35:06.128]   ..$ : int 9
[13:35:06.128]   ..$ : int 10
[13:35:06.128]  $ ...future.seeds_ii       : NULL
[13:35:06.128]  $ ...future.globals.maxSize: NULL
[13:35:06.128]  - attr(*, "where")=List of 11
[13:35:06.128]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.128]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.128]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.128]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.128]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.128]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.128]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.128]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.128]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.128]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.128]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.128]  - attr(*, "resolved")= logi FALSE
[13:35:06.128]  - attr(*, "total_size")= num 105552
[13:35:06.128]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.128]  - attr(*, "already-done")= logi TRUE
[13:35:06.139] - copied ‘...future.FUN’ to environment
[13:35:06.139] - reassign environment for ‘x_FUN’
[13:35:06.139] - copied ‘x_FUN’ to environment
[13:35:06.139] - copied ‘times’ to environment
[13:35:06.139] - copied ‘stopf’ to environment
[13:35:06.139] - copied ‘stop_if_not’ to environment
[13:35:06.139] - copied ‘dim’ to environment
[13:35:06.139] - copied ‘valid_types’ to environment
[13:35:06.139] - copied ‘future.call.arguments’ to environment
[13:35:06.140] - copied ‘...future.elements_ii’ to environment
[13:35:06.140] - copied ‘...future.seeds_ii’ to environment
[13:35:06.140] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.140] assign_globals() ... done
[13:35:06.140] plan(): Setting new future strategy stack:
[13:35:06.140] List of future strategies:
[13:35:06.140] 1. sequential:
[13:35:06.140]    - args: function (..., envir = parent.frame())
[13:35:06.140]    - tweaked: FALSE
[13:35:06.140]    - call: NULL
[13:35:06.141] plan(): nbrOfWorkers() = 1
[13:35:06.141] plan(): Setting new future strategy stack:
[13:35:06.141] List of future strategies:
[13:35:06.141] 1. sequential:
[13:35:06.141]    - args: function (..., envir = parent.frame())
[13:35:06.141]    - tweaked: FALSE
[13:35:06.141]    - call: plan(strategy)
[13:35:06.142] plan(): nbrOfWorkers() = 1
[13:35:06.142] SequentialFuture started (and completed)
[13:35:06.142] - Launch lazy future ... done
[13:35:06.142] run() for ‘SequentialFuture’ ... done
[13:35:06.142] Created future:
[13:35:06.142] SequentialFuture:
[13:35:06.142] Label: ‘future_vapply-1’
[13:35:06.142] Expression:
[13:35:06.142] {
[13:35:06.142]     do.call(function(...) {
[13:35:06.142]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.142]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.142]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.142]             on.exit(options(oopts), add = TRUE)
[13:35:06.142]         }
[13:35:06.142]         {
[13:35:06.142]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.142]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.142]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.142]             })
[13:35:06.142]         }
[13:35:06.142]     }, args = future.call.arguments)
[13:35:06.142] }
[13:35:06.142] Lazy evaluation: FALSE
[13:35:06.142] Asynchronous evaluation: FALSE
[13:35:06.142] Local evaluation: TRUE
[13:35:06.142] Environment: R_GlobalEnv
[13:35:06.142] Capture standard output: TRUE
[13:35:06.142] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.142] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.142] Packages: 1 packages (‘future.apply’)
[13:35:06.142] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.142] Resolved: TRUE
[13:35:06.142] Value: 7.42 KiB of class ‘list’
[13:35:06.142] Early signaling: FALSE
[13:35:06.142] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.142] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.143] Chunk #1 of 1 ... DONE
[13:35:06.144] Launching 1 futures (chunks) ... DONE
[13:35:06.144] Resolving 1 futures (chunks) ...
[13:35:06.144] resolve() on list ...
[13:35:06.144]  recursive: 0
[13:35:06.144]  length: 1
[13:35:06.144] 
[13:35:06.144] resolved() for ‘SequentialFuture’ ...
[13:35:06.144] - state: ‘finished’
[13:35:06.144] - run: TRUE
[13:35:06.144] - result: ‘FutureResult’
[13:35:06.144] resolved() for ‘SequentialFuture’ ... done
[13:35:06.145] Future #1
[13:35:06.145] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:06.145] - nx: 1
[13:35:06.145] - relay: TRUE
[13:35:06.145] - stdout: TRUE
[13:35:06.145] - signal: TRUE
[13:35:06.145] - resignal: FALSE
[13:35:06.145] - force: TRUE
[13:35:06.145] - relayed: [n=1] FALSE
[13:35:06.145] - queued futures: [n=1] FALSE
[13:35:06.145]  - until=1
[13:35:06.145]  - relaying element #1
[13:35:06.146] - relayed: [n=1] TRUE
[13:35:06.146] - queued futures: [n=1] TRUE
[13:35:06.146] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:06.146]  length: 0 (resolved future 1)
[13:35:06.146] Relaying remaining futures
[13:35:06.146] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.146] - nx: 1
[13:35:06.146] - relay: TRUE
[13:35:06.146] - stdout: TRUE
[13:35:06.146] - signal: TRUE
[13:35:06.146] - resignal: FALSE
[13:35:06.147] - force: TRUE
[13:35:06.147] - relayed: [n=1] TRUE
[13:35:06.147] - queued futures: [n=1] TRUE
 - flush all
[13:35:06.147] - relayed: [n=1] TRUE
[13:35:06.147] - queued futures: [n=1] TRUE
[13:35:06.147] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.147] resolve() on list ... DONE
[13:35:06.147]  - Number of value chunks collected: 1
[13:35:06.147] Resolving 1 futures (chunks) ... DONE
[13:35:06.147] Reducing values from 1 chunks ...
[13:35:06.148]  - Number of values collected after concatenation: 10
[13:35:06.148]  - Number of values expected: 10
[13:35:06.148] Reducing values from 1 chunks ... DONE
[13:35:06.148] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[13:35:06.151] future_lapply() ...
[13:35:06.153] Number of chunks: 1
[13:35:06.153] getGlobalsAndPackagesXApply() ...
[13:35:06.153]  - future.globals: TRUE
[13:35:06.154] getGlobalsAndPackages() ...
[13:35:06.154] Searching for globals...
[13:35:06.157] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[13:35:06.158] Searching for globals ... DONE
[13:35:06.158] Resolving globals: FALSE
[13:35:06.158] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[13:35:06.159] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:06.159] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.159] - packages: [2] ‘stats’, ‘future.apply’
[13:35:06.159] getGlobalsAndPackages() ... DONE
[13:35:06.159]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.159]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:35:06.159] Finding globals ... DONE
[13:35:06.160]  - use_args: TRUE
[13:35:06.160]  - Getting '...' globals ...
[13:35:06.160] resolve() on list ...
[13:35:06.160]  recursive: 0
[13:35:06.160]  length: 1
[13:35:06.160]  elements: ‘...’
[13:35:06.160]  length: 0 (resolved future 1)
[13:35:06.160] resolve() on list ... DONE
[13:35:06.161]    - '...' content: [n=0] 
[13:35:06.161] List of 1
[13:35:06.161]  $ ...: list()
[13:35:06.161]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.161]  - attr(*, "where")=List of 1
[13:35:06.161]   ..$ ...:<environment: 0x5574d0c256e0> 
[13:35:06.161]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.161]  - attr(*, "resolved")= logi TRUE
[13:35:06.161]  - attr(*, "total_size")= num NA
[13:35:06.163]  - Getting '...' globals ... DONE
[13:35:06.163] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:06.163] List of 8
[13:35:06.163]  $ ...future.FUN:function (x, ...)  
[13:35:06.163]  $ x_FUN        :function (x, ...)  
[13:35:06.163]  $ times        : int 5
[13:35:06.163]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.163]  $ stop_if_not  :function (...)  
[13:35:06.163]  $ dim          : NULL
[13:35:06.163]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:06.163]  $ ...          : list()
[13:35:06.163]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.163]  - attr(*, "where")=List of 8
[13:35:06.163]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.163]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:06.163]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:06.163]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:06.163]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:06.163]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:06.163]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:06.163]   ..$ ...          :<environment: 0x5574d0c256e0> 
[13:35:06.163]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.163]  - attr(*, "resolved")= logi FALSE
[13:35:06.163]  - attr(*, "total_size")= num 95528
[13:35:06.168] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:35:06.168] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.169] Number of futures (= number of chunks): 1
[13:35:06.169] Launching 1 futures (chunks) ...
[13:35:06.169] Chunk #1 of 1 ...
[13:35:06.169]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.169] getGlobalsAndPackages() ...
[13:35:06.169] Searching for globals...
[13:35:06.169] 
[13:35:06.169] Searching for globals ... DONE
[13:35:06.169] - globals: [0] <none>
[13:35:06.170] getGlobalsAndPackages() ... DONE
[13:35:06.170]    + additional globals found: [n=0] 
[13:35:06.170]    + additional namespaces needed: [n=0] 
[13:35:06.170]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.170]  - seeds: <none>
[13:35:06.170]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.170] getGlobalsAndPackages() ...
[13:35:06.170] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.170] Resolving globals: FALSE
[13:35:06.170] Tweak future expression to call with '...' arguments ...
[13:35:06.171] {
[13:35:06.171]     do.call(function(...) {
[13:35:06.171]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.171]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.171]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.171]             on.exit(options(oopts), add = TRUE)
[13:35:06.171]         }
[13:35:06.171]         {
[13:35:06.171]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.171]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.171]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.171]             })
[13:35:06.171]         }
[13:35:06.171]     }, args = future.call.arguments)
[13:35:06.171] }
[13:35:06.171] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.171] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.171] - packages: [2] ‘stats’, ‘future.apply’
[13:35:06.171] getGlobalsAndPackages() ... DONE
[13:35:06.172] run() for ‘Future’ ...
[13:35:06.172] - state: ‘created’
[13:35:06.172] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:06.172] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.172] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:06.172]   - Field: ‘label’
[13:35:06.173]   - Field: ‘local’
[13:35:06.173]   - Field: ‘owner’
[13:35:06.173]   - Field: ‘envir’
[13:35:06.173]   - Field: ‘packages’
[13:35:06.173]   - Field: ‘gc’
[13:35:06.173]   - Field: ‘conditions’
[13:35:06.173]   - Field: ‘expr’
[13:35:06.173]   - Field: ‘uuid’
[13:35:06.173]   - Field: ‘seed’
[13:35:06.173]   - Field: ‘version’
[13:35:06.173]   - Field: ‘result’
[13:35:06.173]   - Field: ‘asynchronous’
[13:35:06.175]   - Field: ‘calls’
[13:35:06.175]   - Field: ‘globals’
[13:35:06.175]   - Field: ‘stdout’
[13:35:06.175]   - Field: ‘earlySignal’
[13:35:06.175]   - Field: ‘lazy’
[13:35:06.175]   - Field: ‘state’
[13:35:06.175] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:06.175] - Launch lazy future ...
[13:35:06.175] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:35:06.175] Packages needed by future strategies (n = 0): <none>
[13:35:06.176] {
[13:35:06.176]     {
[13:35:06.176]         {
[13:35:06.176]             ...future.startTime <- base::Sys.time()
[13:35:06.176]             {
[13:35:06.176]                 {
[13:35:06.176]                   {
[13:35:06.176]                     {
[13:35:06.176]                       base::local({
[13:35:06.176]                         has_future <- base::requireNamespace("future", 
[13:35:06.176]                           quietly = TRUE)
[13:35:06.176]                         if (has_future) {
[13:35:06.176]                           ns <- base::getNamespace("future")
[13:35:06.176]                           version <- ns[[".package"]][["version"]]
[13:35:06.176]                           if (is.null(version)) 
[13:35:06.176]                             version <- utils::packageVersion("future")
[13:35:06.176]                         }
[13:35:06.176]                         else {
[13:35:06.176]                           version <- NULL
[13:35:06.176]                         }
[13:35:06.176]                         if (!has_future || version < "1.8.0") {
[13:35:06.176]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.176]                             "", base::R.version$version.string), 
[13:35:06.176]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:06.176]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:06.176]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.176]                               "release", "version")], collapse = " "), 
[13:35:06.176]                             hostname = base::Sys.info()[["nodename"]])
[13:35:06.176]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.176]                             info)
[13:35:06.176]                           info <- base::paste(info, collapse = "; ")
[13:35:06.176]                           if (!has_future) {
[13:35:06.176]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.176]                               info)
[13:35:06.176]                           }
[13:35:06.176]                           else {
[13:35:06.176]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.176]                               info, version)
[13:35:06.176]                           }
[13:35:06.176]                           base::stop(msg)
[13:35:06.176]                         }
[13:35:06.176]                       })
[13:35:06.176]                     }
[13:35:06.176]                     base::local({
[13:35:06.176]                       for (pkg in c("stats", "future.apply")) {
[13:35:06.176]                         base::loadNamespace(pkg)
[13:35:06.176]                         base::library(pkg, character.only = TRUE)
[13:35:06.176]                       }
[13:35:06.176]                     })
[13:35:06.176]                   }
[13:35:06.176]                   ...future.strategy.old <- future::plan("list")
[13:35:06.176]                   options(future.plan = NULL)
[13:35:06.176]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.176]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.176]                 }
[13:35:06.176]                 ...future.workdir <- getwd()
[13:35:06.176]             }
[13:35:06.176]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.176]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.176]         }
[13:35:06.176]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.176]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:06.176]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.176]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.176]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.176]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.176]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.176]             base::names(...future.oldOptions))
[13:35:06.176]     }
[13:35:06.176]     if (FALSE) {
[13:35:06.176]     }
[13:35:06.176]     else {
[13:35:06.176]         if (TRUE) {
[13:35:06.176]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.176]                 open = "w")
[13:35:06.176]         }
[13:35:06.176]         else {
[13:35:06.176]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.176]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.176]         }
[13:35:06.176]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.176]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.176]             base::sink(type = "output", split = FALSE)
[13:35:06.176]             base::close(...future.stdout)
[13:35:06.176]         }, add = TRUE)
[13:35:06.176]     }
[13:35:06.176]     ...future.frame <- base::sys.nframe()
[13:35:06.176]     ...future.conditions <- base::list()
[13:35:06.176]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.176]     if (FALSE) {
[13:35:06.176]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.176]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.176]     }
[13:35:06.176]     ...future.result <- base::tryCatch({
[13:35:06.176]         base::withCallingHandlers({
[13:35:06.176]             ...future.value <- base::withVisible(base::local({
[13:35:06.176]                 do.call(function(...) {
[13:35:06.176]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.176]                   if (!identical(...future.globals.maxSize.org, 
[13:35:06.176]                     ...future.globals.maxSize)) {
[13:35:06.176]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.176]                     on.exit(options(oopts), add = TRUE)
[13:35:06.176]                   }
[13:35:06.176]                   {
[13:35:06.176]                     lapply(seq_along(...future.elements_ii), 
[13:35:06.176]                       FUN = function(jj) {
[13:35:06.176]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.176]                         ...future.FUN(...future.X_jj, ...)
[13:35:06.176]                       })
[13:35:06.176]                   }
[13:35:06.176]                 }, args = future.call.arguments)
[13:35:06.176]             }))
[13:35:06.176]             future::FutureResult(value = ...future.value$value, 
[13:35:06.176]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.176]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.176]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.176]                     ...future.globalenv.names))
[13:35:06.176]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.176]         }, condition = base::local({
[13:35:06.176]             c <- base::c
[13:35:06.176]             inherits <- base::inherits
[13:35:06.176]             invokeRestart <- base::invokeRestart
[13:35:06.176]             length <- base::length
[13:35:06.176]             list <- base::list
[13:35:06.176]             seq.int <- base::seq.int
[13:35:06.176]             signalCondition <- base::signalCondition
[13:35:06.176]             sys.calls <- base::sys.calls
[13:35:06.176]             `[[` <- base::`[[`
[13:35:06.176]             `+` <- base::`+`
[13:35:06.176]             `<<-` <- base::`<<-`
[13:35:06.176]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.176]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.176]                   3L)]
[13:35:06.176]             }
[13:35:06.176]             function(cond) {
[13:35:06.176]                 is_error <- inherits(cond, "error")
[13:35:06.176]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.176]                   NULL)
[13:35:06.176]                 if (is_error) {
[13:35:06.176]                   sessionInformation <- function() {
[13:35:06.176]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.176]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.176]                       search = base::search(), system = base::Sys.info())
[13:35:06.176]                   }
[13:35:06.176]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.176]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.176]                     cond$call), session = sessionInformation(), 
[13:35:06.176]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.176]                   signalCondition(cond)
[13:35:06.176]                 }
[13:35:06.176]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.176]                 "immediateCondition"))) {
[13:35:06.176]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.176]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.176]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.176]                   if (TRUE && !signal) {
[13:35:06.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.176]                     {
[13:35:06.176]                       inherits <- base::inherits
[13:35:06.176]                       invokeRestart <- base::invokeRestart
[13:35:06.176]                       is.null <- base::is.null
[13:35:06.176]                       muffled <- FALSE
[13:35:06.176]                       if (inherits(cond, "message")) {
[13:35:06.176]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.176]                         if (muffled) 
[13:35:06.176]                           invokeRestart("muffleMessage")
[13:35:06.176]                       }
[13:35:06.176]                       else if (inherits(cond, "warning")) {
[13:35:06.176]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.176]                         if (muffled) 
[13:35:06.176]                           invokeRestart("muffleWarning")
[13:35:06.176]                       }
[13:35:06.176]                       else if (inherits(cond, "condition")) {
[13:35:06.176]                         if (!is.null(pattern)) {
[13:35:06.176]                           computeRestarts <- base::computeRestarts
[13:35:06.176]                           grepl <- base::grepl
[13:35:06.176]                           restarts <- computeRestarts(cond)
[13:35:06.176]                           for (restart in restarts) {
[13:35:06.176]                             name <- restart$name
[13:35:06.176]                             if (is.null(name)) 
[13:35:06.176]                               next
[13:35:06.176]                             if (!grepl(pattern, name)) 
[13:35:06.176]                               next
[13:35:06.176]                             invokeRestart(restart)
[13:35:06.176]                             muffled <- TRUE
[13:35:06.176]                             break
[13:35:06.176]                           }
[13:35:06.176]                         }
[13:35:06.176]                       }
[13:35:06.176]                       invisible(muffled)
[13:35:06.176]                     }
[13:35:06.176]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.176]                   }
[13:35:06.176]                 }
[13:35:06.176]                 else {
[13:35:06.176]                   if (TRUE) {
[13:35:06.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.176]                     {
[13:35:06.176]                       inherits <- base::inherits
[13:35:06.176]                       invokeRestart <- base::invokeRestart
[13:35:06.176]                       is.null <- base::is.null
[13:35:06.176]                       muffled <- FALSE
[13:35:06.176]                       if (inherits(cond, "message")) {
[13:35:06.176]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.176]                         if (muffled) 
[13:35:06.176]                           invokeRestart("muffleMessage")
[13:35:06.176]                       }
[13:35:06.176]                       else if (inherits(cond, "warning")) {
[13:35:06.176]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.176]                         if (muffled) 
[13:35:06.176]                           invokeRestart("muffleWarning")
[13:35:06.176]                       }
[13:35:06.176]                       else if (inherits(cond, "condition")) {
[13:35:06.176]                         if (!is.null(pattern)) {
[13:35:06.176]                           computeRestarts <- base::computeRestarts
[13:35:06.176]                           grepl <- base::grepl
[13:35:06.176]                           restarts <- computeRestarts(cond)
[13:35:06.176]                           for (restart in restarts) {
[13:35:06.176]                             name <- restart$name
[13:35:06.176]                             if (is.null(name)) 
[13:35:06.176]                               next
[13:35:06.176]                             if (!grepl(pattern, name)) 
[13:35:06.176]                               next
[13:35:06.176]                             invokeRestart(restart)
[13:35:06.176]                             muffled <- TRUE
[13:35:06.176]                             break
[13:35:06.176]                           }
[13:35:06.176]                         }
[13:35:06.176]                       }
[13:35:06.176]                       invisible(muffled)
[13:35:06.176]                     }
[13:35:06.176]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.176]                   }
[13:35:06.176]                 }
[13:35:06.176]             }
[13:35:06.176]         }))
[13:35:06.176]     }, error = function(ex) {
[13:35:06.176]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.176]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.176]                 ...future.rng), started = ...future.startTime, 
[13:35:06.176]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.176]             version = "1.8"), class = "FutureResult")
[13:35:06.176]     }, finally = {
[13:35:06.176]         if (!identical(...future.workdir, getwd())) 
[13:35:06.176]             setwd(...future.workdir)
[13:35:06.176]         {
[13:35:06.176]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.176]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.176]             }
[13:35:06.176]             base::options(...future.oldOptions)
[13:35:06.176]             if (.Platform$OS.type == "windows") {
[13:35:06.176]                 old_names <- names(...future.oldEnvVars)
[13:35:06.176]                 envs <- base::Sys.getenv()
[13:35:06.176]                 names <- names(envs)
[13:35:06.176]                 common <- intersect(names, old_names)
[13:35:06.176]                 added <- setdiff(names, old_names)
[13:35:06.176]                 removed <- setdiff(old_names, names)
[13:35:06.176]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.176]                   envs[common]]
[13:35:06.176]                 NAMES <- toupper(changed)
[13:35:06.176]                 args <- list()
[13:35:06.176]                 for (kk in seq_along(NAMES)) {
[13:35:06.176]                   name <- changed[[kk]]
[13:35:06.176]                   NAME <- NAMES[[kk]]
[13:35:06.176]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.176]                     next
[13:35:06.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.176]                 }
[13:35:06.176]                 NAMES <- toupper(added)
[13:35:06.176]                 for (kk in seq_along(NAMES)) {
[13:35:06.176]                   name <- added[[kk]]
[13:35:06.176]                   NAME <- NAMES[[kk]]
[13:35:06.176]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.176]                     next
[13:35:06.176]                   args[[name]] <- ""
[13:35:06.176]                 }
[13:35:06.176]                 NAMES <- toupper(removed)
[13:35:06.176]                 for (kk in seq_along(NAMES)) {
[13:35:06.176]                   name <- removed[[kk]]
[13:35:06.176]                   NAME <- NAMES[[kk]]
[13:35:06.176]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.176]                     next
[13:35:06.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.176]                 }
[13:35:06.176]                 if (length(args) > 0) 
[13:35:06.176]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.176]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.176]             }
[13:35:06.176]             else {
[13:35:06.176]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.176]             }
[13:35:06.176]             {
[13:35:06.176]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.176]                   0L) {
[13:35:06.176]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.176]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.176]                   base::options(opts)
[13:35:06.176]                 }
[13:35:06.176]                 {
[13:35:06.176]                   {
[13:35:06.176]                     NULL
[13:35:06.176]                     RNGkind("Mersenne-Twister")
[13:35:06.176]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:06.176]                       inherits = FALSE)
[13:35:06.176]                   }
[13:35:06.176]                   options(future.plan = NULL)
[13:35:06.176]                   if (is.na(NA_character_)) 
[13:35:06.176]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.176]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.176]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.176]                     .init = FALSE)
[13:35:06.176]                 }
[13:35:06.176]             }
[13:35:06.176]         }
[13:35:06.176]     })
[13:35:06.176]     if (TRUE) {
[13:35:06.176]         base::sink(type = "output", split = FALSE)
[13:35:06.176]         if (TRUE) {
[13:35:06.176]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.176]         }
[13:35:06.176]         else {
[13:35:06.176]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.176]         }
[13:35:06.176]         base::close(...future.stdout)
[13:35:06.176]         ...future.stdout <- NULL
[13:35:06.176]     }
[13:35:06.176]     ...future.result$conditions <- ...future.conditions
[13:35:06.176]     ...future.result$finished <- base::Sys.time()
[13:35:06.176]     ...future.result
[13:35:06.176] }
[13:35:06.178] assign_globals() ...
[13:35:06.178] List of 11
[13:35:06.178]  $ ...future.FUN            :function (x, ...)  
[13:35:06.178]  $ x_FUN                    :function (x, ...)  
[13:35:06.178]  $ times                    : int 5
[13:35:06.178]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.178]  $ stop_if_not              :function (...)  
[13:35:06.178]  $ dim                      : NULL
[13:35:06.178]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:06.178]  $ future.call.arguments    : list()
[13:35:06.178]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.178]  $ ...future.elements_ii    :List of 3
[13:35:06.178]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:35:06.178]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:35:06.178]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:35:06.178]  $ ...future.seeds_ii       : NULL
[13:35:06.178]  $ ...future.globals.maxSize: NULL
[13:35:06.178]  - attr(*, "where")=List of 11
[13:35:06.178]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.178]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.178]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.178]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.178]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.178]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.178]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.178]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.178]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.178]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.178]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.178]  - attr(*, "resolved")= logi FALSE
[13:35:06.178]  - attr(*, "total_size")= num 95528
[13:35:06.178]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.178]  - attr(*, "already-done")= logi TRUE
[13:35:06.185] - copied ‘...future.FUN’ to environment
[13:35:06.185] - copied ‘x_FUN’ to environment
[13:35:06.185] - copied ‘times’ to environment
[13:35:06.186] - copied ‘stopf’ to environment
[13:35:06.186] - copied ‘stop_if_not’ to environment
[13:35:06.186] - copied ‘dim’ to environment
[13:35:06.186] - copied ‘valid_types’ to environment
[13:35:06.186] - copied ‘future.call.arguments’ to environment
[13:35:06.186] - copied ‘...future.elements_ii’ to environment
[13:35:06.186] - copied ‘...future.seeds_ii’ to environment
[13:35:06.186] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.186] assign_globals() ... done
[13:35:06.187] plan(): Setting new future strategy stack:
[13:35:06.187] List of future strategies:
[13:35:06.187] 1. sequential:
[13:35:06.187]    - args: function (..., envir = parent.frame())
[13:35:06.187]    - tweaked: FALSE
[13:35:06.187]    - call: NULL
[13:35:06.187] plan(): nbrOfWorkers() = 1
[13:35:06.188] plan(): Setting new future strategy stack:
[13:35:06.188] List of future strategies:
[13:35:06.188] 1. sequential:
[13:35:06.188]    - args: function (..., envir = parent.frame())
[13:35:06.188]    - tweaked: FALSE
[13:35:06.188]    - call: plan(strategy)
[13:35:06.189] plan(): nbrOfWorkers() = 1
[13:35:06.189] SequentialFuture started (and completed)
[13:35:06.189] - Launch lazy future ... done
[13:35:06.189] run() for ‘SequentialFuture’ ... done
[13:35:06.189] Created future:
[13:35:06.189] SequentialFuture:
[13:35:06.189] Label: ‘future_vapply-1’
[13:35:06.189] Expression:
[13:35:06.189] {
[13:35:06.189]     do.call(function(...) {
[13:35:06.189]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.189]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.189]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.189]             on.exit(options(oopts), add = TRUE)
[13:35:06.189]         }
[13:35:06.189]         {
[13:35:06.189]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.189]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.189]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.189]             })
[13:35:06.189]         }
[13:35:06.189]     }, args = future.call.arguments)
[13:35:06.189] }
[13:35:06.189] Lazy evaluation: FALSE
[13:35:06.189] Asynchronous evaluation: FALSE
[13:35:06.189] Local evaluation: TRUE
[13:35:06.189] Environment: R_GlobalEnv
[13:35:06.189] Capture standard output: TRUE
[13:35:06.189] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.189] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.189] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:35:06.189] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.189] Resolved: TRUE
[13:35:06.189] Value: 1.71 KiB of class ‘list’
[13:35:06.189] Early signaling: FALSE
[13:35:06.189] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.189] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.190] Chunk #1 of 1 ... DONE
[13:35:06.191] Launching 1 futures (chunks) ... DONE
[13:35:06.191] Resolving 1 futures (chunks) ...
[13:35:06.191] resolve() on list ...
[13:35:06.191]  recursive: 0
[13:35:06.191]  length: 1
[13:35:06.191] 
[13:35:06.191] resolved() for ‘SequentialFuture’ ...
[13:35:06.191] - state: ‘finished’
[13:35:06.191] - run: TRUE
[13:35:06.191] - result: ‘FutureResult’
[13:35:06.191] resolved() for ‘SequentialFuture’ ... done
[13:35:06.192] Future #1
[13:35:06.192] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:06.192] - nx: 1
[13:35:06.192] - relay: TRUE
[13:35:06.192] - stdout: TRUE
[13:35:06.192] - signal: TRUE
[13:35:06.192] - resignal: FALSE
[13:35:06.192] - force: TRUE
[13:35:06.192] - relayed: [n=1] FALSE
[13:35:06.192] - queued futures: [n=1] FALSE
[13:35:06.192]  - until=1
[13:35:06.192]  - relaying element #1
[13:35:06.193] - relayed: [n=1] TRUE
[13:35:06.193] - queued futures: [n=1] TRUE
[13:35:06.193] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:06.193]  length: 0 (resolved future 1)
[13:35:06.193] Relaying remaining futures
[13:35:06.193] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.193] - nx: 1
[13:35:06.193] - relay: TRUE
[13:35:06.193] - stdout: TRUE
[13:35:06.193] - signal: TRUE
[13:35:06.193] - resignal: FALSE
[13:35:06.194] - force: TRUE
[13:35:06.194] - relayed: [n=1] TRUE
[13:35:06.194] - queued futures: [n=1] TRUE
 - flush all
[13:35:06.194] - relayed: [n=1] TRUE
[13:35:06.194] - queued futures: [n=1] TRUE
[13:35:06.194] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.194] resolve() on list ... DONE
[13:35:06.194]  - Number of value chunks collected: 1
[13:35:06.194] Resolving 1 futures (chunks) ... DONE
[13:35:06.194] Reducing values from 1 chunks ...
[13:35:06.195]  - Number of values collected after concatenation: 3
[13:35:06.195]  - Number of values expected: 3
[13:35:06.195] Reducing values from 1 chunks ... DONE
[13:35:06.195] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[13:35:06.197] future_lapply() ...
[13:35:06.201] Number of chunks: 1
[13:35:06.201] getGlobalsAndPackagesXApply() ...
[13:35:06.201]  - future.globals: TRUE
[13:35:06.201] getGlobalsAndPackages() ...
[13:35:06.201] Searching for globals...
[13:35:06.206] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:35:06.206] Searching for globals ... DONE
[13:35:06.206] Resolving globals: FALSE
[13:35:06.207] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[13:35:06.207] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[13:35:06.207] - globals: [1] ‘FUN’
[13:35:06.207] - packages: [1] ‘stats’
[13:35:06.207] getGlobalsAndPackages() ... DONE
[13:35:06.207]  - globals found/used: [n=1] ‘FUN’
[13:35:06.207]  - needed namespaces: [n=1] ‘stats’
[13:35:06.208] Finding globals ... DONE
[13:35:06.208]  - use_args: TRUE
[13:35:06.208]  - Getting '...' globals ...
[13:35:06.208] resolve() on list ...
[13:35:06.208]  recursive: 0
[13:35:06.208]  length: 1
[13:35:06.208]  elements: ‘...’
[13:35:06.208]  length: 0 (resolved future 1)
[13:35:06.208] resolve() on list ... DONE
[13:35:06.209]    - '...' content: [n=0] 
[13:35:06.209] List of 1
[13:35:06.209]  $ ...: list()
[13:35:06.209]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.209]  - attr(*, "where")=List of 1
[13:35:06.209]   ..$ ...:<environment: 0x5574ce5de768> 
[13:35:06.209]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.209]  - attr(*, "resolved")= logi TRUE
[13:35:06.209]  - attr(*, "total_size")= num NA
[13:35:06.211]  - Getting '...' globals ... DONE
[13:35:06.211] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:06.211] List of 2
[13:35:06.211]  $ ...future.FUN:function (x, na.rm = TRUE)  
[13:35:06.211]  $ ...          : list()
[13:35:06.211]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.211]  - attr(*, "where")=List of 2
[13:35:06.211]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.211]   ..$ ...          :<environment: 0x5574ce5de768> 
[13:35:06.211]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.211]  - attr(*, "resolved")= logi FALSE
[13:35:06.211]  - attr(*, "total_size")= num 46960
[13:35:06.214] Packages to be attached in all futures: [n=1] ‘stats’
[13:35:06.214] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.214] Number of futures (= number of chunks): 1
[13:35:06.214] Launching 1 futures (chunks) ...
[13:35:06.214] Chunk #1 of 1 ...
[13:35:06.214]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.215] getGlobalsAndPackages() ...
[13:35:06.215] Searching for globals...
[13:35:06.215] 
[13:35:06.216] Searching for globals ... DONE
[13:35:06.216] - globals: [0] <none>
[13:35:06.216] getGlobalsAndPackages() ... DONE
[13:35:06.216]    + additional globals found: [n=0] 
[13:35:06.216]    + additional namespaces needed: [n=0] 
[13:35:06.216]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.216]  - seeds: <none>
[13:35:06.216]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.216] getGlobalsAndPackages() ...
[13:35:06.216] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.216] Resolving globals: FALSE
[13:35:06.217] Tweak future expression to call with '...' arguments ...
[13:35:06.217] {
[13:35:06.217]     do.call(function(...) {
[13:35:06.217]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.217]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.217]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.217]             on.exit(options(oopts), add = TRUE)
[13:35:06.217]         }
[13:35:06.217]         {
[13:35:06.217]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.217]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.217]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.217]             })
[13:35:06.217]         }
[13:35:06.217]     }, args = future.call.arguments)
[13:35:06.217] }
[13:35:06.217] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.217] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.217] - packages: [1] ‘stats’
[13:35:06.217] getGlobalsAndPackages() ... DONE
[13:35:06.218] run() for ‘Future’ ...
[13:35:06.218] - state: ‘created’
[13:35:06.218] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:06.218] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.218] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:06.219]   - Field: ‘label’
[13:35:06.219]   - Field: ‘local’
[13:35:06.219]   - Field: ‘owner’
[13:35:06.219]   - Field: ‘envir’
[13:35:06.219]   - Field: ‘packages’
[13:35:06.220]   - Field: ‘gc’
[13:35:06.220]   - Field: ‘conditions’
[13:35:06.220]   - Field: ‘expr’
[13:35:06.220]   - Field: ‘uuid’
[13:35:06.220]   - Field: ‘seed’
[13:35:06.220]   - Field: ‘version’
[13:35:06.220]   - Field: ‘result’
[13:35:06.220]   - Field: ‘asynchronous’
[13:35:06.220]   - Field: ‘calls’
[13:35:06.220]   - Field: ‘globals’
[13:35:06.220]   - Field: ‘stdout’
[13:35:06.221]   - Field: ‘earlySignal’
[13:35:06.221]   - Field: ‘lazy’
[13:35:06.221]   - Field: ‘state’
[13:35:06.221] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:06.221] - Launch lazy future ...
[13:35:06.221] Packages needed by the future expression (n = 1): ‘stats’
[13:35:06.221] Packages needed by future strategies (n = 0): <none>
[13:35:06.222] {
[13:35:06.222]     {
[13:35:06.222]         {
[13:35:06.222]             ...future.startTime <- base::Sys.time()
[13:35:06.222]             {
[13:35:06.222]                 {
[13:35:06.222]                   {
[13:35:06.222]                     {
[13:35:06.222]                       base::local({
[13:35:06.222]                         has_future <- base::requireNamespace("future", 
[13:35:06.222]                           quietly = TRUE)
[13:35:06.222]                         if (has_future) {
[13:35:06.222]                           ns <- base::getNamespace("future")
[13:35:06.222]                           version <- ns[[".package"]][["version"]]
[13:35:06.222]                           if (is.null(version)) 
[13:35:06.222]                             version <- utils::packageVersion("future")
[13:35:06.222]                         }
[13:35:06.222]                         else {
[13:35:06.222]                           version <- NULL
[13:35:06.222]                         }
[13:35:06.222]                         if (!has_future || version < "1.8.0") {
[13:35:06.222]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.222]                             "", base::R.version$version.string), 
[13:35:06.222]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:06.222]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:06.222]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.222]                               "release", "version")], collapse = " "), 
[13:35:06.222]                             hostname = base::Sys.info()[["nodename"]])
[13:35:06.222]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.222]                             info)
[13:35:06.222]                           info <- base::paste(info, collapse = "; ")
[13:35:06.222]                           if (!has_future) {
[13:35:06.222]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.222]                               info)
[13:35:06.222]                           }
[13:35:06.222]                           else {
[13:35:06.222]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.222]                               info, version)
[13:35:06.222]                           }
[13:35:06.222]                           base::stop(msg)
[13:35:06.222]                         }
[13:35:06.222]                       })
[13:35:06.222]                     }
[13:35:06.222]                     base::local({
[13:35:06.222]                       for (pkg in "stats") {
[13:35:06.222]                         base::loadNamespace(pkg)
[13:35:06.222]                         base::library(pkg, character.only = TRUE)
[13:35:06.222]                       }
[13:35:06.222]                     })
[13:35:06.222]                   }
[13:35:06.222]                   ...future.strategy.old <- future::plan("list")
[13:35:06.222]                   options(future.plan = NULL)
[13:35:06.222]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.222]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.222]                 }
[13:35:06.222]                 ...future.workdir <- getwd()
[13:35:06.222]             }
[13:35:06.222]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.222]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.222]         }
[13:35:06.222]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.222]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:06.222]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.222]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.222]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.222]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.222]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.222]             base::names(...future.oldOptions))
[13:35:06.222]     }
[13:35:06.222]     if (FALSE) {
[13:35:06.222]     }
[13:35:06.222]     else {
[13:35:06.222]         if (TRUE) {
[13:35:06.222]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.222]                 open = "w")
[13:35:06.222]         }
[13:35:06.222]         else {
[13:35:06.222]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.222]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.222]         }
[13:35:06.222]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.222]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.222]             base::sink(type = "output", split = FALSE)
[13:35:06.222]             base::close(...future.stdout)
[13:35:06.222]         }, add = TRUE)
[13:35:06.222]     }
[13:35:06.222]     ...future.frame <- base::sys.nframe()
[13:35:06.222]     ...future.conditions <- base::list()
[13:35:06.222]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.222]     if (FALSE) {
[13:35:06.222]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.222]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.222]     }
[13:35:06.222]     ...future.result <- base::tryCatch({
[13:35:06.222]         base::withCallingHandlers({
[13:35:06.222]             ...future.value <- base::withVisible(base::local({
[13:35:06.222]                 do.call(function(...) {
[13:35:06.222]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.222]                   if (!identical(...future.globals.maxSize.org, 
[13:35:06.222]                     ...future.globals.maxSize)) {
[13:35:06.222]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.222]                     on.exit(options(oopts), add = TRUE)
[13:35:06.222]                   }
[13:35:06.222]                   {
[13:35:06.222]                     lapply(seq_along(...future.elements_ii), 
[13:35:06.222]                       FUN = function(jj) {
[13:35:06.222]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.222]                         ...future.FUN(...future.X_jj, ...)
[13:35:06.222]                       })
[13:35:06.222]                   }
[13:35:06.222]                 }, args = future.call.arguments)
[13:35:06.222]             }))
[13:35:06.222]             future::FutureResult(value = ...future.value$value, 
[13:35:06.222]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.222]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.222]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.222]                     ...future.globalenv.names))
[13:35:06.222]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.222]         }, condition = base::local({
[13:35:06.222]             c <- base::c
[13:35:06.222]             inherits <- base::inherits
[13:35:06.222]             invokeRestart <- base::invokeRestart
[13:35:06.222]             length <- base::length
[13:35:06.222]             list <- base::list
[13:35:06.222]             seq.int <- base::seq.int
[13:35:06.222]             signalCondition <- base::signalCondition
[13:35:06.222]             sys.calls <- base::sys.calls
[13:35:06.222]             `[[` <- base::`[[`
[13:35:06.222]             `+` <- base::`+`
[13:35:06.222]             `<<-` <- base::`<<-`
[13:35:06.222]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.222]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.222]                   3L)]
[13:35:06.222]             }
[13:35:06.222]             function(cond) {
[13:35:06.222]                 is_error <- inherits(cond, "error")
[13:35:06.222]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.222]                   NULL)
[13:35:06.222]                 if (is_error) {
[13:35:06.222]                   sessionInformation <- function() {
[13:35:06.222]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.222]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.222]                       search = base::search(), system = base::Sys.info())
[13:35:06.222]                   }
[13:35:06.222]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.222]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.222]                     cond$call), session = sessionInformation(), 
[13:35:06.222]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.222]                   signalCondition(cond)
[13:35:06.222]                 }
[13:35:06.222]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.222]                 "immediateCondition"))) {
[13:35:06.222]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.222]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.222]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.222]                   if (TRUE && !signal) {
[13:35:06.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.222]                     {
[13:35:06.222]                       inherits <- base::inherits
[13:35:06.222]                       invokeRestart <- base::invokeRestart
[13:35:06.222]                       is.null <- base::is.null
[13:35:06.222]                       muffled <- FALSE
[13:35:06.222]                       if (inherits(cond, "message")) {
[13:35:06.222]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.222]                         if (muffled) 
[13:35:06.222]                           invokeRestart("muffleMessage")
[13:35:06.222]                       }
[13:35:06.222]                       else if (inherits(cond, "warning")) {
[13:35:06.222]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.222]                         if (muffled) 
[13:35:06.222]                           invokeRestart("muffleWarning")
[13:35:06.222]                       }
[13:35:06.222]                       else if (inherits(cond, "condition")) {
[13:35:06.222]                         if (!is.null(pattern)) {
[13:35:06.222]                           computeRestarts <- base::computeRestarts
[13:35:06.222]                           grepl <- base::grepl
[13:35:06.222]                           restarts <- computeRestarts(cond)
[13:35:06.222]                           for (restart in restarts) {
[13:35:06.222]                             name <- restart$name
[13:35:06.222]                             if (is.null(name)) 
[13:35:06.222]                               next
[13:35:06.222]                             if (!grepl(pattern, name)) 
[13:35:06.222]                               next
[13:35:06.222]                             invokeRestart(restart)
[13:35:06.222]                             muffled <- TRUE
[13:35:06.222]                             break
[13:35:06.222]                           }
[13:35:06.222]                         }
[13:35:06.222]                       }
[13:35:06.222]                       invisible(muffled)
[13:35:06.222]                     }
[13:35:06.222]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.222]                   }
[13:35:06.222]                 }
[13:35:06.222]                 else {
[13:35:06.222]                   if (TRUE) {
[13:35:06.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.222]                     {
[13:35:06.222]                       inherits <- base::inherits
[13:35:06.222]                       invokeRestart <- base::invokeRestart
[13:35:06.222]                       is.null <- base::is.null
[13:35:06.222]                       muffled <- FALSE
[13:35:06.222]                       if (inherits(cond, "message")) {
[13:35:06.222]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.222]                         if (muffled) 
[13:35:06.222]                           invokeRestart("muffleMessage")
[13:35:06.222]                       }
[13:35:06.222]                       else if (inherits(cond, "warning")) {
[13:35:06.222]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.222]                         if (muffled) 
[13:35:06.222]                           invokeRestart("muffleWarning")
[13:35:06.222]                       }
[13:35:06.222]                       else if (inherits(cond, "condition")) {
[13:35:06.222]                         if (!is.null(pattern)) {
[13:35:06.222]                           computeRestarts <- base::computeRestarts
[13:35:06.222]                           grepl <- base::grepl
[13:35:06.222]                           restarts <- computeRestarts(cond)
[13:35:06.222]                           for (restart in restarts) {
[13:35:06.222]                             name <- restart$name
[13:35:06.222]                             if (is.null(name)) 
[13:35:06.222]                               next
[13:35:06.222]                             if (!grepl(pattern, name)) 
[13:35:06.222]                               next
[13:35:06.222]                             invokeRestart(restart)
[13:35:06.222]                             muffled <- TRUE
[13:35:06.222]                             break
[13:35:06.222]                           }
[13:35:06.222]                         }
[13:35:06.222]                       }
[13:35:06.222]                       invisible(muffled)
[13:35:06.222]                     }
[13:35:06.222]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.222]                   }
[13:35:06.222]                 }
[13:35:06.222]             }
[13:35:06.222]         }))
[13:35:06.222]     }, error = function(ex) {
[13:35:06.222]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.222]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.222]                 ...future.rng), started = ...future.startTime, 
[13:35:06.222]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.222]             version = "1.8"), class = "FutureResult")
[13:35:06.222]     }, finally = {
[13:35:06.222]         if (!identical(...future.workdir, getwd())) 
[13:35:06.222]             setwd(...future.workdir)
[13:35:06.222]         {
[13:35:06.222]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.222]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.222]             }
[13:35:06.222]             base::options(...future.oldOptions)
[13:35:06.222]             if (.Platform$OS.type == "windows") {
[13:35:06.222]                 old_names <- names(...future.oldEnvVars)
[13:35:06.222]                 envs <- base::Sys.getenv()
[13:35:06.222]                 names <- names(envs)
[13:35:06.222]                 common <- intersect(names, old_names)
[13:35:06.222]                 added <- setdiff(names, old_names)
[13:35:06.222]                 removed <- setdiff(old_names, names)
[13:35:06.222]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.222]                   envs[common]]
[13:35:06.222]                 NAMES <- toupper(changed)
[13:35:06.222]                 args <- list()
[13:35:06.222]                 for (kk in seq_along(NAMES)) {
[13:35:06.222]                   name <- changed[[kk]]
[13:35:06.222]                   NAME <- NAMES[[kk]]
[13:35:06.222]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.222]                     next
[13:35:06.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.222]                 }
[13:35:06.222]                 NAMES <- toupper(added)
[13:35:06.222]                 for (kk in seq_along(NAMES)) {
[13:35:06.222]                   name <- added[[kk]]
[13:35:06.222]                   NAME <- NAMES[[kk]]
[13:35:06.222]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.222]                     next
[13:35:06.222]                   args[[name]] <- ""
[13:35:06.222]                 }
[13:35:06.222]                 NAMES <- toupper(removed)
[13:35:06.222]                 for (kk in seq_along(NAMES)) {
[13:35:06.222]                   name <- removed[[kk]]
[13:35:06.222]                   NAME <- NAMES[[kk]]
[13:35:06.222]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.222]                     next
[13:35:06.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.222]                 }
[13:35:06.222]                 if (length(args) > 0) 
[13:35:06.222]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.222]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.222]             }
[13:35:06.222]             else {
[13:35:06.222]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.222]             }
[13:35:06.222]             {
[13:35:06.222]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.222]                   0L) {
[13:35:06.222]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.222]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.222]                   base::options(opts)
[13:35:06.222]                 }
[13:35:06.222]                 {
[13:35:06.222]                   {
[13:35:06.222]                     NULL
[13:35:06.222]                     RNGkind("Mersenne-Twister")
[13:35:06.222]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:06.222]                       inherits = FALSE)
[13:35:06.222]                   }
[13:35:06.222]                   options(future.plan = NULL)
[13:35:06.222]                   if (is.na(NA_character_)) 
[13:35:06.222]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.222]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.222]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.222]                     .init = FALSE)
[13:35:06.222]                 }
[13:35:06.222]             }
[13:35:06.222]         }
[13:35:06.222]     })
[13:35:06.222]     if (TRUE) {
[13:35:06.222]         base::sink(type = "output", split = FALSE)
[13:35:06.222]         if (TRUE) {
[13:35:06.222]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.222]         }
[13:35:06.222]         else {
[13:35:06.222]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.222]         }
[13:35:06.222]         base::close(...future.stdout)
[13:35:06.222]         ...future.stdout <- NULL
[13:35:06.222]     }
[13:35:06.222]     ...future.result$conditions <- ...future.conditions
[13:35:06.222]     ...future.result$finished <- base::Sys.time()
[13:35:06.222]     ...future.result
[13:35:06.222] }
[13:35:06.223] assign_globals() ...
[13:35:06.223] List of 5
[13:35:06.223]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[13:35:06.223]  $ future.call.arguments    : list()
[13:35:06.223]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.223]  $ ...future.elements_ii    :List of 7
[13:35:06.223]   ..$ : int [1:3] 1 2 3
[13:35:06.223]   ..$ : int [1:4] 1 2 3 4
[13:35:06.223]   ..$ : int [1:5] 1 2 3 4 5
[13:35:06.223]   ..$ : int [1:6] 1 2 3 4 5 6
[13:35:06.223]   ..$ : int [1:7] 1 2 3 4 5 6 7
[13:35:06.223]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[13:35:06.223]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[13:35:06.223]  $ ...future.seeds_ii       : NULL
[13:35:06.223]  $ ...future.globals.maxSize: NULL
[13:35:06.223]  - attr(*, "where")=List of 5
[13:35:06.223]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.223]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.223]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.223]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.223]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.223]  - attr(*, "resolved")= logi FALSE
[13:35:06.223]  - attr(*, "total_size")= num 46960
[13:35:06.223]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.223]  - attr(*, "already-done")= logi TRUE
[13:35:06.229] - copied ‘...future.FUN’ to environment
[13:35:06.229] - copied ‘future.call.arguments’ to environment
[13:35:06.230] - copied ‘...future.elements_ii’ to environment
[13:35:06.230] - copied ‘...future.seeds_ii’ to environment
[13:35:06.230] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.230] assign_globals() ... done
[13:35:06.230] plan(): Setting new future strategy stack:
[13:35:06.230] List of future strategies:
[13:35:06.230] 1. sequential:
[13:35:06.230]    - args: function (..., envir = parent.frame())
[13:35:06.230]    - tweaked: FALSE
[13:35:06.230]    - call: NULL
[13:35:06.231] plan(): nbrOfWorkers() = 1
[13:35:06.231] plan(): Setting new future strategy stack:
[13:35:06.231] List of future strategies:
[13:35:06.231] 1. sequential:
[13:35:06.231]    - args: function (..., envir = parent.frame())
[13:35:06.231]    - tweaked: FALSE
[13:35:06.231]    - call: plan(strategy)
[13:35:06.232] plan(): nbrOfWorkers() = 1
[13:35:06.232] SequentialFuture started (and completed)
[13:35:06.232] - Launch lazy future ... done
[13:35:06.232] run() for ‘SequentialFuture’ ... done
[13:35:06.232] Created future:
[13:35:06.232] SequentialFuture:
[13:35:06.232] Label: ‘future_sapply-1’
[13:35:06.232] Expression:
[13:35:06.232] {
[13:35:06.232]     do.call(function(...) {
[13:35:06.232]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.232]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.232]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.232]             on.exit(options(oopts), add = TRUE)
[13:35:06.232]         }
[13:35:06.232]         {
[13:35:06.232]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.232]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.232]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.232]             })
[13:35:06.232]         }
[13:35:06.232]     }, args = future.call.arguments)
[13:35:06.232] }
[13:35:06.232] Lazy evaluation: FALSE
[13:35:06.232] Asynchronous evaluation: FALSE
[13:35:06.232] Local evaluation: TRUE
[13:35:06.232] Environment: R_GlobalEnv
[13:35:06.232] Capture standard output: TRUE
[13:35:06.232] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.232] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:06.232] Packages: 1 packages (‘stats’)
[13:35:06.232] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.232] Resolved: TRUE
[13:35:06.232] Value: 672 bytes of class ‘list’
[13:35:06.232] Early signaling: FALSE
[13:35:06.232] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.232] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.233] Chunk #1 of 1 ... DONE
[13:35:06.233] Launching 1 futures (chunks) ... DONE
[13:35:06.233] Resolving 1 futures (chunks) ...
[13:35:06.234] resolve() on list ...
[13:35:06.234]  recursive: 0
[13:35:06.234]  length: 1
[13:35:06.234] 
[13:35:06.234] resolved() for ‘SequentialFuture’ ...
[13:35:06.234] - state: ‘finished’
[13:35:06.234] - run: TRUE
[13:35:06.234] - result: ‘FutureResult’
[13:35:06.234] resolved() for ‘SequentialFuture’ ... done
[13:35:06.234] Future #1
[13:35:06.235] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:06.235] - nx: 1
[13:35:06.235] - relay: TRUE
[13:35:06.235] - stdout: TRUE
[13:35:06.235] - signal: TRUE
[13:35:06.235] - resignal: FALSE
[13:35:06.235] - force: TRUE
[13:35:06.235] - relayed: [n=1] FALSE
[13:35:06.235] - queued futures: [n=1] FALSE
[13:35:06.235]  - until=1
[13:35:06.235]  - relaying element #1
[13:35:06.236] - relayed: [n=1] TRUE
[13:35:06.236] - queued futures: [n=1] TRUE
[13:35:06.236] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:06.236]  length: 0 (resolved future 1)
[13:35:06.236] Relaying remaining futures
[13:35:06.236] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.236] - nx: 1
[13:35:06.236] - relay: TRUE
[13:35:06.236] - stdout: TRUE
[13:35:06.236] - signal: TRUE
[13:35:06.236] - resignal: FALSE
[13:35:06.236] - force: TRUE
[13:35:06.237] - relayed: [n=1] TRUE
[13:35:06.237] - queued futures: [n=1] TRUE
 - flush all
[13:35:06.237] - relayed: [n=1] TRUE
[13:35:06.237] - queued futures: [n=1] TRUE
[13:35:06.237] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.238] resolve() on list ... DONE
[13:35:06.238]  - Number of value chunks collected: 1
[13:35:06.238] Resolving 1 futures (chunks) ... DONE
[13:35:06.238] Reducing values from 1 chunks ...
[13:35:06.238]  - Number of values collected after concatenation: 7
[13:35:06.238]  - Number of values expected: 7
[13:35:06.239] Reducing values from 1 chunks ... DONE
[13:35:06.239] future_lapply() ... DONE
[13:35:06.239] future_lapply() ...
[13:35:06.241] Number of chunks: 1
[13:35:06.241] getGlobalsAndPackagesXApply() ...
[13:35:06.241]  - future.globals: TRUE
[13:35:06.241] getGlobalsAndPackages() ...
[13:35:06.241] Searching for globals...
[13:35:06.247] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:35:06.248] Searching for globals ... DONE
[13:35:06.248] Resolving globals: FALSE
[13:35:06.249] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[13:35:06.249] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[13:35:06.249] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.249] - packages: [2] ‘stats’, ‘future.apply’
[13:35:06.249] getGlobalsAndPackages() ... DONE
[13:35:06.250]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.250]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:35:06.250] Finding globals ... DONE
[13:35:06.250]  - use_args: TRUE
[13:35:06.250]  - Getting '...' globals ...
[13:35:06.250] resolve() on list ...
[13:35:06.250]  recursive: 0
[13:35:06.250]  length: 1
[13:35:06.250]  elements: ‘...’
[13:35:06.251]  length: 0 (resolved future 1)
[13:35:06.251] resolve() on list ... DONE
[13:35:06.251]    - '...' content: [n=0] 
[13:35:06.251] List of 1
[13:35:06.251]  $ ...: list()
[13:35:06.251]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.251]  - attr(*, "where")=List of 1
[13:35:06.251]   ..$ ...:<environment: 0x5574d054f620> 
[13:35:06.251]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.251]  - attr(*, "resolved")= logi TRUE
[13:35:06.251]  - attr(*, "total_size")= num NA
[13:35:06.253]  - Getting '...' globals ... DONE
[13:35:06.253] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:06.253] List of 8
[13:35:06.253]  $ ...future.FUN:function (x, ...)  
[13:35:06.253]  $ x_FUN        :function (x, na.rm = TRUE)  
[13:35:06.253]  $ times        : int 5
[13:35:06.253]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.253]  $ stop_if_not  :function (...)  
[13:35:06.253]  $ dim          : NULL
[13:35:06.253]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:06.253]  $ ...          : list()
[13:35:06.253]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.253]  - attr(*, "where")=List of 8
[13:35:06.253]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.253]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:06.253]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:06.253]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:06.253]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:06.253]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:06.253]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:06.253]   ..$ ...          :<environment: 0x5574d054f620> 
[13:35:06.253]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.253]  - attr(*, "resolved")= logi FALSE
[13:35:06.253]  - attr(*, "total_size")= num 141240
[13:35:06.259] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:35:06.259] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.260] Number of futures (= number of chunks): 1
[13:35:06.260] Launching 1 futures (chunks) ...
[13:35:06.260] Chunk #1 of 1 ...
[13:35:06.260]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.260] getGlobalsAndPackages() ...
[13:35:06.260] Searching for globals...
[13:35:06.260] 
[13:35:06.260] Searching for globals ... DONE
[13:35:06.261] - globals: [0] <none>
[13:35:06.261] getGlobalsAndPackages() ... DONE
[13:35:06.261]    + additional globals found: [n=0] 
[13:35:06.261]    + additional namespaces needed: [n=0] 
[13:35:06.261]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.261]  - seeds: <none>
[13:35:06.261]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.261] getGlobalsAndPackages() ...
[13:35:06.261] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.261] Resolving globals: FALSE
[13:35:06.261] Tweak future expression to call with '...' arguments ...
[13:35:06.262] {
[13:35:06.262]     do.call(function(...) {
[13:35:06.262]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.262]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.262]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.262]             on.exit(options(oopts), add = TRUE)
[13:35:06.262]         }
[13:35:06.262]         {
[13:35:06.262]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.262]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.262]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.262]             })
[13:35:06.262]         }
[13:35:06.262]     }, args = future.call.arguments)
[13:35:06.262] }
[13:35:06.262] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.262] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.262] - packages: [2] ‘stats’, ‘future.apply’
[13:35:06.262] getGlobalsAndPackages() ... DONE
[13:35:06.263] run() for ‘Future’ ...
[13:35:06.263] - state: ‘created’
[13:35:06.263] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:06.263] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.263] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:06.263]   - Field: ‘label’
[13:35:06.264]   - Field: ‘local’
[13:35:06.264]   - Field: ‘owner’
[13:35:06.264]   - Field: ‘envir’
[13:35:06.264]   - Field: ‘packages’
[13:35:06.264]   - Field: ‘gc’
[13:35:06.264]   - Field: ‘conditions’
[13:35:06.264]   - Field: ‘expr’
[13:35:06.264]   - Field: ‘uuid’
[13:35:06.264]   - Field: ‘seed’
[13:35:06.264]   - Field: ‘version’
[13:35:06.264]   - Field: ‘result’
[13:35:06.264]   - Field: ‘asynchronous’
[13:35:06.265]   - Field: ‘calls’
[13:35:06.265]   - Field: ‘globals’
[13:35:06.265]   - Field: ‘stdout’
[13:35:06.265]   - Field: ‘earlySignal’
[13:35:06.265]   - Field: ‘lazy’
[13:35:06.265]   - Field: ‘state’
[13:35:06.265] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:06.265] - Launch lazy future ...
[13:35:06.265] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:35:06.265] Packages needed by future strategies (n = 0): <none>
[13:35:06.266] {
[13:35:06.266]     {
[13:35:06.266]         {
[13:35:06.266]             ...future.startTime <- base::Sys.time()
[13:35:06.266]             {
[13:35:06.266]                 {
[13:35:06.266]                   {
[13:35:06.266]                     {
[13:35:06.266]                       base::local({
[13:35:06.266]                         has_future <- base::requireNamespace("future", 
[13:35:06.266]                           quietly = TRUE)
[13:35:06.266]                         if (has_future) {
[13:35:06.266]                           ns <- base::getNamespace("future")
[13:35:06.266]                           version <- ns[[".package"]][["version"]]
[13:35:06.266]                           if (is.null(version)) 
[13:35:06.266]                             version <- utils::packageVersion("future")
[13:35:06.266]                         }
[13:35:06.266]                         else {
[13:35:06.266]                           version <- NULL
[13:35:06.266]                         }
[13:35:06.266]                         if (!has_future || version < "1.8.0") {
[13:35:06.266]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.266]                             "", base::R.version$version.string), 
[13:35:06.266]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:06.266]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:06.266]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.266]                               "release", "version")], collapse = " "), 
[13:35:06.266]                             hostname = base::Sys.info()[["nodename"]])
[13:35:06.266]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.266]                             info)
[13:35:06.266]                           info <- base::paste(info, collapse = "; ")
[13:35:06.266]                           if (!has_future) {
[13:35:06.266]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.266]                               info)
[13:35:06.266]                           }
[13:35:06.266]                           else {
[13:35:06.266]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.266]                               info, version)
[13:35:06.266]                           }
[13:35:06.266]                           base::stop(msg)
[13:35:06.266]                         }
[13:35:06.266]                       })
[13:35:06.266]                     }
[13:35:06.266]                     base::local({
[13:35:06.266]                       for (pkg in c("stats", "future.apply")) {
[13:35:06.266]                         base::loadNamespace(pkg)
[13:35:06.266]                         base::library(pkg, character.only = TRUE)
[13:35:06.266]                       }
[13:35:06.266]                     })
[13:35:06.266]                   }
[13:35:06.266]                   ...future.strategy.old <- future::plan("list")
[13:35:06.266]                   options(future.plan = NULL)
[13:35:06.266]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.266]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.266]                 }
[13:35:06.266]                 ...future.workdir <- getwd()
[13:35:06.266]             }
[13:35:06.266]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.266]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.266]         }
[13:35:06.266]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.266]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:06.266]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.266]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.266]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.266]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.266]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.266]             base::names(...future.oldOptions))
[13:35:06.266]     }
[13:35:06.266]     if (FALSE) {
[13:35:06.266]     }
[13:35:06.266]     else {
[13:35:06.266]         if (TRUE) {
[13:35:06.266]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.266]                 open = "w")
[13:35:06.266]         }
[13:35:06.266]         else {
[13:35:06.266]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.266]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.266]         }
[13:35:06.266]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.266]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.266]             base::sink(type = "output", split = FALSE)
[13:35:06.266]             base::close(...future.stdout)
[13:35:06.266]         }, add = TRUE)
[13:35:06.266]     }
[13:35:06.266]     ...future.frame <- base::sys.nframe()
[13:35:06.266]     ...future.conditions <- base::list()
[13:35:06.266]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.266]     if (FALSE) {
[13:35:06.266]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.266]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.266]     }
[13:35:06.266]     ...future.result <- base::tryCatch({
[13:35:06.266]         base::withCallingHandlers({
[13:35:06.266]             ...future.value <- base::withVisible(base::local({
[13:35:06.266]                 do.call(function(...) {
[13:35:06.266]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.266]                   if (!identical(...future.globals.maxSize.org, 
[13:35:06.266]                     ...future.globals.maxSize)) {
[13:35:06.266]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.266]                     on.exit(options(oopts), add = TRUE)
[13:35:06.266]                   }
[13:35:06.266]                   {
[13:35:06.266]                     lapply(seq_along(...future.elements_ii), 
[13:35:06.266]                       FUN = function(jj) {
[13:35:06.266]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.266]                         ...future.FUN(...future.X_jj, ...)
[13:35:06.266]                       })
[13:35:06.266]                   }
[13:35:06.266]                 }, args = future.call.arguments)
[13:35:06.266]             }))
[13:35:06.266]             future::FutureResult(value = ...future.value$value, 
[13:35:06.266]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.266]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.266]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.266]                     ...future.globalenv.names))
[13:35:06.266]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.266]         }, condition = base::local({
[13:35:06.266]             c <- base::c
[13:35:06.266]             inherits <- base::inherits
[13:35:06.266]             invokeRestart <- base::invokeRestart
[13:35:06.266]             length <- base::length
[13:35:06.266]             list <- base::list
[13:35:06.266]             seq.int <- base::seq.int
[13:35:06.266]             signalCondition <- base::signalCondition
[13:35:06.266]             sys.calls <- base::sys.calls
[13:35:06.266]             `[[` <- base::`[[`
[13:35:06.266]             `+` <- base::`+`
[13:35:06.266]             `<<-` <- base::`<<-`
[13:35:06.266]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.266]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.266]                   3L)]
[13:35:06.266]             }
[13:35:06.266]             function(cond) {
[13:35:06.266]                 is_error <- inherits(cond, "error")
[13:35:06.266]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.266]                   NULL)
[13:35:06.266]                 if (is_error) {
[13:35:06.266]                   sessionInformation <- function() {
[13:35:06.266]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.266]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.266]                       search = base::search(), system = base::Sys.info())
[13:35:06.266]                   }
[13:35:06.266]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.266]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.266]                     cond$call), session = sessionInformation(), 
[13:35:06.266]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.266]                   signalCondition(cond)
[13:35:06.266]                 }
[13:35:06.266]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.266]                 "immediateCondition"))) {
[13:35:06.266]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.266]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.266]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.266]                   if (TRUE && !signal) {
[13:35:06.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.266]                     {
[13:35:06.266]                       inherits <- base::inherits
[13:35:06.266]                       invokeRestart <- base::invokeRestart
[13:35:06.266]                       is.null <- base::is.null
[13:35:06.266]                       muffled <- FALSE
[13:35:06.266]                       if (inherits(cond, "message")) {
[13:35:06.266]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.266]                         if (muffled) 
[13:35:06.266]                           invokeRestart("muffleMessage")
[13:35:06.266]                       }
[13:35:06.266]                       else if (inherits(cond, "warning")) {
[13:35:06.266]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.266]                         if (muffled) 
[13:35:06.266]                           invokeRestart("muffleWarning")
[13:35:06.266]                       }
[13:35:06.266]                       else if (inherits(cond, "condition")) {
[13:35:06.266]                         if (!is.null(pattern)) {
[13:35:06.266]                           computeRestarts <- base::computeRestarts
[13:35:06.266]                           grepl <- base::grepl
[13:35:06.266]                           restarts <- computeRestarts(cond)
[13:35:06.266]                           for (restart in restarts) {
[13:35:06.266]                             name <- restart$name
[13:35:06.266]                             if (is.null(name)) 
[13:35:06.266]                               next
[13:35:06.266]                             if (!grepl(pattern, name)) 
[13:35:06.266]                               next
[13:35:06.266]                             invokeRestart(restart)
[13:35:06.266]                             muffled <- TRUE
[13:35:06.266]                             break
[13:35:06.266]                           }
[13:35:06.266]                         }
[13:35:06.266]                       }
[13:35:06.266]                       invisible(muffled)
[13:35:06.266]                     }
[13:35:06.266]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.266]                   }
[13:35:06.266]                 }
[13:35:06.266]                 else {
[13:35:06.266]                   if (TRUE) {
[13:35:06.266]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.266]                     {
[13:35:06.266]                       inherits <- base::inherits
[13:35:06.266]                       invokeRestart <- base::invokeRestart
[13:35:06.266]                       is.null <- base::is.null
[13:35:06.266]                       muffled <- FALSE
[13:35:06.266]                       if (inherits(cond, "message")) {
[13:35:06.266]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.266]                         if (muffled) 
[13:35:06.266]                           invokeRestart("muffleMessage")
[13:35:06.266]                       }
[13:35:06.266]                       else if (inherits(cond, "warning")) {
[13:35:06.266]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.266]                         if (muffled) 
[13:35:06.266]                           invokeRestart("muffleWarning")
[13:35:06.266]                       }
[13:35:06.266]                       else if (inherits(cond, "condition")) {
[13:35:06.266]                         if (!is.null(pattern)) {
[13:35:06.266]                           computeRestarts <- base::computeRestarts
[13:35:06.266]                           grepl <- base::grepl
[13:35:06.266]                           restarts <- computeRestarts(cond)
[13:35:06.266]                           for (restart in restarts) {
[13:35:06.266]                             name <- restart$name
[13:35:06.266]                             if (is.null(name)) 
[13:35:06.266]                               next
[13:35:06.266]                             if (!grepl(pattern, name)) 
[13:35:06.266]                               next
[13:35:06.266]                             invokeRestart(restart)
[13:35:06.266]                             muffled <- TRUE
[13:35:06.266]                             break
[13:35:06.266]                           }
[13:35:06.266]                         }
[13:35:06.266]                       }
[13:35:06.266]                       invisible(muffled)
[13:35:06.266]                     }
[13:35:06.266]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.266]                   }
[13:35:06.266]                 }
[13:35:06.266]             }
[13:35:06.266]         }))
[13:35:06.266]     }, error = function(ex) {
[13:35:06.266]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.266]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.266]                 ...future.rng), started = ...future.startTime, 
[13:35:06.266]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.266]             version = "1.8"), class = "FutureResult")
[13:35:06.266]     }, finally = {
[13:35:06.266]         if (!identical(...future.workdir, getwd())) 
[13:35:06.266]             setwd(...future.workdir)
[13:35:06.266]         {
[13:35:06.266]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.266]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.266]             }
[13:35:06.266]             base::options(...future.oldOptions)
[13:35:06.266]             if (.Platform$OS.type == "windows") {
[13:35:06.266]                 old_names <- names(...future.oldEnvVars)
[13:35:06.266]                 envs <- base::Sys.getenv()
[13:35:06.266]                 names <- names(envs)
[13:35:06.266]                 common <- intersect(names, old_names)
[13:35:06.266]                 added <- setdiff(names, old_names)
[13:35:06.266]                 removed <- setdiff(old_names, names)
[13:35:06.266]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.266]                   envs[common]]
[13:35:06.266]                 NAMES <- toupper(changed)
[13:35:06.266]                 args <- list()
[13:35:06.266]                 for (kk in seq_along(NAMES)) {
[13:35:06.266]                   name <- changed[[kk]]
[13:35:06.266]                   NAME <- NAMES[[kk]]
[13:35:06.266]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.266]                     next
[13:35:06.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.266]                 }
[13:35:06.266]                 NAMES <- toupper(added)
[13:35:06.266]                 for (kk in seq_along(NAMES)) {
[13:35:06.266]                   name <- added[[kk]]
[13:35:06.266]                   NAME <- NAMES[[kk]]
[13:35:06.266]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.266]                     next
[13:35:06.266]                   args[[name]] <- ""
[13:35:06.266]                 }
[13:35:06.266]                 NAMES <- toupper(removed)
[13:35:06.266]                 for (kk in seq_along(NAMES)) {
[13:35:06.266]                   name <- removed[[kk]]
[13:35:06.266]                   NAME <- NAMES[[kk]]
[13:35:06.266]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.266]                     next
[13:35:06.266]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.266]                 }
[13:35:06.266]                 if (length(args) > 0) 
[13:35:06.266]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.266]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.266]             }
[13:35:06.266]             else {
[13:35:06.266]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.266]             }
[13:35:06.266]             {
[13:35:06.266]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.266]                   0L) {
[13:35:06.266]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.266]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.266]                   base::options(opts)
[13:35:06.266]                 }
[13:35:06.266]                 {
[13:35:06.266]                   {
[13:35:06.266]                     NULL
[13:35:06.266]                     RNGkind("Mersenne-Twister")
[13:35:06.266]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:06.266]                       inherits = FALSE)
[13:35:06.266]                   }
[13:35:06.266]                   options(future.plan = NULL)
[13:35:06.266]                   if (is.na(NA_character_)) 
[13:35:06.266]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.266]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.266]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.266]                     .init = FALSE)
[13:35:06.266]                 }
[13:35:06.266]             }
[13:35:06.266]         }
[13:35:06.266]     })
[13:35:06.266]     if (TRUE) {
[13:35:06.266]         base::sink(type = "output", split = FALSE)
[13:35:06.266]         if (TRUE) {
[13:35:06.266]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.266]         }
[13:35:06.266]         else {
[13:35:06.266]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.266]         }
[13:35:06.266]         base::close(...future.stdout)
[13:35:06.266]         ...future.stdout <- NULL
[13:35:06.266]     }
[13:35:06.266]     ...future.result$conditions <- ...future.conditions
[13:35:06.266]     ...future.result$finished <- base::Sys.time()
[13:35:06.266]     ...future.result
[13:35:06.266] }
[13:35:06.268] assign_globals() ...
[13:35:06.268] List of 11
[13:35:06.268]  $ ...future.FUN            :function (x, ...)  
[13:35:06.268]  $ x_FUN                    :function (x, na.rm = TRUE)  
[13:35:06.268]  $ times                    : int 5
[13:35:06.268]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.268]  $ stop_if_not              :function (...)  
[13:35:06.268]  $ dim                      : NULL
[13:35:06.268]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:06.268]  $ future.call.arguments    : list()
[13:35:06.268]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.268]  $ ...future.elements_ii    :List of 7
[13:35:06.268]   ..$ : int [1:3] 1 2 3
[13:35:06.268]   ..$ : int [1:4] 1 2 3 4
[13:35:06.268]   ..$ : int [1:5] 1 2 3 4 5
[13:35:06.268]   ..$ : int [1:6] 1 2 3 4 5 6
[13:35:06.268]   ..$ : int [1:7] 1 2 3 4 5 6 7
[13:35:06.268]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[13:35:06.268]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[13:35:06.268]  $ ...future.seeds_ii       : NULL
[13:35:06.268]  $ ...future.globals.maxSize: NULL
[13:35:06.268]  - attr(*, "where")=List of 11
[13:35:06.268]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.268]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.268]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.268]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.268]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.268]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.268]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.268]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.268]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.268]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.268]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.268]  - attr(*, "resolved")= logi FALSE
[13:35:06.268]  - attr(*, "total_size")= num 141240
[13:35:06.268]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.268]  - attr(*, "already-done")= logi TRUE
[13:35:06.277] - copied ‘...future.FUN’ to environment
[13:35:06.277] - copied ‘x_FUN’ to environment
[13:35:06.277] - copied ‘times’ to environment
[13:35:06.277] - copied ‘stopf’ to environment
[13:35:06.277] - copied ‘stop_if_not’ to environment
[13:35:06.277] - copied ‘dim’ to environment
[13:35:06.278] - copied ‘valid_types’ to environment
[13:35:06.278] - copied ‘future.call.arguments’ to environment
[13:35:06.278] - copied ‘...future.elements_ii’ to environment
[13:35:06.278] - copied ‘...future.seeds_ii’ to environment
[13:35:06.278] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.278] assign_globals() ... done
[13:35:06.278] plan(): Setting new future strategy stack:
[13:35:06.279] List of future strategies:
[13:35:06.279] 1. sequential:
[13:35:06.279]    - args: function (..., envir = parent.frame())
[13:35:06.279]    - tweaked: FALSE
[13:35:06.279]    - call: NULL
[13:35:06.279] plan(): nbrOfWorkers() = 1
[13:35:06.280] plan(): Setting new future strategy stack:
[13:35:06.280] List of future strategies:
[13:35:06.280] 1. sequential:
[13:35:06.280]    - args: function (..., envir = parent.frame())
[13:35:06.280]    - tweaked: FALSE
[13:35:06.280]    - call: plan(strategy)
[13:35:06.280] plan(): nbrOfWorkers() = 1
[13:35:06.280] SequentialFuture started (and completed)
[13:35:06.280] - Launch lazy future ... done
[13:35:06.280] run() for ‘SequentialFuture’ ... done
[13:35:06.281] Created future:
[13:35:06.281] SequentialFuture:
[13:35:06.281] Label: ‘future_vapply-1’
[13:35:06.281] Expression:
[13:35:06.281] {
[13:35:06.281]     do.call(function(...) {
[13:35:06.281]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.281]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.281]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.281]             on.exit(options(oopts), add = TRUE)
[13:35:06.281]         }
[13:35:06.281]         {
[13:35:06.281]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.281]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.281]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.281]             })
[13:35:06.281]         }
[13:35:06.281]     }, args = future.call.arguments)
[13:35:06.281] }
[13:35:06.281] Lazy evaluation: FALSE
[13:35:06.281] Asynchronous evaluation: FALSE
[13:35:06.281] Local evaluation: TRUE
[13:35:06.281] Environment: R_GlobalEnv
[13:35:06.281] Capture standard output: TRUE
[13:35:06.281] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.281] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.281] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:35:06.281] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.281] Resolved: TRUE
[13:35:06.281] Value: 672 bytes of class ‘list’
[13:35:06.281] Early signaling: FALSE
[13:35:06.281] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.281] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.282] Chunk #1 of 1 ... DONE
[13:35:06.282] Launching 1 futures (chunks) ... DONE
[13:35:06.282] Resolving 1 futures (chunks) ...
[13:35:06.282] resolve() on list ...
[13:35:06.282]  recursive: 0
[13:35:06.282]  length: 1
[13:35:06.282] 
[13:35:06.282] resolved() for ‘SequentialFuture’ ...
[13:35:06.282] - state: ‘finished’
[13:35:06.283] - run: TRUE
[13:35:06.283] - result: ‘FutureResult’
[13:35:06.283] resolved() for ‘SequentialFuture’ ... done
[13:35:06.283] Future #1
[13:35:06.283] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:06.283] - nx: 1
[13:35:06.283] - relay: TRUE
[13:35:06.283] - stdout: TRUE
[13:35:06.283] - signal: TRUE
[13:35:06.283] - resignal: FALSE
[13:35:06.283] - force: TRUE
[13:35:06.284] - relayed: [n=1] FALSE
[13:35:06.284] - queued futures: [n=1] FALSE
[13:35:06.284]  - until=1
[13:35:06.284]  - relaying element #1
[13:35:06.284] - relayed: [n=1] TRUE
[13:35:06.284] - queued futures: [n=1] TRUE
[13:35:06.284] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:06.284]  length: 0 (resolved future 1)
[13:35:06.284] Relaying remaining futures
[13:35:06.284] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.284] - nx: 1
[13:35:06.285] - relay: TRUE
[13:35:06.285] - stdout: TRUE
[13:35:06.285] - signal: TRUE
[13:35:06.285] - resignal: FALSE
[13:35:06.285] - force: TRUE
[13:35:06.285] - relayed: [n=1] TRUE
[13:35:06.285] - queued futures: [n=1] TRUE
 - flush all
[13:35:06.285] - relayed: [n=1] TRUE
[13:35:06.285] - queued futures: [n=1] TRUE
[13:35:06.285] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.285] resolve() on list ... DONE
[13:35:06.286]  - Number of value chunks collected: 1
[13:35:06.286] Resolving 1 futures (chunks) ... DONE
[13:35:06.286] Reducing values from 1 chunks ...
[13:35:06.286]  - Number of values collected after concatenation: 7
[13:35:06.286]  - Number of values expected: 7
[13:35:06.286] Reducing values from 1 chunks ... DONE
[13:35:06.286] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[13:35:06.287] future_lapply() ...
[13:35:06.288] Number of chunks: 1
[13:35:06.288] getGlobalsAndPackagesXApply() ...
[13:35:06.288]  - future.globals: TRUE
[13:35:06.288] getGlobalsAndPackages() ...
[13:35:06.288] Searching for globals...
[13:35:06.289] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[13:35:06.290] Searching for globals ... DONE
[13:35:06.290] Resolving globals: FALSE
[13:35:06.290] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[13:35:06.290] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[13:35:06.291] - globals: [1] ‘FUN’
[13:35:06.291] 
[13:35:06.291] getGlobalsAndPackages() ... DONE
[13:35:06.291]  - globals found/used: [n=1] ‘FUN’
[13:35:06.291]  - needed namespaces: [n=0] 
[13:35:06.291] Finding globals ... DONE
[13:35:06.291]  - use_args: TRUE
[13:35:06.291]  - Getting '...' globals ...
[13:35:06.291] resolve() on list ...
[13:35:06.292]  recursive: 0
[13:35:06.292]  length: 1
[13:35:06.292]  elements: ‘...’
[13:35:06.292]  length: 0 (resolved future 1)
[13:35:06.292] resolve() on list ... DONE
[13:35:06.292]    - '...' content: [n=1] ‘y’
[13:35:06.292] List of 1
[13:35:06.292]  $ ...:List of 1
[13:35:06.292]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:06.292]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.292]  - attr(*, "where")=List of 1
[13:35:06.292]   ..$ ...:<environment: 0x5574d061f6c0> 
[13:35:06.292]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.292]  - attr(*, "resolved")= logi TRUE
[13:35:06.292]  - attr(*, "total_size")= num NA
[13:35:06.295]  - Getting '...' globals ... DONE
[13:35:06.295] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:06.295] List of 2
[13:35:06.295]  $ ...future.FUN:function (x, y)  
[13:35:06.295]  $ ...          :List of 1
[13:35:06.295]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:06.295]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.295]  - attr(*, "where")=List of 2
[13:35:06.295]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.295]   ..$ ...          :<environment: 0x5574d061f6c0> 
[13:35:06.295]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.295]  - attr(*, "resolved")= logi FALSE
[13:35:06.295]  - attr(*, "total_size")= num 4264
[13:35:06.299] Packages to be attached in all futures: [n=0] 
[13:35:06.299] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.299] Number of futures (= number of chunks): 1
[13:35:06.299] Launching 1 futures (chunks) ...
[13:35:06.300] Chunk #1 of 1 ...
[13:35:06.300]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.300] getGlobalsAndPackages() ...
[13:35:06.300] Searching for globals...
[13:35:06.300] 
[13:35:06.300] Searching for globals ... DONE
[13:35:06.300] - globals: [0] <none>
[13:35:06.300] getGlobalsAndPackages() ... DONE
[13:35:06.300]    + additional globals found: [n=0] 
[13:35:06.300]    + additional namespaces needed: [n=0] 
[13:35:06.301]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.301]  - seeds: <none>
[13:35:06.301]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.301] getGlobalsAndPackages() ...
[13:35:06.301] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.301] Resolving globals: FALSE
[13:35:06.301] Tweak future expression to call with '...' arguments ...
[13:35:06.301] {
[13:35:06.301]     do.call(function(...) {
[13:35:06.301]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.301]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.301]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.301]             on.exit(options(oopts), add = TRUE)
[13:35:06.301]         }
[13:35:06.301]         {
[13:35:06.301]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.301]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.301]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.301]             })
[13:35:06.301]         }
[13:35:06.301]     }, args = future.call.arguments)
[13:35:06.301] }
[13:35:06.302] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.302] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.302] 
[13:35:06.302] getGlobalsAndPackages() ... DONE
[13:35:06.302] run() for ‘Future’ ...
[13:35:06.302] - state: ‘created’
[13:35:06.303] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:06.303] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.303] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:06.303]   - Field: ‘label’
[13:35:06.303]   - Field: ‘local’
[13:35:06.303]   - Field: ‘owner’
[13:35:06.303]   - Field: ‘envir’
[13:35:06.303]   - Field: ‘packages’
[13:35:06.303]   - Field: ‘gc’
[13:35:06.304]   - Field: ‘conditions’
[13:35:06.304]   - Field: ‘expr’
[13:35:06.304]   - Field: ‘uuid’
[13:35:06.304]   - Field: ‘seed’
[13:35:06.304]   - Field: ‘version’
[13:35:06.304]   - Field: ‘result’
[13:35:06.304]   - Field: ‘asynchronous’
[13:35:06.304]   - Field: ‘calls’
[13:35:06.304]   - Field: ‘globals’
[13:35:06.304]   - Field: ‘stdout’
[13:35:06.304]   - Field: ‘earlySignal’
[13:35:06.304]   - Field: ‘lazy’
[13:35:06.305]   - Field: ‘state’
[13:35:06.305] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:06.305] - Launch lazy future ...
[13:35:06.305] Packages needed by the future expression (n = 0): <none>
[13:35:06.305] Packages needed by future strategies (n = 0): <none>
[13:35:06.305] {
[13:35:06.305]     {
[13:35:06.305]         {
[13:35:06.305]             ...future.startTime <- base::Sys.time()
[13:35:06.305]             {
[13:35:06.305]                 {
[13:35:06.305]                   {
[13:35:06.305]                     base::local({
[13:35:06.305]                       has_future <- base::requireNamespace("future", 
[13:35:06.305]                         quietly = TRUE)
[13:35:06.305]                       if (has_future) {
[13:35:06.305]                         ns <- base::getNamespace("future")
[13:35:06.305]                         version <- ns[[".package"]][["version"]]
[13:35:06.305]                         if (is.null(version)) 
[13:35:06.305]                           version <- utils::packageVersion("future")
[13:35:06.305]                       }
[13:35:06.305]                       else {
[13:35:06.305]                         version <- NULL
[13:35:06.305]                       }
[13:35:06.305]                       if (!has_future || version < "1.8.0") {
[13:35:06.305]                         info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.305]                           "", base::R.version$version.string), 
[13:35:06.305]                           platform = base::sprintf("%s (%s-bit)", 
[13:35:06.305]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:06.305]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.305]                             "release", "version")], collapse = " "), 
[13:35:06.305]                           hostname = base::Sys.info()[["nodename"]])
[13:35:06.305]                         info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.305]                           info)
[13:35:06.305]                         info <- base::paste(info, collapse = "; ")
[13:35:06.305]                         if (!has_future) {
[13:35:06.305]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.305]                             info)
[13:35:06.305]                         }
[13:35:06.305]                         else {
[13:35:06.305]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.305]                             info, version)
[13:35:06.305]                         }
[13:35:06.305]                         base::stop(msg)
[13:35:06.305]                       }
[13:35:06.305]                     })
[13:35:06.305]                   }
[13:35:06.305]                   ...future.strategy.old <- future::plan("list")
[13:35:06.305]                   options(future.plan = NULL)
[13:35:06.305]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.305]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.305]                 }
[13:35:06.305]                 ...future.workdir <- getwd()
[13:35:06.305]             }
[13:35:06.305]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.305]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.305]         }
[13:35:06.305]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.305]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:06.305]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.305]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.305]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.305]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.305]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.305]             base::names(...future.oldOptions))
[13:35:06.305]     }
[13:35:06.305]     if (FALSE) {
[13:35:06.305]     }
[13:35:06.305]     else {
[13:35:06.305]         if (TRUE) {
[13:35:06.305]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.305]                 open = "w")
[13:35:06.305]         }
[13:35:06.305]         else {
[13:35:06.305]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.305]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.305]         }
[13:35:06.305]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.305]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.305]             base::sink(type = "output", split = FALSE)
[13:35:06.305]             base::close(...future.stdout)
[13:35:06.305]         }, add = TRUE)
[13:35:06.305]     }
[13:35:06.305]     ...future.frame <- base::sys.nframe()
[13:35:06.305]     ...future.conditions <- base::list()
[13:35:06.305]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.305]     if (FALSE) {
[13:35:06.305]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.305]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.305]     }
[13:35:06.305]     ...future.result <- base::tryCatch({
[13:35:06.305]         base::withCallingHandlers({
[13:35:06.305]             ...future.value <- base::withVisible(base::local({
[13:35:06.305]                 do.call(function(...) {
[13:35:06.305]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.305]                   if (!identical(...future.globals.maxSize.org, 
[13:35:06.305]                     ...future.globals.maxSize)) {
[13:35:06.305]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.305]                     on.exit(options(oopts), add = TRUE)
[13:35:06.305]                   }
[13:35:06.305]                   {
[13:35:06.305]                     lapply(seq_along(...future.elements_ii), 
[13:35:06.305]                       FUN = function(jj) {
[13:35:06.305]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.305]                         ...future.FUN(...future.X_jj, ...)
[13:35:06.305]                       })
[13:35:06.305]                   }
[13:35:06.305]                 }, args = future.call.arguments)
[13:35:06.305]             }))
[13:35:06.305]             future::FutureResult(value = ...future.value$value, 
[13:35:06.305]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.305]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.305]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.305]                     ...future.globalenv.names))
[13:35:06.305]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.305]         }, condition = base::local({
[13:35:06.305]             c <- base::c
[13:35:06.305]             inherits <- base::inherits
[13:35:06.305]             invokeRestart <- base::invokeRestart
[13:35:06.305]             length <- base::length
[13:35:06.305]             list <- base::list
[13:35:06.305]             seq.int <- base::seq.int
[13:35:06.305]             signalCondition <- base::signalCondition
[13:35:06.305]             sys.calls <- base::sys.calls
[13:35:06.305]             `[[` <- base::`[[`
[13:35:06.305]             `+` <- base::`+`
[13:35:06.305]             `<<-` <- base::`<<-`
[13:35:06.305]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.305]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.305]                   3L)]
[13:35:06.305]             }
[13:35:06.305]             function(cond) {
[13:35:06.305]                 is_error <- inherits(cond, "error")
[13:35:06.305]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.305]                   NULL)
[13:35:06.305]                 if (is_error) {
[13:35:06.305]                   sessionInformation <- function() {
[13:35:06.305]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.305]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.305]                       search = base::search(), system = base::Sys.info())
[13:35:06.305]                   }
[13:35:06.305]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.305]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.305]                     cond$call), session = sessionInformation(), 
[13:35:06.305]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.305]                   signalCondition(cond)
[13:35:06.305]                 }
[13:35:06.305]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.305]                 "immediateCondition"))) {
[13:35:06.305]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.305]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.305]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.305]                   if (TRUE && !signal) {
[13:35:06.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.305]                     {
[13:35:06.305]                       inherits <- base::inherits
[13:35:06.305]                       invokeRestart <- base::invokeRestart
[13:35:06.305]                       is.null <- base::is.null
[13:35:06.305]                       muffled <- FALSE
[13:35:06.305]                       if (inherits(cond, "message")) {
[13:35:06.305]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.305]                         if (muffled) 
[13:35:06.305]                           invokeRestart("muffleMessage")
[13:35:06.305]                       }
[13:35:06.305]                       else if (inherits(cond, "warning")) {
[13:35:06.305]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.305]                         if (muffled) 
[13:35:06.305]                           invokeRestart("muffleWarning")
[13:35:06.305]                       }
[13:35:06.305]                       else if (inherits(cond, "condition")) {
[13:35:06.305]                         if (!is.null(pattern)) {
[13:35:06.305]                           computeRestarts <- base::computeRestarts
[13:35:06.305]                           grepl <- base::grepl
[13:35:06.305]                           restarts <- computeRestarts(cond)
[13:35:06.305]                           for (restart in restarts) {
[13:35:06.305]                             name <- restart$name
[13:35:06.305]                             if (is.null(name)) 
[13:35:06.305]                               next
[13:35:06.305]                             if (!grepl(pattern, name)) 
[13:35:06.305]                               next
[13:35:06.305]                             invokeRestart(restart)
[13:35:06.305]                             muffled <- TRUE
[13:35:06.305]                             break
[13:35:06.305]                           }
[13:35:06.305]                         }
[13:35:06.305]                       }
[13:35:06.305]                       invisible(muffled)
[13:35:06.305]                     }
[13:35:06.305]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.305]                   }
[13:35:06.305]                 }
[13:35:06.305]                 else {
[13:35:06.305]                   if (TRUE) {
[13:35:06.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.305]                     {
[13:35:06.305]                       inherits <- base::inherits
[13:35:06.305]                       invokeRestart <- base::invokeRestart
[13:35:06.305]                       is.null <- base::is.null
[13:35:06.305]                       muffled <- FALSE
[13:35:06.305]                       if (inherits(cond, "message")) {
[13:35:06.305]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.305]                         if (muffled) 
[13:35:06.305]                           invokeRestart("muffleMessage")
[13:35:06.305]                       }
[13:35:06.305]                       else if (inherits(cond, "warning")) {
[13:35:06.305]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.305]                         if (muffled) 
[13:35:06.305]                           invokeRestart("muffleWarning")
[13:35:06.305]                       }
[13:35:06.305]                       else if (inherits(cond, "condition")) {
[13:35:06.305]                         if (!is.null(pattern)) {
[13:35:06.305]                           computeRestarts <- base::computeRestarts
[13:35:06.305]                           grepl <- base::grepl
[13:35:06.305]                           restarts <- computeRestarts(cond)
[13:35:06.305]                           for (restart in restarts) {
[13:35:06.305]                             name <- restart$name
[13:35:06.305]                             if (is.null(name)) 
[13:35:06.305]                               next
[13:35:06.305]                             if (!grepl(pattern, name)) 
[13:35:06.305]                               next
[13:35:06.305]                             invokeRestart(restart)
[13:35:06.305]                             muffled <- TRUE
[13:35:06.305]                             break
[13:35:06.305]                           }
[13:35:06.305]                         }
[13:35:06.305]                       }
[13:35:06.305]                       invisible(muffled)
[13:35:06.305]                     }
[13:35:06.305]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.305]                   }
[13:35:06.305]                 }
[13:35:06.305]             }
[13:35:06.305]         }))
[13:35:06.305]     }, error = function(ex) {
[13:35:06.305]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.305]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.305]                 ...future.rng), started = ...future.startTime, 
[13:35:06.305]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.305]             version = "1.8"), class = "FutureResult")
[13:35:06.305]     }, finally = {
[13:35:06.305]         if (!identical(...future.workdir, getwd())) 
[13:35:06.305]             setwd(...future.workdir)
[13:35:06.305]         {
[13:35:06.305]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.305]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.305]             }
[13:35:06.305]             base::options(...future.oldOptions)
[13:35:06.305]             if (.Platform$OS.type == "windows") {
[13:35:06.305]                 old_names <- names(...future.oldEnvVars)
[13:35:06.305]                 envs <- base::Sys.getenv()
[13:35:06.305]                 names <- names(envs)
[13:35:06.305]                 common <- intersect(names, old_names)
[13:35:06.305]                 added <- setdiff(names, old_names)
[13:35:06.305]                 removed <- setdiff(old_names, names)
[13:35:06.305]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.305]                   envs[common]]
[13:35:06.305]                 NAMES <- toupper(changed)
[13:35:06.305]                 args <- list()
[13:35:06.305]                 for (kk in seq_along(NAMES)) {
[13:35:06.305]                   name <- changed[[kk]]
[13:35:06.305]                   NAME <- NAMES[[kk]]
[13:35:06.305]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.305]                     next
[13:35:06.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.305]                 }
[13:35:06.305]                 NAMES <- toupper(added)
[13:35:06.305]                 for (kk in seq_along(NAMES)) {
[13:35:06.305]                   name <- added[[kk]]
[13:35:06.305]                   NAME <- NAMES[[kk]]
[13:35:06.305]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.305]                     next
[13:35:06.305]                   args[[name]] <- ""
[13:35:06.305]                 }
[13:35:06.305]                 NAMES <- toupper(removed)
[13:35:06.305]                 for (kk in seq_along(NAMES)) {
[13:35:06.305]                   name <- removed[[kk]]
[13:35:06.305]                   NAME <- NAMES[[kk]]
[13:35:06.305]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.305]                     next
[13:35:06.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.305]                 }
[13:35:06.305]                 if (length(args) > 0) 
[13:35:06.305]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.305]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.305]             }
[13:35:06.305]             else {
[13:35:06.305]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.305]             }
[13:35:06.305]             {
[13:35:06.305]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.305]                   0L) {
[13:35:06.305]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.305]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.305]                   base::options(opts)
[13:35:06.305]                 }
[13:35:06.305]                 {
[13:35:06.305]                   {
[13:35:06.305]                     NULL
[13:35:06.305]                     RNGkind("Mersenne-Twister")
[13:35:06.305]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:06.305]                       inherits = FALSE)
[13:35:06.305]                   }
[13:35:06.305]                   options(future.plan = NULL)
[13:35:06.305]                   if (is.na(NA_character_)) 
[13:35:06.305]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.305]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.305]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.305]                     .init = FALSE)
[13:35:06.305]                 }
[13:35:06.305]             }
[13:35:06.305]         }
[13:35:06.305]     })
[13:35:06.305]     if (TRUE) {
[13:35:06.305]         base::sink(type = "output", split = FALSE)
[13:35:06.305]         if (TRUE) {
[13:35:06.305]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.305]         }
[13:35:06.305]         else {
[13:35:06.305]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.305]         }
[13:35:06.305]         base::close(...future.stdout)
[13:35:06.305]         ...future.stdout <- NULL
[13:35:06.305]     }
[13:35:06.305]     ...future.result$conditions <- ...future.conditions
[13:35:06.305]     ...future.result$finished <- base::Sys.time()
[13:35:06.305]     ...future.result
[13:35:06.305] }
[13:35:06.307] assign_globals() ...
[13:35:06.307] List of 5
[13:35:06.307]  $ ...future.FUN            :function (x, y)  
[13:35:06.307]  $ future.call.arguments    :List of 1
[13:35:06.307]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:06.307]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.307]  $ ...future.elements_ii    :List of 4
[13:35:06.307]   ..$ A: num 50
[13:35:06.307]   ..$ B: num 60
[13:35:06.307]   ..$ C: num 70
[13:35:06.307]   ..$ D: num 80
[13:35:06.307]  $ ...future.seeds_ii       : NULL
[13:35:06.307]  $ ...future.globals.maxSize: NULL
[13:35:06.307]  - attr(*, "where")=List of 5
[13:35:06.307]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.307]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.307]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.307]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.307]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.307]  - attr(*, "resolved")= logi FALSE
[13:35:06.307]  - attr(*, "total_size")= num 4264
[13:35:06.307]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.307]  - attr(*, "already-done")= logi TRUE
[13:35:06.313] - reassign environment for ‘...future.FUN’
[13:35:06.313] - copied ‘...future.FUN’ to environment
[13:35:06.313] - copied ‘future.call.arguments’ to environment
[13:35:06.313] - copied ‘...future.elements_ii’ to environment
[13:35:06.313] - copied ‘...future.seeds_ii’ to environment
[13:35:06.313] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.313] assign_globals() ... done
[13:35:06.313] plan(): Setting new future strategy stack:
[13:35:06.313] List of future strategies:
[13:35:06.313] 1. sequential:
[13:35:06.313]    - args: function (..., envir = parent.frame())
[13:35:06.313]    - tweaked: FALSE
[13:35:06.313]    - call: NULL
[13:35:06.314] plan(): nbrOfWorkers() = 1
[13:35:06.315] plan(): Setting new future strategy stack:
[13:35:06.315] List of future strategies:
[13:35:06.315] 1. sequential:
[13:35:06.315]    - args: function (..., envir = parent.frame())
[13:35:06.315]    - tweaked: FALSE
[13:35:06.315]    - call: plan(strategy)
[13:35:06.315] plan(): nbrOfWorkers() = 1
[13:35:06.315] SequentialFuture started (and completed)
[13:35:06.315] - Launch lazy future ... done
[13:35:06.315] run() for ‘SequentialFuture’ ... done
[13:35:06.315] Created future:
[13:35:06.316] SequentialFuture:
[13:35:06.316] Label: ‘future_sapply-1’
[13:35:06.316] Expression:
[13:35:06.316] {
[13:35:06.316]     do.call(function(...) {
[13:35:06.316]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.316]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.316]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.316]             on.exit(options(oopts), add = TRUE)
[13:35:06.316]         }
[13:35:06.316]         {
[13:35:06.316]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.316]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.316]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.316]             })
[13:35:06.316]         }
[13:35:06.316]     }, args = future.call.arguments)
[13:35:06.316] }
[13:35:06.316] Lazy evaluation: FALSE
[13:35:06.316] Asynchronous evaluation: FALSE
[13:35:06.316] Local evaluation: TRUE
[13:35:06.316] Environment: R_GlobalEnv
[13:35:06.316] Capture standard output: TRUE
[13:35:06.316] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.316] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:06.316] Packages: <none>
[13:35:06.316] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.316] Resolved: TRUE
[13:35:06.316] Value: 1.34 KiB of class ‘list’
[13:35:06.316] Early signaling: FALSE
[13:35:06.316] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.316] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.316] Chunk #1 of 1 ... DONE
[13:35:06.317] Launching 1 futures (chunks) ... DONE
[13:35:06.317] Resolving 1 futures (chunks) ...
[13:35:06.317] resolve() on list ...
[13:35:06.317]  recursive: 0
[13:35:06.317]  length: 1
[13:35:06.317] 
[13:35:06.317] resolved() for ‘SequentialFuture’ ...
[13:35:06.317] - state: ‘finished’
[13:35:06.317] - run: TRUE
[13:35:06.317] - result: ‘FutureResult’
[13:35:06.317] resolved() for ‘SequentialFuture’ ... done
[13:35:06.318] Future #1
[13:35:06.318] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:06.318] - nx: 1
[13:35:06.318] - relay: TRUE
[13:35:06.318] - stdout: TRUE
[13:35:06.318] - signal: TRUE
[13:35:06.319] - resignal: FALSE
[13:35:06.319] - force: TRUE
[13:35:06.319] - relayed: [n=1] FALSE
[13:35:06.319] - queued futures: [n=1] FALSE
[13:35:06.319]  - until=1
[13:35:06.319]  - relaying element #1
[13:35:06.320] - relayed: [n=1] TRUE
[13:35:06.320] - queued futures: [n=1] TRUE
[13:35:06.320] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:06.320]  length: 0 (resolved future 1)
[13:35:06.320] Relaying remaining futures
[13:35:06.320] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.320] - nx: 1
[13:35:06.320] - relay: TRUE
[13:35:06.320] - stdout: TRUE
[13:35:06.320] - signal: TRUE
[13:35:06.320] - resignal: FALSE
[13:35:06.321] - force: TRUE
[13:35:06.321] - relayed: [n=1] TRUE
[13:35:06.321] - queued futures: [n=1] TRUE
 - flush all
[13:35:06.321] - relayed: [n=1] TRUE
[13:35:06.321] - queued futures: [n=1] TRUE
[13:35:06.321] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.321] resolve() on list ... DONE
[13:35:06.321]  - Number of value chunks collected: 1
[13:35:06.321] Resolving 1 futures (chunks) ... DONE
[13:35:06.321] Reducing values from 1 chunks ...
[13:35:06.321]  - Number of values collected after concatenation: 4
[13:35:06.322]  - Number of values expected: 4
[13:35:06.322] Reducing values from 1 chunks ... DONE
[13:35:06.322] future_lapply() ... DONE
[13:35:06.322] future_lapply() ...
[13:35:06.324] Number of chunks: 1
[13:35:06.324] getGlobalsAndPackagesXApply() ...
[13:35:06.324]  - future.globals: TRUE
[13:35:06.324] getGlobalsAndPackages() ...
[13:35:06.324] Searching for globals...
[13:35:06.327] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[13:35:06.327] Searching for globals ... DONE
[13:35:06.328] Resolving globals: FALSE
[13:35:06.328] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[13:35:06.329] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:06.329] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.329] - packages: [1] ‘future.apply’
[13:35:06.329] getGlobalsAndPackages() ... DONE
[13:35:06.329]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.329]  - needed namespaces: [n=1] ‘future.apply’
[13:35:06.329] Finding globals ... DONE
[13:35:06.329]  - use_args: TRUE
[13:35:06.329]  - Getting '...' globals ...
[13:35:06.330] resolve() on list ...
[13:35:06.330]  recursive: 0
[13:35:06.330]  length: 1
[13:35:06.330]  elements: ‘...’
[13:35:06.330]  length: 0 (resolved future 1)
[13:35:06.330] resolve() on list ... DONE
[13:35:06.330]    - '...' content: [n=1] ‘y’
[13:35:06.330] List of 1
[13:35:06.330]  $ ...:List of 1
[13:35:06.330]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:06.330]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.330]  - attr(*, "where")=List of 1
[13:35:06.330]   ..$ ...:<environment: 0x5574cf3471b0> 
[13:35:06.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.330]  - attr(*, "resolved")= logi TRUE
[13:35:06.330]  - attr(*, "total_size")= num NA
[13:35:06.333]  - Getting '...' globals ... DONE
[13:35:06.333] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:06.333] List of 8
[13:35:06.333]  $ ...future.FUN:function (x, ...)  
[13:35:06.333]  $ x_FUN        :function (x, y)  
[13:35:06.333]  $ times        : int 15
[13:35:06.333]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.333]  $ stop_if_not  :function (...)  
[13:35:06.333]  $ dim          : int [1:2] 3 5
[13:35:06.333]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:06.333]  $ ...          :List of 1
[13:35:06.333]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:06.333]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.333]  - attr(*, "where")=List of 8
[13:35:06.333]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.333]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:06.333]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:06.333]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:06.333]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:06.333]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:06.333]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:06.333]   ..$ ...          :<environment: 0x5574cf3471b0> 
[13:35:06.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.333]  - attr(*, "resolved")= logi FALSE
[13:35:06.333]  - attr(*, "total_size")= num 98600
[13:35:06.340] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:06.340] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.340] Number of futures (= number of chunks): 1
[13:35:06.340] Launching 1 futures (chunks) ...
[13:35:06.340] Chunk #1 of 1 ...
[13:35:06.340]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.340] getGlobalsAndPackages() ...
[13:35:06.341] Searching for globals...
[13:35:06.341] 
[13:35:06.341] Searching for globals ... DONE
[13:35:06.341] - globals: [0] <none>
[13:35:06.341] getGlobalsAndPackages() ... DONE
[13:35:06.341]    + additional globals found: [n=0] 
[13:35:06.341]    + additional namespaces needed: [n=0] 
[13:35:06.341]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.341]  - seeds: <none>
[13:35:06.341]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.342] getGlobalsAndPackages() ...
[13:35:06.342] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.342] Resolving globals: FALSE
[13:35:06.342] Tweak future expression to call with '...' arguments ...
[13:35:06.342] {
[13:35:06.342]     do.call(function(...) {
[13:35:06.342]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.342]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.342]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.342]             on.exit(options(oopts), add = TRUE)
[13:35:06.342]         }
[13:35:06.342]         {
[13:35:06.342]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.342]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.342]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.342]             })
[13:35:06.342]         }
[13:35:06.342]     }, args = future.call.arguments)
[13:35:06.342] }
[13:35:06.342] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.343] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.343] - packages: [1] ‘future.apply’
[13:35:06.343] getGlobalsAndPackages() ... DONE
[13:35:06.343] run() for ‘Future’ ...
[13:35:06.343] - state: ‘created’
[13:35:06.343] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:06.344] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.344] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:06.344]   - Field: ‘label’
[13:35:06.344]   - Field: ‘local’
[13:35:06.344]   - Field: ‘owner’
[13:35:06.344]   - Field: ‘envir’
[13:35:06.344]   - Field: ‘packages’
[13:35:06.344]   - Field: ‘gc’
[13:35:06.344]   - Field: ‘conditions’
[13:35:06.344]   - Field: ‘expr’
[13:35:06.345]   - Field: ‘uuid’
[13:35:06.345]   - Field: ‘seed’
[13:35:06.345]   - Field: ‘version’
[13:35:06.345]   - Field: ‘result’
[13:35:06.345]   - Field: ‘asynchronous’
[13:35:06.345]   - Field: ‘calls’
[13:35:06.345]   - Field: ‘globals’
[13:35:06.345]   - Field: ‘stdout’
[13:35:06.345]   - Field: ‘earlySignal’
[13:35:06.345]   - Field: ‘lazy’
[13:35:06.345]   - Field: ‘state’
[13:35:06.345] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:06.346] - Launch lazy future ...
[13:35:06.346] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.346] Packages needed by future strategies (n = 0): <none>
[13:35:06.346] {
[13:35:06.346]     {
[13:35:06.346]         {
[13:35:06.346]             ...future.startTime <- base::Sys.time()
[13:35:06.346]             {
[13:35:06.346]                 {
[13:35:06.346]                   {
[13:35:06.346]                     {
[13:35:06.346]                       base::local({
[13:35:06.346]                         has_future <- base::requireNamespace("future", 
[13:35:06.346]                           quietly = TRUE)
[13:35:06.346]                         if (has_future) {
[13:35:06.346]                           ns <- base::getNamespace("future")
[13:35:06.346]                           version <- ns[[".package"]][["version"]]
[13:35:06.346]                           if (is.null(version)) 
[13:35:06.346]                             version <- utils::packageVersion("future")
[13:35:06.346]                         }
[13:35:06.346]                         else {
[13:35:06.346]                           version <- NULL
[13:35:06.346]                         }
[13:35:06.346]                         if (!has_future || version < "1.8.0") {
[13:35:06.346]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.346]                             "", base::R.version$version.string), 
[13:35:06.346]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:06.346]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:06.346]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.346]                               "release", "version")], collapse = " "), 
[13:35:06.346]                             hostname = base::Sys.info()[["nodename"]])
[13:35:06.346]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.346]                             info)
[13:35:06.346]                           info <- base::paste(info, collapse = "; ")
[13:35:06.346]                           if (!has_future) {
[13:35:06.346]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.346]                               info)
[13:35:06.346]                           }
[13:35:06.346]                           else {
[13:35:06.346]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.346]                               info, version)
[13:35:06.346]                           }
[13:35:06.346]                           base::stop(msg)
[13:35:06.346]                         }
[13:35:06.346]                       })
[13:35:06.346]                     }
[13:35:06.346]                     base::local({
[13:35:06.346]                       for (pkg in "future.apply") {
[13:35:06.346]                         base::loadNamespace(pkg)
[13:35:06.346]                         base::library(pkg, character.only = TRUE)
[13:35:06.346]                       }
[13:35:06.346]                     })
[13:35:06.346]                   }
[13:35:06.346]                   ...future.strategy.old <- future::plan("list")
[13:35:06.346]                   options(future.plan = NULL)
[13:35:06.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.346]                 }
[13:35:06.346]                 ...future.workdir <- getwd()
[13:35:06.346]             }
[13:35:06.346]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.346]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.346]         }
[13:35:06.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.346]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:06.346]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.346]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.346]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.346]             base::names(...future.oldOptions))
[13:35:06.346]     }
[13:35:06.346]     if (FALSE) {
[13:35:06.346]     }
[13:35:06.346]     else {
[13:35:06.346]         if (TRUE) {
[13:35:06.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.346]                 open = "w")
[13:35:06.346]         }
[13:35:06.346]         else {
[13:35:06.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.346]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.346]         }
[13:35:06.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.346]             base::sink(type = "output", split = FALSE)
[13:35:06.346]             base::close(...future.stdout)
[13:35:06.346]         }, add = TRUE)
[13:35:06.346]     }
[13:35:06.346]     ...future.frame <- base::sys.nframe()
[13:35:06.346]     ...future.conditions <- base::list()
[13:35:06.346]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.346]     if (FALSE) {
[13:35:06.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.346]     }
[13:35:06.346]     ...future.result <- base::tryCatch({
[13:35:06.346]         base::withCallingHandlers({
[13:35:06.346]             ...future.value <- base::withVisible(base::local({
[13:35:06.346]                 do.call(function(...) {
[13:35:06.346]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.346]                   if (!identical(...future.globals.maxSize.org, 
[13:35:06.346]                     ...future.globals.maxSize)) {
[13:35:06.346]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.346]                     on.exit(options(oopts), add = TRUE)
[13:35:06.346]                   }
[13:35:06.346]                   {
[13:35:06.346]                     lapply(seq_along(...future.elements_ii), 
[13:35:06.346]                       FUN = function(jj) {
[13:35:06.346]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.346]                         ...future.FUN(...future.X_jj, ...)
[13:35:06.346]                       })
[13:35:06.346]                   }
[13:35:06.346]                 }, args = future.call.arguments)
[13:35:06.346]             }))
[13:35:06.346]             future::FutureResult(value = ...future.value$value, 
[13:35:06.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.346]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.346]                     ...future.globalenv.names))
[13:35:06.346]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.346]         }, condition = base::local({
[13:35:06.346]             c <- base::c
[13:35:06.346]             inherits <- base::inherits
[13:35:06.346]             invokeRestart <- base::invokeRestart
[13:35:06.346]             length <- base::length
[13:35:06.346]             list <- base::list
[13:35:06.346]             seq.int <- base::seq.int
[13:35:06.346]             signalCondition <- base::signalCondition
[13:35:06.346]             sys.calls <- base::sys.calls
[13:35:06.346]             `[[` <- base::`[[`
[13:35:06.346]             `+` <- base::`+`
[13:35:06.346]             `<<-` <- base::`<<-`
[13:35:06.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.346]                   3L)]
[13:35:06.346]             }
[13:35:06.346]             function(cond) {
[13:35:06.346]                 is_error <- inherits(cond, "error")
[13:35:06.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.346]                   NULL)
[13:35:06.346]                 if (is_error) {
[13:35:06.346]                   sessionInformation <- function() {
[13:35:06.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.346]                       search = base::search(), system = base::Sys.info())
[13:35:06.346]                   }
[13:35:06.346]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.346]                     cond$call), session = sessionInformation(), 
[13:35:06.346]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.346]                   signalCondition(cond)
[13:35:06.346]                 }
[13:35:06.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.346]                 "immediateCondition"))) {
[13:35:06.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.346]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.346]                   if (TRUE && !signal) {
[13:35:06.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.346]                     {
[13:35:06.346]                       inherits <- base::inherits
[13:35:06.346]                       invokeRestart <- base::invokeRestart
[13:35:06.346]                       is.null <- base::is.null
[13:35:06.346]                       muffled <- FALSE
[13:35:06.346]                       if (inherits(cond, "message")) {
[13:35:06.346]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.346]                         if (muffled) 
[13:35:06.346]                           invokeRestart("muffleMessage")
[13:35:06.346]                       }
[13:35:06.346]                       else if (inherits(cond, "warning")) {
[13:35:06.346]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.346]                         if (muffled) 
[13:35:06.346]                           invokeRestart("muffleWarning")
[13:35:06.346]                       }
[13:35:06.346]                       else if (inherits(cond, "condition")) {
[13:35:06.346]                         if (!is.null(pattern)) {
[13:35:06.346]                           computeRestarts <- base::computeRestarts
[13:35:06.346]                           grepl <- base::grepl
[13:35:06.346]                           restarts <- computeRestarts(cond)
[13:35:06.346]                           for (restart in restarts) {
[13:35:06.346]                             name <- restart$name
[13:35:06.346]                             if (is.null(name)) 
[13:35:06.346]                               next
[13:35:06.346]                             if (!grepl(pattern, name)) 
[13:35:06.346]                               next
[13:35:06.346]                             invokeRestart(restart)
[13:35:06.346]                             muffled <- TRUE
[13:35:06.346]                             break
[13:35:06.346]                           }
[13:35:06.346]                         }
[13:35:06.346]                       }
[13:35:06.346]                       invisible(muffled)
[13:35:06.346]                     }
[13:35:06.346]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.346]                   }
[13:35:06.346]                 }
[13:35:06.346]                 else {
[13:35:06.346]                   if (TRUE) {
[13:35:06.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.346]                     {
[13:35:06.346]                       inherits <- base::inherits
[13:35:06.346]                       invokeRestart <- base::invokeRestart
[13:35:06.346]                       is.null <- base::is.null
[13:35:06.346]                       muffled <- FALSE
[13:35:06.346]                       if (inherits(cond, "message")) {
[13:35:06.346]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.346]                         if (muffled) 
[13:35:06.346]                           invokeRestart("muffleMessage")
[13:35:06.346]                       }
[13:35:06.346]                       else if (inherits(cond, "warning")) {
[13:35:06.346]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.346]                         if (muffled) 
[13:35:06.346]                           invokeRestart("muffleWarning")
[13:35:06.346]                       }
[13:35:06.346]                       else if (inherits(cond, "condition")) {
[13:35:06.346]                         if (!is.null(pattern)) {
[13:35:06.346]                           computeRestarts <- base::computeRestarts
[13:35:06.346]                           grepl <- base::grepl
[13:35:06.346]                           restarts <- computeRestarts(cond)
[13:35:06.346]                           for (restart in restarts) {
[13:35:06.346]                             name <- restart$name
[13:35:06.346]                             if (is.null(name)) 
[13:35:06.346]                               next
[13:35:06.346]                             if (!grepl(pattern, name)) 
[13:35:06.346]                               next
[13:35:06.346]                             invokeRestart(restart)
[13:35:06.346]                             muffled <- TRUE
[13:35:06.346]                             break
[13:35:06.346]                           }
[13:35:06.346]                         }
[13:35:06.346]                       }
[13:35:06.346]                       invisible(muffled)
[13:35:06.346]                     }
[13:35:06.346]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.346]                   }
[13:35:06.346]                 }
[13:35:06.346]             }
[13:35:06.346]         }))
[13:35:06.346]     }, error = function(ex) {
[13:35:06.346]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.346]                 ...future.rng), started = ...future.startTime, 
[13:35:06.346]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.346]             version = "1.8"), class = "FutureResult")
[13:35:06.346]     }, finally = {
[13:35:06.346]         if (!identical(...future.workdir, getwd())) 
[13:35:06.346]             setwd(...future.workdir)
[13:35:06.346]         {
[13:35:06.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.346]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.346]             }
[13:35:06.346]             base::options(...future.oldOptions)
[13:35:06.346]             if (.Platform$OS.type == "windows") {
[13:35:06.346]                 old_names <- names(...future.oldEnvVars)
[13:35:06.346]                 envs <- base::Sys.getenv()
[13:35:06.346]                 names <- names(envs)
[13:35:06.346]                 common <- intersect(names, old_names)
[13:35:06.346]                 added <- setdiff(names, old_names)
[13:35:06.346]                 removed <- setdiff(old_names, names)
[13:35:06.346]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.346]                   envs[common]]
[13:35:06.346]                 NAMES <- toupper(changed)
[13:35:06.346]                 args <- list()
[13:35:06.346]                 for (kk in seq_along(NAMES)) {
[13:35:06.346]                   name <- changed[[kk]]
[13:35:06.346]                   NAME <- NAMES[[kk]]
[13:35:06.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.346]                     next
[13:35:06.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.346]                 }
[13:35:06.346]                 NAMES <- toupper(added)
[13:35:06.346]                 for (kk in seq_along(NAMES)) {
[13:35:06.346]                   name <- added[[kk]]
[13:35:06.346]                   NAME <- NAMES[[kk]]
[13:35:06.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.346]                     next
[13:35:06.346]                   args[[name]] <- ""
[13:35:06.346]                 }
[13:35:06.346]                 NAMES <- toupper(removed)
[13:35:06.346]                 for (kk in seq_along(NAMES)) {
[13:35:06.346]                   name <- removed[[kk]]
[13:35:06.346]                   NAME <- NAMES[[kk]]
[13:35:06.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.346]                     next
[13:35:06.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.346]                 }
[13:35:06.346]                 if (length(args) > 0) 
[13:35:06.346]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.346]             }
[13:35:06.346]             else {
[13:35:06.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.346]             }
[13:35:06.346]             {
[13:35:06.346]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.346]                   0L) {
[13:35:06.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.346]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.346]                   base::options(opts)
[13:35:06.346]                 }
[13:35:06.346]                 {
[13:35:06.346]                   {
[13:35:06.346]                     NULL
[13:35:06.346]                     RNGkind("Mersenne-Twister")
[13:35:06.346]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:06.346]                       inherits = FALSE)
[13:35:06.346]                   }
[13:35:06.346]                   options(future.plan = NULL)
[13:35:06.346]                   if (is.na(NA_character_)) 
[13:35:06.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.346]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.346]                     .init = FALSE)
[13:35:06.346]                 }
[13:35:06.346]             }
[13:35:06.346]         }
[13:35:06.346]     })
[13:35:06.346]     if (TRUE) {
[13:35:06.346]         base::sink(type = "output", split = FALSE)
[13:35:06.346]         if (TRUE) {
[13:35:06.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.346]         }
[13:35:06.346]         else {
[13:35:06.346]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.346]         }
[13:35:06.346]         base::close(...future.stdout)
[13:35:06.346]         ...future.stdout <- NULL
[13:35:06.346]     }
[13:35:06.346]     ...future.result$conditions <- ...future.conditions
[13:35:06.346]     ...future.result$finished <- base::Sys.time()
[13:35:06.346]     ...future.result
[13:35:06.346] }
[13:35:06.348] assign_globals() ...
[13:35:06.348] List of 11
[13:35:06.348]  $ ...future.FUN            :function (x, ...)  
[13:35:06.348]  $ x_FUN                    :function (x, y)  
[13:35:06.348]  $ times                    : int 15
[13:35:06.348]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.348]  $ stop_if_not              :function (...)  
[13:35:06.348]  $ dim                      : int [1:2] 3 5
[13:35:06.348]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:06.348]  $ future.call.arguments    :List of 1
[13:35:06.348]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:06.348]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.348]  $ ...future.elements_ii    :List of 4
[13:35:06.348]   ..$ A: num 50
[13:35:06.348]   ..$ B: num 60
[13:35:06.348]   ..$ C: num 70
[13:35:06.348]   ..$ D: num 80
[13:35:06.348]  $ ...future.seeds_ii       : NULL
[13:35:06.348]  $ ...future.globals.maxSize: NULL
[13:35:06.348]  - attr(*, "where")=List of 11
[13:35:06.348]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.348]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.348]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.348]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.348]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.348]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.348]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.348]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.348]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.348]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.348]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.348]  - attr(*, "resolved")= logi FALSE
[13:35:06.348]  - attr(*, "total_size")= num 98600
[13:35:06.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.348]  - attr(*, "already-done")= logi TRUE
[13:35:06.356] - copied ‘...future.FUN’ to environment
[13:35:06.356] - reassign environment for ‘x_FUN’
[13:35:06.356] - copied ‘x_FUN’ to environment
[13:35:06.356] - copied ‘times’ to environment
[13:35:06.356] - copied ‘stopf’ to environment
[13:35:06.357] - copied ‘stop_if_not’ to environment
[13:35:06.358] - copied ‘dim’ to environment
[13:35:06.358] - copied ‘valid_types’ to environment
[13:35:06.358] - copied ‘future.call.arguments’ to environment
[13:35:06.358] - copied ‘...future.elements_ii’ to environment
[13:35:06.358] - copied ‘...future.seeds_ii’ to environment
[13:35:06.358] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.358] assign_globals() ... done
[13:35:06.358] plan(): Setting new future strategy stack:
[13:35:06.359] List of future strategies:
[13:35:06.359] 1. sequential:
[13:35:06.359]    - args: function (..., envir = parent.frame())
[13:35:06.359]    - tweaked: FALSE
[13:35:06.359]    - call: NULL
[13:35:06.359] plan(): nbrOfWorkers() = 1
[13:35:06.360] plan(): Setting new future strategy stack:
[13:35:06.360] List of future strategies:
[13:35:06.360] 1. sequential:
[13:35:06.360]    - args: function (..., envir = parent.frame())
[13:35:06.360]    - tweaked: FALSE
[13:35:06.360]    - call: plan(strategy)
[13:35:06.360] plan(): nbrOfWorkers() = 1
[13:35:06.360] SequentialFuture started (and completed)
[13:35:06.360] - Launch lazy future ... done
[13:35:06.360] run() for ‘SequentialFuture’ ... done
[13:35:06.361] Created future:
[13:35:06.361] SequentialFuture:
[13:35:06.361] Label: ‘future_vapply-1’
[13:35:06.361] Expression:
[13:35:06.361] {
[13:35:06.361]     do.call(function(...) {
[13:35:06.361]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.361]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.361]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.361]             on.exit(options(oopts), add = TRUE)
[13:35:06.361]         }
[13:35:06.361]         {
[13:35:06.361]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.361]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.361]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.361]             })
[13:35:06.361]         }
[13:35:06.361]     }, args = future.call.arguments)
[13:35:06.361] }
[13:35:06.361] Lazy evaluation: FALSE
[13:35:06.361] Asynchronous evaluation: FALSE
[13:35:06.361] Local evaluation: TRUE
[13:35:06.361] Environment: R_GlobalEnv
[13:35:06.361] Capture standard output: TRUE
[13:35:06.361] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.361] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.361] Packages: 1 packages (‘future.apply’)
[13:35:06.361] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.361] Resolved: TRUE
[13:35:06.361] Value: 1.34 KiB of class ‘list’
[13:35:06.361] Early signaling: FALSE
[13:35:06.361] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.361] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.362] Chunk #1 of 1 ... DONE
[13:35:06.362] Launching 1 futures (chunks) ... DONE
[13:35:06.362] Resolving 1 futures (chunks) ...
[13:35:06.362] resolve() on list ...
[13:35:06.362]  recursive: 0
[13:35:06.362]  length: 1
[13:35:06.362] 
[13:35:06.362] resolved() for ‘SequentialFuture’ ...
[13:35:06.362] - state: ‘finished’
[13:35:06.363] - run: TRUE
[13:35:06.363] - result: ‘FutureResult’
[13:35:06.363] resolved() for ‘SequentialFuture’ ... done
[13:35:06.363] Future #1
[13:35:06.363] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:06.363] - nx: 1
[13:35:06.363] - relay: TRUE
[13:35:06.363] - stdout: TRUE
[13:35:06.363] - signal: TRUE
[13:35:06.363] - resignal: FALSE
[13:35:06.363] - force: TRUE
[13:35:06.363] - relayed: [n=1] FALSE
[13:35:06.364] - queued futures: [n=1] FALSE
[13:35:06.364]  - until=1
[13:35:06.364]  - relaying element #1
[13:35:06.364] - relayed: [n=1] TRUE
[13:35:06.364] - queued futures: [n=1] TRUE
[13:35:06.364] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:06.364]  length: 0 (resolved future 1)
[13:35:06.364] Relaying remaining futures
[13:35:06.364] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.364] - nx: 1
[13:35:06.364] - relay: TRUE
[13:35:06.365] - stdout: TRUE
[13:35:06.365] - signal: TRUE
[13:35:06.365] - resignal: FALSE
[13:35:06.365] - force: TRUE
[13:35:06.365] - relayed: [n=1] TRUE
[13:35:06.365] - queued futures: [n=1] TRUE
 - flush all
[13:35:06.365] - relayed: [n=1] TRUE
[13:35:06.365] - queued futures: [n=1] TRUE
[13:35:06.365] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.365] resolve() on list ... DONE
[13:35:06.365]  - Number of value chunks collected: 1
[13:35:06.366] Resolving 1 futures (chunks) ... DONE
[13:35:06.366] Reducing values from 1 chunks ...
[13:35:06.366]  - Number of values collected after concatenation: 4
[13:35:06.366]  - Number of values expected: 4
[13:35:06.366] Reducing values from 1 chunks ... DONE
[13:35:06.366] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[13:35:06.368] future_lapply() ...
[13:35:06.369] Number of chunks: 1
[13:35:06.369] getGlobalsAndPackagesXApply() ...
[13:35:06.369]  - future.globals: TRUE
[13:35:06.370] getGlobalsAndPackages() ...
[13:35:06.370] Searching for globals...
[13:35:06.372] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:06.372] Searching for globals ... DONE
[13:35:06.372] Resolving globals: FALSE
[13:35:06.373] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[13:35:06.374] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:06.374] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.374] - packages: [1] ‘future.apply’
[13:35:06.374] getGlobalsAndPackages() ... DONE
[13:35:06.374]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.374]  - needed namespaces: [n=1] ‘future.apply’
[13:35:06.374] Finding globals ... DONE
[13:35:06.374]  - use_args: TRUE
[13:35:06.374]  - Getting '...' globals ...
[13:35:06.375] resolve() on list ...
[13:35:06.375]  recursive: 0
[13:35:06.375]  length: 1
[13:35:06.375]  elements: ‘...’
[13:35:06.375]  length: 0 (resolved future 1)
[13:35:06.375] resolve() on list ... DONE
[13:35:06.375]    - '...' content: [n=0] 
[13:35:06.375] List of 1
[13:35:06.375]  $ ...: list()
[13:35:06.375]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.375]  - attr(*, "where")=List of 1
[13:35:06.375]   ..$ ...:<environment: 0x5574d0596348> 
[13:35:06.375]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.375]  - attr(*, "resolved")= logi TRUE
[13:35:06.375]  - attr(*, "total_size")= num NA
[13:35:06.378]  - Getting '...' globals ... DONE
[13:35:06.379] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:06.379] List of 8
[13:35:06.379]  $ ...future.FUN:function (x, ...)  
[13:35:06.379]  $ x_FUN        :function (x)  
[13:35:06.379]  $ times        : int 1
[13:35:06.379]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.379]  $ stop_if_not  :function (...)  
[13:35:06.379]  $ dim          : NULL
[13:35:06.379]  $ valid_types  : chr "logical"
[13:35:06.379]  $ ...          : list()
[13:35:06.379]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.379]  - attr(*, "where")=List of 8
[13:35:06.379]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.379]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:06.379]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:06.379]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:06.379]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:06.379]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:06.379]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:06.379]   ..$ ...          :<environment: 0x5574d0596348> 
[13:35:06.379]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.379]  - attr(*, "resolved")= logi FALSE
[13:35:06.379]  - attr(*, "total_size")= num 94200
[13:35:06.384] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:06.384] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.384] Number of futures (= number of chunks): 1
[13:35:06.384] Launching 1 futures (chunks) ...
[13:35:06.384] Chunk #1 of 1 ...
[13:35:06.384]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.385] getGlobalsAndPackages() ...
[13:35:06.385] Searching for globals...
[13:35:06.385] 
[13:35:06.385] Searching for globals ... DONE
[13:35:06.385] - globals: [0] <none>
[13:35:06.385] getGlobalsAndPackages() ... DONE
[13:35:06.385]    + additional globals found: [n=0] 
[13:35:06.385]    + additional namespaces needed: [n=0] 
[13:35:06.385]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.385]  - seeds: <none>
[13:35:06.385]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.386] getGlobalsAndPackages() ...
[13:35:06.386] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.386] Resolving globals: FALSE
[13:35:06.386] Tweak future expression to call with '...' arguments ...
[13:35:06.386] {
[13:35:06.386]     do.call(function(...) {
[13:35:06.386]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.386]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.386]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.386]             on.exit(options(oopts), add = TRUE)
[13:35:06.386]         }
[13:35:06.386]         {
[13:35:06.386]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.386]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.386]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.386]             })
[13:35:06.386]         }
[13:35:06.386]     }, args = future.call.arguments)
[13:35:06.386] }
[13:35:06.386] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.387] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.387] - packages: [1] ‘future.apply’
[13:35:06.387] getGlobalsAndPackages() ... DONE
[13:35:06.387] run() for ‘Future’ ...
[13:35:06.387] - state: ‘created’
[13:35:06.387] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:06.388] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.388] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:06.388]   - Field: ‘label’
[13:35:06.388]   - Field: ‘local’
[13:35:06.388]   - Field: ‘owner’
[13:35:06.388]   - Field: ‘envir’
[13:35:06.388]   - Field: ‘packages’
[13:35:06.388]   - Field: ‘gc’
[13:35:06.388]   - Field: ‘conditions’
[13:35:06.388]   - Field: ‘expr’
[13:35:06.389]   - Field: ‘uuid’
[13:35:06.389]   - Field: ‘seed’
[13:35:06.389]   - Field: ‘version’
[13:35:06.389]   - Field: ‘result’
[13:35:06.389]   - Field: ‘asynchronous’
[13:35:06.389]   - Field: ‘calls’
[13:35:06.389]   - Field: ‘globals’
[13:35:06.389]   - Field: ‘stdout’
[13:35:06.389]   - Field: ‘earlySignal’
[13:35:06.389]   - Field: ‘lazy’
[13:35:06.389]   - Field: ‘state’
[13:35:06.390] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:06.390] - Launch lazy future ...
[13:35:06.390] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.390] Packages needed by future strategies (n = 0): <none>
[13:35:06.390] {
[13:35:06.390]     {
[13:35:06.390]         {
[13:35:06.390]             ...future.startTime <- base::Sys.time()
[13:35:06.390]             {
[13:35:06.390]                 {
[13:35:06.390]                   {
[13:35:06.390]                     {
[13:35:06.390]                       base::local({
[13:35:06.390]                         has_future <- base::requireNamespace("future", 
[13:35:06.390]                           quietly = TRUE)
[13:35:06.390]                         if (has_future) {
[13:35:06.390]                           ns <- base::getNamespace("future")
[13:35:06.390]                           version <- ns[[".package"]][["version"]]
[13:35:06.390]                           if (is.null(version)) 
[13:35:06.390]                             version <- utils::packageVersion("future")
[13:35:06.390]                         }
[13:35:06.390]                         else {
[13:35:06.390]                           version <- NULL
[13:35:06.390]                         }
[13:35:06.390]                         if (!has_future || version < "1.8.0") {
[13:35:06.390]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.390]                             "", base::R.version$version.string), 
[13:35:06.390]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:06.390]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:06.390]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.390]                               "release", "version")], collapse = " "), 
[13:35:06.390]                             hostname = base::Sys.info()[["nodename"]])
[13:35:06.390]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.390]                             info)
[13:35:06.390]                           info <- base::paste(info, collapse = "; ")
[13:35:06.390]                           if (!has_future) {
[13:35:06.390]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.390]                               info)
[13:35:06.390]                           }
[13:35:06.390]                           else {
[13:35:06.390]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.390]                               info, version)
[13:35:06.390]                           }
[13:35:06.390]                           base::stop(msg)
[13:35:06.390]                         }
[13:35:06.390]                       })
[13:35:06.390]                     }
[13:35:06.390]                     base::local({
[13:35:06.390]                       for (pkg in "future.apply") {
[13:35:06.390]                         base::loadNamespace(pkg)
[13:35:06.390]                         base::library(pkg, character.only = TRUE)
[13:35:06.390]                       }
[13:35:06.390]                     })
[13:35:06.390]                   }
[13:35:06.390]                   ...future.strategy.old <- future::plan("list")
[13:35:06.390]                   options(future.plan = NULL)
[13:35:06.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.390]                 }
[13:35:06.390]                 ...future.workdir <- getwd()
[13:35:06.390]             }
[13:35:06.390]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.390]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.390]         }
[13:35:06.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.390]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:06.390]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.390]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.390]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.390]             base::names(...future.oldOptions))
[13:35:06.390]     }
[13:35:06.390]     if (FALSE) {
[13:35:06.390]     }
[13:35:06.390]     else {
[13:35:06.390]         if (TRUE) {
[13:35:06.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.390]                 open = "w")
[13:35:06.390]         }
[13:35:06.390]         else {
[13:35:06.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.390]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.390]         }
[13:35:06.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.390]             base::sink(type = "output", split = FALSE)
[13:35:06.390]             base::close(...future.stdout)
[13:35:06.390]         }, add = TRUE)
[13:35:06.390]     }
[13:35:06.390]     ...future.frame <- base::sys.nframe()
[13:35:06.390]     ...future.conditions <- base::list()
[13:35:06.390]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.390]     if (FALSE) {
[13:35:06.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.390]     }
[13:35:06.390]     ...future.result <- base::tryCatch({
[13:35:06.390]         base::withCallingHandlers({
[13:35:06.390]             ...future.value <- base::withVisible(base::local({
[13:35:06.390]                 do.call(function(...) {
[13:35:06.390]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.390]                   if (!identical(...future.globals.maxSize.org, 
[13:35:06.390]                     ...future.globals.maxSize)) {
[13:35:06.390]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.390]                     on.exit(options(oopts), add = TRUE)
[13:35:06.390]                   }
[13:35:06.390]                   {
[13:35:06.390]                     lapply(seq_along(...future.elements_ii), 
[13:35:06.390]                       FUN = function(jj) {
[13:35:06.390]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.390]                         ...future.FUN(...future.X_jj, ...)
[13:35:06.390]                       })
[13:35:06.390]                   }
[13:35:06.390]                 }, args = future.call.arguments)
[13:35:06.390]             }))
[13:35:06.390]             future::FutureResult(value = ...future.value$value, 
[13:35:06.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.390]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.390]                     ...future.globalenv.names))
[13:35:06.390]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.390]         }, condition = base::local({
[13:35:06.390]             c <- base::c
[13:35:06.390]             inherits <- base::inherits
[13:35:06.390]             invokeRestart <- base::invokeRestart
[13:35:06.390]             length <- base::length
[13:35:06.390]             list <- base::list
[13:35:06.390]             seq.int <- base::seq.int
[13:35:06.390]             signalCondition <- base::signalCondition
[13:35:06.390]             sys.calls <- base::sys.calls
[13:35:06.390]             `[[` <- base::`[[`
[13:35:06.390]             `+` <- base::`+`
[13:35:06.390]             `<<-` <- base::`<<-`
[13:35:06.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.390]                   3L)]
[13:35:06.390]             }
[13:35:06.390]             function(cond) {
[13:35:06.390]                 is_error <- inherits(cond, "error")
[13:35:06.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.390]                   NULL)
[13:35:06.390]                 if (is_error) {
[13:35:06.390]                   sessionInformation <- function() {
[13:35:06.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.390]                       search = base::search(), system = base::Sys.info())
[13:35:06.390]                   }
[13:35:06.390]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.390]                     cond$call), session = sessionInformation(), 
[13:35:06.390]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.390]                   signalCondition(cond)
[13:35:06.390]                 }
[13:35:06.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.390]                 "immediateCondition"))) {
[13:35:06.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.390]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.390]                   if (TRUE && !signal) {
[13:35:06.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.390]                     {
[13:35:06.390]                       inherits <- base::inherits
[13:35:06.390]                       invokeRestart <- base::invokeRestart
[13:35:06.390]                       is.null <- base::is.null
[13:35:06.390]                       muffled <- FALSE
[13:35:06.390]                       if (inherits(cond, "message")) {
[13:35:06.390]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.390]                         if (muffled) 
[13:35:06.390]                           invokeRestart("muffleMessage")
[13:35:06.390]                       }
[13:35:06.390]                       else if (inherits(cond, "warning")) {
[13:35:06.390]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.390]                         if (muffled) 
[13:35:06.390]                           invokeRestart("muffleWarning")
[13:35:06.390]                       }
[13:35:06.390]                       else if (inherits(cond, "condition")) {
[13:35:06.390]                         if (!is.null(pattern)) {
[13:35:06.390]                           computeRestarts <- base::computeRestarts
[13:35:06.390]                           grepl <- base::grepl
[13:35:06.390]                           restarts <- computeRestarts(cond)
[13:35:06.390]                           for (restart in restarts) {
[13:35:06.390]                             name <- restart$name
[13:35:06.390]                             if (is.null(name)) 
[13:35:06.390]                               next
[13:35:06.390]                             if (!grepl(pattern, name)) 
[13:35:06.390]                               next
[13:35:06.390]                             invokeRestart(restart)
[13:35:06.390]                             muffled <- TRUE
[13:35:06.390]                             break
[13:35:06.390]                           }
[13:35:06.390]                         }
[13:35:06.390]                       }
[13:35:06.390]                       invisible(muffled)
[13:35:06.390]                     }
[13:35:06.390]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.390]                   }
[13:35:06.390]                 }
[13:35:06.390]                 else {
[13:35:06.390]                   if (TRUE) {
[13:35:06.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.390]                     {
[13:35:06.390]                       inherits <- base::inherits
[13:35:06.390]                       invokeRestart <- base::invokeRestart
[13:35:06.390]                       is.null <- base::is.null
[13:35:06.390]                       muffled <- FALSE
[13:35:06.390]                       if (inherits(cond, "message")) {
[13:35:06.390]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.390]                         if (muffled) 
[13:35:06.390]                           invokeRestart("muffleMessage")
[13:35:06.390]                       }
[13:35:06.390]                       else if (inherits(cond, "warning")) {
[13:35:06.390]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.390]                         if (muffled) 
[13:35:06.390]                           invokeRestart("muffleWarning")
[13:35:06.390]                       }
[13:35:06.390]                       else if (inherits(cond, "condition")) {
[13:35:06.390]                         if (!is.null(pattern)) {
[13:35:06.390]                           computeRestarts <- base::computeRestarts
[13:35:06.390]                           grepl <- base::grepl
[13:35:06.390]                           restarts <- computeRestarts(cond)
[13:35:06.390]                           for (restart in restarts) {
[13:35:06.390]                             name <- restart$name
[13:35:06.390]                             if (is.null(name)) 
[13:35:06.390]                               next
[13:35:06.390]                             if (!grepl(pattern, name)) 
[13:35:06.390]                               next
[13:35:06.390]                             invokeRestart(restart)
[13:35:06.390]                             muffled <- TRUE
[13:35:06.390]                             break
[13:35:06.390]                           }
[13:35:06.390]                         }
[13:35:06.390]                       }
[13:35:06.390]                       invisible(muffled)
[13:35:06.390]                     }
[13:35:06.390]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.390]                   }
[13:35:06.390]                 }
[13:35:06.390]             }
[13:35:06.390]         }))
[13:35:06.390]     }, error = function(ex) {
[13:35:06.390]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.390]                 ...future.rng), started = ...future.startTime, 
[13:35:06.390]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.390]             version = "1.8"), class = "FutureResult")
[13:35:06.390]     }, finally = {
[13:35:06.390]         if (!identical(...future.workdir, getwd())) 
[13:35:06.390]             setwd(...future.workdir)
[13:35:06.390]         {
[13:35:06.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.390]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.390]             }
[13:35:06.390]             base::options(...future.oldOptions)
[13:35:06.390]             if (.Platform$OS.type == "windows") {
[13:35:06.390]                 old_names <- names(...future.oldEnvVars)
[13:35:06.390]                 envs <- base::Sys.getenv()
[13:35:06.390]                 names <- names(envs)
[13:35:06.390]                 common <- intersect(names, old_names)
[13:35:06.390]                 added <- setdiff(names, old_names)
[13:35:06.390]                 removed <- setdiff(old_names, names)
[13:35:06.390]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.390]                   envs[common]]
[13:35:06.390]                 NAMES <- toupper(changed)
[13:35:06.390]                 args <- list()
[13:35:06.390]                 for (kk in seq_along(NAMES)) {
[13:35:06.390]                   name <- changed[[kk]]
[13:35:06.390]                   NAME <- NAMES[[kk]]
[13:35:06.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.390]                     next
[13:35:06.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.390]                 }
[13:35:06.390]                 NAMES <- toupper(added)
[13:35:06.390]                 for (kk in seq_along(NAMES)) {
[13:35:06.390]                   name <- added[[kk]]
[13:35:06.390]                   NAME <- NAMES[[kk]]
[13:35:06.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.390]                     next
[13:35:06.390]                   args[[name]] <- ""
[13:35:06.390]                 }
[13:35:06.390]                 NAMES <- toupper(removed)
[13:35:06.390]                 for (kk in seq_along(NAMES)) {
[13:35:06.390]                   name <- removed[[kk]]
[13:35:06.390]                   NAME <- NAMES[[kk]]
[13:35:06.390]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.390]                     next
[13:35:06.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.390]                 }
[13:35:06.390]                 if (length(args) > 0) 
[13:35:06.390]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.390]             }
[13:35:06.390]             else {
[13:35:06.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.390]             }
[13:35:06.390]             {
[13:35:06.390]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.390]                   0L) {
[13:35:06.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.390]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.390]                   base::options(opts)
[13:35:06.390]                 }
[13:35:06.390]                 {
[13:35:06.390]                   {
[13:35:06.390]                     NULL
[13:35:06.390]                     RNGkind("Mersenne-Twister")
[13:35:06.390]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:06.390]                       inherits = FALSE)
[13:35:06.390]                   }
[13:35:06.390]                   options(future.plan = NULL)
[13:35:06.390]                   if (is.na(NA_character_)) 
[13:35:06.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.390]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.390]                     .init = FALSE)
[13:35:06.390]                 }
[13:35:06.390]             }
[13:35:06.390]         }
[13:35:06.390]     })
[13:35:06.390]     if (TRUE) {
[13:35:06.390]         base::sink(type = "output", split = FALSE)
[13:35:06.390]         if (TRUE) {
[13:35:06.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.390]         }
[13:35:06.390]         else {
[13:35:06.390]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.390]         }
[13:35:06.390]         base::close(...future.stdout)
[13:35:06.390]         ...future.stdout <- NULL
[13:35:06.390]     }
[13:35:06.390]     ...future.result$conditions <- ...future.conditions
[13:35:06.390]     ...future.result$finished <- base::Sys.time()
[13:35:06.390]     ...future.result
[13:35:06.390] }
[13:35:06.392] assign_globals() ...
[13:35:06.392] List of 11
[13:35:06.392]  $ ...future.FUN            :function (x, ...)  
[13:35:06.392]  $ x_FUN                    :function (x)  
[13:35:06.392]  $ times                    : int 1
[13:35:06.392]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.392]  $ stop_if_not              :function (...)  
[13:35:06.392]  $ dim                      : NULL
[13:35:06.392]  $ valid_types              : chr "logical"
[13:35:06.392]  $ future.call.arguments    : list()
[13:35:06.392]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.392]  $ ...future.elements_ii    :List of 11
[13:35:06.392]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[13:35:06.392]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[13:35:06.392]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[13:35:06.392]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[13:35:06.392]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[13:35:06.392]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[13:35:06.392]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[13:35:06.392]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[13:35:06.392]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[13:35:06.392]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[13:35:06.392]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[13:35:06.392]  $ ...future.seeds_ii       : NULL
[13:35:06.392]  $ ...future.globals.maxSize: NULL
[13:35:06.392]  - attr(*, "where")=List of 11
[13:35:06.392]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.392]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.392]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.392]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.392]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.392]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.392]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.392]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.392]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.392]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.392]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.392]  - attr(*, "resolved")= logi FALSE
[13:35:06.392]  - attr(*, "total_size")= num 94200
[13:35:06.392]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.392]  - attr(*, "already-done")= logi TRUE
[13:35:06.403] - copied ‘...future.FUN’ to environment
[13:35:06.403] - copied ‘x_FUN’ to environment
[13:35:06.403] - copied ‘times’ to environment
[13:35:06.403] - copied ‘stopf’ to environment
[13:35:06.403] - copied ‘stop_if_not’ to environment
[13:35:06.403] - copied ‘dim’ to environment
[13:35:06.403] - copied ‘valid_types’ to environment
[13:35:06.403] - copied ‘future.call.arguments’ to environment
[13:35:06.404] - copied ‘...future.elements_ii’ to environment
[13:35:06.404] - copied ‘...future.seeds_ii’ to environment
[13:35:06.404] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.404] assign_globals() ... done
[13:35:06.404] plan(): Setting new future strategy stack:
[13:35:06.404] List of future strategies:
[13:35:06.404] 1. sequential:
[13:35:06.404]    - args: function (..., envir = parent.frame())
[13:35:06.404]    - tweaked: FALSE
[13:35:06.404]    - call: NULL
[13:35:06.405] plan(): nbrOfWorkers() = 1
[13:35:06.405] plan(): Setting new future strategy stack:
[13:35:06.405] List of future strategies:
[13:35:06.405] 1. sequential:
[13:35:06.405]    - args: function (..., envir = parent.frame())
[13:35:06.405]    - tweaked: FALSE
[13:35:06.405]    - call: plan(strategy)
[13:35:06.406] plan(): nbrOfWorkers() = 1
[13:35:06.406] SequentialFuture started (and completed)
[13:35:06.406] - Launch lazy future ... done
[13:35:06.406] run() for ‘SequentialFuture’ ... done
[13:35:06.406] Created future:
[13:35:06.406] SequentialFuture:
[13:35:06.406] Label: ‘future_vapply-1’
[13:35:06.406] Expression:
[13:35:06.406] {
[13:35:06.406]     do.call(function(...) {
[13:35:06.406]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.406]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.406]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.406]             on.exit(options(oopts), add = TRUE)
[13:35:06.406]         }
[13:35:06.406]         {
[13:35:06.406]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.406]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.406]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.406]             })
[13:35:06.406]         }
[13:35:06.406]     }, args = future.call.arguments)
[13:35:06.406] }
[13:35:06.406] Lazy evaluation: FALSE
[13:35:06.406] Asynchronous evaluation: FALSE
[13:35:06.406] Local evaluation: TRUE
[13:35:06.406] Environment: R_GlobalEnv
[13:35:06.406] Capture standard output: TRUE
[13:35:06.406] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.406] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.406] Packages: 1 packages (‘future.apply’)
[13:35:06.406] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.406] Resolved: TRUE
[13:35:06.406] Value: 616 bytes of class ‘list’
[13:35:06.406] Early signaling: FALSE
[13:35:06.406] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.406] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.407] Chunk #1 of 1 ... DONE
[13:35:06.407] Launching 1 futures (chunks) ... DONE
[13:35:06.407] Resolving 1 futures (chunks) ...
[13:35:06.408] resolve() on list ...
[13:35:06.408]  recursive: 0
[13:35:06.408]  length: 1
[13:35:06.408] 
[13:35:06.408] resolved() for ‘SequentialFuture’ ...
[13:35:06.408] - state: ‘finished’
[13:35:06.408] - run: TRUE
[13:35:06.408] - result: ‘FutureResult’
[13:35:06.408] resolved() for ‘SequentialFuture’ ... done
[13:35:06.408] Future #1
[13:35:06.409] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:06.409] - nx: 1
[13:35:06.409] - relay: TRUE
[13:35:06.409] - stdout: TRUE
[13:35:06.409] - signal: TRUE
[13:35:06.409] - resignal: FALSE
[13:35:06.409] - force: TRUE
[13:35:06.409] - relayed: [n=1] FALSE
[13:35:06.409] - queued futures: [n=1] FALSE
[13:35:06.409]  - until=1
[13:35:06.409]  - relaying element #1
[13:35:06.409] - relayed: [n=1] TRUE
[13:35:06.410] - queued futures: [n=1] TRUE
[13:35:06.410] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:06.410]  length: 0 (resolved future 1)
[13:35:06.410] Relaying remaining futures
[13:35:06.410] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.410] - nx: 1
[13:35:06.410] - relay: TRUE
[13:35:06.410] - stdout: TRUE
[13:35:06.410] - signal: TRUE
[13:35:06.410] - resignal: FALSE
[13:35:06.410] - force: TRUE
[13:35:06.411] - relayed: [n=1] TRUE
[13:35:06.411] - queued futures: [n=1] TRUE
 - flush all
[13:35:06.411] - relayed: [n=1] TRUE
[13:35:06.411] - queued futures: [n=1] TRUE
[13:35:06.411] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.411] resolve() on list ... DONE
[13:35:06.411]  - Number of value chunks collected: 1
[13:35:06.411] Resolving 1 futures (chunks) ... DONE
[13:35:06.411] Reducing values from 1 chunks ...
[13:35:06.411]  - Number of values collected after concatenation: 11
[13:35:06.412]  - Number of values expected: 11
[13:35:06.412] Reducing values from 1 chunks ... DONE
[13:35:06.412] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[13:35:06.412] future_lapply() ...
[13:35:06.414] Number of chunks: 1
[13:35:06.414] getGlobalsAndPackagesXApply() ...
[13:35:06.414]  - future.globals: TRUE
[13:35:06.414] getGlobalsAndPackages() ...
[13:35:06.414] Searching for globals...
[13:35:06.418] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:06.418] Searching for globals ... DONE
[13:35:06.418] Resolving globals: FALSE
[13:35:06.419] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[13:35:06.419] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:06.420] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.420] - packages: [1] ‘future.apply’
[13:35:06.420] getGlobalsAndPackages() ... DONE
[13:35:06.420]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.420]  - needed namespaces: [n=1] ‘future.apply’
[13:35:06.420] Finding globals ... DONE
[13:35:06.420]  - use_args: TRUE
[13:35:06.420]  - Getting '...' globals ...
[13:35:06.420] resolve() on list ...
[13:35:06.421]  recursive: 0
[13:35:06.421]  length: 1
[13:35:06.421]  elements: ‘...’
[13:35:06.421]  length: 0 (resolved future 1)
[13:35:06.421] resolve() on list ... DONE
[13:35:06.421]    - '...' content: [n=0] 
[13:35:06.421] List of 1
[13:35:06.421]  $ ...: list()
[13:35:06.421]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.421]  - attr(*, "where")=List of 1
[13:35:06.421]   ..$ ...:<environment: 0x5574d0a4c4a0> 
[13:35:06.421]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.421]  - attr(*, "resolved")= logi TRUE
[13:35:06.421]  - attr(*, "total_size")= num NA
[13:35:06.423]  - Getting '...' globals ... DONE
[13:35:06.424] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:06.424] List of 8
[13:35:06.424]  $ ...future.FUN:function (x, ...)  
[13:35:06.424]  $ x_FUN        :function (x)  
[13:35:06.424]  $ times        : int 1
[13:35:06.424]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.424]  $ stop_if_not  :function (...)  
[13:35:06.424]  $ dim          : NULL
[13:35:06.424]  $ valid_types  : chr [1:2] "logical" "integer"
[13:35:06.424]  $ ...          : list()
[13:35:06.424]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.424]  - attr(*, "where")=List of 8
[13:35:06.424]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.424]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:06.424]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:06.424]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:06.424]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:06.424]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:06.424]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:06.424]   ..$ ...          :<environment: 0x5574d0a4c4a0> 
[13:35:06.424]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.424]  - attr(*, "resolved")= logi FALSE
[13:35:06.424]  - attr(*, "total_size")= num 94264
[13:35:06.429] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:06.429] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.429] Number of futures (= number of chunks): 1
[13:35:06.429] Launching 1 futures (chunks) ...
[13:35:06.429] Chunk #1 of 1 ...
[13:35:06.429]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.429] getGlobalsAndPackages() ...
[13:35:06.429] Searching for globals...
[13:35:06.430] 
[13:35:06.430] Searching for globals ... DONE
[13:35:06.430] - globals: [0] <none>
[13:35:06.430] getGlobalsAndPackages() ... DONE
[13:35:06.430]    + additional globals found: [n=0] 
[13:35:06.430]    + additional namespaces needed: [n=0] 
[13:35:06.430]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.430]  - seeds: <none>
[13:35:06.430]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.430] getGlobalsAndPackages() ...
[13:35:06.430] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.431] Resolving globals: FALSE
[13:35:06.431] Tweak future expression to call with '...' arguments ...
[13:35:06.431] {
[13:35:06.431]     do.call(function(...) {
[13:35:06.431]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.431]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.431]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.431]             on.exit(options(oopts), add = TRUE)
[13:35:06.431]         }
[13:35:06.431]         {
[13:35:06.431]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.431]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.431]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.431]             })
[13:35:06.431]         }
[13:35:06.431]     }, args = future.call.arguments)
[13:35:06.431] }
[13:35:06.431] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.431] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.432] - packages: [1] ‘future.apply’
[13:35:06.432] getGlobalsAndPackages() ... DONE
[13:35:06.432] run() for ‘Future’ ...
[13:35:06.432] - state: ‘created’
[13:35:06.432] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:06.432] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.432] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:06.433]   - Field: ‘label’
[13:35:06.433]   - Field: ‘local’
[13:35:06.433]   - Field: ‘owner’
[13:35:06.433]   - Field: ‘envir’
[13:35:06.433]   - Field: ‘packages’
[13:35:06.433]   - Field: ‘gc’
[13:35:06.434]   - Field: ‘conditions’
[13:35:06.434]   - Field: ‘expr’
[13:35:06.434]   - Field: ‘uuid’
[13:35:06.434]   - Field: ‘seed’
[13:35:06.434]   - Field: ‘version’
[13:35:06.434]   - Field: ‘result’
[13:35:06.434]   - Field: ‘asynchronous’
[13:35:06.435]   - Field: ‘calls’
[13:35:06.435]   - Field: ‘globals’
[13:35:06.435]   - Field: ‘stdout’
[13:35:06.435]   - Field: ‘earlySignal’
[13:35:06.435]   - Field: ‘lazy’
[13:35:06.435]   - Field: ‘state’
[13:35:06.435] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:06.435] - Launch lazy future ...
[13:35:06.435] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.436] Packages needed by future strategies (n = 0): <none>
[13:35:06.436] {
[13:35:06.436]     {
[13:35:06.436]         {
[13:35:06.436]             ...future.startTime <- base::Sys.time()
[13:35:06.436]             {
[13:35:06.436]                 {
[13:35:06.436]                   {
[13:35:06.436]                     {
[13:35:06.436]                       base::local({
[13:35:06.436]                         has_future <- base::requireNamespace("future", 
[13:35:06.436]                           quietly = TRUE)
[13:35:06.436]                         if (has_future) {
[13:35:06.436]                           ns <- base::getNamespace("future")
[13:35:06.436]                           version <- ns[[".package"]][["version"]]
[13:35:06.436]                           if (is.null(version)) 
[13:35:06.436]                             version <- utils::packageVersion("future")
[13:35:06.436]                         }
[13:35:06.436]                         else {
[13:35:06.436]                           version <- NULL
[13:35:06.436]                         }
[13:35:06.436]                         if (!has_future || version < "1.8.0") {
[13:35:06.436]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.436]                             "", base::R.version$version.string), 
[13:35:06.436]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:06.436]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:06.436]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.436]                               "release", "version")], collapse = " "), 
[13:35:06.436]                             hostname = base::Sys.info()[["nodename"]])
[13:35:06.436]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.436]                             info)
[13:35:06.436]                           info <- base::paste(info, collapse = "; ")
[13:35:06.436]                           if (!has_future) {
[13:35:06.436]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.436]                               info)
[13:35:06.436]                           }
[13:35:06.436]                           else {
[13:35:06.436]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.436]                               info, version)
[13:35:06.436]                           }
[13:35:06.436]                           base::stop(msg)
[13:35:06.436]                         }
[13:35:06.436]                       })
[13:35:06.436]                     }
[13:35:06.436]                     base::local({
[13:35:06.436]                       for (pkg in "future.apply") {
[13:35:06.436]                         base::loadNamespace(pkg)
[13:35:06.436]                         base::library(pkg, character.only = TRUE)
[13:35:06.436]                       }
[13:35:06.436]                     })
[13:35:06.436]                   }
[13:35:06.436]                   ...future.strategy.old <- future::plan("list")
[13:35:06.436]                   options(future.plan = NULL)
[13:35:06.436]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.436]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.436]                 }
[13:35:06.436]                 ...future.workdir <- getwd()
[13:35:06.436]             }
[13:35:06.436]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.436]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.436]         }
[13:35:06.436]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.436]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:06.436]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.436]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.436]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.436]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.436]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.436]             base::names(...future.oldOptions))
[13:35:06.436]     }
[13:35:06.436]     if (FALSE) {
[13:35:06.436]     }
[13:35:06.436]     else {
[13:35:06.436]         if (TRUE) {
[13:35:06.436]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.436]                 open = "w")
[13:35:06.436]         }
[13:35:06.436]         else {
[13:35:06.436]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.436]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.436]         }
[13:35:06.436]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.436]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.436]             base::sink(type = "output", split = FALSE)
[13:35:06.436]             base::close(...future.stdout)
[13:35:06.436]         }, add = TRUE)
[13:35:06.436]     }
[13:35:06.436]     ...future.frame <- base::sys.nframe()
[13:35:06.436]     ...future.conditions <- base::list()
[13:35:06.436]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.436]     if (FALSE) {
[13:35:06.436]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.436]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.436]     }
[13:35:06.436]     ...future.result <- base::tryCatch({
[13:35:06.436]         base::withCallingHandlers({
[13:35:06.436]             ...future.value <- base::withVisible(base::local({
[13:35:06.436]                 do.call(function(...) {
[13:35:06.436]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.436]                   if (!identical(...future.globals.maxSize.org, 
[13:35:06.436]                     ...future.globals.maxSize)) {
[13:35:06.436]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.436]                     on.exit(options(oopts), add = TRUE)
[13:35:06.436]                   }
[13:35:06.436]                   {
[13:35:06.436]                     lapply(seq_along(...future.elements_ii), 
[13:35:06.436]                       FUN = function(jj) {
[13:35:06.436]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.436]                         ...future.FUN(...future.X_jj, ...)
[13:35:06.436]                       })
[13:35:06.436]                   }
[13:35:06.436]                 }, args = future.call.arguments)
[13:35:06.436]             }))
[13:35:06.436]             future::FutureResult(value = ...future.value$value, 
[13:35:06.436]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.436]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.436]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.436]                     ...future.globalenv.names))
[13:35:06.436]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.436]         }, condition = base::local({
[13:35:06.436]             c <- base::c
[13:35:06.436]             inherits <- base::inherits
[13:35:06.436]             invokeRestart <- base::invokeRestart
[13:35:06.436]             length <- base::length
[13:35:06.436]             list <- base::list
[13:35:06.436]             seq.int <- base::seq.int
[13:35:06.436]             signalCondition <- base::signalCondition
[13:35:06.436]             sys.calls <- base::sys.calls
[13:35:06.436]             `[[` <- base::`[[`
[13:35:06.436]             `+` <- base::`+`
[13:35:06.436]             `<<-` <- base::`<<-`
[13:35:06.436]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.436]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.436]                   3L)]
[13:35:06.436]             }
[13:35:06.436]             function(cond) {
[13:35:06.436]                 is_error <- inherits(cond, "error")
[13:35:06.436]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.436]                   NULL)
[13:35:06.436]                 if (is_error) {
[13:35:06.436]                   sessionInformation <- function() {
[13:35:06.436]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.436]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.436]                       search = base::search(), system = base::Sys.info())
[13:35:06.436]                   }
[13:35:06.436]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.436]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.436]                     cond$call), session = sessionInformation(), 
[13:35:06.436]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.436]                   signalCondition(cond)
[13:35:06.436]                 }
[13:35:06.436]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.436]                 "immediateCondition"))) {
[13:35:06.436]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.436]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.436]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.436]                   if (TRUE && !signal) {
[13:35:06.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.436]                     {
[13:35:06.436]                       inherits <- base::inherits
[13:35:06.436]                       invokeRestart <- base::invokeRestart
[13:35:06.436]                       is.null <- base::is.null
[13:35:06.436]                       muffled <- FALSE
[13:35:06.436]                       if (inherits(cond, "message")) {
[13:35:06.436]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.436]                         if (muffled) 
[13:35:06.436]                           invokeRestart("muffleMessage")
[13:35:06.436]                       }
[13:35:06.436]                       else if (inherits(cond, "warning")) {
[13:35:06.436]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.436]                         if (muffled) 
[13:35:06.436]                           invokeRestart("muffleWarning")
[13:35:06.436]                       }
[13:35:06.436]                       else if (inherits(cond, "condition")) {
[13:35:06.436]                         if (!is.null(pattern)) {
[13:35:06.436]                           computeRestarts <- base::computeRestarts
[13:35:06.436]                           grepl <- base::grepl
[13:35:06.436]                           restarts <- computeRestarts(cond)
[13:35:06.436]                           for (restart in restarts) {
[13:35:06.436]                             name <- restart$name
[13:35:06.436]                             if (is.null(name)) 
[13:35:06.436]                               next
[13:35:06.436]                             if (!grepl(pattern, name)) 
[13:35:06.436]                               next
[13:35:06.436]                             invokeRestart(restart)
[13:35:06.436]                             muffled <- TRUE
[13:35:06.436]                             break
[13:35:06.436]                           }
[13:35:06.436]                         }
[13:35:06.436]                       }
[13:35:06.436]                       invisible(muffled)
[13:35:06.436]                     }
[13:35:06.436]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.436]                   }
[13:35:06.436]                 }
[13:35:06.436]                 else {
[13:35:06.436]                   if (TRUE) {
[13:35:06.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.436]                     {
[13:35:06.436]                       inherits <- base::inherits
[13:35:06.436]                       invokeRestart <- base::invokeRestart
[13:35:06.436]                       is.null <- base::is.null
[13:35:06.436]                       muffled <- FALSE
[13:35:06.436]                       if (inherits(cond, "message")) {
[13:35:06.436]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.436]                         if (muffled) 
[13:35:06.436]                           invokeRestart("muffleMessage")
[13:35:06.436]                       }
[13:35:06.436]                       else if (inherits(cond, "warning")) {
[13:35:06.436]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.436]                         if (muffled) 
[13:35:06.436]                           invokeRestart("muffleWarning")
[13:35:06.436]                       }
[13:35:06.436]                       else if (inherits(cond, "condition")) {
[13:35:06.436]                         if (!is.null(pattern)) {
[13:35:06.436]                           computeRestarts <- base::computeRestarts
[13:35:06.436]                           grepl <- base::grepl
[13:35:06.436]                           restarts <- computeRestarts(cond)
[13:35:06.436]                           for (restart in restarts) {
[13:35:06.436]                             name <- restart$name
[13:35:06.436]                             if (is.null(name)) 
[13:35:06.436]                               next
[13:35:06.436]                             if (!grepl(pattern, name)) 
[13:35:06.436]                               next
[13:35:06.436]                             invokeRestart(restart)
[13:35:06.436]                             muffled <- TRUE
[13:35:06.436]                             break
[13:35:06.436]                           }
[13:35:06.436]                         }
[13:35:06.436]                       }
[13:35:06.436]                       invisible(muffled)
[13:35:06.436]                     }
[13:35:06.436]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.436]                   }
[13:35:06.436]                 }
[13:35:06.436]             }
[13:35:06.436]         }))
[13:35:06.436]     }, error = function(ex) {
[13:35:06.436]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.436]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.436]                 ...future.rng), started = ...future.startTime, 
[13:35:06.436]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.436]             version = "1.8"), class = "FutureResult")
[13:35:06.436]     }, finally = {
[13:35:06.436]         if (!identical(...future.workdir, getwd())) 
[13:35:06.436]             setwd(...future.workdir)
[13:35:06.436]         {
[13:35:06.436]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.436]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.436]             }
[13:35:06.436]             base::options(...future.oldOptions)
[13:35:06.436]             if (.Platform$OS.type == "windows") {
[13:35:06.436]                 old_names <- names(...future.oldEnvVars)
[13:35:06.436]                 envs <- base::Sys.getenv()
[13:35:06.436]                 names <- names(envs)
[13:35:06.436]                 common <- intersect(names, old_names)
[13:35:06.436]                 added <- setdiff(names, old_names)
[13:35:06.436]                 removed <- setdiff(old_names, names)
[13:35:06.436]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.436]                   envs[common]]
[13:35:06.436]                 NAMES <- toupper(changed)
[13:35:06.436]                 args <- list()
[13:35:06.436]                 for (kk in seq_along(NAMES)) {
[13:35:06.436]                   name <- changed[[kk]]
[13:35:06.436]                   NAME <- NAMES[[kk]]
[13:35:06.436]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.436]                     next
[13:35:06.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.436]                 }
[13:35:06.436]                 NAMES <- toupper(added)
[13:35:06.436]                 for (kk in seq_along(NAMES)) {
[13:35:06.436]                   name <- added[[kk]]
[13:35:06.436]                   NAME <- NAMES[[kk]]
[13:35:06.436]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.436]                     next
[13:35:06.436]                   args[[name]] <- ""
[13:35:06.436]                 }
[13:35:06.436]                 NAMES <- toupper(removed)
[13:35:06.436]                 for (kk in seq_along(NAMES)) {
[13:35:06.436]                   name <- removed[[kk]]
[13:35:06.436]                   NAME <- NAMES[[kk]]
[13:35:06.436]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.436]                     next
[13:35:06.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.436]                 }
[13:35:06.436]                 if (length(args) > 0) 
[13:35:06.436]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.436]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.436]             }
[13:35:06.436]             else {
[13:35:06.436]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.436]             }
[13:35:06.436]             {
[13:35:06.436]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.436]                   0L) {
[13:35:06.436]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.436]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.436]                   base::options(opts)
[13:35:06.436]                 }
[13:35:06.436]                 {
[13:35:06.436]                   {
[13:35:06.436]                     NULL
[13:35:06.436]                     RNGkind("Mersenne-Twister")
[13:35:06.436]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:06.436]                       inherits = FALSE)
[13:35:06.436]                   }
[13:35:06.436]                   options(future.plan = NULL)
[13:35:06.436]                   if (is.na(NA_character_)) 
[13:35:06.436]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.436]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.436]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.436]                     .init = FALSE)
[13:35:06.436]                 }
[13:35:06.436]             }
[13:35:06.436]         }
[13:35:06.436]     })
[13:35:06.436]     if (TRUE) {
[13:35:06.436]         base::sink(type = "output", split = FALSE)
[13:35:06.436]         if (TRUE) {
[13:35:06.436]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.436]         }
[13:35:06.436]         else {
[13:35:06.436]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.436]         }
[13:35:06.436]         base::close(...future.stdout)
[13:35:06.436]         ...future.stdout <- NULL
[13:35:06.436]     }
[13:35:06.436]     ...future.result$conditions <- ...future.conditions
[13:35:06.436]     ...future.result$finished <- base::Sys.time()
[13:35:06.436]     ...future.result
[13:35:06.436] }
[13:35:06.438] assign_globals() ...
[13:35:06.438] List of 11
[13:35:06.438]  $ ...future.FUN            :function (x, ...)  
[13:35:06.438]  $ x_FUN                    :function (x)  
[13:35:06.438]  $ times                    : int 1
[13:35:06.438]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.438]  $ stop_if_not              :function (...)  
[13:35:06.438]  $ dim                      : NULL
[13:35:06.438]  $ valid_types              : chr [1:2] "logical" "integer"
[13:35:06.438]  $ future.call.arguments    : list()
[13:35:06.438]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.438]  $ ...future.elements_ii    :List of 3
[13:35:06.438]   ..$ a: num 1
[13:35:06.438]   ..$ b: num 2
[13:35:06.438]   ..$ c: num 3
[13:35:06.438]  $ ...future.seeds_ii       : NULL
[13:35:06.438]  $ ...future.globals.maxSize: NULL
[13:35:06.438]  - attr(*, "where")=List of 11
[13:35:06.438]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.438]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.438]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.438]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.438]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.438]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.438]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.438]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.438]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.438]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.438]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.438]  - attr(*, "resolved")= logi FALSE
[13:35:06.438]  - attr(*, "total_size")= num 94264
[13:35:06.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.438]  - attr(*, "already-done")= logi TRUE
[13:35:06.446] - copied ‘...future.FUN’ to environment
[13:35:06.446] - copied ‘x_FUN’ to environment
[13:35:06.446] - copied ‘times’ to environment
[13:35:06.446] - copied ‘stopf’ to environment
[13:35:06.446] - copied ‘stop_if_not’ to environment
[13:35:06.446] - copied ‘dim’ to environment
[13:35:06.447] - copied ‘valid_types’ to environment
[13:35:06.447] - copied ‘future.call.arguments’ to environment
[13:35:06.447] - copied ‘...future.elements_ii’ to environment
[13:35:06.447] - copied ‘...future.seeds_ii’ to environment
[13:35:06.447] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.447] assign_globals() ... done
[13:35:06.447] plan(): Setting new future strategy stack:
[13:35:06.447] List of future strategies:
[13:35:06.447] 1. sequential:
[13:35:06.447]    - args: function (..., envir = parent.frame())
[13:35:06.447]    - tweaked: FALSE
[13:35:06.447]    - call: NULL
[13:35:06.448] plan(): nbrOfWorkers() = 1
[13:35:06.448] plan(): Setting new future strategy stack:
[13:35:06.449] List of future strategies:
[13:35:06.449] 1. sequential:
[13:35:06.449]    - args: function (..., envir = parent.frame())
[13:35:06.449]    - tweaked: FALSE
[13:35:06.449]    - call: plan(strategy)
[13:35:06.449] plan(): nbrOfWorkers() = 1
[13:35:06.449] SequentialFuture started (and completed)
[13:35:06.449] - Launch lazy future ... done
[13:35:06.449] run() for ‘SequentialFuture’ ... done
[13:35:06.449] Created future:
[13:35:06.449] SequentialFuture:
[13:35:06.449] Label: ‘future_vapply-1’
[13:35:06.449] Expression:
[13:35:06.449] {
[13:35:06.449]     do.call(function(...) {
[13:35:06.449]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.449]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.449]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.449]             on.exit(options(oopts), add = TRUE)
[13:35:06.449]         }
[13:35:06.449]         {
[13:35:06.449]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.449]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.449]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.449]             })
[13:35:06.449]         }
[13:35:06.449]     }, args = future.call.arguments)
[13:35:06.449] }
[13:35:06.449] Lazy evaluation: FALSE
[13:35:06.449] Asynchronous evaluation: FALSE
[13:35:06.449] Local evaluation: TRUE
[13:35:06.449] Environment: R_GlobalEnv
[13:35:06.449] Capture standard output: TRUE
[13:35:06.449] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.449] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.449] Packages: 1 packages (‘future.apply’)
[13:35:06.449] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.449] Resolved: TRUE
[13:35:06.449] Value: 168 bytes of class ‘list’
[13:35:06.449] Early signaling: FALSE
[13:35:06.449] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.449] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.450] Chunk #1 of 1 ... DONE
[13:35:06.451] Launching 1 futures (chunks) ... DONE
[13:35:06.451] Resolving 1 futures (chunks) ...
[13:35:06.451] resolve() on list ...
[13:35:06.451]  recursive: 0
[13:35:06.451]  length: 1
[13:35:06.451] 
[13:35:06.451] resolved() for ‘SequentialFuture’ ...
[13:35:06.451] - state: ‘finished’
[13:35:06.451] - run: TRUE
[13:35:06.451] - result: ‘FutureResult’
[13:35:06.451] resolved() for ‘SequentialFuture’ ... done
[13:35:06.452] Future #1
[13:35:06.452] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:06.452] - nx: 1
[13:35:06.452] - relay: TRUE
[13:35:06.452] - stdout: TRUE
[13:35:06.452] - signal: TRUE
[13:35:06.452] - resignal: FALSE
[13:35:06.452] - force: TRUE
[13:35:06.452] - relayed: [n=1] FALSE
[13:35:06.452] - queued futures: [n=1] FALSE
[13:35:06.452]  - until=1
[13:35:06.452]  - relaying element #1
[13:35:06.453] - relayed: [n=1] TRUE
[13:35:06.453] - queued futures: [n=1] TRUE
[13:35:06.453] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:06.453]  length: 0 (resolved future 1)
[13:35:06.453] Relaying remaining futures
[13:35:06.453] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.453] - nx: 1
[13:35:06.453] - relay: TRUE
[13:35:06.453] - stdout: TRUE
[13:35:06.453] - signal: TRUE
[13:35:06.453] - resignal: FALSE
[13:35:06.454] - force: TRUE
[13:35:06.454] - relayed: [n=1] TRUE
[13:35:06.454] - queued futures: [n=1] TRUE
 - flush all
[13:35:06.455] - relayed: [n=1] TRUE
[13:35:06.455] - queued futures: [n=1] TRUE
[13:35:06.455] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.455] resolve() on list ... DONE
[13:35:06.455]  - Number of value chunks collected: 1
[13:35:06.455] Resolving 1 futures (chunks) ... DONE
[13:35:06.455] Reducing values from 1 chunks ...
[13:35:06.455]  - Number of values collected after concatenation: 3
[13:35:06.456]  - Number of values expected: 3
[13:35:06.456] Reducing values from 1 chunks ... DONE
[13:35:06.456] future_lapply() ... DONE
- exceptions ...
[13:35:06.456] future_lapply() ...
[13:35:06.458] Number of chunks: 1
[13:35:06.458] getGlobalsAndPackagesXApply() ...
[13:35:06.458]  - future.globals: TRUE
[13:35:06.458] getGlobalsAndPackages() ...
[13:35:06.458] Searching for globals...
[13:35:06.461] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:06.461] Searching for globals ... DONE
[13:35:06.461] Resolving globals: FALSE
[13:35:06.462] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[13:35:06.462] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:06.463] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.463] - packages: [1] ‘future.apply’
[13:35:06.463] getGlobalsAndPackages() ... DONE
[13:35:06.463]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.463]  - needed namespaces: [n=1] ‘future.apply’
[13:35:06.463] Finding globals ... DONE
[13:35:06.463]  - use_args: TRUE
[13:35:06.463]  - Getting '...' globals ...
[13:35:06.464] resolve() on list ...
[13:35:06.464]  recursive: 0
[13:35:06.464]  length: 1
[13:35:06.464]  elements: ‘...’
[13:35:06.464]  length: 0 (resolved future 1)
[13:35:06.464] resolve() on list ... DONE
[13:35:06.464]    - '...' content: [n=0] 
[13:35:06.464] List of 1
[13:35:06.464]  $ ...: list()
[13:35:06.464]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.464]  - attr(*, "where")=List of 1
[13:35:06.464]   ..$ ...:<environment: 0x5574d0e11520> 
[13:35:06.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.464]  - attr(*, "resolved")= logi TRUE
[13:35:06.464]  - attr(*, "total_size")= num NA
[13:35:06.466]  - Getting '...' globals ... DONE
[13:35:06.467] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:06.467] List of 8
[13:35:06.467]  $ ...future.FUN:function (x, ...)  
[13:35:06.467]  $ x_FUN        :function (x)  
[13:35:06.467]  $ times        : int 2
[13:35:06.467]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.467]  $ stop_if_not  :function (...)  
[13:35:06.467]  $ dim          : NULL
[13:35:06.467]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:06.467]  $ ...          : list()
[13:35:06.467]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.467]  - attr(*, "where")=List of 8
[13:35:06.467]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.467]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:06.467]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:06.467]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:06.467]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:06.467]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:06.467]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:06.467]   ..$ ...          :<environment: 0x5574d0e11520> 
[13:35:06.467]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.467]  - attr(*, "resolved")= logi FALSE
[13:35:06.467]  - attr(*, "total_size")= num 95128
[13:35:06.472] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:06.473] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.473] Number of futures (= number of chunks): 1
[13:35:06.473] Launching 1 futures (chunks) ...
[13:35:06.473] Chunk #1 of 1 ...
[13:35:06.473]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.473] getGlobalsAndPackages() ...
[13:35:06.473] Searching for globals...
[13:35:06.473] 
[13:35:06.474] Searching for globals ... DONE
[13:35:06.474] - globals: [0] <none>
[13:35:06.474] getGlobalsAndPackages() ... DONE
[13:35:06.474]    + additional globals found: [n=0] 
[13:35:06.474]    + additional namespaces needed: [n=0] 
[13:35:06.474]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.474]  - seeds: <none>
[13:35:06.474]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.474] getGlobalsAndPackages() ...
[13:35:06.474] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.475] Resolving globals: FALSE
[13:35:06.475] Tweak future expression to call with '...' arguments ...
[13:35:06.475] {
[13:35:06.475]     do.call(function(...) {
[13:35:06.475]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.475]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.475]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.475]             on.exit(options(oopts), add = TRUE)
[13:35:06.475]         }
[13:35:06.475]         {
[13:35:06.475]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.475]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.475]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.475]             })
[13:35:06.475]         }
[13:35:06.475]     }, args = future.call.arguments)
[13:35:06.475] }
[13:35:06.475] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.475] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.476] - packages: [1] ‘future.apply’
[13:35:06.476] getGlobalsAndPackages() ... DONE
[13:35:06.476] run() for ‘Future’ ...
[13:35:06.476] - state: ‘created’
[13:35:06.476] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[13:35:06.476] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.477] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[13:35:06.477]   - Field: ‘label’
[13:35:06.477]   - Field: ‘local’
[13:35:06.477]   - Field: ‘owner’
[13:35:06.477]   - Field: ‘envir’
[13:35:06.477]   - Field: ‘packages’
[13:35:06.477]   - Field: ‘gc’
[13:35:06.477]   - Field: ‘conditions’
[13:35:06.477]   - Field: ‘expr’
[13:35:06.477]   - Field: ‘uuid’
[13:35:06.477]   - Field: ‘seed’
[13:35:06.478]   - Field: ‘version’
[13:35:06.478]   - Field: ‘result’
[13:35:06.478]   - Field: ‘asynchronous’
[13:35:06.478]   - Field: ‘calls’
[13:35:06.478]   - Field: ‘globals’
[13:35:06.478]   - Field: ‘stdout’
[13:35:06.478]   - Field: ‘earlySignal’
[13:35:06.478]   - Field: ‘lazy’
[13:35:06.478]   - Field: ‘state’
[13:35:06.478] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[13:35:06.478] - Launch lazy future ...
[13:35:06.479] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.479] Packages needed by future strategies (n = 0): <none>
[13:35:06.479] {
[13:35:06.479]     {
[13:35:06.479]         {
[13:35:06.479]             ...future.startTime <- base::Sys.time()
[13:35:06.479]             {
[13:35:06.479]                 {
[13:35:06.479]                   {
[13:35:06.479]                     {
[13:35:06.479]                       base::local({
[13:35:06.479]                         has_future <- base::requireNamespace("future", 
[13:35:06.479]                           quietly = TRUE)
[13:35:06.479]                         if (has_future) {
[13:35:06.479]                           ns <- base::getNamespace("future")
[13:35:06.479]                           version <- ns[[".package"]][["version"]]
[13:35:06.479]                           if (is.null(version)) 
[13:35:06.479]                             version <- utils::packageVersion("future")
[13:35:06.479]                         }
[13:35:06.479]                         else {
[13:35:06.479]                           version <- NULL
[13:35:06.479]                         }
[13:35:06.479]                         if (!has_future || version < "1.8.0") {
[13:35:06.479]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.479]                             "", base::R.version$version.string), 
[13:35:06.479]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:06.479]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:06.479]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.479]                               "release", "version")], collapse = " "), 
[13:35:06.479]                             hostname = base::Sys.info()[["nodename"]])
[13:35:06.479]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.479]                             info)
[13:35:06.479]                           info <- base::paste(info, collapse = "; ")
[13:35:06.479]                           if (!has_future) {
[13:35:06.479]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.479]                               info)
[13:35:06.479]                           }
[13:35:06.479]                           else {
[13:35:06.479]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.479]                               info, version)
[13:35:06.479]                           }
[13:35:06.479]                           base::stop(msg)
[13:35:06.479]                         }
[13:35:06.479]                       })
[13:35:06.479]                     }
[13:35:06.479]                     base::local({
[13:35:06.479]                       for (pkg in "future.apply") {
[13:35:06.479]                         base::loadNamespace(pkg)
[13:35:06.479]                         base::library(pkg, character.only = TRUE)
[13:35:06.479]                       }
[13:35:06.479]                     })
[13:35:06.479]                   }
[13:35:06.479]                   ...future.strategy.old <- future::plan("list")
[13:35:06.479]                   options(future.plan = NULL)
[13:35:06.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.479]                 }
[13:35:06.479]                 ...future.workdir <- getwd()
[13:35:06.479]             }
[13:35:06.479]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.479]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.479]         }
[13:35:06.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.479]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:06.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.479]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.479]             base::names(...future.oldOptions))
[13:35:06.479]     }
[13:35:06.479]     if (FALSE) {
[13:35:06.479]     }
[13:35:06.479]     else {
[13:35:06.479]         if (TRUE) {
[13:35:06.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.479]                 open = "w")
[13:35:06.479]         }
[13:35:06.479]         else {
[13:35:06.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.479]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.479]         }
[13:35:06.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.479]             base::sink(type = "output", split = FALSE)
[13:35:06.479]             base::close(...future.stdout)
[13:35:06.479]         }, add = TRUE)
[13:35:06.479]     }
[13:35:06.479]     ...future.frame <- base::sys.nframe()
[13:35:06.479]     ...future.conditions <- base::list()
[13:35:06.479]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.479]     if (FALSE) {
[13:35:06.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.479]     }
[13:35:06.479]     ...future.result <- base::tryCatch({
[13:35:06.479]         base::withCallingHandlers({
[13:35:06.479]             ...future.value <- base::withVisible(base::local({
[13:35:06.479]                 do.call(function(...) {
[13:35:06.479]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.479]                   if (!identical(...future.globals.maxSize.org, 
[13:35:06.479]                     ...future.globals.maxSize)) {
[13:35:06.479]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.479]                     on.exit(options(oopts), add = TRUE)
[13:35:06.479]                   }
[13:35:06.479]                   {
[13:35:06.479]                     lapply(seq_along(...future.elements_ii), 
[13:35:06.479]                       FUN = function(jj) {
[13:35:06.479]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.479]                         ...future.FUN(...future.X_jj, ...)
[13:35:06.479]                       })
[13:35:06.479]                   }
[13:35:06.479]                 }, args = future.call.arguments)
[13:35:06.479]             }))
[13:35:06.479]             future::FutureResult(value = ...future.value$value, 
[13:35:06.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.479]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.479]                     ...future.globalenv.names))
[13:35:06.479]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.479]         }, condition = base::local({
[13:35:06.479]             c <- base::c
[13:35:06.479]             inherits <- base::inherits
[13:35:06.479]             invokeRestart <- base::invokeRestart
[13:35:06.479]             length <- base::length
[13:35:06.479]             list <- base::list
[13:35:06.479]             seq.int <- base::seq.int
[13:35:06.479]             signalCondition <- base::signalCondition
[13:35:06.479]             sys.calls <- base::sys.calls
[13:35:06.479]             `[[` <- base::`[[`
[13:35:06.479]             `+` <- base::`+`
[13:35:06.479]             `<<-` <- base::`<<-`
[13:35:06.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.479]                   3L)]
[13:35:06.479]             }
[13:35:06.479]             function(cond) {
[13:35:06.479]                 is_error <- inherits(cond, "error")
[13:35:06.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.479]                   NULL)
[13:35:06.479]                 if (is_error) {
[13:35:06.479]                   sessionInformation <- function() {
[13:35:06.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.479]                       search = base::search(), system = base::Sys.info())
[13:35:06.479]                   }
[13:35:06.479]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.479]                     cond$call), session = sessionInformation(), 
[13:35:06.479]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.479]                   signalCondition(cond)
[13:35:06.479]                 }
[13:35:06.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.479]                 "immediateCondition"))) {
[13:35:06.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.479]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.479]                   if (TRUE && !signal) {
[13:35:06.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.479]                     {
[13:35:06.479]                       inherits <- base::inherits
[13:35:06.479]                       invokeRestart <- base::invokeRestart
[13:35:06.479]                       is.null <- base::is.null
[13:35:06.479]                       muffled <- FALSE
[13:35:06.479]                       if (inherits(cond, "message")) {
[13:35:06.479]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.479]                         if (muffled) 
[13:35:06.479]                           invokeRestart("muffleMessage")
[13:35:06.479]                       }
[13:35:06.479]                       else if (inherits(cond, "warning")) {
[13:35:06.479]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.479]                         if (muffled) 
[13:35:06.479]                           invokeRestart("muffleWarning")
[13:35:06.479]                       }
[13:35:06.479]                       else if (inherits(cond, "condition")) {
[13:35:06.479]                         if (!is.null(pattern)) {
[13:35:06.479]                           computeRestarts <- base::computeRestarts
[13:35:06.479]                           grepl <- base::grepl
[13:35:06.479]                           restarts <- computeRestarts(cond)
[13:35:06.479]                           for (restart in restarts) {
[13:35:06.479]                             name <- restart$name
[13:35:06.479]                             if (is.null(name)) 
[13:35:06.479]                               next
[13:35:06.479]                             if (!grepl(pattern, name)) 
[13:35:06.479]                               next
[13:35:06.479]                             invokeRestart(restart)
[13:35:06.479]                             muffled <- TRUE
[13:35:06.479]                             break
[13:35:06.479]                           }
[13:35:06.479]                         }
[13:35:06.479]                       }
[13:35:06.479]                       invisible(muffled)
[13:35:06.479]                     }
[13:35:06.479]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.479]                   }
[13:35:06.479]                 }
[13:35:06.479]                 else {
[13:35:06.479]                   if (TRUE) {
[13:35:06.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.479]                     {
[13:35:06.479]                       inherits <- base::inherits
[13:35:06.479]                       invokeRestart <- base::invokeRestart
[13:35:06.479]                       is.null <- base::is.null
[13:35:06.479]                       muffled <- FALSE
[13:35:06.479]                       if (inherits(cond, "message")) {
[13:35:06.479]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.479]                         if (muffled) 
[13:35:06.479]                           invokeRestart("muffleMessage")
[13:35:06.479]                       }
[13:35:06.479]                       else if (inherits(cond, "warning")) {
[13:35:06.479]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.479]                         if (muffled) 
[13:35:06.479]                           invokeRestart("muffleWarning")
[13:35:06.479]                       }
[13:35:06.479]                       else if (inherits(cond, "condition")) {
[13:35:06.479]                         if (!is.null(pattern)) {
[13:35:06.479]                           computeRestarts <- base::computeRestarts
[13:35:06.479]                           grepl <- base::grepl
[13:35:06.479]                           restarts <- computeRestarts(cond)
[13:35:06.479]                           for (restart in restarts) {
[13:35:06.479]                             name <- restart$name
[13:35:06.479]                             if (is.null(name)) 
[13:35:06.479]                               next
[13:35:06.479]                             if (!grepl(pattern, name)) 
[13:35:06.479]                               next
[13:35:06.479]                             invokeRestart(restart)
[13:35:06.479]                             muffled <- TRUE
[13:35:06.479]                             break
[13:35:06.479]                           }
[13:35:06.479]                         }
[13:35:06.479]                       }
[13:35:06.479]                       invisible(muffled)
[13:35:06.479]                     }
[13:35:06.479]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.479]                   }
[13:35:06.479]                 }
[13:35:06.479]             }
[13:35:06.479]         }))
[13:35:06.479]     }, error = function(ex) {
[13:35:06.479]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.479]                 ...future.rng), started = ...future.startTime, 
[13:35:06.479]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.479]             version = "1.8"), class = "FutureResult")
[13:35:06.479]     }, finally = {
[13:35:06.479]         if (!identical(...future.workdir, getwd())) 
[13:35:06.479]             setwd(...future.workdir)
[13:35:06.479]         {
[13:35:06.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.479]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.479]             }
[13:35:06.479]             base::options(...future.oldOptions)
[13:35:06.479]             if (.Platform$OS.type == "windows") {
[13:35:06.479]                 old_names <- names(...future.oldEnvVars)
[13:35:06.479]                 envs <- base::Sys.getenv()
[13:35:06.479]                 names <- names(envs)
[13:35:06.479]                 common <- intersect(names, old_names)
[13:35:06.479]                 added <- setdiff(names, old_names)
[13:35:06.479]                 removed <- setdiff(old_names, names)
[13:35:06.479]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.479]                   envs[common]]
[13:35:06.479]                 NAMES <- toupper(changed)
[13:35:06.479]                 args <- list()
[13:35:06.479]                 for (kk in seq_along(NAMES)) {
[13:35:06.479]                   name <- changed[[kk]]
[13:35:06.479]                   NAME <- NAMES[[kk]]
[13:35:06.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.479]                     next
[13:35:06.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.479]                 }
[13:35:06.479]                 NAMES <- toupper(added)
[13:35:06.479]                 for (kk in seq_along(NAMES)) {
[13:35:06.479]                   name <- added[[kk]]
[13:35:06.479]                   NAME <- NAMES[[kk]]
[13:35:06.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.479]                     next
[13:35:06.479]                   args[[name]] <- ""
[13:35:06.479]                 }
[13:35:06.479]                 NAMES <- toupper(removed)
[13:35:06.479]                 for (kk in seq_along(NAMES)) {
[13:35:06.479]                   name <- removed[[kk]]
[13:35:06.479]                   NAME <- NAMES[[kk]]
[13:35:06.479]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.479]                     next
[13:35:06.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.479]                 }
[13:35:06.479]                 if (length(args) > 0) 
[13:35:06.479]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.479]             }
[13:35:06.479]             else {
[13:35:06.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.479]             }
[13:35:06.479]             {
[13:35:06.479]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.479]                   0L) {
[13:35:06.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.479]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.479]                   base::options(opts)
[13:35:06.479]                 }
[13:35:06.479]                 {
[13:35:06.479]                   {
[13:35:06.479]                     NULL
[13:35:06.479]                     RNGkind("Mersenne-Twister")
[13:35:06.479]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[13:35:06.479]                       inherits = FALSE)
[13:35:06.479]                   }
[13:35:06.479]                   options(future.plan = NULL)
[13:35:06.479]                   if (is.na(NA_character_)) 
[13:35:06.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.479]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.479]                     .init = FALSE)
[13:35:06.479]                 }
[13:35:06.479]             }
[13:35:06.479]         }
[13:35:06.479]     })
[13:35:06.479]     if (TRUE) {
[13:35:06.479]         base::sink(type = "output", split = FALSE)
[13:35:06.479]         if (TRUE) {
[13:35:06.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.479]         }
[13:35:06.479]         else {
[13:35:06.479]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.479]         }
[13:35:06.479]         base::close(...future.stdout)
[13:35:06.479]         ...future.stdout <- NULL
[13:35:06.479]     }
[13:35:06.479]     ...future.result$conditions <- ...future.conditions
[13:35:06.479]     ...future.result$finished <- base::Sys.time()
[13:35:06.479]     ...future.result
[13:35:06.479] }
[13:35:06.481] assign_globals() ...
[13:35:06.481] List of 11
[13:35:06.481]  $ ...future.FUN            :function (x, ...)  
[13:35:06.481]  $ x_FUN                    :function (x)  
[13:35:06.481]  $ times                    : int 2
[13:35:06.481]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.481]  $ stop_if_not              :function (...)  
[13:35:06.481]  $ dim                      : NULL
[13:35:06.481]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:06.481]  $ future.call.arguments    : list()
[13:35:06.481]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.481]  $ ...future.elements_ii    :List of 3
[13:35:06.481]   ..$ : int 1
[13:35:06.481]   ..$ : int 2
[13:35:06.481]   ..$ : int 3
[13:35:06.481]  $ ...future.seeds_ii       : NULL
[13:35:06.481]  $ ...future.globals.maxSize: NULL
[13:35:06.481]  - attr(*, "where")=List of 11
[13:35:06.481]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.481]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.481]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.481]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.481]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.481]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.481]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.481]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.481]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.481]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.481]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.481]  - attr(*, "resolved")= logi FALSE
[13:35:06.481]  - attr(*, "total_size")= num 95128
[13:35:06.481]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.481]  - attr(*, "already-done")= logi TRUE
[13:35:06.488] - copied ‘...future.FUN’ to environment
[13:35:06.488] - copied ‘x_FUN’ to environment
[13:35:06.488] - copied ‘times’ to environment
[13:35:06.488] - copied ‘stopf’ to environment
[13:35:06.488] - copied ‘stop_if_not’ to environment
[13:35:06.489] - copied ‘dim’ to environment
[13:35:06.489] - copied ‘valid_types’ to environment
[13:35:06.489] - copied ‘future.call.arguments’ to environment
[13:35:06.489] - copied ‘...future.elements_ii’ to environment
[13:35:06.489] - copied ‘...future.seeds_ii’ to environment
[13:35:06.489] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.489] assign_globals() ... done
[13:35:06.489] plan(): Setting new future strategy stack:
[13:35:06.490] List of future strategies:
[13:35:06.490] 1. sequential:
[13:35:06.490]    - args: function (..., envir = parent.frame())
[13:35:06.490]    - tweaked: FALSE
[13:35:06.490]    - call: NULL
[13:35:06.490] plan(): nbrOfWorkers() = 1
[13:35:06.491] plan(): Setting new future strategy stack:
[13:35:06.491] List of future strategies:
[13:35:06.491] 1. sequential:
[13:35:06.491]    - args: function (..., envir = parent.frame())
[13:35:06.491]    - tweaked: FALSE
[13:35:06.491]    - call: plan(strategy)
[13:35:06.491] plan(): nbrOfWorkers() = 1
[13:35:06.491] SequentialFuture started (and completed)
[13:35:06.491] signalConditions() ...
[13:35:06.492]  - include = ‘immediateCondition’
[13:35:06.493]  - exclude = 
[13:35:06.493]  - resignal = FALSE
[13:35:06.493]  - Number of conditions: 1
[13:35:06.493] signalConditions() ... done
[13:35:06.493] - Launch lazy future ... done
[13:35:06.493] run() for ‘SequentialFuture’ ... done
[13:35:06.493] Created future:
[13:35:06.493] SequentialFuture:
[13:35:06.493] Label: ‘future_vapply-1’
[13:35:06.493] Expression:
[13:35:06.493] {
[13:35:06.493]     do.call(function(...) {
[13:35:06.493]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.493]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.493]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.493]             on.exit(options(oopts), add = TRUE)
[13:35:06.493]         }
[13:35:06.493]         {
[13:35:06.493]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.493]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.493]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.493]             })
[13:35:06.493]         }
[13:35:06.493]     }, args = future.call.arguments)
[13:35:06.493] }
[13:35:06.493] Lazy evaluation: FALSE
[13:35:06.493] Asynchronous evaluation: FALSE
[13:35:06.493] Local evaluation: TRUE
[13:35:06.493] Environment: R_GlobalEnv
[13:35:06.493] Capture standard output: TRUE
[13:35:06.493] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.493] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.493] Packages: 1 packages (‘future.apply’)
[13:35:06.493] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.493] Resolved: TRUE
[13:35:06.493] Value: 0 bytes of class ‘NULL’
[13:35:06.493] Conditions captured: [n=1] ‘simpleError’
[13:35:06.493] Early signaling: FALSE
[13:35:06.493] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.493] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[13:35:06.494] Chunk #1 of 1 ... DONE
[13:35:06.494] Launching 1 futures (chunks) ... DONE
[13:35:06.494] Resolving 1 futures (chunks) ...
[13:35:06.495] resolve() on list ...
[13:35:06.495]  recursive: 0
[13:35:06.495]  length: 1
[13:35:06.495] 
[13:35:06.495] resolved() for ‘SequentialFuture’ ...
[13:35:06.495] - state: ‘finished’
[13:35:06.495] - run: TRUE
[13:35:06.495] - result: ‘FutureResult’
[13:35:06.495] resolved() for ‘SequentialFuture’ ... done
[13:35:06.495] Future #1
[13:35:06.495] signalConditions() ...
[13:35:06.496]  - include = ‘immediateCondition’
[13:35:06.496]  - exclude = 
[13:35:06.496]  - resignal = FALSE
[13:35:06.496]  - Number of conditions: 1
[13:35:06.496] signalConditions() ... done
[13:35:06.496] signalConditionsASAP(SequentialFuture, pos=1) ...
[13:35:06.496] - nx: 1
[13:35:06.496] - relay: TRUE
[13:35:06.496] - stdout: TRUE
[13:35:06.496] - signal: TRUE
[13:35:06.496] - resignal: FALSE
[13:35:06.496] - force: TRUE
[13:35:06.497] - relayed: [n=1] FALSE
[13:35:06.497] - queued futures: [n=1] FALSE
[13:35:06.497]  - until=1
[13:35:06.497]  - relaying element #1
[13:35:06.497] signalConditions() ...
[13:35:06.497]  - include = ‘immediateCondition’
[13:35:06.497]  - exclude = 
[13:35:06.497]  - resignal = FALSE
[13:35:06.497]  - Number of conditions: 1
[13:35:06.497] signalConditions() ... done
[13:35:06.498] signalConditions() ...
[13:35:06.498]  - include = ‘immediateCondition’
[13:35:06.498]  - exclude = 
[13:35:06.498]  - resignal = FALSE
[13:35:06.498]  - Number of conditions: 1
[13:35:06.498] signalConditions() ... done
[13:35:06.498] signalConditions() ...
[13:35:06.498]  - include = ‘condition’
[13:35:06.498]  - exclude = ‘immediateCondition’
[13:35:06.498]  - resignal = TRUE
[13:35:06.498]  - Number of conditions: 1
[13:35:06.498]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:35:06.499] signalConditions() ... done
[13:35:06.499] - relayed: [n=1] FALSE
[13:35:06.499] - queued futures: [n=1] TRUE
[13:35:06.499] signalConditionsASAP(SequentialFuture, pos=1) ... done
[13:35:06.499] plan(): Setting new future strategy stack:
[13:35:06.499] List of future strategies:
[13:35:06.499] 1. sequential:
[13:35:06.499]    - args: function (..., envir = parent.frame())
[13:35:06.499]    - tweaked: FALSE
[13:35:06.499]    - call: plan(sequential)
[13:35:06.499] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[13:35:06.500] plan(): Setting new future strategy stack:
[13:35:06.500] List of future strategies:
[13:35:06.500] 1. multicore:
[13:35:06.500]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:06.500]    - tweaked: FALSE
[13:35:06.500]    - call: plan(strategy)
[13:35:06.504] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[13:35:06.506] future_lapply() ...
[13:35:06.512] Number of chunks: 2
[13:35:06.512] getGlobalsAndPackagesXApply() ...
[13:35:06.512]  - future.globals: TRUE
[13:35:06.512] getGlobalsAndPackages() ...
[13:35:06.512] Searching for globals...
[13:35:06.515] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:06.515] Searching for globals ... DONE
[13:35:06.515] Resolving globals: FALSE
[13:35:06.518] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[13:35:06.519] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:06.519] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.519] - packages: [1] ‘future.apply’
[13:35:06.519] getGlobalsAndPackages() ... DONE
[13:35:06.519]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.519]  - needed namespaces: [n=1] ‘future.apply’
[13:35:06.519] Finding globals ... DONE
[13:35:06.519]  - use_args: TRUE
[13:35:06.519]  - Getting '...' globals ...
[13:35:06.520] resolve() on list ...
[13:35:06.520]  recursive: 0
[13:35:06.520]  length: 1
[13:35:06.520]  elements: ‘...’
[13:35:06.520]  length: 0 (resolved future 1)
[13:35:06.520] resolve() on list ... DONE
[13:35:06.520]    - '...' content: [n=0] 
[13:35:06.520] List of 1
[13:35:06.520]  $ ...: list()
[13:35:06.520]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.520]  - attr(*, "where")=List of 1
[13:35:06.520]   ..$ ...:<environment: 0x5574d068d218> 
[13:35:06.520]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.520]  - attr(*, "resolved")= logi TRUE
[13:35:06.520]  - attr(*, "total_size")= num NA
[13:35:06.523]  - Getting '...' globals ... DONE
[13:35:06.523] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:06.523] List of 8
[13:35:06.523]  $ ...future.FUN:function (x, ...)  
[13:35:06.523]  $ x_FUN        :function (x)  
[13:35:06.523]  $ times        : int 1
[13:35:06.523]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.523]  $ stop_if_not  :function (...)  
[13:35:06.523]  $ dim          : NULL
[13:35:06.523]  $ valid_types  : chr "character"
[13:35:06.523]  $ ...          : list()
[13:35:06.523]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.523]  - attr(*, "where")=List of 8
[13:35:06.523]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.523]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:06.523]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:06.523]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:06.523]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:06.523]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:06.523]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:06.523]   ..$ ...          :<environment: 0x5574d068d218> 
[13:35:06.523]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.523]  - attr(*, "resolved")= logi FALSE
[13:35:06.523]  - attr(*, "total_size")= num 94208
[13:35:06.528] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:06.528] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.529] Number of futures (= number of chunks): 2
[13:35:06.529] Launching 2 futures (chunks) ...
[13:35:06.529] Chunk #1 of 2 ...
[13:35:06.529]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.529] getGlobalsAndPackages() ...
[13:35:06.529] Searching for globals...
[13:35:06.529] 
[13:35:06.529] Searching for globals ... DONE
[13:35:06.530] - globals: [0] <none>
[13:35:06.530] getGlobalsAndPackages() ... DONE
[13:35:06.530]    + additional globals found: [n=0] 
[13:35:06.530]    + additional namespaces needed: [n=0] 
[13:35:06.530]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.530]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:06.530]  - seeds: <none>
[13:35:06.530]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.530] getGlobalsAndPackages() ...
[13:35:06.530] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.530] Resolving globals: FALSE
[13:35:06.531] Tweak future expression to call with '...' arguments ...
[13:35:06.531] {
[13:35:06.531]     do.call(function(...) {
[13:35:06.531]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.531]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.531]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.531]             on.exit(options(oopts), add = TRUE)
[13:35:06.531]         }
[13:35:06.531]         {
[13:35:06.531]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.531]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.531]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.531]             })
[13:35:06.531]         }
[13:35:06.531]     }, args = future.call.arguments)
[13:35:06.531] }
[13:35:06.531] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.531] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.532] - packages: [1] ‘future.apply’
[13:35:06.532] getGlobalsAndPackages() ... DONE
[13:35:06.532] run() for ‘Future’ ...
[13:35:06.532] - state: ‘created’
[13:35:06.532] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:06.536] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.536] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:06.536]   - Field: ‘label’
[13:35:06.536]   - Field: ‘local’
[13:35:06.536]   - Field: ‘owner’
[13:35:06.536]   - Field: ‘envir’
[13:35:06.536]   - Field: ‘workers’
[13:35:06.536]   - Field: ‘packages’
[13:35:06.536]   - Field: ‘gc’
[13:35:06.537]   - Field: ‘job’
[13:35:06.537]   - Field: ‘conditions’
[13:35:06.537]   - Field: ‘expr’
[13:35:06.537]   - Field: ‘uuid’
[13:35:06.537]   - Field: ‘seed’
[13:35:06.537]   - Field: ‘version’
[13:35:06.537]   - Field: ‘result’
[13:35:06.537]   - Field: ‘asynchronous’
[13:35:06.537]   - Field: ‘calls’
[13:35:06.537]   - Field: ‘globals’
[13:35:06.537]   - Field: ‘stdout’
[13:35:06.538]   - Field: ‘earlySignal’
[13:35:06.538]   - Field: ‘lazy’
[13:35:06.538]   - Field: ‘state’
[13:35:06.538] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:06.538] - Launch lazy future ...
[13:35:06.539] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.539] Packages needed by future strategies (n = 0): <none>
[13:35:06.540] {
[13:35:06.540]     {
[13:35:06.540]         {
[13:35:06.540]             ...future.startTime <- base::Sys.time()
[13:35:06.540]             {
[13:35:06.540]                 {
[13:35:06.540]                   {
[13:35:06.540]                     {
[13:35:06.540]                       {
[13:35:06.540]                         base::local({
[13:35:06.540]                           has_future <- base::requireNamespace("future", 
[13:35:06.540]                             quietly = TRUE)
[13:35:06.540]                           if (has_future) {
[13:35:06.540]                             ns <- base::getNamespace("future")
[13:35:06.540]                             version <- ns[[".package"]][["version"]]
[13:35:06.540]                             if (is.null(version)) 
[13:35:06.540]                               version <- utils::packageVersion("future")
[13:35:06.540]                           }
[13:35:06.540]                           else {
[13:35:06.540]                             version <- NULL
[13:35:06.540]                           }
[13:35:06.540]                           if (!has_future || version < "1.8.0") {
[13:35:06.540]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.540]                               "", base::R.version$version.string), 
[13:35:06.540]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:06.540]                                 base::R.version$platform, 8 * 
[13:35:06.540]                                   base::.Machine$sizeof.pointer), 
[13:35:06.540]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.540]                                 "release", "version")], collapse = " "), 
[13:35:06.540]                               hostname = base::Sys.info()[["nodename"]])
[13:35:06.540]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.540]                               info)
[13:35:06.540]                             info <- base::paste(info, collapse = "; ")
[13:35:06.540]                             if (!has_future) {
[13:35:06.540]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.540]                                 info)
[13:35:06.540]                             }
[13:35:06.540]                             else {
[13:35:06.540]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.540]                                 info, version)
[13:35:06.540]                             }
[13:35:06.540]                             base::stop(msg)
[13:35:06.540]                           }
[13:35:06.540]                         })
[13:35:06.540]                       }
[13:35:06.540]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:06.540]                       base::options(mc.cores = 1L)
[13:35:06.540]                     }
[13:35:06.540]                     base::local({
[13:35:06.540]                       for (pkg in "future.apply") {
[13:35:06.540]                         base::loadNamespace(pkg)
[13:35:06.540]                         base::library(pkg, character.only = TRUE)
[13:35:06.540]                       }
[13:35:06.540]                     })
[13:35:06.540]                   }
[13:35:06.540]                   ...future.strategy.old <- future::plan("list")
[13:35:06.540]                   options(future.plan = NULL)
[13:35:06.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.540]                 }
[13:35:06.540]                 ...future.workdir <- getwd()
[13:35:06.540]             }
[13:35:06.540]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.540]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.540]         }
[13:35:06.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.540]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:06.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.540]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.540]             base::names(...future.oldOptions))
[13:35:06.540]     }
[13:35:06.540]     if (FALSE) {
[13:35:06.540]     }
[13:35:06.540]     else {
[13:35:06.540]         if (TRUE) {
[13:35:06.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.540]                 open = "w")
[13:35:06.540]         }
[13:35:06.540]         else {
[13:35:06.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.540]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.540]         }
[13:35:06.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.540]             base::sink(type = "output", split = FALSE)
[13:35:06.540]             base::close(...future.stdout)
[13:35:06.540]         }, add = TRUE)
[13:35:06.540]     }
[13:35:06.540]     ...future.frame <- base::sys.nframe()
[13:35:06.540]     ...future.conditions <- base::list()
[13:35:06.540]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.540]     if (FALSE) {
[13:35:06.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.540]     }
[13:35:06.540]     ...future.result <- base::tryCatch({
[13:35:06.540]         base::withCallingHandlers({
[13:35:06.540]             ...future.value <- base::withVisible(base::local({
[13:35:06.540]                 withCallingHandlers({
[13:35:06.540]                   {
[13:35:06.540]                     do.call(function(...) {
[13:35:06.540]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.540]                       if (!identical(...future.globals.maxSize.org, 
[13:35:06.540]                         ...future.globals.maxSize)) {
[13:35:06.540]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.540]                         on.exit(options(oopts), add = TRUE)
[13:35:06.540]                       }
[13:35:06.540]                       {
[13:35:06.540]                         lapply(seq_along(...future.elements_ii), 
[13:35:06.540]                           FUN = function(jj) {
[13:35:06.540]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.540]                             ...future.FUN(...future.X_jj, ...)
[13:35:06.540]                           })
[13:35:06.540]                       }
[13:35:06.540]                     }, args = future.call.arguments)
[13:35:06.540]                   }
[13:35:06.540]                 }, immediateCondition = function(cond) {
[13:35:06.540]                   save_rds <- function (object, pathname, ...) 
[13:35:06.540]                   {
[13:35:06.540]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:06.540]                     if (file_test("-f", pathname_tmp)) {
[13:35:06.540]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.540]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:06.540]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.540]                         fi_tmp[["mtime"]])
[13:35:06.540]                     }
[13:35:06.540]                     tryCatch({
[13:35:06.540]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:06.540]                     }, error = function(ex) {
[13:35:06.540]                       msg <- conditionMessage(ex)
[13:35:06.540]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.540]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:06.540]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.540]                         fi_tmp[["mtime"]], msg)
[13:35:06.540]                       ex$message <- msg
[13:35:06.540]                       stop(ex)
[13:35:06.540]                     })
[13:35:06.540]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:06.540]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:06.540]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:06.540]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.540]                       fi <- file.info(pathname)
[13:35:06.540]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:06.540]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.540]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:06.540]                         fi[["size"]], fi[["mtime"]])
[13:35:06.540]                       stop(msg)
[13:35:06.540]                     }
[13:35:06.540]                     invisible(pathname)
[13:35:06.540]                   }
[13:35:06.540]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:06.540]                     rootPath = tempdir()) 
[13:35:06.540]                   {
[13:35:06.540]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:06.540]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:06.540]                       tmpdir = path, fileext = ".rds")
[13:35:06.540]                     save_rds(obj, file)
[13:35:06.540]                   }
[13:35:06.540]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:06.540]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.540]                   {
[13:35:06.540]                     inherits <- base::inherits
[13:35:06.540]                     invokeRestart <- base::invokeRestart
[13:35:06.540]                     is.null <- base::is.null
[13:35:06.540]                     muffled <- FALSE
[13:35:06.540]                     if (inherits(cond, "message")) {
[13:35:06.540]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:06.540]                       if (muffled) 
[13:35:06.540]                         invokeRestart("muffleMessage")
[13:35:06.540]                     }
[13:35:06.540]                     else if (inherits(cond, "warning")) {
[13:35:06.540]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:06.540]                       if (muffled) 
[13:35:06.540]                         invokeRestart("muffleWarning")
[13:35:06.540]                     }
[13:35:06.540]                     else if (inherits(cond, "condition")) {
[13:35:06.540]                       if (!is.null(pattern)) {
[13:35:06.540]                         computeRestarts <- base::computeRestarts
[13:35:06.540]                         grepl <- base::grepl
[13:35:06.540]                         restarts <- computeRestarts(cond)
[13:35:06.540]                         for (restart in restarts) {
[13:35:06.540]                           name <- restart$name
[13:35:06.540]                           if (is.null(name)) 
[13:35:06.540]                             next
[13:35:06.540]                           if (!grepl(pattern, name)) 
[13:35:06.540]                             next
[13:35:06.540]                           invokeRestart(restart)
[13:35:06.540]                           muffled <- TRUE
[13:35:06.540]                           break
[13:35:06.540]                         }
[13:35:06.540]                       }
[13:35:06.540]                     }
[13:35:06.540]                     invisible(muffled)
[13:35:06.540]                   }
[13:35:06.540]                   muffleCondition(cond)
[13:35:06.540]                 })
[13:35:06.540]             }))
[13:35:06.540]             future::FutureResult(value = ...future.value$value, 
[13:35:06.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.540]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.540]                     ...future.globalenv.names))
[13:35:06.540]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.540]         }, condition = base::local({
[13:35:06.540]             c <- base::c
[13:35:06.540]             inherits <- base::inherits
[13:35:06.540]             invokeRestart <- base::invokeRestart
[13:35:06.540]             length <- base::length
[13:35:06.540]             list <- base::list
[13:35:06.540]             seq.int <- base::seq.int
[13:35:06.540]             signalCondition <- base::signalCondition
[13:35:06.540]             sys.calls <- base::sys.calls
[13:35:06.540]             `[[` <- base::`[[`
[13:35:06.540]             `+` <- base::`+`
[13:35:06.540]             `<<-` <- base::`<<-`
[13:35:06.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.540]                   3L)]
[13:35:06.540]             }
[13:35:06.540]             function(cond) {
[13:35:06.540]                 is_error <- inherits(cond, "error")
[13:35:06.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.540]                   NULL)
[13:35:06.540]                 if (is_error) {
[13:35:06.540]                   sessionInformation <- function() {
[13:35:06.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.540]                       search = base::search(), system = base::Sys.info())
[13:35:06.540]                   }
[13:35:06.540]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.540]                     cond$call), session = sessionInformation(), 
[13:35:06.540]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.540]                   signalCondition(cond)
[13:35:06.540]                 }
[13:35:06.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.540]                 "immediateCondition"))) {
[13:35:06.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.540]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.540]                   if (TRUE && !signal) {
[13:35:06.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.540]                     {
[13:35:06.540]                       inherits <- base::inherits
[13:35:06.540]                       invokeRestart <- base::invokeRestart
[13:35:06.540]                       is.null <- base::is.null
[13:35:06.540]                       muffled <- FALSE
[13:35:06.540]                       if (inherits(cond, "message")) {
[13:35:06.540]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.540]                         if (muffled) 
[13:35:06.540]                           invokeRestart("muffleMessage")
[13:35:06.540]                       }
[13:35:06.540]                       else if (inherits(cond, "warning")) {
[13:35:06.540]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.540]                         if (muffled) 
[13:35:06.540]                           invokeRestart("muffleWarning")
[13:35:06.540]                       }
[13:35:06.540]                       else if (inherits(cond, "condition")) {
[13:35:06.540]                         if (!is.null(pattern)) {
[13:35:06.540]                           computeRestarts <- base::computeRestarts
[13:35:06.540]                           grepl <- base::grepl
[13:35:06.540]                           restarts <- computeRestarts(cond)
[13:35:06.540]                           for (restart in restarts) {
[13:35:06.540]                             name <- restart$name
[13:35:06.540]                             if (is.null(name)) 
[13:35:06.540]                               next
[13:35:06.540]                             if (!grepl(pattern, name)) 
[13:35:06.540]                               next
[13:35:06.540]                             invokeRestart(restart)
[13:35:06.540]                             muffled <- TRUE
[13:35:06.540]                             break
[13:35:06.540]                           }
[13:35:06.540]                         }
[13:35:06.540]                       }
[13:35:06.540]                       invisible(muffled)
[13:35:06.540]                     }
[13:35:06.540]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.540]                   }
[13:35:06.540]                 }
[13:35:06.540]                 else {
[13:35:06.540]                   if (TRUE) {
[13:35:06.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.540]                     {
[13:35:06.540]                       inherits <- base::inherits
[13:35:06.540]                       invokeRestart <- base::invokeRestart
[13:35:06.540]                       is.null <- base::is.null
[13:35:06.540]                       muffled <- FALSE
[13:35:06.540]                       if (inherits(cond, "message")) {
[13:35:06.540]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.540]                         if (muffled) 
[13:35:06.540]                           invokeRestart("muffleMessage")
[13:35:06.540]                       }
[13:35:06.540]                       else if (inherits(cond, "warning")) {
[13:35:06.540]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.540]                         if (muffled) 
[13:35:06.540]                           invokeRestart("muffleWarning")
[13:35:06.540]                       }
[13:35:06.540]                       else if (inherits(cond, "condition")) {
[13:35:06.540]                         if (!is.null(pattern)) {
[13:35:06.540]                           computeRestarts <- base::computeRestarts
[13:35:06.540]                           grepl <- base::grepl
[13:35:06.540]                           restarts <- computeRestarts(cond)
[13:35:06.540]                           for (restart in restarts) {
[13:35:06.540]                             name <- restart$name
[13:35:06.540]                             if (is.null(name)) 
[13:35:06.540]                               next
[13:35:06.540]                             if (!grepl(pattern, name)) 
[13:35:06.540]                               next
[13:35:06.540]                             invokeRestart(restart)
[13:35:06.540]                             muffled <- TRUE
[13:35:06.540]                             break
[13:35:06.540]                           }
[13:35:06.540]                         }
[13:35:06.540]                       }
[13:35:06.540]                       invisible(muffled)
[13:35:06.540]                     }
[13:35:06.540]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.540]                   }
[13:35:06.540]                 }
[13:35:06.540]             }
[13:35:06.540]         }))
[13:35:06.540]     }, error = function(ex) {
[13:35:06.540]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.540]                 ...future.rng), started = ...future.startTime, 
[13:35:06.540]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.540]             version = "1.8"), class = "FutureResult")
[13:35:06.540]     }, finally = {
[13:35:06.540]         if (!identical(...future.workdir, getwd())) 
[13:35:06.540]             setwd(...future.workdir)
[13:35:06.540]         {
[13:35:06.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.540]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.540]             }
[13:35:06.540]             base::options(...future.oldOptions)
[13:35:06.540]             if (.Platform$OS.type == "windows") {
[13:35:06.540]                 old_names <- names(...future.oldEnvVars)
[13:35:06.540]                 envs <- base::Sys.getenv()
[13:35:06.540]                 names <- names(envs)
[13:35:06.540]                 common <- intersect(names, old_names)
[13:35:06.540]                 added <- setdiff(names, old_names)
[13:35:06.540]                 removed <- setdiff(old_names, names)
[13:35:06.540]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.540]                   envs[common]]
[13:35:06.540]                 NAMES <- toupper(changed)
[13:35:06.540]                 args <- list()
[13:35:06.540]                 for (kk in seq_along(NAMES)) {
[13:35:06.540]                   name <- changed[[kk]]
[13:35:06.540]                   NAME <- NAMES[[kk]]
[13:35:06.540]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.540]                     next
[13:35:06.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.540]                 }
[13:35:06.540]                 NAMES <- toupper(added)
[13:35:06.540]                 for (kk in seq_along(NAMES)) {
[13:35:06.540]                   name <- added[[kk]]
[13:35:06.540]                   NAME <- NAMES[[kk]]
[13:35:06.540]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.540]                     next
[13:35:06.540]                   args[[name]] <- ""
[13:35:06.540]                 }
[13:35:06.540]                 NAMES <- toupper(removed)
[13:35:06.540]                 for (kk in seq_along(NAMES)) {
[13:35:06.540]                   name <- removed[[kk]]
[13:35:06.540]                   NAME <- NAMES[[kk]]
[13:35:06.540]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.540]                     next
[13:35:06.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.540]                 }
[13:35:06.540]                 if (length(args) > 0) 
[13:35:06.540]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.540]             }
[13:35:06.540]             else {
[13:35:06.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.540]             }
[13:35:06.540]             {
[13:35:06.540]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.540]                   0L) {
[13:35:06.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.540]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.540]                   base::options(opts)
[13:35:06.540]                 }
[13:35:06.540]                 {
[13:35:06.540]                   {
[13:35:06.540]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:06.540]                     NULL
[13:35:06.540]                   }
[13:35:06.540]                   options(future.plan = NULL)
[13:35:06.540]                   if (is.na(NA_character_)) 
[13:35:06.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.540]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.540]                     .init = FALSE)
[13:35:06.540]                 }
[13:35:06.540]             }
[13:35:06.540]         }
[13:35:06.540]     })
[13:35:06.540]     if (TRUE) {
[13:35:06.540]         base::sink(type = "output", split = FALSE)
[13:35:06.540]         if (TRUE) {
[13:35:06.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.540]         }
[13:35:06.540]         else {
[13:35:06.540]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.540]         }
[13:35:06.540]         base::close(...future.stdout)
[13:35:06.540]         ...future.stdout <- NULL
[13:35:06.540]     }
[13:35:06.540]     ...future.result$conditions <- ...future.conditions
[13:35:06.540]     ...future.result$finished <- base::Sys.time()
[13:35:06.540]     ...future.result
[13:35:06.540] }
[13:35:06.542] assign_globals() ...
[13:35:06.542] List of 11
[13:35:06.542]  $ ...future.FUN            :function (x, ...)  
[13:35:06.542]  $ x_FUN                    :function (x)  
[13:35:06.542]  $ times                    : int 1
[13:35:06.542]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.542]  $ stop_if_not              :function (...)  
[13:35:06.542]  $ dim                      : NULL
[13:35:06.542]  $ valid_types              : chr "character"
[13:35:06.542]  $ future.call.arguments    : list()
[13:35:06.542]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.542]  $ ...future.elements_ii    :List of 1
[13:35:06.542]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:35:06.542]  $ ...future.seeds_ii       : NULL
[13:35:06.542]  $ ...future.globals.maxSize: NULL
[13:35:06.542]  - attr(*, "where")=List of 11
[13:35:06.542]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.542]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.542]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.542]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.542]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.542]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.542]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.542]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.542]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.542]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.542]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.542]  - attr(*, "resolved")= logi FALSE
[13:35:06.542]  - attr(*, "total_size")= num 94208
[13:35:06.542]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.542]  - attr(*, "already-done")= logi TRUE
[13:35:06.551] - copied ‘...future.FUN’ to environment
[13:35:06.551] - copied ‘x_FUN’ to environment
[13:35:06.551] - copied ‘times’ to environment
[13:35:06.551] - copied ‘stopf’ to environment
[13:35:06.551] - copied ‘stop_if_not’ to environment
[13:35:06.551] - copied ‘dim’ to environment
[13:35:06.551] - copied ‘valid_types’ to environment
[13:35:06.551] - copied ‘future.call.arguments’ to environment
[13:35:06.552] - copied ‘...future.elements_ii’ to environment
[13:35:06.552] - copied ‘...future.seeds_ii’ to environment
[13:35:06.552] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.552] assign_globals() ... done
[13:35:06.552] requestCore(): workers = 2
[13:35:06.555] MulticoreFuture started
[13:35:06.556] - Launch lazy future ... done
[13:35:06.556] run() for ‘MulticoreFuture’ ... done
[13:35:06.556] Created future:
[13:35:06.556] plan(): Setting new future strategy stack:
[13:35:06.557] List of future strategies:
[13:35:06.557] 1. sequential:
[13:35:06.557]    - args: function (..., envir = parent.frame())
[13:35:06.557]    - tweaked: FALSE
[13:35:06.557]    - call: NULL
[13:35:06.558] plan(): nbrOfWorkers() = 1
[13:35:06.560] plan(): Setting new future strategy stack:
[13:35:06.560] List of future strategies:
[13:35:06.560] 1. multicore:
[13:35:06.560]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:06.560]    - tweaked: FALSE
[13:35:06.560]    - call: plan(strategy)
[13:35:06.565] plan(): nbrOfWorkers() = 2
[13:35:06.557] MulticoreFuture:
[13:35:06.557] Label: ‘future_vapply-1’
[13:35:06.557] Expression:
[13:35:06.557] {
[13:35:06.557]     do.call(function(...) {
[13:35:06.557]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.557]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.557]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.557]             on.exit(options(oopts), add = TRUE)
[13:35:06.557]         }
[13:35:06.557]         {
[13:35:06.557]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.557]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.557]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.557]             })
[13:35:06.557]         }
[13:35:06.557]     }, args = future.call.arguments)
[13:35:06.557] }
[13:35:06.557] Lazy evaluation: FALSE
[13:35:06.557] Asynchronous evaluation: TRUE
[13:35:06.557] Local evaluation: TRUE
[13:35:06.557] Environment: R_GlobalEnv
[13:35:06.557] Capture standard output: TRUE
[13:35:06.557] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.557] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.557] Packages: 1 packages (‘future.apply’)
[13:35:06.557] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.557] Resolved: TRUE
[13:35:06.557] Value: <not collected>
[13:35:06.557] Conditions captured: <none>
[13:35:06.557] Early signaling: FALSE
[13:35:06.557] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.557] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.567] Chunk #1 of 2 ... DONE
[13:35:06.567] Chunk #2 of 2 ...
[13:35:06.567]  - Finding globals in 'X' for chunk #2 ...
[13:35:06.567] getGlobalsAndPackages() ...
[13:35:06.567] Searching for globals...
[13:35:06.568] 
[13:35:06.568] Searching for globals ... DONE
[13:35:06.568] - globals: [0] <none>
[13:35:06.568] getGlobalsAndPackages() ... DONE
[13:35:06.568]    + additional globals found: [n=0] 
[13:35:06.569]    + additional namespaces needed: [n=0] 
[13:35:06.569]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:06.569]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:06.569]  - seeds: <none>
[13:35:06.569]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.569] getGlobalsAndPackages() ...
[13:35:06.569] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.570] Resolving globals: FALSE
[13:35:06.570] Tweak future expression to call with '...' arguments ...
[13:35:06.570] {
[13:35:06.570]     do.call(function(...) {
[13:35:06.570]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.570]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.570]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.570]             on.exit(options(oopts), add = TRUE)
[13:35:06.570]         }
[13:35:06.570]         {
[13:35:06.570]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.570]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.570]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.570]             })
[13:35:06.570]         }
[13:35:06.570]     }, args = future.call.arguments)
[13:35:06.570] }
[13:35:06.570] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.571] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.571] - packages: [1] ‘future.apply’
[13:35:06.572] getGlobalsAndPackages() ... DONE
[13:35:06.572] run() for ‘Future’ ...
[13:35:06.572] - state: ‘created’
[13:35:06.572] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:06.577] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.577] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:06.577]   - Field: ‘label’
[13:35:06.577]   - Field: ‘local’
[13:35:06.577]   - Field: ‘owner’
[13:35:06.578]   - Field: ‘envir’
[13:35:06.578]   - Field: ‘workers’
[13:35:06.578]   - Field: ‘packages’
[13:35:06.578]   - Field: ‘gc’
[13:35:06.578]   - Field: ‘job’
[13:35:06.578]   - Field: ‘conditions’
[13:35:06.578]   - Field: ‘expr’
[13:35:06.579]   - Field: ‘uuid’
[13:35:06.579]   - Field: ‘seed’
[13:35:06.579]   - Field: ‘version’
[13:35:06.579]   - Field: ‘result’
[13:35:06.579]   - Field: ‘asynchronous’
[13:35:06.579]   - Field: ‘calls’
[13:35:06.579]   - Field: ‘globals’
[13:35:06.580]   - Field: ‘stdout’
[13:35:06.580]   - Field: ‘earlySignal’
[13:35:06.580]   - Field: ‘lazy’
[13:35:06.580]   - Field: ‘state’
[13:35:06.580] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:06.580] - Launch lazy future ...
[13:35:06.581] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.581] Packages needed by future strategies (n = 0): <none>
[13:35:06.582] {
[13:35:06.582]     {
[13:35:06.582]         {
[13:35:06.582]             ...future.startTime <- base::Sys.time()
[13:35:06.582]             {
[13:35:06.582]                 {
[13:35:06.582]                   {
[13:35:06.582]                     {
[13:35:06.582]                       {
[13:35:06.582]                         base::local({
[13:35:06.582]                           has_future <- base::requireNamespace("future", 
[13:35:06.582]                             quietly = TRUE)
[13:35:06.582]                           if (has_future) {
[13:35:06.582]                             ns <- base::getNamespace("future")
[13:35:06.582]                             version <- ns[[".package"]][["version"]]
[13:35:06.582]                             if (is.null(version)) 
[13:35:06.582]                               version <- utils::packageVersion("future")
[13:35:06.582]                           }
[13:35:06.582]                           else {
[13:35:06.582]                             version <- NULL
[13:35:06.582]                           }
[13:35:06.582]                           if (!has_future || version < "1.8.0") {
[13:35:06.582]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.582]                               "", base::R.version$version.string), 
[13:35:06.582]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:06.582]                                 base::R.version$platform, 8 * 
[13:35:06.582]                                   base::.Machine$sizeof.pointer), 
[13:35:06.582]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.582]                                 "release", "version")], collapse = " "), 
[13:35:06.582]                               hostname = base::Sys.info()[["nodename"]])
[13:35:06.582]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.582]                               info)
[13:35:06.582]                             info <- base::paste(info, collapse = "; ")
[13:35:06.582]                             if (!has_future) {
[13:35:06.582]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.582]                                 info)
[13:35:06.582]                             }
[13:35:06.582]                             else {
[13:35:06.582]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.582]                                 info, version)
[13:35:06.582]                             }
[13:35:06.582]                             base::stop(msg)
[13:35:06.582]                           }
[13:35:06.582]                         })
[13:35:06.582]                       }
[13:35:06.582]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:06.582]                       base::options(mc.cores = 1L)
[13:35:06.582]                     }
[13:35:06.582]                     base::local({
[13:35:06.582]                       for (pkg in "future.apply") {
[13:35:06.582]                         base::loadNamespace(pkg)
[13:35:06.582]                         base::library(pkg, character.only = TRUE)
[13:35:06.582]                       }
[13:35:06.582]                     })
[13:35:06.582]                   }
[13:35:06.582]                   ...future.strategy.old <- future::plan("list")
[13:35:06.582]                   options(future.plan = NULL)
[13:35:06.582]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.582]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.582]                 }
[13:35:06.582]                 ...future.workdir <- getwd()
[13:35:06.582]             }
[13:35:06.582]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.582]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.582]         }
[13:35:06.582]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.582]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:06.582]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.582]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.582]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.582]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.582]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.582]             base::names(...future.oldOptions))
[13:35:06.582]     }
[13:35:06.582]     if (FALSE) {
[13:35:06.582]     }
[13:35:06.582]     else {
[13:35:06.582]         if (TRUE) {
[13:35:06.582]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.582]                 open = "w")
[13:35:06.582]         }
[13:35:06.582]         else {
[13:35:06.582]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.582]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.582]         }
[13:35:06.582]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.582]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.582]             base::sink(type = "output", split = FALSE)
[13:35:06.582]             base::close(...future.stdout)
[13:35:06.582]         }, add = TRUE)
[13:35:06.582]     }
[13:35:06.582]     ...future.frame <- base::sys.nframe()
[13:35:06.582]     ...future.conditions <- base::list()
[13:35:06.582]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.582]     if (FALSE) {
[13:35:06.582]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.582]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.582]     }
[13:35:06.582]     ...future.result <- base::tryCatch({
[13:35:06.582]         base::withCallingHandlers({
[13:35:06.582]             ...future.value <- base::withVisible(base::local({
[13:35:06.582]                 withCallingHandlers({
[13:35:06.582]                   {
[13:35:06.582]                     do.call(function(...) {
[13:35:06.582]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.582]                       if (!identical(...future.globals.maxSize.org, 
[13:35:06.582]                         ...future.globals.maxSize)) {
[13:35:06.582]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.582]                         on.exit(options(oopts), add = TRUE)
[13:35:06.582]                       }
[13:35:06.582]                       {
[13:35:06.582]                         lapply(seq_along(...future.elements_ii), 
[13:35:06.582]                           FUN = function(jj) {
[13:35:06.582]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.582]                             ...future.FUN(...future.X_jj, ...)
[13:35:06.582]                           })
[13:35:06.582]                       }
[13:35:06.582]                     }, args = future.call.arguments)
[13:35:06.582]                   }
[13:35:06.582]                 }, immediateCondition = function(cond) {
[13:35:06.582]                   save_rds <- function (object, pathname, ...) 
[13:35:06.582]                   {
[13:35:06.582]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:06.582]                     if (file_test("-f", pathname_tmp)) {
[13:35:06.582]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.582]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:06.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.582]                         fi_tmp[["mtime"]])
[13:35:06.582]                     }
[13:35:06.582]                     tryCatch({
[13:35:06.582]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:06.582]                     }, error = function(ex) {
[13:35:06.582]                       msg <- conditionMessage(ex)
[13:35:06.582]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.582]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:06.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.582]                         fi_tmp[["mtime"]], msg)
[13:35:06.582]                       ex$message <- msg
[13:35:06.582]                       stop(ex)
[13:35:06.582]                     })
[13:35:06.582]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:06.582]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:06.582]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:06.582]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.582]                       fi <- file.info(pathname)
[13:35:06.582]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:06.582]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.582]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:06.582]                         fi[["size"]], fi[["mtime"]])
[13:35:06.582]                       stop(msg)
[13:35:06.582]                     }
[13:35:06.582]                     invisible(pathname)
[13:35:06.582]                   }
[13:35:06.582]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:06.582]                     rootPath = tempdir()) 
[13:35:06.582]                   {
[13:35:06.582]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:06.582]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:06.582]                       tmpdir = path, fileext = ".rds")
[13:35:06.582]                     save_rds(obj, file)
[13:35:06.582]                   }
[13:35:06.582]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:06.582]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.582]                   {
[13:35:06.582]                     inherits <- base::inherits
[13:35:06.582]                     invokeRestart <- base::invokeRestart
[13:35:06.582]                     is.null <- base::is.null
[13:35:06.582]                     muffled <- FALSE
[13:35:06.582]                     if (inherits(cond, "message")) {
[13:35:06.582]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:06.582]                       if (muffled) 
[13:35:06.582]                         invokeRestart("muffleMessage")
[13:35:06.582]                     }
[13:35:06.582]                     else if (inherits(cond, "warning")) {
[13:35:06.582]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:06.582]                       if (muffled) 
[13:35:06.582]                         invokeRestart("muffleWarning")
[13:35:06.582]                     }
[13:35:06.582]                     else if (inherits(cond, "condition")) {
[13:35:06.582]                       if (!is.null(pattern)) {
[13:35:06.582]                         computeRestarts <- base::computeRestarts
[13:35:06.582]                         grepl <- base::grepl
[13:35:06.582]                         restarts <- computeRestarts(cond)
[13:35:06.582]                         for (restart in restarts) {
[13:35:06.582]                           name <- restart$name
[13:35:06.582]                           if (is.null(name)) 
[13:35:06.582]                             next
[13:35:06.582]                           if (!grepl(pattern, name)) 
[13:35:06.582]                             next
[13:35:06.582]                           invokeRestart(restart)
[13:35:06.582]                           muffled <- TRUE
[13:35:06.582]                           break
[13:35:06.582]                         }
[13:35:06.582]                       }
[13:35:06.582]                     }
[13:35:06.582]                     invisible(muffled)
[13:35:06.582]                   }
[13:35:06.582]                   muffleCondition(cond)
[13:35:06.582]                 })
[13:35:06.582]             }))
[13:35:06.582]             future::FutureResult(value = ...future.value$value, 
[13:35:06.582]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.582]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.582]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.582]                     ...future.globalenv.names))
[13:35:06.582]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.582]         }, condition = base::local({
[13:35:06.582]             c <- base::c
[13:35:06.582]             inherits <- base::inherits
[13:35:06.582]             invokeRestart <- base::invokeRestart
[13:35:06.582]             length <- base::length
[13:35:06.582]             list <- base::list
[13:35:06.582]             seq.int <- base::seq.int
[13:35:06.582]             signalCondition <- base::signalCondition
[13:35:06.582]             sys.calls <- base::sys.calls
[13:35:06.582]             `[[` <- base::`[[`
[13:35:06.582]             `+` <- base::`+`
[13:35:06.582]             `<<-` <- base::`<<-`
[13:35:06.582]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.582]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.582]                   3L)]
[13:35:06.582]             }
[13:35:06.582]             function(cond) {
[13:35:06.582]                 is_error <- inherits(cond, "error")
[13:35:06.582]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.582]                   NULL)
[13:35:06.582]                 if (is_error) {
[13:35:06.582]                   sessionInformation <- function() {
[13:35:06.582]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.582]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.582]                       search = base::search(), system = base::Sys.info())
[13:35:06.582]                   }
[13:35:06.582]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.582]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.582]                     cond$call), session = sessionInformation(), 
[13:35:06.582]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.582]                   signalCondition(cond)
[13:35:06.582]                 }
[13:35:06.582]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.582]                 "immediateCondition"))) {
[13:35:06.582]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.582]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.582]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.582]                   if (TRUE && !signal) {
[13:35:06.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.582]                     {
[13:35:06.582]                       inherits <- base::inherits
[13:35:06.582]                       invokeRestart <- base::invokeRestart
[13:35:06.582]                       is.null <- base::is.null
[13:35:06.582]                       muffled <- FALSE
[13:35:06.582]                       if (inherits(cond, "message")) {
[13:35:06.582]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.582]                         if (muffled) 
[13:35:06.582]                           invokeRestart("muffleMessage")
[13:35:06.582]                       }
[13:35:06.582]                       else if (inherits(cond, "warning")) {
[13:35:06.582]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.582]                         if (muffled) 
[13:35:06.582]                           invokeRestart("muffleWarning")
[13:35:06.582]                       }
[13:35:06.582]                       else if (inherits(cond, "condition")) {
[13:35:06.582]                         if (!is.null(pattern)) {
[13:35:06.582]                           computeRestarts <- base::computeRestarts
[13:35:06.582]                           grepl <- base::grepl
[13:35:06.582]                           restarts <- computeRestarts(cond)
[13:35:06.582]                           for (restart in restarts) {
[13:35:06.582]                             name <- restart$name
[13:35:06.582]                             if (is.null(name)) 
[13:35:06.582]                               next
[13:35:06.582]                             if (!grepl(pattern, name)) 
[13:35:06.582]                               next
[13:35:06.582]                             invokeRestart(restart)
[13:35:06.582]                             muffled <- TRUE
[13:35:06.582]                             break
[13:35:06.582]                           }
[13:35:06.582]                         }
[13:35:06.582]                       }
[13:35:06.582]                       invisible(muffled)
[13:35:06.582]                     }
[13:35:06.582]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.582]                   }
[13:35:06.582]                 }
[13:35:06.582]                 else {
[13:35:06.582]                   if (TRUE) {
[13:35:06.582]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.582]                     {
[13:35:06.582]                       inherits <- base::inherits
[13:35:06.582]                       invokeRestart <- base::invokeRestart
[13:35:06.582]                       is.null <- base::is.null
[13:35:06.582]                       muffled <- FALSE
[13:35:06.582]                       if (inherits(cond, "message")) {
[13:35:06.582]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.582]                         if (muffled) 
[13:35:06.582]                           invokeRestart("muffleMessage")
[13:35:06.582]                       }
[13:35:06.582]                       else if (inherits(cond, "warning")) {
[13:35:06.582]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.582]                         if (muffled) 
[13:35:06.582]                           invokeRestart("muffleWarning")
[13:35:06.582]                       }
[13:35:06.582]                       else if (inherits(cond, "condition")) {
[13:35:06.582]                         if (!is.null(pattern)) {
[13:35:06.582]                           computeRestarts <- base::computeRestarts
[13:35:06.582]                           grepl <- base::grepl
[13:35:06.582]                           restarts <- computeRestarts(cond)
[13:35:06.582]                           for (restart in restarts) {
[13:35:06.582]                             name <- restart$name
[13:35:06.582]                             if (is.null(name)) 
[13:35:06.582]                               next
[13:35:06.582]                             if (!grepl(pattern, name)) 
[13:35:06.582]                               next
[13:35:06.582]                             invokeRestart(restart)
[13:35:06.582]                             muffled <- TRUE
[13:35:06.582]                             break
[13:35:06.582]                           }
[13:35:06.582]                         }
[13:35:06.582]                       }
[13:35:06.582]                       invisible(muffled)
[13:35:06.582]                     }
[13:35:06.582]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.582]                   }
[13:35:06.582]                 }
[13:35:06.582]             }
[13:35:06.582]         }))
[13:35:06.582]     }, error = function(ex) {
[13:35:06.582]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.582]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.582]                 ...future.rng), started = ...future.startTime, 
[13:35:06.582]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.582]             version = "1.8"), class = "FutureResult")
[13:35:06.582]     }, finally = {
[13:35:06.582]         if (!identical(...future.workdir, getwd())) 
[13:35:06.582]             setwd(...future.workdir)
[13:35:06.582]         {
[13:35:06.582]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.582]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.582]             }
[13:35:06.582]             base::options(...future.oldOptions)
[13:35:06.582]             if (.Platform$OS.type == "windows") {
[13:35:06.582]                 old_names <- names(...future.oldEnvVars)
[13:35:06.582]                 envs <- base::Sys.getenv()
[13:35:06.582]                 names <- names(envs)
[13:35:06.582]                 common <- intersect(names, old_names)
[13:35:06.582]                 added <- setdiff(names, old_names)
[13:35:06.582]                 removed <- setdiff(old_names, names)
[13:35:06.582]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.582]                   envs[common]]
[13:35:06.582]                 NAMES <- toupper(changed)
[13:35:06.582]                 args <- list()
[13:35:06.582]                 for (kk in seq_along(NAMES)) {
[13:35:06.582]                   name <- changed[[kk]]
[13:35:06.582]                   NAME <- NAMES[[kk]]
[13:35:06.582]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.582]                     next
[13:35:06.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.582]                 }
[13:35:06.582]                 NAMES <- toupper(added)
[13:35:06.582]                 for (kk in seq_along(NAMES)) {
[13:35:06.582]                   name <- added[[kk]]
[13:35:06.582]                   NAME <- NAMES[[kk]]
[13:35:06.582]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.582]                     next
[13:35:06.582]                   args[[name]] <- ""
[13:35:06.582]                 }
[13:35:06.582]                 NAMES <- toupper(removed)
[13:35:06.582]                 for (kk in seq_along(NAMES)) {
[13:35:06.582]                   name <- removed[[kk]]
[13:35:06.582]                   NAME <- NAMES[[kk]]
[13:35:06.582]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.582]                     next
[13:35:06.582]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.582]                 }
[13:35:06.582]                 if (length(args) > 0) 
[13:35:06.582]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.582]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.582]             }
[13:35:06.582]             else {
[13:35:06.582]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.582]             }
[13:35:06.582]             {
[13:35:06.582]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.582]                   0L) {
[13:35:06.582]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.582]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.582]                   base::options(opts)
[13:35:06.582]                 }
[13:35:06.582]                 {
[13:35:06.582]                   {
[13:35:06.582]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:06.582]                     NULL
[13:35:06.582]                   }
[13:35:06.582]                   options(future.plan = NULL)
[13:35:06.582]                   if (is.na(NA_character_)) 
[13:35:06.582]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.582]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.582]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.582]                     .init = FALSE)
[13:35:06.582]                 }
[13:35:06.582]             }
[13:35:06.582]         }
[13:35:06.582]     })
[13:35:06.582]     if (TRUE) {
[13:35:06.582]         base::sink(type = "output", split = FALSE)
[13:35:06.582]         if (TRUE) {
[13:35:06.582]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.582]         }
[13:35:06.582]         else {
[13:35:06.582]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.582]         }
[13:35:06.582]         base::close(...future.stdout)
[13:35:06.582]         ...future.stdout <- NULL
[13:35:06.582]     }
[13:35:06.582]     ...future.result$conditions <- ...future.conditions
[13:35:06.582]     ...future.result$finished <- base::Sys.time()
[13:35:06.582]     ...future.result
[13:35:06.582] }
[13:35:06.585] assign_globals() ...
[13:35:06.585] List of 11
[13:35:06.585]  $ ...future.FUN            :function (x, ...)  
[13:35:06.585]  $ x_FUN                    :function (x)  
[13:35:06.585]  $ times                    : int 1
[13:35:06.585]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.585]  $ stop_if_not              :function (...)  
[13:35:06.585]  $ dim                      : NULL
[13:35:06.585]  $ valid_types              : chr "character"
[13:35:06.585]  $ future.call.arguments    : list()
[13:35:06.585]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.585]  $ ...future.elements_ii    :List of 1
[13:35:06.585]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[13:35:06.585]  $ ...future.seeds_ii       : NULL
[13:35:06.585]  $ ...future.globals.maxSize: NULL
[13:35:06.585]  - attr(*, "where")=List of 11
[13:35:06.585]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.585]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.585]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.585]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.585]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.585]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.585]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.585]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.585]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.585]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.585]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.585]  - attr(*, "resolved")= logi FALSE
[13:35:06.585]  - attr(*, "total_size")= num 94208
[13:35:06.585]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.585]  - attr(*, "already-done")= logi TRUE
[13:35:06.602] - copied ‘...future.FUN’ to environment
[13:35:06.602] - copied ‘x_FUN’ to environment
[13:35:06.602] - copied ‘times’ to environment
[13:35:06.602] - copied ‘stopf’ to environment
[13:35:06.602] - copied ‘stop_if_not’ to environment
[13:35:06.603] - copied ‘dim’ to environment
[13:35:06.603] - copied ‘valid_types’ to environment
[13:35:06.603] - copied ‘future.call.arguments’ to environment
[13:35:06.603] - copied ‘...future.elements_ii’ to environment
[13:35:06.603] - copied ‘...future.seeds_ii’ to environment
[13:35:06.603] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.604] assign_globals() ... done
[13:35:06.604] requestCore(): workers = 2
[13:35:06.609] MulticoreFuture started
[13:35:06.609] - Launch lazy future ... done
[13:35:06.609] run() for ‘MulticoreFuture’ ... done
[13:35:06.610] Created future:
[13:35:06.610] plan(): Setting new future strategy stack:
[13:35:06.610] List of future strategies:
[13:35:06.610] 1. sequential:
[13:35:06.610]    - args: function (..., envir = parent.frame())
[13:35:06.610]    - tweaked: FALSE
[13:35:06.610]    - call: NULL
[13:35:06.611] plan(): nbrOfWorkers() = 1
[13:35:06.613] plan(): Setting new future strategy stack:
[13:35:06.613] List of future strategies:
[13:35:06.613] 1. multicore:
[13:35:06.613]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:06.613]    - tweaked: FALSE
[13:35:06.613]    - call: plan(strategy)
[13:35:06.619] plan(): nbrOfWorkers() = 2
[13:35:06.610] MulticoreFuture:
[13:35:06.610] Label: ‘future_vapply-2’
[13:35:06.610] Expression:
[13:35:06.610] {
[13:35:06.610]     do.call(function(...) {
[13:35:06.610]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.610]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.610]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.610]             on.exit(options(oopts), add = TRUE)
[13:35:06.610]         }
[13:35:06.610]         {
[13:35:06.610]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.610]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.610]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.610]             })
[13:35:06.610]         }
[13:35:06.610]     }, args = future.call.arguments)
[13:35:06.610] }
[13:35:06.610] Lazy evaluation: FALSE
[13:35:06.610] Asynchronous evaluation: TRUE
[13:35:06.610] Local evaluation: TRUE
[13:35:06.610] Environment: R_GlobalEnv
[13:35:06.610] Capture standard output: TRUE
[13:35:06.610] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.610] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.610] Packages: 1 packages (‘future.apply’)
[13:35:06.610] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.610] Resolved: TRUE
[13:35:06.610] Value: <not collected>
[13:35:06.610] Conditions captured: <none>
[13:35:06.610] Early signaling: FALSE
[13:35:06.610] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.610] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.620] Chunk #2 of 2 ... DONE
[13:35:06.620] Launching 2 futures (chunks) ... DONE
[13:35:06.620] Resolving 2 futures (chunks) ...
[13:35:06.620] resolve() on list ...
[13:35:06.620]  recursive: 0
[13:35:06.621]  length: 2
[13:35:06.621] 
[13:35:06.621] Future #1
[13:35:06.622] result() for MulticoreFuture ...
[13:35:06.623] result() for MulticoreFuture ...
[13:35:06.624] result() for MulticoreFuture ... done
[13:35:06.624] result() for MulticoreFuture ... done
[13:35:06.624] result() for MulticoreFuture ...
[13:35:06.624] result() for MulticoreFuture ... done
[13:35:06.624] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:06.624] - nx: 2
[13:35:06.624] - relay: TRUE
[13:35:06.625] - stdout: TRUE
[13:35:06.625] - signal: TRUE
[13:35:06.625] - resignal: FALSE
[13:35:06.625] - force: TRUE
[13:35:06.625] - relayed: [n=2] FALSE, FALSE
[13:35:06.625] - queued futures: [n=2] FALSE, FALSE
[13:35:06.625]  - until=1
[13:35:06.626]  - relaying element #1
[13:35:06.626] result() for MulticoreFuture ...
[13:35:06.626] result() for MulticoreFuture ... done
[13:35:06.626] result() for MulticoreFuture ...
[13:35:06.626] result() for MulticoreFuture ... done
[13:35:06.626] result() for MulticoreFuture ...
[13:35:06.626] result() for MulticoreFuture ... done
[13:35:06.627] result() for MulticoreFuture ...
[13:35:06.627] result() for MulticoreFuture ... done
[13:35:06.627] - relayed: [n=2] TRUE, FALSE
[13:35:06.627] - queued futures: [n=2] TRUE, FALSE
[13:35:06.627] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:06.627]  length: 1 (resolved future 1)
[13:35:06.628] Future #2
[13:35:06.628] result() for MulticoreFuture ...
[13:35:06.628] result() for MulticoreFuture ...
[13:35:06.629] result() for MulticoreFuture ... done
[13:35:06.629] result() for MulticoreFuture ... done
[13:35:06.629] result() for MulticoreFuture ...
[13:35:06.629] result() for MulticoreFuture ... done
[13:35:06.629] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:06.629] - nx: 2
[13:35:06.629] - relay: TRUE
[13:35:06.630] - stdout: TRUE
[13:35:06.630] - signal: TRUE
[13:35:06.630] - resignal: FALSE
[13:35:06.630] - force: TRUE
[13:35:06.630] - relayed: [n=2] TRUE, FALSE
[13:35:06.630] - queued futures: [n=2] TRUE, FALSE
[13:35:06.630]  - until=2
[13:35:06.630]  - relaying element #2
[13:35:06.631] result() for MulticoreFuture ...
[13:35:06.631] result() for MulticoreFuture ... done
[13:35:06.631] result() for MulticoreFuture ...
[13:35:06.631] result() for MulticoreFuture ... done
[13:35:06.631] result() for MulticoreFuture ...
[13:35:06.631] result() for MulticoreFuture ... done
[13:35:06.631] result() for MulticoreFuture ...
[13:35:06.631] result() for MulticoreFuture ... done
[13:35:06.632] - relayed: [n=2] TRUE, TRUE
[13:35:06.632] - queued futures: [n=2] TRUE, TRUE
[13:35:06.632] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:06.634]  length: 0 (resolved future 2)
[13:35:06.634] Relaying remaining futures
[13:35:06.634] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.635] - nx: 2
[13:35:06.635] - relay: TRUE
[13:35:06.635] - stdout: TRUE
[13:35:06.635] - signal: TRUE
[13:35:06.635] - resignal: FALSE
[13:35:06.635] - force: TRUE
[13:35:06.636] - relayed: [n=2] TRUE, TRUE
[13:35:06.636] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:06.636] - relayed: [n=2] TRUE, TRUE
[13:35:06.636] - queued futures: [n=2] TRUE, TRUE
[13:35:06.636] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.636] resolve() on list ... DONE
[13:35:06.637] result() for MulticoreFuture ...
[13:35:06.637] result() for MulticoreFuture ... done
[13:35:06.637] result() for MulticoreFuture ...
[13:35:06.637] result() for MulticoreFuture ... done
[13:35:06.637] result() for MulticoreFuture ...
[13:35:06.637] result() for MulticoreFuture ... done
[13:35:06.638] result() for MulticoreFuture ...
[13:35:06.638] result() for MulticoreFuture ... done
[13:35:06.638]  - Number of value chunks collected: 2
[13:35:06.638] Resolving 2 futures (chunks) ... DONE
[13:35:06.638] Reducing values from 2 chunks ...
[13:35:06.638]  - Number of values collected after concatenation: 2
[13:35:06.639]  - Number of values expected: 2
[13:35:06.639] Reducing values from 2 chunks ... DONE
[13:35:06.639] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[13:35:06.640] future_lapply() ...
[13:35:06.646] Number of chunks: 2
[13:35:06.647] getGlobalsAndPackagesXApply() ...
[13:35:06.647]  - future.globals: TRUE
[13:35:06.647] getGlobalsAndPackages() ...
[13:35:06.647] Searching for globals...
[13:35:06.651] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[13:35:06.651] Searching for globals ... DONE
[13:35:06.651] Resolving globals: FALSE
[13:35:06.652] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[13:35:06.652] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:06.652] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.653] - packages: [1] ‘future.apply’
[13:35:06.653] getGlobalsAndPackages() ... DONE
[13:35:06.653]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.653]  - needed namespaces: [n=1] ‘future.apply’
[13:35:06.653] Finding globals ... DONE
[13:35:06.653]  - use_args: TRUE
[13:35:06.653]  - Getting '...' globals ...
[13:35:06.653] resolve() on list ...
[13:35:06.654]  recursive: 0
[13:35:06.654]  length: 1
[13:35:06.654]  elements: ‘...’
[13:35:06.654]  length: 0 (resolved future 1)
[13:35:06.654] resolve() on list ... DONE
[13:35:06.654]    - '...' content: [n=0] 
[13:35:06.654] List of 1
[13:35:06.654]  $ ...: list()
[13:35:06.654]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.654]  - attr(*, "where")=List of 1
[13:35:06.654]   ..$ ...:<environment: 0x5574cfd7e2a0> 
[13:35:06.654]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.654]  - attr(*, "resolved")= logi TRUE
[13:35:06.654]  - attr(*, "total_size")= num NA
[13:35:06.657]  - Getting '...' globals ... DONE
[13:35:06.657] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:06.657] List of 8
[13:35:06.657]  $ ...future.FUN:function (x, ...)  
[13:35:06.657]  $ x_FUN        :function (x)  
[13:35:06.657]  $ times        : int 0
[13:35:06.657]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.657]  $ stop_if_not  :function (...)  
[13:35:06.657]  $ dim          : NULL
[13:35:06.657]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:06.657]  $ ...          : list()
[13:35:06.657]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.657]  - attr(*, "where")=List of 8
[13:35:06.657]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.657]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:06.657]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:06.657]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:06.657]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:06.657]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:06.657]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:06.657]   ..$ ...          :<environment: 0x5574cfd7e2a0> 
[13:35:06.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.657]  - attr(*, "resolved")= logi FALSE
[13:35:06.657]  - attr(*, "total_size")= num 95472
[13:35:06.664] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:06.664] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.665] Number of futures (= number of chunks): 2
[13:35:06.665] Launching 2 futures (chunks) ...
[13:35:06.665] Chunk #1 of 2 ...
[13:35:06.665]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.665] getGlobalsAndPackages() ...
[13:35:06.665] Searching for globals...
[13:35:06.665] 
[13:35:06.666] Searching for globals ... DONE
[13:35:06.666] - globals: [0] <none>
[13:35:06.666] getGlobalsAndPackages() ... DONE
[13:35:06.666]    + additional globals found: [n=0] 
[13:35:06.666]    + additional namespaces needed: [n=0] 
[13:35:06.666]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.666]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:06.666]  - seeds: <none>
[13:35:06.666]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.666] getGlobalsAndPackages() ...
[13:35:06.667] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.667] Resolving globals: FALSE
[13:35:06.667] Tweak future expression to call with '...' arguments ...
[13:35:06.667] {
[13:35:06.667]     do.call(function(...) {
[13:35:06.667]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.667]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.667]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.667]             on.exit(options(oopts), add = TRUE)
[13:35:06.667]         }
[13:35:06.667]         {
[13:35:06.667]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.667]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.667]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.667]             })
[13:35:06.667]         }
[13:35:06.667]     }, args = future.call.arguments)
[13:35:06.667] }
[13:35:06.667] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.668] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.668] - packages: [1] ‘future.apply’
[13:35:06.668] getGlobalsAndPackages() ... DONE
[13:35:06.668] run() for ‘Future’ ...
[13:35:06.668] - state: ‘created’
[13:35:06.668] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:06.672] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.672] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:06.672]   - Field: ‘label’
[13:35:06.672]   - Field: ‘local’
[13:35:06.672]   - Field: ‘owner’
[13:35:06.672]   - Field: ‘envir’
[13:35:06.673]   - Field: ‘workers’
[13:35:06.673]   - Field: ‘packages’
[13:35:06.673]   - Field: ‘gc’
[13:35:06.673]   - Field: ‘job’
[13:35:06.673]   - Field: ‘conditions’
[13:35:06.673]   - Field: ‘expr’
[13:35:06.673]   - Field: ‘uuid’
[13:35:06.673]   - Field: ‘seed’
[13:35:06.673]   - Field: ‘version’
[13:35:06.673]   - Field: ‘result’
[13:35:06.673]   - Field: ‘asynchronous’
[13:35:06.674]   - Field: ‘calls’
[13:35:06.674]   - Field: ‘globals’
[13:35:06.674]   - Field: ‘stdout’
[13:35:06.674]   - Field: ‘earlySignal’
[13:35:06.674]   - Field: ‘lazy’
[13:35:06.674]   - Field: ‘state’
[13:35:06.674] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:06.674] - Launch lazy future ...
[13:35:06.674] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.675] Packages needed by future strategies (n = 0): <none>
[13:35:06.675] {
[13:35:06.675]     {
[13:35:06.675]         {
[13:35:06.675]             ...future.startTime <- base::Sys.time()
[13:35:06.675]             {
[13:35:06.675]                 {
[13:35:06.675]                   {
[13:35:06.675]                     {
[13:35:06.675]                       {
[13:35:06.675]                         base::local({
[13:35:06.675]                           has_future <- base::requireNamespace("future", 
[13:35:06.675]                             quietly = TRUE)
[13:35:06.675]                           if (has_future) {
[13:35:06.675]                             ns <- base::getNamespace("future")
[13:35:06.675]                             version <- ns[[".package"]][["version"]]
[13:35:06.675]                             if (is.null(version)) 
[13:35:06.675]                               version <- utils::packageVersion("future")
[13:35:06.675]                           }
[13:35:06.675]                           else {
[13:35:06.675]                             version <- NULL
[13:35:06.675]                           }
[13:35:06.675]                           if (!has_future || version < "1.8.0") {
[13:35:06.675]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.675]                               "", base::R.version$version.string), 
[13:35:06.675]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:06.675]                                 base::R.version$platform, 8 * 
[13:35:06.675]                                   base::.Machine$sizeof.pointer), 
[13:35:06.675]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.675]                                 "release", "version")], collapse = " "), 
[13:35:06.675]                               hostname = base::Sys.info()[["nodename"]])
[13:35:06.675]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.675]                               info)
[13:35:06.675]                             info <- base::paste(info, collapse = "; ")
[13:35:06.675]                             if (!has_future) {
[13:35:06.675]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.675]                                 info)
[13:35:06.675]                             }
[13:35:06.675]                             else {
[13:35:06.675]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.675]                                 info, version)
[13:35:06.675]                             }
[13:35:06.675]                             base::stop(msg)
[13:35:06.675]                           }
[13:35:06.675]                         })
[13:35:06.675]                       }
[13:35:06.675]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:06.675]                       base::options(mc.cores = 1L)
[13:35:06.675]                     }
[13:35:06.675]                     base::local({
[13:35:06.675]                       for (pkg in "future.apply") {
[13:35:06.675]                         base::loadNamespace(pkg)
[13:35:06.675]                         base::library(pkg, character.only = TRUE)
[13:35:06.675]                       }
[13:35:06.675]                     })
[13:35:06.675]                   }
[13:35:06.675]                   ...future.strategy.old <- future::plan("list")
[13:35:06.675]                   options(future.plan = NULL)
[13:35:06.675]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.675]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.675]                 }
[13:35:06.675]                 ...future.workdir <- getwd()
[13:35:06.675]             }
[13:35:06.675]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.675]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.675]         }
[13:35:06.675]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.675]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:06.675]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.675]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.675]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.675]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.675]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.675]             base::names(...future.oldOptions))
[13:35:06.675]     }
[13:35:06.675]     if (FALSE) {
[13:35:06.675]     }
[13:35:06.675]     else {
[13:35:06.675]         if (TRUE) {
[13:35:06.675]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.675]                 open = "w")
[13:35:06.675]         }
[13:35:06.675]         else {
[13:35:06.675]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.675]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.675]         }
[13:35:06.675]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.675]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.675]             base::sink(type = "output", split = FALSE)
[13:35:06.675]             base::close(...future.stdout)
[13:35:06.675]         }, add = TRUE)
[13:35:06.675]     }
[13:35:06.675]     ...future.frame <- base::sys.nframe()
[13:35:06.675]     ...future.conditions <- base::list()
[13:35:06.675]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.675]     if (FALSE) {
[13:35:06.675]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.675]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.675]     }
[13:35:06.675]     ...future.result <- base::tryCatch({
[13:35:06.675]         base::withCallingHandlers({
[13:35:06.675]             ...future.value <- base::withVisible(base::local({
[13:35:06.675]                 withCallingHandlers({
[13:35:06.675]                   {
[13:35:06.675]                     do.call(function(...) {
[13:35:06.675]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.675]                       if (!identical(...future.globals.maxSize.org, 
[13:35:06.675]                         ...future.globals.maxSize)) {
[13:35:06.675]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.675]                         on.exit(options(oopts), add = TRUE)
[13:35:06.675]                       }
[13:35:06.675]                       {
[13:35:06.675]                         lapply(seq_along(...future.elements_ii), 
[13:35:06.675]                           FUN = function(jj) {
[13:35:06.675]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.675]                             ...future.FUN(...future.X_jj, ...)
[13:35:06.675]                           })
[13:35:06.675]                       }
[13:35:06.675]                     }, args = future.call.arguments)
[13:35:06.675]                   }
[13:35:06.675]                 }, immediateCondition = function(cond) {
[13:35:06.675]                   save_rds <- function (object, pathname, ...) 
[13:35:06.675]                   {
[13:35:06.675]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:06.675]                     if (file_test("-f", pathname_tmp)) {
[13:35:06.675]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.675]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:06.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.675]                         fi_tmp[["mtime"]])
[13:35:06.675]                     }
[13:35:06.675]                     tryCatch({
[13:35:06.675]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:06.675]                     }, error = function(ex) {
[13:35:06.675]                       msg <- conditionMessage(ex)
[13:35:06.675]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.675]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:06.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.675]                         fi_tmp[["mtime"]], msg)
[13:35:06.675]                       ex$message <- msg
[13:35:06.675]                       stop(ex)
[13:35:06.675]                     })
[13:35:06.675]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:06.675]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:06.675]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:06.675]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.675]                       fi <- file.info(pathname)
[13:35:06.675]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:06.675]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.675]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:06.675]                         fi[["size"]], fi[["mtime"]])
[13:35:06.675]                       stop(msg)
[13:35:06.675]                     }
[13:35:06.675]                     invisible(pathname)
[13:35:06.675]                   }
[13:35:06.675]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:06.675]                     rootPath = tempdir()) 
[13:35:06.675]                   {
[13:35:06.675]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:06.675]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:06.675]                       tmpdir = path, fileext = ".rds")
[13:35:06.675]                     save_rds(obj, file)
[13:35:06.675]                   }
[13:35:06.675]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:06.675]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.675]                   {
[13:35:06.675]                     inherits <- base::inherits
[13:35:06.675]                     invokeRestart <- base::invokeRestart
[13:35:06.675]                     is.null <- base::is.null
[13:35:06.675]                     muffled <- FALSE
[13:35:06.675]                     if (inherits(cond, "message")) {
[13:35:06.675]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:06.675]                       if (muffled) 
[13:35:06.675]                         invokeRestart("muffleMessage")
[13:35:06.675]                     }
[13:35:06.675]                     else if (inherits(cond, "warning")) {
[13:35:06.675]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:06.675]                       if (muffled) 
[13:35:06.675]                         invokeRestart("muffleWarning")
[13:35:06.675]                     }
[13:35:06.675]                     else if (inherits(cond, "condition")) {
[13:35:06.675]                       if (!is.null(pattern)) {
[13:35:06.675]                         computeRestarts <- base::computeRestarts
[13:35:06.675]                         grepl <- base::grepl
[13:35:06.675]                         restarts <- computeRestarts(cond)
[13:35:06.675]                         for (restart in restarts) {
[13:35:06.675]                           name <- restart$name
[13:35:06.675]                           if (is.null(name)) 
[13:35:06.675]                             next
[13:35:06.675]                           if (!grepl(pattern, name)) 
[13:35:06.675]                             next
[13:35:06.675]                           invokeRestart(restart)
[13:35:06.675]                           muffled <- TRUE
[13:35:06.675]                           break
[13:35:06.675]                         }
[13:35:06.675]                       }
[13:35:06.675]                     }
[13:35:06.675]                     invisible(muffled)
[13:35:06.675]                   }
[13:35:06.675]                   muffleCondition(cond)
[13:35:06.675]                 })
[13:35:06.675]             }))
[13:35:06.675]             future::FutureResult(value = ...future.value$value, 
[13:35:06.675]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.675]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.675]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.675]                     ...future.globalenv.names))
[13:35:06.675]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.675]         }, condition = base::local({
[13:35:06.675]             c <- base::c
[13:35:06.675]             inherits <- base::inherits
[13:35:06.675]             invokeRestart <- base::invokeRestart
[13:35:06.675]             length <- base::length
[13:35:06.675]             list <- base::list
[13:35:06.675]             seq.int <- base::seq.int
[13:35:06.675]             signalCondition <- base::signalCondition
[13:35:06.675]             sys.calls <- base::sys.calls
[13:35:06.675]             `[[` <- base::`[[`
[13:35:06.675]             `+` <- base::`+`
[13:35:06.675]             `<<-` <- base::`<<-`
[13:35:06.675]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.675]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.675]                   3L)]
[13:35:06.675]             }
[13:35:06.675]             function(cond) {
[13:35:06.675]                 is_error <- inherits(cond, "error")
[13:35:06.675]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.675]                   NULL)
[13:35:06.675]                 if (is_error) {
[13:35:06.675]                   sessionInformation <- function() {
[13:35:06.675]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.675]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.675]                       search = base::search(), system = base::Sys.info())
[13:35:06.675]                   }
[13:35:06.675]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.675]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.675]                     cond$call), session = sessionInformation(), 
[13:35:06.675]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.675]                   signalCondition(cond)
[13:35:06.675]                 }
[13:35:06.675]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.675]                 "immediateCondition"))) {
[13:35:06.675]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.675]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.675]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.675]                   if (TRUE && !signal) {
[13:35:06.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.675]                     {
[13:35:06.675]                       inherits <- base::inherits
[13:35:06.675]                       invokeRestart <- base::invokeRestart
[13:35:06.675]                       is.null <- base::is.null
[13:35:06.675]                       muffled <- FALSE
[13:35:06.675]                       if (inherits(cond, "message")) {
[13:35:06.675]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.675]                         if (muffled) 
[13:35:06.675]                           invokeRestart("muffleMessage")
[13:35:06.675]                       }
[13:35:06.675]                       else if (inherits(cond, "warning")) {
[13:35:06.675]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.675]                         if (muffled) 
[13:35:06.675]                           invokeRestart("muffleWarning")
[13:35:06.675]                       }
[13:35:06.675]                       else if (inherits(cond, "condition")) {
[13:35:06.675]                         if (!is.null(pattern)) {
[13:35:06.675]                           computeRestarts <- base::computeRestarts
[13:35:06.675]                           grepl <- base::grepl
[13:35:06.675]                           restarts <- computeRestarts(cond)
[13:35:06.675]                           for (restart in restarts) {
[13:35:06.675]                             name <- restart$name
[13:35:06.675]                             if (is.null(name)) 
[13:35:06.675]                               next
[13:35:06.675]                             if (!grepl(pattern, name)) 
[13:35:06.675]                               next
[13:35:06.675]                             invokeRestart(restart)
[13:35:06.675]                             muffled <- TRUE
[13:35:06.675]                             break
[13:35:06.675]                           }
[13:35:06.675]                         }
[13:35:06.675]                       }
[13:35:06.675]                       invisible(muffled)
[13:35:06.675]                     }
[13:35:06.675]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.675]                   }
[13:35:06.675]                 }
[13:35:06.675]                 else {
[13:35:06.675]                   if (TRUE) {
[13:35:06.675]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.675]                     {
[13:35:06.675]                       inherits <- base::inherits
[13:35:06.675]                       invokeRestart <- base::invokeRestart
[13:35:06.675]                       is.null <- base::is.null
[13:35:06.675]                       muffled <- FALSE
[13:35:06.675]                       if (inherits(cond, "message")) {
[13:35:06.675]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.675]                         if (muffled) 
[13:35:06.675]                           invokeRestart("muffleMessage")
[13:35:06.675]                       }
[13:35:06.675]                       else if (inherits(cond, "warning")) {
[13:35:06.675]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.675]                         if (muffled) 
[13:35:06.675]                           invokeRestart("muffleWarning")
[13:35:06.675]                       }
[13:35:06.675]                       else if (inherits(cond, "condition")) {
[13:35:06.675]                         if (!is.null(pattern)) {
[13:35:06.675]                           computeRestarts <- base::computeRestarts
[13:35:06.675]                           grepl <- base::grepl
[13:35:06.675]                           restarts <- computeRestarts(cond)
[13:35:06.675]                           for (restart in restarts) {
[13:35:06.675]                             name <- restart$name
[13:35:06.675]                             if (is.null(name)) 
[13:35:06.675]                               next
[13:35:06.675]                             if (!grepl(pattern, name)) 
[13:35:06.675]                               next
[13:35:06.675]                             invokeRestart(restart)
[13:35:06.675]                             muffled <- TRUE
[13:35:06.675]                             break
[13:35:06.675]                           }
[13:35:06.675]                         }
[13:35:06.675]                       }
[13:35:06.675]                       invisible(muffled)
[13:35:06.675]                     }
[13:35:06.675]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.675]                   }
[13:35:06.675]                 }
[13:35:06.675]             }
[13:35:06.675]         }))
[13:35:06.675]     }, error = function(ex) {
[13:35:06.675]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.675]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.675]                 ...future.rng), started = ...future.startTime, 
[13:35:06.675]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.675]             version = "1.8"), class = "FutureResult")
[13:35:06.675]     }, finally = {
[13:35:06.675]         if (!identical(...future.workdir, getwd())) 
[13:35:06.675]             setwd(...future.workdir)
[13:35:06.675]         {
[13:35:06.675]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.675]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.675]             }
[13:35:06.675]             base::options(...future.oldOptions)
[13:35:06.675]             if (.Platform$OS.type == "windows") {
[13:35:06.675]                 old_names <- names(...future.oldEnvVars)
[13:35:06.675]                 envs <- base::Sys.getenv()
[13:35:06.675]                 names <- names(envs)
[13:35:06.675]                 common <- intersect(names, old_names)
[13:35:06.675]                 added <- setdiff(names, old_names)
[13:35:06.675]                 removed <- setdiff(old_names, names)
[13:35:06.675]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.675]                   envs[common]]
[13:35:06.675]                 NAMES <- toupper(changed)
[13:35:06.675]                 args <- list()
[13:35:06.675]                 for (kk in seq_along(NAMES)) {
[13:35:06.675]                   name <- changed[[kk]]
[13:35:06.675]                   NAME <- NAMES[[kk]]
[13:35:06.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.675]                     next
[13:35:06.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.675]                 }
[13:35:06.675]                 NAMES <- toupper(added)
[13:35:06.675]                 for (kk in seq_along(NAMES)) {
[13:35:06.675]                   name <- added[[kk]]
[13:35:06.675]                   NAME <- NAMES[[kk]]
[13:35:06.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.675]                     next
[13:35:06.675]                   args[[name]] <- ""
[13:35:06.675]                 }
[13:35:06.675]                 NAMES <- toupper(removed)
[13:35:06.675]                 for (kk in seq_along(NAMES)) {
[13:35:06.675]                   name <- removed[[kk]]
[13:35:06.675]                   NAME <- NAMES[[kk]]
[13:35:06.675]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.675]                     next
[13:35:06.675]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.675]                 }
[13:35:06.675]                 if (length(args) > 0) 
[13:35:06.675]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.675]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.675]             }
[13:35:06.675]             else {
[13:35:06.675]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.675]             }
[13:35:06.675]             {
[13:35:06.675]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.675]                   0L) {
[13:35:06.675]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.675]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.675]                   base::options(opts)
[13:35:06.675]                 }
[13:35:06.675]                 {
[13:35:06.675]                   {
[13:35:06.675]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:06.675]                     NULL
[13:35:06.675]                   }
[13:35:06.675]                   options(future.plan = NULL)
[13:35:06.675]                   if (is.na(NA_character_)) 
[13:35:06.675]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.675]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.675]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.675]                     .init = FALSE)
[13:35:06.675]                 }
[13:35:06.675]             }
[13:35:06.675]         }
[13:35:06.675]     })
[13:35:06.675]     if (TRUE) {
[13:35:06.675]         base::sink(type = "output", split = FALSE)
[13:35:06.675]         if (TRUE) {
[13:35:06.675]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.675]         }
[13:35:06.675]         else {
[13:35:06.675]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.675]         }
[13:35:06.675]         base::close(...future.stdout)
[13:35:06.675]         ...future.stdout <- NULL
[13:35:06.675]     }
[13:35:06.675]     ...future.result$conditions <- ...future.conditions
[13:35:06.675]     ...future.result$finished <- base::Sys.time()
[13:35:06.675]     ...future.result
[13:35:06.675] }
[13:35:06.678] assign_globals() ...
[13:35:06.678] List of 11
[13:35:06.678]  $ ...future.FUN            :function (x, ...)  
[13:35:06.678]  $ x_FUN                    :function (x)  
[13:35:06.678]  $ times                    : int 0
[13:35:06.678]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.678]  $ stop_if_not              :function (...)  
[13:35:06.678]  $ dim                      : NULL
[13:35:06.678]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:06.678]  $ future.call.arguments    : list()
[13:35:06.678]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.678]  $ ...future.elements_ii    :List of 5
[13:35:06.678]   ..$ : int 1
[13:35:06.678]   ..$ : int 2
[13:35:06.678]   ..$ : int 3
[13:35:06.678]   ..$ : int 4
[13:35:06.678]   ..$ : int 5
[13:35:06.678]  $ ...future.seeds_ii       : NULL
[13:35:06.678]  $ ...future.globals.maxSize: NULL
[13:35:06.678]  - attr(*, "where")=List of 11
[13:35:06.678]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.678]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.678]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.678]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.678]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.678]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.678]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.678]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.678]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.678]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.678]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.678]  - attr(*, "resolved")= logi FALSE
[13:35:06.678]  - attr(*, "total_size")= num 95472
[13:35:06.678]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.678]  - attr(*, "already-done")= logi TRUE
[13:35:06.687] - copied ‘...future.FUN’ to environment
[13:35:06.688] - reassign environment for ‘x_FUN’
[13:35:06.688] - copied ‘x_FUN’ to environment
[13:35:06.688] - copied ‘times’ to environment
[13:35:06.688] - copied ‘stopf’ to environment
[13:35:06.688] - copied ‘stop_if_not’ to environment
[13:35:06.688] - copied ‘dim’ to environment
[13:35:06.688] - copied ‘valid_types’ to environment
[13:35:06.688] - copied ‘future.call.arguments’ to environment
[13:35:06.688] - copied ‘...future.elements_ii’ to environment
[13:35:06.688] - copied ‘...future.seeds_ii’ to environment
[13:35:06.689] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.689] assign_globals() ... done
[13:35:06.689] requestCore(): workers = 2
[13:35:06.691] MulticoreFuture started
[13:35:06.691] - Launch lazy future ... done
[13:35:06.692] run() for ‘MulticoreFuture’ ... done
[13:35:06.692] Created future:
[13:35:06.692] plan(): Setting new future strategy stack:
[13:35:06.693] List of future strategies:
[13:35:06.693] 1. sequential:
[13:35:06.693]    - args: function (..., envir = parent.frame())
[13:35:06.693]    - tweaked: FALSE
[13:35:06.693]    - call: NULL
[13:35:06.694] plan(): nbrOfWorkers() = 1
[13:35:06.696] plan(): Setting new future strategy stack:
[13:35:06.696] List of future strategies:
[13:35:06.696] 1. multicore:
[13:35:06.696]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:06.696]    - tweaked: FALSE
[13:35:06.696]    - call: plan(strategy)
[13:35:06.702] plan(): nbrOfWorkers() = 2
[13:35:06.692] MulticoreFuture:
[13:35:06.692] Label: ‘future_vapply-1’
[13:35:06.692] Expression:
[13:35:06.692] {
[13:35:06.692]     do.call(function(...) {
[13:35:06.692]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.692]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.692]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.692]             on.exit(options(oopts), add = TRUE)
[13:35:06.692]         }
[13:35:06.692]         {
[13:35:06.692]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.692]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.692]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.692]             })
[13:35:06.692]         }
[13:35:06.692]     }, args = future.call.arguments)
[13:35:06.692] }
[13:35:06.692] Lazy evaluation: FALSE
[13:35:06.692] Asynchronous evaluation: TRUE
[13:35:06.692] Local evaluation: TRUE
[13:35:06.692] Environment: R_GlobalEnv
[13:35:06.692] Capture standard output: TRUE
[13:35:06.692] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.692] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.692] Packages: 1 packages (‘future.apply’)
[13:35:06.692] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.692] Resolved: TRUE
[13:35:06.692] Value: <not collected>
[13:35:06.692] Conditions captured: <none>
[13:35:06.692] Early signaling: FALSE
[13:35:06.692] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.692] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.703] Chunk #1 of 2 ... DONE
[13:35:06.703] Chunk #2 of 2 ...
[13:35:06.704]  - Finding globals in 'X' for chunk #2 ...
[13:35:06.704] getGlobalsAndPackages() ...
[13:35:06.704] Searching for globals...
[13:35:06.705] 
[13:35:06.705] Searching for globals ... DONE
[13:35:06.705] - globals: [0] <none>
[13:35:06.705] getGlobalsAndPackages() ... DONE
[13:35:06.705]    + additional globals found: [n=0] 
[13:35:06.705]    + additional namespaces needed: [n=0] 
[13:35:06.705]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:06.706]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:06.706]  - seeds: <none>
[13:35:06.706]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.706] getGlobalsAndPackages() ...
[13:35:06.706] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.707] Resolving globals: FALSE
[13:35:06.707] Tweak future expression to call with '...' arguments ...
[13:35:06.707] {
[13:35:06.707]     do.call(function(...) {
[13:35:06.707]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.707]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.707]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.707]             on.exit(options(oopts), add = TRUE)
[13:35:06.707]         }
[13:35:06.707]         {
[13:35:06.707]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.707]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.707]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.707]             })
[13:35:06.707]         }
[13:35:06.707]     }, args = future.call.arguments)
[13:35:06.707] }
[13:35:06.707] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.708] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.709] - packages: [1] ‘future.apply’
[13:35:06.709] getGlobalsAndPackages() ... DONE
[13:35:06.709] run() for ‘Future’ ...
[13:35:06.709] - state: ‘created’
[13:35:06.710] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:06.714] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:06.714]   - Field: ‘label’
[13:35:06.715]   - Field: ‘local’
[13:35:06.715]   - Field: ‘owner’
[13:35:06.715]   - Field: ‘envir’
[13:35:06.715]   - Field: ‘workers’
[13:35:06.715]   - Field: ‘packages’
[13:35:06.715]   - Field: ‘gc’
[13:35:06.716]   - Field: ‘job’
[13:35:06.716]   - Field: ‘conditions’
[13:35:06.716]   - Field: ‘expr’
[13:35:06.716]   - Field: ‘uuid’
[13:35:06.716]   - Field: ‘seed’
[13:35:06.716]   - Field: ‘version’
[13:35:06.716]   - Field: ‘result’
[13:35:06.717]   - Field: ‘asynchronous’
[13:35:06.717]   - Field: ‘calls’
[13:35:06.717]   - Field: ‘globals’
[13:35:06.717]   - Field: ‘stdout’
[13:35:06.717]   - Field: ‘earlySignal’
[13:35:06.717]   - Field: ‘lazy’
[13:35:06.717]   - Field: ‘state’
[13:35:06.718] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:06.718] - Launch lazy future ...
[13:35:06.718] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.718] Packages needed by future strategies (n = 0): <none>
[13:35:06.719] {
[13:35:06.719]     {
[13:35:06.719]         {
[13:35:06.719]             ...future.startTime <- base::Sys.time()
[13:35:06.719]             {
[13:35:06.719]                 {
[13:35:06.719]                   {
[13:35:06.719]                     {
[13:35:06.719]                       {
[13:35:06.719]                         base::local({
[13:35:06.719]                           has_future <- base::requireNamespace("future", 
[13:35:06.719]                             quietly = TRUE)
[13:35:06.719]                           if (has_future) {
[13:35:06.719]                             ns <- base::getNamespace("future")
[13:35:06.719]                             version <- ns[[".package"]][["version"]]
[13:35:06.719]                             if (is.null(version)) 
[13:35:06.719]                               version <- utils::packageVersion("future")
[13:35:06.719]                           }
[13:35:06.719]                           else {
[13:35:06.719]                             version <- NULL
[13:35:06.719]                           }
[13:35:06.719]                           if (!has_future || version < "1.8.0") {
[13:35:06.719]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.719]                               "", base::R.version$version.string), 
[13:35:06.719]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:06.719]                                 base::R.version$platform, 8 * 
[13:35:06.719]                                   base::.Machine$sizeof.pointer), 
[13:35:06.719]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.719]                                 "release", "version")], collapse = " "), 
[13:35:06.719]                               hostname = base::Sys.info()[["nodename"]])
[13:35:06.719]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.719]                               info)
[13:35:06.719]                             info <- base::paste(info, collapse = "; ")
[13:35:06.719]                             if (!has_future) {
[13:35:06.719]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.719]                                 info)
[13:35:06.719]                             }
[13:35:06.719]                             else {
[13:35:06.719]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.719]                                 info, version)
[13:35:06.719]                             }
[13:35:06.719]                             base::stop(msg)
[13:35:06.719]                           }
[13:35:06.719]                         })
[13:35:06.719]                       }
[13:35:06.719]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:06.719]                       base::options(mc.cores = 1L)
[13:35:06.719]                     }
[13:35:06.719]                     base::local({
[13:35:06.719]                       for (pkg in "future.apply") {
[13:35:06.719]                         base::loadNamespace(pkg)
[13:35:06.719]                         base::library(pkg, character.only = TRUE)
[13:35:06.719]                       }
[13:35:06.719]                     })
[13:35:06.719]                   }
[13:35:06.719]                   ...future.strategy.old <- future::plan("list")
[13:35:06.719]                   options(future.plan = NULL)
[13:35:06.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.719]                 }
[13:35:06.719]                 ...future.workdir <- getwd()
[13:35:06.719]             }
[13:35:06.719]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.719]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.719]         }
[13:35:06.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.719]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:06.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.719]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.719]             base::names(...future.oldOptions))
[13:35:06.719]     }
[13:35:06.719]     if (FALSE) {
[13:35:06.719]     }
[13:35:06.719]     else {
[13:35:06.719]         if (TRUE) {
[13:35:06.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.719]                 open = "w")
[13:35:06.719]         }
[13:35:06.719]         else {
[13:35:06.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.719]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.719]         }
[13:35:06.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.719]             base::sink(type = "output", split = FALSE)
[13:35:06.719]             base::close(...future.stdout)
[13:35:06.719]         }, add = TRUE)
[13:35:06.719]     }
[13:35:06.719]     ...future.frame <- base::sys.nframe()
[13:35:06.719]     ...future.conditions <- base::list()
[13:35:06.719]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.719]     if (FALSE) {
[13:35:06.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.719]     }
[13:35:06.719]     ...future.result <- base::tryCatch({
[13:35:06.719]         base::withCallingHandlers({
[13:35:06.719]             ...future.value <- base::withVisible(base::local({
[13:35:06.719]                 withCallingHandlers({
[13:35:06.719]                   {
[13:35:06.719]                     do.call(function(...) {
[13:35:06.719]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.719]                       if (!identical(...future.globals.maxSize.org, 
[13:35:06.719]                         ...future.globals.maxSize)) {
[13:35:06.719]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.719]                         on.exit(options(oopts), add = TRUE)
[13:35:06.719]                       }
[13:35:06.719]                       {
[13:35:06.719]                         lapply(seq_along(...future.elements_ii), 
[13:35:06.719]                           FUN = function(jj) {
[13:35:06.719]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.719]                             ...future.FUN(...future.X_jj, ...)
[13:35:06.719]                           })
[13:35:06.719]                       }
[13:35:06.719]                     }, args = future.call.arguments)
[13:35:06.719]                   }
[13:35:06.719]                 }, immediateCondition = function(cond) {
[13:35:06.719]                   save_rds <- function (object, pathname, ...) 
[13:35:06.719]                   {
[13:35:06.719]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:06.719]                     if (file_test("-f", pathname_tmp)) {
[13:35:06.719]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.719]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:06.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.719]                         fi_tmp[["mtime"]])
[13:35:06.719]                     }
[13:35:06.719]                     tryCatch({
[13:35:06.719]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:06.719]                     }, error = function(ex) {
[13:35:06.719]                       msg <- conditionMessage(ex)
[13:35:06.719]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.719]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:06.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.719]                         fi_tmp[["mtime"]], msg)
[13:35:06.719]                       ex$message <- msg
[13:35:06.719]                       stop(ex)
[13:35:06.719]                     })
[13:35:06.719]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:06.719]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:06.719]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:06.719]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.719]                       fi <- file.info(pathname)
[13:35:06.719]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:06.719]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.719]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:06.719]                         fi[["size"]], fi[["mtime"]])
[13:35:06.719]                       stop(msg)
[13:35:06.719]                     }
[13:35:06.719]                     invisible(pathname)
[13:35:06.719]                   }
[13:35:06.719]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:06.719]                     rootPath = tempdir()) 
[13:35:06.719]                   {
[13:35:06.719]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:06.719]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:06.719]                       tmpdir = path, fileext = ".rds")
[13:35:06.719]                     save_rds(obj, file)
[13:35:06.719]                   }
[13:35:06.719]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:06.719]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.719]                   {
[13:35:06.719]                     inherits <- base::inherits
[13:35:06.719]                     invokeRestart <- base::invokeRestart
[13:35:06.719]                     is.null <- base::is.null
[13:35:06.719]                     muffled <- FALSE
[13:35:06.719]                     if (inherits(cond, "message")) {
[13:35:06.719]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:06.719]                       if (muffled) 
[13:35:06.719]                         invokeRestart("muffleMessage")
[13:35:06.719]                     }
[13:35:06.719]                     else if (inherits(cond, "warning")) {
[13:35:06.719]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:06.719]                       if (muffled) 
[13:35:06.719]                         invokeRestart("muffleWarning")
[13:35:06.719]                     }
[13:35:06.719]                     else if (inherits(cond, "condition")) {
[13:35:06.719]                       if (!is.null(pattern)) {
[13:35:06.719]                         computeRestarts <- base::computeRestarts
[13:35:06.719]                         grepl <- base::grepl
[13:35:06.719]                         restarts <- computeRestarts(cond)
[13:35:06.719]                         for (restart in restarts) {
[13:35:06.719]                           name <- restart$name
[13:35:06.719]                           if (is.null(name)) 
[13:35:06.719]                             next
[13:35:06.719]                           if (!grepl(pattern, name)) 
[13:35:06.719]                             next
[13:35:06.719]                           invokeRestart(restart)
[13:35:06.719]                           muffled <- TRUE
[13:35:06.719]                           break
[13:35:06.719]                         }
[13:35:06.719]                       }
[13:35:06.719]                     }
[13:35:06.719]                     invisible(muffled)
[13:35:06.719]                   }
[13:35:06.719]                   muffleCondition(cond)
[13:35:06.719]                 })
[13:35:06.719]             }))
[13:35:06.719]             future::FutureResult(value = ...future.value$value, 
[13:35:06.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.719]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.719]                     ...future.globalenv.names))
[13:35:06.719]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.719]         }, condition = base::local({
[13:35:06.719]             c <- base::c
[13:35:06.719]             inherits <- base::inherits
[13:35:06.719]             invokeRestart <- base::invokeRestart
[13:35:06.719]             length <- base::length
[13:35:06.719]             list <- base::list
[13:35:06.719]             seq.int <- base::seq.int
[13:35:06.719]             signalCondition <- base::signalCondition
[13:35:06.719]             sys.calls <- base::sys.calls
[13:35:06.719]             `[[` <- base::`[[`
[13:35:06.719]             `+` <- base::`+`
[13:35:06.719]             `<<-` <- base::`<<-`
[13:35:06.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.719]                   3L)]
[13:35:06.719]             }
[13:35:06.719]             function(cond) {
[13:35:06.719]                 is_error <- inherits(cond, "error")
[13:35:06.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.719]                   NULL)
[13:35:06.719]                 if (is_error) {
[13:35:06.719]                   sessionInformation <- function() {
[13:35:06.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.719]                       search = base::search(), system = base::Sys.info())
[13:35:06.719]                   }
[13:35:06.719]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.719]                     cond$call), session = sessionInformation(), 
[13:35:06.719]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.719]                   signalCondition(cond)
[13:35:06.719]                 }
[13:35:06.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.719]                 "immediateCondition"))) {
[13:35:06.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.719]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.719]                   if (TRUE && !signal) {
[13:35:06.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.719]                     {
[13:35:06.719]                       inherits <- base::inherits
[13:35:06.719]                       invokeRestart <- base::invokeRestart
[13:35:06.719]                       is.null <- base::is.null
[13:35:06.719]                       muffled <- FALSE
[13:35:06.719]                       if (inherits(cond, "message")) {
[13:35:06.719]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.719]                         if (muffled) 
[13:35:06.719]                           invokeRestart("muffleMessage")
[13:35:06.719]                       }
[13:35:06.719]                       else if (inherits(cond, "warning")) {
[13:35:06.719]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.719]                         if (muffled) 
[13:35:06.719]                           invokeRestart("muffleWarning")
[13:35:06.719]                       }
[13:35:06.719]                       else if (inherits(cond, "condition")) {
[13:35:06.719]                         if (!is.null(pattern)) {
[13:35:06.719]                           computeRestarts <- base::computeRestarts
[13:35:06.719]                           grepl <- base::grepl
[13:35:06.719]                           restarts <- computeRestarts(cond)
[13:35:06.719]                           for (restart in restarts) {
[13:35:06.719]                             name <- restart$name
[13:35:06.719]                             if (is.null(name)) 
[13:35:06.719]                               next
[13:35:06.719]                             if (!grepl(pattern, name)) 
[13:35:06.719]                               next
[13:35:06.719]                             invokeRestart(restart)
[13:35:06.719]                             muffled <- TRUE
[13:35:06.719]                             break
[13:35:06.719]                           }
[13:35:06.719]                         }
[13:35:06.719]                       }
[13:35:06.719]                       invisible(muffled)
[13:35:06.719]                     }
[13:35:06.719]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.719]                   }
[13:35:06.719]                 }
[13:35:06.719]                 else {
[13:35:06.719]                   if (TRUE) {
[13:35:06.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.719]                     {
[13:35:06.719]                       inherits <- base::inherits
[13:35:06.719]                       invokeRestart <- base::invokeRestart
[13:35:06.719]                       is.null <- base::is.null
[13:35:06.719]                       muffled <- FALSE
[13:35:06.719]                       if (inherits(cond, "message")) {
[13:35:06.719]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.719]                         if (muffled) 
[13:35:06.719]                           invokeRestart("muffleMessage")
[13:35:06.719]                       }
[13:35:06.719]                       else if (inherits(cond, "warning")) {
[13:35:06.719]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.719]                         if (muffled) 
[13:35:06.719]                           invokeRestart("muffleWarning")
[13:35:06.719]                       }
[13:35:06.719]                       else if (inherits(cond, "condition")) {
[13:35:06.719]                         if (!is.null(pattern)) {
[13:35:06.719]                           computeRestarts <- base::computeRestarts
[13:35:06.719]                           grepl <- base::grepl
[13:35:06.719]                           restarts <- computeRestarts(cond)
[13:35:06.719]                           for (restart in restarts) {
[13:35:06.719]                             name <- restart$name
[13:35:06.719]                             if (is.null(name)) 
[13:35:06.719]                               next
[13:35:06.719]                             if (!grepl(pattern, name)) 
[13:35:06.719]                               next
[13:35:06.719]                             invokeRestart(restart)
[13:35:06.719]                             muffled <- TRUE
[13:35:06.719]                             break
[13:35:06.719]                           }
[13:35:06.719]                         }
[13:35:06.719]                       }
[13:35:06.719]                       invisible(muffled)
[13:35:06.719]                     }
[13:35:06.719]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.719]                   }
[13:35:06.719]                 }
[13:35:06.719]             }
[13:35:06.719]         }))
[13:35:06.719]     }, error = function(ex) {
[13:35:06.719]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.719]                 ...future.rng), started = ...future.startTime, 
[13:35:06.719]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.719]             version = "1.8"), class = "FutureResult")
[13:35:06.719]     }, finally = {
[13:35:06.719]         if (!identical(...future.workdir, getwd())) 
[13:35:06.719]             setwd(...future.workdir)
[13:35:06.719]         {
[13:35:06.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.719]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.719]             }
[13:35:06.719]             base::options(...future.oldOptions)
[13:35:06.719]             if (.Platform$OS.type == "windows") {
[13:35:06.719]                 old_names <- names(...future.oldEnvVars)
[13:35:06.719]                 envs <- base::Sys.getenv()
[13:35:06.719]                 names <- names(envs)
[13:35:06.719]                 common <- intersect(names, old_names)
[13:35:06.719]                 added <- setdiff(names, old_names)
[13:35:06.719]                 removed <- setdiff(old_names, names)
[13:35:06.719]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.719]                   envs[common]]
[13:35:06.719]                 NAMES <- toupper(changed)
[13:35:06.719]                 args <- list()
[13:35:06.719]                 for (kk in seq_along(NAMES)) {
[13:35:06.719]                   name <- changed[[kk]]
[13:35:06.719]                   NAME <- NAMES[[kk]]
[13:35:06.719]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.719]                     next
[13:35:06.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.719]                 }
[13:35:06.719]                 NAMES <- toupper(added)
[13:35:06.719]                 for (kk in seq_along(NAMES)) {
[13:35:06.719]                   name <- added[[kk]]
[13:35:06.719]                   NAME <- NAMES[[kk]]
[13:35:06.719]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.719]                     next
[13:35:06.719]                   args[[name]] <- ""
[13:35:06.719]                 }
[13:35:06.719]                 NAMES <- toupper(removed)
[13:35:06.719]                 for (kk in seq_along(NAMES)) {
[13:35:06.719]                   name <- removed[[kk]]
[13:35:06.719]                   NAME <- NAMES[[kk]]
[13:35:06.719]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.719]                     next
[13:35:06.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.719]                 }
[13:35:06.719]                 if (length(args) > 0) 
[13:35:06.719]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.719]             }
[13:35:06.719]             else {
[13:35:06.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.719]             }
[13:35:06.719]             {
[13:35:06.719]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.719]                   0L) {
[13:35:06.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.719]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.719]                   base::options(opts)
[13:35:06.719]                 }
[13:35:06.719]                 {
[13:35:06.719]                   {
[13:35:06.719]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:06.719]                     NULL
[13:35:06.719]                   }
[13:35:06.719]                   options(future.plan = NULL)
[13:35:06.719]                   if (is.na(NA_character_)) 
[13:35:06.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.719]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.719]                     .init = FALSE)
[13:35:06.719]                 }
[13:35:06.719]             }
[13:35:06.719]         }
[13:35:06.719]     })
[13:35:06.719]     if (TRUE) {
[13:35:06.719]         base::sink(type = "output", split = FALSE)
[13:35:06.719]         if (TRUE) {
[13:35:06.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.719]         }
[13:35:06.719]         else {
[13:35:06.719]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.719]         }
[13:35:06.719]         base::close(...future.stdout)
[13:35:06.719]         ...future.stdout <- NULL
[13:35:06.719]     }
[13:35:06.719]     ...future.result$conditions <- ...future.conditions
[13:35:06.719]     ...future.result$finished <- base::Sys.time()
[13:35:06.719]     ...future.result
[13:35:06.719] }
[13:35:06.722] assign_globals() ...
[13:35:06.723] List of 11
[13:35:06.723]  $ ...future.FUN            :function (x, ...)  
[13:35:06.723]  $ x_FUN                    :function (x)  
[13:35:06.723]  $ times                    : int 0
[13:35:06.723]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.723]  $ stop_if_not              :function (...)  
[13:35:06.723]  $ dim                      : NULL
[13:35:06.723]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:06.723]  $ future.call.arguments    : list()
[13:35:06.723]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.723]  $ ...future.elements_ii    :List of 5
[13:35:06.723]   ..$ : int 6
[13:35:06.723]   ..$ : int 7
[13:35:06.723]   ..$ : int 8
[13:35:06.723]   ..$ : int 9
[13:35:06.723]   ..$ : int 10
[13:35:06.723]  $ ...future.seeds_ii       : NULL
[13:35:06.723]  $ ...future.globals.maxSize: NULL
[13:35:06.723]  - attr(*, "where")=List of 11
[13:35:06.723]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.723]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.723]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.723]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.723]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.723]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.723]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.723]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.723]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.723]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.723]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.723]  - attr(*, "resolved")= logi FALSE
[13:35:06.723]  - attr(*, "total_size")= num 95472
[13:35:06.723]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.723]  - attr(*, "already-done")= logi TRUE
[13:35:06.738] - copied ‘...future.FUN’ to environment
[13:35:06.739] - reassign environment for ‘x_FUN’
[13:35:06.739] - copied ‘x_FUN’ to environment
[13:35:06.739] - copied ‘times’ to environment
[13:35:06.739] - copied ‘stopf’ to environment
[13:35:06.739] - copied ‘stop_if_not’ to environment
[13:35:06.739] - copied ‘dim’ to environment
[13:35:06.739] - copied ‘valid_types’ to environment
[13:35:06.739] - copied ‘future.call.arguments’ to environment
[13:35:06.739] - copied ‘...future.elements_ii’ to environment
[13:35:06.740] - copied ‘...future.seeds_ii’ to environment
[13:35:06.740] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.740] assign_globals() ... done
[13:35:06.740] requestCore(): workers = 2
[13:35:06.742] MulticoreFuture started
[13:35:06.743] - Launch lazy future ... done
[13:35:06.743] run() for ‘MulticoreFuture’ ... done
[13:35:06.743] Created future:
[13:35:06.744] plan(): Setting new future strategy stack:
[13:35:06.744] List of future strategies:
[13:35:06.744] 1. sequential:
[13:35:06.744]    - args: function (..., envir = parent.frame())
[13:35:06.744]    - tweaked: FALSE
[13:35:06.744]    - call: NULL
[13:35:06.745] plan(): nbrOfWorkers() = 1
[13:35:06.747] plan(): Setting new future strategy stack:
[13:35:06.747] List of future strategies:
[13:35:06.747] 1. multicore:
[13:35:06.747]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:06.747]    - tweaked: FALSE
[13:35:06.747]    - call: plan(strategy)
[13:35:06.753] plan(): nbrOfWorkers() = 2
[13:35:06.743] MulticoreFuture:
[13:35:06.743] Label: ‘future_vapply-2’
[13:35:06.743] Expression:
[13:35:06.743] {
[13:35:06.743]     do.call(function(...) {
[13:35:06.743]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.743]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.743]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.743]             on.exit(options(oopts), add = TRUE)
[13:35:06.743]         }
[13:35:06.743]         {
[13:35:06.743]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.743]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.743]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.743]             })
[13:35:06.743]         }
[13:35:06.743]     }, args = future.call.arguments)
[13:35:06.743] }
[13:35:06.743] Lazy evaluation: FALSE
[13:35:06.743] Asynchronous evaluation: TRUE
[13:35:06.743] Local evaluation: TRUE
[13:35:06.743] Environment: R_GlobalEnv
[13:35:06.743] Capture standard output: TRUE
[13:35:06.743] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.743] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.743] Packages: 1 packages (‘future.apply’)
[13:35:06.743] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.743] Resolved: TRUE
[13:35:06.743] Value: <not collected>
[13:35:06.743] Conditions captured: <none>
[13:35:06.743] Early signaling: FALSE
[13:35:06.743] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.743] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.755] Chunk #2 of 2 ... DONE
[13:35:06.755] Launching 2 futures (chunks) ... DONE
[13:35:06.755] Resolving 2 futures (chunks) ...
[13:35:06.755] resolve() on list ...
[13:35:06.755]  recursive: 0
[13:35:06.755]  length: 2
[13:35:06.756] 
[13:35:06.756] Future #1
[13:35:06.756] result() for MulticoreFuture ...
[13:35:06.757] result() for MulticoreFuture ...
[13:35:06.757] result() for MulticoreFuture ... done
[13:35:06.757] result() for MulticoreFuture ... done
[13:35:06.758] result() for MulticoreFuture ...
[13:35:06.758] result() for MulticoreFuture ... done
[13:35:06.758] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:06.758] - nx: 2
[13:35:06.758] - relay: TRUE
[13:35:06.758] - stdout: TRUE
[13:35:06.759] - signal: TRUE
[13:35:06.759] - resignal: FALSE
[13:35:06.759] - force: TRUE
[13:35:06.759] - relayed: [n=2] FALSE, FALSE
[13:35:06.759] - queued futures: [n=2] FALSE, FALSE
[13:35:06.759]  - until=1
[13:35:06.760]  - relaying element #1
[13:35:06.760] result() for MulticoreFuture ...
[13:35:06.760] result() for MulticoreFuture ... done
[13:35:06.760] result() for MulticoreFuture ...
[13:35:06.760] result() for MulticoreFuture ... done
[13:35:06.760] result() for MulticoreFuture ...
[13:35:06.761] result() for MulticoreFuture ... done
[13:35:06.761] result() for MulticoreFuture ...
[13:35:06.761] result() for MulticoreFuture ... done
[13:35:06.761] - relayed: [n=2] TRUE, FALSE
[13:35:06.761] - queued futures: [n=2] TRUE, FALSE
[13:35:06.761] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:06.762]  length: 1 (resolved future 1)
[13:35:06.762] Future #2
[13:35:06.762] result() for MulticoreFuture ...
[13:35:06.763] result() for MulticoreFuture ...
[13:35:06.763] result() for MulticoreFuture ... done
[13:35:06.763] result() for MulticoreFuture ... done
[13:35:06.763] result() for MulticoreFuture ...
[13:35:06.763] result() for MulticoreFuture ... done
[13:35:06.764] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:06.764] - nx: 2
[13:35:06.764] - relay: TRUE
[13:35:06.764] - stdout: TRUE
[13:35:06.764] - signal: TRUE
[13:35:06.764] - resignal: FALSE
[13:35:06.764] - force: TRUE
[13:35:06.764] - relayed: [n=2] TRUE, FALSE
[13:35:06.764] - queued futures: [n=2] TRUE, FALSE
[13:35:06.765]  - until=2
[13:35:06.765]  - relaying element #2
[13:35:06.765] result() for MulticoreFuture ...
[13:35:06.765] result() for MulticoreFuture ... done
[13:35:06.765] result() for MulticoreFuture ...
[13:35:06.765] result() for MulticoreFuture ... done
[13:35:06.765] result() for MulticoreFuture ...
[13:35:06.765] result() for MulticoreFuture ... done
[13:35:06.766] result() for MulticoreFuture ...
[13:35:06.766] result() for MulticoreFuture ... done
[13:35:06.766] - relayed: [n=2] TRUE, TRUE
[13:35:06.766] - queued futures: [n=2] TRUE, TRUE
[13:35:06.766] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:06.766]  length: 0 (resolved future 2)
[13:35:06.766] Relaying remaining futures
[13:35:06.766] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.767] - nx: 2
[13:35:06.767] - relay: TRUE
[13:35:06.767] - stdout: TRUE
[13:35:06.767] - signal: TRUE
[13:35:06.767] - resignal: FALSE
[13:35:06.767] - force: TRUE
[13:35:06.767] - relayed: [n=2] TRUE, TRUE
[13:35:06.767] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:06.767] - relayed: [n=2] TRUE, TRUE
[13:35:06.767] - queued futures: [n=2] TRUE, TRUE
[13:35:06.768] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.768] resolve() on list ... DONE
[13:35:06.768] result() for MulticoreFuture ...
[13:35:06.768] result() for MulticoreFuture ... done
[13:35:06.768] result() for MulticoreFuture ...
[13:35:06.768] result() for MulticoreFuture ... done
[13:35:06.768] result() for MulticoreFuture ...
[13:35:06.768] result() for MulticoreFuture ... done
[13:35:06.769] result() for MulticoreFuture ...
[13:35:06.769] result() for MulticoreFuture ... done
[13:35:06.769]  - Number of value chunks collected: 2
[13:35:06.769] Resolving 2 futures (chunks) ... DONE
[13:35:06.769] Reducing values from 2 chunks ...
[13:35:06.769]  - Number of values collected after concatenation: 10
[13:35:06.769]  - Number of values expected: 10
[13:35:06.769] Reducing values from 2 chunks ... DONE
[13:35:06.769] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[13:35:06.771] future_lapply() ...
[13:35:06.779] Number of chunks: 2
[13:35:06.780] getGlobalsAndPackagesXApply() ...
[13:35:06.780]  - future.globals: TRUE
[13:35:06.780] getGlobalsAndPackages() ...
[13:35:06.780] Searching for globals...
[13:35:06.784] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[13:35:06.785] Searching for globals ... DONE
[13:35:06.785] Resolving globals: FALSE
[13:35:06.786] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[13:35:06.786] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:06.786] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.786] - packages: [1] ‘future.apply’
[13:35:06.786] getGlobalsAndPackages() ... DONE
[13:35:06.787]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.787]  - needed namespaces: [n=1] ‘future.apply’
[13:35:06.787] Finding globals ... DONE
[13:35:06.787]  - use_args: TRUE
[13:35:06.787]  - Getting '...' globals ...
[13:35:06.787] resolve() on list ...
[13:35:06.787]  recursive: 0
[13:35:06.788]  length: 1
[13:35:06.788]  elements: ‘...’
[13:35:06.788]  length: 0 (resolved future 1)
[13:35:06.788] resolve() on list ... DONE
[13:35:06.788]    - '...' content: [n=0] 
[13:35:06.788] List of 1
[13:35:06.788]  $ ...: list()
[13:35:06.788]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.788]  - attr(*, "where")=List of 1
[13:35:06.788]   ..$ ...:<environment: 0x5574d0a52cf8> 
[13:35:06.788]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.788]  - attr(*, "resolved")= logi TRUE
[13:35:06.788]  - attr(*, "total_size")= num NA
[13:35:06.791]  - Getting '...' globals ... DONE
[13:35:06.791] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:06.791] List of 8
[13:35:06.791]  $ ...future.FUN:function (x, ...)  
[13:35:06.791]  $ x_FUN        :function (x)  
[13:35:06.791]  $ times        : int 0
[13:35:06.791]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.791]  $ stop_if_not  :function (...)  
[13:35:06.791]  $ dim          : NULL
[13:35:06.791]  $ valid_types  : chr [1:2] "logical" "integer"
[13:35:06.791]  $ ...          : list()
[13:35:06.791]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.791]  - attr(*, "where")=List of 8
[13:35:06.791]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.791]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:06.791]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:06.791]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:06.791]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:06.791]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:06.791]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:06.791]   ..$ ...          :<environment: 0x5574d0a52cf8> 
[13:35:06.791]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.791]  - attr(*, "resolved")= logi FALSE
[13:35:06.791]  - attr(*, "total_size")= num 95400
[13:35:06.796] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:06.796] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.796] Number of futures (= number of chunks): 2
[13:35:06.797] Launching 2 futures (chunks) ...
[13:35:06.797] Chunk #1 of 2 ...
[13:35:06.797]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.797] getGlobalsAndPackages() ...
[13:35:06.799] Searching for globals...
[13:35:06.799] 
[13:35:06.799] Searching for globals ... DONE
[13:35:06.799] - globals: [0] <none>
[13:35:06.799] getGlobalsAndPackages() ... DONE
[13:35:06.799]    + additional globals found: [n=0] 
[13:35:06.800]    + additional namespaces needed: [n=0] 
[13:35:06.800]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.800]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:06.800]  - seeds: <none>
[13:35:06.800]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.800] getGlobalsAndPackages() ...
[13:35:06.800] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.800] Resolving globals: FALSE
[13:35:06.800] Tweak future expression to call with '...' arguments ...
[13:35:06.801] {
[13:35:06.801]     do.call(function(...) {
[13:35:06.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.801]             on.exit(options(oopts), add = TRUE)
[13:35:06.801]         }
[13:35:06.801]         {
[13:35:06.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.801]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.801]             })
[13:35:06.801]         }
[13:35:06.801]     }, args = future.call.arguments)
[13:35:06.801] }
[13:35:06.801] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.801] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.801] - packages: [1] ‘future.apply’
[13:35:06.802] getGlobalsAndPackages() ... DONE
[13:35:06.802] run() for ‘Future’ ...
[13:35:06.802] - state: ‘created’
[13:35:06.802] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:06.806] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.806] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:06.806]   - Field: ‘label’
[13:35:06.806]   - Field: ‘local’
[13:35:06.806]   - Field: ‘owner’
[13:35:06.806]   - Field: ‘envir’
[13:35:06.806]   - Field: ‘workers’
[13:35:06.807]   - Field: ‘packages’
[13:35:06.807]   - Field: ‘gc’
[13:35:06.807]   - Field: ‘job’
[13:35:06.807]   - Field: ‘conditions’
[13:35:06.807]   - Field: ‘expr’
[13:35:06.807]   - Field: ‘uuid’
[13:35:06.807]   - Field: ‘seed’
[13:35:06.807]   - Field: ‘version’
[13:35:06.807]   - Field: ‘result’
[13:35:06.807]   - Field: ‘asynchronous’
[13:35:06.807]   - Field: ‘calls’
[13:35:06.808]   - Field: ‘globals’
[13:35:06.808]   - Field: ‘stdout’
[13:35:06.808]   - Field: ‘earlySignal’
[13:35:06.808]   - Field: ‘lazy’
[13:35:06.808]   - Field: ‘state’
[13:35:06.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:06.808] - Launch lazy future ...
[13:35:06.808] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.808] Packages needed by future strategies (n = 0): <none>
[13:35:06.809] {
[13:35:06.809]     {
[13:35:06.809]         {
[13:35:06.809]             ...future.startTime <- base::Sys.time()
[13:35:06.809]             {
[13:35:06.809]                 {
[13:35:06.809]                   {
[13:35:06.809]                     {
[13:35:06.809]                       {
[13:35:06.809]                         base::local({
[13:35:06.809]                           has_future <- base::requireNamespace("future", 
[13:35:06.809]                             quietly = TRUE)
[13:35:06.809]                           if (has_future) {
[13:35:06.809]                             ns <- base::getNamespace("future")
[13:35:06.809]                             version <- ns[[".package"]][["version"]]
[13:35:06.809]                             if (is.null(version)) 
[13:35:06.809]                               version <- utils::packageVersion("future")
[13:35:06.809]                           }
[13:35:06.809]                           else {
[13:35:06.809]                             version <- NULL
[13:35:06.809]                           }
[13:35:06.809]                           if (!has_future || version < "1.8.0") {
[13:35:06.809]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.809]                               "", base::R.version$version.string), 
[13:35:06.809]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:06.809]                                 base::R.version$platform, 8 * 
[13:35:06.809]                                   base::.Machine$sizeof.pointer), 
[13:35:06.809]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.809]                                 "release", "version")], collapse = " "), 
[13:35:06.809]                               hostname = base::Sys.info()[["nodename"]])
[13:35:06.809]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.809]                               info)
[13:35:06.809]                             info <- base::paste(info, collapse = "; ")
[13:35:06.809]                             if (!has_future) {
[13:35:06.809]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.809]                                 info)
[13:35:06.809]                             }
[13:35:06.809]                             else {
[13:35:06.809]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.809]                                 info, version)
[13:35:06.809]                             }
[13:35:06.809]                             base::stop(msg)
[13:35:06.809]                           }
[13:35:06.809]                         })
[13:35:06.809]                       }
[13:35:06.809]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:06.809]                       base::options(mc.cores = 1L)
[13:35:06.809]                     }
[13:35:06.809]                     base::local({
[13:35:06.809]                       for (pkg in "future.apply") {
[13:35:06.809]                         base::loadNamespace(pkg)
[13:35:06.809]                         base::library(pkg, character.only = TRUE)
[13:35:06.809]                       }
[13:35:06.809]                     })
[13:35:06.809]                   }
[13:35:06.809]                   ...future.strategy.old <- future::plan("list")
[13:35:06.809]                   options(future.plan = NULL)
[13:35:06.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.809]                 }
[13:35:06.809]                 ...future.workdir <- getwd()
[13:35:06.809]             }
[13:35:06.809]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.809]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.809]         }
[13:35:06.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.809]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:06.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.809]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.809]             base::names(...future.oldOptions))
[13:35:06.809]     }
[13:35:06.809]     if (FALSE) {
[13:35:06.809]     }
[13:35:06.809]     else {
[13:35:06.809]         if (TRUE) {
[13:35:06.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.809]                 open = "w")
[13:35:06.809]         }
[13:35:06.809]         else {
[13:35:06.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.809]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.809]         }
[13:35:06.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.809]             base::sink(type = "output", split = FALSE)
[13:35:06.809]             base::close(...future.stdout)
[13:35:06.809]         }, add = TRUE)
[13:35:06.809]     }
[13:35:06.809]     ...future.frame <- base::sys.nframe()
[13:35:06.809]     ...future.conditions <- base::list()
[13:35:06.809]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.809]     if (FALSE) {
[13:35:06.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.809]     }
[13:35:06.809]     ...future.result <- base::tryCatch({
[13:35:06.809]         base::withCallingHandlers({
[13:35:06.809]             ...future.value <- base::withVisible(base::local({
[13:35:06.809]                 withCallingHandlers({
[13:35:06.809]                   {
[13:35:06.809]                     do.call(function(...) {
[13:35:06.809]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.809]                       if (!identical(...future.globals.maxSize.org, 
[13:35:06.809]                         ...future.globals.maxSize)) {
[13:35:06.809]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.809]                         on.exit(options(oopts), add = TRUE)
[13:35:06.809]                       }
[13:35:06.809]                       {
[13:35:06.809]                         lapply(seq_along(...future.elements_ii), 
[13:35:06.809]                           FUN = function(jj) {
[13:35:06.809]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.809]                             ...future.FUN(...future.X_jj, ...)
[13:35:06.809]                           })
[13:35:06.809]                       }
[13:35:06.809]                     }, args = future.call.arguments)
[13:35:06.809]                   }
[13:35:06.809]                 }, immediateCondition = function(cond) {
[13:35:06.809]                   save_rds <- function (object, pathname, ...) 
[13:35:06.809]                   {
[13:35:06.809]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:06.809]                     if (file_test("-f", pathname_tmp)) {
[13:35:06.809]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.809]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:06.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.809]                         fi_tmp[["mtime"]])
[13:35:06.809]                     }
[13:35:06.809]                     tryCatch({
[13:35:06.809]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:06.809]                     }, error = function(ex) {
[13:35:06.809]                       msg <- conditionMessage(ex)
[13:35:06.809]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.809]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:06.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.809]                         fi_tmp[["mtime"]], msg)
[13:35:06.809]                       ex$message <- msg
[13:35:06.809]                       stop(ex)
[13:35:06.809]                     })
[13:35:06.809]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:06.809]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:06.809]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:06.809]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.809]                       fi <- file.info(pathname)
[13:35:06.809]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:06.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.809]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:06.809]                         fi[["size"]], fi[["mtime"]])
[13:35:06.809]                       stop(msg)
[13:35:06.809]                     }
[13:35:06.809]                     invisible(pathname)
[13:35:06.809]                   }
[13:35:06.809]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:06.809]                     rootPath = tempdir()) 
[13:35:06.809]                   {
[13:35:06.809]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:06.809]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:06.809]                       tmpdir = path, fileext = ".rds")
[13:35:06.809]                     save_rds(obj, file)
[13:35:06.809]                   }
[13:35:06.809]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:06.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.809]                   {
[13:35:06.809]                     inherits <- base::inherits
[13:35:06.809]                     invokeRestart <- base::invokeRestart
[13:35:06.809]                     is.null <- base::is.null
[13:35:06.809]                     muffled <- FALSE
[13:35:06.809]                     if (inherits(cond, "message")) {
[13:35:06.809]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:06.809]                       if (muffled) 
[13:35:06.809]                         invokeRestart("muffleMessage")
[13:35:06.809]                     }
[13:35:06.809]                     else if (inherits(cond, "warning")) {
[13:35:06.809]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:06.809]                       if (muffled) 
[13:35:06.809]                         invokeRestart("muffleWarning")
[13:35:06.809]                     }
[13:35:06.809]                     else if (inherits(cond, "condition")) {
[13:35:06.809]                       if (!is.null(pattern)) {
[13:35:06.809]                         computeRestarts <- base::computeRestarts
[13:35:06.809]                         grepl <- base::grepl
[13:35:06.809]                         restarts <- computeRestarts(cond)
[13:35:06.809]                         for (restart in restarts) {
[13:35:06.809]                           name <- restart$name
[13:35:06.809]                           if (is.null(name)) 
[13:35:06.809]                             next
[13:35:06.809]                           if (!grepl(pattern, name)) 
[13:35:06.809]                             next
[13:35:06.809]                           invokeRestart(restart)
[13:35:06.809]                           muffled <- TRUE
[13:35:06.809]                           break
[13:35:06.809]                         }
[13:35:06.809]                       }
[13:35:06.809]                     }
[13:35:06.809]                     invisible(muffled)
[13:35:06.809]                   }
[13:35:06.809]                   muffleCondition(cond)
[13:35:06.809]                 })
[13:35:06.809]             }))
[13:35:06.809]             future::FutureResult(value = ...future.value$value, 
[13:35:06.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.809]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.809]                     ...future.globalenv.names))
[13:35:06.809]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.809]         }, condition = base::local({
[13:35:06.809]             c <- base::c
[13:35:06.809]             inherits <- base::inherits
[13:35:06.809]             invokeRestart <- base::invokeRestart
[13:35:06.809]             length <- base::length
[13:35:06.809]             list <- base::list
[13:35:06.809]             seq.int <- base::seq.int
[13:35:06.809]             signalCondition <- base::signalCondition
[13:35:06.809]             sys.calls <- base::sys.calls
[13:35:06.809]             `[[` <- base::`[[`
[13:35:06.809]             `+` <- base::`+`
[13:35:06.809]             `<<-` <- base::`<<-`
[13:35:06.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.809]                   3L)]
[13:35:06.809]             }
[13:35:06.809]             function(cond) {
[13:35:06.809]                 is_error <- inherits(cond, "error")
[13:35:06.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.809]                   NULL)
[13:35:06.809]                 if (is_error) {
[13:35:06.809]                   sessionInformation <- function() {
[13:35:06.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.809]                       search = base::search(), system = base::Sys.info())
[13:35:06.809]                   }
[13:35:06.809]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.809]                     cond$call), session = sessionInformation(), 
[13:35:06.809]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.809]                   signalCondition(cond)
[13:35:06.809]                 }
[13:35:06.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.809]                 "immediateCondition"))) {
[13:35:06.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.809]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.809]                   if (TRUE && !signal) {
[13:35:06.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.809]                     {
[13:35:06.809]                       inherits <- base::inherits
[13:35:06.809]                       invokeRestart <- base::invokeRestart
[13:35:06.809]                       is.null <- base::is.null
[13:35:06.809]                       muffled <- FALSE
[13:35:06.809]                       if (inherits(cond, "message")) {
[13:35:06.809]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.809]                         if (muffled) 
[13:35:06.809]                           invokeRestart("muffleMessage")
[13:35:06.809]                       }
[13:35:06.809]                       else if (inherits(cond, "warning")) {
[13:35:06.809]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.809]                         if (muffled) 
[13:35:06.809]                           invokeRestart("muffleWarning")
[13:35:06.809]                       }
[13:35:06.809]                       else if (inherits(cond, "condition")) {
[13:35:06.809]                         if (!is.null(pattern)) {
[13:35:06.809]                           computeRestarts <- base::computeRestarts
[13:35:06.809]                           grepl <- base::grepl
[13:35:06.809]                           restarts <- computeRestarts(cond)
[13:35:06.809]                           for (restart in restarts) {
[13:35:06.809]                             name <- restart$name
[13:35:06.809]                             if (is.null(name)) 
[13:35:06.809]                               next
[13:35:06.809]                             if (!grepl(pattern, name)) 
[13:35:06.809]                               next
[13:35:06.809]                             invokeRestart(restart)
[13:35:06.809]                             muffled <- TRUE
[13:35:06.809]                             break
[13:35:06.809]                           }
[13:35:06.809]                         }
[13:35:06.809]                       }
[13:35:06.809]                       invisible(muffled)
[13:35:06.809]                     }
[13:35:06.809]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.809]                   }
[13:35:06.809]                 }
[13:35:06.809]                 else {
[13:35:06.809]                   if (TRUE) {
[13:35:06.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.809]                     {
[13:35:06.809]                       inherits <- base::inherits
[13:35:06.809]                       invokeRestart <- base::invokeRestart
[13:35:06.809]                       is.null <- base::is.null
[13:35:06.809]                       muffled <- FALSE
[13:35:06.809]                       if (inherits(cond, "message")) {
[13:35:06.809]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.809]                         if (muffled) 
[13:35:06.809]                           invokeRestart("muffleMessage")
[13:35:06.809]                       }
[13:35:06.809]                       else if (inherits(cond, "warning")) {
[13:35:06.809]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.809]                         if (muffled) 
[13:35:06.809]                           invokeRestart("muffleWarning")
[13:35:06.809]                       }
[13:35:06.809]                       else if (inherits(cond, "condition")) {
[13:35:06.809]                         if (!is.null(pattern)) {
[13:35:06.809]                           computeRestarts <- base::computeRestarts
[13:35:06.809]                           grepl <- base::grepl
[13:35:06.809]                           restarts <- computeRestarts(cond)
[13:35:06.809]                           for (restart in restarts) {
[13:35:06.809]                             name <- restart$name
[13:35:06.809]                             if (is.null(name)) 
[13:35:06.809]                               next
[13:35:06.809]                             if (!grepl(pattern, name)) 
[13:35:06.809]                               next
[13:35:06.809]                             invokeRestart(restart)
[13:35:06.809]                             muffled <- TRUE
[13:35:06.809]                             break
[13:35:06.809]                           }
[13:35:06.809]                         }
[13:35:06.809]                       }
[13:35:06.809]                       invisible(muffled)
[13:35:06.809]                     }
[13:35:06.809]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.809]                   }
[13:35:06.809]                 }
[13:35:06.809]             }
[13:35:06.809]         }))
[13:35:06.809]     }, error = function(ex) {
[13:35:06.809]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.809]                 ...future.rng), started = ...future.startTime, 
[13:35:06.809]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.809]             version = "1.8"), class = "FutureResult")
[13:35:06.809]     }, finally = {
[13:35:06.809]         if (!identical(...future.workdir, getwd())) 
[13:35:06.809]             setwd(...future.workdir)
[13:35:06.809]         {
[13:35:06.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.809]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.809]             }
[13:35:06.809]             base::options(...future.oldOptions)
[13:35:06.809]             if (.Platform$OS.type == "windows") {
[13:35:06.809]                 old_names <- names(...future.oldEnvVars)
[13:35:06.809]                 envs <- base::Sys.getenv()
[13:35:06.809]                 names <- names(envs)
[13:35:06.809]                 common <- intersect(names, old_names)
[13:35:06.809]                 added <- setdiff(names, old_names)
[13:35:06.809]                 removed <- setdiff(old_names, names)
[13:35:06.809]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.809]                   envs[common]]
[13:35:06.809]                 NAMES <- toupper(changed)
[13:35:06.809]                 args <- list()
[13:35:06.809]                 for (kk in seq_along(NAMES)) {
[13:35:06.809]                   name <- changed[[kk]]
[13:35:06.809]                   NAME <- NAMES[[kk]]
[13:35:06.809]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.809]                     next
[13:35:06.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.809]                 }
[13:35:06.809]                 NAMES <- toupper(added)
[13:35:06.809]                 for (kk in seq_along(NAMES)) {
[13:35:06.809]                   name <- added[[kk]]
[13:35:06.809]                   NAME <- NAMES[[kk]]
[13:35:06.809]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.809]                     next
[13:35:06.809]                   args[[name]] <- ""
[13:35:06.809]                 }
[13:35:06.809]                 NAMES <- toupper(removed)
[13:35:06.809]                 for (kk in seq_along(NAMES)) {
[13:35:06.809]                   name <- removed[[kk]]
[13:35:06.809]                   NAME <- NAMES[[kk]]
[13:35:06.809]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.809]                     next
[13:35:06.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.809]                 }
[13:35:06.809]                 if (length(args) > 0) 
[13:35:06.809]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.809]             }
[13:35:06.809]             else {
[13:35:06.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.809]             }
[13:35:06.809]             {
[13:35:06.809]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.809]                   0L) {
[13:35:06.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.809]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.809]                   base::options(opts)
[13:35:06.809]                 }
[13:35:06.809]                 {
[13:35:06.809]                   {
[13:35:06.809]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:06.809]                     NULL
[13:35:06.809]                   }
[13:35:06.809]                   options(future.plan = NULL)
[13:35:06.809]                   if (is.na(NA_character_)) 
[13:35:06.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.809]                     .init = FALSE)
[13:35:06.809]                 }
[13:35:06.809]             }
[13:35:06.809]         }
[13:35:06.809]     })
[13:35:06.809]     if (TRUE) {
[13:35:06.809]         base::sink(type = "output", split = FALSE)
[13:35:06.809]         if (TRUE) {
[13:35:06.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.809]         }
[13:35:06.809]         else {
[13:35:06.809]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.809]         }
[13:35:06.809]         base::close(...future.stdout)
[13:35:06.809]         ...future.stdout <- NULL
[13:35:06.809]     }
[13:35:06.809]     ...future.result$conditions <- ...future.conditions
[13:35:06.809]     ...future.result$finished <- base::Sys.time()
[13:35:06.809]     ...future.result
[13:35:06.809] }
[13:35:06.811] assign_globals() ...
[13:35:06.812] List of 11
[13:35:06.812]  $ ...future.FUN            :function (x, ...)  
[13:35:06.812]  $ x_FUN                    :function (x)  
[13:35:06.812]  $ times                    : int 0
[13:35:06.812]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.812]  $ stop_if_not              :function (...)  
[13:35:06.812]  $ dim                      : NULL
[13:35:06.812]  $ valid_types              : chr [1:2] "logical" "integer"
[13:35:06.812]  $ future.call.arguments    : list()
[13:35:06.812]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.812]  $ ...future.elements_ii    :List of 5
[13:35:06.812]   ..$ : int 1
[13:35:06.812]   ..$ : int 2
[13:35:06.812]   ..$ : int 3
[13:35:06.812]   ..$ : int 4
[13:35:06.812]   ..$ : int 5
[13:35:06.812]  $ ...future.seeds_ii       : NULL
[13:35:06.812]  $ ...future.globals.maxSize: NULL
[13:35:06.812]  - attr(*, "where")=List of 11
[13:35:06.812]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.812]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.812]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.812]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.812]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.812]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.812]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.812]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.812]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.812]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.812]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.812]  - attr(*, "resolved")= logi FALSE
[13:35:06.812]  - attr(*, "total_size")= num 95400
[13:35:06.812]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.812]  - attr(*, "already-done")= logi TRUE
[13:35:06.820] - copied ‘...future.FUN’ to environment
[13:35:06.820] - reassign environment for ‘x_FUN’
[13:35:06.820] - copied ‘x_FUN’ to environment
[13:35:06.820] - copied ‘times’ to environment
[13:35:06.820] - copied ‘stopf’ to environment
[13:35:06.820] - copied ‘stop_if_not’ to environment
[13:35:06.820] - copied ‘dim’ to environment
[13:35:06.820] - copied ‘valid_types’ to environment
[13:35:06.820] - copied ‘future.call.arguments’ to environment
[13:35:06.820] - copied ‘...future.elements_ii’ to environment
[13:35:06.821] - copied ‘...future.seeds_ii’ to environment
[13:35:06.821] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.821] assign_globals() ... done
[13:35:06.821] requestCore(): workers = 2
[13:35:06.825] MulticoreFuture started
[13:35:06.825] - Launch lazy future ... done
[13:35:06.826] run() for ‘MulticoreFuture’ ... done
[13:35:06.827] Created future:
[13:35:06.827] plan(): Setting new future strategy stack:
[13:35:06.827] List of future strategies:
[13:35:06.827] 1. sequential:
[13:35:06.827]    - args: function (..., envir = parent.frame())
[13:35:06.827]    - tweaked: FALSE
[13:35:06.827]    - call: NULL
[13:35:06.829] plan(): nbrOfWorkers() = 1
[13:35:06.831] plan(): Setting new future strategy stack:
[13:35:06.831] List of future strategies:
[13:35:06.831] 1. multicore:
[13:35:06.831]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:06.831]    - tweaked: FALSE
[13:35:06.831]    - call: plan(strategy)
[13:35:06.838] plan(): nbrOfWorkers() = 2
[13:35:06.827] MulticoreFuture:
[13:35:06.827] Label: ‘future_vapply-1’
[13:35:06.827] Expression:
[13:35:06.827] {
[13:35:06.827]     do.call(function(...) {
[13:35:06.827]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.827]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.827]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.827]             on.exit(options(oopts), add = TRUE)
[13:35:06.827]         }
[13:35:06.827]         {
[13:35:06.827]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.827]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.827]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.827]             })
[13:35:06.827]         }
[13:35:06.827]     }, args = future.call.arguments)
[13:35:06.827] }
[13:35:06.827] Lazy evaluation: FALSE
[13:35:06.827] Asynchronous evaluation: TRUE
[13:35:06.827] Local evaluation: TRUE
[13:35:06.827] Environment: R_GlobalEnv
[13:35:06.827] Capture standard output: TRUE
[13:35:06.827] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.827] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.827] Packages: 1 packages (‘future.apply’)
[13:35:06.827] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.827] Resolved: TRUE
[13:35:06.827] Value: <not collected>
[13:35:06.827] Conditions captured: <none>
[13:35:06.827] Early signaling: FALSE
[13:35:06.827] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.827] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.839] Chunk #1 of 2 ... DONE
[13:35:06.840] Chunk #2 of 2 ...
[13:35:06.840]  - Finding globals in 'X' for chunk #2 ...
[13:35:06.840] getGlobalsAndPackages() ...
[13:35:06.840] Searching for globals...
[13:35:06.841] 
[13:35:06.841] Searching for globals ... DONE
[13:35:06.841] - globals: [0] <none>
[13:35:06.841] getGlobalsAndPackages() ... DONE
[13:35:06.842]    + additional globals found: [n=0] 
[13:35:06.842]    + additional namespaces needed: [n=0] 
[13:35:06.842]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:06.842]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:06.842]  - seeds: <none>
[13:35:06.843]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.843] getGlobalsAndPackages() ...
[13:35:06.843] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.843] Resolving globals: FALSE
[13:35:06.844] Tweak future expression to call with '...' arguments ...
[13:35:06.844] {
[13:35:06.844]     do.call(function(...) {
[13:35:06.844]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.844]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.844]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.844]             on.exit(options(oopts), add = TRUE)
[13:35:06.844]         }
[13:35:06.844]         {
[13:35:06.844]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.844]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.844]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.844]             })
[13:35:06.844]         }
[13:35:06.844]     }, args = future.call.arguments)
[13:35:06.844] }
[13:35:06.844] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.845] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.845] - packages: [1] ‘future.apply’
[13:35:06.846] getGlobalsAndPackages() ... DONE
[13:35:06.846] run() for ‘Future’ ...
[13:35:06.846] - state: ‘created’
[13:35:06.846] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:06.851] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.851] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:06.852]   - Field: ‘label’
[13:35:06.852]   - Field: ‘local’
[13:35:06.852]   - Field: ‘owner’
[13:35:06.852]   - Field: ‘envir’
[13:35:06.852]   - Field: ‘workers’
[13:35:06.852]   - Field: ‘packages’
[13:35:06.853]   - Field: ‘gc’
[13:35:06.853]   - Field: ‘job’
[13:35:06.853]   - Field: ‘conditions’
[13:35:06.853]   - Field: ‘expr’
[13:35:06.853]   - Field: ‘uuid’
[13:35:06.853]   - Field: ‘seed’
[13:35:06.853]   - Field: ‘version’
[13:35:06.853]   - Field: ‘result’
[13:35:06.854]   - Field: ‘asynchronous’
[13:35:06.854]   - Field: ‘calls’
[13:35:06.854]   - Field: ‘globals’
[13:35:06.854]   - Field: ‘stdout’
[13:35:06.854]   - Field: ‘earlySignal’
[13:35:06.854]   - Field: ‘lazy’
[13:35:06.854]   - Field: ‘state’
[13:35:06.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:06.855] - Launch lazy future ...
[13:35:06.855] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.855] Packages needed by future strategies (n = 0): <none>
[13:35:06.856] {
[13:35:06.856]     {
[13:35:06.856]         {
[13:35:06.856]             ...future.startTime <- base::Sys.time()
[13:35:06.856]             {
[13:35:06.856]                 {
[13:35:06.856]                   {
[13:35:06.856]                     {
[13:35:06.856]                       {
[13:35:06.856]                         base::local({
[13:35:06.856]                           has_future <- base::requireNamespace("future", 
[13:35:06.856]                             quietly = TRUE)
[13:35:06.856]                           if (has_future) {
[13:35:06.856]                             ns <- base::getNamespace("future")
[13:35:06.856]                             version <- ns[[".package"]][["version"]]
[13:35:06.856]                             if (is.null(version)) 
[13:35:06.856]                               version <- utils::packageVersion("future")
[13:35:06.856]                           }
[13:35:06.856]                           else {
[13:35:06.856]                             version <- NULL
[13:35:06.856]                           }
[13:35:06.856]                           if (!has_future || version < "1.8.0") {
[13:35:06.856]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.856]                               "", base::R.version$version.string), 
[13:35:06.856]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:06.856]                                 base::R.version$platform, 8 * 
[13:35:06.856]                                   base::.Machine$sizeof.pointer), 
[13:35:06.856]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.856]                                 "release", "version")], collapse = " "), 
[13:35:06.856]                               hostname = base::Sys.info()[["nodename"]])
[13:35:06.856]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.856]                               info)
[13:35:06.856]                             info <- base::paste(info, collapse = "; ")
[13:35:06.856]                             if (!has_future) {
[13:35:06.856]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.856]                                 info)
[13:35:06.856]                             }
[13:35:06.856]                             else {
[13:35:06.856]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.856]                                 info, version)
[13:35:06.856]                             }
[13:35:06.856]                             base::stop(msg)
[13:35:06.856]                           }
[13:35:06.856]                         })
[13:35:06.856]                       }
[13:35:06.856]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:06.856]                       base::options(mc.cores = 1L)
[13:35:06.856]                     }
[13:35:06.856]                     base::local({
[13:35:06.856]                       for (pkg in "future.apply") {
[13:35:06.856]                         base::loadNamespace(pkg)
[13:35:06.856]                         base::library(pkg, character.only = TRUE)
[13:35:06.856]                       }
[13:35:06.856]                     })
[13:35:06.856]                   }
[13:35:06.856]                   ...future.strategy.old <- future::plan("list")
[13:35:06.856]                   options(future.plan = NULL)
[13:35:06.856]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.856]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.856]                 }
[13:35:06.856]                 ...future.workdir <- getwd()
[13:35:06.856]             }
[13:35:06.856]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.856]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.856]         }
[13:35:06.856]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.856]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:06.856]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.856]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.856]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.856]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.856]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.856]             base::names(...future.oldOptions))
[13:35:06.856]     }
[13:35:06.856]     if (FALSE) {
[13:35:06.856]     }
[13:35:06.856]     else {
[13:35:06.856]         if (TRUE) {
[13:35:06.856]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.856]                 open = "w")
[13:35:06.856]         }
[13:35:06.856]         else {
[13:35:06.856]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.856]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.856]         }
[13:35:06.856]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.856]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.856]             base::sink(type = "output", split = FALSE)
[13:35:06.856]             base::close(...future.stdout)
[13:35:06.856]         }, add = TRUE)
[13:35:06.856]     }
[13:35:06.856]     ...future.frame <- base::sys.nframe()
[13:35:06.856]     ...future.conditions <- base::list()
[13:35:06.856]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.856]     if (FALSE) {
[13:35:06.856]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.856]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.856]     }
[13:35:06.856]     ...future.result <- base::tryCatch({
[13:35:06.856]         base::withCallingHandlers({
[13:35:06.856]             ...future.value <- base::withVisible(base::local({
[13:35:06.856]                 withCallingHandlers({
[13:35:06.856]                   {
[13:35:06.856]                     do.call(function(...) {
[13:35:06.856]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.856]                       if (!identical(...future.globals.maxSize.org, 
[13:35:06.856]                         ...future.globals.maxSize)) {
[13:35:06.856]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.856]                         on.exit(options(oopts), add = TRUE)
[13:35:06.856]                       }
[13:35:06.856]                       {
[13:35:06.856]                         lapply(seq_along(...future.elements_ii), 
[13:35:06.856]                           FUN = function(jj) {
[13:35:06.856]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.856]                             ...future.FUN(...future.X_jj, ...)
[13:35:06.856]                           })
[13:35:06.856]                       }
[13:35:06.856]                     }, args = future.call.arguments)
[13:35:06.856]                   }
[13:35:06.856]                 }, immediateCondition = function(cond) {
[13:35:06.856]                   save_rds <- function (object, pathname, ...) 
[13:35:06.856]                   {
[13:35:06.856]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:06.856]                     if (file_test("-f", pathname_tmp)) {
[13:35:06.856]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.856]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:06.856]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.856]                         fi_tmp[["mtime"]])
[13:35:06.856]                     }
[13:35:06.856]                     tryCatch({
[13:35:06.856]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:06.856]                     }, error = function(ex) {
[13:35:06.856]                       msg <- conditionMessage(ex)
[13:35:06.856]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.856]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:06.856]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.856]                         fi_tmp[["mtime"]], msg)
[13:35:06.856]                       ex$message <- msg
[13:35:06.856]                       stop(ex)
[13:35:06.856]                     })
[13:35:06.856]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:06.856]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:06.856]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:06.856]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.856]                       fi <- file.info(pathname)
[13:35:06.856]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:06.856]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.856]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:06.856]                         fi[["size"]], fi[["mtime"]])
[13:35:06.856]                       stop(msg)
[13:35:06.856]                     }
[13:35:06.856]                     invisible(pathname)
[13:35:06.856]                   }
[13:35:06.856]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:06.856]                     rootPath = tempdir()) 
[13:35:06.856]                   {
[13:35:06.856]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:06.856]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:06.856]                       tmpdir = path, fileext = ".rds")
[13:35:06.856]                     save_rds(obj, file)
[13:35:06.856]                   }
[13:35:06.856]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:06.856]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.856]                   {
[13:35:06.856]                     inherits <- base::inherits
[13:35:06.856]                     invokeRestart <- base::invokeRestart
[13:35:06.856]                     is.null <- base::is.null
[13:35:06.856]                     muffled <- FALSE
[13:35:06.856]                     if (inherits(cond, "message")) {
[13:35:06.856]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:06.856]                       if (muffled) 
[13:35:06.856]                         invokeRestart("muffleMessage")
[13:35:06.856]                     }
[13:35:06.856]                     else if (inherits(cond, "warning")) {
[13:35:06.856]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:06.856]                       if (muffled) 
[13:35:06.856]                         invokeRestart("muffleWarning")
[13:35:06.856]                     }
[13:35:06.856]                     else if (inherits(cond, "condition")) {
[13:35:06.856]                       if (!is.null(pattern)) {
[13:35:06.856]                         computeRestarts <- base::computeRestarts
[13:35:06.856]                         grepl <- base::grepl
[13:35:06.856]                         restarts <- computeRestarts(cond)
[13:35:06.856]                         for (restart in restarts) {
[13:35:06.856]                           name <- restart$name
[13:35:06.856]                           if (is.null(name)) 
[13:35:06.856]                             next
[13:35:06.856]                           if (!grepl(pattern, name)) 
[13:35:06.856]                             next
[13:35:06.856]                           invokeRestart(restart)
[13:35:06.856]                           muffled <- TRUE
[13:35:06.856]                           break
[13:35:06.856]                         }
[13:35:06.856]                       }
[13:35:06.856]                     }
[13:35:06.856]                     invisible(muffled)
[13:35:06.856]                   }
[13:35:06.856]                   muffleCondition(cond)
[13:35:06.856]                 })
[13:35:06.856]             }))
[13:35:06.856]             future::FutureResult(value = ...future.value$value, 
[13:35:06.856]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.856]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.856]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.856]                     ...future.globalenv.names))
[13:35:06.856]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.856]         }, condition = base::local({
[13:35:06.856]             c <- base::c
[13:35:06.856]             inherits <- base::inherits
[13:35:06.856]             invokeRestart <- base::invokeRestart
[13:35:06.856]             length <- base::length
[13:35:06.856]             list <- base::list
[13:35:06.856]             seq.int <- base::seq.int
[13:35:06.856]             signalCondition <- base::signalCondition
[13:35:06.856]             sys.calls <- base::sys.calls
[13:35:06.856]             `[[` <- base::`[[`
[13:35:06.856]             `+` <- base::`+`
[13:35:06.856]             `<<-` <- base::`<<-`
[13:35:06.856]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.856]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.856]                   3L)]
[13:35:06.856]             }
[13:35:06.856]             function(cond) {
[13:35:06.856]                 is_error <- inherits(cond, "error")
[13:35:06.856]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.856]                   NULL)
[13:35:06.856]                 if (is_error) {
[13:35:06.856]                   sessionInformation <- function() {
[13:35:06.856]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.856]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.856]                       search = base::search(), system = base::Sys.info())
[13:35:06.856]                   }
[13:35:06.856]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.856]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.856]                     cond$call), session = sessionInformation(), 
[13:35:06.856]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.856]                   signalCondition(cond)
[13:35:06.856]                 }
[13:35:06.856]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.856]                 "immediateCondition"))) {
[13:35:06.856]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.856]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.856]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.856]                   if (TRUE && !signal) {
[13:35:06.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.856]                     {
[13:35:06.856]                       inherits <- base::inherits
[13:35:06.856]                       invokeRestart <- base::invokeRestart
[13:35:06.856]                       is.null <- base::is.null
[13:35:06.856]                       muffled <- FALSE
[13:35:06.856]                       if (inherits(cond, "message")) {
[13:35:06.856]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.856]                         if (muffled) 
[13:35:06.856]                           invokeRestart("muffleMessage")
[13:35:06.856]                       }
[13:35:06.856]                       else if (inherits(cond, "warning")) {
[13:35:06.856]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.856]                         if (muffled) 
[13:35:06.856]                           invokeRestart("muffleWarning")
[13:35:06.856]                       }
[13:35:06.856]                       else if (inherits(cond, "condition")) {
[13:35:06.856]                         if (!is.null(pattern)) {
[13:35:06.856]                           computeRestarts <- base::computeRestarts
[13:35:06.856]                           grepl <- base::grepl
[13:35:06.856]                           restarts <- computeRestarts(cond)
[13:35:06.856]                           for (restart in restarts) {
[13:35:06.856]                             name <- restart$name
[13:35:06.856]                             if (is.null(name)) 
[13:35:06.856]                               next
[13:35:06.856]                             if (!grepl(pattern, name)) 
[13:35:06.856]                               next
[13:35:06.856]                             invokeRestart(restart)
[13:35:06.856]                             muffled <- TRUE
[13:35:06.856]                             break
[13:35:06.856]                           }
[13:35:06.856]                         }
[13:35:06.856]                       }
[13:35:06.856]                       invisible(muffled)
[13:35:06.856]                     }
[13:35:06.856]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.856]                   }
[13:35:06.856]                 }
[13:35:06.856]                 else {
[13:35:06.856]                   if (TRUE) {
[13:35:06.856]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.856]                     {
[13:35:06.856]                       inherits <- base::inherits
[13:35:06.856]                       invokeRestart <- base::invokeRestart
[13:35:06.856]                       is.null <- base::is.null
[13:35:06.856]                       muffled <- FALSE
[13:35:06.856]                       if (inherits(cond, "message")) {
[13:35:06.856]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.856]                         if (muffled) 
[13:35:06.856]                           invokeRestart("muffleMessage")
[13:35:06.856]                       }
[13:35:06.856]                       else if (inherits(cond, "warning")) {
[13:35:06.856]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.856]                         if (muffled) 
[13:35:06.856]                           invokeRestart("muffleWarning")
[13:35:06.856]                       }
[13:35:06.856]                       else if (inherits(cond, "condition")) {
[13:35:06.856]                         if (!is.null(pattern)) {
[13:35:06.856]                           computeRestarts <- base::computeRestarts
[13:35:06.856]                           grepl <- base::grepl
[13:35:06.856]                           restarts <- computeRestarts(cond)
[13:35:06.856]                           for (restart in restarts) {
[13:35:06.856]                             name <- restart$name
[13:35:06.856]                             if (is.null(name)) 
[13:35:06.856]                               next
[13:35:06.856]                             if (!grepl(pattern, name)) 
[13:35:06.856]                               next
[13:35:06.856]                             invokeRestart(restart)
[13:35:06.856]                             muffled <- TRUE
[13:35:06.856]                             break
[13:35:06.856]                           }
[13:35:06.856]                         }
[13:35:06.856]                       }
[13:35:06.856]                       invisible(muffled)
[13:35:06.856]                     }
[13:35:06.856]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.856]                   }
[13:35:06.856]                 }
[13:35:06.856]             }
[13:35:06.856]         }))
[13:35:06.856]     }, error = function(ex) {
[13:35:06.856]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.856]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.856]                 ...future.rng), started = ...future.startTime, 
[13:35:06.856]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.856]             version = "1.8"), class = "FutureResult")
[13:35:06.856]     }, finally = {
[13:35:06.856]         if (!identical(...future.workdir, getwd())) 
[13:35:06.856]             setwd(...future.workdir)
[13:35:06.856]         {
[13:35:06.856]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.856]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.856]             }
[13:35:06.856]             base::options(...future.oldOptions)
[13:35:06.856]             if (.Platform$OS.type == "windows") {
[13:35:06.856]                 old_names <- names(...future.oldEnvVars)
[13:35:06.856]                 envs <- base::Sys.getenv()
[13:35:06.856]                 names <- names(envs)
[13:35:06.856]                 common <- intersect(names, old_names)
[13:35:06.856]                 added <- setdiff(names, old_names)
[13:35:06.856]                 removed <- setdiff(old_names, names)
[13:35:06.856]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.856]                   envs[common]]
[13:35:06.856]                 NAMES <- toupper(changed)
[13:35:06.856]                 args <- list()
[13:35:06.856]                 for (kk in seq_along(NAMES)) {
[13:35:06.856]                   name <- changed[[kk]]
[13:35:06.856]                   NAME <- NAMES[[kk]]
[13:35:06.856]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.856]                     next
[13:35:06.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.856]                 }
[13:35:06.856]                 NAMES <- toupper(added)
[13:35:06.856]                 for (kk in seq_along(NAMES)) {
[13:35:06.856]                   name <- added[[kk]]
[13:35:06.856]                   NAME <- NAMES[[kk]]
[13:35:06.856]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.856]                     next
[13:35:06.856]                   args[[name]] <- ""
[13:35:06.856]                 }
[13:35:06.856]                 NAMES <- toupper(removed)
[13:35:06.856]                 for (kk in seq_along(NAMES)) {
[13:35:06.856]                   name <- removed[[kk]]
[13:35:06.856]                   NAME <- NAMES[[kk]]
[13:35:06.856]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.856]                     next
[13:35:06.856]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.856]                 }
[13:35:06.856]                 if (length(args) > 0) 
[13:35:06.856]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.856]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.856]             }
[13:35:06.856]             else {
[13:35:06.856]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.856]             }
[13:35:06.856]             {
[13:35:06.856]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.856]                   0L) {
[13:35:06.856]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.856]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.856]                   base::options(opts)
[13:35:06.856]                 }
[13:35:06.856]                 {
[13:35:06.856]                   {
[13:35:06.856]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:06.856]                     NULL
[13:35:06.856]                   }
[13:35:06.856]                   options(future.plan = NULL)
[13:35:06.856]                   if (is.na(NA_character_)) 
[13:35:06.856]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.856]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.856]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.856]                     .init = FALSE)
[13:35:06.856]                 }
[13:35:06.856]             }
[13:35:06.856]         }
[13:35:06.856]     })
[13:35:06.856]     if (TRUE) {
[13:35:06.856]         base::sink(type = "output", split = FALSE)
[13:35:06.856]         if (TRUE) {
[13:35:06.856]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.856]         }
[13:35:06.856]         else {
[13:35:06.856]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.856]         }
[13:35:06.856]         base::close(...future.stdout)
[13:35:06.856]         ...future.stdout <- NULL
[13:35:06.856]     }
[13:35:06.856]     ...future.result$conditions <- ...future.conditions
[13:35:06.856]     ...future.result$finished <- base::Sys.time()
[13:35:06.856]     ...future.result
[13:35:06.856] }
[13:35:06.859] assign_globals() ...
[13:35:06.859] List of 11
[13:35:06.859]  $ ...future.FUN            :function (x, ...)  
[13:35:06.859]  $ x_FUN                    :function (x)  
[13:35:06.859]  $ times                    : int 0
[13:35:06.859]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.859]  $ stop_if_not              :function (...)  
[13:35:06.859]  $ dim                      : NULL
[13:35:06.859]  $ valid_types              : chr [1:2] "logical" "integer"
[13:35:06.859]  $ future.call.arguments    : list()
[13:35:06.859]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.859]  $ ...future.elements_ii    :List of 5
[13:35:06.859]   ..$ : int 6
[13:35:06.859]   ..$ : int 7
[13:35:06.859]   ..$ : int 8
[13:35:06.859]   ..$ : int 9
[13:35:06.859]   ..$ : int 10
[13:35:06.859]  $ ...future.seeds_ii       : NULL
[13:35:06.859]  $ ...future.globals.maxSize: NULL
[13:35:06.859]  - attr(*, "where")=List of 11
[13:35:06.859]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.859]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.859]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.859]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.859]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.859]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.859]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.859]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.859]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.859]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.859]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.859]  - attr(*, "resolved")= logi FALSE
[13:35:06.859]  - attr(*, "total_size")= num 95400
[13:35:06.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.859]  - attr(*, "already-done")= logi TRUE
[13:35:06.871] - copied ‘...future.FUN’ to environment
[13:35:06.872] - reassign environment for ‘x_FUN’
[13:35:06.872] - copied ‘x_FUN’ to environment
[13:35:06.872] - copied ‘times’ to environment
[13:35:06.872] - copied ‘stopf’ to environment
[13:35:06.872] - copied ‘stop_if_not’ to environment
[13:35:06.872] - copied ‘dim’ to environment
[13:35:06.872] - copied ‘valid_types’ to environment
[13:35:06.872] - copied ‘future.call.arguments’ to environment
[13:35:06.872] - copied ‘...future.elements_ii’ to environment
[13:35:06.873] - copied ‘...future.seeds_ii’ to environment
[13:35:06.873] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.873] assign_globals() ... done
[13:35:06.873] requestCore(): workers = 2
[13:35:06.875] MulticoreFuture started
[13:35:06.876] - Launch lazy future ... done
[13:35:06.876] run() for ‘MulticoreFuture’ ... done
[13:35:06.877] Created future:
[13:35:06.877] plan(): Setting new future strategy stack:
[13:35:06.878] List of future strategies:
[13:35:06.878] 1. sequential:
[13:35:06.878]    - args: function (..., envir = parent.frame())
[13:35:06.878]    - tweaked: FALSE
[13:35:06.878]    - call: NULL
[13:35:06.879] plan(): nbrOfWorkers() = 1
[13:35:06.882] plan(): Setting new future strategy stack:
[13:35:06.882] List of future strategies:
[13:35:06.882] 1. multicore:
[13:35:06.882]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:06.882]    - tweaked: FALSE
[13:35:06.882]    - call: plan(strategy)
[13:35:06.887] plan(): nbrOfWorkers() = 2
[13:35:06.877] MulticoreFuture:
[13:35:06.877] Label: ‘future_vapply-2’
[13:35:06.877] Expression:
[13:35:06.877] {
[13:35:06.877]     do.call(function(...) {
[13:35:06.877]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.877]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.877]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.877]             on.exit(options(oopts), add = TRUE)
[13:35:06.877]         }
[13:35:06.877]         {
[13:35:06.877]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.877]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.877]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.877]             })
[13:35:06.877]         }
[13:35:06.877]     }, args = future.call.arguments)
[13:35:06.877] }
[13:35:06.877] Lazy evaluation: FALSE
[13:35:06.877] Asynchronous evaluation: TRUE
[13:35:06.877] Local evaluation: TRUE
[13:35:06.877] Environment: R_GlobalEnv
[13:35:06.877] Capture standard output: TRUE
[13:35:06.877] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.877] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.877] Packages: 1 packages (‘future.apply’)
[13:35:06.877] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.877] Resolved: TRUE
[13:35:06.877] Value: <not collected>
[13:35:06.877] Conditions captured: <none>
[13:35:06.877] Early signaling: FALSE
[13:35:06.877] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.877] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.888] Chunk #2 of 2 ... DONE
[13:35:06.889] Launching 2 futures (chunks) ... DONE
[13:35:06.889] Resolving 2 futures (chunks) ...
[13:35:06.889] resolve() on list ...
[13:35:06.889]  recursive: 0
[13:35:06.889]  length: 2
[13:35:06.889] 
[13:35:06.890] Future #1
[13:35:06.890] result() for MulticoreFuture ...
[13:35:06.891] result() for MulticoreFuture ...
[13:35:06.891] result() for MulticoreFuture ... done
[13:35:06.891] result() for MulticoreFuture ... done
[13:35:06.891] result() for MulticoreFuture ...
[13:35:06.891] result() for MulticoreFuture ... done
[13:35:06.892] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:06.892] - nx: 2
[13:35:06.892] - relay: TRUE
[13:35:06.892] - stdout: TRUE
[13:35:06.893] - signal: TRUE
[13:35:06.893] - resignal: FALSE
[13:35:06.893] - force: TRUE
[13:35:06.893] - relayed: [n=2] FALSE, FALSE
[13:35:06.893] - queued futures: [n=2] FALSE, FALSE
[13:35:06.893]  - until=1
[13:35:06.894]  - relaying element #1
[13:35:06.894] result() for MulticoreFuture ...
[13:35:06.894] result() for MulticoreFuture ... done
[13:35:06.894] result() for MulticoreFuture ...
[13:35:06.894] result() for MulticoreFuture ... done
[13:35:06.895] result() for MulticoreFuture ...
[13:35:06.895] result() for MulticoreFuture ... done
[13:35:06.895] result() for MulticoreFuture ...
[13:35:06.895] result() for MulticoreFuture ... done
[13:35:06.895] - relayed: [n=2] TRUE, FALSE
[13:35:06.895] - queued futures: [n=2] TRUE, FALSE
[13:35:06.896] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:06.896]  length: 1 (resolved future 1)
[13:35:06.896] Future #2
[13:35:06.896] result() for MulticoreFuture ...
[13:35:06.897] result() for MulticoreFuture ...
[13:35:06.897] result() for MulticoreFuture ... done
[13:35:06.897] result() for MulticoreFuture ... done
[13:35:06.897] result() for MulticoreFuture ...
[13:35:06.897] result() for MulticoreFuture ... done
[13:35:06.898] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:06.898] - nx: 2
[13:35:06.898] - relay: TRUE
[13:35:06.898] - stdout: TRUE
[13:35:06.898] - signal: TRUE
[13:35:06.898] - resignal: FALSE
[13:35:06.898] - force: TRUE
[13:35:06.898] - relayed: [n=2] TRUE, FALSE
[13:35:06.898] - queued futures: [n=2] TRUE, FALSE
[13:35:06.899]  - until=2
[13:35:06.899]  - relaying element #2
[13:35:06.899] result() for MulticoreFuture ...
[13:35:06.899] result() for MulticoreFuture ... done
[13:35:06.899] result() for MulticoreFuture ...
[13:35:06.899] result() for MulticoreFuture ... done
[13:35:06.899] result() for MulticoreFuture ...
[13:35:06.899] result() for MulticoreFuture ... done
[13:35:06.900] result() for MulticoreFuture ...
[13:35:06.900] result() for MulticoreFuture ... done
[13:35:06.900] - relayed: [n=2] TRUE, TRUE
[13:35:06.900] - queued futures: [n=2] TRUE, TRUE
[13:35:06.900] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:06.900]  length: 0 (resolved future 2)
[13:35:06.900] Relaying remaining futures
[13:35:06.900] signalConditionsASAP(NULL, pos=0) ...
[13:35:06.900] - nx: 2
[13:35:06.900] - relay: TRUE
[13:35:06.901] - stdout: TRUE
[13:35:06.901] - signal: TRUE
[13:35:06.901] - resignal: FALSE
[13:35:06.901] - force: TRUE
[13:35:06.901] - relayed: [n=2] TRUE, TRUE
[13:35:06.901] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:06.901] - relayed: [n=2] TRUE, TRUE
[13:35:06.901] - queued futures: [n=2] TRUE, TRUE
[13:35:06.901] signalConditionsASAP(NULL, pos=0) ... done
[13:35:06.902] resolve() on list ... DONE
[13:35:06.902] result() for MulticoreFuture ...
[13:35:06.902] result() for MulticoreFuture ... done
[13:35:06.902] result() for MulticoreFuture ...
[13:35:06.902] result() for MulticoreFuture ... done
[13:35:06.902] result() for MulticoreFuture ...
[13:35:06.902] result() for MulticoreFuture ... done
[13:35:06.902] result() for MulticoreFuture ...
[13:35:06.902] result() for MulticoreFuture ... done
[13:35:06.903]  - Number of value chunks collected: 2
[13:35:06.903] Resolving 2 futures (chunks) ... DONE
[13:35:06.903] Reducing values from 2 chunks ...
[13:35:06.903]  - Number of values collected after concatenation: 10
[13:35:06.903]  - Number of values expected: 10
[13:35:06.903] Reducing values from 2 chunks ... DONE
[13:35:06.903] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[13:35:06.904] future_lapply() ...
[13:35:06.910] Number of chunks: 2
[13:35:06.910] getGlobalsAndPackagesXApply() ...
[13:35:06.910]  - future.globals: TRUE
[13:35:06.911] getGlobalsAndPackages() ...
[13:35:06.911] Searching for globals...
[13:35:06.917] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:06.917] Searching for globals ... DONE
[13:35:06.917] Resolving globals: FALSE
[13:35:06.918] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[13:35:06.919] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:06.919] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.919] - packages: [1] ‘future.apply’
[13:35:06.919] getGlobalsAndPackages() ... DONE
[13:35:06.919]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:06.919]  - needed namespaces: [n=1] ‘future.apply’
[13:35:06.919] Finding globals ... DONE
[13:35:06.919]  - use_args: TRUE
[13:35:06.919]  - Getting '...' globals ...
[13:35:06.920] resolve() on list ...
[13:35:06.920]  recursive: 0
[13:35:06.920]  length: 1
[13:35:06.920]  elements: ‘...’
[13:35:06.920]  length: 0 (resolved future 1)
[13:35:06.920] resolve() on list ... DONE
[13:35:06.920]    - '...' content: [n=0] 
[13:35:06.920] List of 1
[13:35:06.920]  $ ...: list()
[13:35:06.920]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.920]  - attr(*, "where")=List of 1
[13:35:06.920]   ..$ ...:<environment: 0x5574d081a770> 
[13:35:06.920]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.920]  - attr(*, "resolved")= logi TRUE
[13:35:06.920]  - attr(*, "total_size")= num NA
[13:35:06.923]  - Getting '...' globals ... DONE
[13:35:06.923] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:06.923] List of 8
[13:35:06.923]  $ ...future.FUN:function (x, ...)  
[13:35:06.923]  $ x_FUN        :function (x)  
[13:35:06.923]  $ times        : int 1
[13:35:06.923]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.923]  $ stop_if_not  :function (...)  
[13:35:06.923]  $ dim          : NULL
[13:35:06.923]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:06.923]  $ ...          : list()
[13:35:06.923]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.923]  - attr(*, "where")=List of 8
[13:35:06.923]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:06.923]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:06.923]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:06.923]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:06.923]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:06.923]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:06.923]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:06.923]   ..$ ...          :<environment: 0x5574d081a770> 
[13:35:06.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.923]  - attr(*, "resolved")= logi FALSE
[13:35:06.923]  - attr(*, "total_size")= num 94336
[13:35:06.929] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:06.929] getGlobalsAndPackagesXApply() ... DONE
[13:35:06.929] Number of futures (= number of chunks): 2
[13:35:06.929] Launching 2 futures (chunks) ...
[13:35:06.929] Chunk #1 of 2 ...
[13:35:06.929]  - Finding globals in 'X' for chunk #1 ...
[13:35:06.929] getGlobalsAndPackages() ...
[13:35:06.929] Searching for globals...
[13:35:06.930] 
[13:35:06.930] Searching for globals ... DONE
[13:35:06.930] - globals: [0] <none>
[13:35:06.930] getGlobalsAndPackages() ... DONE
[13:35:06.930]    + additional globals found: [n=0] 
[13:35:06.930]    + additional namespaces needed: [n=0] 
[13:35:06.930]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:06.930]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:06.931]  - seeds: <none>
[13:35:06.931]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.931] getGlobalsAndPackages() ...
[13:35:06.931] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.931] Resolving globals: FALSE
[13:35:06.931] Tweak future expression to call with '...' arguments ...
[13:35:06.931] {
[13:35:06.931]     do.call(function(...) {
[13:35:06.931]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.931]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.931]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.931]             on.exit(options(oopts), add = TRUE)
[13:35:06.931]         }
[13:35:06.931]         {
[13:35:06.931]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.931]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.931]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.931]             })
[13:35:06.931]         }
[13:35:06.931]     }, args = future.call.arguments)
[13:35:06.931] }
[13:35:06.931] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.932] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.932] - packages: [1] ‘future.apply’
[13:35:06.932] getGlobalsAndPackages() ... DONE
[13:35:06.932] run() for ‘Future’ ...
[13:35:06.933] - state: ‘created’
[13:35:06.933] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:06.938] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.938] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:06.938]   - Field: ‘label’
[13:35:06.939]   - Field: ‘local’
[13:35:06.939]   - Field: ‘owner’
[13:35:06.939]   - Field: ‘envir’
[13:35:06.939]   - Field: ‘workers’
[13:35:06.939]   - Field: ‘packages’
[13:35:06.939]   - Field: ‘gc’
[13:35:06.939]   - Field: ‘job’
[13:35:06.939]   - Field: ‘conditions’
[13:35:06.939]   - Field: ‘expr’
[13:35:06.939]   - Field: ‘uuid’
[13:35:06.940]   - Field: ‘seed’
[13:35:06.940]   - Field: ‘version’
[13:35:06.940]   - Field: ‘result’
[13:35:06.940]   - Field: ‘asynchronous’
[13:35:06.940]   - Field: ‘calls’
[13:35:06.940]   - Field: ‘globals’
[13:35:06.940]   - Field: ‘stdout’
[13:35:06.940]   - Field: ‘earlySignal’
[13:35:06.940]   - Field: ‘lazy’
[13:35:06.940]   - Field: ‘state’
[13:35:06.941] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:06.941] - Launch lazy future ...
[13:35:06.941] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.941] Packages needed by future strategies (n = 0): <none>
[13:35:06.942] {
[13:35:06.942]     {
[13:35:06.942]         {
[13:35:06.942]             ...future.startTime <- base::Sys.time()
[13:35:06.942]             {
[13:35:06.942]                 {
[13:35:06.942]                   {
[13:35:06.942]                     {
[13:35:06.942]                       {
[13:35:06.942]                         base::local({
[13:35:06.942]                           has_future <- base::requireNamespace("future", 
[13:35:06.942]                             quietly = TRUE)
[13:35:06.942]                           if (has_future) {
[13:35:06.942]                             ns <- base::getNamespace("future")
[13:35:06.942]                             version <- ns[[".package"]][["version"]]
[13:35:06.942]                             if (is.null(version)) 
[13:35:06.942]                               version <- utils::packageVersion("future")
[13:35:06.942]                           }
[13:35:06.942]                           else {
[13:35:06.942]                             version <- NULL
[13:35:06.942]                           }
[13:35:06.942]                           if (!has_future || version < "1.8.0") {
[13:35:06.942]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.942]                               "", base::R.version$version.string), 
[13:35:06.942]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:06.942]                                 base::R.version$platform, 8 * 
[13:35:06.942]                                   base::.Machine$sizeof.pointer), 
[13:35:06.942]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.942]                                 "release", "version")], collapse = " "), 
[13:35:06.942]                               hostname = base::Sys.info()[["nodename"]])
[13:35:06.942]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.942]                               info)
[13:35:06.942]                             info <- base::paste(info, collapse = "; ")
[13:35:06.942]                             if (!has_future) {
[13:35:06.942]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.942]                                 info)
[13:35:06.942]                             }
[13:35:06.942]                             else {
[13:35:06.942]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.942]                                 info, version)
[13:35:06.942]                             }
[13:35:06.942]                             base::stop(msg)
[13:35:06.942]                           }
[13:35:06.942]                         })
[13:35:06.942]                       }
[13:35:06.942]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:06.942]                       base::options(mc.cores = 1L)
[13:35:06.942]                     }
[13:35:06.942]                     base::local({
[13:35:06.942]                       for (pkg in "future.apply") {
[13:35:06.942]                         base::loadNamespace(pkg)
[13:35:06.942]                         base::library(pkg, character.only = TRUE)
[13:35:06.942]                       }
[13:35:06.942]                     })
[13:35:06.942]                   }
[13:35:06.942]                   ...future.strategy.old <- future::plan("list")
[13:35:06.942]                   options(future.plan = NULL)
[13:35:06.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.942]                 }
[13:35:06.942]                 ...future.workdir <- getwd()
[13:35:06.942]             }
[13:35:06.942]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.942]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.942]         }
[13:35:06.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.942]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:06.942]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.942]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.942]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.942]             base::names(...future.oldOptions))
[13:35:06.942]     }
[13:35:06.942]     if (FALSE) {
[13:35:06.942]     }
[13:35:06.942]     else {
[13:35:06.942]         if (TRUE) {
[13:35:06.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.942]                 open = "w")
[13:35:06.942]         }
[13:35:06.942]         else {
[13:35:06.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.942]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.942]         }
[13:35:06.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.942]             base::sink(type = "output", split = FALSE)
[13:35:06.942]             base::close(...future.stdout)
[13:35:06.942]         }, add = TRUE)
[13:35:06.942]     }
[13:35:06.942]     ...future.frame <- base::sys.nframe()
[13:35:06.942]     ...future.conditions <- base::list()
[13:35:06.942]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.942]     if (FALSE) {
[13:35:06.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.942]     }
[13:35:06.942]     ...future.result <- base::tryCatch({
[13:35:06.942]         base::withCallingHandlers({
[13:35:06.942]             ...future.value <- base::withVisible(base::local({
[13:35:06.942]                 withCallingHandlers({
[13:35:06.942]                   {
[13:35:06.942]                     do.call(function(...) {
[13:35:06.942]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.942]                       if (!identical(...future.globals.maxSize.org, 
[13:35:06.942]                         ...future.globals.maxSize)) {
[13:35:06.942]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.942]                         on.exit(options(oopts), add = TRUE)
[13:35:06.942]                       }
[13:35:06.942]                       {
[13:35:06.942]                         lapply(seq_along(...future.elements_ii), 
[13:35:06.942]                           FUN = function(jj) {
[13:35:06.942]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.942]                             ...future.FUN(...future.X_jj, ...)
[13:35:06.942]                           })
[13:35:06.942]                       }
[13:35:06.942]                     }, args = future.call.arguments)
[13:35:06.942]                   }
[13:35:06.942]                 }, immediateCondition = function(cond) {
[13:35:06.942]                   save_rds <- function (object, pathname, ...) 
[13:35:06.942]                   {
[13:35:06.942]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:06.942]                     if (file_test("-f", pathname_tmp)) {
[13:35:06.942]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.942]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:06.942]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.942]                         fi_tmp[["mtime"]])
[13:35:06.942]                     }
[13:35:06.942]                     tryCatch({
[13:35:06.942]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:06.942]                     }, error = function(ex) {
[13:35:06.942]                       msg <- conditionMessage(ex)
[13:35:06.942]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.942]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:06.942]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.942]                         fi_tmp[["mtime"]], msg)
[13:35:06.942]                       ex$message <- msg
[13:35:06.942]                       stop(ex)
[13:35:06.942]                     })
[13:35:06.942]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:06.942]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:06.942]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:06.942]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.942]                       fi <- file.info(pathname)
[13:35:06.942]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:06.942]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.942]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:06.942]                         fi[["size"]], fi[["mtime"]])
[13:35:06.942]                       stop(msg)
[13:35:06.942]                     }
[13:35:06.942]                     invisible(pathname)
[13:35:06.942]                   }
[13:35:06.942]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:06.942]                     rootPath = tempdir()) 
[13:35:06.942]                   {
[13:35:06.942]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:06.942]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:06.942]                       tmpdir = path, fileext = ".rds")
[13:35:06.942]                     save_rds(obj, file)
[13:35:06.942]                   }
[13:35:06.942]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:06.942]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.942]                   {
[13:35:06.942]                     inherits <- base::inherits
[13:35:06.942]                     invokeRestart <- base::invokeRestart
[13:35:06.942]                     is.null <- base::is.null
[13:35:06.942]                     muffled <- FALSE
[13:35:06.942]                     if (inherits(cond, "message")) {
[13:35:06.942]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:06.942]                       if (muffled) 
[13:35:06.942]                         invokeRestart("muffleMessage")
[13:35:06.942]                     }
[13:35:06.942]                     else if (inherits(cond, "warning")) {
[13:35:06.942]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:06.942]                       if (muffled) 
[13:35:06.942]                         invokeRestart("muffleWarning")
[13:35:06.942]                     }
[13:35:06.942]                     else if (inherits(cond, "condition")) {
[13:35:06.942]                       if (!is.null(pattern)) {
[13:35:06.942]                         computeRestarts <- base::computeRestarts
[13:35:06.942]                         grepl <- base::grepl
[13:35:06.942]                         restarts <- computeRestarts(cond)
[13:35:06.942]                         for (restart in restarts) {
[13:35:06.942]                           name <- restart$name
[13:35:06.942]                           if (is.null(name)) 
[13:35:06.942]                             next
[13:35:06.942]                           if (!grepl(pattern, name)) 
[13:35:06.942]                             next
[13:35:06.942]                           invokeRestart(restart)
[13:35:06.942]                           muffled <- TRUE
[13:35:06.942]                           break
[13:35:06.942]                         }
[13:35:06.942]                       }
[13:35:06.942]                     }
[13:35:06.942]                     invisible(muffled)
[13:35:06.942]                   }
[13:35:06.942]                   muffleCondition(cond)
[13:35:06.942]                 })
[13:35:06.942]             }))
[13:35:06.942]             future::FutureResult(value = ...future.value$value, 
[13:35:06.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.942]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.942]                     ...future.globalenv.names))
[13:35:06.942]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.942]         }, condition = base::local({
[13:35:06.942]             c <- base::c
[13:35:06.942]             inherits <- base::inherits
[13:35:06.942]             invokeRestart <- base::invokeRestart
[13:35:06.942]             length <- base::length
[13:35:06.942]             list <- base::list
[13:35:06.942]             seq.int <- base::seq.int
[13:35:06.942]             signalCondition <- base::signalCondition
[13:35:06.942]             sys.calls <- base::sys.calls
[13:35:06.942]             `[[` <- base::`[[`
[13:35:06.942]             `+` <- base::`+`
[13:35:06.942]             `<<-` <- base::`<<-`
[13:35:06.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.942]                   3L)]
[13:35:06.942]             }
[13:35:06.942]             function(cond) {
[13:35:06.942]                 is_error <- inherits(cond, "error")
[13:35:06.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.942]                   NULL)
[13:35:06.942]                 if (is_error) {
[13:35:06.942]                   sessionInformation <- function() {
[13:35:06.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.942]                       search = base::search(), system = base::Sys.info())
[13:35:06.942]                   }
[13:35:06.942]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.942]                     cond$call), session = sessionInformation(), 
[13:35:06.942]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.942]                   signalCondition(cond)
[13:35:06.942]                 }
[13:35:06.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.942]                 "immediateCondition"))) {
[13:35:06.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.942]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.942]                   if (TRUE && !signal) {
[13:35:06.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.942]                     {
[13:35:06.942]                       inherits <- base::inherits
[13:35:06.942]                       invokeRestart <- base::invokeRestart
[13:35:06.942]                       is.null <- base::is.null
[13:35:06.942]                       muffled <- FALSE
[13:35:06.942]                       if (inherits(cond, "message")) {
[13:35:06.942]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.942]                         if (muffled) 
[13:35:06.942]                           invokeRestart("muffleMessage")
[13:35:06.942]                       }
[13:35:06.942]                       else if (inherits(cond, "warning")) {
[13:35:06.942]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.942]                         if (muffled) 
[13:35:06.942]                           invokeRestart("muffleWarning")
[13:35:06.942]                       }
[13:35:06.942]                       else if (inherits(cond, "condition")) {
[13:35:06.942]                         if (!is.null(pattern)) {
[13:35:06.942]                           computeRestarts <- base::computeRestarts
[13:35:06.942]                           grepl <- base::grepl
[13:35:06.942]                           restarts <- computeRestarts(cond)
[13:35:06.942]                           for (restart in restarts) {
[13:35:06.942]                             name <- restart$name
[13:35:06.942]                             if (is.null(name)) 
[13:35:06.942]                               next
[13:35:06.942]                             if (!grepl(pattern, name)) 
[13:35:06.942]                               next
[13:35:06.942]                             invokeRestart(restart)
[13:35:06.942]                             muffled <- TRUE
[13:35:06.942]                             break
[13:35:06.942]                           }
[13:35:06.942]                         }
[13:35:06.942]                       }
[13:35:06.942]                       invisible(muffled)
[13:35:06.942]                     }
[13:35:06.942]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.942]                   }
[13:35:06.942]                 }
[13:35:06.942]                 else {
[13:35:06.942]                   if (TRUE) {
[13:35:06.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.942]                     {
[13:35:06.942]                       inherits <- base::inherits
[13:35:06.942]                       invokeRestart <- base::invokeRestart
[13:35:06.942]                       is.null <- base::is.null
[13:35:06.942]                       muffled <- FALSE
[13:35:06.942]                       if (inherits(cond, "message")) {
[13:35:06.942]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.942]                         if (muffled) 
[13:35:06.942]                           invokeRestart("muffleMessage")
[13:35:06.942]                       }
[13:35:06.942]                       else if (inherits(cond, "warning")) {
[13:35:06.942]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.942]                         if (muffled) 
[13:35:06.942]                           invokeRestart("muffleWarning")
[13:35:06.942]                       }
[13:35:06.942]                       else if (inherits(cond, "condition")) {
[13:35:06.942]                         if (!is.null(pattern)) {
[13:35:06.942]                           computeRestarts <- base::computeRestarts
[13:35:06.942]                           grepl <- base::grepl
[13:35:06.942]                           restarts <- computeRestarts(cond)
[13:35:06.942]                           for (restart in restarts) {
[13:35:06.942]                             name <- restart$name
[13:35:06.942]                             if (is.null(name)) 
[13:35:06.942]                               next
[13:35:06.942]                             if (!grepl(pattern, name)) 
[13:35:06.942]                               next
[13:35:06.942]                             invokeRestart(restart)
[13:35:06.942]                             muffled <- TRUE
[13:35:06.942]                             break
[13:35:06.942]                           }
[13:35:06.942]                         }
[13:35:06.942]                       }
[13:35:06.942]                       invisible(muffled)
[13:35:06.942]                     }
[13:35:06.942]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.942]                   }
[13:35:06.942]                 }
[13:35:06.942]             }
[13:35:06.942]         }))
[13:35:06.942]     }, error = function(ex) {
[13:35:06.942]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.942]                 ...future.rng), started = ...future.startTime, 
[13:35:06.942]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.942]             version = "1.8"), class = "FutureResult")
[13:35:06.942]     }, finally = {
[13:35:06.942]         if (!identical(...future.workdir, getwd())) 
[13:35:06.942]             setwd(...future.workdir)
[13:35:06.942]         {
[13:35:06.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.942]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.942]             }
[13:35:06.942]             base::options(...future.oldOptions)
[13:35:06.942]             if (.Platform$OS.type == "windows") {
[13:35:06.942]                 old_names <- names(...future.oldEnvVars)
[13:35:06.942]                 envs <- base::Sys.getenv()
[13:35:06.942]                 names <- names(envs)
[13:35:06.942]                 common <- intersect(names, old_names)
[13:35:06.942]                 added <- setdiff(names, old_names)
[13:35:06.942]                 removed <- setdiff(old_names, names)
[13:35:06.942]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.942]                   envs[common]]
[13:35:06.942]                 NAMES <- toupper(changed)
[13:35:06.942]                 args <- list()
[13:35:06.942]                 for (kk in seq_along(NAMES)) {
[13:35:06.942]                   name <- changed[[kk]]
[13:35:06.942]                   NAME <- NAMES[[kk]]
[13:35:06.942]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.942]                     next
[13:35:06.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.942]                 }
[13:35:06.942]                 NAMES <- toupper(added)
[13:35:06.942]                 for (kk in seq_along(NAMES)) {
[13:35:06.942]                   name <- added[[kk]]
[13:35:06.942]                   NAME <- NAMES[[kk]]
[13:35:06.942]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.942]                     next
[13:35:06.942]                   args[[name]] <- ""
[13:35:06.942]                 }
[13:35:06.942]                 NAMES <- toupper(removed)
[13:35:06.942]                 for (kk in seq_along(NAMES)) {
[13:35:06.942]                   name <- removed[[kk]]
[13:35:06.942]                   NAME <- NAMES[[kk]]
[13:35:06.942]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.942]                     next
[13:35:06.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.942]                 }
[13:35:06.942]                 if (length(args) > 0) 
[13:35:06.942]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.942]             }
[13:35:06.942]             else {
[13:35:06.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.942]             }
[13:35:06.942]             {
[13:35:06.942]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.942]                   0L) {
[13:35:06.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.942]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.942]                   base::options(opts)
[13:35:06.942]                 }
[13:35:06.942]                 {
[13:35:06.942]                   {
[13:35:06.942]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:06.942]                     NULL
[13:35:06.942]                   }
[13:35:06.942]                   options(future.plan = NULL)
[13:35:06.942]                   if (is.na(NA_character_)) 
[13:35:06.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.942]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.942]                     .init = FALSE)
[13:35:06.942]                 }
[13:35:06.942]             }
[13:35:06.942]         }
[13:35:06.942]     })
[13:35:06.942]     if (TRUE) {
[13:35:06.942]         base::sink(type = "output", split = FALSE)
[13:35:06.942]         if (TRUE) {
[13:35:06.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.942]         }
[13:35:06.942]         else {
[13:35:06.942]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.942]         }
[13:35:06.942]         base::close(...future.stdout)
[13:35:06.942]         ...future.stdout <- NULL
[13:35:06.942]     }
[13:35:06.942]     ...future.result$conditions <- ...future.conditions
[13:35:06.942]     ...future.result$finished <- base::Sys.time()
[13:35:06.942]     ...future.result
[13:35:06.942] }
[13:35:06.944] assign_globals() ...
[13:35:06.944] List of 11
[13:35:06.944]  $ ...future.FUN            :function (x, ...)  
[13:35:06.944]  $ x_FUN                    :function (x)  
[13:35:06.944]  $ times                    : int 1
[13:35:06.944]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.944]  $ stop_if_not              :function (...)  
[13:35:06.944]  $ dim                      : NULL
[13:35:06.944]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:06.944]  $ future.call.arguments    : list()
[13:35:06.944]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.944]  $ ...future.elements_ii    :List of 5
[13:35:06.944]   ..$ : int 1
[13:35:06.944]   ..$ : int 2
[13:35:06.944]   ..$ : int 3
[13:35:06.944]   ..$ : int 4
[13:35:06.944]   ..$ : int 5
[13:35:06.944]  $ ...future.seeds_ii       : NULL
[13:35:06.944]  $ ...future.globals.maxSize: NULL
[13:35:06.944]  - attr(*, "where")=List of 11
[13:35:06.944]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.944]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.944]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.944]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.944]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.944]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.944]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.944]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.944]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.944]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.944]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.944]  - attr(*, "resolved")= logi FALSE
[13:35:06.944]  - attr(*, "total_size")= num 94336
[13:35:06.944]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.944]  - attr(*, "already-done")= logi TRUE
[13:35:06.952] - copied ‘...future.FUN’ to environment
[13:35:06.952] - copied ‘x_FUN’ to environment
[13:35:06.953] - copied ‘times’ to environment
[13:35:06.953] - copied ‘stopf’ to environment
[13:35:06.953] - copied ‘stop_if_not’ to environment
[13:35:06.953] - copied ‘dim’ to environment
[13:35:06.953] - copied ‘valid_types’ to environment
[13:35:06.953] - copied ‘future.call.arguments’ to environment
[13:35:06.953] - copied ‘...future.elements_ii’ to environment
[13:35:06.953] - copied ‘...future.seeds_ii’ to environment
[13:35:06.953] - copied ‘...future.globals.maxSize’ to environment
[13:35:06.953] assign_globals() ... done
[13:35:06.953] requestCore(): workers = 2
[13:35:06.955] MulticoreFuture started
[13:35:06.956] - Launch lazy future ... done
[13:35:06.956] run() for ‘MulticoreFuture’ ... done
[13:35:06.956] Created future:
[13:35:06.957] plan(): Setting new future strategy stack:
[13:35:06.957] List of future strategies:
[13:35:06.957] 1. sequential:
[13:35:06.957]    - args: function (..., envir = parent.frame())
[13:35:06.957]    - tweaked: FALSE
[13:35:06.957]    - call: NULL
[13:35:06.958] plan(): nbrOfWorkers() = 1
[13:35:06.960] plan(): Setting new future strategy stack:
[13:35:06.960] List of future strategies:
[13:35:06.960] 1. multicore:
[13:35:06.960]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:06.960]    - tweaked: FALSE
[13:35:06.960]    - call: plan(strategy)
[13:35:06.956] MulticoreFuture:
[13:35:06.956] Label: ‘future_vapply-1’
[13:35:06.956] Expression:
[13:35:06.956] {
[13:35:06.956]     do.call(function(...) {
[13:35:06.956]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.956]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.956]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.956]             on.exit(options(oopts), add = TRUE)
[13:35:06.956]         }
[13:35:06.956]         {
[13:35:06.956]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.956]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.956]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.956]             })
[13:35:06.956]         }
[13:35:06.956]     }, args = future.call.arguments)
[13:35:06.956] }
[13:35:06.956] Lazy evaluation: FALSE
[13:35:06.956] Asynchronous evaluation: TRUE
[13:35:06.956] Local evaluation: TRUE
[13:35:06.956] Environment: R_GlobalEnv
[13:35:06.956] Capture standard output: TRUE
[13:35:06.956] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:06.956] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:06.956] Packages: 1 packages (‘future.apply’)
[13:35:06.956] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:06.956] Resolved: FALSE
[13:35:06.956] Value: <not collected>
[13:35:06.956] Conditions captured: <none>
[13:35:06.956] Early signaling: FALSE
[13:35:06.956] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:06.956] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.969] Chunk #1 of 2 ... DONE
[13:35:06.969] plan(): nbrOfWorkers() = 2
[13:35:06.970] Chunk #2 of 2 ...
[13:35:06.970]  - Finding globals in 'X' for chunk #2 ...
[13:35:06.970] getGlobalsAndPackages() ...
[13:35:06.970] Searching for globals...
[13:35:06.971] 
[13:35:06.971] Searching for globals ... DONE
[13:35:06.971] - globals: [0] <none>
[13:35:06.971] getGlobalsAndPackages() ... DONE
[13:35:06.971]    + additional globals found: [n=0] 
[13:35:06.974]    + additional namespaces needed: [n=0] 
[13:35:06.974]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:06.974]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:06.974]  - seeds: <none>
[13:35:06.975]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.975] getGlobalsAndPackages() ...
[13:35:06.975] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.976] Resolving globals: FALSE
[13:35:06.976] Tweak future expression to call with '...' arguments ...
[13:35:06.977] {
[13:35:06.977]     do.call(function(...) {
[13:35:06.977]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.977]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:06.977]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.977]             on.exit(options(oopts), add = TRUE)
[13:35:06.977]         }
[13:35:06.977]         {
[13:35:06.977]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:06.977]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.977]                 ...future.FUN(...future.X_jj, ...)
[13:35:06.977]             })
[13:35:06.977]         }
[13:35:06.977]     }, args = future.call.arguments)
[13:35:06.977] }
[13:35:06.977] Tweak future expression to call with '...' arguments ... DONE
[13:35:06.979] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:06.979] - packages: [1] ‘future.apply’
[13:35:06.979] getGlobalsAndPackages() ... DONE
[13:35:06.980] run() for ‘Future’ ...
[13:35:06.980] - state: ‘created’
[13:35:06.981] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:06.986] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:06.986] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:06.986]   - Field: ‘label’
[13:35:06.986]   - Field: ‘local’
[13:35:06.987]   - Field: ‘owner’
[13:35:06.987]   - Field: ‘envir’
[13:35:06.987]   - Field: ‘workers’
[13:35:06.987]   - Field: ‘packages’
[13:35:06.987]   - Field: ‘gc’
[13:35:06.987]   - Field: ‘job’
[13:35:06.988]   - Field: ‘conditions’
[13:35:06.988]   - Field: ‘expr’
[13:35:06.988]   - Field: ‘uuid’
[13:35:06.988]   - Field: ‘seed’
[13:35:06.988]   - Field: ‘version’
[13:35:06.988]   - Field: ‘result’
[13:35:06.989]   - Field: ‘asynchronous’
[13:35:06.989]   - Field: ‘calls’
[13:35:06.989]   - Field: ‘globals’
[13:35:06.989]   - Field: ‘stdout’
[13:35:06.989]   - Field: ‘earlySignal’
[13:35:06.990]   - Field: ‘lazy’
[13:35:06.990]   - Field: ‘state’
[13:35:06.990] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:06.990] - Launch lazy future ...
[13:35:06.990] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:06.991] Packages needed by future strategies (n = 0): <none>
[13:35:06.991] {
[13:35:06.991]     {
[13:35:06.991]         {
[13:35:06.991]             ...future.startTime <- base::Sys.time()
[13:35:06.991]             {
[13:35:06.991]                 {
[13:35:06.991]                   {
[13:35:06.991]                     {
[13:35:06.991]                       {
[13:35:06.991]                         base::local({
[13:35:06.991]                           has_future <- base::requireNamespace("future", 
[13:35:06.991]                             quietly = TRUE)
[13:35:06.991]                           if (has_future) {
[13:35:06.991]                             ns <- base::getNamespace("future")
[13:35:06.991]                             version <- ns[[".package"]][["version"]]
[13:35:06.991]                             if (is.null(version)) 
[13:35:06.991]                               version <- utils::packageVersion("future")
[13:35:06.991]                           }
[13:35:06.991]                           else {
[13:35:06.991]                             version <- NULL
[13:35:06.991]                           }
[13:35:06.991]                           if (!has_future || version < "1.8.0") {
[13:35:06.991]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:06.991]                               "", base::R.version$version.string), 
[13:35:06.991]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:06.991]                                 base::R.version$platform, 8 * 
[13:35:06.991]                                   base::.Machine$sizeof.pointer), 
[13:35:06.991]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:06.991]                                 "release", "version")], collapse = " "), 
[13:35:06.991]                               hostname = base::Sys.info()[["nodename"]])
[13:35:06.991]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:06.991]                               info)
[13:35:06.991]                             info <- base::paste(info, collapse = "; ")
[13:35:06.991]                             if (!has_future) {
[13:35:06.991]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:06.991]                                 info)
[13:35:06.991]                             }
[13:35:06.991]                             else {
[13:35:06.991]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:06.991]                                 info, version)
[13:35:06.991]                             }
[13:35:06.991]                             base::stop(msg)
[13:35:06.991]                           }
[13:35:06.991]                         })
[13:35:06.991]                       }
[13:35:06.991]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:06.991]                       base::options(mc.cores = 1L)
[13:35:06.991]                     }
[13:35:06.991]                     base::local({
[13:35:06.991]                       for (pkg in "future.apply") {
[13:35:06.991]                         base::loadNamespace(pkg)
[13:35:06.991]                         base::library(pkg, character.only = TRUE)
[13:35:06.991]                       }
[13:35:06.991]                     })
[13:35:06.991]                   }
[13:35:06.991]                   ...future.strategy.old <- future::plan("list")
[13:35:06.991]                   options(future.plan = NULL)
[13:35:06.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:06.991]                 }
[13:35:06.991]                 ...future.workdir <- getwd()
[13:35:06.991]             }
[13:35:06.991]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:06.991]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:06.991]         }
[13:35:06.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:06.991]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:06.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:06.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:06.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:06.991]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:06.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:06.991]             base::names(...future.oldOptions))
[13:35:06.991]     }
[13:35:06.991]     if (FALSE) {
[13:35:06.991]     }
[13:35:06.991]     else {
[13:35:06.991]         if (TRUE) {
[13:35:06.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:06.991]                 open = "w")
[13:35:06.991]         }
[13:35:06.991]         else {
[13:35:06.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:06.991]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:06.991]         }
[13:35:06.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:06.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:06.991]             base::sink(type = "output", split = FALSE)
[13:35:06.991]             base::close(...future.stdout)
[13:35:06.991]         }, add = TRUE)
[13:35:06.991]     }
[13:35:06.991]     ...future.frame <- base::sys.nframe()
[13:35:06.991]     ...future.conditions <- base::list()
[13:35:06.991]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:06.991]     if (FALSE) {
[13:35:06.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:06.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:06.991]     }
[13:35:06.991]     ...future.result <- base::tryCatch({
[13:35:06.991]         base::withCallingHandlers({
[13:35:06.991]             ...future.value <- base::withVisible(base::local({
[13:35:06.991]                 withCallingHandlers({
[13:35:06.991]                   {
[13:35:06.991]                     do.call(function(...) {
[13:35:06.991]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:06.991]                       if (!identical(...future.globals.maxSize.org, 
[13:35:06.991]                         ...future.globals.maxSize)) {
[13:35:06.991]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:06.991]                         on.exit(options(oopts), add = TRUE)
[13:35:06.991]                       }
[13:35:06.991]                       {
[13:35:06.991]                         lapply(seq_along(...future.elements_ii), 
[13:35:06.991]                           FUN = function(jj) {
[13:35:06.991]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:06.991]                             ...future.FUN(...future.X_jj, ...)
[13:35:06.991]                           })
[13:35:06.991]                       }
[13:35:06.991]                     }, args = future.call.arguments)
[13:35:06.991]                   }
[13:35:06.991]                 }, immediateCondition = function(cond) {
[13:35:06.991]                   save_rds <- function (object, pathname, ...) 
[13:35:06.991]                   {
[13:35:06.991]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:06.991]                     if (file_test("-f", pathname_tmp)) {
[13:35:06.991]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.991]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:06.991]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.991]                         fi_tmp[["mtime"]])
[13:35:06.991]                     }
[13:35:06.991]                     tryCatch({
[13:35:06.991]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:06.991]                     }, error = function(ex) {
[13:35:06.991]                       msg <- conditionMessage(ex)
[13:35:06.991]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.991]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:06.991]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.991]                         fi_tmp[["mtime"]], msg)
[13:35:06.991]                       ex$message <- msg
[13:35:06.991]                       stop(ex)
[13:35:06.991]                     })
[13:35:06.991]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:06.991]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:06.991]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:06.991]                       fi_tmp <- file.info(pathname_tmp)
[13:35:06.991]                       fi <- file.info(pathname)
[13:35:06.991]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:06.991]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:06.991]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:06.991]                         fi[["size"]], fi[["mtime"]])
[13:35:06.991]                       stop(msg)
[13:35:06.991]                     }
[13:35:06.991]                     invisible(pathname)
[13:35:06.991]                   }
[13:35:06.991]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:06.991]                     rootPath = tempdir()) 
[13:35:06.991]                   {
[13:35:06.991]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:06.991]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:06.991]                       tmpdir = path, fileext = ".rds")
[13:35:06.991]                     save_rds(obj, file)
[13:35:06.991]                   }
[13:35:06.991]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:06.991]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.991]                   {
[13:35:06.991]                     inherits <- base::inherits
[13:35:06.991]                     invokeRestart <- base::invokeRestart
[13:35:06.991]                     is.null <- base::is.null
[13:35:06.991]                     muffled <- FALSE
[13:35:06.991]                     if (inherits(cond, "message")) {
[13:35:06.991]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:06.991]                       if (muffled) 
[13:35:06.991]                         invokeRestart("muffleMessage")
[13:35:06.991]                     }
[13:35:06.991]                     else if (inherits(cond, "warning")) {
[13:35:06.991]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:06.991]                       if (muffled) 
[13:35:06.991]                         invokeRestart("muffleWarning")
[13:35:06.991]                     }
[13:35:06.991]                     else if (inherits(cond, "condition")) {
[13:35:06.991]                       if (!is.null(pattern)) {
[13:35:06.991]                         computeRestarts <- base::computeRestarts
[13:35:06.991]                         grepl <- base::grepl
[13:35:06.991]                         restarts <- computeRestarts(cond)
[13:35:06.991]                         for (restart in restarts) {
[13:35:06.991]                           name <- restart$name
[13:35:06.991]                           if (is.null(name)) 
[13:35:06.991]                             next
[13:35:06.991]                           if (!grepl(pattern, name)) 
[13:35:06.991]                             next
[13:35:06.991]                           invokeRestart(restart)
[13:35:06.991]                           muffled <- TRUE
[13:35:06.991]                           break
[13:35:06.991]                         }
[13:35:06.991]                       }
[13:35:06.991]                     }
[13:35:06.991]                     invisible(muffled)
[13:35:06.991]                   }
[13:35:06.991]                   muffleCondition(cond)
[13:35:06.991]                 })
[13:35:06.991]             }))
[13:35:06.991]             future::FutureResult(value = ...future.value$value, 
[13:35:06.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.991]                   ...future.rng), globalenv = if (FALSE) 
[13:35:06.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:06.991]                     ...future.globalenv.names))
[13:35:06.991]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:06.991]         }, condition = base::local({
[13:35:06.991]             c <- base::c
[13:35:06.991]             inherits <- base::inherits
[13:35:06.991]             invokeRestart <- base::invokeRestart
[13:35:06.991]             length <- base::length
[13:35:06.991]             list <- base::list
[13:35:06.991]             seq.int <- base::seq.int
[13:35:06.991]             signalCondition <- base::signalCondition
[13:35:06.991]             sys.calls <- base::sys.calls
[13:35:06.991]             `[[` <- base::`[[`
[13:35:06.991]             `+` <- base::`+`
[13:35:06.991]             `<<-` <- base::`<<-`
[13:35:06.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:06.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:06.991]                   3L)]
[13:35:06.991]             }
[13:35:06.991]             function(cond) {
[13:35:06.991]                 is_error <- inherits(cond, "error")
[13:35:06.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:06.991]                   NULL)
[13:35:06.991]                 if (is_error) {
[13:35:06.991]                   sessionInformation <- function() {
[13:35:06.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:06.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:06.991]                       search = base::search(), system = base::Sys.info())
[13:35:06.991]                   }
[13:35:06.991]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:06.991]                     cond$call), session = sessionInformation(), 
[13:35:06.991]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:06.991]                   signalCondition(cond)
[13:35:06.991]                 }
[13:35:06.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:06.991]                 "immediateCondition"))) {
[13:35:06.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:06.991]                   ...future.conditions[[length(...future.conditions) + 
[13:35:06.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:06.991]                   if (TRUE && !signal) {
[13:35:06.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.991]                     {
[13:35:06.991]                       inherits <- base::inherits
[13:35:06.991]                       invokeRestart <- base::invokeRestart
[13:35:06.991]                       is.null <- base::is.null
[13:35:06.991]                       muffled <- FALSE
[13:35:06.991]                       if (inherits(cond, "message")) {
[13:35:06.991]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.991]                         if (muffled) 
[13:35:06.991]                           invokeRestart("muffleMessage")
[13:35:06.991]                       }
[13:35:06.991]                       else if (inherits(cond, "warning")) {
[13:35:06.991]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.991]                         if (muffled) 
[13:35:06.991]                           invokeRestart("muffleWarning")
[13:35:06.991]                       }
[13:35:06.991]                       else if (inherits(cond, "condition")) {
[13:35:06.991]                         if (!is.null(pattern)) {
[13:35:06.991]                           computeRestarts <- base::computeRestarts
[13:35:06.991]                           grepl <- base::grepl
[13:35:06.991]                           restarts <- computeRestarts(cond)
[13:35:06.991]                           for (restart in restarts) {
[13:35:06.991]                             name <- restart$name
[13:35:06.991]                             if (is.null(name)) 
[13:35:06.991]                               next
[13:35:06.991]                             if (!grepl(pattern, name)) 
[13:35:06.991]                               next
[13:35:06.991]                             invokeRestart(restart)
[13:35:06.991]                             muffled <- TRUE
[13:35:06.991]                             break
[13:35:06.991]                           }
[13:35:06.991]                         }
[13:35:06.991]                       }
[13:35:06.991]                       invisible(muffled)
[13:35:06.991]                     }
[13:35:06.991]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.991]                   }
[13:35:06.991]                 }
[13:35:06.991]                 else {
[13:35:06.991]                   if (TRUE) {
[13:35:06.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:06.991]                     {
[13:35:06.991]                       inherits <- base::inherits
[13:35:06.991]                       invokeRestart <- base::invokeRestart
[13:35:06.991]                       is.null <- base::is.null
[13:35:06.991]                       muffled <- FALSE
[13:35:06.991]                       if (inherits(cond, "message")) {
[13:35:06.991]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:06.991]                         if (muffled) 
[13:35:06.991]                           invokeRestart("muffleMessage")
[13:35:06.991]                       }
[13:35:06.991]                       else if (inherits(cond, "warning")) {
[13:35:06.991]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:06.991]                         if (muffled) 
[13:35:06.991]                           invokeRestart("muffleWarning")
[13:35:06.991]                       }
[13:35:06.991]                       else if (inherits(cond, "condition")) {
[13:35:06.991]                         if (!is.null(pattern)) {
[13:35:06.991]                           computeRestarts <- base::computeRestarts
[13:35:06.991]                           grepl <- base::grepl
[13:35:06.991]                           restarts <- computeRestarts(cond)
[13:35:06.991]                           for (restart in restarts) {
[13:35:06.991]                             name <- restart$name
[13:35:06.991]                             if (is.null(name)) 
[13:35:06.991]                               next
[13:35:06.991]                             if (!grepl(pattern, name)) 
[13:35:06.991]                               next
[13:35:06.991]                             invokeRestart(restart)
[13:35:06.991]                             muffled <- TRUE
[13:35:06.991]                             break
[13:35:06.991]                           }
[13:35:06.991]                         }
[13:35:06.991]                       }
[13:35:06.991]                       invisible(muffled)
[13:35:06.991]                     }
[13:35:06.991]                     muffleCondition(cond, pattern = "^muffle")
[13:35:06.991]                   }
[13:35:06.991]                 }
[13:35:06.991]             }
[13:35:06.991]         }))
[13:35:06.991]     }, error = function(ex) {
[13:35:06.991]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:06.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:06.991]                 ...future.rng), started = ...future.startTime, 
[13:35:06.991]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:06.991]             version = "1.8"), class = "FutureResult")
[13:35:06.991]     }, finally = {
[13:35:06.991]         if (!identical(...future.workdir, getwd())) 
[13:35:06.991]             setwd(...future.workdir)
[13:35:06.991]         {
[13:35:06.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:06.991]                 ...future.oldOptions$nwarnings <- NULL
[13:35:06.991]             }
[13:35:06.991]             base::options(...future.oldOptions)
[13:35:06.991]             if (.Platform$OS.type == "windows") {
[13:35:06.991]                 old_names <- names(...future.oldEnvVars)
[13:35:06.991]                 envs <- base::Sys.getenv()
[13:35:06.991]                 names <- names(envs)
[13:35:06.991]                 common <- intersect(names, old_names)
[13:35:06.991]                 added <- setdiff(names, old_names)
[13:35:06.991]                 removed <- setdiff(old_names, names)
[13:35:06.991]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:06.991]                   envs[common]]
[13:35:06.991]                 NAMES <- toupper(changed)
[13:35:06.991]                 args <- list()
[13:35:06.991]                 for (kk in seq_along(NAMES)) {
[13:35:06.991]                   name <- changed[[kk]]
[13:35:06.991]                   NAME <- NAMES[[kk]]
[13:35:06.991]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.991]                     next
[13:35:06.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.991]                 }
[13:35:06.991]                 NAMES <- toupper(added)
[13:35:06.991]                 for (kk in seq_along(NAMES)) {
[13:35:06.991]                   name <- added[[kk]]
[13:35:06.991]                   NAME <- NAMES[[kk]]
[13:35:06.991]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.991]                     next
[13:35:06.991]                   args[[name]] <- ""
[13:35:06.991]                 }
[13:35:06.991]                 NAMES <- toupper(removed)
[13:35:06.991]                 for (kk in seq_along(NAMES)) {
[13:35:06.991]                   name <- removed[[kk]]
[13:35:06.991]                   NAME <- NAMES[[kk]]
[13:35:06.991]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:06.991]                     next
[13:35:06.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:06.991]                 }
[13:35:06.991]                 if (length(args) > 0) 
[13:35:06.991]                   base::do.call(base::Sys.setenv, args = args)
[13:35:06.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:06.991]             }
[13:35:06.991]             else {
[13:35:06.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:06.991]             }
[13:35:06.991]             {
[13:35:06.991]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:06.991]                   0L) {
[13:35:06.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:06.991]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:06.991]                   base::options(opts)
[13:35:06.991]                 }
[13:35:06.991]                 {
[13:35:06.991]                   {
[13:35:06.991]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:06.991]                     NULL
[13:35:06.991]                   }
[13:35:06.991]                   options(future.plan = NULL)
[13:35:06.991]                   if (is.na(NA_character_)) 
[13:35:06.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:06.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:06.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:06.991]                     .init = FALSE)
[13:35:06.991]                 }
[13:35:06.991]             }
[13:35:06.991]         }
[13:35:06.991]     })
[13:35:06.991]     if (TRUE) {
[13:35:06.991]         base::sink(type = "output", split = FALSE)
[13:35:06.991]         if (TRUE) {
[13:35:06.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:06.991]         }
[13:35:06.991]         else {
[13:35:06.991]             ...future.result["stdout"] <- base::list(NULL)
[13:35:06.991]         }
[13:35:06.991]         base::close(...future.stdout)
[13:35:06.991]         ...future.stdout <- NULL
[13:35:06.991]     }
[13:35:06.991]     ...future.result$conditions <- ...future.conditions
[13:35:06.991]     ...future.result$finished <- base::Sys.time()
[13:35:06.991]     ...future.result
[13:35:06.991] }
[13:35:06.994] assign_globals() ...
[13:35:06.994] List of 11
[13:35:06.994]  $ ...future.FUN            :function (x, ...)  
[13:35:06.994]  $ x_FUN                    :function (x)  
[13:35:06.994]  $ times                    : int 1
[13:35:06.994]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:06.994]  $ stop_if_not              :function (...)  
[13:35:06.994]  $ dim                      : NULL
[13:35:06.994]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:06.994]  $ future.call.arguments    : list()
[13:35:06.994]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:06.994]  $ ...future.elements_ii    :List of 5
[13:35:06.994]   ..$ : int 6
[13:35:06.994]   ..$ : int 7
[13:35:06.994]   ..$ : int 8
[13:35:06.994]   ..$ : int 9
[13:35:06.994]   ..$ : int 10
[13:35:06.994]  $ ...future.seeds_ii       : NULL
[13:35:06.994]  $ ...future.globals.maxSize: NULL
[13:35:06.994]  - attr(*, "where")=List of 11
[13:35:06.994]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:06.994]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:06.994]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:06.994]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:06.994]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:06.994]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:06.994]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:06.994]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:06.994]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:06.994]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:06.994]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:06.994]  - attr(*, "resolved")= logi FALSE
[13:35:06.994]  - attr(*, "total_size")= num 94336
[13:35:06.994]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:06.994]  - attr(*, "already-done")= logi TRUE
[13:35:07.005] - copied ‘...future.FUN’ to environment
[13:35:07.005] - copied ‘x_FUN’ to environment
[13:35:07.005] - copied ‘times’ to environment
[13:35:07.005] - copied ‘stopf’ to environment
[13:35:07.005] - copied ‘stop_if_not’ to environment
[13:35:07.005] - copied ‘dim’ to environment
[13:35:07.005] - copied ‘valid_types’ to environment
[13:35:07.005] - copied ‘future.call.arguments’ to environment
[13:35:07.005] - copied ‘...future.elements_ii’ to environment
[13:35:07.005] - copied ‘...future.seeds_ii’ to environment
[13:35:07.006] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.006] assign_globals() ... done
[13:35:07.006] requestCore(): workers = 2
[13:35:07.008] MulticoreFuture started
[13:35:07.012] - Launch lazy future ... done
[13:35:07.013] run() for ‘MulticoreFuture’ ... done
[13:35:07.013] Created future:
[13:35:07.013] plan(): Setting new future strategy stack:
[13:35:07.014] List of future strategies:
[13:35:07.014] 1. sequential:
[13:35:07.014]    - args: function (..., envir = parent.frame())
[13:35:07.014]    - tweaked: FALSE
[13:35:07.014]    - call: NULL
[13:35:07.015] plan(): nbrOfWorkers() = 1
[13:35:07.018] plan(): Setting new future strategy stack:
[13:35:07.018] List of future strategies:
[13:35:07.018] 1. multicore:
[13:35:07.018]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.018]    - tweaked: FALSE
[13:35:07.018]    - call: plan(strategy)
[13:35:07.024] plan(): nbrOfWorkers() = 2
[13:35:07.013] MulticoreFuture:
[13:35:07.013] Label: ‘future_vapply-2’
[13:35:07.013] Expression:
[13:35:07.013] {
[13:35:07.013]     do.call(function(...) {
[13:35:07.013]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.013]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.013]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.013]             on.exit(options(oopts), add = TRUE)
[13:35:07.013]         }
[13:35:07.013]         {
[13:35:07.013]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.013]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.013]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.013]             })
[13:35:07.013]         }
[13:35:07.013]     }, args = future.call.arguments)
[13:35:07.013] }
[13:35:07.013] Lazy evaluation: FALSE
[13:35:07.013] Asynchronous evaluation: TRUE
[13:35:07.013] Local evaluation: TRUE
[13:35:07.013] Environment: R_GlobalEnv
[13:35:07.013] Capture standard output: TRUE
[13:35:07.013] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.013] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:07.013] Packages: 1 packages (‘future.apply’)
[13:35:07.013] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.013] Resolved: TRUE
[13:35:07.013] Value: <not collected>
[13:35:07.013] Conditions captured: <none>
[13:35:07.013] Early signaling: FALSE
[13:35:07.013] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.013] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.026] Chunk #2 of 2 ... DONE
[13:35:07.026] Launching 2 futures (chunks) ... DONE
[13:35:07.026] Resolving 2 futures (chunks) ...
[13:35:07.026] resolve() on list ...
[13:35:07.027]  recursive: 0
[13:35:07.027]  length: 2
[13:35:07.027] 
[13:35:07.027] Future #1
[13:35:07.028] result() for MulticoreFuture ...
[13:35:07.028] result() for MulticoreFuture ...
[13:35:07.029] result() for MulticoreFuture ... done
[13:35:07.029] result() for MulticoreFuture ... done
[13:35:07.029] result() for MulticoreFuture ...
[13:35:07.029] result() for MulticoreFuture ... done
[13:35:07.030] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:07.030] - nx: 2
[13:35:07.030] - relay: TRUE
[13:35:07.030] - stdout: TRUE
[13:35:07.030] - signal: TRUE
[13:35:07.031] - resignal: FALSE
[13:35:07.031] - force: TRUE
[13:35:07.031] - relayed: [n=2] FALSE, FALSE
[13:35:07.031] - queued futures: [n=2] FALSE, FALSE
[13:35:07.031]  - until=1
[13:35:07.031]  - relaying element #1
[13:35:07.031] result() for MulticoreFuture ...
[13:35:07.032] result() for MulticoreFuture ... done
[13:35:07.032] result() for MulticoreFuture ...
[13:35:07.032] result() for MulticoreFuture ... done
[13:35:07.032] result() for MulticoreFuture ...
[13:35:07.032] result() for MulticoreFuture ... done
[13:35:07.032] result() for MulticoreFuture ...
[13:35:07.033] result() for MulticoreFuture ... done
[13:35:07.033] - relayed: [n=2] TRUE, FALSE
[13:35:07.033] - queued futures: [n=2] TRUE, FALSE
[13:35:07.033] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:07.034]  length: 1 (resolved future 1)
[13:35:07.034] Future #2
[13:35:07.034] result() for MulticoreFuture ...
[13:35:07.035] result() for MulticoreFuture ...
[13:35:07.035] result() for MulticoreFuture ... done
[13:35:07.035] result() for MulticoreFuture ... done
[13:35:07.035] result() for MulticoreFuture ...
[13:35:07.035] result() for MulticoreFuture ... done
[13:35:07.036] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:07.036] - nx: 2
[13:35:07.036] - relay: TRUE
[13:35:07.036] - stdout: TRUE
[13:35:07.036] - signal: TRUE
[13:35:07.036] - resignal: FALSE
[13:35:07.036] - force: TRUE
[13:35:07.036] - relayed: [n=2] TRUE, FALSE
[13:35:07.036] - queued futures: [n=2] TRUE, FALSE
[13:35:07.037]  - until=2
[13:35:07.037]  - relaying element #2
[13:35:07.037] result() for MulticoreFuture ...
[13:35:07.037] result() for MulticoreFuture ... done
[13:35:07.037] result() for MulticoreFuture ...
[13:35:07.037] result() for MulticoreFuture ... done
[13:35:07.037] result() for MulticoreFuture ...
[13:35:07.037] result() for MulticoreFuture ... done
[13:35:07.038] result() for MulticoreFuture ...
[13:35:07.038] result() for MulticoreFuture ... done
[13:35:07.038] - relayed: [n=2] TRUE, TRUE
[13:35:07.038] - queued futures: [n=2] TRUE, TRUE
[13:35:07.038] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:07.038]  length: 0 (resolved future 2)
[13:35:07.038] Relaying remaining futures
[13:35:07.038] signalConditionsASAP(NULL, pos=0) ...
[13:35:07.038] - nx: 2
[13:35:07.038] - relay: TRUE
[13:35:07.039] - stdout: TRUE
[13:35:07.039] - signal: TRUE
[13:35:07.039] - resignal: FALSE
[13:35:07.039] - force: TRUE
[13:35:07.039] - relayed: [n=2] TRUE, TRUE
[13:35:07.039] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:07.039] - relayed: [n=2] TRUE, TRUE
[13:35:07.039] - queued futures: [n=2] TRUE, TRUE
[13:35:07.039] signalConditionsASAP(NULL, pos=0) ... done
[13:35:07.040] resolve() on list ... DONE
[13:35:07.040] result() for MulticoreFuture ...
[13:35:07.040] result() for MulticoreFuture ... done
[13:35:07.040] result() for MulticoreFuture ...
[13:35:07.040] result() for MulticoreFuture ... done
[13:35:07.040] result() for MulticoreFuture ...
[13:35:07.040] result() for MulticoreFuture ... done
[13:35:07.040] result() for MulticoreFuture ...
[13:35:07.040] result() for MulticoreFuture ... done
[13:35:07.041]  - Number of value chunks collected: 2
[13:35:07.041] Resolving 2 futures (chunks) ... DONE
[13:35:07.041] Reducing values from 2 chunks ...
[13:35:07.041]  - Number of values collected after concatenation: 10
[13:35:07.041]  - Number of values expected: 10
[13:35:07.041] Reducing values from 2 chunks ... DONE
[13:35:07.041] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[13:35:07.042] future_lapply() ...
[13:35:07.048] Number of chunks: 2
[13:35:07.048] getGlobalsAndPackagesXApply() ...
[13:35:07.048]  - future.globals: TRUE
[13:35:07.048] getGlobalsAndPackages() ...
[13:35:07.048] Searching for globals...
[13:35:07.054] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[13:35:07.054] Searching for globals ... DONE
[13:35:07.054] Resolving globals: FALSE
[13:35:07.055] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[13:35:07.056] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:07.056] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:07.056] - packages: [1] ‘future.apply’
[13:35:07.056] getGlobalsAndPackages() ... DONE
[13:35:07.056]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:07.056]  - needed namespaces: [n=1] ‘future.apply’
[13:35:07.057] Finding globals ... DONE
[13:35:07.057]  - use_args: TRUE
[13:35:07.057]  - Getting '...' globals ...
[13:35:07.057] resolve() on list ...
[13:35:07.057]  recursive: 0
[13:35:07.057]  length: 1
[13:35:07.057]  elements: ‘...’
[13:35:07.058]  length: 0 (resolved future 1)
[13:35:07.058] resolve() on list ... DONE
[13:35:07.058]    - '...' content: [n=0] 
[13:35:07.058] List of 1
[13:35:07.058]  $ ...: list()
[13:35:07.058]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.058]  - attr(*, "where")=List of 1
[13:35:07.058]   ..$ ...:<environment: 0x5574d06150c8> 
[13:35:07.058]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.058]  - attr(*, "resolved")= logi TRUE
[13:35:07.058]  - attr(*, "total_size")= num NA
[13:35:07.060]  - Getting '...' globals ... DONE
[13:35:07.061] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:07.061] List of 8
[13:35:07.061]  $ ...future.FUN:function (x, ...)  
[13:35:07.061]  $ x_FUN        :function (x)  
[13:35:07.061]  $ times        : int 2
[13:35:07.061]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.061]  $ stop_if_not  :function (...)  
[13:35:07.061]  $ dim          : NULL
[13:35:07.061]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:07.061]  $ ...          : list()
[13:35:07.061]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.061]  - attr(*, "where")=List of 8
[13:35:07.061]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:07.061]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:07.061]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:07.061]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:07.061]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:07.061]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:07.061]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:07.061]   ..$ ...          :<environment: 0x5574d06150c8> 
[13:35:07.061]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.061]  - attr(*, "resolved")= logi FALSE
[13:35:07.061]  - attr(*, "total_size")= num 96456
[13:35:07.066] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:07.066] getGlobalsAndPackagesXApply() ... DONE
[13:35:07.066] Number of futures (= number of chunks): 2
[13:35:07.066] Launching 2 futures (chunks) ...
[13:35:07.066] Chunk #1 of 2 ...
[13:35:07.067]  - Finding globals in 'X' for chunk #1 ...
[13:35:07.067] getGlobalsAndPackages() ...
[13:35:07.067] Searching for globals...
[13:35:07.067] 
[13:35:07.067] Searching for globals ... DONE
[13:35:07.067] - globals: [0] <none>
[13:35:07.067] getGlobalsAndPackages() ... DONE
[13:35:07.067]    + additional globals found: [n=0] 
[13:35:07.068]    + additional namespaces needed: [n=0] 
[13:35:07.068]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:07.068]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.068]  - seeds: <none>
[13:35:07.068]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.068] getGlobalsAndPackages() ...
[13:35:07.068] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.068] Resolving globals: FALSE
[13:35:07.068] Tweak future expression to call with '...' arguments ...
[13:35:07.068] {
[13:35:07.068]     do.call(function(...) {
[13:35:07.068]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.068]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.068]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.068]             on.exit(options(oopts), add = TRUE)
[13:35:07.068]         }
[13:35:07.068]         {
[13:35:07.068]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.068]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.068]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.068]             })
[13:35:07.068]         }
[13:35:07.068]     }, args = future.call.arguments)
[13:35:07.068] }
[13:35:07.069] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.069] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.069] - packages: [1] ‘future.apply’
[13:35:07.069] getGlobalsAndPackages() ... DONE
[13:35:07.070] run() for ‘Future’ ...
[13:35:07.070] - state: ‘created’
[13:35:07.070] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.075] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.075] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.075]   - Field: ‘label’
[13:35:07.076]   - Field: ‘local’
[13:35:07.076]   - Field: ‘owner’
[13:35:07.076]   - Field: ‘envir’
[13:35:07.076]   - Field: ‘workers’
[13:35:07.076]   - Field: ‘packages’
[13:35:07.076]   - Field: ‘gc’
[13:35:07.076]   - Field: ‘job’
[13:35:07.076]   - Field: ‘conditions’
[13:35:07.076]   - Field: ‘expr’
[13:35:07.076]   - Field: ‘uuid’
[13:35:07.077]   - Field: ‘seed’
[13:35:07.077]   - Field: ‘version’
[13:35:07.077]   - Field: ‘result’
[13:35:07.077]   - Field: ‘asynchronous’
[13:35:07.077]   - Field: ‘calls’
[13:35:07.077]   - Field: ‘globals’
[13:35:07.077]   - Field: ‘stdout’
[13:35:07.077]   - Field: ‘earlySignal’
[13:35:07.077]   - Field: ‘lazy’
[13:35:07.077]   - Field: ‘state’
[13:35:07.078] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.078] - Launch lazy future ...
[13:35:07.078] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:07.078] Packages needed by future strategies (n = 0): <none>
[13:35:07.079] {
[13:35:07.079]     {
[13:35:07.079]         {
[13:35:07.079]             ...future.startTime <- base::Sys.time()
[13:35:07.079]             {
[13:35:07.079]                 {
[13:35:07.079]                   {
[13:35:07.079]                     {
[13:35:07.079]                       {
[13:35:07.079]                         base::local({
[13:35:07.079]                           has_future <- base::requireNamespace("future", 
[13:35:07.079]                             quietly = TRUE)
[13:35:07.079]                           if (has_future) {
[13:35:07.079]                             ns <- base::getNamespace("future")
[13:35:07.079]                             version <- ns[[".package"]][["version"]]
[13:35:07.079]                             if (is.null(version)) 
[13:35:07.079]                               version <- utils::packageVersion("future")
[13:35:07.079]                           }
[13:35:07.079]                           else {
[13:35:07.079]                             version <- NULL
[13:35:07.079]                           }
[13:35:07.079]                           if (!has_future || version < "1.8.0") {
[13:35:07.079]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.079]                               "", base::R.version$version.string), 
[13:35:07.079]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.079]                                 base::R.version$platform, 8 * 
[13:35:07.079]                                   base::.Machine$sizeof.pointer), 
[13:35:07.079]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.079]                                 "release", "version")], collapse = " "), 
[13:35:07.079]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.079]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.079]                               info)
[13:35:07.079]                             info <- base::paste(info, collapse = "; ")
[13:35:07.079]                             if (!has_future) {
[13:35:07.079]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.079]                                 info)
[13:35:07.079]                             }
[13:35:07.079]                             else {
[13:35:07.079]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.079]                                 info, version)
[13:35:07.079]                             }
[13:35:07.079]                             base::stop(msg)
[13:35:07.079]                           }
[13:35:07.079]                         })
[13:35:07.079]                       }
[13:35:07.079]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.079]                       base::options(mc.cores = 1L)
[13:35:07.079]                     }
[13:35:07.079]                     base::local({
[13:35:07.079]                       for (pkg in "future.apply") {
[13:35:07.079]                         base::loadNamespace(pkg)
[13:35:07.079]                         base::library(pkg, character.only = TRUE)
[13:35:07.079]                       }
[13:35:07.079]                     })
[13:35:07.079]                   }
[13:35:07.079]                   ...future.strategy.old <- future::plan("list")
[13:35:07.079]                   options(future.plan = NULL)
[13:35:07.079]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.079]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.079]                 }
[13:35:07.079]                 ...future.workdir <- getwd()
[13:35:07.079]             }
[13:35:07.079]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.079]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.079]         }
[13:35:07.079]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.079]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.079]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.079]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.079]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.079]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.079]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.079]             base::names(...future.oldOptions))
[13:35:07.079]     }
[13:35:07.079]     if (FALSE) {
[13:35:07.079]     }
[13:35:07.079]     else {
[13:35:07.079]         if (TRUE) {
[13:35:07.079]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.079]                 open = "w")
[13:35:07.079]         }
[13:35:07.079]         else {
[13:35:07.079]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.079]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.079]         }
[13:35:07.079]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.079]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.079]             base::sink(type = "output", split = FALSE)
[13:35:07.079]             base::close(...future.stdout)
[13:35:07.079]         }, add = TRUE)
[13:35:07.079]     }
[13:35:07.079]     ...future.frame <- base::sys.nframe()
[13:35:07.079]     ...future.conditions <- base::list()
[13:35:07.079]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.079]     if (FALSE) {
[13:35:07.079]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.079]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.079]     }
[13:35:07.079]     ...future.result <- base::tryCatch({
[13:35:07.079]         base::withCallingHandlers({
[13:35:07.079]             ...future.value <- base::withVisible(base::local({
[13:35:07.079]                 withCallingHandlers({
[13:35:07.079]                   {
[13:35:07.079]                     do.call(function(...) {
[13:35:07.079]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.079]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.079]                         ...future.globals.maxSize)) {
[13:35:07.079]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.079]                         on.exit(options(oopts), add = TRUE)
[13:35:07.079]                       }
[13:35:07.079]                       {
[13:35:07.079]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.079]                           FUN = function(jj) {
[13:35:07.079]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.079]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.079]                           })
[13:35:07.079]                       }
[13:35:07.079]                     }, args = future.call.arguments)
[13:35:07.079]                   }
[13:35:07.079]                 }, immediateCondition = function(cond) {
[13:35:07.079]                   save_rds <- function (object, pathname, ...) 
[13:35:07.079]                   {
[13:35:07.079]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.079]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.079]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.079]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.079]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.079]                         fi_tmp[["mtime"]])
[13:35:07.079]                     }
[13:35:07.079]                     tryCatch({
[13:35:07.079]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.079]                     }, error = function(ex) {
[13:35:07.079]                       msg <- conditionMessage(ex)
[13:35:07.079]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.079]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.079]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.079]                         fi_tmp[["mtime"]], msg)
[13:35:07.079]                       ex$message <- msg
[13:35:07.079]                       stop(ex)
[13:35:07.079]                     })
[13:35:07.079]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.079]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.079]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.079]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.079]                       fi <- file.info(pathname)
[13:35:07.079]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.079]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.079]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.079]                         fi[["size"]], fi[["mtime"]])
[13:35:07.079]                       stop(msg)
[13:35:07.079]                     }
[13:35:07.079]                     invisible(pathname)
[13:35:07.079]                   }
[13:35:07.079]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.079]                     rootPath = tempdir()) 
[13:35:07.079]                   {
[13:35:07.079]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.079]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.079]                       tmpdir = path, fileext = ".rds")
[13:35:07.079]                     save_rds(obj, file)
[13:35:07.079]                   }
[13:35:07.079]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.079]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.079]                   {
[13:35:07.079]                     inherits <- base::inherits
[13:35:07.079]                     invokeRestart <- base::invokeRestart
[13:35:07.079]                     is.null <- base::is.null
[13:35:07.079]                     muffled <- FALSE
[13:35:07.079]                     if (inherits(cond, "message")) {
[13:35:07.079]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.079]                       if (muffled) 
[13:35:07.079]                         invokeRestart("muffleMessage")
[13:35:07.079]                     }
[13:35:07.079]                     else if (inherits(cond, "warning")) {
[13:35:07.079]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.079]                       if (muffled) 
[13:35:07.079]                         invokeRestart("muffleWarning")
[13:35:07.079]                     }
[13:35:07.079]                     else if (inherits(cond, "condition")) {
[13:35:07.079]                       if (!is.null(pattern)) {
[13:35:07.079]                         computeRestarts <- base::computeRestarts
[13:35:07.079]                         grepl <- base::grepl
[13:35:07.079]                         restarts <- computeRestarts(cond)
[13:35:07.079]                         for (restart in restarts) {
[13:35:07.079]                           name <- restart$name
[13:35:07.079]                           if (is.null(name)) 
[13:35:07.079]                             next
[13:35:07.079]                           if (!grepl(pattern, name)) 
[13:35:07.079]                             next
[13:35:07.079]                           invokeRestart(restart)
[13:35:07.079]                           muffled <- TRUE
[13:35:07.079]                           break
[13:35:07.079]                         }
[13:35:07.079]                       }
[13:35:07.079]                     }
[13:35:07.079]                     invisible(muffled)
[13:35:07.079]                   }
[13:35:07.079]                   muffleCondition(cond)
[13:35:07.079]                 })
[13:35:07.079]             }))
[13:35:07.079]             future::FutureResult(value = ...future.value$value, 
[13:35:07.079]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.079]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.079]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.079]                     ...future.globalenv.names))
[13:35:07.079]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.079]         }, condition = base::local({
[13:35:07.079]             c <- base::c
[13:35:07.079]             inherits <- base::inherits
[13:35:07.079]             invokeRestart <- base::invokeRestart
[13:35:07.079]             length <- base::length
[13:35:07.079]             list <- base::list
[13:35:07.079]             seq.int <- base::seq.int
[13:35:07.079]             signalCondition <- base::signalCondition
[13:35:07.079]             sys.calls <- base::sys.calls
[13:35:07.079]             `[[` <- base::`[[`
[13:35:07.079]             `+` <- base::`+`
[13:35:07.079]             `<<-` <- base::`<<-`
[13:35:07.079]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.079]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.079]                   3L)]
[13:35:07.079]             }
[13:35:07.079]             function(cond) {
[13:35:07.079]                 is_error <- inherits(cond, "error")
[13:35:07.079]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.079]                   NULL)
[13:35:07.079]                 if (is_error) {
[13:35:07.079]                   sessionInformation <- function() {
[13:35:07.079]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.079]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.079]                       search = base::search(), system = base::Sys.info())
[13:35:07.079]                   }
[13:35:07.079]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.079]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.079]                     cond$call), session = sessionInformation(), 
[13:35:07.079]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.079]                   signalCondition(cond)
[13:35:07.079]                 }
[13:35:07.079]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.079]                 "immediateCondition"))) {
[13:35:07.079]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.079]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.079]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.079]                   if (TRUE && !signal) {
[13:35:07.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.079]                     {
[13:35:07.079]                       inherits <- base::inherits
[13:35:07.079]                       invokeRestart <- base::invokeRestart
[13:35:07.079]                       is.null <- base::is.null
[13:35:07.079]                       muffled <- FALSE
[13:35:07.079]                       if (inherits(cond, "message")) {
[13:35:07.079]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.079]                         if (muffled) 
[13:35:07.079]                           invokeRestart("muffleMessage")
[13:35:07.079]                       }
[13:35:07.079]                       else if (inherits(cond, "warning")) {
[13:35:07.079]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.079]                         if (muffled) 
[13:35:07.079]                           invokeRestart("muffleWarning")
[13:35:07.079]                       }
[13:35:07.079]                       else if (inherits(cond, "condition")) {
[13:35:07.079]                         if (!is.null(pattern)) {
[13:35:07.079]                           computeRestarts <- base::computeRestarts
[13:35:07.079]                           grepl <- base::grepl
[13:35:07.079]                           restarts <- computeRestarts(cond)
[13:35:07.079]                           for (restart in restarts) {
[13:35:07.079]                             name <- restart$name
[13:35:07.079]                             if (is.null(name)) 
[13:35:07.079]                               next
[13:35:07.079]                             if (!grepl(pattern, name)) 
[13:35:07.079]                               next
[13:35:07.079]                             invokeRestart(restart)
[13:35:07.079]                             muffled <- TRUE
[13:35:07.079]                             break
[13:35:07.079]                           }
[13:35:07.079]                         }
[13:35:07.079]                       }
[13:35:07.079]                       invisible(muffled)
[13:35:07.079]                     }
[13:35:07.079]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.079]                   }
[13:35:07.079]                 }
[13:35:07.079]                 else {
[13:35:07.079]                   if (TRUE) {
[13:35:07.079]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.079]                     {
[13:35:07.079]                       inherits <- base::inherits
[13:35:07.079]                       invokeRestart <- base::invokeRestart
[13:35:07.079]                       is.null <- base::is.null
[13:35:07.079]                       muffled <- FALSE
[13:35:07.079]                       if (inherits(cond, "message")) {
[13:35:07.079]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.079]                         if (muffled) 
[13:35:07.079]                           invokeRestart("muffleMessage")
[13:35:07.079]                       }
[13:35:07.079]                       else if (inherits(cond, "warning")) {
[13:35:07.079]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.079]                         if (muffled) 
[13:35:07.079]                           invokeRestart("muffleWarning")
[13:35:07.079]                       }
[13:35:07.079]                       else if (inherits(cond, "condition")) {
[13:35:07.079]                         if (!is.null(pattern)) {
[13:35:07.079]                           computeRestarts <- base::computeRestarts
[13:35:07.079]                           grepl <- base::grepl
[13:35:07.079]                           restarts <- computeRestarts(cond)
[13:35:07.079]                           for (restart in restarts) {
[13:35:07.079]                             name <- restart$name
[13:35:07.079]                             if (is.null(name)) 
[13:35:07.079]                               next
[13:35:07.079]                             if (!grepl(pattern, name)) 
[13:35:07.079]                               next
[13:35:07.079]                             invokeRestart(restart)
[13:35:07.079]                             muffled <- TRUE
[13:35:07.079]                             break
[13:35:07.079]                           }
[13:35:07.079]                         }
[13:35:07.079]                       }
[13:35:07.079]                       invisible(muffled)
[13:35:07.079]                     }
[13:35:07.079]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.079]                   }
[13:35:07.079]                 }
[13:35:07.079]             }
[13:35:07.079]         }))
[13:35:07.079]     }, error = function(ex) {
[13:35:07.079]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.079]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.079]                 ...future.rng), started = ...future.startTime, 
[13:35:07.079]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.079]             version = "1.8"), class = "FutureResult")
[13:35:07.079]     }, finally = {
[13:35:07.079]         if (!identical(...future.workdir, getwd())) 
[13:35:07.079]             setwd(...future.workdir)
[13:35:07.079]         {
[13:35:07.079]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.079]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.079]             }
[13:35:07.079]             base::options(...future.oldOptions)
[13:35:07.079]             if (.Platform$OS.type == "windows") {
[13:35:07.079]                 old_names <- names(...future.oldEnvVars)
[13:35:07.079]                 envs <- base::Sys.getenv()
[13:35:07.079]                 names <- names(envs)
[13:35:07.079]                 common <- intersect(names, old_names)
[13:35:07.079]                 added <- setdiff(names, old_names)
[13:35:07.079]                 removed <- setdiff(old_names, names)
[13:35:07.079]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.079]                   envs[common]]
[13:35:07.079]                 NAMES <- toupper(changed)
[13:35:07.079]                 args <- list()
[13:35:07.079]                 for (kk in seq_along(NAMES)) {
[13:35:07.079]                   name <- changed[[kk]]
[13:35:07.079]                   NAME <- NAMES[[kk]]
[13:35:07.079]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.079]                     next
[13:35:07.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.079]                 }
[13:35:07.079]                 NAMES <- toupper(added)
[13:35:07.079]                 for (kk in seq_along(NAMES)) {
[13:35:07.079]                   name <- added[[kk]]
[13:35:07.079]                   NAME <- NAMES[[kk]]
[13:35:07.079]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.079]                     next
[13:35:07.079]                   args[[name]] <- ""
[13:35:07.079]                 }
[13:35:07.079]                 NAMES <- toupper(removed)
[13:35:07.079]                 for (kk in seq_along(NAMES)) {
[13:35:07.079]                   name <- removed[[kk]]
[13:35:07.079]                   NAME <- NAMES[[kk]]
[13:35:07.079]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.079]                     next
[13:35:07.079]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.079]                 }
[13:35:07.079]                 if (length(args) > 0) 
[13:35:07.079]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.079]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.079]             }
[13:35:07.079]             else {
[13:35:07.079]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.079]             }
[13:35:07.079]             {
[13:35:07.079]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.079]                   0L) {
[13:35:07.079]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.079]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.079]                   base::options(opts)
[13:35:07.079]                 }
[13:35:07.079]                 {
[13:35:07.079]                   {
[13:35:07.079]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.079]                     NULL
[13:35:07.079]                   }
[13:35:07.079]                   options(future.plan = NULL)
[13:35:07.079]                   if (is.na(NA_character_)) 
[13:35:07.079]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.079]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.079]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.079]                     .init = FALSE)
[13:35:07.079]                 }
[13:35:07.079]             }
[13:35:07.079]         }
[13:35:07.079]     })
[13:35:07.079]     if (TRUE) {
[13:35:07.079]         base::sink(type = "output", split = FALSE)
[13:35:07.079]         if (TRUE) {
[13:35:07.079]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.079]         }
[13:35:07.079]         else {
[13:35:07.079]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.079]         }
[13:35:07.079]         base::close(...future.stdout)
[13:35:07.079]         ...future.stdout <- NULL
[13:35:07.079]     }
[13:35:07.079]     ...future.result$conditions <- ...future.conditions
[13:35:07.079]     ...future.result$finished <- base::Sys.time()
[13:35:07.079]     ...future.result
[13:35:07.079] }
[13:35:07.081] assign_globals() ...
[13:35:07.081] List of 11
[13:35:07.081]  $ ...future.FUN            :function (x, ...)  
[13:35:07.081]  $ x_FUN                    :function (x)  
[13:35:07.081]  $ times                    : int 2
[13:35:07.081]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.081]  $ stop_if_not              :function (...)  
[13:35:07.081]  $ dim                      : NULL
[13:35:07.081]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:07.081]  $ future.call.arguments    : list()
[13:35:07.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.081]  $ ...future.elements_ii    :List of 5
[13:35:07.081]   ..$ : int 1
[13:35:07.081]   ..$ : int 2
[13:35:07.081]   ..$ : int 3
[13:35:07.081]   ..$ : int 4
[13:35:07.081]   ..$ : int 5
[13:35:07.081]  $ ...future.seeds_ii       : NULL
[13:35:07.081]  $ ...future.globals.maxSize: NULL
[13:35:07.081]  - attr(*, "where")=List of 11
[13:35:07.081]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.081]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:07.081]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:07.081]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:07.081]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:07.081]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:07.081]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:07.081]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.081]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.081]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.081]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.081]  - attr(*, "resolved")= logi FALSE
[13:35:07.081]  - attr(*, "total_size")= num 96456
[13:35:07.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.081]  - attr(*, "already-done")= logi TRUE
[13:35:07.089] - copied ‘...future.FUN’ to environment
[13:35:07.089] - reassign environment for ‘x_FUN’
[13:35:07.089] - copied ‘x_FUN’ to environment
[13:35:07.090] - copied ‘times’ to environment
[13:35:07.090] - copied ‘stopf’ to environment
[13:35:07.090] - copied ‘stop_if_not’ to environment
[13:35:07.090] - copied ‘dim’ to environment
[13:35:07.090] - copied ‘valid_types’ to environment
[13:35:07.090] - copied ‘future.call.arguments’ to environment
[13:35:07.090] - copied ‘...future.elements_ii’ to environment
[13:35:07.090] - copied ‘...future.seeds_ii’ to environment
[13:35:07.090] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.090] assign_globals() ... done
[13:35:07.091] requestCore(): workers = 2
[13:35:07.092] MulticoreFuture started
[13:35:07.093] - Launch lazy future ... done
[13:35:07.093] run() for ‘MulticoreFuture’ ... done
[13:35:07.093] Created future:
[13:35:07.094] plan(): Setting new future strategy stack:
[13:35:07.094] List of future strategies:
[13:35:07.094] 1. sequential:
[13:35:07.094]    - args: function (..., envir = parent.frame())
[13:35:07.094]    - tweaked: FALSE
[13:35:07.094]    - call: NULL
[13:35:07.095] plan(): nbrOfWorkers() = 1
[13:35:07.097] plan(): Setting new future strategy stack:
[13:35:07.097] List of future strategies:
[13:35:07.097] 1. multicore:
[13:35:07.097]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.097]    - tweaked: FALSE
[13:35:07.097]    - call: plan(strategy)
[13:35:07.106] plan(): nbrOfWorkers() = 2
[13:35:07.094] MulticoreFuture:
[13:35:07.094] Label: ‘future_vapply-1’
[13:35:07.094] Expression:
[13:35:07.094] {
[13:35:07.094]     do.call(function(...) {
[13:35:07.094]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.094]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.094]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.094]             on.exit(options(oopts), add = TRUE)
[13:35:07.094]         }
[13:35:07.094]         {
[13:35:07.094]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.094]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.094]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.094]             })
[13:35:07.094]         }
[13:35:07.094]     }, args = future.call.arguments)
[13:35:07.094] }
[13:35:07.094] Lazy evaluation: FALSE
[13:35:07.094] Asynchronous evaluation: TRUE
[13:35:07.094] Local evaluation: TRUE
[13:35:07.094] Environment: R_GlobalEnv
[13:35:07.094] Capture standard output: TRUE
[13:35:07.094] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.094] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:07.094] Packages: 1 packages (‘future.apply’)
[13:35:07.094] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.094] Resolved: FALSE
[13:35:07.094] Value: <not collected>
[13:35:07.094] Conditions captured: <none>
[13:35:07.094] Early signaling: FALSE
[13:35:07.094] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.094] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.107] Chunk #1 of 2 ... DONE
[13:35:07.107] Chunk #2 of 2 ...
[13:35:07.107]  - Finding globals in 'X' for chunk #2 ...
[13:35:07.107] getGlobalsAndPackages() ...
[13:35:07.107] Searching for globals...
[13:35:07.108] 
[13:35:07.108] Searching for globals ... DONE
[13:35:07.108] - globals: [0] <none>
[13:35:07.108] getGlobalsAndPackages() ... DONE
[13:35:07.108]    + additional globals found: [n=0] 
[13:35:07.111]    + additional namespaces needed: [n=0] 
[13:35:07.111]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:07.111]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.111]  - seeds: <none>
[13:35:07.112]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.112] getGlobalsAndPackages() ...
[13:35:07.112] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.113] Resolving globals: FALSE
[13:35:07.113] Tweak future expression to call with '...' arguments ...
[13:35:07.114] {
[13:35:07.114]     do.call(function(...) {
[13:35:07.114]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.114]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.114]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.114]             on.exit(options(oopts), add = TRUE)
[13:35:07.114]         }
[13:35:07.114]         {
[13:35:07.114]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.114]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.114]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.114]             })
[13:35:07.114]         }
[13:35:07.114]     }, args = future.call.arguments)
[13:35:07.114] }
[13:35:07.114] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.116] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.116] - packages: [1] ‘future.apply’
[13:35:07.116] getGlobalsAndPackages() ... DONE
[13:35:07.117] run() for ‘Future’ ...
[13:35:07.117] - state: ‘created’
[13:35:07.118] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.123] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.123] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.123]   - Field: ‘label’
[13:35:07.124]   - Field: ‘local’
[13:35:07.124]   - Field: ‘owner’
[13:35:07.124]   - Field: ‘envir’
[13:35:07.124]   - Field: ‘workers’
[13:35:07.124]   - Field: ‘packages’
[13:35:07.124]   - Field: ‘gc’
[13:35:07.124]   - Field: ‘job’
[13:35:07.125]   - Field: ‘conditions’
[13:35:07.125]   - Field: ‘expr’
[13:35:07.125]   - Field: ‘uuid’
[13:35:07.125]   - Field: ‘seed’
[13:35:07.125]   - Field: ‘version’
[13:35:07.125]   - Field: ‘result’
[13:35:07.126]   - Field: ‘asynchronous’
[13:35:07.126]   - Field: ‘calls’
[13:35:07.126]   - Field: ‘globals’
[13:35:07.126]   - Field: ‘stdout’
[13:35:07.127]   - Field: ‘earlySignal’
[13:35:07.127]   - Field: ‘lazy’
[13:35:07.127]   - Field: ‘state’
[13:35:07.127] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.127] - Launch lazy future ...
[13:35:07.128] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:07.128] Packages needed by future strategies (n = 0): <none>
[13:35:07.129] {
[13:35:07.129]     {
[13:35:07.129]         {
[13:35:07.129]             ...future.startTime <- base::Sys.time()
[13:35:07.129]             {
[13:35:07.129]                 {
[13:35:07.129]                   {
[13:35:07.129]                     {
[13:35:07.129]                       {
[13:35:07.129]                         base::local({
[13:35:07.129]                           has_future <- base::requireNamespace("future", 
[13:35:07.129]                             quietly = TRUE)
[13:35:07.129]                           if (has_future) {
[13:35:07.129]                             ns <- base::getNamespace("future")
[13:35:07.129]                             version <- ns[[".package"]][["version"]]
[13:35:07.129]                             if (is.null(version)) 
[13:35:07.129]                               version <- utils::packageVersion("future")
[13:35:07.129]                           }
[13:35:07.129]                           else {
[13:35:07.129]                             version <- NULL
[13:35:07.129]                           }
[13:35:07.129]                           if (!has_future || version < "1.8.0") {
[13:35:07.129]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.129]                               "", base::R.version$version.string), 
[13:35:07.129]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.129]                                 base::R.version$platform, 8 * 
[13:35:07.129]                                   base::.Machine$sizeof.pointer), 
[13:35:07.129]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.129]                                 "release", "version")], collapse = " "), 
[13:35:07.129]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.129]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.129]                               info)
[13:35:07.129]                             info <- base::paste(info, collapse = "; ")
[13:35:07.129]                             if (!has_future) {
[13:35:07.129]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.129]                                 info)
[13:35:07.129]                             }
[13:35:07.129]                             else {
[13:35:07.129]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.129]                                 info, version)
[13:35:07.129]                             }
[13:35:07.129]                             base::stop(msg)
[13:35:07.129]                           }
[13:35:07.129]                         })
[13:35:07.129]                       }
[13:35:07.129]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.129]                       base::options(mc.cores = 1L)
[13:35:07.129]                     }
[13:35:07.129]                     base::local({
[13:35:07.129]                       for (pkg in "future.apply") {
[13:35:07.129]                         base::loadNamespace(pkg)
[13:35:07.129]                         base::library(pkg, character.only = TRUE)
[13:35:07.129]                       }
[13:35:07.129]                     })
[13:35:07.129]                   }
[13:35:07.129]                   ...future.strategy.old <- future::plan("list")
[13:35:07.129]                   options(future.plan = NULL)
[13:35:07.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.129]                 }
[13:35:07.129]                 ...future.workdir <- getwd()
[13:35:07.129]             }
[13:35:07.129]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.129]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.129]         }
[13:35:07.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.129]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.129]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.129]             base::names(...future.oldOptions))
[13:35:07.129]     }
[13:35:07.129]     if (FALSE) {
[13:35:07.129]     }
[13:35:07.129]     else {
[13:35:07.129]         if (TRUE) {
[13:35:07.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.129]                 open = "w")
[13:35:07.129]         }
[13:35:07.129]         else {
[13:35:07.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.129]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.129]         }
[13:35:07.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.129]             base::sink(type = "output", split = FALSE)
[13:35:07.129]             base::close(...future.stdout)
[13:35:07.129]         }, add = TRUE)
[13:35:07.129]     }
[13:35:07.129]     ...future.frame <- base::sys.nframe()
[13:35:07.129]     ...future.conditions <- base::list()
[13:35:07.129]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.129]     if (FALSE) {
[13:35:07.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.129]     }
[13:35:07.129]     ...future.result <- base::tryCatch({
[13:35:07.129]         base::withCallingHandlers({
[13:35:07.129]             ...future.value <- base::withVisible(base::local({
[13:35:07.129]                 withCallingHandlers({
[13:35:07.129]                   {
[13:35:07.129]                     do.call(function(...) {
[13:35:07.129]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.129]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.129]                         ...future.globals.maxSize)) {
[13:35:07.129]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.129]                         on.exit(options(oopts), add = TRUE)
[13:35:07.129]                       }
[13:35:07.129]                       {
[13:35:07.129]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.129]                           FUN = function(jj) {
[13:35:07.129]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.129]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.129]                           })
[13:35:07.129]                       }
[13:35:07.129]                     }, args = future.call.arguments)
[13:35:07.129]                   }
[13:35:07.129]                 }, immediateCondition = function(cond) {
[13:35:07.129]                   save_rds <- function (object, pathname, ...) 
[13:35:07.129]                   {
[13:35:07.129]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.129]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.129]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.129]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.129]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.129]                         fi_tmp[["mtime"]])
[13:35:07.129]                     }
[13:35:07.129]                     tryCatch({
[13:35:07.129]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.129]                     }, error = function(ex) {
[13:35:07.129]                       msg <- conditionMessage(ex)
[13:35:07.129]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.129]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.129]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.129]                         fi_tmp[["mtime"]], msg)
[13:35:07.129]                       ex$message <- msg
[13:35:07.129]                       stop(ex)
[13:35:07.129]                     })
[13:35:07.129]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.129]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.129]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.129]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.129]                       fi <- file.info(pathname)
[13:35:07.129]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.129]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.129]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.129]                         fi[["size"]], fi[["mtime"]])
[13:35:07.129]                       stop(msg)
[13:35:07.129]                     }
[13:35:07.129]                     invisible(pathname)
[13:35:07.129]                   }
[13:35:07.129]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.129]                     rootPath = tempdir()) 
[13:35:07.129]                   {
[13:35:07.129]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.129]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.129]                       tmpdir = path, fileext = ".rds")
[13:35:07.129]                     save_rds(obj, file)
[13:35:07.129]                   }
[13:35:07.129]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.129]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.129]                   {
[13:35:07.129]                     inherits <- base::inherits
[13:35:07.129]                     invokeRestart <- base::invokeRestart
[13:35:07.129]                     is.null <- base::is.null
[13:35:07.129]                     muffled <- FALSE
[13:35:07.129]                     if (inherits(cond, "message")) {
[13:35:07.129]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.129]                       if (muffled) 
[13:35:07.129]                         invokeRestart("muffleMessage")
[13:35:07.129]                     }
[13:35:07.129]                     else if (inherits(cond, "warning")) {
[13:35:07.129]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.129]                       if (muffled) 
[13:35:07.129]                         invokeRestart("muffleWarning")
[13:35:07.129]                     }
[13:35:07.129]                     else if (inherits(cond, "condition")) {
[13:35:07.129]                       if (!is.null(pattern)) {
[13:35:07.129]                         computeRestarts <- base::computeRestarts
[13:35:07.129]                         grepl <- base::grepl
[13:35:07.129]                         restarts <- computeRestarts(cond)
[13:35:07.129]                         for (restart in restarts) {
[13:35:07.129]                           name <- restart$name
[13:35:07.129]                           if (is.null(name)) 
[13:35:07.129]                             next
[13:35:07.129]                           if (!grepl(pattern, name)) 
[13:35:07.129]                             next
[13:35:07.129]                           invokeRestart(restart)
[13:35:07.129]                           muffled <- TRUE
[13:35:07.129]                           break
[13:35:07.129]                         }
[13:35:07.129]                       }
[13:35:07.129]                     }
[13:35:07.129]                     invisible(muffled)
[13:35:07.129]                   }
[13:35:07.129]                   muffleCondition(cond)
[13:35:07.129]                 })
[13:35:07.129]             }))
[13:35:07.129]             future::FutureResult(value = ...future.value$value, 
[13:35:07.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.129]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.129]                     ...future.globalenv.names))
[13:35:07.129]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.129]         }, condition = base::local({
[13:35:07.129]             c <- base::c
[13:35:07.129]             inherits <- base::inherits
[13:35:07.129]             invokeRestart <- base::invokeRestart
[13:35:07.129]             length <- base::length
[13:35:07.129]             list <- base::list
[13:35:07.129]             seq.int <- base::seq.int
[13:35:07.129]             signalCondition <- base::signalCondition
[13:35:07.129]             sys.calls <- base::sys.calls
[13:35:07.129]             `[[` <- base::`[[`
[13:35:07.129]             `+` <- base::`+`
[13:35:07.129]             `<<-` <- base::`<<-`
[13:35:07.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.129]                   3L)]
[13:35:07.129]             }
[13:35:07.129]             function(cond) {
[13:35:07.129]                 is_error <- inherits(cond, "error")
[13:35:07.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.129]                   NULL)
[13:35:07.129]                 if (is_error) {
[13:35:07.129]                   sessionInformation <- function() {
[13:35:07.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.129]                       search = base::search(), system = base::Sys.info())
[13:35:07.129]                   }
[13:35:07.129]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.129]                     cond$call), session = sessionInformation(), 
[13:35:07.129]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.129]                   signalCondition(cond)
[13:35:07.129]                 }
[13:35:07.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.129]                 "immediateCondition"))) {
[13:35:07.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.129]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.129]                   if (TRUE && !signal) {
[13:35:07.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.129]                     {
[13:35:07.129]                       inherits <- base::inherits
[13:35:07.129]                       invokeRestart <- base::invokeRestart
[13:35:07.129]                       is.null <- base::is.null
[13:35:07.129]                       muffled <- FALSE
[13:35:07.129]                       if (inherits(cond, "message")) {
[13:35:07.129]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.129]                         if (muffled) 
[13:35:07.129]                           invokeRestart("muffleMessage")
[13:35:07.129]                       }
[13:35:07.129]                       else if (inherits(cond, "warning")) {
[13:35:07.129]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.129]                         if (muffled) 
[13:35:07.129]                           invokeRestart("muffleWarning")
[13:35:07.129]                       }
[13:35:07.129]                       else if (inherits(cond, "condition")) {
[13:35:07.129]                         if (!is.null(pattern)) {
[13:35:07.129]                           computeRestarts <- base::computeRestarts
[13:35:07.129]                           grepl <- base::grepl
[13:35:07.129]                           restarts <- computeRestarts(cond)
[13:35:07.129]                           for (restart in restarts) {
[13:35:07.129]                             name <- restart$name
[13:35:07.129]                             if (is.null(name)) 
[13:35:07.129]                               next
[13:35:07.129]                             if (!grepl(pattern, name)) 
[13:35:07.129]                               next
[13:35:07.129]                             invokeRestart(restart)
[13:35:07.129]                             muffled <- TRUE
[13:35:07.129]                             break
[13:35:07.129]                           }
[13:35:07.129]                         }
[13:35:07.129]                       }
[13:35:07.129]                       invisible(muffled)
[13:35:07.129]                     }
[13:35:07.129]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.129]                   }
[13:35:07.129]                 }
[13:35:07.129]                 else {
[13:35:07.129]                   if (TRUE) {
[13:35:07.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.129]                     {
[13:35:07.129]                       inherits <- base::inherits
[13:35:07.129]                       invokeRestart <- base::invokeRestart
[13:35:07.129]                       is.null <- base::is.null
[13:35:07.129]                       muffled <- FALSE
[13:35:07.129]                       if (inherits(cond, "message")) {
[13:35:07.129]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.129]                         if (muffled) 
[13:35:07.129]                           invokeRestart("muffleMessage")
[13:35:07.129]                       }
[13:35:07.129]                       else if (inherits(cond, "warning")) {
[13:35:07.129]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.129]                         if (muffled) 
[13:35:07.129]                           invokeRestart("muffleWarning")
[13:35:07.129]                       }
[13:35:07.129]                       else if (inherits(cond, "condition")) {
[13:35:07.129]                         if (!is.null(pattern)) {
[13:35:07.129]                           computeRestarts <- base::computeRestarts
[13:35:07.129]                           grepl <- base::grepl
[13:35:07.129]                           restarts <- computeRestarts(cond)
[13:35:07.129]                           for (restart in restarts) {
[13:35:07.129]                             name <- restart$name
[13:35:07.129]                             if (is.null(name)) 
[13:35:07.129]                               next
[13:35:07.129]                             if (!grepl(pattern, name)) 
[13:35:07.129]                               next
[13:35:07.129]                             invokeRestart(restart)
[13:35:07.129]                             muffled <- TRUE
[13:35:07.129]                             break
[13:35:07.129]                           }
[13:35:07.129]                         }
[13:35:07.129]                       }
[13:35:07.129]                       invisible(muffled)
[13:35:07.129]                     }
[13:35:07.129]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.129]                   }
[13:35:07.129]                 }
[13:35:07.129]             }
[13:35:07.129]         }))
[13:35:07.129]     }, error = function(ex) {
[13:35:07.129]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.129]                 ...future.rng), started = ...future.startTime, 
[13:35:07.129]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.129]             version = "1.8"), class = "FutureResult")
[13:35:07.129]     }, finally = {
[13:35:07.129]         if (!identical(...future.workdir, getwd())) 
[13:35:07.129]             setwd(...future.workdir)
[13:35:07.129]         {
[13:35:07.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.129]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.129]             }
[13:35:07.129]             base::options(...future.oldOptions)
[13:35:07.129]             if (.Platform$OS.type == "windows") {
[13:35:07.129]                 old_names <- names(...future.oldEnvVars)
[13:35:07.129]                 envs <- base::Sys.getenv()
[13:35:07.129]                 names <- names(envs)
[13:35:07.129]                 common <- intersect(names, old_names)
[13:35:07.129]                 added <- setdiff(names, old_names)
[13:35:07.129]                 removed <- setdiff(old_names, names)
[13:35:07.129]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.129]                   envs[common]]
[13:35:07.129]                 NAMES <- toupper(changed)
[13:35:07.129]                 args <- list()
[13:35:07.129]                 for (kk in seq_along(NAMES)) {
[13:35:07.129]                   name <- changed[[kk]]
[13:35:07.129]                   NAME <- NAMES[[kk]]
[13:35:07.129]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.129]                     next
[13:35:07.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.129]                 }
[13:35:07.129]                 NAMES <- toupper(added)
[13:35:07.129]                 for (kk in seq_along(NAMES)) {
[13:35:07.129]                   name <- added[[kk]]
[13:35:07.129]                   NAME <- NAMES[[kk]]
[13:35:07.129]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.129]                     next
[13:35:07.129]                   args[[name]] <- ""
[13:35:07.129]                 }
[13:35:07.129]                 NAMES <- toupper(removed)
[13:35:07.129]                 for (kk in seq_along(NAMES)) {
[13:35:07.129]                   name <- removed[[kk]]
[13:35:07.129]                   NAME <- NAMES[[kk]]
[13:35:07.129]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.129]                     next
[13:35:07.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.129]                 }
[13:35:07.129]                 if (length(args) > 0) 
[13:35:07.129]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.129]             }
[13:35:07.129]             else {
[13:35:07.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.129]             }
[13:35:07.129]             {
[13:35:07.129]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.129]                   0L) {
[13:35:07.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.129]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.129]                   base::options(opts)
[13:35:07.129]                 }
[13:35:07.129]                 {
[13:35:07.129]                   {
[13:35:07.129]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.129]                     NULL
[13:35:07.129]                   }
[13:35:07.129]                   options(future.plan = NULL)
[13:35:07.129]                   if (is.na(NA_character_)) 
[13:35:07.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.129]                     .init = FALSE)
[13:35:07.129]                 }
[13:35:07.129]             }
[13:35:07.129]         }
[13:35:07.129]     })
[13:35:07.129]     if (TRUE) {
[13:35:07.129]         base::sink(type = "output", split = FALSE)
[13:35:07.129]         if (TRUE) {
[13:35:07.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.129]         }
[13:35:07.129]         else {
[13:35:07.129]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.129]         }
[13:35:07.129]         base::close(...future.stdout)
[13:35:07.129]         ...future.stdout <- NULL
[13:35:07.129]     }
[13:35:07.129]     ...future.result$conditions <- ...future.conditions
[13:35:07.129]     ...future.result$finished <- base::Sys.time()
[13:35:07.129]     ...future.result
[13:35:07.129] }
[13:35:07.131] assign_globals() ...
[13:35:07.131] List of 11
[13:35:07.131]  $ ...future.FUN            :function (x, ...)  
[13:35:07.131]  $ x_FUN                    :function (x)  
[13:35:07.131]  $ times                    : int 2
[13:35:07.131]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.131]  $ stop_if_not              :function (...)  
[13:35:07.131]  $ dim                      : NULL
[13:35:07.131]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:07.131]  $ future.call.arguments    : list()
[13:35:07.131]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.131]  $ ...future.elements_ii    :List of 5
[13:35:07.131]   ..$ : int 6
[13:35:07.131]   ..$ : int 7
[13:35:07.131]   ..$ : int 8
[13:35:07.131]   ..$ : int 9
[13:35:07.131]   ..$ : int 10
[13:35:07.131]  $ ...future.seeds_ii       : NULL
[13:35:07.131]  $ ...future.globals.maxSize: NULL
[13:35:07.131]  - attr(*, "where")=List of 11
[13:35:07.131]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.131]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:07.131]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:07.131]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:07.131]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:07.131]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:07.131]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:07.131]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.131]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.131]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.131]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.131]  - attr(*, "resolved")= logi FALSE
[13:35:07.131]  - attr(*, "total_size")= num 96456
[13:35:07.131]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.131]  - attr(*, "already-done")= logi TRUE
[13:35:07.142] - copied ‘...future.FUN’ to environment
[13:35:07.142] - reassign environment for ‘x_FUN’
[13:35:07.142] - copied ‘x_FUN’ to environment
[13:35:07.142] - copied ‘times’ to environment
[13:35:07.142] - copied ‘stopf’ to environment
[13:35:07.142] - copied ‘stop_if_not’ to environment
[13:35:07.142] - copied ‘dim’ to environment
[13:35:07.143] - copied ‘valid_types’ to environment
[13:35:07.143] - copied ‘future.call.arguments’ to environment
[13:35:07.143] - copied ‘...future.elements_ii’ to environment
[13:35:07.143] - copied ‘...future.seeds_ii’ to environment
[13:35:07.143] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.145] assign_globals() ... done
[13:35:07.145] requestCore(): workers = 2
[13:35:07.147] MulticoreFuture started
[13:35:07.148] - Launch lazy future ... done
[13:35:07.149] run() for ‘MulticoreFuture’ ... done
[13:35:07.149] Created future:
[13:35:07.149] plan(): Setting new future strategy stack:
[13:35:07.150] List of future strategies:
[13:35:07.150] 1. sequential:
[13:35:07.150]    - args: function (..., envir = parent.frame())
[13:35:07.150]    - tweaked: FALSE
[13:35:07.150]    - call: NULL
[13:35:07.151] plan(): nbrOfWorkers() = 1
[13:35:07.154] plan(): Setting new future strategy stack:
[13:35:07.154] List of future strategies:
[13:35:07.154] 1. multicore:
[13:35:07.154]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.154]    - tweaked: FALSE
[13:35:07.154]    - call: plan(strategy)
[13:35:07.161] plan(): nbrOfWorkers() = 2
[13:35:07.149] MulticoreFuture:
[13:35:07.149] Label: ‘future_vapply-2’
[13:35:07.149] Expression:
[13:35:07.149] {
[13:35:07.149]     do.call(function(...) {
[13:35:07.149]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.149]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.149]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.149]             on.exit(options(oopts), add = TRUE)
[13:35:07.149]         }
[13:35:07.149]         {
[13:35:07.149]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.149]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.149]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.149]             })
[13:35:07.149]         }
[13:35:07.149]     }, args = future.call.arguments)
[13:35:07.149] }
[13:35:07.149] Lazy evaluation: FALSE
[13:35:07.149] Asynchronous evaluation: TRUE
[13:35:07.149] Local evaluation: TRUE
[13:35:07.149] Environment: R_GlobalEnv
[13:35:07.149] Capture standard output: TRUE
[13:35:07.149] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.149] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:07.149] Packages: 1 packages (‘future.apply’)
[13:35:07.149] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.149] Resolved: TRUE
[13:35:07.149] Value: <not collected>
[13:35:07.149] Conditions captured: <none>
[13:35:07.149] Early signaling: FALSE
[13:35:07.149] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.149] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.162] Chunk #2 of 2 ... DONE
[13:35:07.162] Launching 2 futures (chunks) ... DONE
[13:35:07.163] Resolving 2 futures (chunks) ...
[13:35:07.163] resolve() on list ...
[13:35:07.163]  recursive: 0
[13:35:07.163]  length: 2
[13:35:07.163] 
[13:35:07.164] Future #1
[13:35:07.164] result() for MulticoreFuture ...
[13:35:07.165] result() for MulticoreFuture ...
[13:35:07.165] result() for MulticoreFuture ... done
[13:35:07.165] result() for MulticoreFuture ... done
[13:35:07.166] result() for MulticoreFuture ...
[13:35:07.166] result() for MulticoreFuture ... done
[13:35:07.166] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:07.166] - nx: 2
[13:35:07.166] - relay: TRUE
[13:35:07.167] - stdout: TRUE
[13:35:07.167] - signal: TRUE
[13:35:07.167] - resignal: FALSE
[13:35:07.167] - force: TRUE
[13:35:07.167] - relayed: [n=2] FALSE, FALSE
[13:35:07.167] - queued futures: [n=2] FALSE, FALSE
[13:35:07.167]  - until=1
[13:35:07.168]  - relaying element #1
[13:35:07.168] result() for MulticoreFuture ...
[13:35:07.168] result() for MulticoreFuture ... done
[13:35:07.168] result() for MulticoreFuture ...
[13:35:07.168] result() for MulticoreFuture ... done
[13:35:07.169] result() for MulticoreFuture ...
[13:35:07.169] result() for MulticoreFuture ... done
[13:35:07.169] result() for MulticoreFuture ...
[13:35:07.169] result() for MulticoreFuture ... done
[13:35:07.169] - relayed: [n=2] TRUE, FALSE
[13:35:07.170] - queued futures: [n=2] TRUE, FALSE
[13:35:07.170] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:07.170]  length: 1 (resolved future 1)
[13:35:07.170] Future #2
[13:35:07.170] result() for MulticoreFuture ...
[13:35:07.171] result() for MulticoreFuture ...
[13:35:07.171] result() for MulticoreFuture ... done
[13:35:07.171] result() for MulticoreFuture ... done
[13:35:07.172] result() for MulticoreFuture ...
[13:35:07.172] result() for MulticoreFuture ... done
[13:35:07.172] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:07.172] - nx: 2
[13:35:07.172] - relay: TRUE
[13:35:07.172] - stdout: TRUE
[13:35:07.172] - signal: TRUE
[13:35:07.172] - resignal: FALSE
[13:35:07.173] - force: TRUE
[13:35:07.173] - relayed: [n=2] TRUE, FALSE
[13:35:07.173] - queued futures: [n=2] TRUE, FALSE
[13:35:07.173]  - until=2
[13:35:07.173]  - relaying element #2
[13:35:07.173] result() for MulticoreFuture ...
[13:35:07.173] result() for MulticoreFuture ... done
[13:35:07.173] result() for MulticoreFuture ...
[13:35:07.173] result() for MulticoreFuture ... done
[13:35:07.174] result() for MulticoreFuture ...
[13:35:07.174] result() for MulticoreFuture ... done
[13:35:07.174] result() for MulticoreFuture ...
[13:35:07.174] result() for MulticoreFuture ... done
[13:35:07.174] - relayed: [n=2] TRUE, TRUE
[13:35:07.174] - queued futures: [n=2] TRUE, TRUE
[13:35:07.174] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:07.174]  length: 0 (resolved future 2)
[13:35:07.175] Relaying remaining futures
[13:35:07.175] signalConditionsASAP(NULL, pos=0) ...
[13:35:07.175] - nx: 2
[13:35:07.175] - relay: TRUE
[13:35:07.175] - stdout: TRUE
[13:35:07.175] - signal: TRUE
[13:35:07.175] - resignal: FALSE
[13:35:07.175] - force: TRUE
[13:35:07.175] - relayed: [n=2] TRUE, TRUE
[13:35:07.175] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:07.176] - relayed: [n=2] TRUE, TRUE
[13:35:07.176] - queued futures: [n=2] TRUE, TRUE
[13:35:07.176] signalConditionsASAP(NULL, pos=0) ... done
[13:35:07.176] resolve() on list ... DONE
[13:35:07.176] result() for MulticoreFuture ...
[13:35:07.176] result() for MulticoreFuture ... done
[13:35:07.176] result() for MulticoreFuture ...
[13:35:07.176] result() for MulticoreFuture ... done
[13:35:07.176] result() for MulticoreFuture ...
[13:35:07.176] result() for MulticoreFuture ... done
[13:35:07.177] result() for MulticoreFuture ...
[13:35:07.177] result() for MulticoreFuture ... done
[13:35:07.177]  - Number of value chunks collected: 2
[13:35:07.177] Resolving 2 futures (chunks) ... DONE
[13:35:07.177] Reducing values from 2 chunks ...
[13:35:07.177]  - Number of values collected after concatenation: 10
[13:35:07.177]  - Number of values expected: 10
[13:35:07.177] Reducing values from 2 chunks ... DONE
[13:35:07.177] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:35:07.179] future_lapply() ...
[13:35:07.185] Number of chunks: 2
[13:35:07.185] getGlobalsAndPackagesXApply() ...
[13:35:07.185]  - future.globals: TRUE
[13:35:07.185] getGlobalsAndPackages() ...
[13:35:07.185] Searching for globals...
[13:35:07.192] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:35:07.192] Searching for globals ... DONE
[13:35:07.192] Resolving globals: FALSE
[13:35:07.193] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[13:35:07.193] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:07.193] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:07.193] - packages: [1] ‘future.apply’
[13:35:07.194] getGlobalsAndPackages() ... DONE
[13:35:07.194]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:07.194]  - needed namespaces: [n=1] ‘future.apply’
[13:35:07.194] Finding globals ... DONE
[13:35:07.194]  - use_args: TRUE
[13:35:07.194]  - Getting '...' globals ...
[13:35:07.194] resolve() on list ...
[13:35:07.195]  recursive: 0
[13:35:07.195]  length: 1
[13:35:07.195]  elements: ‘...’
[13:35:07.195]  length: 0 (resolved future 1)
[13:35:07.195] resolve() on list ... DONE
[13:35:07.195]    - '...' content: [n=0] 
[13:35:07.195] List of 1
[13:35:07.195]  $ ...: list()
[13:35:07.195]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.195]  - attr(*, "where")=List of 1
[13:35:07.195]   ..$ ...:<environment: 0x5574d06ca0b0> 
[13:35:07.195]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.195]  - attr(*, "resolved")= logi TRUE
[13:35:07.195]  - attr(*, "total_size")= num NA
[13:35:07.198]  - Getting '...' globals ... DONE
[13:35:07.198] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:07.198] List of 8
[13:35:07.198]  $ ...future.FUN:function (x, ...)  
[13:35:07.198]  $ x_FUN        :function (x)  
[13:35:07.198]  $ times        : int 4
[13:35:07.198]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.198]  $ stop_if_not  :function (...)  
[13:35:07.198]  $ dim          : int [1:2] 2 2
[13:35:07.198]  $ valid_types  : chr [1:2] "logical" "integer"
[13:35:07.198]  $ ...          : list()
[13:35:07.198]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.198]  - attr(*, "where")=List of 8
[13:35:07.198]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:07.198]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:07.198]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:07.198]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:07.198]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:07.198]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:07.198]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:07.198]   ..$ ...          :<environment: 0x5574d06ca0b0> 
[13:35:07.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.198]  - attr(*, "resolved")= logi FALSE
[13:35:07.198]  - attr(*, "total_size")= num 97232
[13:35:07.203] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:07.204] getGlobalsAndPackagesXApply() ... DONE
[13:35:07.204] Number of futures (= number of chunks): 2
[13:35:07.204] Launching 2 futures (chunks) ...
[13:35:07.204] Chunk #1 of 2 ...
[13:35:07.204]  - Finding globals in 'X' for chunk #1 ...
[13:35:07.204] getGlobalsAndPackages() ...
[13:35:07.204] Searching for globals...
[13:35:07.205] 
[13:35:07.205] Searching for globals ... DONE
[13:35:07.205] - globals: [0] <none>
[13:35:07.205] getGlobalsAndPackages() ... DONE
[13:35:07.205]    + additional globals found: [n=0] 
[13:35:07.205]    + additional namespaces needed: [n=0] 
[13:35:07.205]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:07.205]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.205]  - seeds: <none>
[13:35:07.205]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.206] getGlobalsAndPackages() ...
[13:35:07.206] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.206] Resolving globals: FALSE
[13:35:07.206] Tweak future expression to call with '...' arguments ...
[13:35:07.206] {
[13:35:07.206]     do.call(function(...) {
[13:35:07.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.206]             on.exit(options(oopts), add = TRUE)
[13:35:07.206]         }
[13:35:07.206]         {
[13:35:07.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.206]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.206]             })
[13:35:07.206]         }
[13:35:07.206]     }, args = future.call.arguments)
[13:35:07.206] }
[13:35:07.206] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.209] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.209] - packages: [1] ‘future.apply’
[13:35:07.209] getGlobalsAndPackages() ... DONE
[13:35:07.209] run() for ‘Future’ ...
[13:35:07.209] - state: ‘created’
[13:35:07.210] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.213] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.213] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.213]   - Field: ‘label’
[13:35:07.214]   - Field: ‘local’
[13:35:07.214]   - Field: ‘owner’
[13:35:07.214]   - Field: ‘envir’
[13:35:07.214]   - Field: ‘workers’
[13:35:07.214]   - Field: ‘packages’
[13:35:07.214]   - Field: ‘gc’
[13:35:07.214]   - Field: ‘job’
[13:35:07.214]   - Field: ‘conditions’
[13:35:07.214]   - Field: ‘expr’
[13:35:07.214]   - Field: ‘uuid’
[13:35:07.215]   - Field: ‘seed’
[13:35:07.215]   - Field: ‘version’
[13:35:07.215]   - Field: ‘result’
[13:35:07.215]   - Field: ‘asynchronous’
[13:35:07.215]   - Field: ‘calls’
[13:35:07.215]   - Field: ‘globals’
[13:35:07.215]   - Field: ‘stdout’
[13:35:07.215]   - Field: ‘earlySignal’
[13:35:07.215]   - Field: ‘lazy’
[13:35:07.215]   - Field: ‘state’
[13:35:07.216] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.216] - Launch lazy future ...
[13:35:07.216] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:07.216] Packages needed by future strategies (n = 0): <none>
[13:35:07.217] {
[13:35:07.217]     {
[13:35:07.217]         {
[13:35:07.217]             ...future.startTime <- base::Sys.time()
[13:35:07.217]             {
[13:35:07.217]                 {
[13:35:07.217]                   {
[13:35:07.217]                     {
[13:35:07.217]                       {
[13:35:07.217]                         base::local({
[13:35:07.217]                           has_future <- base::requireNamespace("future", 
[13:35:07.217]                             quietly = TRUE)
[13:35:07.217]                           if (has_future) {
[13:35:07.217]                             ns <- base::getNamespace("future")
[13:35:07.217]                             version <- ns[[".package"]][["version"]]
[13:35:07.217]                             if (is.null(version)) 
[13:35:07.217]                               version <- utils::packageVersion("future")
[13:35:07.217]                           }
[13:35:07.217]                           else {
[13:35:07.217]                             version <- NULL
[13:35:07.217]                           }
[13:35:07.217]                           if (!has_future || version < "1.8.0") {
[13:35:07.217]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.217]                               "", base::R.version$version.string), 
[13:35:07.217]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.217]                                 base::R.version$platform, 8 * 
[13:35:07.217]                                   base::.Machine$sizeof.pointer), 
[13:35:07.217]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.217]                                 "release", "version")], collapse = " "), 
[13:35:07.217]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.217]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.217]                               info)
[13:35:07.217]                             info <- base::paste(info, collapse = "; ")
[13:35:07.217]                             if (!has_future) {
[13:35:07.217]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.217]                                 info)
[13:35:07.217]                             }
[13:35:07.217]                             else {
[13:35:07.217]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.217]                                 info, version)
[13:35:07.217]                             }
[13:35:07.217]                             base::stop(msg)
[13:35:07.217]                           }
[13:35:07.217]                         })
[13:35:07.217]                       }
[13:35:07.217]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.217]                       base::options(mc.cores = 1L)
[13:35:07.217]                     }
[13:35:07.217]                     base::local({
[13:35:07.217]                       for (pkg in "future.apply") {
[13:35:07.217]                         base::loadNamespace(pkg)
[13:35:07.217]                         base::library(pkg, character.only = TRUE)
[13:35:07.217]                       }
[13:35:07.217]                     })
[13:35:07.217]                   }
[13:35:07.217]                   ...future.strategy.old <- future::plan("list")
[13:35:07.217]                   options(future.plan = NULL)
[13:35:07.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.217]                 }
[13:35:07.217]                 ...future.workdir <- getwd()
[13:35:07.217]             }
[13:35:07.217]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.217]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.217]         }
[13:35:07.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.217]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.217]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.217]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.217]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.217]             base::names(...future.oldOptions))
[13:35:07.217]     }
[13:35:07.217]     if (FALSE) {
[13:35:07.217]     }
[13:35:07.217]     else {
[13:35:07.217]         if (TRUE) {
[13:35:07.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.217]                 open = "w")
[13:35:07.217]         }
[13:35:07.217]         else {
[13:35:07.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.217]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.217]         }
[13:35:07.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.217]             base::sink(type = "output", split = FALSE)
[13:35:07.217]             base::close(...future.stdout)
[13:35:07.217]         }, add = TRUE)
[13:35:07.217]     }
[13:35:07.217]     ...future.frame <- base::sys.nframe()
[13:35:07.217]     ...future.conditions <- base::list()
[13:35:07.217]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.217]     if (FALSE) {
[13:35:07.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.217]     }
[13:35:07.217]     ...future.result <- base::tryCatch({
[13:35:07.217]         base::withCallingHandlers({
[13:35:07.217]             ...future.value <- base::withVisible(base::local({
[13:35:07.217]                 withCallingHandlers({
[13:35:07.217]                   {
[13:35:07.217]                     do.call(function(...) {
[13:35:07.217]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.217]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.217]                         ...future.globals.maxSize)) {
[13:35:07.217]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.217]                         on.exit(options(oopts), add = TRUE)
[13:35:07.217]                       }
[13:35:07.217]                       {
[13:35:07.217]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.217]                           FUN = function(jj) {
[13:35:07.217]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.217]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.217]                           })
[13:35:07.217]                       }
[13:35:07.217]                     }, args = future.call.arguments)
[13:35:07.217]                   }
[13:35:07.217]                 }, immediateCondition = function(cond) {
[13:35:07.217]                   save_rds <- function (object, pathname, ...) 
[13:35:07.217]                   {
[13:35:07.217]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.217]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.217]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.217]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.217]                         fi_tmp[["mtime"]])
[13:35:07.217]                     }
[13:35:07.217]                     tryCatch({
[13:35:07.217]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.217]                     }, error = function(ex) {
[13:35:07.217]                       msg <- conditionMessage(ex)
[13:35:07.217]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.217]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.217]                         fi_tmp[["mtime"]], msg)
[13:35:07.217]                       ex$message <- msg
[13:35:07.217]                       stop(ex)
[13:35:07.217]                     })
[13:35:07.217]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.217]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.217]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.217]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.217]                       fi <- file.info(pathname)
[13:35:07.217]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.217]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.217]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.217]                         fi[["size"]], fi[["mtime"]])
[13:35:07.217]                       stop(msg)
[13:35:07.217]                     }
[13:35:07.217]                     invisible(pathname)
[13:35:07.217]                   }
[13:35:07.217]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.217]                     rootPath = tempdir()) 
[13:35:07.217]                   {
[13:35:07.217]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.217]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.217]                       tmpdir = path, fileext = ".rds")
[13:35:07.217]                     save_rds(obj, file)
[13:35:07.217]                   }
[13:35:07.217]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.217]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.217]                   {
[13:35:07.217]                     inherits <- base::inherits
[13:35:07.217]                     invokeRestart <- base::invokeRestart
[13:35:07.217]                     is.null <- base::is.null
[13:35:07.217]                     muffled <- FALSE
[13:35:07.217]                     if (inherits(cond, "message")) {
[13:35:07.217]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.217]                       if (muffled) 
[13:35:07.217]                         invokeRestart("muffleMessage")
[13:35:07.217]                     }
[13:35:07.217]                     else if (inherits(cond, "warning")) {
[13:35:07.217]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.217]                       if (muffled) 
[13:35:07.217]                         invokeRestart("muffleWarning")
[13:35:07.217]                     }
[13:35:07.217]                     else if (inherits(cond, "condition")) {
[13:35:07.217]                       if (!is.null(pattern)) {
[13:35:07.217]                         computeRestarts <- base::computeRestarts
[13:35:07.217]                         grepl <- base::grepl
[13:35:07.217]                         restarts <- computeRestarts(cond)
[13:35:07.217]                         for (restart in restarts) {
[13:35:07.217]                           name <- restart$name
[13:35:07.217]                           if (is.null(name)) 
[13:35:07.217]                             next
[13:35:07.217]                           if (!grepl(pattern, name)) 
[13:35:07.217]                             next
[13:35:07.217]                           invokeRestart(restart)
[13:35:07.217]                           muffled <- TRUE
[13:35:07.217]                           break
[13:35:07.217]                         }
[13:35:07.217]                       }
[13:35:07.217]                     }
[13:35:07.217]                     invisible(muffled)
[13:35:07.217]                   }
[13:35:07.217]                   muffleCondition(cond)
[13:35:07.217]                 })
[13:35:07.217]             }))
[13:35:07.217]             future::FutureResult(value = ...future.value$value, 
[13:35:07.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.217]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.217]                     ...future.globalenv.names))
[13:35:07.217]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.217]         }, condition = base::local({
[13:35:07.217]             c <- base::c
[13:35:07.217]             inherits <- base::inherits
[13:35:07.217]             invokeRestart <- base::invokeRestart
[13:35:07.217]             length <- base::length
[13:35:07.217]             list <- base::list
[13:35:07.217]             seq.int <- base::seq.int
[13:35:07.217]             signalCondition <- base::signalCondition
[13:35:07.217]             sys.calls <- base::sys.calls
[13:35:07.217]             `[[` <- base::`[[`
[13:35:07.217]             `+` <- base::`+`
[13:35:07.217]             `<<-` <- base::`<<-`
[13:35:07.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.217]                   3L)]
[13:35:07.217]             }
[13:35:07.217]             function(cond) {
[13:35:07.217]                 is_error <- inherits(cond, "error")
[13:35:07.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.217]                   NULL)
[13:35:07.217]                 if (is_error) {
[13:35:07.217]                   sessionInformation <- function() {
[13:35:07.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.217]                       search = base::search(), system = base::Sys.info())
[13:35:07.217]                   }
[13:35:07.217]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.217]                     cond$call), session = sessionInformation(), 
[13:35:07.217]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.217]                   signalCondition(cond)
[13:35:07.217]                 }
[13:35:07.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.217]                 "immediateCondition"))) {
[13:35:07.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.217]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.217]                   if (TRUE && !signal) {
[13:35:07.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.217]                     {
[13:35:07.217]                       inherits <- base::inherits
[13:35:07.217]                       invokeRestart <- base::invokeRestart
[13:35:07.217]                       is.null <- base::is.null
[13:35:07.217]                       muffled <- FALSE
[13:35:07.217]                       if (inherits(cond, "message")) {
[13:35:07.217]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.217]                         if (muffled) 
[13:35:07.217]                           invokeRestart("muffleMessage")
[13:35:07.217]                       }
[13:35:07.217]                       else if (inherits(cond, "warning")) {
[13:35:07.217]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.217]                         if (muffled) 
[13:35:07.217]                           invokeRestart("muffleWarning")
[13:35:07.217]                       }
[13:35:07.217]                       else if (inherits(cond, "condition")) {
[13:35:07.217]                         if (!is.null(pattern)) {
[13:35:07.217]                           computeRestarts <- base::computeRestarts
[13:35:07.217]                           grepl <- base::grepl
[13:35:07.217]                           restarts <- computeRestarts(cond)
[13:35:07.217]                           for (restart in restarts) {
[13:35:07.217]                             name <- restart$name
[13:35:07.217]                             if (is.null(name)) 
[13:35:07.217]                               next
[13:35:07.217]                             if (!grepl(pattern, name)) 
[13:35:07.217]                               next
[13:35:07.217]                             invokeRestart(restart)
[13:35:07.217]                             muffled <- TRUE
[13:35:07.217]                             break
[13:35:07.217]                           }
[13:35:07.217]                         }
[13:35:07.217]                       }
[13:35:07.217]                       invisible(muffled)
[13:35:07.217]                     }
[13:35:07.217]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.217]                   }
[13:35:07.217]                 }
[13:35:07.217]                 else {
[13:35:07.217]                   if (TRUE) {
[13:35:07.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.217]                     {
[13:35:07.217]                       inherits <- base::inherits
[13:35:07.217]                       invokeRestart <- base::invokeRestart
[13:35:07.217]                       is.null <- base::is.null
[13:35:07.217]                       muffled <- FALSE
[13:35:07.217]                       if (inherits(cond, "message")) {
[13:35:07.217]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.217]                         if (muffled) 
[13:35:07.217]                           invokeRestart("muffleMessage")
[13:35:07.217]                       }
[13:35:07.217]                       else if (inherits(cond, "warning")) {
[13:35:07.217]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.217]                         if (muffled) 
[13:35:07.217]                           invokeRestart("muffleWarning")
[13:35:07.217]                       }
[13:35:07.217]                       else if (inherits(cond, "condition")) {
[13:35:07.217]                         if (!is.null(pattern)) {
[13:35:07.217]                           computeRestarts <- base::computeRestarts
[13:35:07.217]                           grepl <- base::grepl
[13:35:07.217]                           restarts <- computeRestarts(cond)
[13:35:07.217]                           for (restart in restarts) {
[13:35:07.217]                             name <- restart$name
[13:35:07.217]                             if (is.null(name)) 
[13:35:07.217]                               next
[13:35:07.217]                             if (!grepl(pattern, name)) 
[13:35:07.217]                               next
[13:35:07.217]                             invokeRestart(restart)
[13:35:07.217]                             muffled <- TRUE
[13:35:07.217]                             break
[13:35:07.217]                           }
[13:35:07.217]                         }
[13:35:07.217]                       }
[13:35:07.217]                       invisible(muffled)
[13:35:07.217]                     }
[13:35:07.217]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.217]                   }
[13:35:07.217]                 }
[13:35:07.217]             }
[13:35:07.217]         }))
[13:35:07.217]     }, error = function(ex) {
[13:35:07.217]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.217]                 ...future.rng), started = ...future.startTime, 
[13:35:07.217]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.217]             version = "1.8"), class = "FutureResult")
[13:35:07.217]     }, finally = {
[13:35:07.217]         if (!identical(...future.workdir, getwd())) 
[13:35:07.217]             setwd(...future.workdir)
[13:35:07.217]         {
[13:35:07.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.217]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.217]             }
[13:35:07.217]             base::options(...future.oldOptions)
[13:35:07.217]             if (.Platform$OS.type == "windows") {
[13:35:07.217]                 old_names <- names(...future.oldEnvVars)
[13:35:07.217]                 envs <- base::Sys.getenv()
[13:35:07.217]                 names <- names(envs)
[13:35:07.217]                 common <- intersect(names, old_names)
[13:35:07.217]                 added <- setdiff(names, old_names)
[13:35:07.217]                 removed <- setdiff(old_names, names)
[13:35:07.217]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.217]                   envs[common]]
[13:35:07.217]                 NAMES <- toupper(changed)
[13:35:07.217]                 args <- list()
[13:35:07.217]                 for (kk in seq_along(NAMES)) {
[13:35:07.217]                   name <- changed[[kk]]
[13:35:07.217]                   NAME <- NAMES[[kk]]
[13:35:07.217]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.217]                     next
[13:35:07.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.217]                 }
[13:35:07.217]                 NAMES <- toupper(added)
[13:35:07.217]                 for (kk in seq_along(NAMES)) {
[13:35:07.217]                   name <- added[[kk]]
[13:35:07.217]                   NAME <- NAMES[[kk]]
[13:35:07.217]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.217]                     next
[13:35:07.217]                   args[[name]] <- ""
[13:35:07.217]                 }
[13:35:07.217]                 NAMES <- toupper(removed)
[13:35:07.217]                 for (kk in seq_along(NAMES)) {
[13:35:07.217]                   name <- removed[[kk]]
[13:35:07.217]                   NAME <- NAMES[[kk]]
[13:35:07.217]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.217]                     next
[13:35:07.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.217]                 }
[13:35:07.217]                 if (length(args) > 0) 
[13:35:07.217]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.217]             }
[13:35:07.217]             else {
[13:35:07.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.217]             }
[13:35:07.217]             {
[13:35:07.217]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.217]                   0L) {
[13:35:07.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.217]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.217]                   base::options(opts)
[13:35:07.217]                 }
[13:35:07.217]                 {
[13:35:07.217]                   {
[13:35:07.217]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.217]                     NULL
[13:35:07.217]                   }
[13:35:07.217]                   options(future.plan = NULL)
[13:35:07.217]                   if (is.na(NA_character_)) 
[13:35:07.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.217]                     .init = FALSE)
[13:35:07.217]                 }
[13:35:07.217]             }
[13:35:07.217]         }
[13:35:07.217]     })
[13:35:07.217]     if (TRUE) {
[13:35:07.217]         base::sink(type = "output", split = FALSE)
[13:35:07.217]         if (TRUE) {
[13:35:07.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.217]         }
[13:35:07.217]         else {
[13:35:07.217]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.217]         }
[13:35:07.217]         base::close(...future.stdout)
[13:35:07.217]         ...future.stdout <- NULL
[13:35:07.217]     }
[13:35:07.217]     ...future.result$conditions <- ...future.conditions
[13:35:07.217]     ...future.result$finished <- base::Sys.time()
[13:35:07.217]     ...future.result
[13:35:07.217] }
[13:35:07.219] assign_globals() ...
[13:35:07.219] List of 11
[13:35:07.219]  $ ...future.FUN            :function (x, ...)  
[13:35:07.219]  $ x_FUN                    :function (x)  
[13:35:07.219]  $ times                    : int 4
[13:35:07.219]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.219]  $ stop_if_not              :function (...)  
[13:35:07.219]  $ dim                      : int [1:2] 2 2
[13:35:07.219]  $ valid_types              : chr [1:2] "logical" "integer"
[13:35:07.219]  $ future.call.arguments    : list()
[13:35:07.219]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.219]  $ ...future.elements_ii    :List of 5
[13:35:07.219]   ..$ : int 1
[13:35:07.219]   ..$ : int 2
[13:35:07.219]   ..$ : int 3
[13:35:07.219]   ..$ : int 4
[13:35:07.219]   ..$ : int 5
[13:35:07.219]  $ ...future.seeds_ii       : NULL
[13:35:07.219]  $ ...future.globals.maxSize: NULL
[13:35:07.219]  - attr(*, "where")=List of 11
[13:35:07.219]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.219]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:07.219]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:07.219]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:07.219]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:07.219]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:07.219]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:07.219]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.219]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.219]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.219]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.219]  - attr(*, "resolved")= logi FALSE
[13:35:07.219]  - attr(*, "total_size")= num 97232
[13:35:07.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.219]  - attr(*, "already-done")= logi TRUE
[13:35:07.227] - copied ‘...future.FUN’ to environment
[13:35:07.227] - reassign environment for ‘x_FUN’
[13:35:07.228] - copied ‘x_FUN’ to environment
[13:35:07.228] - copied ‘times’ to environment
[13:35:07.228] - copied ‘stopf’ to environment
[13:35:07.228] - copied ‘stop_if_not’ to environment
[13:35:07.228] - copied ‘dim’ to environment
[13:35:07.228] - copied ‘valid_types’ to environment
[13:35:07.228] - copied ‘future.call.arguments’ to environment
[13:35:07.228] - copied ‘...future.elements_ii’ to environment
[13:35:07.228] - copied ‘...future.seeds_ii’ to environment
[13:35:07.228] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.229] assign_globals() ... done
[13:35:07.229] requestCore(): workers = 2
[13:35:07.231] MulticoreFuture started
[13:35:07.231] - Launch lazy future ... done
[13:35:07.231] run() for ‘MulticoreFuture’ ... done
[13:35:07.231] Created future:
[13:35:07.232] plan(): Setting new future strategy stack:
[13:35:07.232] List of future strategies:
[13:35:07.232] 1. sequential:
[13:35:07.232]    - args: function (..., envir = parent.frame())
[13:35:07.232]    - tweaked: FALSE
[13:35:07.232]    - call: NULL
[13:35:07.243] plan(): nbrOfWorkers() = 1
[13:35:07.245] plan(): Setting new future strategy stack:
[13:35:07.245] List of future strategies:
[13:35:07.245] 1. multicore:
[13:35:07.245]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.245]    - tweaked: FALSE
[13:35:07.245]    - call: plan(strategy)
[13:35:07.250] plan(): nbrOfWorkers() = 2
[13:35:07.232] MulticoreFuture:
[13:35:07.232] Label: ‘future_vapply-1’
[13:35:07.232] Expression:
[13:35:07.232] {
[13:35:07.232]     do.call(function(...) {
[13:35:07.232]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.232]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.232]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.232]             on.exit(options(oopts), add = TRUE)
[13:35:07.232]         }
[13:35:07.232]         {
[13:35:07.232]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.232]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.232]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.232]             })
[13:35:07.232]         }
[13:35:07.232]     }, args = future.call.arguments)
[13:35:07.232] }
[13:35:07.232] Lazy evaluation: FALSE
[13:35:07.232] Asynchronous evaluation: TRUE
[13:35:07.232] Local evaluation: TRUE
[13:35:07.232] Environment: R_GlobalEnv
[13:35:07.232] Capture standard output: TRUE
[13:35:07.232] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.232] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:07.232] Packages: 1 packages (‘future.apply’)
[13:35:07.232] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.232] Resolved: TRUE
[13:35:07.232] Value: <not collected>
[13:35:07.232] Conditions captured: <none>
[13:35:07.232] Early signaling: FALSE
[13:35:07.232] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.232] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.251] Chunk #1 of 2 ... DONE
[13:35:07.251] Chunk #2 of 2 ...
[13:35:07.252]  - Finding globals in 'X' for chunk #2 ...
[13:35:07.252] getGlobalsAndPackages() ...
[13:35:07.252] Searching for globals...
[13:35:07.252] 
[13:35:07.253] Searching for globals ... DONE
[13:35:07.253] - globals: [0] <none>
[13:35:07.253] getGlobalsAndPackages() ... DONE
[13:35:07.253]    + additional globals found: [n=0] 
[13:35:07.253]    + additional namespaces needed: [n=0] 
[13:35:07.253]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:07.253]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.254]  - seeds: <none>
[13:35:07.254]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.254] getGlobalsAndPackages() ...
[13:35:07.254] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.255] Resolving globals: FALSE
[13:35:07.255] Tweak future expression to call with '...' arguments ...
[13:35:07.255] {
[13:35:07.255]     do.call(function(...) {
[13:35:07.255]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.255]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.255]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.255]             on.exit(options(oopts), add = TRUE)
[13:35:07.255]         }
[13:35:07.255]         {
[13:35:07.255]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.255]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.255]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.255]             })
[13:35:07.255]         }
[13:35:07.255]     }, args = future.call.arguments)
[13:35:07.255] }
[13:35:07.256] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.257] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.257] - packages: [1] ‘future.apply’
[13:35:07.257] getGlobalsAndPackages() ... DONE
[13:35:07.258] run() for ‘Future’ ...
[13:35:07.258] - state: ‘created’
[13:35:07.258] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.263] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.263] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.263]   - Field: ‘label’
[13:35:07.263]   - Field: ‘local’
[13:35:07.263]   - Field: ‘owner’
[13:35:07.264]   - Field: ‘envir’
[13:35:07.264]   - Field: ‘workers’
[13:35:07.264]   - Field: ‘packages’
[13:35:07.264]   - Field: ‘gc’
[13:35:07.264]   - Field: ‘job’
[13:35:07.265]   - Field: ‘conditions’
[13:35:07.265]   - Field: ‘expr’
[13:35:07.265]   - Field: ‘uuid’
[13:35:07.265]   - Field: ‘seed’
[13:35:07.265]   - Field: ‘version’
[13:35:07.265]   - Field: ‘result’
[13:35:07.265]   - Field: ‘asynchronous’
[13:35:07.266]   - Field: ‘calls’
[13:35:07.266]   - Field: ‘globals’
[13:35:07.266]   - Field: ‘stdout’
[13:35:07.266]   - Field: ‘earlySignal’
[13:35:07.266]   - Field: ‘lazy’
[13:35:07.266]   - Field: ‘state’
[13:35:07.266] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.267] - Launch lazy future ...
[13:35:07.267] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:07.267] Packages needed by future strategies (n = 0): <none>
[13:35:07.268] {
[13:35:07.268]     {
[13:35:07.268]         {
[13:35:07.268]             ...future.startTime <- base::Sys.time()
[13:35:07.268]             {
[13:35:07.268]                 {
[13:35:07.268]                   {
[13:35:07.268]                     {
[13:35:07.268]                       {
[13:35:07.268]                         base::local({
[13:35:07.268]                           has_future <- base::requireNamespace("future", 
[13:35:07.268]                             quietly = TRUE)
[13:35:07.268]                           if (has_future) {
[13:35:07.268]                             ns <- base::getNamespace("future")
[13:35:07.268]                             version <- ns[[".package"]][["version"]]
[13:35:07.268]                             if (is.null(version)) 
[13:35:07.268]                               version <- utils::packageVersion("future")
[13:35:07.268]                           }
[13:35:07.268]                           else {
[13:35:07.268]                             version <- NULL
[13:35:07.268]                           }
[13:35:07.268]                           if (!has_future || version < "1.8.0") {
[13:35:07.268]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.268]                               "", base::R.version$version.string), 
[13:35:07.268]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.268]                                 base::R.version$platform, 8 * 
[13:35:07.268]                                   base::.Machine$sizeof.pointer), 
[13:35:07.268]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.268]                                 "release", "version")], collapse = " "), 
[13:35:07.268]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.268]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.268]                               info)
[13:35:07.268]                             info <- base::paste(info, collapse = "; ")
[13:35:07.268]                             if (!has_future) {
[13:35:07.268]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.268]                                 info)
[13:35:07.268]                             }
[13:35:07.268]                             else {
[13:35:07.268]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.268]                                 info, version)
[13:35:07.268]                             }
[13:35:07.268]                             base::stop(msg)
[13:35:07.268]                           }
[13:35:07.268]                         })
[13:35:07.268]                       }
[13:35:07.268]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.268]                       base::options(mc.cores = 1L)
[13:35:07.268]                     }
[13:35:07.268]                     base::local({
[13:35:07.268]                       for (pkg in "future.apply") {
[13:35:07.268]                         base::loadNamespace(pkg)
[13:35:07.268]                         base::library(pkg, character.only = TRUE)
[13:35:07.268]                       }
[13:35:07.268]                     })
[13:35:07.268]                   }
[13:35:07.268]                   ...future.strategy.old <- future::plan("list")
[13:35:07.268]                   options(future.plan = NULL)
[13:35:07.268]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.268]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.268]                 }
[13:35:07.268]                 ...future.workdir <- getwd()
[13:35:07.268]             }
[13:35:07.268]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.268]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.268]         }
[13:35:07.268]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.268]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.268]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.268]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.268]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.268]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.268]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.268]             base::names(...future.oldOptions))
[13:35:07.268]     }
[13:35:07.268]     if (FALSE) {
[13:35:07.268]     }
[13:35:07.268]     else {
[13:35:07.268]         if (TRUE) {
[13:35:07.268]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.268]                 open = "w")
[13:35:07.268]         }
[13:35:07.268]         else {
[13:35:07.268]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.268]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.268]         }
[13:35:07.268]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.268]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.268]             base::sink(type = "output", split = FALSE)
[13:35:07.268]             base::close(...future.stdout)
[13:35:07.268]         }, add = TRUE)
[13:35:07.268]     }
[13:35:07.268]     ...future.frame <- base::sys.nframe()
[13:35:07.268]     ...future.conditions <- base::list()
[13:35:07.268]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.268]     if (FALSE) {
[13:35:07.268]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.268]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.268]     }
[13:35:07.268]     ...future.result <- base::tryCatch({
[13:35:07.268]         base::withCallingHandlers({
[13:35:07.268]             ...future.value <- base::withVisible(base::local({
[13:35:07.268]                 withCallingHandlers({
[13:35:07.268]                   {
[13:35:07.268]                     do.call(function(...) {
[13:35:07.268]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.268]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.268]                         ...future.globals.maxSize)) {
[13:35:07.268]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.268]                         on.exit(options(oopts), add = TRUE)
[13:35:07.268]                       }
[13:35:07.268]                       {
[13:35:07.268]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.268]                           FUN = function(jj) {
[13:35:07.268]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.268]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.268]                           })
[13:35:07.268]                       }
[13:35:07.268]                     }, args = future.call.arguments)
[13:35:07.268]                   }
[13:35:07.268]                 }, immediateCondition = function(cond) {
[13:35:07.268]                   save_rds <- function (object, pathname, ...) 
[13:35:07.268]                   {
[13:35:07.268]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.268]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.268]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.268]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.268]                         fi_tmp[["mtime"]])
[13:35:07.268]                     }
[13:35:07.268]                     tryCatch({
[13:35:07.268]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.268]                     }, error = function(ex) {
[13:35:07.268]                       msg <- conditionMessage(ex)
[13:35:07.268]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.268]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.268]                         fi_tmp[["mtime"]], msg)
[13:35:07.268]                       ex$message <- msg
[13:35:07.268]                       stop(ex)
[13:35:07.268]                     })
[13:35:07.268]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.268]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.268]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.268]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.268]                       fi <- file.info(pathname)
[13:35:07.268]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.268]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.268]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.268]                         fi[["size"]], fi[["mtime"]])
[13:35:07.268]                       stop(msg)
[13:35:07.268]                     }
[13:35:07.268]                     invisible(pathname)
[13:35:07.268]                   }
[13:35:07.268]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.268]                     rootPath = tempdir()) 
[13:35:07.268]                   {
[13:35:07.268]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.268]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.268]                       tmpdir = path, fileext = ".rds")
[13:35:07.268]                     save_rds(obj, file)
[13:35:07.268]                   }
[13:35:07.268]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.268]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.268]                   {
[13:35:07.268]                     inherits <- base::inherits
[13:35:07.268]                     invokeRestart <- base::invokeRestart
[13:35:07.268]                     is.null <- base::is.null
[13:35:07.268]                     muffled <- FALSE
[13:35:07.268]                     if (inherits(cond, "message")) {
[13:35:07.268]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.268]                       if (muffled) 
[13:35:07.268]                         invokeRestart("muffleMessage")
[13:35:07.268]                     }
[13:35:07.268]                     else if (inherits(cond, "warning")) {
[13:35:07.268]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.268]                       if (muffled) 
[13:35:07.268]                         invokeRestart("muffleWarning")
[13:35:07.268]                     }
[13:35:07.268]                     else if (inherits(cond, "condition")) {
[13:35:07.268]                       if (!is.null(pattern)) {
[13:35:07.268]                         computeRestarts <- base::computeRestarts
[13:35:07.268]                         grepl <- base::grepl
[13:35:07.268]                         restarts <- computeRestarts(cond)
[13:35:07.268]                         for (restart in restarts) {
[13:35:07.268]                           name <- restart$name
[13:35:07.268]                           if (is.null(name)) 
[13:35:07.268]                             next
[13:35:07.268]                           if (!grepl(pattern, name)) 
[13:35:07.268]                             next
[13:35:07.268]                           invokeRestart(restart)
[13:35:07.268]                           muffled <- TRUE
[13:35:07.268]                           break
[13:35:07.268]                         }
[13:35:07.268]                       }
[13:35:07.268]                     }
[13:35:07.268]                     invisible(muffled)
[13:35:07.268]                   }
[13:35:07.268]                   muffleCondition(cond)
[13:35:07.268]                 })
[13:35:07.268]             }))
[13:35:07.268]             future::FutureResult(value = ...future.value$value, 
[13:35:07.268]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.268]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.268]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.268]                     ...future.globalenv.names))
[13:35:07.268]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.268]         }, condition = base::local({
[13:35:07.268]             c <- base::c
[13:35:07.268]             inherits <- base::inherits
[13:35:07.268]             invokeRestart <- base::invokeRestart
[13:35:07.268]             length <- base::length
[13:35:07.268]             list <- base::list
[13:35:07.268]             seq.int <- base::seq.int
[13:35:07.268]             signalCondition <- base::signalCondition
[13:35:07.268]             sys.calls <- base::sys.calls
[13:35:07.268]             `[[` <- base::`[[`
[13:35:07.268]             `+` <- base::`+`
[13:35:07.268]             `<<-` <- base::`<<-`
[13:35:07.268]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.268]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.268]                   3L)]
[13:35:07.268]             }
[13:35:07.268]             function(cond) {
[13:35:07.268]                 is_error <- inherits(cond, "error")
[13:35:07.268]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.268]                   NULL)
[13:35:07.268]                 if (is_error) {
[13:35:07.268]                   sessionInformation <- function() {
[13:35:07.268]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.268]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.268]                       search = base::search(), system = base::Sys.info())
[13:35:07.268]                   }
[13:35:07.268]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.268]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.268]                     cond$call), session = sessionInformation(), 
[13:35:07.268]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.268]                   signalCondition(cond)
[13:35:07.268]                 }
[13:35:07.268]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.268]                 "immediateCondition"))) {
[13:35:07.268]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.268]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.268]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.268]                   if (TRUE && !signal) {
[13:35:07.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.268]                     {
[13:35:07.268]                       inherits <- base::inherits
[13:35:07.268]                       invokeRestart <- base::invokeRestart
[13:35:07.268]                       is.null <- base::is.null
[13:35:07.268]                       muffled <- FALSE
[13:35:07.268]                       if (inherits(cond, "message")) {
[13:35:07.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.268]                         if (muffled) 
[13:35:07.268]                           invokeRestart("muffleMessage")
[13:35:07.268]                       }
[13:35:07.268]                       else if (inherits(cond, "warning")) {
[13:35:07.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.268]                         if (muffled) 
[13:35:07.268]                           invokeRestart("muffleWarning")
[13:35:07.268]                       }
[13:35:07.268]                       else if (inherits(cond, "condition")) {
[13:35:07.268]                         if (!is.null(pattern)) {
[13:35:07.268]                           computeRestarts <- base::computeRestarts
[13:35:07.268]                           grepl <- base::grepl
[13:35:07.268]                           restarts <- computeRestarts(cond)
[13:35:07.268]                           for (restart in restarts) {
[13:35:07.268]                             name <- restart$name
[13:35:07.268]                             if (is.null(name)) 
[13:35:07.268]                               next
[13:35:07.268]                             if (!grepl(pattern, name)) 
[13:35:07.268]                               next
[13:35:07.268]                             invokeRestart(restart)
[13:35:07.268]                             muffled <- TRUE
[13:35:07.268]                             break
[13:35:07.268]                           }
[13:35:07.268]                         }
[13:35:07.268]                       }
[13:35:07.268]                       invisible(muffled)
[13:35:07.268]                     }
[13:35:07.268]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.268]                   }
[13:35:07.268]                 }
[13:35:07.268]                 else {
[13:35:07.268]                   if (TRUE) {
[13:35:07.268]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.268]                     {
[13:35:07.268]                       inherits <- base::inherits
[13:35:07.268]                       invokeRestart <- base::invokeRestart
[13:35:07.268]                       is.null <- base::is.null
[13:35:07.268]                       muffled <- FALSE
[13:35:07.268]                       if (inherits(cond, "message")) {
[13:35:07.268]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.268]                         if (muffled) 
[13:35:07.268]                           invokeRestart("muffleMessage")
[13:35:07.268]                       }
[13:35:07.268]                       else if (inherits(cond, "warning")) {
[13:35:07.268]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.268]                         if (muffled) 
[13:35:07.268]                           invokeRestart("muffleWarning")
[13:35:07.268]                       }
[13:35:07.268]                       else if (inherits(cond, "condition")) {
[13:35:07.268]                         if (!is.null(pattern)) {
[13:35:07.268]                           computeRestarts <- base::computeRestarts
[13:35:07.268]                           grepl <- base::grepl
[13:35:07.268]                           restarts <- computeRestarts(cond)
[13:35:07.268]                           for (restart in restarts) {
[13:35:07.268]                             name <- restart$name
[13:35:07.268]                             if (is.null(name)) 
[13:35:07.268]                               next
[13:35:07.268]                             if (!grepl(pattern, name)) 
[13:35:07.268]                               next
[13:35:07.268]                             invokeRestart(restart)
[13:35:07.268]                             muffled <- TRUE
[13:35:07.268]                             break
[13:35:07.268]                           }
[13:35:07.268]                         }
[13:35:07.268]                       }
[13:35:07.268]                       invisible(muffled)
[13:35:07.268]                     }
[13:35:07.268]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.268]                   }
[13:35:07.268]                 }
[13:35:07.268]             }
[13:35:07.268]         }))
[13:35:07.268]     }, error = function(ex) {
[13:35:07.268]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.268]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.268]                 ...future.rng), started = ...future.startTime, 
[13:35:07.268]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.268]             version = "1.8"), class = "FutureResult")
[13:35:07.268]     }, finally = {
[13:35:07.268]         if (!identical(...future.workdir, getwd())) 
[13:35:07.268]             setwd(...future.workdir)
[13:35:07.268]         {
[13:35:07.268]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.268]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.268]             }
[13:35:07.268]             base::options(...future.oldOptions)
[13:35:07.268]             if (.Platform$OS.type == "windows") {
[13:35:07.268]                 old_names <- names(...future.oldEnvVars)
[13:35:07.268]                 envs <- base::Sys.getenv()
[13:35:07.268]                 names <- names(envs)
[13:35:07.268]                 common <- intersect(names, old_names)
[13:35:07.268]                 added <- setdiff(names, old_names)
[13:35:07.268]                 removed <- setdiff(old_names, names)
[13:35:07.268]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.268]                   envs[common]]
[13:35:07.268]                 NAMES <- toupper(changed)
[13:35:07.268]                 args <- list()
[13:35:07.268]                 for (kk in seq_along(NAMES)) {
[13:35:07.268]                   name <- changed[[kk]]
[13:35:07.268]                   NAME <- NAMES[[kk]]
[13:35:07.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.268]                     next
[13:35:07.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.268]                 }
[13:35:07.268]                 NAMES <- toupper(added)
[13:35:07.268]                 for (kk in seq_along(NAMES)) {
[13:35:07.268]                   name <- added[[kk]]
[13:35:07.268]                   NAME <- NAMES[[kk]]
[13:35:07.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.268]                     next
[13:35:07.268]                   args[[name]] <- ""
[13:35:07.268]                 }
[13:35:07.268]                 NAMES <- toupper(removed)
[13:35:07.268]                 for (kk in seq_along(NAMES)) {
[13:35:07.268]                   name <- removed[[kk]]
[13:35:07.268]                   NAME <- NAMES[[kk]]
[13:35:07.268]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.268]                     next
[13:35:07.268]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.268]                 }
[13:35:07.268]                 if (length(args) > 0) 
[13:35:07.268]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.268]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.268]             }
[13:35:07.268]             else {
[13:35:07.268]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.268]             }
[13:35:07.268]             {
[13:35:07.268]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.268]                   0L) {
[13:35:07.268]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.268]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.268]                   base::options(opts)
[13:35:07.268]                 }
[13:35:07.268]                 {
[13:35:07.268]                   {
[13:35:07.268]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.268]                     NULL
[13:35:07.268]                   }
[13:35:07.268]                   options(future.plan = NULL)
[13:35:07.268]                   if (is.na(NA_character_)) 
[13:35:07.268]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.268]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.268]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.268]                     .init = FALSE)
[13:35:07.268]                 }
[13:35:07.268]             }
[13:35:07.268]         }
[13:35:07.268]     })
[13:35:07.268]     if (TRUE) {
[13:35:07.268]         base::sink(type = "output", split = FALSE)
[13:35:07.268]         if (TRUE) {
[13:35:07.268]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.268]         }
[13:35:07.268]         else {
[13:35:07.268]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.268]         }
[13:35:07.268]         base::close(...future.stdout)
[13:35:07.268]         ...future.stdout <- NULL
[13:35:07.268]     }
[13:35:07.268]     ...future.result$conditions <- ...future.conditions
[13:35:07.268]     ...future.result$finished <- base::Sys.time()
[13:35:07.268]     ...future.result
[13:35:07.268] }
[13:35:07.270] assign_globals() ...
[13:35:07.270] List of 11
[13:35:07.270]  $ ...future.FUN            :function (x, ...)  
[13:35:07.270]  $ x_FUN                    :function (x)  
[13:35:07.270]  $ times                    : int 4
[13:35:07.270]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.270]  $ stop_if_not              :function (...)  
[13:35:07.270]  $ dim                      : int [1:2] 2 2
[13:35:07.270]  $ valid_types              : chr [1:2] "logical" "integer"
[13:35:07.270]  $ future.call.arguments    : list()
[13:35:07.270]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.270]  $ ...future.elements_ii    :List of 5
[13:35:07.270]   ..$ : int 6
[13:35:07.270]   ..$ : int 7
[13:35:07.270]   ..$ : int 8
[13:35:07.270]   ..$ : int 9
[13:35:07.270]   ..$ : int 10
[13:35:07.270]  $ ...future.seeds_ii       : NULL
[13:35:07.270]  $ ...future.globals.maxSize: NULL
[13:35:07.270]  - attr(*, "where")=List of 11
[13:35:07.270]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.270]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:07.270]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:07.270]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:07.270]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:07.270]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:07.270]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:07.270]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.270]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.270]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.270]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.270]  - attr(*, "resolved")= logi FALSE
[13:35:07.270]  - attr(*, "total_size")= num 97232
[13:35:07.270]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.270]  - attr(*, "already-done")= logi TRUE
[13:35:07.280] - copied ‘...future.FUN’ to environment
[13:35:07.280] - reassign environment for ‘x_FUN’
[13:35:07.281] - copied ‘x_FUN’ to environment
[13:35:07.281] - copied ‘times’ to environment
[13:35:07.282] - copied ‘stopf’ to environment
[13:35:07.283] - copied ‘stop_if_not’ to environment
[13:35:07.283] - copied ‘dim’ to environment
[13:35:07.283] - copied ‘valid_types’ to environment
[13:35:07.283] - copied ‘future.call.arguments’ to environment
[13:35:07.283] - copied ‘...future.elements_ii’ to environment
[13:35:07.283] - copied ‘...future.seeds_ii’ to environment
[13:35:07.283] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.283] assign_globals() ... done
[13:35:07.284] requestCore(): workers = 2
[13:35:07.286] MulticoreFuture started
[13:35:07.287] - Launch lazy future ... done
[13:35:07.288] run() for ‘MulticoreFuture’ ... done
[13:35:07.288] Created future:
[13:35:07.288] plan(): Setting new future strategy stack:
[13:35:07.289] List of future strategies:
[13:35:07.289] 1. sequential:
[13:35:07.289]    - args: function (..., envir = parent.frame())
[13:35:07.289]    - tweaked: FALSE
[13:35:07.289]    - call: NULL
[13:35:07.290] plan(): nbrOfWorkers() = 1
[13:35:07.293] plan(): Setting new future strategy stack:
[13:35:07.293] List of future strategies:
[13:35:07.293] 1. multicore:
[13:35:07.293]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.293]    - tweaked: FALSE
[13:35:07.293]    - call: plan(strategy)
[13:35:07.301] plan(): nbrOfWorkers() = 2
[13:35:07.288] MulticoreFuture:
[13:35:07.288] Label: ‘future_vapply-2’
[13:35:07.288] Expression:
[13:35:07.288] {
[13:35:07.288]     do.call(function(...) {
[13:35:07.288]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.288]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.288]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.288]             on.exit(options(oopts), add = TRUE)
[13:35:07.288]         }
[13:35:07.288]         {
[13:35:07.288]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.288]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.288]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.288]             })
[13:35:07.288]         }
[13:35:07.288]     }, args = future.call.arguments)
[13:35:07.288] }
[13:35:07.288] Lazy evaluation: FALSE
[13:35:07.288] Asynchronous evaluation: TRUE
[13:35:07.288] Local evaluation: TRUE
[13:35:07.288] Environment: R_GlobalEnv
[13:35:07.288] Capture standard output: TRUE
[13:35:07.288] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.288] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:07.288] Packages: 1 packages (‘future.apply’)
[13:35:07.288] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.288] Resolved: TRUE
[13:35:07.288] Value: <not collected>
[13:35:07.288] Conditions captured: <none>
[13:35:07.288] Early signaling: FALSE
[13:35:07.288] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.288] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.302] Chunk #2 of 2 ... DONE
[13:35:07.302] Launching 2 futures (chunks) ... DONE
[13:35:07.303] Resolving 2 futures (chunks) ...
[13:35:07.303] resolve() on list ...
[13:35:07.303]  recursive: 0
[13:35:07.303]  length: 2
[13:35:07.303] 
[13:35:07.304] Future #1
[13:35:07.304] result() for MulticoreFuture ...
[13:35:07.305] result() for MulticoreFuture ...
[13:35:07.305] result() for MulticoreFuture ... done
[13:35:07.305] result() for MulticoreFuture ... done
[13:35:07.306] result() for MulticoreFuture ...
[13:35:07.306] result() for MulticoreFuture ... done
[13:35:07.306] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:07.306] - nx: 2
[13:35:07.307] - relay: TRUE
[13:35:07.307] - stdout: TRUE
[13:35:07.307] - signal: TRUE
[13:35:07.307] - resignal: FALSE
[13:35:07.308] - force: TRUE
[13:35:07.308] - relayed: [n=2] FALSE, FALSE
[13:35:07.308] - queued futures: [n=2] FALSE, FALSE
[13:35:07.308]  - until=1
[13:35:07.308]  - relaying element #1
[13:35:07.308] result() for MulticoreFuture ...
[13:35:07.309] result() for MulticoreFuture ... done
[13:35:07.309] result() for MulticoreFuture ...
[13:35:07.309] result() for MulticoreFuture ... done
[13:35:07.309] result() for MulticoreFuture ...
[13:35:07.309] result() for MulticoreFuture ... done
[13:35:07.309] result() for MulticoreFuture ...
[13:35:07.310] result() for MulticoreFuture ... done
[13:35:07.310] - relayed: [n=2] TRUE, FALSE
[13:35:07.310] - queued futures: [n=2] TRUE, FALSE
[13:35:07.310] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:07.311]  length: 1 (resolved future 1)
[13:35:07.311] Future #2
[13:35:07.311] result() for MulticoreFuture ...
[13:35:07.312] result() for MulticoreFuture ...
[13:35:07.312] result() for MulticoreFuture ... done
[13:35:07.312] result() for MulticoreFuture ... done
[13:35:07.312] result() for MulticoreFuture ...
[13:35:07.313] result() for MulticoreFuture ... done
[13:35:07.313] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:07.313] - nx: 2
[13:35:07.313] - relay: TRUE
[13:35:07.313] - stdout: TRUE
[13:35:07.313] - signal: TRUE
[13:35:07.313] - resignal: FALSE
[13:35:07.313] - force: TRUE
[13:35:07.313] - relayed: [n=2] TRUE, FALSE
[13:35:07.314] - queued futures: [n=2] TRUE, FALSE
[13:35:07.314]  - until=2
[13:35:07.314]  - relaying element #2
[13:35:07.314] result() for MulticoreFuture ...
[13:35:07.314] result() for MulticoreFuture ... done
[13:35:07.314] result() for MulticoreFuture ...
[13:35:07.314] result() for MulticoreFuture ... done
[13:35:07.314] result() for MulticoreFuture ...
[13:35:07.315] result() for MulticoreFuture ... done
[13:35:07.315] result() for MulticoreFuture ...
[13:35:07.315] result() for MulticoreFuture ... done
[13:35:07.315] - relayed: [n=2] TRUE, TRUE
[13:35:07.315] - queued futures: [n=2] TRUE, TRUE
[13:35:07.315] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:07.315]  length: 0 (resolved future 2)
[13:35:07.315] Relaying remaining futures
[13:35:07.315] signalConditionsASAP(NULL, pos=0) ...
[13:35:07.316] - nx: 2
[13:35:07.316] - relay: TRUE
[13:35:07.316] - stdout: TRUE
[13:35:07.316] - signal: TRUE
[13:35:07.316] - resignal: FALSE
[13:35:07.316] - force: TRUE
[13:35:07.316] - relayed: [n=2] TRUE, TRUE
[13:35:07.316] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:07.316] - relayed: [n=2] TRUE, TRUE
[13:35:07.317] - queued futures: [n=2] TRUE, TRUE
[13:35:07.317] signalConditionsASAP(NULL, pos=0) ... done
[13:35:07.317] resolve() on list ... DONE
[13:35:07.317] result() for MulticoreFuture ...
[13:35:07.317] result() for MulticoreFuture ... done
[13:35:07.317] result() for MulticoreFuture ...
[13:35:07.317] result() for MulticoreFuture ... done
[13:35:07.317] result() for MulticoreFuture ...
[13:35:07.317] result() for MulticoreFuture ... done
[13:35:07.317] result() for MulticoreFuture ...
[13:35:07.318] result() for MulticoreFuture ... done
[13:35:07.318]  - Number of value chunks collected: 2
[13:35:07.318] Resolving 2 futures (chunks) ... DONE
[13:35:07.318] Reducing values from 2 chunks ...
[13:35:07.318]  - Number of values collected after concatenation: 10
[13:35:07.318]  - Number of values expected: 10
[13:35:07.318] Reducing values from 2 chunks ... DONE
[13:35:07.318] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:35:07.320] future_lapply() ...
[13:35:07.326] Number of chunks: 2
[13:35:07.326] getGlobalsAndPackagesXApply() ...
[13:35:07.326]  - future.globals: TRUE
[13:35:07.326] getGlobalsAndPackages() ...
[13:35:07.326] Searching for globals...
[13:35:07.333] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:35:07.333] Searching for globals ... DONE
[13:35:07.333] Resolving globals: FALSE
[13:35:07.334] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[13:35:07.335] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:07.335] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:07.335] - packages: [1] ‘future.apply’
[13:35:07.335] getGlobalsAndPackages() ... DONE
[13:35:07.335]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:07.335]  - needed namespaces: [n=1] ‘future.apply’
[13:35:07.335] Finding globals ... DONE
[13:35:07.336]  - use_args: TRUE
[13:35:07.336]  - Getting '...' globals ...
[13:35:07.336] resolve() on list ...
[13:35:07.336]  recursive: 0
[13:35:07.336]  length: 1
[13:35:07.336]  elements: ‘...’
[13:35:07.337]  length: 0 (resolved future 1)
[13:35:07.337] resolve() on list ... DONE
[13:35:07.337]    - '...' content: [n=0] 
[13:35:07.337] List of 1
[13:35:07.337]  $ ...: list()
[13:35:07.337]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.337]  - attr(*, "where")=List of 1
[13:35:07.337]   ..$ ...:<environment: 0x5574d06062e8> 
[13:35:07.337]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.337]  - attr(*, "resolved")= logi TRUE
[13:35:07.337]  - attr(*, "total_size")= num NA
[13:35:07.340]  - Getting '...' globals ... DONE
[13:35:07.340] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:07.340] List of 8
[13:35:07.340]  $ ...future.FUN:function (x, ...)  
[13:35:07.340]  $ x_FUN        :function (x)  
[13:35:07.340]  $ times        : int 4
[13:35:07.340]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.340]  $ stop_if_not  :function (...)  
[13:35:07.340]  $ dim          : int [1:2] 2 2
[13:35:07.340]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:07.340]  $ ...          : list()
[13:35:07.340]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.340]  - attr(*, "where")=List of 8
[13:35:07.340]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:07.340]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:07.340]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:07.340]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:07.340]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:07.340]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:07.340]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:07.340]   ..$ ...          :<environment: 0x5574d06062e8> 
[13:35:07.340]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.340]  - attr(*, "resolved")= logi FALSE
[13:35:07.340]  - attr(*, "total_size")= num 97304
[13:35:07.345] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:07.345] getGlobalsAndPackagesXApply() ... DONE
[13:35:07.346] Number of futures (= number of chunks): 2
[13:35:07.346] Launching 2 futures (chunks) ...
[13:35:07.346] Chunk #1 of 2 ...
[13:35:07.346]  - Finding globals in 'X' for chunk #1 ...
[13:35:07.346] getGlobalsAndPackages() ...
[13:35:07.346] Searching for globals...
[13:35:07.346] 
[13:35:07.347] Searching for globals ... DONE
[13:35:07.347] - globals: [0] <none>
[13:35:07.347] getGlobalsAndPackages() ... DONE
[13:35:07.347]    + additional globals found: [n=0] 
[13:35:07.347]    + additional namespaces needed: [n=0] 
[13:35:07.347]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:07.347]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.347]  - seeds: <none>
[13:35:07.347]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.347] getGlobalsAndPackages() ...
[13:35:07.347] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.348] Resolving globals: FALSE
[13:35:07.348] Tweak future expression to call with '...' arguments ...
[13:35:07.348] {
[13:35:07.348]     do.call(function(...) {
[13:35:07.348]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.348]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.348]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.348]             on.exit(options(oopts), add = TRUE)
[13:35:07.348]         }
[13:35:07.348]         {
[13:35:07.348]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.348]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.348]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.348]             })
[13:35:07.348]         }
[13:35:07.348]     }, args = future.call.arguments)
[13:35:07.348] }
[13:35:07.348] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.349] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.349] - packages: [1] ‘future.apply’
[13:35:07.349] getGlobalsAndPackages() ... DONE
[13:35:07.349] run() for ‘Future’ ...
[13:35:07.349] - state: ‘created’
[13:35:07.349] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.355] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.355] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.355]   - Field: ‘label’
[13:35:07.355]   - Field: ‘local’
[13:35:07.356]   - Field: ‘owner’
[13:35:07.356]   - Field: ‘envir’
[13:35:07.356]   - Field: ‘workers’
[13:35:07.356]   - Field: ‘packages’
[13:35:07.356]   - Field: ‘gc’
[13:35:07.356]   - Field: ‘job’
[13:35:07.356]   - Field: ‘conditions’
[13:35:07.356]   - Field: ‘expr’
[13:35:07.356]   - Field: ‘uuid’
[13:35:07.357]   - Field: ‘seed’
[13:35:07.357]   - Field: ‘version’
[13:35:07.357]   - Field: ‘result’
[13:35:07.357]   - Field: ‘asynchronous’
[13:35:07.357]   - Field: ‘calls’
[13:35:07.357]   - Field: ‘globals’
[13:35:07.357]   - Field: ‘stdout’
[13:35:07.357]   - Field: ‘earlySignal’
[13:35:07.357]   - Field: ‘lazy’
[13:35:07.357]   - Field: ‘state’
[13:35:07.358] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.358] - Launch lazy future ...
[13:35:07.358] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:07.358] Packages needed by future strategies (n = 0): <none>
[13:35:07.359] {
[13:35:07.359]     {
[13:35:07.359]         {
[13:35:07.359]             ...future.startTime <- base::Sys.time()
[13:35:07.359]             {
[13:35:07.359]                 {
[13:35:07.359]                   {
[13:35:07.359]                     {
[13:35:07.359]                       {
[13:35:07.359]                         base::local({
[13:35:07.359]                           has_future <- base::requireNamespace("future", 
[13:35:07.359]                             quietly = TRUE)
[13:35:07.359]                           if (has_future) {
[13:35:07.359]                             ns <- base::getNamespace("future")
[13:35:07.359]                             version <- ns[[".package"]][["version"]]
[13:35:07.359]                             if (is.null(version)) 
[13:35:07.359]                               version <- utils::packageVersion("future")
[13:35:07.359]                           }
[13:35:07.359]                           else {
[13:35:07.359]                             version <- NULL
[13:35:07.359]                           }
[13:35:07.359]                           if (!has_future || version < "1.8.0") {
[13:35:07.359]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.359]                               "", base::R.version$version.string), 
[13:35:07.359]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.359]                                 base::R.version$platform, 8 * 
[13:35:07.359]                                   base::.Machine$sizeof.pointer), 
[13:35:07.359]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.359]                                 "release", "version")], collapse = " "), 
[13:35:07.359]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.359]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.359]                               info)
[13:35:07.359]                             info <- base::paste(info, collapse = "; ")
[13:35:07.359]                             if (!has_future) {
[13:35:07.359]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.359]                                 info)
[13:35:07.359]                             }
[13:35:07.359]                             else {
[13:35:07.359]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.359]                                 info, version)
[13:35:07.359]                             }
[13:35:07.359]                             base::stop(msg)
[13:35:07.359]                           }
[13:35:07.359]                         })
[13:35:07.359]                       }
[13:35:07.359]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.359]                       base::options(mc.cores = 1L)
[13:35:07.359]                     }
[13:35:07.359]                     base::local({
[13:35:07.359]                       for (pkg in "future.apply") {
[13:35:07.359]                         base::loadNamespace(pkg)
[13:35:07.359]                         base::library(pkg, character.only = TRUE)
[13:35:07.359]                       }
[13:35:07.359]                     })
[13:35:07.359]                   }
[13:35:07.359]                   ...future.strategy.old <- future::plan("list")
[13:35:07.359]                   options(future.plan = NULL)
[13:35:07.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.359]                 }
[13:35:07.359]                 ...future.workdir <- getwd()
[13:35:07.359]             }
[13:35:07.359]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.359]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.359]         }
[13:35:07.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.359]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.359]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.359]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.359]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.359]             base::names(...future.oldOptions))
[13:35:07.359]     }
[13:35:07.359]     if (FALSE) {
[13:35:07.359]     }
[13:35:07.359]     else {
[13:35:07.359]         if (TRUE) {
[13:35:07.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.359]                 open = "w")
[13:35:07.359]         }
[13:35:07.359]         else {
[13:35:07.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.359]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.359]         }
[13:35:07.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.359]             base::sink(type = "output", split = FALSE)
[13:35:07.359]             base::close(...future.stdout)
[13:35:07.359]         }, add = TRUE)
[13:35:07.359]     }
[13:35:07.359]     ...future.frame <- base::sys.nframe()
[13:35:07.359]     ...future.conditions <- base::list()
[13:35:07.359]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.359]     if (FALSE) {
[13:35:07.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.359]     }
[13:35:07.359]     ...future.result <- base::tryCatch({
[13:35:07.359]         base::withCallingHandlers({
[13:35:07.359]             ...future.value <- base::withVisible(base::local({
[13:35:07.359]                 withCallingHandlers({
[13:35:07.359]                   {
[13:35:07.359]                     do.call(function(...) {
[13:35:07.359]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.359]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.359]                         ...future.globals.maxSize)) {
[13:35:07.359]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.359]                         on.exit(options(oopts), add = TRUE)
[13:35:07.359]                       }
[13:35:07.359]                       {
[13:35:07.359]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.359]                           FUN = function(jj) {
[13:35:07.359]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.359]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.359]                           })
[13:35:07.359]                       }
[13:35:07.359]                     }, args = future.call.arguments)
[13:35:07.359]                   }
[13:35:07.359]                 }, immediateCondition = function(cond) {
[13:35:07.359]                   save_rds <- function (object, pathname, ...) 
[13:35:07.359]                   {
[13:35:07.359]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.359]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.359]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.359]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.359]                         fi_tmp[["mtime"]])
[13:35:07.359]                     }
[13:35:07.359]                     tryCatch({
[13:35:07.359]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.359]                     }, error = function(ex) {
[13:35:07.359]                       msg <- conditionMessage(ex)
[13:35:07.359]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.359]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.359]                         fi_tmp[["mtime"]], msg)
[13:35:07.359]                       ex$message <- msg
[13:35:07.359]                       stop(ex)
[13:35:07.359]                     })
[13:35:07.359]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.359]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.359]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.359]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.359]                       fi <- file.info(pathname)
[13:35:07.359]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.359]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.359]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.359]                         fi[["size"]], fi[["mtime"]])
[13:35:07.359]                       stop(msg)
[13:35:07.359]                     }
[13:35:07.359]                     invisible(pathname)
[13:35:07.359]                   }
[13:35:07.359]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.359]                     rootPath = tempdir()) 
[13:35:07.359]                   {
[13:35:07.359]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.359]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.359]                       tmpdir = path, fileext = ".rds")
[13:35:07.359]                     save_rds(obj, file)
[13:35:07.359]                   }
[13:35:07.359]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.359]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.359]                   {
[13:35:07.359]                     inherits <- base::inherits
[13:35:07.359]                     invokeRestart <- base::invokeRestart
[13:35:07.359]                     is.null <- base::is.null
[13:35:07.359]                     muffled <- FALSE
[13:35:07.359]                     if (inherits(cond, "message")) {
[13:35:07.359]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.359]                       if (muffled) 
[13:35:07.359]                         invokeRestart("muffleMessage")
[13:35:07.359]                     }
[13:35:07.359]                     else if (inherits(cond, "warning")) {
[13:35:07.359]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.359]                       if (muffled) 
[13:35:07.359]                         invokeRestart("muffleWarning")
[13:35:07.359]                     }
[13:35:07.359]                     else if (inherits(cond, "condition")) {
[13:35:07.359]                       if (!is.null(pattern)) {
[13:35:07.359]                         computeRestarts <- base::computeRestarts
[13:35:07.359]                         grepl <- base::grepl
[13:35:07.359]                         restarts <- computeRestarts(cond)
[13:35:07.359]                         for (restart in restarts) {
[13:35:07.359]                           name <- restart$name
[13:35:07.359]                           if (is.null(name)) 
[13:35:07.359]                             next
[13:35:07.359]                           if (!grepl(pattern, name)) 
[13:35:07.359]                             next
[13:35:07.359]                           invokeRestart(restart)
[13:35:07.359]                           muffled <- TRUE
[13:35:07.359]                           break
[13:35:07.359]                         }
[13:35:07.359]                       }
[13:35:07.359]                     }
[13:35:07.359]                     invisible(muffled)
[13:35:07.359]                   }
[13:35:07.359]                   muffleCondition(cond)
[13:35:07.359]                 })
[13:35:07.359]             }))
[13:35:07.359]             future::FutureResult(value = ...future.value$value, 
[13:35:07.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.359]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.359]                     ...future.globalenv.names))
[13:35:07.359]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.359]         }, condition = base::local({
[13:35:07.359]             c <- base::c
[13:35:07.359]             inherits <- base::inherits
[13:35:07.359]             invokeRestart <- base::invokeRestart
[13:35:07.359]             length <- base::length
[13:35:07.359]             list <- base::list
[13:35:07.359]             seq.int <- base::seq.int
[13:35:07.359]             signalCondition <- base::signalCondition
[13:35:07.359]             sys.calls <- base::sys.calls
[13:35:07.359]             `[[` <- base::`[[`
[13:35:07.359]             `+` <- base::`+`
[13:35:07.359]             `<<-` <- base::`<<-`
[13:35:07.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.359]                   3L)]
[13:35:07.359]             }
[13:35:07.359]             function(cond) {
[13:35:07.359]                 is_error <- inherits(cond, "error")
[13:35:07.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.359]                   NULL)
[13:35:07.359]                 if (is_error) {
[13:35:07.359]                   sessionInformation <- function() {
[13:35:07.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.359]                       search = base::search(), system = base::Sys.info())
[13:35:07.359]                   }
[13:35:07.359]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.359]                     cond$call), session = sessionInformation(), 
[13:35:07.359]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.359]                   signalCondition(cond)
[13:35:07.359]                 }
[13:35:07.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.359]                 "immediateCondition"))) {
[13:35:07.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.359]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.359]                   if (TRUE && !signal) {
[13:35:07.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.359]                     {
[13:35:07.359]                       inherits <- base::inherits
[13:35:07.359]                       invokeRestart <- base::invokeRestart
[13:35:07.359]                       is.null <- base::is.null
[13:35:07.359]                       muffled <- FALSE
[13:35:07.359]                       if (inherits(cond, "message")) {
[13:35:07.359]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.359]                         if (muffled) 
[13:35:07.359]                           invokeRestart("muffleMessage")
[13:35:07.359]                       }
[13:35:07.359]                       else if (inherits(cond, "warning")) {
[13:35:07.359]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.359]                         if (muffled) 
[13:35:07.359]                           invokeRestart("muffleWarning")
[13:35:07.359]                       }
[13:35:07.359]                       else if (inherits(cond, "condition")) {
[13:35:07.359]                         if (!is.null(pattern)) {
[13:35:07.359]                           computeRestarts <- base::computeRestarts
[13:35:07.359]                           grepl <- base::grepl
[13:35:07.359]                           restarts <- computeRestarts(cond)
[13:35:07.359]                           for (restart in restarts) {
[13:35:07.359]                             name <- restart$name
[13:35:07.359]                             if (is.null(name)) 
[13:35:07.359]                               next
[13:35:07.359]                             if (!grepl(pattern, name)) 
[13:35:07.359]                               next
[13:35:07.359]                             invokeRestart(restart)
[13:35:07.359]                             muffled <- TRUE
[13:35:07.359]                             break
[13:35:07.359]                           }
[13:35:07.359]                         }
[13:35:07.359]                       }
[13:35:07.359]                       invisible(muffled)
[13:35:07.359]                     }
[13:35:07.359]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.359]                   }
[13:35:07.359]                 }
[13:35:07.359]                 else {
[13:35:07.359]                   if (TRUE) {
[13:35:07.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.359]                     {
[13:35:07.359]                       inherits <- base::inherits
[13:35:07.359]                       invokeRestart <- base::invokeRestart
[13:35:07.359]                       is.null <- base::is.null
[13:35:07.359]                       muffled <- FALSE
[13:35:07.359]                       if (inherits(cond, "message")) {
[13:35:07.359]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.359]                         if (muffled) 
[13:35:07.359]                           invokeRestart("muffleMessage")
[13:35:07.359]                       }
[13:35:07.359]                       else if (inherits(cond, "warning")) {
[13:35:07.359]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.359]                         if (muffled) 
[13:35:07.359]                           invokeRestart("muffleWarning")
[13:35:07.359]                       }
[13:35:07.359]                       else if (inherits(cond, "condition")) {
[13:35:07.359]                         if (!is.null(pattern)) {
[13:35:07.359]                           computeRestarts <- base::computeRestarts
[13:35:07.359]                           grepl <- base::grepl
[13:35:07.359]                           restarts <- computeRestarts(cond)
[13:35:07.359]                           for (restart in restarts) {
[13:35:07.359]                             name <- restart$name
[13:35:07.359]                             if (is.null(name)) 
[13:35:07.359]                               next
[13:35:07.359]                             if (!grepl(pattern, name)) 
[13:35:07.359]                               next
[13:35:07.359]                             invokeRestart(restart)
[13:35:07.359]                             muffled <- TRUE
[13:35:07.359]                             break
[13:35:07.359]                           }
[13:35:07.359]                         }
[13:35:07.359]                       }
[13:35:07.359]                       invisible(muffled)
[13:35:07.359]                     }
[13:35:07.359]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.359]                   }
[13:35:07.359]                 }
[13:35:07.359]             }
[13:35:07.359]         }))
[13:35:07.359]     }, error = function(ex) {
[13:35:07.359]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.359]                 ...future.rng), started = ...future.startTime, 
[13:35:07.359]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.359]             version = "1.8"), class = "FutureResult")
[13:35:07.359]     }, finally = {
[13:35:07.359]         if (!identical(...future.workdir, getwd())) 
[13:35:07.359]             setwd(...future.workdir)
[13:35:07.359]         {
[13:35:07.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.359]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.359]             }
[13:35:07.359]             base::options(...future.oldOptions)
[13:35:07.359]             if (.Platform$OS.type == "windows") {
[13:35:07.359]                 old_names <- names(...future.oldEnvVars)
[13:35:07.359]                 envs <- base::Sys.getenv()
[13:35:07.359]                 names <- names(envs)
[13:35:07.359]                 common <- intersect(names, old_names)
[13:35:07.359]                 added <- setdiff(names, old_names)
[13:35:07.359]                 removed <- setdiff(old_names, names)
[13:35:07.359]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.359]                   envs[common]]
[13:35:07.359]                 NAMES <- toupper(changed)
[13:35:07.359]                 args <- list()
[13:35:07.359]                 for (kk in seq_along(NAMES)) {
[13:35:07.359]                   name <- changed[[kk]]
[13:35:07.359]                   NAME <- NAMES[[kk]]
[13:35:07.359]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.359]                     next
[13:35:07.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.359]                 }
[13:35:07.359]                 NAMES <- toupper(added)
[13:35:07.359]                 for (kk in seq_along(NAMES)) {
[13:35:07.359]                   name <- added[[kk]]
[13:35:07.359]                   NAME <- NAMES[[kk]]
[13:35:07.359]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.359]                     next
[13:35:07.359]                   args[[name]] <- ""
[13:35:07.359]                 }
[13:35:07.359]                 NAMES <- toupper(removed)
[13:35:07.359]                 for (kk in seq_along(NAMES)) {
[13:35:07.359]                   name <- removed[[kk]]
[13:35:07.359]                   NAME <- NAMES[[kk]]
[13:35:07.359]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.359]                     next
[13:35:07.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.359]                 }
[13:35:07.359]                 if (length(args) > 0) 
[13:35:07.359]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.359]             }
[13:35:07.359]             else {
[13:35:07.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.359]             }
[13:35:07.359]             {
[13:35:07.359]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.359]                   0L) {
[13:35:07.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.359]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.359]                   base::options(opts)
[13:35:07.359]                 }
[13:35:07.359]                 {
[13:35:07.359]                   {
[13:35:07.359]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.359]                     NULL
[13:35:07.359]                   }
[13:35:07.359]                   options(future.plan = NULL)
[13:35:07.359]                   if (is.na(NA_character_)) 
[13:35:07.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.359]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.359]                     .init = FALSE)
[13:35:07.359]                 }
[13:35:07.359]             }
[13:35:07.359]         }
[13:35:07.359]     })
[13:35:07.359]     if (TRUE) {
[13:35:07.359]         base::sink(type = "output", split = FALSE)
[13:35:07.359]         if (TRUE) {
[13:35:07.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.359]         }
[13:35:07.359]         else {
[13:35:07.359]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.359]         }
[13:35:07.359]         base::close(...future.stdout)
[13:35:07.359]         ...future.stdout <- NULL
[13:35:07.359]     }
[13:35:07.359]     ...future.result$conditions <- ...future.conditions
[13:35:07.359]     ...future.result$finished <- base::Sys.time()
[13:35:07.359]     ...future.result
[13:35:07.359] }
[13:35:07.361] assign_globals() ...
[13:35:07.361] List of 11
[13:35:07.361]  $ ...future.FUN            :function (x, ...)  
[13:35:07.361]  $ x_FUN                    :function (x)  
[13:35:07.361]  $ times                    : int 4
[13:35:07.361]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.361]  $ stop_if_not              :function (...)  
[13:35:07.361]  $ dim                      : int [1:2] 2 2
[13:35:07.361]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:07.361]  $ future.call.arguments    : list()
[13:35:07.361]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.361]  $ ...future.elements_ii    :List of 5
[13:35:07.361]   ..$ : int 1
[13:35:07.361]   ..$ : int 2
[13:35:07.361]   ..$ : int 3
[13:35:07.361]   ..$ : int 4
[13:35:07.361]   ..$ : int 5
[13:35:07.361]  $ ...future.seeds_ii       : NULL
[13:35:07.361]  $ ...future.globals.maxSize: NULL
[13:35:07.361]  - attr(*, "where")=List of 11
[13:35:07.361]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.361]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:07.361]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:07.361]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:07.361]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:07.361]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:07.361]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:07.361]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.361]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.361]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.361]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.361]  - attr(*, "resolved")= logi FALSE
[13:35:07.361]  - attr(*, "total_size")= num 97304
[13:35:07.361]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.361]  - attr(*, "already-done")= logi TRUE
[13:35:07.370] - copied ‘...future.FUN’ to environment
[13:35:07.370] - reassign environment for ‘x_FUN’
[13:35:07.370] - copied ‘x_FUN’ to environment
[13:35:07.370] - copied ‘times’ to environment
[13:35:07.370] - copied ‘stopf’ to environment
[13:35:07.370] - copied ‘stop_if_not’ to environment
[13:35:07.371] - copied ‘dim’ to environment
[13:35:07.371] - copied ‘valid_types’ to environment
[13:35:07.371] - copied ‘future.call.arguments’ to environment
[13:35:07.371] - copied ‘...future.elements_ii’ to environment
[13:35:07.371] - copied ‘...future.seeds_ii’ to environment
[13:35:07.371] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.371] assign_globals() ... done
[13:35:07.371] requestCore(): workers = 2
[13:35:07.373] MulticoreFuture started
[13:35:07.374] - Launch lazy future ... done
[13:35:07.374] run() for ‘MulticoreFuture’ ... done
[13:35:07.374] Created future:
[13:35:07.375] plan(): Setting new future strategy stack:
[13:35:07.375] List of future strategies:
[13:35:07.375] 1. sequential:
[13:35:07.375]    - args: function (..., envir = parent.frame())
[13:35:07.375]    - tweaked: FALSE
[13:35:07.375]    - call: NULL
[13:35:07.376] plan(): nbrOfWorkers() = 1
[13:35:07.378] plan(): Setting new future strategy stack:
[13:35:07.378] List of future strategies:
[13:35:07.378] 1. multicore:
[13:35:07.378]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.378]    - tweaked: FALSE
[13:35:07.378]    - call: plan(strategy)
[13:35:07.384] plan(): nbrOfWorkers() = 2
[13:35:07.374] MulticoreFuture:
[13:35:07.374] Label: ‘future_vapply-1’
[13:35:07.374] Expression:
[13:35:07.374] {
[13:35:07.374]     do.call(function(...) {
[13:35:07.374]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.374]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.374]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.374]             on.exit(options(oopts), add = TRUE)
[13:35:07.374]         }
[13:35:07.374]         {
[13:35:07.374]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.374]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.374]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.374]             })
[13:35:07.374]         }
[13:35:07.374]     }, args = future.call.arguments)
[13:35:07.374] }
[13:35:07.374] Lazy evaluation: FALSE
[13:35:07.374] Asynchronous evaluation: TRUE
[13:35:07.374] Local evaluation: TRUE
[13:35:07.374] Environment: R_GlobalEnv
[13:35:07.374] Capture standard output: TRUE
[13:35:07.374] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.374] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:07.374] Packages: 1 packages (‘future.apply’)
[13:35:07.374] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.374] Resolved: TRUE
[13:35:07.374] Value: <not collected>
[13:35:07.374] Conditions captured: <none>
[13:35:07.374] Early signaling: FALSE
[13:35:07.374] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.374] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.385] Chunk #1 of 2 ... DONE
[13:35:07.385] Chunk #2 of 2 ...
[13:35:07.385]  - Finding globals in 'X' for chunk #2 ...
[13:35:07.385] getGlobalsAndPackages() ...
[13:35:07.386] Searching for globals...
[13:35:07.386] 
[13:35:07.386] Searching for globals ... DONE
[13:35:07.386] - globals: [0] <none>
[13:35:07.386] getGlobalsAndPackages() ... DONE
[13:35:07.387]    + additional globals found: [n=0] 
[13:35:07.387]    + additional namespaces needed: [n=0] 
[13:35:07.387]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:07.387]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.387]  - seeds: <none>
[13:35:07.387]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.387] getGlobalsAndPackages() ...
[13:35:07.388] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.388] Resolving globals: FALSE
[13:35:07.388] Tweak future expression to call with '...' arguments ...
[13:35:07.388] {
[13:35:07.388]     do.call(function(...) {
[13:35:07.388]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.388]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.388]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.388]             on.exit(options(oopts), add = TRUE)
[13:35:07.388]         }
[13:35:07.388]         {
[13:35:07.388]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.388]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.388]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.388]             })
[13:35:07.388]         }
[13:35:07.388]     }, args = future.call.arguments)
[13:35:07.388] }
[13:35:07.389] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.394] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.394] - packages: [1] ‘future.apply’
[13:35:07.394] getGlobalsAndPackages() ... DONE
[13:35:07.395] run() for ‘Future’ ...
[13:35:07.396] - state: ‘created’
[13:35:07.396] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.402] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.403] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.403]   - Field: ‘label’
[13:35:07.403]   - Field: ‘local’
[13:35:07.403]   - Field: ‘owner’
[13:35:07.403]   - Field: ‘envir’
[13:35:07.404]   - Field: ‘workers’
[13:35:07.404]   - Field: ‘packages’
[13:35:07.404]   - Field: ‘gc’
[13:35:07.404]   - Field: ‘job’
[13:35:07.405]   - Field: ‘conditions’
[13:35:07.405]   - Field: ‘expr’
[13:35:07.405]   - Field: ‘uuid’
[13:35:07.405]   - Field: ‘seed’
[13:35:07.406]   - Field: ‘version’
[13:35:07.406]   - Field: ‘result’
[13:35:07.406]   - Field: ‘asynchronous’
[13:35:07.406]   - Field: ‘calls’
[13:35:07.406]   - Field: ‘globals’
[13:35:07.407]   - Field: ‘stdout’
[13:35:07.407]   - Field: ‘earlySignal’
[13:35:07.407]   - Field: ‘lazy’
[13:35:07.407]   - Field: ‘state’
[13:35:07.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.408] - Launch lazy future ...
[13:35:07.408] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:07.408] Packages needed by future strategies (n = 0): <none>
[13:35:07.409] {
[13:35:07.409]     {
[13:35:07.409]         {
[13:35:07.409]             ...future.startTime <- base::Sys.time()
[13:35:07.409]             {
[13:35:07.409]                 {
[13:35:07.409]                   {
[13:35:07.409]                     {
[13:35:07.409]                       {
[13:35:07.409]                         base::local({
[13:35:07.409]                           has_future <- base::requireNamespace("future", 
[13:35:07.409]                             quietly = TRUE)
[13:35:07.409]                           if (has_future) {
[13:35:07.409]                             ns <- base::getNamespace("future")
[13:35:07.409]                             version <- ns[[".package"]][["version"]]
[13:35:07.409]                             if (is.null(version)) 
[13:35:07.409]                               version <- utils::packageVersion("future")
[13:35:07.409]                           }
[13:35:07.409]                           else {
[13:35:07.409]                             version <- NULL
[13:35:07.409]                           }
[13:35:07.409]                           if (!has_future || version < "1.8.0") {
[13:35:07.409]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.409]                               "", base::R.version$version.string), 
[13:35:07.409]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.409]                                 base::R.version$platform, 8 * 
[13:35:07.409]                                   base::.Machine$sizeof.pointer), 
[13:35:07.409]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.409]                                 "release", "version")], collapse = " "), 
[13:35:07.409]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.409]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.409]                               info)
[13:35:07.409]                             info <- base::paste(info, collapse = "; ")
[13:35:07.409]                             if (!has_future) {
[13:35:07.409]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.409]                                 info)
[13:35:07.409]                             }
[13:35:07.409]                             else {
[13:35:07.409]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.409]                                 info, version)
[13:35:07.409]                             }
[13:35:07.409]                             base::stop(msg)
[13:35:07.409]                           }
[13:35:07.409]                         })
[13:35:07.409]                       }
[13:35:07.409]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.409]                       base::options(mc.cores = 1L)
[13:35:07.409]                     }
[13:35:07.409]                     base::local({
[13:35:07.409]                       for (pkg in "future.apply") {
[13:35:07.409]                         base::loadNamespace(pkg)
[13:35:07.409]                         base::library(pkg, character.only = TRUE)
[13:35:07.409]                       }
[13:35:07.409]                     })
[13:35:07.409]                   }
[13:35:07.409]                   ...future.strategy.old <- future::plan("list")
[13:35:07.409]                   options(future.plan = NULL)
[13:35:07.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.409]                 }
[13:35:07.409]                 ...future.workdir <- getwd()
[13:35:07.409]             }
[13:35:07.409]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.409]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.409]         }
[13:35:07.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.409]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.409]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.409]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.409]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.409]             base::names(...future.oldOptions))
[13:35:07.409]     }
[13:35:07.409]     if (FALSE) {
[13:35:07.409]     }
[13:35:07.409]     else {
[13:35:07.409]         if (TRUE) {
[13:35:07.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.409]                 open = "w")
[13:35:07.409]         }
[13:35:07.409]         else {
[13:35:07.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.409]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.409]         }
[13:35:07.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.409]             base::sink(type = "output", split = FALSE)
[13:35:07.409]             base::close(...future.stdout)
[13:35:07.409]         }, add = TRUE)
[13:35:07.409]     }
[13:35:07.409]     ...future.frame <- base::sys.nframe()
[13:35:07.409]     ...future.conditions <- base::list()
[13:35:07.409]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.409]     if (FALSE) {
[13:35:07.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.409]     }
[13:35:07.409]     ...future.result <- base::tryCatch({
[13:35:07.409]         base::withCallingHandlers({
[13:35:07.409]             ...future.value <- base::withVisible(base::local({
[13:35:07.409]                 withCallingHandlers({
[13:35:07.409]                   {
[13:35:07.409]                     do.call(function(...) {
[13:35:07.409]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.409]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.409]                         ...future.globals.maxSize)) {
[13:35:07.409]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.409]                         on.exit(options(oopts), add = TRUE)
[13:35:07.409]                       }
[13:35:07.409]                       {
[13:35:07.409]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.409]                           FUN = function(jj) {
[13:35:07.409]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.409]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.409]                           })
[13:35:07.409]                       }
[13:35:07.409]                     }, args = future.call.arguments)
[13:35:07.409]                   }
[13:35:07.409]                 }, immediateCondition = function(cond) {
[13:35:07.409]                   save_rds <- function (object, pathname, ...) 
[13:35:07.409]                   {
[13:35:07.409]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.409]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.409]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.409]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.409]                         fi_tmp[["mtime"]])
[13:35:07.409]                     }
[13:35:07.409]                     tryCatch({
[13:35:07.409]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.409]                     }, error = function(ex) {
[13:35:07.409]                       msg <- conditionMessage(ex)
[13:35:07.409]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.409]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.409]                         fi_tmp[["mtime"]], msg)
[13:35:07.409]                       ex$message <- msg
[13:35:07.409]                       stop(ex)
[13:35:07.409]                     })
[13:35:07.409]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.409]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.409]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.409]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.409]                       fi <- file.info(pathname)
[13:35:07.409]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.409]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.409]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.409]                         fi[["size"]], fi[["mtime"]])
[13:35:07.409]                       stop(msg)
[13:35:07.409]                     }
[13:35:07.409]                     invisible(pathname)
[13:35:07.409]                   }
[13:35:07.409]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.409]                     rootPath = tempdir()) 
[13:35:07.409]                   {
[13:35:07.409]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.409]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.409]                       tmpdir = path, fileext = ".rds")
[13:35:07.409]                     save_rds(obj, file)
[13:35:07.409]                   }
[13:35:07.409]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.409]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.409]                   {
[13:35:07.409]                     inherits <- base::inherits
[13:35:07.409]                     invokeRestart <- base::invokeRestart
[13:35:07.409]                     is.null <- base::is.null
[13:35:07.409]                     muffled <- FALSE
[13:35:07.409]                     if (inherits(cond, "message")) {
[13:35:07.409]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.409]                       if (muffled) 
[13:35:07.409]                         invokeRestart("muffleMessage")
[13:35:07.409]                     }
[13:35:07.409]                     else if (inherits(cond, "warning")) {
[13:35:07.409]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.409]                       if (muffled) 
[13:35:07.409]                         invokeRestart("muffleWarning")
[13:35:07.409]                     }
[13:35:07.409]                     else if (inherits(cond, "condition")) {
[13:35:07.409]                       if (!is.null(pattern)) {
[13:35:07.409]                         computeRestarts <- base::computeRestarts
[13:35:07.409]                         grepl <- base::grepl
[13:35:07.409]                         restarts <- computeRestarts(cond)
[13:35:07.409]                         for (restart in restarts) {
[13:35:07.409]                           name <- restart$name
[13:35:07.409]                           if (is.null(name)) 
[13:35:07.409]                             next
[13:35:07.409]                           if (!grepl(pattern, name)) 
[13:35:07.409]                             next
[13:35:07.409]                           invokeRestart(restart)
[13:35:07.409]                           muffled <- TRUE
[13:35:07.409]                           break
[13:35:07.409]                         }
[13:35:07.409]                       }
[13:35:07.409]                     }
[13:35:07.409]                     invisible(muffled)
[13:35:07.409]                   }
[13:35:07.409]                   muffleCondition(cond)
[13:35:07.409]                 })
[13:35:07.409]             }))
[13:35:07.409]             future::FutureResult(value = ...future.value$value, 
[13:35:07.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.409]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.409]                     ...future.globalenv.names))
[13:35:07.409]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.409]         }, condition = base::local({
[13:35:07.409]             c <- base::c
[13:35:07.409]             inherits <- base::inherits
[13:35:07.409]             invokeRestart <- base::invokeRestart
[13:35:07.409]             length <- base::length
[13:35:07.409]             list <- base::list
[13:35:07.409]             seq.int <- base::seq.int
[13:35:07.409]             signalCondition <- base::signalCondition
[13:35:07.409]             sys.calls <- base::sys.calls
[13:35:07.409]             `[[` <- base::`[[`
[13:35:07.409]             `+` <- base::`+`
[13:35:07.409]             `<<-` <- base::`<<-`
[13:35:07.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.409]                   3L)]
[13:35:07.409]             }
[13:35:07.409]             function(cond) {
[13:35:07.409]                 is_error <- inherits(cond, "error")
[13:35:07.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.409]                   NULL)
[13:35:07.409]                 if (is_error) {
[13:35:07.409]                   sessionInformation <- function() {
[13:35:07.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.409]                       search = base::search(), system = base::Sys.info())
[13:35:07.409]                   }
[13:35:07.409]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.409]                     cond$call), session = sessionInformation(), 
[13:35:07.409]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.409]                   signalCondition(cond)
[13:35:07.409]                 }
[13:35:07.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.409]                 "immediateCondition"))) {
[13:35:07.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.409]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.409]                   if (TRUE && !signal) {
[13:35:07.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.409]                     {
[13:35:07.409]                       inherits <- base::inherits
[13:35:07.409]                       invokeRestart <- base::invokeRestart
[13:35:07.409]                       is.null <- base::is.null
[13:35:07.409]                       muffled <- FALSE
[13:35:07.409]                       if (inherits(cond, "message")) {
[13:35:07.409]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.409]                         if (muffled) 
[13:35:07.409]                           invokeRestart("muffleMessage")
[13:35:07.409]                       }
[13:35:07.409]                       else if (inherits(cond, "warning")) {
[13:35:07.409]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.409]                         if (muffled) 
[13:35:07.409]                           invokeRestart("muffleWarning")
[13:35:07.409]                       }
[13:35:07.409]                       else if (inherits(cond, "condition")) {
[13:35:07.409]                         if (!is.null(pattern)) {
[13:35:07.409]                           computeRestarts <- base::computeRestarts
[13:35:07.409]                           grepl <- base::grepl
[13:35:07.409]                           restarts <- computeRestarts(cond)
[13:35:07.409]                           for (restart in restarts) {
[13:35:07.409]                             name <- restart$name
[13:35:07.409]                             if (is.null(name)) 
[13:35:07.409]                               next
[13:35:07.409]                             if (!grepl(pattern, name)) 
[13:35:07.409]                               next
[13:35:07.409]                             invokeRestart(restart)
[13:35:07.409]                             muffled <- TRUE
[13:35:07.409]                             break
[13:35:07.409]                           }
[13:35:07.409]                         }
[13:35:07.409]                       }
[13:35:07.409]                       invisible(muffled)
[13:35:07.409]                     }
[13:35:07.409]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.409]                   }
[13:35:07.409]                 }
[13:35:07.409]                 else {
[13:35:07.409]                   if (TRUE) {
[13:35:07.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.409]                     {
[13:35:07.409]                       inherits <- base::inherits
[13:35:07.409]                       invokeRestart <- base::invokeRestart
[13:35:07.409]                       is.null <- base::is.null
[13:35:07.409]                       muffled <- FALSE
[13:35:07.409]                       if (inherits(cond, "message")) {
[13:35:07.409]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.409]                         if (muffled) 
[13:35:07.409]                           invokeRestart("muffleMessage")
[13:35:07.409]                       }
[13:35:07.409]                       else if (inherits(cond, "warning")) {
[13:35:07.409]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.409]                         if (muffled) 
[13:35:07.409]                           invokeRestart("muffleWarning")
[13:35:07.409]                       }
[13:35:07.409]                       else if (inherits(cond, "condition")) {
[13:35:07.409]                         if (!is.null(pattern)) {
[13:35:07.409]                           computeRestarts <- base::computeRestarts
[13:35:07.409]                           grepl <- base::grepl
[13:35:07.409]                           restarts <- computeRestarts(cond)
[13:35:07.409]                           for (restart in restarts) {
[13:35:07.409]                             name <- restart$name
[13:35:07.409]                             if (is.null(name)) 
[13:35:07.409]                               next
[13:35:07.409]                             if (!grepl(pattern, name)) 
[13:35:07.409]                               next
[13:35:07.409]                             invokeRestart(restart)
[13:35:07.409]                             muffled <- TRUE
[13:35:07.409]                             break
[13:35:07.409]                           }
[13:35:07.409]                         }
[13:35:07.409]                       }
[13:35:07.409]                       invisible(muffled)
[13:35:07.409]                     }
[13:35:07.409]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.409]                   }
[13:35:07.409]                 }
[13:35:07.409]             }
[13:35:07.409]         }))
[13:35:07.409]     }, error = function(ex) {
[13:35:07.409]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.409]                 ...future.rng), started = ...future.startTime, 
[13:35:07.409]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.409]             version = "1.8"), class = "FutureResult")
[13:35:07.409]     }, finally = {
[13:35:07.409]         if (!identical(...future.workdir, getwd())) 
[13:35:07.409]             setwd(...future.workdir)
[13:35:07.409]         {
[13:35:07.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.409]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.409]             }
[13:35:07.409]             base::options(...future.oldOptions)
[13:35:07.409]             if (.Platform$OS.type == "windows") {
[13:35:07.409]                 old_names <- names(...future.oldEnvVars)
[13:35:07.409]                 envs <- base::Sys.getenv()
[13:35:07.409]                 names <- names(envs)
[13:35:07.409]                 common <- intersect(names, old_names)
[13:35:07.409]                 added <- setdiff(names, old_names)
[13:35:07.409]                 removed <- setdiff(old_names, names)
[13:35:07.409]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.409]                   envs[common]]
[13:35:07.409]                 NAMES <- toupper(changed)
[13:35:07.409]                 args <- list()
[13:35:07.409]                 for (kk in seq_along(NAMES)) {
[13:35:07.409]                   name <- changed[[kk]]
[13:35:07.409]                   NAME <- NAMES[[kk]]
[13:35:07.409]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.409]                     next
[13:35:07.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.409]                 }
[13:35:07.409]                 NAMES <- toupper(added)
[13:35:07.409]                 for (kk in seq_along(NAMES)) {
[13:35:07.409]                   name <- added[[kk]]
[13:35:07.409]                   NAME <- NAMES[[kk]]
[13:35:07.409]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.409]                     next
[13:35:07.409]                   args[[name]] <- ""
[13:35:07.409]                 }
[13:35:07.409]                 NAMES <- toupper(removed)
[13:35:07.409]                 for (kk in seq_along(NAMES)) {
[13:35:07.409]                   name <- removed[[kk]]
[13:35:07.409]                   NAME <- NAMES[[kk]]
[13:35:07.409]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.409]                     next
[13:35:07.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.409]                 }
[13:35:07.409]                 if (length(args) > 0) 
[13:35:07.409]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.409]             }
[13:35:07.409]             else {
[13:35:07.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.409]             }
[13:35:07.409]             {
[13:35:07.409]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.409]                   0L) {
[13:35:07.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.409]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.409]                   base::options(opts)
[13:35:07.409]                 }
[13:35:07.409]                 {
[13:35:07.409]                   {
[13:35:07.409]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.409]                     NULL
[13:35:07.409]                   }
[13:35:07.409]                   options(future.plan = NULL)
[13:35:07.409]                   if (is.na(NA_character_)) 
[13:35:07.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.409]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.409]                     .init = FALSE)
[13:35:07.409]                 }
[13:35:07.409]             }
[13:35:07.409]         }
[13:35:07.409]     })
[13:35:07.409]     if (TRUE) {
[13:35:07.409]         base::sink(type = "output", split = FALSE)
[13:35:07.409]         if (TRUE) {
[13:35:07.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.409]         }
[13:35:07.409]         else {
[13:35:07.409]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.409]         }
[13:35:07.409]         base::close(...future.stdout)
[13:35:07.409]         ...future.stdout <- NULL
[13:35:07.409]     }
[13:35:07.409]     ...future.result$conditions <- ...future.conditions
[13:35:07.409]     ...future.result$finished <- base::Sys.time()
[13:35:07.409]     ...future.result
[13:35:07.409] }
[13:35:07.412] assign_globals() ...
[13:35:07.412] List of 11
[13:35:07.412]  $ ...future.FUN            :function (x, ...)  
[13:35:07.412]  $ x_FUN                    :function (x)  
[13:35:07.412]  $ times                    : int 4
[13:35:07.412]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.412]  $ stop_if_not              :function (...)  
[13:35:07.412]  $ dim                      : int [1:2] 2 2
[13:35:07.412]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:07.412]  $ future.call.arguments    : list()
[13:35:07.412]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.412]  $ ...future.elements_ii    :List of 5
[13:35:07.412]   ..$ : int 6
[13:35:07.412]   ..$ : int 7
[13:35:07.412]   ..$ : int 8
[13:35:07.412]   ..$ : int 9
[13:35:07.412]   ..$ : int 10
[13:35:07.412]  $ ...future.seeds_ii       : NULL
[13:35:07.412]  $ ...future.globals.maxSize: NULL
[13:35:07.412]  - attr(*, "where")=List of 11
[13:35:07.412]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.412]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:07.412]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:07.412]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:07.412]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:07.412]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:07.412]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:07.412]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.412]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.412]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.412]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.412]  - attr(*, "resolved")= logi FALSE
[13:35:07.412]  - attr(*, "total_size")= num 97304
[13:35:07.412]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.412]  - attr(*, "already-done")= logi TRUE
[13:35:07.423] - copied ‘...future.FUN’ to environment
[13:35:07.424] - reassign environment for ‘x_FUN’
[13:35:07.424] - copied ‘x_FUN’ to environment
[13:35:07.424] - copied ‘times’ to environment
[13:35:07.424] - copied ‘stopf’ to environment
[13:35:07.424] - copied ‘stop_if_not’ to environment
[13:35:07.424] - copied ‘dim’ to environment
[13:35:07.424] - copied ‘valid_types’ to environment
[13:35:07.424] - copied ‘future.call.arguments’ to environment
[13:35:07.424] - copied ‘...future.elements_ii’ to environment
[13:35:07.424] - copied ‘...future.seeds_ii’ to environment
[13:35:07.425] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.425] assign_globals() ... done
[13:35:07.425] requestCore(): workers = 2
[13:35:07.427] MulticoreFuture started
[13:35:07.427] - Launch lazy future ... done
[13:35:07.428] run() for ‘MulticoreFuture’ ... done
[13:35:07.428] Created future:
[13:35:07.429] plan(): Setting new future strategy stack:
[13:35:07.429] List of future strategies:
[13:35:07.429] 1. sequential:
[13:35:07.429]    - args: function (..., envir = parent.frame())
[13:35:07.429]    - tweaked: FALSE
[13:35:07.429]    - call: NULL
[13:35:07.429] plan(): nbrOfWorkers() = 1
[13:35:07.432] plan(): Setting new future strategy stack:
[13:35:07.432] List of future strategies:
[13:35:07.432] 1. multicore:
[13:35:07.432]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.432]    - tweaked: FALSE
[13:35:07.432]    - call: plan(strategy)
[13:35:07.428] MulticoreFuture:
[13:35:07.428] Label: ‘future_vapply-2’
[13:35:07.428] Expression:
[13:35:07.428] {
[13:35:07.428]     do.call(function(...) {
[13:35:07.428]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.428]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.428]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.428]             on.exit(options(oopts), add = TRUE)
[13:35:07.428]         }
[13:35:07.428]         {
[13:35:07.428]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.428]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.428]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.428]             })
[13:35:07.428]         }
[13:35:07.428]     }, args = future.call.arguments)
[13:35:07.428] }
[13:35:07.428] Lazy evaluation: FALSE
[13:35:07.428] Asynchronous evaluation: TRUE
[13:35:07.428] Local evaluation: TRUE
[13:35:07.428] Environment: R_GlobalEnv
[13:35:07.428] Capture standard output: TRUE
[13:35:07.428] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.428] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:07.428] Packages: 1 packages (‘future.apply’)
[13:35:07.428] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.428] Resolved: FALSE
[13:35:07.428] Value: <not collected>
[13:35:07.428] Conditions captured: <none>
[13:35:07.428] Early signaling: FALSE
[13:35:07.428] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.428] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.441] Chunk #2 of 2 ... DONE
[13:35:07.444] plan(): nbrOfWorkers() = 2
[13:35:07.441] Launching 2 futures (chunks) ... DONE
[13:35:07.445] Resolving 2 futures (chunks) ...
[13:35:07.445] resolve() on list ...
[13:35:07.446]  recursive: 0
[13:35:07.446]  length: 2
[13:35:07.446] 
[13:35:07.447] Future #1
[13:35:07.447] result() for MulticoreFuture ...
[13:35:07.448] result() for MulticoreFuture ...
[13:35:07.448] result() for MulticoreFuture ... done
[13:35:07.448] result() for MulticoreFuture ... done
[13:35:07.449] result() for MulticoreFuture ...
[13:35:07.449] result() for MulticoreFuture ... done
[13:35:07.449] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:07.450] - nx: 2
[13:35:07.450] - relay: TRUE
[13:35:07.450] - stdout: TRUE
[13:35:07.450] - signal: TRUE
[13:35:07.451] - resignal: FALSE
[13:35:07.451] - force: TRUE
[13:35:07.451] - relayed: [n=2] FALSE, FALSE
[13:35:07.451] - queued futures: [n=2] FALSE, FALSE
[13:35:07.452]  - until=1
[13:35:07.452]  - relaying element #1
[13:35:07.452] result() for MulticoreFuture ...
[13:35:07.452] result() for MulticoreFuture ... done
[13:35:07.452] result() for MulticoreFuture ...
[13:35:07.453] result() for MulticoreFuture ... done
[13:35:07.453] result() for MulticoreFuture ...
[13:35:07.453] result() for MulticoreFuture ... done
[13:35:07.453] result() for MulticoreFuture ...
[13:35:07.454] result() for MulticoreFuture ... done
[13:35:07.454] - relayed: [n=2] TRUE, FALSE
[13:35:07.454] - queued futures: [n=2] TRUE, FALSE
[13:35:07.454] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:07.455]  length: 1 (resolved future 1)
[13:35:07.455] Future #2
[13:35:07.455] result() for MulticoreFuture ...
[13:35:07.456] result() for MulticoreFuture ...
[13:35:07.456] result() for MulticoreFuture ... done
[13:35:07.457] result() for MulticoreFuture ... done
[13:35:07.457] result() for MulticoreFuture ...
[13:35:07.457] result() for MulticoreFuture ... done
[13:35:07.457] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:07.458] - nx: 2
[13:35:07.458] - relay: TRUE
[13:35:07.458] - stdout: TRUE
[13:35:07.458] - signal: TRUE
[13:35:07.458] - resignal: FALSE
[13:35:07.458] - force: TRUE
[13:35:07.459] - relayed: [n=2] TRUE, FALSE
[13:35:07.459] - queued futures: [n=2] TRUE, FALSE
[13:35:07.459]  - until=2
[13:35:07.459]  - relaying element #2
[13:35:07.459] result() for MulticoreFuture ...
[13:35:07.459] result() for MulticoreFuture ... done
[13:35:07.460] result() for MulticoreFuture ...
[13:35:07.460] result() for MulticoreFuture ... done
[13:35:07.460] result() for MulticoreFuture ...
[13:35:07.460] result() for MulticoreFuture ... done
[13:35:07.460] result() for MulticoreFuture ...
[13:35:07.460] result() for MulticoreFuture ... done
[13:35:07.460] - relayed: [n=2] TRUE, TRUE
[13:35:07.460] - queued futures: [n=2] TRUE, TRUE
[13:35:07.461] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:07.461]  length: 0 (resolved future 2)
[13:35:07.461] Relaying remaining futures
[13:35:07.461] signalConditionsASAP(NULL, pos=0) ...
[13:35:07.461] - nx: 2
[13:35:07.461] - relay: TRUE
[13:35:07.461] - stdout: TRUE
[13:35:07.461] - signal: TRUE
[13:35:07.461] - resignal: FALSE
[13:35:07.462] - force: TRUE
[13:35:07.462] - relayed: [n=2] TRUE, TRUE
[13:35:07.462] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:07.462] - relayed: [n=2] TRUE, TRUE
[13:35:07.462] - queued futures: [n=2] TRUE, TRUE
[13:35:07.462] signalConditionsASAP(NULL, pos=0) ... done
[13:35:07.462] resolve() on list ... DONE
[13:35:07.462] result() for MulticoreFuture ...
[13:35:07.462] result() for MulticoreFuture ... done
[13:35:07.463] result() for MulticoreFuture ...
[13:35:07.463] result() for MulticoreFuture ... done
[13:35:07.463] result() for MulticoreFuture ...
[13:35:07.463] result() for MulticoreFuture ... done
[13:35:07.463] result() for MulticoreFuture ...
[13:35:07.463] result() for MulticoreFuture ... done
[13:35:07.463]  - Number of value chunks collected: 2
[13:35:07.463] Resolving 2 futures (chunks) ... DONE
[13:35:07.463] Reducing values from 2 chunks ...
[13:35:07.464]  - Number of values collected after concatenation: 10
[13:35:07.464]  - Number of values expected: 10
[13:35:07.464] Reducing values from 2 chunks ... DONE
[13:35:07.464] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[13:35:07.466] future_lapply() ...
[13:35:07.472] Number of chunks: 2
[13:35:07.472] getGlobalsAndPackagesXApply() ...
[13:35:07.472]  - future.globals: TRUE
[13:35:07.472] getGlobalsAndPackages() ...
[13:35:07.472] Searching for globals...
[13:35:07.478] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[13:35:07.479] Searching for globals ... DONE
[13:35:07.479] Resolving globals: FALSE
[13:35:07.480] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[13:35:07.480] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:07.480] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:07.480] - packages: [1] ‘future.apply’
[13:35:07.481] getGlobalsAndPackages() ... DONE
[13:35:07.481]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:07.481]  - needed namespaces: [n=1] ‘future.apply’
[13:35:07.481] Finding globals ... DONE
[13:35:07.481]  - use_args: TRUE
[13:35:07.481]  - Getting '...' globals ...
[13:35:07.481] resolve() on list ...
[13:35:07.482]  recursive: 0
[13:35:07.482]  length: 1
[13:35:07.482]  elements: ‘...’
[13:35:07.482]  length: 0 (resolved future 1)
[13:35:07.482] resolve() on list ... DONE
[13:35:07.482]    - '...' content: [n=0] 
[13:35:07.482] List of 1
[13:35:07.482]  $ ...: list()
[13:35:07.482]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.482]  - attr(*, "where")=List of 1
[13:35:07.482]   ..$ ...:<environment: 0x5574d007dd48> 
[13:35:07.482]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.482]  - attr(*, "resolved")= logi TRUE
[13:35:07.482]  - attr(*, "total_size")= num NA
[13:35:07.485]  - Getting '...' globals ... DONE
[13:35:07.485] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:07.485] List of 8
[13:35:07.485]  $ ...future.FUN:function (x, ...)  
[13:35:07.485]  $ x_FUN        :function (x)  
[13:35:07.485]  $ times        : int 4
[13:35:07.485]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.485]  $ stop_if_not  :function (...)  
[13:35:07.485]  $ dim          : int [1:2] 2 2
[13:35:07.485]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:07.485]  $ ...          : list()
[13:35:07.485]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.485]  - attr(*, "where")=List of 8
[13:35:07.485]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:07.485]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:07.485]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:07.485]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:07.485]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:07.485]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:07.485]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:07.485]   ..$ ...          :<environment: 0x5574d007dd48> 
[13:35:07.485]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.485]  - attr(*, "resolved")= logi FALSE
[13:35:07.485]  - attr(*, "total_size")= num 105552
[13:35:07.490] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:07.491] getGlobalsAndPackagesXApply() ... DONE
[13:35:07.491] Number of futures (= number of chunks): 2
[13:35:07.491] Launching 2 futures (chunks) ...
[13:35:07.491] Chunk #1 of 2 ...
[13:35:07.491]  - Finding globals in 'X' for chunk #1 ...
[13:35:07.491] getGlobalsAndPackages() ...
[13:35:07.491] Searching for globals...
[13:35:07.491] 
[13:35:07.492] Searching for globals ... DONE
[13:35:07.492] - globals: [0] <none>
[13:35:07.492] getGlobalsAndPackages() ... DONE
[13:35:07.492]    + additional globals found: [n=0] 
[13:35:07.492]    + additional namespaces needed: [n=0] 
[13:35:07.492]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:07.492]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.492]  - seeds: <none>
[13:35:07.492]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.492] getGlobalsAndPackages() ...
[13:35:07.493] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.493] Resolving globals: FALSE
[13:35:07.493] Tweak future expression to call with '...' arguments ...
[13:35:07.493] {
[13:35:07.493]     do.call(function(...) {
[13:35:07.493]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.493]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.493]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.493]             on.exit(options(oopts), add = TRUE)
[13:35:07.493]         }
[13:35:07.493]         {
[13:35:07.493]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.493]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.493]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.493]             })
[13:35:07.493]         }
[13:35:07.493]     }, args = future.call.arguments)
[13:35:07.493] }
[13:35:07.493] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.494] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.494] - packages: [1] ‘future.apply’
[13:35:07.494] getGlobalsAndPackages() ... DONE
[13:35:07.494] run() for ‘Future’ ...
[13:35:07.494] - state: ‘created’
[13:35:07.494] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.498] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.498] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.498]   - Field: ‘label’
[13:35:07.500]   - Field: ‘local’
[13:35:07.500]   - Field: ‘owner’
[13:35:07.500]   - Field: ‘envir’
[13:35:07.500]   - Field: ‘workers’
[13:35:07.500]   - Field: ‘packages’
[13:35:07.501]   - Field: ‘gc’
[13:35:07.501]   - Field: ‘job’
[13:35:07.501]   - Field: ‘conditions’
[13:35:07.501]   - Field: ‘expr’
[13:35:07.501]   - Field: ‘uuid’
[13:35:07.501]   - Field: ‘seed’
[13:35:07.501]   - Field: ‘version’
[13:35:07.501]   - Field: ‘result’
[13:35:07.501]   - Field: ‘asynchronous’
[13:35:07.501]   - Field: ‘calls’
[13:35:07.502]   - Field: ‘globals’
[13:35:07.502]   - Field: ‘stdout’
[13:35:07.502]   - Field: ‘earlySignal’
[13:35:07.502]   - Field: ‘lazy’
[13:35:07.502]   - Field: ‘state’
[13:35:07.502] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.502] - Launch lazy future ...
[13:35:07.502] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:07.503] Packages needed by future strategies (n = 0): <none>
[13:35:07.503] {
[13:35:07.503]     {
[13:35:07.503]         {
[13:35:07.503]             ...future.startTime <- base::Sys.time()
[13:35:07.503]             {
[13:35:07.503]                 {
[13:35:07.503]                   {
[13:35:07.503]                     {
[13:35:07.503]                       {
[13:35:07.503]                         base::local({
[13:35:07.503]                           has_future <- base::requireNamespace("future", 
[13:35:07.503]                             quietly = TRUE)
[13:35:07.503]                           if (has_future) {
[13:35:07.503]                             ns <- base::getNamespace("future")
[13:35:07.503]                             version <- ns[[".package"]][["version"]]
[13:35:07.503]                             if (is.null(version)) 
[13:35:07.503]                               version <- utils::packageVersion("future")
[13:35:07.503]                           }
[13:35:07.503]                           else {
[13:35:07.503]                             version <- NULL
[13:35:07.503]                           }
[13:35:07.503]                           if (!has_future || version < "1.8.0") {
[13:35:07.503]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.503]                               "", base::R.version$version.string), 
[13:35:07.503]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.503]                                 base::R.version$platform, 8 * 
[13:35:07.503]                                   base::.Machine$sizeof.pointer), 
[13:35:07.503]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.503]                                 "release", "version")], collapse = " "), 
[13:35:07.503]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.503]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.503]                               info)
[13:35:07.503]                             info <- base::paste(info, collapse = "; ")
[13:35:07.503]                             if (!has_future) {
[13:35:07.503]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.503]                                 info)
[13:35:07.503]                             }
[13:35:07.503]                             else {
[13:35:07.503]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.503]                                 info, version)
[13:35:07.503]                             }
[13:35:07.503]                             base::stop(msg)
[13:35:07.503]                           }
[13:35:07.503]                         })
[13:35:07.503]                       }
[13:35:07.503]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.503]                       base::options(mc.cores = 1L)
[13:35:07.503]                     }
[13:35:07.503]                     base::local({
[13:35:07.503]                       for (pkg in "future.apply") {
[13:35:07.503]                         base::loadNamespace(pkg)
[13:35:07.503]                         base::library(pkg, character.only = TRUE)
[13:35:07.503]                       }
[13:35:07.503]                     })
[13:35:07.503]                   }
[13:35:07.503]                   ...future.strategy.old <- future::plan("list")
[13:35:07.503]                   options(future.plan = NULL)
[13:35:07.503]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.503]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.503]                 }
[13:35:07.503]                 ...future.workdir <- getwd()
[13:35:07.503]             }
[13:35:07.503]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.503]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.503]         }
[13:35:07.503]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.503]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.503]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.503]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.503]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.503]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.503]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.503]             base::names(...future.oldOptions))
[13:35:07.503]     }
[13:35:07.503]     if (FALSE) {
[13:35:07.503]     }
[13:35:07.503]     else {
[13:35:07.503]         if (TRUE) {
[13:35:07.503]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.503]                 open = "w")
[13:35:07.503]         }
[13:35:07.503]         else {
[13:35:07.503]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.503]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.503]         }
[13:35:07.503]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.503]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.503]             base::sink(type = "output", split = FALSE)
[13:35:07.503]             base::close(...future.stdout)
[13:35:07.503]         }, add = TRUE)
[13:35:07.503]     }
[13:35:07.503]     ...future.frame <- base::sys.nframe()
[13:35:07.503]     ...future.conditions <- base::list()
[13:35:07.503]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.503]     if (FALSE) {
[13:35:07.503]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.503]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.503]     }
[13:35:07.503]     ...future.result <- base::tryCatch({
[13:35:07.503]         base::withCallingHandlers({
[13:35:07.503]             ...future.value <- base::withVisible(base::local({
[13:35:07.503]                 withCallingHandlers({
[13:35:07.503]                   {
[13:35:07.503]                     do.call(function(...) {
[13:35:07.503]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.503]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.503]                         ...future.globals.maxSize)) {
[13:35:07.503]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.503]                         on.exit(options(oopts), add = TRUE)
[13:35:07.503]                       }
[13:35:07.503]                       {
[13:35:07.503]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.503]                           FUN = function(jj) {
[13:35:07.503]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.503]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.503]                           })
[13:35:07.503]                       }
[13:35:07.503]                     }, args = future.call.arguments)
[13:35:07.503]                   }
[13:35:07.503]                 }, immediateCondition = function(cond) {
[13:35:07.503]                   save_rds <- function (object, pathname, ...) 
[13:35:07.503]                   {
[13:35:07.503]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.503]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.503]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.503]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.503]                         fi_tmp[["mtime"]])
[13:35:07.503]                     }
[13:35:07.503]                     tryCatch({
[13:35:07.503]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.503]                     }, error = function(ex) {
[13:35:07.503]                       msg <- conditionMessage(ex)
[13:35:07.503]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.503]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.503]                         fi_tmp[["mtime"]], msg)
[13:35:07.503]                       ex$message <- msg
[13:35:07.503]                       stop(ex)
[13:35:07.503]                     })
[13:35:07.503]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.503]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.503]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.503]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.503]                       fi <- file.info(pathname)
[13:35:07.503]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.503]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.503]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.503]                         fi[["size"]], fi[["mtime"]])
[13:35:07.503]                       stop(msg)
[13:35:07.503]                     }
[13:35:07.503]                     invisible(pathname)
[13:35:07.503]                   }
[13:35:07.503]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.503]                     rootPath = tempdir()) 
[13:35:07.503]                   {
[13:35:07.503]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.503]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.503]                       tmpdir = path, fileext = ".rds")
[13:35:07.503]                     save_rds(obj, file)
[13:35:07.503]                   }
[13:35:07.503]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.503]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.503]                   {
[13:35:07.503]                     inherits <- base::inherits
[13:35:07.503]                     invokeRestart <- base::invokeRestart
[13:35:07.503]                     is.null <- base::is.null
[13:35:07.503]                     muffled <- FALSE
[13:35:07.503]                     if (inherits(cond, "message")) {
[13:35:07.503]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.503]                       if (muffled) 
[13:35:07.503]                         invokeRestart("muffleMessage")
[13:35:07.503]                     }
[13:35:07.503]                     else if (inherits(cond, "warning")) {
[13:35:07.503]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.503]                       if (muffled) 
[13:35:07.503]                         invokeRestart("muffleWarning")
[13:35:07.503]                     }
[13:35:07.503]                     else if (inherits(cond, "condition")) {
[13:35:07.503]                       if (!is.null(pattern)) {
[13:35:07.503]                         computeRestarts <- base::computeRestarts
[13:35:07.503]                         grepl <- base::grepl
[13:35:07.503]                         restarts <- computeRestarts(cond)
[13:35:07.503]                         for (restart in restarts) {
[13:35:07.503]                           name <- restart$name
[13:35:07.503]                           if (is.null(name)) 
[13:35:07.503]                             next
[13:35:07.503]                           if (!grepl(pattern, name)) 
[13:35:07.503]                             next
[13:35:07.503]                           invokeRestart(restart)
[13:35:07.503]                           muffled <- TRUE
[13:35:07.503]                           break
[13:35:07.503]                         }
[13:35:07.503]                       }
[13:35:07.503]                     }
[13:35:07.503]                     invisible(muffled)
[13:35:07.503]                   }
[13:35:07.503]                   muffleCondition(cond)
[13:35:07.503]                 })
[13:35:07.503]             }))
[13:35:07.503]             future::FutureResult(value = ...future.value$value, 
[13:35:07.503]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.503]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.503]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.503]                     ...future.globalenv.names))
[13:35:07.503]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.503]         }, condition = base::local({
[13:35:07.503]             c <- base::c
[13:35:07.503]             inherits <- base::inherits
[13:35:07.503]             invokeRestart <- base::invokeRestart
[13:35:07.503]             length <- base::length
[13:35:07.503]             list <- base::list
[13:35:07.503]             seq.int <- base::seq.int
[13:35:07.503]             signalCondition <- base::signalCondition
[13:35:07.503]             sys.calls <- base::sys.calls
[13:35:07.503]             `[[` <- base::`[[`
[13:35:07.503]             `+` <- base::`+`
[13:35:07.503]             `<<-` <- base::`<<-`
[13:35:07.503]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.503]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.503]                   3L)]
[13:35:07.503]             }
[13:35:07.503]             function(cond) {
[13:35:07.503]                 is_error <- inherits(cond, "error")
[13:35:07.503]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.503]                   NULL)
[13:35:07.503]                 if (is_error) {
[13:35:07.503]                   sessionInformation <- function() {
[13:35:07.503]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.503]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.503]                       search = base::search(), system = base::Sys.info())
[13:35:07.503]                   }
[13:35:07.503]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.503]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.503]                     cond$call), session = sessionInformation(), 
[13:35:07.503]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.503]                   signalCondition(cond)
[13:35:07.503]                 }
[13:35:07.503]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.503]                 "immediateCondition"))) {
[13:35:07.503]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.503]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.503]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.503]                   if (TRUE && !signal) {
[13:35:07.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.503]                     {
[13:35:07.503]                       inherits <- base::inherits
[13:35:07.503]                       invokeRestart <- base::invokeRestart
[13:35:07.503]                       is.null <- base::is.null
[13:35:07.503]                       muffled <- FALSE
[13:35:07.503]                       if (inherits(cond, "message")) {
[13:35:07.503]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.503]                         if (muffled) 
[13:35:07.503]                           invokeRestart("muffleMessage")
[13:35:07.503]                       }
[13:35:07.503]                       else if (inherits(cond, "warning")) {
[13:35:07.503]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.503]                         if (muffled) 
[13:35:07.503]                           invokeRestart("muffleWarning")
[13:35:07.503]                       }
[13:35:07.503]                       else if (inherits(cond, "condition")) {
[13:35:07.503]                         if (!is.null(pattern)) {
[13:35:07.503]                           computeRestarts <- base::computeRestarts
[13:35:07.503]                           grepl <- base::grepl
[13:35:07.503]                           restarts <- computeRestarts(cond)
[13:35:07.503]                           for (restart in restarts) {
[13:35:07.503]                             name <- restart$name
[13:35:07.503]                             if (is.null(name)) 
[13:35:07.503]                               next
[13:35:07.503]                             if (!grepl(pattern, name)) 
[13:35:07.503]                               next
[13:35:07.503]                             invokeRestart(restart)
[13:35:07.503]                             muffled <- TRUE
[13:35:07.503]                             break
[13:35:07.503]                           }
[13:35:07.503]                         }
[13:35:07.503]                       }
[13:35:07.503]                       invisible(muffled)
[13:35:07.503]                     }
[13:35:07.503]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.503]                   }
[13:35:07.503]                 }
[13:35:07.503]                 else {
[13:35:07.503]                   if (TRUE) {
[13:35:07.503]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.503]                     {
[13:35:07.503]                       inherits <- base::inherits
[13:35:07.503]                       invokeRestart <- base::invokeRestart
[13:35:07.503]                       is.null <- base::is.null
[13:35:07.503]                       muffled <- FALSE
[13:35:07.503]                       if (inherits(cond, "message")) {
[13:35:07.503]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.503]                         if (muffled) 
[13:35:07.503]                           invokeRestart("muffleMessage")
[13:35:07.503]                       }
[13:35:07.503]                       else if (inherits(cond, "warning")) {
[13:35:07.503]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.503]                         if (muffled) 
[13:35:07.503]                           invokeRestart("muffleWarning")
[13:35:07.503]                       }
[13:35:07.503]                       else if (inherits(cond, "condition")) {
[13:35:07.503]                         if (!is.null(pattern)) {
[13:35:07.503]                           computeRestarts <- base::computeRestarts
[13:35:07.503]                           grepl <- base::grepl
[13:35:07.503]                           restarts <- computeRestarts(cond)
[13:35:07.503]                           for (restart in restarts) {
[13:35:07.503]                             name <- restart$name
[13:35:07.503]                             if (is.null(name)) 
[13:35:07.503]                               next
[13:35:07.503]                             if (!grepl(pattern, name)) 
[13:35:07.503]                               next
[13:35:07.503]                             invokeRestart(restart)
[13:35:07.503]                             muffled <- TRUE
[13:35:07.503]                             break
[13:35:07.503]                           }
[13:35:07.503]                         }
[13:35:07.503]                       }
[13:35:07.503]                       invisible(muffled)
[13:35:07.503]                     }
[13:35:07.503]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.503]                   }
[13:35:07.503]                 }
[13:35:07.503]             }
[13:35:07.503]         }))
[13:35:07.503]     }, error = function(ex) {
[13:35:07.503]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.503]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.503]                 ...future.rng), started = ...future.startTime, 
[13:35:07.503]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.503]             version = "1.8"), class = "FutureResult")
[13:35:07.503]     }, finally = {
[13:35:07.503]         if (!identical(...future.workdir, getwd())) 
[13:35:07.503]             setwd(...future.workdir)
[13:35:07.503]         {
[13:35:07.503]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.503]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.503]             }
[13:35:07.503]             base::options(...future.oldOptions)
[13:35:07.503]             if (.Platform$OS.type == "windows") {
[13:35:07.503]                 old_names <- names(...future.oldEnvVars)
[13:35:07.503]                 envs <- base::Sys.getenv()
[13:35:07.503]                 names <- names(envs)
[13:35:07.503]                 common <- intersect(names, old_names)
[13:35:07.503]                 added <- setdiff(names, old_names)
[13:35:07.503]                 removed <- setdiff(old_names, names)
[13:35:07.503]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.503]                   envs[common]]
[13:35:07.503]                 NAMES <- toupper(changed)
[13:35:07.503]                 args <- list()
[13:35:07.503]                 for (kk in seq_along(NAMES)) {
[13:35:07.503]                   name <- changed[[kk]]
[13:35:07.503]                   NAME <- NAMES[[kk]]
[13:35:07.503]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.503]                     next
[13:35:07.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.503]                 }
[13:35:07.503]                 NAMES <- toupper(added)
[13:35:07.503]                 for (kk in seq_along(NAMES)) {
[13:35:07.503]                   name <- added[[kk]]
[13:35:07.503]                   NAME <- NAMES[[kk]]
[13:35:07.503]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.503]                     next
[13:35:07.503]                   args[[name]] <- ""
[13:35:07.503]                 }
[13:35:07.503]                 NAMES <- toupper(removed)
[13:35:07.503]                 for (kk in seq_along(NAMES)) {
[13:35:07.503]                   name <- removed[[kk]]
[13:35:07.503]                   NAME <- NAMES[[kk]]
[13:35:07.503]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.503]                     next
[13:35:07.503]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.503]                 }
[13:35:07.503]                 if (length(args) > 0) 
[13:35:07.503]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.503]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.503]             }
[13:35:07.503]             else {
[13:35:07.503]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.503]             }
[13:35:07.503]             {
[13:35:07.503]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.503]                   0L) {
[13:35:07.503]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.503]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.503]                   base::options(opts)
[13:35:07.503]                 }
[13:35:07.503]                 {
[13:35:07.503]                   {
[13:35:07.503]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.503]                     NULL
[13:35:07.503]                   }
[13:35:07.503]                   options(future.plan = NULL)
[13:35:07.503]                   if (is.na(NA_character_)) 
[13:35:07.503]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.503]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.503]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.503]                     .init = FALSE)
[13:35:07.503]                 }
[13:35:07.503]             }
[13:35:07.503]         }
[13:35:07.503]     })
[13:35:07.503]     if (TRUE) {
[13:35:07.503]         base::sink(type = "output", split = FALSE)
[13:35:07.503]         if (TRUE) {
[13:35:07.503]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.503]         }
[13:35:07.503]         else {
[13:35:07.503]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.503]         }
[13:35:07.503]         base::close(...future.stdout)
[13:35:07.503]         ...future.stdout <- NULL
[13:35:07.503]     }
[13:35:07.503]     ...future.result$conditions <- ...future.conditions
[13:35:07.503]     ...future.result$finished <- base::Sys.time()
[13:35:07.503]     ...future.result
[13:35:07.503] }
[13:35:07.505] assign_globals() ...
[13:35:07.506] List of 11
[13:35:07.506]  $ ...future.FUN            :function (x, ...)  
[13:35:07.506]  $ x_FUN                    :function (x)  
[13:35:07.506]  $ times                    : int 4
[13:35:07.506]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.506]  $ stop_if_not              :function (...)  
[13:35:07.506]  $ dim                      : int [1:2] 2 2
[13:35:07.506]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:07.506]  $ future.call.arguments    : list()
[13:35:07.506]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.506]  $ ...future.elements_ii    :List of 5
[13:35:07.506]   ..$ : int 1
[13:35:07.506]   ..$ : int 2
[13:35:07.506]   ..$ : int 3
[13:35:07.506]   ..$ : int 4
[13:35:07.506]   ..$ : int 5
[13:35:07.506]  $ ...future.seeds_ii       : NULL
[13:35:07.506]  $ ...future.globals.maxSize: NULL
[13:35:07.506]  - attr(*, "where")=List of 11
[13:35:07.506]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.506]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:07.506]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:07.506]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:07.506]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:07.506]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:07.506]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:07.506]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.506]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.506]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.506]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.506]  - attr(*, "resolved")= logi FALSE
[13:35:07.506]  - attr(*, "total_size")= num 105552
[13:35:07.506]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.506]  - attr(*, "already-done")= logi TRUE
[13:35:07.514] - copied ‘...future.FUN’ to environment
[13:35:07.514] - reassign environment for ‘x_FUN’
[13:35:07.514] - copied ‘x_FUN’ to environment
[13:35:07.514] - copied ‘times’ to environment
[13:35:07.515] - copied ‘stopf’ to environment
[13:35:07.515] - copied ‘stop_if_not’ to environment
[13:35:07.515] - copied ‘dim’ to environment
[13:35:07.515] - copied ‘valid_types’ to environment
[13:35:07.515] - copied ‘future.call.arguments’ to environment
[13:35:07.515] - copied ‘...future.elements_ii’ to environment
[13:35:07.515] - copied ‘...future.seeds_ii’ to environment
[13:35:07.515] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.515] assign_globals() ... done
[13:35:07.515] requestCore(): workers = 2
[13:35:07.517] MulticoreFuture started
[13:35:07.518] - Launch lazy future ... done
[13:35:07.518] run() for ‘MulticoreFuture’ ... done
[13:35:07.518] Created future:
[13:35:07.519] plan(): Setting new future strategy stack:
[13:35:07.519] List of future strategies:
[13:35:07.519] 1. sequential:
[13:35:07.519]    - args: function (..., envir = parent.frame())
[13:35:07.519]    - tweaked: FALSE
[13:35:07.519]    - call: NULL
[13:35:07.520] plan(): nbrOfWorkers() = 1
[13:35:07.522] plan(): Setting new future strategy stack:
[13:35:07.522] List of future strategies:
[13:35:07.522] 1. multicore:
[13:35:07.522]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.522]    - tweaked: FALSE
[13:35:07.522]    - call: plan(strategy)
[13:35:07.527] plan(): nbrOfWorkers() = 2
[13:35:07.518] MulticoreFuture:
[13:35:07.518] Label: ‘future_vapply-1’
[13:35:07.518] Expression:
[13:35:07.518] {
[13:35:07.518]     do.call(function(...) {
[13:35:07.518]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.518]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.518]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.518]             on.exit(options(oopts), add = TRUE)
[13:35:07.518]         }
[13:35:07.518]         {
[13:35:07.518]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.518]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.518]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.518]             })
[13:35:07.518]         }
[13:35:07.518]     }, args = future.call.arguments)
[13:35:07.518] }
[13:35:07.518] Lazy evaluation: FALSE
[13:35:07.518] Asynchronous evaluation: TRUE
[13:35:07.518] Local evaluation: TRUE
[13:35:07.518] Environment: R_GlobalEnv
[13:35:07.518] Capture standard output: TRUE
[13:35:07.518] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.518] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:07.518] Packages: 1 packages (‘future.apply’)
[13:35:07.518] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.518] Resolved: TRUE
[13:35:07.518] Value: <not collected>
[13:35:07.518] Conditions captured: <none>
[13:35:07.518] Early signaling: FALSE
[13:35:07.518] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.518] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.528] Chunk #1 of 2 ... DONE
[13:35:07.528] Chunk #2 of 2 ...
[13:35:07.529]  - Finding globals in 'X' for chunk #2 ...
[13:35:07.529] getGlobalsAndPackages() ...
[13:35:07.529] Searching for globals...
[13:35:07.529] 
[13:35:07.530] Searching for globals ... DONE
[13:35:07.530] - globals: [0] <none>
[13:35:07.530] getGlobalsAndPackages() ... DONE
[13:35:07.530]    + additional globals found: [n=0] 
[13:35:07.530]    + additional namespaces needed: [n=0] 
[13:35:07.530]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:07.530]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.530]  - seeds: <none>
[13:35:07.531]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.531] getGlobalsAndPackages() ...
[13:35:07.531] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.531] Resolving globals: FALSE
[13:35:07.531] Tweak future expression to call with '...' arguments ...
[13:35:07.531] {
[13:35:07.531]     do.call(function(...) {
[13:35:07.531]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.531]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.531]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.531]             on.exit(options(oopts), add = TRUE)
[13:35:07.531]         }
[13:35:07.531]         {
[13:35:07.531]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.531]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.531]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.531]             })
[13:35:07.531]         }
[13:35:07.531]     }, args = future.call.arguments)
[13:35:07.531] }
[13:35:07.532] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.537] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.537] - packages: [1] ‘future.apply’
[13:35:07.537] getGlobalsAndPackages() ... DONE
[13:35:07.538] run() for ‘Future’ ...
[13:35:07.539] - state: ‘created’
[13:35:07.539] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.545] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.545] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.545]   - Field: ‘label’
[13:35:07.546]   - Field: ‘local’
[13:35:07.546]   - Field: ‘owner’
[13:35:07.546]   - Field: ‘envir’
[13:35:07.546]   - Field: ‘workers’
[13:35:07.546]   - Field: ‘packages’
[13:35:07.547]   - Field: ‘gc’
[13:35:07.547]   - Field: ‘job’
[13:35:07.547]   - Field: ‘conditions’
[13:35:07.547]   - Field: ‘expr’
[13:35:07.548]   - Field: ‘uuid’
[13:35:07.548]   - Field: ‘seed’
[13:35:07.548]   - Field: ‘version’
[13:35:07.548]   - Field: ‘result’
[13:35:07.548]   - Field: ‘asynchronous’
[13:35:07.549]   - Field: ‘calls’
[13:35:07.549]   - Field: ‘globals’
[13:35:07.549]   - Field: ‘stdout’
[13:35:07.549]   - Field: ‘earlySignal’
[13:35:07.549]   - Field: ‘lazy’
[13:35:07.550]   - Field: ‘state’
[13:35:07.550] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.550] - Launch lazy future ...
[13:35:07.550] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:07.551] Packages needed by future strategies (n = 0): <none>
[13:35:07.551] {
[13:35:07.551]     {
[13:35:07.551]         {
[13:35:07.551]             ...future.startTime <- base::Sys.time()
[13:35:07.551]             {
[13:35:07.551]                 {
[13:35:07.551]                   {
[13:35:07.551]                     {
[13:35:07.551]                       {
[13:35:07.551]                         base::local({
[13:35:07.551]                           has_future <- base::requireNamespace("future", 
[13:35:07.551]                             quietly = TRUE)
[13:35:07.551]                           if (has_future) {
[13:35:07.551]                             ns <- base::getNamespace("future")
[13:35:07.551]                             version <- ns[[".package"]][["version"]]
[13:35:07.551]                             if (is.null(version)) 
[13:35:07.551]                               version <- utils::packageVersion("future")
[13:35:07.551]                           }
[13:35:07.551]                           else {
[13:35:07.551]                             version <- NULL
[13:35:07.551]                           }
[13:35:07.551]                           if (!has_future || version < "1.8.0") {
[13:35:07.551]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.551]                               "", base::R.version$version.string), 
[13:35:07.551]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.551]                                 base::R.version$platform, 8 * 
[13:35:07.551]                                   base::.Machine$sizeof.pointer), 
[13:35:07.551]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.551]                                 "release", "version")], collapse = " "), 
[13:35:07.551]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.551]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.551]                               info)
[13:35:07.551]                             info <- base::paste(info, collapse = "; ")
[13:35:07.551]                             if (!has_future) {
[13:35:07.551]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.551]                                 info)
[13:35:07.551]                             }
[13:35:07.551]                             else {
[13:35:07.551]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.551]                                 info, version)
[13:35:07.551]                             }
[13:35:07.551]                             base::stop(msg)
[13:35:07.551]                           }
[13:35:07.551]                         })
[13:35:07.551]                       }
[13:35:07.551]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.551]                       base::options(mc.cores = 1L)
[13:35:07.551]                     }
[13:35:07.551]                     base::local({
[13:35:07.551]                       for (pkg in "future.apply") {
[13:35:07.551]                         base::loadNamespace(pkg)
[13:35:07.551]                         base::library(pkg, character.only = TRUE)
[13:35:07.551]                       }
[13:35:07.551]                     })
[13:35:07.551]                   }
[13:35:07.551]                   ...future.strategy.old <- future::plan("list")
[13:35:07.551]                   options(future.plan = NULL)
[13:35:07.551]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.551]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.551]                 }
[13:35:07.551]                 ...future.workdir <- getwd()
[13:35:07.551]             }
[13:35:07.551]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.551]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.551]         }
[13:35:07.551]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.551]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.551]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.551]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.551]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.551]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.551]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.551]             base::names(...future.oldOptions))
[13:35:07.551]     }
[13:35:07.551]     if (FALSE) {
[13:35:07.551]     }
[13:35:07.551]     else {
[13:35:07.551]         if (TRUE) {
[13:35:07.551]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.551]                 open = "w")
[13:35:07.551]         }
[13:35:07.551]         else {
[13:35:07.551]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.551]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.551]         }
[13:35:07.551]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.551]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.551]             base::sink(type = "output", split = FALSE)
[13:35:07.551]             base::close(...future.stdout)
[13:35:07.551]         }, add = TRUE)
[13:35:07.551]     }
[13:35:07.551]     ...future.frame <- base::sys.nframe()
[13:35:07.551]     ...future.conditions <- base::list()
[13:35:07.551]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.551]     if (FALSE) {
[13:35:07.551]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.551]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.551]     }
[13:35:07.551]     ...future.result <- base::tryCatch({
[13:35:07.551]         base::withCallingHandlers({
[13:35:07.551]             ...future.value <- base::withVisible(base::local({
[13:35:07.551]                 withCallingHandlers({
[13:35:07.551]                   {
[13:35:07.551]                     do.call(function(...) {
[13:35:07.551]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.551]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.551]                         ...future.globals.maxSize)) {
[13:35:07.551]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.551]                         on.exit(options(oopts), add = TRUE)
[13:35:07.551]                       }
[13:35:07.551]                       {
[13:35:07.551]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.551]                           FUN = function(jj) {
[13:35:07.551]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.551]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.551]                           })
[13:35:07.551]                       }
[13:35:07.551]                     }, args = future.call.arguments)
[13:35:07.551]                   }
[13:35:07.551]                 }, immediateCondition = function(cond) {
[13:35:07.551]                   save_rds <- function (object, pathname, ...) 
[13:35:07.551]                   {
[13:35:07.551]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.551]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.551]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.551]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.551]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.551]                         fi_tmp[["mtime"]])
[13:35:07.551]                     }
[13:35:07.551]                     tryCatch({
[13:35:07.551]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.551]                     }, error = function(ex) {
[13:35:07.551]                       msg <- conditionMessage(ex)
[13:35:07.551]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.551]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.551]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.551]                         fi_tmp[["mtime"]], msg)
[13:35:07.551]                       ex$message <- msg
[13:35:07.551]                       stop(ex)
[13:35:07.551]                     })
[13:35:07.551]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.551]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.551]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.551]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.551]                       fi <- file.info(pathname)
[13:35:07.551]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.551]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.551]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.551]                         fi[["size"]], fi[["mtime"]])
[13:35:07.551]                       stop(msg)
[13:35:07.551]                     }
[13:35:07.551]                     invisible(pathname)
[13:35:07.551]                   }
[13:35:07.551]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.551]                     rootPath = tempdir()) 
[13:35:07.551]                   {
[13:35:07.551]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.551]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.551]                       tmpdir = path, fileext = ".rds")
[13:35:07.551]                     save_rds(obj, file)
[13:35:07.551]                   }
[13:35:07.551]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.551]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.551]                   {
[13:35:07.551]                     inherits <- base::inherits
[13:35:07.551]                     invokeRestart <- base::invokeRestart
[13:35:07.551]                     is.null <- base::is.null
[13:35:07.551]                     muffled <- FALSE
[13:35:07.551]                     if (inherits(cond, "message")) {
[13:35:07.551]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.551]                       if (muffled) 
[13:35:07.551]                         invokeRestart("muffleMessage")
[13:35:07.551]                     }
[13:35:07.551]                     else if (inherits(cond, "warning")) {
[13:35:07.551]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.551]                       if (muffled) 
[13:35:07.551]                         invokeRestart("muffleWarning")
[13:35:07.551]                     }
[13:35:07.551]                     else if (inherits(cond, "condition")) {
[13:35:07.551]                       if (!is.null(pattern)) {
[13:35:07.551]                         computeRestarts <- base::computeRestarts
[13:35:07.551]                         grepl <- base::grepl
[13:35:07.551]                         restarts <- computeRestarts(cond)
[13:35:07.551]                         for (restart in restarts) {
[13:35:07.551]                           name <- restart$name
[13:35:07.551]                           if (is.null(name)) 
[13:35:07.551]                             next
[13:35:07.551]                           if (!grepl(pattern, name)) 
[13:35:07.551]                             next
[13:35:07.551]                           invokeRestart(restart)
[13:35:07.551]                           muffled <- TRUE
[13:35:07.551]                           break
[13:35:07.551]                         }
[13:35:07.551]                       }
[13:35:07.551]                     }
[13:35:07.551]                     invisible(muffled)
[13:35:07.551]                   }
[13:35:07.551]                   muffleCondition(cond)
[13:35:07.551]                 })
[13:35:07.551]             }))
[13:35:07.551]             future::FutureResult(value = ...future.value$value, 
[13:35:07.551]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.551]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.551]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.551]                     ...future.globalenv.names))
[13:35:07.551]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.551]         }, condition = base::local({
[13:35:07.551]             c <- base::c
[13:35:07.551]             inherits <- base::inherits
[13:35:07.551]             invokeRestart <- base::invokeRestart
[13:35:07.551]             length <- base::length
[13:35:07.551]             list <- base::list
[13:35:07.551]             seq.int <- base::seq.int
[13:35:07.551]             signalCondition <- base::signalCondition
[13:35:07.551]             sys.calls <- base::sys.calls
[13:35:07.551]             `[[` <- base::`[[`
[13:35:07.551]             `+` <- base::`+`
[13:35:07.551]             `<<-` <- base::`<<-`
[13:35:07.551]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.551]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.551]                   3L)]
[13:35:07.551]             }
[13:35:07.551]             function(cond) {
[13:35:07.551]                 is_error <- inherits(cond, "error")
[13:35:07.551]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.551]                   NULL)
[13:35:07.551]                 if (is_error) {
[13:35:07.551]                   sessionInformation <- function() {
[13:35:07.551]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.551]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.551]                       search = base::search(), system = base::Sys.info())
[13:35:07.551]                   }
[13:35:07.551]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.551]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.551]                     cond$call), session = sessionInformation(), 
[13:35:07.551]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.551]                   signalCondition(cond)
[13:35:07.551]                 }
[13:35:07.551]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.551]                 "immediateCondition"))) {
[13:35:07.551]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.551]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.551]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.551]                   if (TRUE && !signal) {
[13:35:07.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.551]                     {
[13:35:07.551]                       inherits <- base::inherits
[13:35:07.551]                       invokeRestart <- base::invokeRestart
[13:35:07.551]                       is.null <- base::is.null
[13:35:07.551]                       muffled <- FALSE
[13:35:07.551]                       if (inherits(cond, "message")) {
[13:35:07.551]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.551]                         if (muffled) 
[13:35:07.551]                           invokeRestart("muffleMessage")
[13:35:07.551]                       }
[13:35:07.551]                       else if (inherits(cond, "warning")) {
[13:35:07.551]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.551]                         if (muffled) 
[13:35:07.551]                           invokeRestart("muffleWarning")
[13:35:07.551]                       }
[13:35:07.551]                       else if (inherits(cond, "condition")) {
[13:35:07.551]                         if (!is.null(pattern)) {
[13:35:07.551]                           computeRestarts <- base::computeRestarts
[13:35:07.551]                           grepl <- base::grepl
[13:35:07.551]                           restarts <- computeRestarts(cond)
[13:35:07.551]                           for (restart in restarts) {
[13:35:07.551]                             name <- restart$name
[13:35:07.551]                             if (is.null(name)) 
[13:35:07.551]                               next
[13:35:07.551]                             if (!grepl(pattern, name)) 
[13:35:07.551]                               next
[13:35:07.551]                             invokeRestart(restart)
[13:35:07.551]                             muffled <- TRUE
[13:35:07.551]                             break
[13:35:07.551]                           }
[13:35:07.551]                         }
[13:35:07.551]                       }
[13:35:07.551]                       invisible(muffled)
[13:35:07.551]                     }
[13:35:07.551]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.551]                   }
[13:35:07.551]                 }
[13:35:07.551]                 else {
[13:35:07.551]                   if (TRUE) {
[13:35:07.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.551]                     {
[13:35:07.551]                       inherits <- base::inherits
[13:35:07.551]                       invokeRestart <- base::invokeRestart
[13:35:07.551]                       is.null <- base::is.null
[13:35:07.551]                       muffled <- FALSE
[13:35:07.551]                       if (inherits(cond, "message")) {
[13:35:07.551]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.551]                         if (muffled) 
[13:35:07.551]                           invokeRestart("muffleMessage")
[13:35:07.551]                       }
[13:35:07.551]                       else if (inherits(cond, "warning")) {
[13:35:07.551]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.551]                         if (muffled) 
[13:35:07.551]                           invokeRestart("muffleWarning")
[13:35:07.551]                       }
[13:35:07.551]                       else if (inherits(cond, "condition")) {
[13:35:07.551]                         if (!is.null(pattern)) {
[13:35:07.551]                           computeRestarts <- base::computeRestarts
[13:35:07.551]                           grepl <- base::grepl
[13:35:07.551]                           restarts <- computeRestarts(cond)
[13:35:07.551]                           for (restart in restarts) {
[13:35:07.551]                             name <- restart$name
[13:35:07.551]                             if (is.null(name)) 
[13:35:07.551]                               next
[13:35:07.551]                             if (!grepl(pattern, name)) 
[13:35:07.551]                               next
[13:35:07.551]                             invokeRestart(restart)
[13:35:07.551]                             muffled <- TRUE
[13:35:07.551]                             break
[13:35:07.551]                           }
[13:35:07.551]                         }
[13:35:07.551]                       }
[13:35:07.551]                       invisible(muffled)
[13:35:07.551]                     }
[13:35:07.551]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.551]                   }
[13:35:07.551]                 }
[13:35:07.551]             }
[13:35:07.551]         }))
[13:35:07.551]     }, error = function(ex) {
[13:35:07.551]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.551]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.551]                 ...future.rng), started = ...future.startTime, 
[13:35:07.551]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.551]             version = "1.8"), class = "FutureResult")
[13:35:07.551]     }, finally = {
[13:35:07.551]         if (!identical(...future.workdir, getwd())) 
[13:35:07.551]             setwd(...future.workdir)
[13:35:07.551]         {
[13:35:07.551]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.551]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.551]             }
[13:35:07.551]             base::options(...future.oldOptions)
[13:35:07.551]             if (.Platform$OS.type == "windows") {
[13:35:07.551]                 old_names <- names(...future.oldEnvVars)
[13:35:07.551]                 envs <- base::Sys.getenv()
[13:35:07.551]                 names <- names(envs)
[13:35:07.551]                 common <- intersect(names, old_names)
[13:35:07.551]                 added <- setdiff(names, old_names)
[13:35:07.551]                 removed <- setdiff(old_names, names)
[13:35:07.551]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.551]                   envs[common]]
[13:35:07.551]                 NAMES <- toupper(changed)
[13:35:07.551]                 args <- list()
[13:35:07.551]                 for (kk in seq_along(NAMES)) {
[13:35:07.551]                   name <- changed[[kk]]
[13:35:07.551]                   NAME <- NAMES[[kk]]
[13:35:07.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.551]                     next
[13:35:07.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.551]                 }
[13:35:07.551]                 NAMES <- toupper(added)
[13:35:07.551]                 for (kk in seq_along(NAMES)) {
[13:35:07.551]                   name <- added[[kk]]
[13:35:07.551]                   NAME <- NAMES[[kk]]
[13:35:07.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.551]                     next
[13:35:07.551]                   args[[name]] <- ""
[13:35:07.551]                 }
[13:35:07.551]                 NAMES <- toupper(removed)
[13:35:07.551]                 for (kk in seq_along(NAMES)) {
[13:35:07.551]                   name <- removed[[kk]]
[13:35:07.551]                   NAME <- NAMES[[kk]]
[13:35:07.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.551]                     next
[13:35:07.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.551]                 }
[13:35:07.551]                 if (length(args) > 0) 
[13:35:07.551]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.551]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.551]             }
[13:35:07.551]             else {
[13:35:07.551]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.551]             }
[13:35:07.551]             {
[13:35:07.551]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.551]                   0L) {
[13:35:07.551]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.551]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.551]                   base::options(opts)
[13:35:07.551]                 }
[13:35:07.551]                 {
[13:35:07.551]                   {
[13:35:07.551]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.551]                     NULL
[13:35:07.551]                   }
[13:35:07.551]                   options(future.plan = NULL)
[13:35:07.551]                   if (is.na(NA_character_)) 
[13:35:07.551]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.551]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.551]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.551]                     .init = FALSE)
[13:35:07.551]                 }
[13:35:07.551]             }
[13:35:07.551]         }
[13:35:07.551]     })
[13:35:07.551]     if (TRUE) {
[13:35:07.551]         base::sink(type = "output", split = FALSE)
[13:35:07.551]         if (TRUE) {
[13:35:07.551]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.551]         }
[13:35:07.551]         else {
[13:35:07.551]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.551]         }
[13:35:07.551]         base::close(...future.stdout)
[13:35:07.551]         ...future.stdout <- NULL
[13:35:07.551]     }
[13:35:07.551]     ...future.result$conditions <- ...future.conditions
[13:35:07.551]     ...future.result$finished <- base::Sys.time()
[13:35:07.551]     ...future.result
[13:35:07.551] }
[13:35:07.554] assign_globals() ...
[13:35:07.554] List of 11
[13:35:07.554]  $ ...future.FUN            :function (x, ...)  
[13:35:07.554]  $ x_FUN                    :function (x)  
[13:35:07.554]  $ times                    : int 4
[13:35:07.554]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.554]  $ stop_if_not              :function (...)  
[13:35:07.554]  $ dim                      : int [1:2] 2 2
[13:35:07.554]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:07.554]  $ future.call.arguments    : list()
[13:35:07.554]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.554]  $ ...future.elements_ii    :List of 5
[13:35:07.554]   ..$ : int 6
[13:35:07.554]   ..$ : int 7
[13:35:07.554]   ..$ : int 8
[13:35:07.554]   ..$ : int 9
[13:35:07.554]   ..$ : int 10
[13:35:07.554]  $ ...future.seeds_ii       : NULL
[13:35:07.554]  $ ...future.globals.maxSize: NULL
[13:35:07.554]  - attr(*, "where")=List of 11
[13:35:07.554]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.554]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:07.554]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:07.554]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:07.554]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:07.554]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:07.554]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:07.554]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.554]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.554]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.554]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.554]  - attr(*, "resolved")= logi FALSE
[13:35:07.554]  - attr(*, "total_size")= num 105552
[13:35:07.554]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.554]  - attr(*, "already-done")= logi TRUE
[13:35:07.565] - copied ‘...future.FUN’ to environment
[13:35:07.565] - reassign environment for ‘x_FUN’
[13:35:07.565] - copied ‘x_FUN’ to environment
[13:35:07.565] - copied ‘times’ to environment
[13:35:07.565] - copied ‘stopf’ to environment
[13:35:07.566] - copied ‘stop_if_not’ to environment
[13:35:07.566] - copied ‘dim’ to environment
[13:35:07.566] - copied ‘valid_types’ to environment
[13:35:07.566] - copied ‘future.call.arguments’ to environment
[13:35:07.566] - copied ‘...future.elements_ii’ to environment
[13:35:07.566] - copied ‘...future.seeds_ii’ to environment
[13:35:07.566] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.566] assign_globals() ... done
[13:35:07.566] requestCore(): workers = 2
[13:35:07.568] MulticoreFuture started
[13:35:07.569] - Launch lazy future ... done
[13:35:07.569] run() for ‘MulticoreFuture’ ... done
[13:35:07.569] Created future:
[13:35:07.570] plan(): Setting new future strategy stack:
[13:35:07.570] List of future strategies:
[13:35:07.570] 1. sequential:
[13:35:07.570]    - args: function (..., envir = parent.frame())
[13:35:07.570]    - tweaked: FALSE
[13:35:07.570]    - call: NULL
[13:35:07.571] plan(): nbrOfWorkers() = 1
[13:35:07.576] plan(): Setting new future strategy stack:
[13:35:07.576] List of future strategies:
[13:35:07.576] 1. multicore:
[13:35:07.576]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.576]    - tweaked: FALSE
[13:35:07.576]    - call: plan(strategy)
[13:35:07.583] plan(): nbrOfWorkers() = 2
[13:35:07.569] MulticoreFuture:
[13:35:07.569] Label: ‘future_vapply-2’
[13:35:07.569] Expression:
[13:35:07.569] {
[13:35:07.569]     do.call(function(...) {
[13:35:07.569]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.569]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.569]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.569]             on.exit(options(oopts), add = TRUE)
[13:35:07.569]         }
[13:35:07.569]         {
[13:35:07.569]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.569]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.569]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.569]             })
[13:35:07.569]         }
[13:35:07.569]     }, args = future.call.arguments)
[13:35:07.569] }
[13:35:07.569] Lazy evaluation: FALSE
[13:35:07.569] Asynchronous evaluation: TRUE
[13:35:07.569] Local evaluation: TRUE
[13:35:07.569] Environment: R_GlobalEnv
[13:35:07.569] Capture standard output: TRUE
[13:35:07.569] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.569] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:07.569] Packages: 1 packages (‘future.apply’)
[13:35:07.569] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.569] Resolved: TRUE
[13:35:07.569] Value: <not collected>
[13:35:07.569] Conditions captured: <none>
[13:35:07.569] Early signaling: FALSE
[13:35:07.569] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.569] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.585] Chunk #2 of 2 ... DONE
[13:35:07.585] Launching 2 futures (chunks) ... DONE
[13:35:07.585] Resolving 2 futures (chunks) ...
[13:35:07.585] resolve() on list ...
[13:35:07.586]  recursive: 0
[13:35:07.586]  length: 2
[13:35:07.586] 
[13:35:07.587] Future #1
[13:35:07.587] result() for MulticoreFuture ...
[13:35:07.588] result() for MulticoreFuture ...
[13:35:07.588] result() for MulticoreFuture ... done
[13:35:07.588] result() for MulticoreFuture ... done
[13:35:07.589] result() for MulticoreFuture ...
[13:35:07.589] result() for MulticoreFuture ... done
[13:35:07.589] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:07.589] - nx: 2
[13:35:07.590] - relay: TRUE
[13:35:07.590] - stdout: TRUE
[13:35:07.590] - signal: TRUE
[13:35:07.590] - resignal: FALSE
[13:35:07.590] - force: TRUE
[13:35:07.591] - relayed: [n=2] FALSE, FALSE
[13:35:07.591] - queued futures: [n=2] FALSE, FALSE
[13:35:07.591]  - until=1
[13:35:07.592]  - relaying element #1
[13:35:07.592] result() for MulticoreFuture ...
[13:35:07.592] result() for MulticoreFuture ... done
[13:35:07.593] result() for MulticoreFuture ...
[13:35:07.593] result() for MulticoreFuture ... done
[13:35:07.594] result() for MulticoreFuture ...
[13:35:07.594] result() for MulticoreFuture ... done
[13:35:07.595] result() for MulticoreFuture ...
[13:35:07.595] result() for MulticoreFuture ... done
[13:35:07.595] - relayed: [n=2] TRUE, FALSE
[13:35:07.596] - queued futures: [n=2] TRUE, FALSE
[13:35:07.596] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:07.596]  length: 1 (resolved future 1)
[13:35:07.597] Future #2
[13:35:07.597] result() for MulticoreFuture ...
[13:35:07.598] result() for MulticoreFuture ...
[13:35:07.599] result() for MulticoreFuture ... done
[13:35:07.599] result() for MulticoreFuture ... done
[13:35:07.599] result() for MulticoreFuture ...
[13:35:07.600] result() for MulticoreFuture ... done
[13:35:07.600] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:07.600] - nx: 2
[13:35:07.600] - relay: TRUE
[13:35:07.600] - stdout: TRUE
[13:35:07.601] - signal: TRUE
[13:35:07.601] - resignal: FALSE
[13:35:07.601] - force: TRUE
[13:35:07.601] - relayed: [n=2] TRUE, FALSE
[13:35:07.601] - queued futures: [n=2] TRUE, FALSE
[13:35:07.602]  - until=2
[13:35:07.602]  - relaying element #2
[13:35:07.602] result() for MulticoreFuture ...
[13:35:07.602] result() for MulticoreFuture ... done
[13:35:07.603] result() for MulticoreFuture ...
[13:35:07.603] result() for MulticoreFuture ... done
[13:35:07.603] result() for MulticoreFuture ...
[13:35:07.603] result() for MulticoreFuture ... done
[13:35:07.603] result() for MulticoreFuture ...
[13:35:07.604] result() for MulticoreFuture ... done
[13:35:07.604] - relayed: [n=2] TRUE, TRUE
[13:35:07.604] - queued futures: [n=2] TRUE, TRUE
[13:35:07.604] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:07.604]  length: 0 (resolved future 2)
[13:35:07.605] Relaying remaining futures
[13:35:07.605] signalConditionsASAP(NULL, pos=0) ...
[13:35:07.605] - nx: 2
[13:35:07.605] - relay: TRUE
[13:35:07.605] - stdout: TRUE
[13:35:07.606] - signal: TRUE
[13:35:07.606] - resignal: FALSE
[13:35:07.606] - force: TRUE
[13:35:07.606] - relayed: [n=2] TRUE, TRUE
[13:35:07.606] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:07.607] - relayed: [n=2] TRUE, TRUE
[13:35:07.607] - queued futures: [n=2] TRUE, TRUE
[13:35:07.607] signalConditionsASAP(NULL, pos=0) ... done
[13:35:07.607] resolve() on list ... DONE
[13:35:07.607] result() for MulticoreFuture ...
[13:35:07.608] result() for MulticoreFuture ... done
[13:35:07.608] result() for MulticoreFuture ...
[13:35:07.608] result() for MulticoreFuture ... done
[13:35:07.608] result() for MulticoreFuture ...
[13:35:07.608] result() for MulticoreFuture ... done
[13:35:07.609] result() for MulticoreFuture ...
[13:35:07.609] result() for MulticoreFuture ... done
[13:35:07.609]  - Number of value chunks collected: 2
[13:35:07.609] Resolving 2 futures (chunks) ... DONE
[13:35:07.609] Reducing values from 2 chunks ...
[13:35:07.610]  - Number of values collected after concatenation: 10
[13:35:07.610]  - Number of values expected: 10
[13:35:07.610] Reducing values from 2 chunks ... DONE
[13:35:07.610] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[13:35:07.615] future_lapply() ...
[13:35:07.623] Number of chunks: 2
[13:35:07.623] getGlobalsAndPackagesXApply() ...
[13:35:07.624]  - future.globals: TRUE
[13:35:07.624] getGlobalsAndPackages() ...
[13:35:07.624] Searching for globals...
[13:35:07.633] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[13:35:07.634] Searching for globals ... DONE
[13:35:07.634] Resolving globals: FALSE
[13:35:07.635] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[13:35:07.636] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:07.636] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:07.636] - packages: [2] ‘stats’, ‘future.apply’
[13:35:07.636] getGlobalsAndPackages() ... DONE
[13:35:07.637]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:07.637]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:35:07.637] Finding globals ... DONE
[13:35:07.637]  - use_args: TRUE
[13:35:07.637]  - Getting '...' globals ...
[13:35:07.638] resolve() on list ...
[13:35:07.638]  recursive: 0
[13:35:07.638]  length: 1
[13:35:07.638]  elements: ‘...’
[13:35:07.638]  length: 0 (resolved future 1)
[13:35:07.638] resolve() on list ... DONE
[13:35:07.639]    - '...' content: [n=0] 
[13:35:07.639] List of 1
[13:35:07.639]  $ ...: list()
[13:35:07.639]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.639]  - attr(*, "where")=List of 1
[13:35:07.639]   ..$ ...:<environment: 0x5574d0574130> 
[13:35:07.639]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.639]  - attr(*, "resolved")= logi TRUE
[13:35:07.639]  - attr(*, "total_size")= num NA
[13:35:07.643]  - Getting '...' globals ... DONE
[13:35:07.643] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:07.643] List of 8
[13:35:07.643]  $ ...future.FUN:function (x, ...)  
[13:35:07.643]  $ x_FUN        :function (x, ...)  
[13:35:07.643]  $ times        : int 5
[13:35:07.643]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.643]  $ stop_if_not  :function (...)  
[13:35:07.643]  $ dim          : NULL
[13:35:07.643]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:07.643]  $ ...          : list()
[13:35:07.643]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.643]  - attr(*, "where")=List of 8
[13:35:07.643]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:07.643]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:07.643]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:07.643]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:07.643]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:07.643]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:07.643]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:07.643]   ..$ ...          :<environment: 0x5574d0574130> 
[13:35:07.643]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.643]  - attr(*, "resolved")= logi FALSE
[13:35:07.643]  - attr(*, "total_size")= num 95528
[13:35:07.651] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:35:07.651] getGlobalsAndPackagesXApply() ... DONE
[13:35:07.651] Number of futures (= number of chunks): 2
[13:35:07.651] Launching 2 futures (chunks) ...
[13:35:07.651] Chunk #1 of 2 ...
[13:35:07.652]  - Finding globals in 'X' for chunk #1 ...
[13:35:07.652] getGlobalsAndPackages() ...
[13:35:07.652] Searching for globals...
[13:35:07.652] 
[13:35:07.652] Searching for globals ... DONE
[13:35:07.652] - globals: [0] <none>
[13:35:07.652] getGlobalsAndPackages() ... DONE
[13:35:07.652]    + additional globals found: [n=0] 
[13:35:07.652]    + additional namespaces needed: [n=0] 
[13:35:07.653]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:07.653]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.653]  - seeds: <none>
[13:35:07.653]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.653] getGlobalsAndPackages() ...
[13:35:07.653] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.653] Resolving globals: FALSE
[13:35:07.653] Tweak future expression to call with '...' arguments ...
[13:35:07.653] {
[13:35:07.653]     do.call(function(...) {
[13:35:07.653]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.653]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.653]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.653]             on.exit(options(oopts), add = TRUE)
[13:35:07.653]         }
[13:35:07.653]         {
[13:35:07.653]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.653]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.653]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.653]             })
[13:35:07.653]         }
[13:35:07.653]     }, args = future.call.arguments)
[13:35:07.653] }
[13:35:07.654] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.654] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.654] - packages: [2] ‘stats’, ‘future.apply’
[13:35:07.654] getGlobalsAndPackages() ... DONE
[13:35:07.655] run() for ‘Future’ ...
[13:35:07.655] - state: ‘created’
[13:35:07.655] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.661] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.661] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.661]   - Field: ‘label’
[13:35:07.661]   - Field: ‘local’
[13:35:07.662]   - Field: ‘owner’
[13:35:07.662]   - Field: ‘envir’
[13:35:07.662]   - Field: ‘workers’
[13:35:07.662]   - Field: ‘packages’
[13:35:07.662]   - Field: ‘gc’
[13:35:07.662]   - Field: ‘job’
[13:35:07.662]   - Field: ‘conditions’
[13:35:07.662]   - Field: ‘expr’
[13:35:07.663]   - Field: ‘uuid’
[13:35:07.663]   - Field: ‘seed’
[13:35:07.663]   - Field: ‘version’
[13:35:07.663]   - Field: ‘result’
[13:35:07.663]   - Field: ‘asynchronous’
[13:35:07.663]   - Field: ‘calls’
[13:35:07.663]   - Field: ‘globals’
[13:35:07.663]   - Field: ‘stdout’
[13:35:07.663]   - Field: ‘earlySignal’
[13:35:07.664]   - Field: ‘lazy’
[13:35:07.664]   - Field: ‘state’
[13:35:07.664] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.664] - Launch lazy future ...
[13:35:07.664] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:35:07.664] Packages needed by future strategies (n = 0): <none>
[13:35:07.665] {
[13:35:07.665]     {
[13:35:07.665]         {
[13:35:07.665]             ...future.startTime <- base::Sys.time()
[13:35:07.665]             {
[13:35:07.665]                 {
[13:35:07.665]                   {
[13:35:07.665]                     {
[13:35:07.665]                       {
[13:35:07.665]                         base::local({
[13:35:07.665]                           has_future <- base::requireNamespace("future", 
[13:35:07.665]                             quietly = TRUE)
[13:35:07.665]                           if (has_future) {
[13:35:07.665]                             ns <- base::getNamespace("future")
[13:35:07.665]                             version <- ns[[".package"]][["version"]]
[13:35:07.665]                             if (is.null(version)) 
[13:35:07.665]                               version <- utils::packageVersion("future")
[13:35:07.665]                           }
[13:35:07.665]                           else {
[13:35:07.665]                             version <- NULL
[13:35:07.665]                           }
[13:35:07.665]                           if (!has_future || version < "1.8.0") {
[13:35:07.665]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.665]                               "", base::R.version$version.string), 
[13:35:07.665]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.665]                                 base::R.version$platform, 8 * 
[13:35:07.665]                                   base::.Machine$sizeof.pointer), 
[13:35:07.665]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.665]                                 "release", "version")], collapse = " "), 
[13:35:07.665]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.665]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.665]                               info)
[13:35:07.665]                             info <- base::paste(info, collapse = "; ")
[13:35:07.665]                             if (!has_future) {
[13:35:07.665]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.665]                                 info)
[13:35:07.665]                             }
[13:35:07.665]                             else {
[13:35:07.665]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.665]                                 info, version)
[13:35:07.665]                             }
[13:35:07.665]                             base::stop(msg)
[13:35:07.665]                           }
[13:35:07.665]                         })
[13:35:07.665]                       }
[13:35:07.665]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.665]                       base::options(mc.cores = 1L)
[13:35:07.665]                     }
[13:35:07.665]                     base::local({
[13:35:07.665]                       for (pkg in c("stats", "future.apply")) {
[13:35:07.665]                         base::loadNamespace(pkg)
[13:35:07.665]                         base::library(pkg, character.only = TRUE)
[13:35:07.665]                       }
[13:35:07.665]                     })
[13:35:07.665]                   }
[13:35:07.665]                   ...future.strategy.old <- future::plan("list")
[13:35:07.665]                   options(future.plan = NULL)
[13:35:07.665]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.665]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.665]                 }
[13:35:07.665]                 ...future.workdir <- getwd()
[13:35:07.665]             }
[13:35:07.665]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.665]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.665]         }
[13:35:07.665]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.665]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.665]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.665]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.665]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.665]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.665]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.665]             base::names(...future.oldOptions))
[13:35:07.665]     }
[13:35:07.665]     if (FALSE) {
[13:35:07.665]     }
[13:35:07.665]     else {
[13:35:07.665]         if (TRUE) {
[13:35:07.665]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.665]                 open = "w")
[13:35:07.665]         }
[13:35:07.665]         else {
[13:35:07.665]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.665]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.665]         }
[13:35:07.665]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.665]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.665]             base::sink(type = "output", split = FALSE)
[13:35:07.665]             base::close(...future.stdout)
[13:35:07.665]         }, add = TRUE)
[13:35:07.665]     }
[13:35:07.665]     ...future.frame <- base::sys.nframe()
[13:35:07.665]     ...future.conditions <- base::list()
[13:35:07.665]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.665]     if (FALSE) {
[13:35:07.665]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.665]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.665]     }
[13:35:07.665]     ...future.result <- base::tryCatch({
[13:35:07.665]         base::withCallingHandlers({
[13:35:07.665]             ...future.value <- base::withVisible(base::local({
[13:35:07.665]                 withCallingHandlers({
[13:35:07.665]                   {
[13:35:07.665]                     do.call(function(...) {
[13:35:07.665]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.665]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.665]                         ...future.globals.maxSize)) {
[13:35:07.665]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.665]                         on.exit(options(oopts), add = TRUE)
[13:35:07.665]                       }
[13:35:07.665]                       {
[13:35:07.665]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.665]                           FUN = function(jj) {
[13:35:07.665]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.665]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.665]                           })
[13:35:07.665]                       }
[13:35:07.665]                     }, args = future.call.arguments)
[13:35:07.665]                   }
[13:35:07.665]                 }, immediateCondition = function(cond) {
[13:35:07.665]                   save_rds <- function (object, pathname, ...) 
[13:35:07.665]                   {
[13:35:07.665]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.665]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.665]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.665]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.665]                         fi_tmp[["mtime"]])
[13:35:07.665]                     }
[13:35:07.665]                     tryCatch({
[13:35:07.665]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.665]                     }, error = function(ex) {
[13:35:07.665]                       msg <- conditionMessage(ex)
[13:35:07.665]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.665]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.665]                         fi_tmp[["mtime"]], msg)
[13:35:07.665]                       ex$message <- msg
[13:35:07.665]                       stop(ex)
[13:35:07.665]                     })
[13:35:07.665]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.665]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.665]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.665]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.665]                       fi <- file.info(pathname)
[13:35:07.665]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.665]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.665]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.665]                         fi[["size"]], fi[["mtime"]])
[13:35:07.665]                       stop(msg)
[13:35:07.665]                     }
[13:35:07.665]                     invisible(pathname)
[13:35:07.665]                   }
[13:35:07.665]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.665]                     rootPath = tempdir()) 
[13:35:07.665]                   {
[13:35:07.665]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.665]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.665]                       tmpdir = path, fileext = ".rds")
[13:35:07.665]                     save_rds(obj, file)
[13:35:07.665]                   }
[13:35:07.665]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.665]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.665]                   {
[13:35:07.665]                     inherits <- base::inherits
[13:35:07.665]                     invokeRestart <- base::invokeRestart
[13:35:07.665]                     is.null <- base::is.null
[13:35:07.665]                     muffled <- FALSE
[13:35:07.665]                     if (inherits(cond, "message")) {
[13:35:07.665]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.665]                       if (muffled) 
[13:35:07.665]                         invokeRestart("muffleMessage")
[13:35:07.665]                     }
[13:35:07.665]                     else if (inherits(cond, "warning")) {
[13:35:07.665]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.665]                       if (muffled) 
[13:35:07.665]                         invokeRestart("muffleWarning")
[13:35:07.665]                     }
[13:35:07.665]                     else if (inherits(cond, "condition")) {
[13:35:07.665]                       if (!is.null(pattern)) {
[13:35:07.665]                         computeRestarts <- base::computeRestarts
[13:35:07.665]                         grepl <- base::grepl
[13:35:07.665]                         restarts <- computeRestarts(cond)
[13:35:07.665]                         for (restart in restarts) {
[13:35:07.665]                           name <- restart$name
[13:35:07.665]                           if (is.null(name)) 
[13:35:07.665]                             next
[13:35:07.665]                           if (!grepl(pattern, name)) 
[13:35:07.665]                             next
[13:35:07.665]                           invokeRestart(restart)
[13:35:07.665]                           muffled <- TRUE
[13:35:07.665]                           break
[13:35:07.665]                         }
[13:35:07.665]                       }
[13:35:07.665]                     }
[13:35:07.665]                     invisible(muffled)
[13:35:07.665]                   }
[13:35:07.665]                   muffleCondition(cond)
[13:35:07.665]                 })
[13:35:07.665]             }))
[13:35:07.665]             future::FutureResult(value = ...future.value$value, 
[13:35:07.665]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.665]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.665]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.665]                     ...future.globalenv.names))
[13:35:07.665]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.665]         }, condition = base::local({
[13:35:07.665]             c <- base::c
[13:35:07.665]             inherits <- base::inherits
[13:35:07.665]             invokeRestart <- base::invokeRestart
[13:35:07.665]             length <- base::length
[13:35:07.665]             list <- base::list
[13:35:07.665]             seq.int <- base::seq.int
[13:35:07.665]             signalCondition <- base::signalCondition
[13:35:07.665]             sys.calls <- base::sys.calls
[13:35:07.665]             `[[` <- base::`[[`
[13:35:07.665]             `+` <- base::`+`
[13:35:07.665]             `<<-` <- base::`<<-`
[13:35:07.665]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.665]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.665]                   3L)]
[13:35:07.665]             }
[13:35:07.665]             function(cond) {
[13:35:07.665]                 is_error <- inherits(cond, "error")
[13:35:07.665]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.665]                   NULL)
[13:35:07.665]                 if (is_error) {
[13:35:07.665]                   sessionInformation <- function() {
[13:35:07.665]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.665]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.665]                       search = base::search(), system = base::Sys.info())
[13:35:07.665]                   }
[13:35:07.665]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.665]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.665]                     cond$call), session = sessionInformation(), 
[13:35:07.665]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.665]                   signalCondition(cond)
[13:35:07.665]                 }
[13:35:07.665]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.665]                 "immediateCondition"))) {
[13:35:07.665]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.665]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.665]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.665]                   if (TRUE && !signal) {
[13:35:07.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.665]                     {
[13:35:07.665]                       inherits <- base::inherits
[13:35:07.665]                       invokeRestart <- base::invokeRestart
[13:35:07.665]                       is.null <- base::is.null
[13:35:07.665]                       muffled <- FALSE
[13:35:07.665]                       if (inherits(cond, "message")) {
[13:35:07.665]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.665]                         if (muffled) 
[13:35:07.665]                           invokeRestart("muffleMessage")
[13:35:07.665]                       }
[13:35:07.665]                       else if (inherits(cond, "warning")) {
[13:35:07.665]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.665]                         if (muffled) 
[13:35:07.665]                           invokeRestart("muffleWarning")
[13:35:07.665]                       }
[13:35:07.665]                       else if (inherits(cond, "condition")) {
[13:35:07.665]                         if (!is.null(pattern)) {
[13:35:07.665]                           computeRestarts <- base::computeRestarts
[13:35:07.665]                           grepl <- base::grepl
[13:35:07.665]                           restarts <- computeRestarts(cond)
[13:35:07.665]                           for (restart in restarts) {
[13:35:07.665]                             name <- restart$name
[13:35:07.665]                             if (is.null(name)) 
[13:35:07.665]                               next
[13:35:07.665]                             if (!grepl(pattern, name)) 
[13:35:07.665]                               next
[13:35:07.665]                             invokeRestart(restart)
[13:35:07.665]                             muffled <- TRUE
[13:35:07.665]                             break
[13:35:07.665]                           }
[13:35:07.665]                         }
[13:35:07.665]                       }
[13:35:07.665]                       invisible(muffled)
[13:35:07.665]                     }
[13:35:07.665]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.665]                   }
[13:35:07.665]                 }
[13:35:07.665]                 else {
[13:35:07.665]                   if (TRUE) {
[13:35:07.665]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.665]                     {
[13:35:07.665]                       inherits <- base::inherits
[13:35:07.665]                       invokeRestart <- base::invokeRestart
[13:35:07.665]                       is.null <- base::is.null
[13:35:07.665]                       muffled <- FALSE
[13:35:07.665]                       if (inherits(cond, "message")) {
[13:35:07.665]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.665]                         if (muffled) 
[13:35:07.665]                           invokeRestart("muffleMessage")
[13:35:07.665]                       }
[13:35:07.665]                       else if (inherits(cond, "warning")) {
[13:35:07.665]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.665]                         if (muffled) 
[13:35:07.665]                           invokeRestart("muffleWarning")
[13:35:07.665]                       }
[13:35:07.665]                       else if (inherits(cond, "condition")) {
[13:35:07.665]                         if (!is.null(pattern)) {
[13:35:07.665]                           computeRestarts <- base::computeRestarts
[13:35:07.665]                           grepl <- base::grepl
[13:35:07.665]                           restarts <- computeRestarts(cond)
[13:35:07.665]                           for (restart in restarts) {
[13:35:07.665]                             name <- restart$name
[13:35:07.665]                             if (is.null(name)) 
[13:35:07.665]                               next
[13:35:07.665]                             if (!grepl(pattern, name)) 
[13:35:07.665]                               next
[13:35:07.665]                             invokeRestart(restart)
[13:35:07.665]                             muffled <- TRUE
[13:35:07.665]                             break
[13:35:07.665]                           }
[13:35:07.665]                         }
[13:35:07.665]                       }
[13:35:07.665]                       invisible(muffled)
[13:35:07.665]                     }
[13:35:07.665]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.665]                   }
[13:35:07.665]                 }
[13:35:07.665]             }
[13:35:07.665]         }))
[13:35:07.665]     }, error = function(ex) {
[13:35:07.665]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.665]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.665]                 ...future.rng), started = ...future.startTime, 
[13:35:07.665]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.665]             version = "1.8"), class = "FutureResult")
[13:35:07.665]     }, finally = {
[13:35:07.665]         if (!identical(...future.workdir, getwd())) 
[13:35:07.665]             setwd(...future.workdir)
[13:35:07.665]         {
[13:35:07.665]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.665]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.665]             }
[13:35:07.665]             base::options(...future.oldOptions)
[13:35:07.665]             if (.Platform$OS.type == "windows") {
[13:35:07.665]                 old_names <- names(...future.oldEnvVars)
[13:35:07.665]                 envs <- base::Sys.getenv()
[13:35:07.665]                 names <- names(envs)
[13:35:07.665]                 common <- intersect(names, old_names)
[13:35:07.665]                 added <- setdiff(names, old_names)
[13:35:07.665]                 removed <- setdiff(old_names, names)
[13:35:07.665]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.665]                   envs[common]]
[13:35:07.665]                 NAMES <- toupper(changed)
[13:35:07.665]                 args <- list()
[13:35:07.665]                 for (kk in seq_along(NAMES)) {
[13:35:07.665]                   name <- changed[[kk]]
[13:35:07.665]                   NAME <- NAMES[[kk]]
[13:35:07.665]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.665]                     next
[13:35:07.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.665]                 }
[13:35:07.665]                 NAMES <- toupper(added)
[13:35:07.665]                 for (kk in seq_along(NAMES)) {
[13:35:07.665]                   name <- added[[kk]]
[13:35:07.665]                   NAME <- NAMES[[kk]]
[13:35:07.665]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.665]                     next
[13:35:07.665]                   args[[name]] <- ""
[13:35:07.665]                 }
[13:35:07.665]                 NAMES <- toupper(removed)
[13:35:07.665]                 for (kk in seq_along(NAMES)) {
[13:35:07.665]                   name <- removed[[kk]]
[13:35:07.665]                   NAME <- NAMES[[kk]]
[13:35:07.665]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.665]                     next
[13:35:07.665]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.665]                 }
[13:35:07.665]                 if (length(args) > 0) 
[13:35:07.665]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.665]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.665]             }
[13:35:07.665]             else {
[13:35:07.665]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.665]             }
[13:35:07.665]             {
[13:35:07.665]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.665]                   0L) {
[13:35:07.665]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.665]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.665]                   base::options(opts)
[13:35:07.665]                 }
[13:35:07.665]                 {
[13:35:07.665]                   {
[13:35:07.665]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.665]                     NULL
[13:35:07.665]                   }
[13:35:07.665]                   options(future.plan = NULL)
[13:35:07.665]                   if (is.na(NA_character_)) 
[13:35:07.665]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.665]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.665]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.665]                     .init = FALSE)
[13:35:07.665]                 }
[13:35:07.665]             }
[13:35:07.665]         }
[13:35:07.665]     })
[13:35:07.665]     if (TRUE) {
[13:35:07.665]         base::sink(type = "output", split = FALSE)
[13:35:07.665]         if (TRUE) {
[13:35:07.665]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.665]         }
[13:35:07.665]         else {
[13:35:07.665]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.665]         }
[13:35:07.665]         base::close(...future.stdout)
[13:35:07.665]         ...future.stdout <- NULL
[13:35:07.665]     }
[13:35:07.665]     ...future.result$conditions <- ...future.conditions
[13:35:07.665]     ...future.result$finished <- base::Sys.time()
[13:35:07.665]     ...future.result
[13:35:07.665] }
[13:35:07.667] assign_globals() ...
[13:35:07.668] List of 11
[13:35:07.668]  $ ...future.FUN            :function (x, ...)  
[13:35:07.668]  $ x_FUN                    :function (x, ...)  
[13:35:07.668]  $ times                    : int 5
[13:35:07.668]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.668]  $ stop_if_not              :function (...)  
[13:35:07.668]  $ dim                      : NULL
[13:35:07.668]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:07.668]  $ future.call.arguments    : list()
[13:35:07.668]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.668]  $ ...future.elements_ii    :List of 1
[13:35:07.668]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[13:35:07.668]  $ ...future.seeds_ii       : NULL
[13:35:07.668]  $ ...future.globals.maxSize: NULL
[13:35:07.668]  - attr(*, "where")=List of 11
[13:35:07.668]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.668]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:07.668]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:07.668]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:07.668]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:07.668]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:07.668]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:07.668]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.668]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.668]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.668]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.668]  - attr(*, "resolved")= logi FALSE
[13:35:07.668]  - attr(*, "total_size")= num 95528
[13:35:07.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.668]  - attr(*, "already-done")= logi TRUE
[13:35:07.675] - copied ‘...future.FUN’ to environment
[13:35:07.675] - copied ‘x_FUN’ to environment
[13:35:07.675] - copied ‘times’ to environment
[13:35:07.675] - copied ‘stopf’ to environment
[13:35:07.675] - copied ‘stop_if_not’ to environment
[13:35:07.676] - copied ‘dim’ to environment
[13:35:07.676] - copied ‘valid_types’ to environment
[13:35:07.676] - copied ‘future.call.arguments’ to environment
[13:35:07.676] - copied ‘...future.elements_ii’ to environment
[13:35:07.676] - copied ‘...future.seeds_ii’ to environment
[13:35:07.676] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.676] assign_globals() ... done
[13:35:07.676] requestCore(): workers = 2
[13:35:07.679] MulticoreFuture started
[13:35:07.679] - Launch lazy future ... done
[13:35:07.679] run() for ‘MulticoreFuture’ ... done
[13:35:07.679] Created future:
[13:35:07.680] plan(): Setting new future strategy stack:
[13:35:07.681] List of future strategies:
[13:35:07.681] 1. sequential:
[13:35:07.681]    - args: function (..., envir = parent.frame())
[13:35:07.681]    - tweaked: FALSE
[13:35:07.681]    - call: NULL
[13:35:07.681] plan(): nbrOfWorkers() = 1
[13:35:07.684] plan(): Setting new future strategy stack:
[13:35:07.684] List of future strategies:
[13:35:07.684] 1. multicore:
[13:35:07.684]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.684]    - tweaked: FALSE
[13:35:07.684]    - call: plan(strategy)
[13:35:07.689] plan(): nbrOfWorkers() = 2
[13:35:07.680] MulticoreFuture:
[13:35:07.680] Label: ‘future_vapply-1’
[13:35:07.680] Expression:
[13:35:07.680] {
[13:35:07.680]     do.call(function(...) {
[13:35:07.680]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.680]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.680]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.680]             on.exit(options(oopts), add = TRUE)
[13:35:07.680]         }
[13:35:07.680]         {
[13:35:07.680]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.680]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.680]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.680]             })
[13:35:07.680]         }
[13:35:07.680]     }, args = future.call.arguments)
[13:35:07.680] }
[13:35:07.680] Lazy evaluation: FALSE
[13:35:07.680] Asynchronous evaluation: TRUE
[13:35:07.680] Local evaluation: TRUE
[13:35:07.680] Environment: R_GlobalEnv
[13:35:07.680] Capture standard output: TRUE
[13:35:07.680] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.680] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:07.680] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:35:07.680] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.680] Resolved: TRUE
[13:35:07.680] Value: <not collected>
[13:35:07.680] Conditions captured: <none>
[13:35:07.680] Early signaling: FALSE
[13:35:07.680] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.680] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.690] Chunk #1 of 2 ... DONE
[13:35:07.691] Chunk #2 of 2 ...
[13:35:07.691]  - Finding globals in 'X' for chunk #2 ...
[13:35:07.691] getGlobalsAndPackages() ...
[13:35:07.691] Searching for globals...
[13:35:07.692] 
[13:35:07.692] Searching for globals ... DONE
[13:35:07.692] - globals: [0] <none>
[13:35:07.692] getGlobalsAndPackages() ... DONE
[13:35:07.692]    + additional globals found: [n=0] 
[13:35:07.692]    + additional namespaces needed: [n=0] 
[13:35:07.692]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:07.692]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.693]  - seeds: <none>
[13:35:07.693]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.693] getGlobalsAndPackages() ...
[13:35:07.693] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.693] Resolving globals: FALSE
[13:35:07.693] Tweak future expression to call with '...' arguments ...
[13:35:07.693] {
[13:35:07.693]     do.call(function(...) {
[13:35:07.693]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.693]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.693]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.693]             on.exit(options(oopts), add = TRUE)
[13:35:07.693]         }
[13:35:07.693]         {
[13:35:07.693]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.693]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.693]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.693]             })
[13:35:07.693]         }
[13:35:07.693]     }, args = future.call.arguments)
[13:35:07.693] }
[13:35:07.694] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.698] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.699] - packages: [2] ‘stats’, ‘future.apply’
[13:35:07.699] getGlobalsAndPackages() ... DONE
[13:35:07.700] run() for ‘Future’ ...
[13:35:07.700] - state: ‘created’
[13:35:07.701] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.707] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.708]   - Field: ‘label’
[13:35:07.708]   - Field: ‘local’
[13:35:07.708]   - Field: ‘owner’
[13:35:07.708]   - Field: ‘envir’
[13:35:07.708]   - Field: ‘workers’
[13:35:07.709]   - Field: ‘packages’
[13:35:07.709]   - Field: ‘gc’
[13:35:07.709]   - Field: ‘job’
[13:35:07.709]   - Field: ‘conditions’
[13:35:07.710]   - Field: ‘expr’
[13:35:07.710]   - Field: ‘uuid’
[13:35:07.710]   - Field: ‘seed’
[13:35:07.710]   - Field: ‘version’
[13:35:07.711]   - Field: ‘result’
[13:35:07.711]   - Field: ‘asynchronous’
[13:35:07.711]   - Field: ‘calls’
[13:35:07.711]   - Field: ‘globals’
[13:35:07.711]   - Field: ‘stdout’
[13:35:07.712]   - Field: ‘earlySignal’
[13:35:07.712]   - Field: ‘lazy’
[13:35:07.712]   - Field: ‘state’
[13:35:07.712] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.712] - Launch lazy future ...
[13:35:07.713] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:35:07.713] Packages needed by future strategies (n = 0): <none>
[13:35:07.714] {
[13:35:07.714]     {
[13:35:07.714]         {
[13:35:07.714]             ...future.startTime <- base::Sys.time()
[13:35:07.714]             {
[13:35:07.714]                 {
[13:35:07.714]                   {
[13:35:07.714]                     {
[13:35:07.714]                       {
[13:35:07.714]                         base::local({
[13:35:07.714]                           has_future <- base::requireNamespace("future", 
[13:35:07.714]                             quietly = TRUE)
[13:35:07.714]                           if (has_future) {
[13:35:07.714]                             ns <- base::getNamespace("future")
[13:35:07.714]                             version <- ns[[".package"]][["version"]]
[13:35:07.714]                             if (is.null(version)) 
[13:35:07.714]                               version <- utils::packageVersion("future")
[13:35:07.714]                           }
[13:35:07.714]                           else {
[13:35:07.714]                             version <- NULL
[13:35:07.714]                           }
[13:35:07.714]                           if (!has_future || version < "1.8.0") {
[13:35:07.714]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.714]                               "", base::R.version$version.string), 
[13:35:07.714]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.714]                                 base::R.version$platform, 8 * 
[13:35:07.714]                                   base::.Machine$sizeof.pointer), 
[13:35:07.714]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.714]                                 "release", "version")], collapse = " "), 
[13:35:07.714]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.714]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.714]                               info)
[13:35:07.714]                             info <- base::paste(info, collapse = "; ")
[13:35:07.714]                             if (!has_future) {
[13:35:07.714]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.714]                                 info)
[13:35:07.714]                             }
[13:35:07.714]                             else {
[13:35:07.714]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.714]                                 info, version)
[13:35:07.714]                             }
[13:35:07.714]                             base::stop(msg)
[13:35:07.714]                           }
[13:35:07.714]                         })
[13:35:07.714]                       }
[13:35:07.714]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.714]                       base::options(mc.cores = 1L)
[13:35:07.714]                     }
[13:35:07.714]                     base::local({
[13:35:07.714]                       for (pkg in c("stats", "future.apply")) {
[13:35:07.714]                         base::loadNamespace(pkg)
[13:35:07.714]                         base::library(pkg, character.only = TRUE)
[13:35:07.714]                       }
[13:35:07.714]                     })
[13:35:07.714]                   }
[13:35:07.714]                   ...future.strategy.old <- future::plan("list")
[13:35:07.714]                   options(future.plan = NULL)
[13:35:07.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.714]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.714]                 }
[13:35:07.714]                 ...future.workdir <- getwd()
[13:35:07.714]             }
[13:35:07.714]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.714]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.714]         }
[13:35:07.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.714]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.714]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.714]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.714]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.714]             base::names(...future.oldOptions))
[13:35:07.714]     }
[13:35:07.714]     if (FALSE) {
[13:35:07.714]     }
[13:35:07.714]     else {
[13:35:07.714]         if (TRUE) {
[13:35:07.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.714]                 open = "w")
[13:35:07.714]         }
[13:35:07.714]         else {
[13:35:07.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.714]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.714]         }
[13:35:07.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.714]             base::sink(type = "output", split = FALSE)
[13:35:07.714]             base::close(...future.stdout)
[13:35:07.714]         }, add = TRUE)
[13:35:07.714]     }
[13:35:07.714]     ...future.frame <- base::sys.nframe()
[13:35:07.714]     ...future.conditions <- base::list()
[13:35:07.714]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.714]     if (FALSE) {
[13:35:07.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.714]     }
[13:35:07.714]     ...future.result <- base::tryCatch({
[13:35:07.714]         base::withCallingHandlers({
[13:35:07.714]             ...future.value <- base::withVisible(base::local({
[13:35:07.714]                 withCallingHandlers({
[13:35:07.714]                   {
[13:35:07.714]                     do.call(function(...) {
[13:35:07.714]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.714]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.714]                         ...future.globals.maxSize)) {
[13:35:07.714]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.714]                         on.exit(options(oopts), add = TRUE)
[13:35:07.714]                       }
[13:35:07.714]                       {
[13:35:07.714]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.714]                           FUN = function(jj) {
[13:35:07.714]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.714]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.714]                           })
[13:35:07.714]                       }
[13:35:07.714]                     }, args = future.call.arguments)
[13:35:07.714]                   }
[13:35:07.714]                 }, immediateCondition = function(cond) {
[13:35:07.714]                   save_rds <- function (object, pathname, ...) 
[13:35:07.714]                   {
[13:35:07.714]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.714]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.714]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.714]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.714]                         fi_tmp[["mtime"]])
[13:35:07.714]                     }
[13:35:07.714]                     tryCatch({
[13:35:07.714]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.714]                     }, error = function(ex) {
[13:35:07.714]                       msg <- conditionMessage(ex)
[13:35:07.714]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.714]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.714]                         fi_tmp[["mtime"]], msg)
[13:35:07.714]                       ex$message <- msg
[13:35:07.714]                       stop(ex)
[13:35:07.714]                     })
[13:35:07.714]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.714]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.714]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.714]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.714]                       fi <- file.info(pathname)
[13:35:07.714]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.714]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.714]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.714]                         fi[["size"]], fi[["mtime"]])
[13:35:07.714]                       stop(msg)
[13:35:07.714]                     }
[13:35:07.714]                     invisible(pathname)
[13:35:07.714]                   }
[13:35:07.714]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.714]                     rootPath = tempdir()) 
[13:35:07.714]                   {
[13:35:07.714]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.714]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.714]                       tmpdir = path, fileext = ".rds")
[13:35:07.714]                     save_rds(obj, file)
[13:35:07.714]                   }
[13:35:07.714]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.714]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.714]                   {
[13:35:07.714]                     inherits <- base::inherits
[13:35:07.714]                     invokeRestart <- base::invokeRestart
[13:35:07.714]                     is.null <- base::is.null
[13:35:07.714]                     muffled <- FALSE
[13:35:07.714]                     if (inherits(cond, "message")) {
[13:35:07.714]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.714]                       if (muffled) 
[13:35:07.714]                         invokeRestart("muffleMessage")
[13:35:07.714]                     }
[13:35:07.714]                     else if (inherits(cond, "warning")) {
[13:35:07.714]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.714]                       if (muffled) 
[13:35:07.714]                         invokeRestart("muffleWarning")
[13:35:07.714]                     }
[13:35:07.714]                     else if (inherits(cond, "condition")) {
[13:35:07.714]                       if (!is.null(pattern)) {
[13:35:07.714]                         computeRestarts <- base::computeRestarts
[13:35:07.714]                         grepl <- base::grepl
[13:35:07.714]                         restarts <- computeRestarts(cond)
[13:35:07.714]                         for (restart in restarts) {
[13:35:07.714]                           name <- restart$name
[13:35:07.714]                           if (is.null(name)) 
[13:35:07.714]                             next
[13:35:07.714]                           if (!grepl(pattern, name)) 
[13:35:07.714]                             next
[13:35:07.714]                           invokeRestart(restart)
[13:35:07.714]                           muffled <- TRUE
[13:35:07.714]                           break
[13:35:07.714]                         }
[13:35:07.714]                       }
[13:35:07.714]                     }
[13:35:07.714]                     invisible(muffled)
[13:35:07.714]                   }
[13:35:07.714]                   muffleCondition(cond)
[13:35:07.714]                 })
[13:35:07.714]             }))
[13:35:07.714]             future::FutureResult(value = ...future.value$value, 
[13:35:07.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.714]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.714]                     ...future.globalenv.names))
[13:35:07.714]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.714]         }, condition = base::local({
[13:35:07.714]             c <- base::c
[13:35:07.714]             inherits <- base::inherits
[13:35:07.714]             invokeRestart <- base::invokeRestart
[13:35:07.714]             length <- base::length
[13:35:07.714]             list <- base::list
[13:35:07.714]             seq.int <- base::seq.int
[13:35:07.714]             signalCondition <- base::signalCondition
[13:35:07.714]             sys.calls <- base::sys.calls
[13:35:07.714]             `[[` <- base::`[[`
[13:35:07.714]             `+` <- base::`+`
[13:35:07.714]             `<<-` <- base::`<<-`
[13:35:07.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.714]                   3L)]
[13:35:07.714]             }
[13:35:07.714]             function(cond) {
[13:35:07.714]                 is_error <- inherits(cond, "error")
[13:35:07.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.714]                   NULL)
[13:35:07.714]                 if (is_error) {
[13:35:07.714]                   sessionInformation <- function() {
[13:35:07.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.714]                       search = base::search(), system = base::Sys.info())
[13:35:07.714]                   }
[13:35:07.714]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.714]                     cond$call), session = sessionInformation(), 
[13:35:07.714]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.714]                   signalCondition(cond)
[13:35:07.714]                 }
[13:35:07.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.714]                 "immediateCondition"))) {
[13:35:07.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.714]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.714]                   if (TRUE && !signal) {
[13:35:07.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.714]                     {
[13:35:07.714]                       inherits <- base::inherits
[13:35:07.714]                       invokeRestart <- base::invokeRestart
[13:35:07.714]                       is.null <- base::is.null
[13:35:07.714]                       muffled <- FALSE
[13:35:07.714]                       if (inherits(cond, "message")) {
[13:35:07.714]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.714]                         if (muffled) 
[13:35:07.714]                           invokeRestart("muffleMessage")
[13:35:07.714]                       }
[13:35:07.714]                       else if (inherits(cond, "warning")) {
[13:35:07.714]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.714]                         if (muffled) 
[13:35:07.714]                           invokeRestart("muffleWarning")
[13:35:07.714]                       }
[13:35:07.714]                       else if (inherits(cond, "condition")) {
[13:35:07.714]                         if (!is.null(pattern)) {
[13:35:07.714]                           computeRestarts <- base::computeRestarts
[13:35:07.714]                           grepl <- base::grepl
[13:35:07.714]                           restarts <- computeRestarts(cond)
[13:35:07.714]                           for (restart in restarts) {
[13:35:07.714]                             name <- restart$name
[13:35:07.714]                             if (is.null(name)) 
[13:35:07.714]                               next
[13:35:07.714]                             if (!grepl(pattern, name)) 
[13:35:07.714]                               next
[13:35:07.714]                             invokeRestart(restart)
[13:35:07.714]                             muffled <- TRUE
[13:35:07.714]                             break
[13:35:07.714]                           }
[13:35:07.714]                         }
[13:35:07.714]                       }
[13:35:07.714]                       invisible(muffled)
[13:35:07.714]                     }
[13:35:07.714]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.714]                   }
[13:35:07.714]                 }
[13:35:07.714]                 else {
[13:35:07.714]                   if (TRUE) {
[13:35:07.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.714]                     {
[13:35:07.714]                       inherits <- base::inherits
[13:35:07.714]                       invokeRestart <- base::invokeRestart
[13:35:07.714]                       is.null <- base::is.null
[13:35:07.714]                       muffled <- FALSE
[13:35:07.714]                       if (inherits(cond, "message")) {
[13:35:07.714]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.714]                         if (muffled) 
[13:35:07.714]                           invokeRestart("muffleMessage")
[13:35:07.714]                       }
[13:35:07.714]                       else if (inherits(cond, "warning")) {
[13:35:07.714]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.714]                         if (muffled) 
[13:35:07.714]                           invokeRestart("muffleWarning")
[13:35:07.714]                       }
[13:35:07.714]                       else if (inherits(cond, "condition")) {
[13:35:07.714]                         if (!is.null(pattern)) {
[13:35:07.714]                           computeRestarts <- base::computeRestarts
[13:35:07.714]                           grepl <- base::grepl
[13:35:07.714]                           restarts <- computeRestarts(cond)
[13:35:07.714]                           for (restart in restarts) {
[13:35:07.714]                             name <- restart$name
[13:35:07.714]                             if (is.null(name)) 
[13:35:07.714]                               next
[13:35:07.714]                             if (!grepl(pattern, name)) 
[13:35:07.714]                               next
[13:35:07.714]                             invokeRestart(restart)
[13:35:07.714]                             muffled <- TRUE
[13:35:07.714]                             break
[13:35:07.714]                           }
[13:35:07.714]                         }
[13:35:07.714]                       }
[13:35:07.714]                       invisible(muffled)
[13:35:07.714]                     }
[13:35:07.714]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.714]                   }
[13:35:07.714]                 }
[13:35:07.714]             }
[13:35:07.714]         }))
[13:35:07.714]     }, error = function(ex) {
[13:35:07.714]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.714]                 ...future.rng), started = ...future.startTime, 
[13:35:07.714]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.714]             version = "1.8"), class = "FutureResult")
[13:35:07.714]     }, finally = {
[13:35:07.714]         if (!identical(...future.workdir, getwd())) 
[13:35:07.714]             setwd(...future.workdir)
[13:35:07.714]         {
[13:35:07.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.714]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.714]             }
[13:35:07.714]             base::options(...future.oldOptions)
[13:35:07.714]             if (.Platform$OS.type == "windows") {
[13:35:07.714]                 old_names <- names(...future.oldEnvVars)
[13:35:07.714]                 envs <- base::Sys.getenv()
[13:35:07.714]                 names <- names(envs)
[13:35:07.714]                 common <- intersect(names, old_names)
[13:35:07.714]                 added <- setdiff(names, old_names)
[13:35:07.714]                 removed <- setdiff(old_names, names)
[13:35:07.714]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.714]                   envs[common]]
[13:35:07.714]                 NAMES <- toupper(changed)
[13:35:07.714]                 args <- list()
[13:35:07.714]                 for (kk in seq_along(NAMES)) {
[13:35:07.714]                   name <- changed[[kk]]
[13:35:07.714]                   NAME <- NAMES[[kk]]
[13:35:07.714]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.714]                     next
[13:35:07.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.714]                 }
[13:35:07.714]                 NAMES <- toupper(added)
[13:35:07.714]                 for (kk in seq_along(NAMES)) {
[13:35:07.714]                   name <- added[[kk]]
[13:35:07.714]                   NAME <- NAMES[[kk]]
[13:35:07.714]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.714]                     next
[13:35:07.714]                   args[[name]] <- ""
[13:35:07.714]                 }
[13:35:07.714]                 NAMES <- toupper(removed)
[13:35:07.714]                 for (kk in seq_along(NAMES)) {
[13:35:07.714]                   name <- removed[[kk]]
[13:35:07.714]                   NAME <- NAMES[[kk]]
[13:35:07.714]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.714]                     next
[13:35:07.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.714]                 }
[13:35:07.714]                 if (length(args) > 0) 
[13:35:07.714]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.714]             }
[13:35:07.714]             else {
[13:35:07.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.714]             }
[13:35:07.714]             {
[13:35:07.714]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.714]                   0L) {
[13:35:07.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.714]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.714]                   base::options(opts)
[13:35:07.714]                 }
[13:35:07.714]                 {
[13:35:07.714]                   {
[13:35:07.714]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.714]                     NULL
[13:35:07.714]                   }
[13:35:07.714]                   options(future.plan = NULL)
[13:35:07.714]                   if (is.na(NA_character_)) 
[13:35:07.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.714]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.714]                     .init = FALSE)
[13:35:07.714]                 }
[13:35:07.714]             }
[13:35:07.714]         }
[13:35:07.714]     })
[13:35:07.714]     if (TRUE) {
[13:35:07.714]         base::sink(type = "output", split = FALSE)
[13:35:07.714]         if (TRUE) {
[13:35:07.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.714]         }
[13:35:07.714]         else {
[13:35:07.714]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.714]         }
[13:35:07.714]         base::close(...future.stdout)
[13:35:07.714]         ...future.stdout <- NULL
[13:35:07.714]     }
[13:35:07.714]     ...future.result$conditions <- ...future.conditions
[13:35:07.714]     ...future.result$finished <- base::Sys.time()
[13:35:07.714]     ...future.result
[13:35:07.714] }
[13:35:07.717] assign_globals() ...
[13:35:07.717] List of 11
[13:35:07.717]  $ ...future.FUN            :function (x, ...)  
[13:35:07.717]  $ x_FUN                    :function (x, ...)  
[13:35:07.717]  $ times                    : int 5
[13:35:07.717]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.717]  $ stop_if_not              :function (...)  
[13:35:07.717]  $ dim                      : NULL
[13:35:07.717]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:07.717]  $ future.call.arguments    : list()
[13:35:07.717]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.717]  $ ...future.elements_ii    :List of 2
[13:35:07.717]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[13:35:07.717]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[13:35:07.717]  $ ...future.seeds_ii       : NULL
[13:35:07.717]  $ ...future.globals.maxSize: NULL
[13:35:07.717]  - attr(*, "where")=List of 11
[13:35:07.717]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.717]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:07.717]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:07.717]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:07.717]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:07.717]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:07.717]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:07.717]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.717]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.717]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.717]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.717]  - attr(*, "resolved")= logi FALSE
[13:35:07.717]  - attr(*, "total_size")= num 95528
[13:35:07.717]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.717]  - attr(*, "already-done")= logi TRUE
[13:35:07.727] - copied ‘...future.FUN’ to environment
[13:35:07.727] - copied ‘x_FUN’ to environment
[13:35:07.727] - copied ‘times’ to environment
[13:35:07.727] - copied ‘stopf’ to environment
[13:35:07.727] - copied ‘stop_if_not’ to environment
[13:35:07.728] - copied ‘dim’ to environment
[13:35:07.728] - copied ‘valid_types’ to environment
[13:35:07.728] - copied ‘future.call.arguments’ to environment
[13:35:07.728] - copied ‘...future.elements_ii’ to environment
[13:35:07.728] - copied ‘...future.seeds_ii’ to environment
[13:35:07.728] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.728] assign_globals() ... done
[13:35:07.728] requestCore(): workers = 2
[13:35:07.730] MulticoreFuture started
[13:35:07.731] - Launch lazy future ... done
[13:35:07.731] run() for ‘MulticoreFuture’ ... done
[13:35:07.731] Created future:
[13:35:07.732] plan(): Setting new future strategy stack:
[13:35:07.732] List of future strategies:
[13:35:07.732] 1. sequential:
[13:35:07.732]    - args: function (..., envir = parent.frame())
[13:35:07.732]    - tweaked: FALSE
[13:35:07.732]    - call: NULL
[13:35:07.733] plan(): nbrOfWorkers() = 1
[13:35:07.736] plan(): Setting new future strategy stack:
[13:35:07.736] List of future strategies:
[13:35:07.736] 1. multicore:
[13:35:07.736]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.736]    - tweaked: FALSE
[13:35:07.736]    - call: plan(strategy)
[13:35:07.731] MulticoreFuture:
[13:35:07.731] Label: ‘future_vapply-2’
[13:35:07.731] Expression:
[13:35:07.731] {
[13:35:07.731]     do.call(function(...) {
[13:35:07.731]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.731]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.731]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.731]             on.exit(options(oopts), add = TRUE)
[13:35:07.731]         }
[13:35:07.731]         {
[13:35:07.731]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.731]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.731]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.731]             })
[13:35:07.731]         }
[13:35:07.731]     }, args = future.call.arguments)
[13:35:07.731] }
[13:35:07.731] Lazy evaluation: FALSE
[13:35:07.731] Asynchronous evaluation: TRUE
[13:35:07.731] Local evaluation: TRUE
[13:35:07.731] Environment: R_GlobalEnv
[13:35:07.731] Capture standard output: TRUE
[13:35:07.731] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.731] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:07.731] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:35:07.731] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.731] Resolved: FALSE
[13:35:07.731] Value: <not collected>
[13:35:07.731] Conditions captured: <none>
[13:35:07.731] Early signaling: FALSE
[13:35:07.731] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.731] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.744] Chunk #2 of 2 ... DONE
[13:35:07.745] Launching 2 futures (chunks) ... DONE
[13:35:07.745] Resolving 2 futures (chunks) ...
[13:35:07.745] resolve() on list ...
[13:35:07.745]  recursive: 0
[13:35:07.745]  length: 2
[13:35:07.747] plan(): nbrOfWorkers() = 2
[13:35:07.745] 
[13:35:07.748] Future #1
[13:35:07.749] result() for MulticoreFuture ...
[13:35:07.750] result() for MulticoreFuture ...
[13:35:07.750] result() for MulticoreFuture ... done
[13:35:07.750] result() for MulticoreFuture ... done
[13:35:07.750] result() for MulticoreFuture ...
[13:35:07.751] result() for MulticoreFuture ... done
[13:35:07.751] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:07.751] - nx: 2
[13:35:07.751] - relay: TRUE
[13:35:07.752] - stdout: TRUE
[13:35:07.752] - signal: TRUE
[13:35:07.752] - resignal: FALSE
[13:35:07.752] - force: TRUE
[13:35:07.752] - relayed: [n=2] FALSE, FALSE
[13:35:07.753] - queued futures: [n=2] FALSE, FALSE
[13:35:07.753]  - until=1
[13:35:07.753]  - relaying element #1
[13:35:07.754] result() for MulticoreFuture ...
[13:35:07.754] result() for MulticoreFuture ... done
[13:35:07.754] result() for MulticoreFuture ...
[13:35:07.754] result() for MulticoreFuture ... done
[13:35:07.755] result() for MulticoreFuture ...
[13:35:07.755] result() for MulticoreFuture ... done
[13:35:07.755] result() for MulticoreFuture ...
[13:35:07.755] result() for MulticoreFuture ... done
[13:35:07.755] - relayed: [n=2] TRUE, FALSE
[13:35:07.756] - queued futures: [n=2] TRUE, FALSE
[13:35:07.756] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:07.756]  length: 1 (resolved future 1)
[13:35:07.757] Future #2
[13:35:07.757] result() for MulticoreFuture ...
[13:35:07.758] result() for MulticoreFuture ...
[13:35:07.758] result() for MulticoreFuture ... done
[13:35:07.758] result() for MulticoreFuture ... done
[13:35:07.758] result() for MulticoreFuture ...
[13:35:07.759] result() for MulticoreFuture ... done
[13:35:07.759] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:07.759] - nx: 2
[13:35:07.759] - relay: TRUE
[13:35:07.759] - stdout: TRUE
[13:35:07.759] - signal: TRUE
[13:35:07.760] - resignal: FALSE
[13:35:07.760] - force: TRUE
[13:35:07.760] - relayed: [n=2] TRUE, FALSE
[13:35:07.760] - queued futures: [n=2] TRUE, FALSE
[13:35:07.760]  - until=2
[13:35:07.760]  - relaying element #2
[13:35:07.760] result() for MulticoreFuture ...
[13:35:07.760] result() for MulticoreFuture ... done
[13:35:07.761] result() for MulticoreFuture ...
[13:35:07.761] result() for MulticoreFuture ... done
[13:35:07.761] result() for MulticoreFuture ...
[13:35:07.761] result() for MulticoreFuture ... done
[13:35:07.761] result() for MulticoreFuture ...
[13:35:07.761] result() for MulticoreFuture ... done
[13:35:07.761] - relayed: [n=2] TRUE, TRUE
[13:35:07.762] - queued futures: [n=2] TRUE, TRUE
[13:35:07.762] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:07.762]  length: 0 (resolved future 2)
[13:35:07.762] Relaying remaining futures
[13:35:07.762] signalConditionsASAP(NULL, pos=0) ...
[13:35:07.762] - nx: 2
[13:35:07.762] - relay: TRUE
[13:35:07.762] - stdout: TRUE
[13:35:07.762] - signal: TRUE
[13:35:07.763] - resignal: FALSE
[13:35:07.763] - force: TRUE
[13:35:07.763] - relayed: [n=2] TRUE, TRUE
[13:35:07.763] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:07.763] - relayed: [n=2] TRUE, TRUE
[13:35:07.763] - queued futures: [n=2] TRUE, TRUE
[13:35:07.763] signalConditionsASAP(NULL, pos=0) ... done
[13:35:07.763] resolve() on list ... DONE
[13:35:07.763] result() for MulticoreFuture ...
[13:35:07.764] result() for MulticoreFuture ... done
[13:35:07.764] result() for MulticoreFuture ...
[13:35:07.764] result() for MulticoreFuture ... done
[13:35:07.764] result() for MulticoreFuture ...
[13:35:07.764] result() for MulticoreFuture ... done
[13:35:07.764] result() for MulticoreFuture ...
[13:35:07.764] result() for MulticoreFuture ... done
[13:35:07.764]  - Number of value chunks collected: 2
[13:35:07.764] Resolving 2 futures (chunks) ... DONE
[13:35:07.765] Reducing values from 2 chunks ...
[13:35:07.765]  - Number of values collected after concatenation: 3
[13:35:07.765]  - Number of values expected: 3
[13:35:07.765] Reducing values from 2 chunks ... DONE
[13:35:07.765] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[13:35:07.767] future_lapply() ...
[13:35:07.775] Number of chunks: 2
[13:35:07.775] getGlobalsAndPackagesXApply() ...
[13:35:07.775]  - future.globals: TRUE
[13:35:07.775] getGlobalsAndPackages() ...
[13:35:07.775] Searching for globals...
[13:35:07.783] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:35:07.783] Searching for globals ... DONE
[13:35:07.783] Resolving globals: FALSE
[13:35:07.784] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[13:35:07.784] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[13:35:07.784] - globals: [1] ‘FUN’
[13:35:07.785] - packages: [1] ‘stats’
[13:35:07.785] getGlobalsAndPackages() ... DONE
[13:35:07.785]  - globals found/used: [n=1] ‘FUN’
[13:35:07.785]  - needed namespaces: [n=1] ‘stats’
[13:35:07.785] Finding globals ... DONE
[13:35:07.785]  - use_args: TRUE
[13:35:07.785]  - Getting '...' globals ...
[13:35:07.785] resolve() on list ...
[13:35:07.786]  recursive: 0
[13:35:07.786]  length: 1
[13:35:07.786]  elements: ‘...’
[13:35:07.786]  length: 0 (resolved future 1)
[13:35:07.786] resolve() on list ... DONE
[13:35:07.786]    - '...' content: [n=0] 
[13:35:07.786] List of 1
[13:35:07.786]  $ ...: list()
[13:35:07.786]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.786]  - attr(*, "where")=List of 1
[13:35:07.786]   ..$ ...:<environment: 0x5574cf1424f8> 
[13:35:07.786]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.786]  - attr(*, "resolved")= logi TRUE
[13:35:07.786]  - attr(*, "total_size")= num NA
[13:35:07.789]  - Getting '...' globals ... DONE
[13:35:07.789] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:07.789] List of 2
[13:35:07.789]  $ ...future.FUN:function (x, na.rm = TRUE)  
[13:35:07.789]  $ ...          : list()
[13:35:07.789]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.789]  - attr(*, "where")=List of 2
[13:35:07.789]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:07.789]   ..$ ...          :<environment: 0x5574cf1424f8> 
[13:35:07.789]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.789]  - attr(*, "resolved")= logi FALSE
[13:35:07.789]  - attr(*, "total_size")= num 46960
[13:35:07.792] Packages to be attached in all futures: [n=1] ‘stats’
[13:35:07.792] getGlobalsAndPackagesXApply() ... DONE
[13:35:07.792] Number of futures (= number of chunks): 2
[13:35:07.792] Launching 2 futures (chunks) ...
[13:35:07.792] Chunk #1 of 2 ...
[13:35:07.792]  - Finding globals in 'X' for chunk #1 ...
[13:35:07.792] getGlobalsAndPackages() ...
[13:35:07.792] Searching for globals...
[13:35:07.793] 
[13:35:07.793] Searching for globals ... DONE
[13:35:07.793] - globals: [0] <none>
[13:35:07.793] getGlobalsAndPackages() ... DONE
[13:35:07.793]    + additional globals found: [n=0] 
[13:35:07.793]    + additional namespaces needed: [n=0] 
[13:35:07.793]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:07.793]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.793]  - seeds: <none>
[13:35:07.794]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.794] getGlobalsAndPackages() ...
[13:35:07.794] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.794] Resolving globals: FALSE
[13:35:07.794] Tweak future expression to call with '...' arguments ...
[13:35:07.794] {
[13:35:07.794]     do.call(function(...) {
[13:35:07.794]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.794]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.794]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.794]             on.exit(options(oopts), add = TRUE)
[13:35:07.794]         }
[13:35:07.794]         {
[13:35:07.794]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.794]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.794]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.794]             })
[13:35:07.794]         }
[13:35:07.794]     }, args = future.call.arguments)
[13:35:07.794] }
[13:35:07.794] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.795] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.795] - packages: [1] ‘stats’
[13:35:07.795] getGlobalsAndPackages() ... DONE
[13:35:07.795] run() for ‘Future’ ...
[13:35:07.795] - state: ‘created’
[13:35:07.796] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.801] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.801] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.801]   - Field: ‘label’
[13:35:07.801]   - Field: ‘local’
[13:35:07.801]   - Field: ‘owner’
[13:35:07.802]   - Field: ‘envir’
[13:35:07.802]   - Field: ‘workers’
[13:35:07.802]   - Field: ‘packages’
[13:35:07.802]   - Field: ‘gc’
[13:35:07.802]   - Field: ‘job’
[13:35:07.802]   - Field: ‘conditions’
[13:35:07.802]   - Field: ‘expr’
[13:35:07.802]   - Field: ‘uuid’
[13:35:07.802]   - Field: ‘seed’
[13:35:07.803]   - Field: ‘version’
[13:35:07.803]   - Field: ‘result’
[13:35:07.803]   - Field: ‘asynchronous’
[13:35:07.803]   - Field: ‘calls’
[13:35:07.803]   - Field: ‘globals’
[13:35:07.803]   - Field: ‘stdout’
[13:35:07.803]   - Field: ‘earlySignal’
[13:35:07.803]   - Field: ‘lazy’
[13:35:07.803]   - Field: ‘state’
[13:35:07.803] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.804] - Launch lazy future ...
[13:35:07.804] Packages needed by the future expression (n = 1): ‘stats’
[13:35:07.804] Packages needed by future strategies (n = 0): <none>
[13:35:07.805] {
[13:35:07.805]     {
[13:35:07.805]         {
[13:35:07.805]             ...future.startTime <- base::Sys.time()
[13:35:07.805]             {
[13:35:07.805]                 {
[13:35:07.805]                   {
[13:35:07.805]                     {
[13:35:07.805]                       {
[13:35:07.805]                         base::local({
[13:35:07.805]                           has_future <- base::requireNamespace("future", 
[13:35:07.805]                             quietly = TRUE)
[13:35:07.805]                           if (has_future) {
[13:35:07.805]                             ns <- base::getNamespace("future")
[13:35:07.805]                             version <- ns[[".package"]][["version"]]
[13:35:07.805]                             if (is.null(version)) 
[13:35:07.805]                               version <- utils::packageVersion("future")
[13:35:07.805]                           }
[13:35:07.805]                           else {
[13:35:07.805]                             version <- NULL
[13:35:07.805]                           }
[13:35:07.805]                           if (!has_future || version < "1.8.0") {
[13:35:07.805]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.805]                               "", base::R.version$version.string), 
[13:35:07.805]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.805]                                 base::R.version$platform, 8 * 
[13:35:07.805]                                   base::.Machine$sizeof.pointer), 
[13:35:07.805]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.805]                                 "release", "version")], collapse = " "), 
[13:35:07.805]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.805]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.805]                               info)
[13:35:07.805]                             info <- base::paste(info, collapse = "; ")
[13:35:07.805]                             if (!has_future) {
[13:35:07.805]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.805]                                 info)
[13:35:07.805]                             }
[13:35:07.805]                             else {
[13:35:07.805]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.805]                                 info, version)
[13:35:07.805]                             }
[13:35:07.805]                             base::stop(msg)
[13:35:07.805]                           }
[13:35:07.805]                         })
[13:35:07.805]                       }
[13:35:07.805]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.805]                       base::options(mc.cores = 1L)
[13:35:07.805]                     }
[13:35:07.805]                     base::local({
[13:35:07.805]                       for (pkg in "stats") {
[13:35:07.805]                         base::loadNamespace(pkg)
[13:35:07.805]                         base::library(pkg, character.only = TRUE)
[13:35:07.805]                       }
[13:35:07.805]                     })
[13:35:07.805]                   }
[13:35:07.805]                   ...future.strategy.old <- future::plan("list")
[13:35:07.805]                   options(future.plan = NULL)
[13:35:07.805]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.805]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.805]                 }
[13:35:07.805]                 ...future.workdir <- getwd()
[13:35:07.805]             }
[13:35:07.805]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.805]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.805]         }
[13:35:07.805]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.805]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.805]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.805]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.805]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.805]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.805]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.805]             base::names(...future.oldOptions))
[13:35:07.805]     }
[13:35:07.805]     if (FALSE) {
[13:35:07.805]     }
[13:35:07.805]     else {
[13:35:07.805]         if (TRUE) {
[13:35:07.805]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.805]                 open = "w")
[13:35:07.805]         }
[13:35:07.805]         else {
[13:35:07.805]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.805]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.805]         }
[13:35:07.805]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.805]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.805]             base::sink(type = "output", split = FALSE)
[13:35:07.805]             base::close(...future.stdout)
[13:35:07.805]         }, add = TRUE)
[13:35:07.805]     }
[13:35:07.805]     ...future.frame <- base::sys.nframe()
[13:35:07.805]     ...future.conditions <- base::list()
[13:35:07.805]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.805]     if (FALSE) {
[13:35:07.805]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.805]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.805]     }
[13:35:07.805]     ...future.result <- base::tryCatch({
[13:35:07.805]         base::withCallingHandlers({
[13:35:07.805]             ...future.value <- base::withVisible(base::local({
[13:35:07.805]                 withCallingHandlers({
[13:35:07.805]                   {
[13:35:07.805]                     do.call(function(...) {
[13:35:07.805]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.805]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.805]                         ...future.globals.maxSize)) {
[13:35:07.805]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.805]                         on.exit(options(oopts), add = TRUE)
[13:35:07.805]                       }
[13:35:07.805]                       {
[13:35:07.805]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.805]                           FUN = function(jj) {
[13:35:07.805]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.805]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.805]                           })
[13:35:07.805]                       }
[13:35:07.805]                     }, args = future.call.arguments)
[13:35:07.805]                   }
[13:35:07.805]                 }, immediateCondition = function(cond) {
[13:35:07.805]                   save_rds <- function (object, pathname, ...) 
[13:35:07.805]                   {
[13:35:07.805]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.805]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.805]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.805]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.805]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.805]                         fi_tmp[["mtime"]])
[13:35:07.805]                     }
[13:35:07.805]                     tryCatch({
[13:35:07.805]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.805]                     }, error = function(ex) {
[13:35:07.805]                       msg <- conditionMessage(ex)
[13:35:07.805]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.805]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.805]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.805]                         fi_tmp[["mtime"]], msg)
[13:35:07.805]                       ex$message <- msg
[13:35:07.805]                       stop(ex)
[13:35:07.805]                     })
[13:35:07.805]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.805]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.805]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.805]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.805]                       fi <- file.info(pathname)
[13:35:07.805]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.805]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.805]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.805]                         fi[["size"]], fi[["mtime"]])
[13:35:07.805]                       stop(msg)
[13:35:07.805]                     }
[13:35:07.805]                     invisible(pathname)
[13:35:07.805]                   }
[13:35:07.805]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.805]                     rootPath = tempdir()) 
[13:35:07.805]                   {
[13:35:07.805]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.805]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.805]                       tmpdir = path, fileext = ".rds")
[13:35:07.805]                     save_rds(obj, file)
[13:35:07.805]                   }
[13:35:07.805]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.805]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.805]                   {
[13:35:07.805]                     inherits <- base::inherits
[13:35:07.805]                     invokeRestart <- base::invokeRestart
[13:35:07.805]                     is.null <- base::is.null
[13:35:07.805]                     muffled <- FALSE
[13:35:07.805]                     if (inherits(cond, "message")) {
[13:35:07.805]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.805]                       if (muffled) 
[13:35:07.805]                         invokeRestart("muffleMessage")
[13:35:07.805]                     }
[13:35:07.805]                     else if (inherits(cond, "warning")) {
[13:35:07.805]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.805]                       if (muffled) 
[13:35:07.805]                         invokeRestart("muffleWarning")
[13:35:07.805]                     }
[13:35:07.805]                     else if (inherits(cond, "condition")) {
[13:35:07.805]                       if (!is.null(pattern)) {
[13:35:07.805]                         computeRestarts <- base::computeRestarts
[13:35:07.805]                         grepl <- base::grepl
[13:35:07.805]                         restarts <- computeRestarts(cond)
[13:35:07.805]                         for (restart in restarts) {
[13:35:07.805]                           name <- restart$name
[13:35:07.805]                           if (is.null(name)) 
[13:35:07.805]                             next
[13:35:07.805]                           if (!grepl(pattern, name)) 
[13:35:07.805]                             next
[13:35:07.805]                           invokeRestart(restart)
[13:35:07.805]                           muffled <- TRUE
[13:35:07.805]                           break
[13:35:07.805]                         }
[13:35:07.805]                       }
[13:35:07.805]                     }
[13:35:07.805]                     invisible(muffled)
[13:35:07.805]                   }
[13:35:07.805]                   muffleCondition(cond)
[13:35:07.805]                 })
[13:35:07.805]             }))
[13:35:07.805]             future::FutureResult(value = ...future.value$value, 
[13:35:07.805]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.805]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.805]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.805]                     ...future.globalenv.names))
[13:35:07.805]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.805]         }, condition = base::local({
[13:35:07.805]             c <- base::c
[13:35:07.805]             inherits <- base::inherits
[13:35:07.805]             invokeRestart <- base::invokeRestart
[13:35:07.805]             length <- base::length
[13:35:07.805]             list <- base::list
[13:35:07.805]             seq.int <- base::seq.int
[13:35:07.805]             signalCondition <- base::signalCondition
[13:35:07.805]             sys.calls <- base::sys.calls
[13:35:07.805]             `[[` <- base::`[[`
[13:35:07.805]             `+` <- base::`+`
[13:35:07.805]             `<<-` <- base::`<<-`
[13:35:07.805]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.805]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.805]                   3L)]
[13:35:07.805]             }
[13:35:07.805]             function(cond) {
[13:35:07.805]                 is_error <- inherits(cond, "error")
[13:35:07.805]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.805]                   NULL)
[13:35:07.805]                 if (is_error) {
[13:35:07.805]                   sessionInformation <- function() {
[13:35:07.805]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.805]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.805]                       search = base::search(), system = base::Sys.info())
[13:35:07.805]                   }
[13:35:07.805]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.805]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.805]                     cond$call), session = sessionInformation(), 
[13:35:07.805]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.805]                   signalCondition(cond)
[13:35:07.805]                 }
[13:35:07.805]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.805]                 "immediateCondition"))) {
[13:35:07.805]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.805]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.805]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.805]                   if (TRUE && !signal) {
[13:35:07.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.805]                     {
[13:35:07.805]                       inherits <- base::inherits
[13:35:07.805]                       invokeRestart <- base::invokeRestart
[13:35:07.805]                       is.null <- base::is.null
[13:35:07.805]                       muffled <- FALSE
[13:35:07.805]                       if (inherits(cond, "message")) {
[13:35:07.805]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.805]                         if (muffled) 
[13:35:07.805]                           invokeRestart("muffleMessage")
[13:35:07.805]                       }
[13:35:07.805]                       else if (inherits(cond, "warning")) {
[13:35:07.805]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.805]                         if (muffled) 
[13:35:07.805]                           invokeRestart("muffleWarning")
[13:35:07.805]                       }
[13:35:07.805]                       else if (inherits(cond, "condition")) {
[13:35:07.805]                         if (!is.null(pattern)) {
[13:35:07.805]                           computeRestarts <- base::computeRestarts
[13:35:07.805]                           grepl <- base::grepl
[13:35:07.805]                           restarts <- computeRestarts(cond)
[13:35:07.805]                           for (restart in restarts) {
[13:35:07.805]                             name <- restart$name
[13:35:07.805]                             if (is.null(name)) 
[13:35:07.805]                               next
[13:35:07.805]                             if (!grepl(pattern, name)) 
[13:35:07.805]                               next
[13:35:07.805]                             invokeRestart(restart)
[13:35:07.805]                             muffled <- TRUE
[13:35:07.805]                             break
[13:35:07.805]                           }
[13:35:07.805]                         }
[13:35:07.805]                       }
[13:35:07.805]                       invisible(muffled)
[13:35:07.805]                     }
[13:35:07.805]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.805]                   }
[13:35:07.805]                 }
[13:35:07.805]                 else {
[13:35:07.805]                   if (TRUE) {
[13:35:07.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.805]                     {
[13:35:07.805]                       inherits <- base::inherits
[13:35:07.805]                       invokeRestart <- base::invokeRestart
[13:35:07.805]                       is.null <- base::is.null
[13:35:07.805]                       muffled <- FALSE
[13:35:07.805]                       if (inherits(cond, "message")) {
[13:35:07.805]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.805]                         if (muffled) 
[13:35:07.805]                           invokeRestart("muffleMessage")
[13:35:07.805]                       }
[13:35:07.805]                       else if (inherits(cond, "warning")) {
[13:35:07.805]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.805]                         if (muffled) 
[13:35:07.805]                           invokeRestart("muffleWarning")
[13:35:07.805]                       }
[13:35:07.805]                       else if (inherits(cond, "condition")) {
[13:35:07.805]                         if (!is.null(pattern)) {
[13:35:07.805]                           computeRestarts <- base::computeRestarts
[13:35:07.805]                           grepl <- base::grepl
[13:35:07.805]                           restarts <- computeRestarts(cond)
[13:35:07.805]                           for (restart in restarts) {
[13:35:07.805]                             name <- restart$name
[13:35:07.805]                             if (is.null(name)) 
[13:35:07.805]                               next
[13:35:07.805]                             if (!grepl(pattern, name)) 
[13:35:07.805]                               next
[13:35:07.805]                             invokeRestart(restart)
[13:35:07.805]                             muffled <- TRUE
[13:35:07.805]                             break
[13:35:07.805]                           }
[13:35:07.805]                         }
[13:35:07.805]                       }
[13:35:07.805]                       invisible(muffled)
[13:35:07.805]                     }
[13:35:07.805]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.805]                   }
[13:35:07.805]                 }
[13:35:07.805]             }
[13:35:07.805]         }))
[13:35:07.805]     }, error = function(ex) {
[13:35:07.805]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.805]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.805]                 ...future.rng), started = ...future.startTime, 
[13:35:07.805]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.805]             version = "1.8"), class = "FutureResult")
[13:35:07.805]     }, finally = {
[13:35:07.805]         if (!identical(...future.workdir, getwd())) 
[13:35:07.805]             setwd(...future.workdir)
[13:35:07.805]         {
[13:35:07.805]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.805]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.805]             }
[13:35:07.805]             base::options(...future.oldOptions)
[13:35:07.805]             if (.Platform$OS.type == "windows") {
[13:35:07.805]                 old_names <- names(...future.oldEnvVars)
[13:35:07.805]                 envs <- base::Sys.getenv()
[13:35:07.805]                 names <- names(envs)
[13:35:07.805]                 common <- intersect(names, old_names)
[13:35:07.805]                 added <- setdiff(names, old_names)
[13:35:07.805]                 removed <- setdiff(old_names, names)
[13:35:07.805]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.805]                   envs[common]]
[13:35:07.805]                 NAMES <- toupper(changed)
[13:35:07.805]                 args <- list()
[13:35:07.805]                 for (kk in seq_along(NAMES)) {
[13:35:07.805]                   name <- changed[[kk]]
[13:35:07.805]                   NAME <- NAMES[[kk]]
[13:35:07.805]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.805]                     next
[13:35:07.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.805]                 }
[13:35:07.805]                 NAMES <- toupper(added)
[13:35:07.805]                 for (kk in seq_along(NAMES)) {
[13:35:07.805]                   name <- added[[kk]]
[13:35:07.805]                   NAME <- NAMES[[kk]]
[13:35:07.805]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.805]                     next
[13:35:07.805]                   args[[name]] <- ""
[13:35:07.805]                 }
[13:35:07.805]                 NAMES <- toupper(removed)
[13:35:07.805]                 for (kk in seq_along(NAMES)) {
[13:35:07.805]                   name <- removed[[kk]]
[13:35:07.805]                   NAME <- NAMES[[kk]]
[13:35:07.805]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.805]                     next
[13:35:07.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.805]                 }
[13:35:07.805]                 if (length(args) > 0) 
[13:35:07.805]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.805]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.805]             }
[13:35:07.805]             else {
[13:35:07.805]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.805]             }
[13:35:07.805]             {
[13:35:07.805]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.805]                   0L) {
[13:35:07.805]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.805]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.805]                   base::options(opts)
[13:35:07.805]                 }
[13:35:07.805]                 {
[13:35:07.805]                   {
[13:35:07.805]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.805]                     NULL
[13:35:07.805]                   }
[13:35:07.805]                   options(future.plan = NULL)
[13:35:07.805]                   if (is.na(NA_character_)) 
[13:35:07.805]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.805]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.805]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.805]                     .init = FALSE)
[13:35:07.805]                 }
[13:35:07.805]             }
[13:35:07.805]         }
[13:35:07.805]     })
[13:35:07.805]     if (TRUE) {
[13:35:07.805]         base::sink(type = "output", split = FALSE)
[13:35:07.805]         if (TRUE) {
[13:35:07.805]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.805]         }
[13:35:07.805]         else {
[13:35:07.805]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.805]         }
[13:35:07.805]         base::close(...future.stdout)
[13:35:07.805]         ...future.stdout <- NULL
[13:35:07.805]     }
[13:35:07.805]     ...future.result$conditions <- ...future.conditions
[13:35:07.805]     ...future.result$finished <- base::Sys.time()
[13:35:07.805]     ...future.result
[13:35:07.805] }
[13:35:07.807] assign_globals() ...
[13:35:07.807] List of 5
[13:35:07.807]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[13:35:07.807]  $ future.call.arguments    : list()
[13:35:07.807]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.807]  $ ...future.elements_ii    :List of 4
[13:35:07.807]   ..$ : int [1:3] 1 2 3
[13:35:07.807]   ..$ : int [1:4] 1 2 3 4
[13:35:07.807]   ..$ : int [1:5] 1 2 3 4 5
[13:35:07.807]   ..$ : int [1:6] 1 2 3 4 5 6
[13:35:07.807]  $ ...future.seeds_ii       : NULL
[13:35:07.807]  $ ...future.globals.maxSize: NULL
[13:35:07.807]  - attr(*, "where")=List of 5
[13:35:07.807]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.807]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.807]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.807]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.807]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.807]  - attr(*, "resolved")= logi FALSE
[13:35:07.807]  - attr(*, "total_size")= num 46960
[13:35:07.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.807]  - attr(*, "already-done")= logi TRUE
[13:35:07.812] - copied ‘...future.FUN’ to environment
[13:35:07.812] - copied ‘future.call.arguments’ to environment
[13:35:07.813] - copied ‘...future.elements_ii’ to environment
[13:35:07.813] - copied ‘...future.seeds_ii’ to environment
[13:35:07.813] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.813] assign_globals() ... done
[13:35:07.813] requestCore(): workers = 2
[13:35:07.815] MulticoreFuture started
[13:35:07.815] - Launch lazy future ... done
[13:35:07.816] run() for ‘MulticoreFuture’ ... done
[13:35:07.816] Created future:
[13:35:07.816] plan(): Setting new future strategy stack:
[13:35:07.817] List of future strategies:
[13:35:07.817] 1. sequential:
[13:35:07.817]    - args: function (..., envir = parent.frame())
[13:35:07.817]    - tweaked: FALSE
[13:35:07.817]    - call: NULL
[13:35:07.817] plan(): nbrOfWorkers() = 1
[13:35:07.820] plan(): Setting new future strategy stack:
[13:35:07.820] List of future strategies:
[13:35:07.820] 1. multicore:
[13:35:07.820]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.820]    - tweaked: FALSE
[13:35:07.820]    - call: plan(strategy)
[13:35:07.825] plan(): nbrOfWorkers() = 2
[13:35:07.816] MulticoreFuture:
[13:35:07.816] Label: ‘future_sapply-1’
[13:35:07.816] Expression:
[13:35:07.816] {
[13:35:07.816]     do.call(function(...) {
[13:35:07.816]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.816]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.816]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.816]             on.exit(options(oopts), add = TRUE)
[13:35:07.816]         }
[13:35:07.816]         {
[13:35:07.816]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.816]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.816]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.816]             })
[13:35:07.816]         }
[13:35:07.816]     }, args = future.call.arguments)
[13:35:07.816] }
[13:35:07.816] Lazy evaluation: FALSE
[13:35:07.816] Asynchronous evaluation: TRUE
[13:35:07.816] Local evaluation: TRUE
[13:35:07.816] Environment: R_GlobalEnv
[13:35:07.816] Capture standard output: TRUE
[13:35:07.816] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.816] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:07.816] Packages: 1 packages (‘stats’)
[13:35:07.816] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.816] Resolved: TRUE
[13:35:07.816] Value: <not collected>
[13:35:07.816] Conditions captured: <none>
[13:35:07.816] Early signaling: FALSE
[13:35:07.816] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.816] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.826] Chunk #1 of 2 ... DONE
[13:35:07.826] Chunk #2 of 2 ...
[13:35:07.826]  - Finding globals in 'X' for chunk #2 ...
[13:35:07.827] getGlobalsAndPackages() ...
[13:35:07.827] Searching for globals...
[13:35:07.827] 
[13:35:07.827] Searching for globals ... DONE
[13:35:07.827] - globals: [0] <none>
[13:35:07.827] getGlobalsAndPackages() ... DONE
[13:35:07.828]    + additional globals found: [n=0] 
[13:35:07.828]    + additional namespaces needed: [n=0] 
[13:35:07.828]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:07.828]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.828]  - seeds: <none>
[13:35:07.828]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.828] getGlobalsAndPackages() ...
[13:35:07.829] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.829] Resolving globals: FALSE
[13:35:07.829] Tweak future expression to call with '...' arguments ...
[13:35:07.829] {
[13:35:07.829]     do.call(function(...) {
[13:35:07.829]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.829]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.829]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.829]             on.exit(options(oopts), add = TRUE)
[13:35:07.829]         }
[13:35:07.829]         {
[13:35:07.829]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.829]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.829]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.829]             })
[13:35:07.829]         }
[13:35:07.829]     }, args = future.call.arguments)
[13:35:07.829] }
[13:35:07.829] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.830] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.830] - packages: [1] ‘stats’
[13:35:07.830] getGlobalsAndPackages() ... DONE
[13:35:07.831] run() for ‘Future’ ...
[13:35:07.831] - state: ‘created’
[13:35:07.831] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.836] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.836] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.839]   - Field: ‘label’
[13:35:07.840]   - Field: ‘local’
[13:35:07.840]   - Field: ‘owner’
[13:35:07.840]   - Field: ‘envir’
[13:35:07.841]   - Field: ‘workers’
[13:35:07.841]   - Field: ‘packages’
[13:35:07.841]   - Field: ‘gc’
[13:35:07.842]   - Field: ‘job’
[13:35:07.842]   - Field: ‘conditions’
[13:35:07.842]   - Field: ‘expr’
[13:35:07.843]   - Field: ‘uuid’
[13:35:07.843]   - Field: ‘seed’
[13:35:07.843]   - Field: ‘version’
[13:35:07.844]   - Field: ‘result’
[13:35:07.844]   - Field: ‘asynchronous’
[13:35:07.844]   - Field: ‘calls’
[13:35:07.844]   - Field: ‘globals’
[13:35:07.845]   - Field: ‘stdout’
[13:35:07.845]   - Field: ‘earlySignal’
[13:35:07.845]   - Field: ‘lazy’
[13:35:07.845]   - Field: ‘state’
[13:35:07.845] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.846] - Launch lazy future ...
[13:35:07.846] Packages needed by the future expression (n = 1): ‘stats’
[13:35:07.846] Packages needed by future strategies (n = 0): <none>
[13:35:07.848] {
[13:35:07.848]     {
[13:35:07.848]         {
[13:35:07.848]             ...future.startTime <- base::Sys.time()
[13:35:07.848]             {
[13:35:07.848]                 {
[13:35:07.848]                   {
[13:35:07.848]                     {
[13:35:07.848]                       {
[13:35:07.848]                         base::local({
[13:35:07.848]                           has_future <- base::requireNamespace("future", 
[13:35:07.848]                             quietly = TRUE)
[13:35:07.848]                           if (has_future) {
[13:35:07.848]                             ns <- base::getNamespace("future")
[13:35:07.848]                             version <- ns[[".package"]][["version"]]
[13:35:07.848]                             if (is.null(version)) 
[13:35:07.848]                               version <- utils::packageVersion("future")
[13:35:07.848]                           }
[13:35:07.848]                           else {
[13:35:07.848]                             version <- NULL
[13:35:07.848]                           }
[13:35:07.848]                           if (!has_future || version < "1.8.0") {
[13:35:07.848]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.848]                               "", base::R.version$version.string), 
[13:35:07.848]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.848]                                 base::R.version$platform, 8 * 
[13:35:07.848]                                   base::.Machine$sizeof.pointer), 
[13:35:07.848]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.848]                                 "release", "version")], collapse = " "), 
[13:35:07.848]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.848]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.848]                               info)
[13:35:07.848]                             info <- base::paste(info, collapse = "; ")
[13:35:07.848]                             if (!has_future) {
[13:35:07.848]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.848]                                 info)
[13:35:07.848]                             }
[13:35:07.848]                             else {
[13:35:07.848]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.848]                                 info, version)
[13:35:07.848]                             }
[13:35:07.848]                             base::stop(msg)
[13:35:07.848]                           }
[13:35:07.848]                         })
[13:35:07.848]                       }
[13:35:07.848]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.848]                       base::options(mc.cores = 1L)
[13:35:07.848]                     }
[13:35:07.848]                     base::local({
[13:35:07.848]                       for (pkg in "stats") {
[13:35:07.848]                         base::loadNamespace(pkg)
[13:35:07.848]                         base::library(pkg, character.only = TRUE)
[13:35:07.848]                       }
[13:35:07.848]                     })
[13:35:07.848]                   }
[13:35:07.848]                   ...future.strategy.old <- future::plan("list")
[13:35:07.848]                   options(future.plan = NULL)
[13:35:07.848]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.848]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.848]                 }
[13:35:07.848]                 ...future.workdir <- getwd()
[13:35:07.848]             }
[13:35:07.848]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.848]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.848]         }
[13:35:07.848]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.848]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.848]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.848]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.848]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.848]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.848]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.848]             base::names(...future.oldOptions))
[13:35:07.848]     }
[13:35:07.848]     if (FALSE) {
[13:35:07.848]     }
[13:35:07.848]     else {
[13:35:07.848]         if (TRUE) {
[13:35:07.848]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.848]                 open = "w")
[13:35:07.848]         }
[13:35:07.848]         else {
[13:35:07.848]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.848]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.848]         }
[13:35:07.848]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.848]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.848]             base::sink(type = "output", split = FALSE)
[13:35:07.848]             base::close(...future.stdout)
[13:35:07.848]         }, add = TRUE)
[13:35:07.848]     }
[13:35:07.848]     ...future.frame <- base::sys.nframe()
[13:35:07.848]     ...future.conditions <- base::list()
[13:35:07.848]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.848]     if (FALSE) {
[13:35:07.848]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.848]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.848]     }
[13:35:07.848]     ...future.result <- base::tryCatch({
[13:35:07.848]         base::withCallingHandlers({
[13:35:07.848]             ...future.value <- base::withVisible(base::local({
[13:35:07.848]                 withCallingHandlers({
[13:35:07.848]                   {
[13:35:07.848]                     do.call(function(...) {
[13:35:07.848]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.848]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.848]                         ...future.globals.maxSize)) {
[13:35:07.848]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.848]                         on.exit(options(oopts), add = TRUE)
[13:35:07.848]                       }
[13:35:07.848]                       {
[13:35:07.848]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.848]                           FUN = function(jj) {
[13:35:07.848]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.848]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.848]                           })
[13:35:07.848]                       }
[13:35:07.848]                     }, args = future.call.arguments)
[13:35:07.848]                   }
[13:35:07.848]                 }, immediateCondition = function(cond) {
[13:35:07.848]                   save_rds <- function (object, pathname, ...) 
[13:35:07.848]                   {
[13:35:07.848]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.848]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.848]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.848]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.848]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.848]                         fi_tmp[["mtime"]])
[13:35:07.848]                     }
[13:35:07.848]                     tryCatch({
[13:35:07.848]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.848]                     }, error = function(ex) {
[13:35:07.848]                       msg <- conditionMessage(ex)
[13:35:07.848]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.848]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.848]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.848]                         fi_tmp[["mtime"]], msg)
[13:35:07.848]                       ex$message <- msg
[13:35:07.848]                       stop(ex)
[13:35:07.848]                     })
[13:35:07.848]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.848]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.848]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.848]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.848]                       fi <- file.info(pathname)
[13:35:07.848]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.848]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.848]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.848]                         fi[["size"]], fi[["mtime"]])
[13:35:07.848]                       stop(msg)
[13:35:07.848]                     }
[13:35:07.848]                     invisible(pathname)
[13:35:07.848]                   }
[13:35:07.848]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.848]                     rootPath = tempdir()) 
[13:35:07.848]                   {
[13:35:07.848]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.848]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.848]                       tmpdir = path, fileext = ".rds")
[13:35:07.848]                     save_rds(obj, file)
[13:35:07.848]                   }
[13:35:07.848]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.848]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.848]                   {
[13:35:07.848]                     inherits <- base::inherits
[13:35:07.848]                     invokeRestart <- base::invokeRestart
[13:35:07.848]                     is.null <- base::is.null
[13:35:07.848]                     muffled <- FALSE
[13:35:07.848]                     if (inherits(cond, "message")) {
[13:35:07.848]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.848]                       if (muffled) 
[13:35:07.848]                         invokeRestart("muffleMessage")
[13:35:07.848]                     }
[13:35:07.848]                     else if (inherits(cond, "warning")) {
[13:35:07.848]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.848]                       if (muffled) 
[13:35:07.848]                         invokeRestart("muffleWarning")
[13:35:07.848]                     }
[13:35:07.848]                     else if (inherits(cond, "condition")) {
[13:35:07.848]                       if (!is.null(pattern)) {
[13:35:07.848]                         computeRestarts <- base::computeRestarts
[13:35:07.848]                         grepl <- base::grepl
[13:35:07.848]                         restarts <- computeRestarts(cond)
[13:35:07.848]                         for (restart in restarts) {
[13:35:07.848]                           name <- restart$name
[13:35:07.848]                           if (is.null(name)) 
[13:35:07.848]                             next
[13:35:07.848]                           if (!grepl(pattern, name)) 
[13:35:07.848]                             next
[13:35:07.848]                           invokeRestart(restart)
[13:35:07.848]                           muffled <- TRUE
[13:35:07.848]                           break
[13:35:07.848]                         }
[13:35:07.848]                       }
[13:35:07.848]                     }
[13:35:07.848]                     invisible(muffled)
[13:35:07.848]                   }
[13:35:07.848]                   muffleCondition(cond)
[13:35:07.848]                 })
[13:35:07.848]             }))
[13:35:07.848]             future::FutureResult(value = ...future.value$value, 
[13:35:07.848]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.848]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.848]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.848]                     ...future.globalenv.names))
[13:35:07.848]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.848]         }, condition = base::local({
[13:35:07.848]             c <- base::c
[13:35:07.848]             inherits <- base::inherits
[13:35:07.848]             invokeRestart <- base::invokeRestart
[13:35:07.848]             length <- base::length
[13:35:07.848]             list <- base::list
[13:35:07.848]             seq.int <- base::seq.int
[13:35:07.848]             signalCondition <- base::signalCondition
[13:35:07.848]             sys.calls <- base::sys.calls
[13:35:07.848]             `[[` <- base::`[[`
[13:35:07.848]             `+` <- base::`+`
[13:35:07.848]             `<<-` <- base::`<<-`
[13:35:07.848]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.848]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.848]                   3L)]
[13:35:07.848]             }
[13:35:07.848]             function(cond) {
[13:35:07.848]                 is_error <- inherits(cond, "error")
[13:35:07.848]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.848]                   NULL)
[13:35:07.848]                 if (is_error) {
[13:35:07.848]                   sessionInformation <- function() {
[13:35:07.848]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.848]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.848]                       search = base::search(), system = base::Sys.info())
[13:35:07.848]                   }
[13:35:07.848]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.848]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.848]                     cond$call), session = sessionInformation(), 
[13:35:07.848]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.848]                   signalCondition(cond)
[13:35:07.848]                 }
[13:35:07.848]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.848]                 "immediateCondition"))) {
[13:35:07.848]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.848]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.848]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.848]                   if (TRUE && !signal) {
[13:35:07.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.848]                     {
[13:35:07.848]                       inherits <- base::inherits
[13:35:07.848]                       invokeRestart <- base::invokeRestart
[13:35:07.848]                       is.null <- base::is.null
[13:35:07.848]                       muffled <- FALSE
[13:35:07.848]                       if (inherits(cond, "message")) {
[13:35:07.848]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.848]                         if (muffled) 
[13:35:07.848]                           invokeRestart("muffleMessage")
[13:35:07.848]                       }
[13:35:07.848]                       else if (inherits(cond, "warning")) {
[13:35:07.848]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.848]                         if (muffled) 
[13:35:07.848]                           invokeRestart("muffleWarning")
[13:35:07.848]                       }
[13:35:07.848]                       else if (inherits(cond, "condition")) {
[13:35:07.848]                         if (!is.null(pattern)) {
[13:35:07.848]                           computeRestarts <- base::computeRestarts
[13:35:07.848]                           grepl <- base::grepl
[13:35:07.848]                           restarts <- computeRestarts(cond)
[13:35:07.848]                           for (restart in restarts) {
[13:35:07.848]                             name <- restart$name
[13:35:07.848]                             if (is.null(name)) 
[13:35:07.848]                               next
[13:35:07.848]                             if (!grepl(pattern, name)) 
[13:35:07.848]                               next
[13:35:07.848]                             invokeRestart(restart)
[13:35:07.848]                             muffled <- TRUE
[13:35:07.848]                             break
[13:35:07.848]                           }
[13:35:07.848]                         }
[13:35:07.848]                       }
[13:35:07.848]                       invisible(muffled)
[13:35:07.848]                     }
[13:35:07.848]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.848]                   }
[13:35:07.848]                 }
[13:35:07.848]                 else {
[13:35:07.848]                   if (TRUE) {
[13:35:07.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.848]                     {
[13:35:07.848]                       inherits <- base::inherits
[13:35:07.848]                       invokeRestart <- base::invokeRestart
[13:35:07.848]                       is.null <- base::is.null
[13:35:07.848]                       muffled <- FALSE
[13:35:07.848]                       if (inherits(cond, "message")) {
[13:35:07.848]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.848]                         if (muffled) 
[13:35:07.848]                           invokeRestart("muffleMessage")
[13:35:07.848]                       }
[13:35:07.848]                       else if (inherits(cond, "warning")) {
[13:35:07.848]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.848]                         if (muffled) 
[13:35:07.848]                           invokeRestart("muffleWarning")
[13:35:07.848]                       }
[13:35:07.848]                       else if (inherits(cond, "condition")) {
[13:35:07.848]                         if (!is.null(pattern)) {
[13:35:07.848]                           computeRestarts <- base::computeRestarts
[13:35:07.848]                           grepl <- base::grepl
[13:35:07.848]                           restarts <- computeRestarts(cond)
[13:35:07.848]                           for (restart in restarts) {
[13:35:07.848]                             name <- restart$name
[13:35:07.848]                             if (is.null(name)) 
[13:35:07.848]                               next
[13:35:07.848]                             if (!grepl(pattern, name)) 
[13:35:07.848]                               next
[13:35:07.848]                             invokeRestart(restart)
[13:35:07.848]                             muffled <- TRUE
[13:35:07.848]                             break
[13:35:07.848]                           }
[13:35:07.848]                         }
[13:35:07.848]                       }
[13:35:07.848]                       invisible(muffled)
[13:35:07.848]                     }
[13:35:07.848]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.848]                   }
[13:35:07.848]                 }
[13:35:07.848]             }
[13:35:07.848]         }))
[13:35:07.848]     }, error = function(ex) {
[13:35:07.848]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.848]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.848]                 ...future.rng), started = ...future.startTime, 
[13:35:07.848]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.848]             version = "1.8"), class = "FutureResult")
[13:35:07.848]     }, finally = {
[13:35:07.848]         if (!identical(...future.workdir, getwd())) 
[13:35:07.848]             setwd(...future.workdir)
[13:35:07.848]         {
[13:35:07.848]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.848]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.848]             }
[13:35:07.848]             base::options(...future.oldOptions)
[13:35:07.848]             if (.Platform$OS.type == "windows") {
[13:35:07.848]                 old_names <- names(...future.oldEnvVars)
[13:35:07.848]                 envs <- base::Sys.getenv()
[13:35:07.848]                 names <- names(envs)
[13:35:07.848]                 common <- intersect(names, old_names)
[13:35:07.848]                 added <- setdiff(names, old_names)
[13:35:07.848]                 removed <- setdiff(old_names, names)
[13:35:07.848]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.848]                   envs[common]]
[13:35:07.848]                 NAMES <- toupper(changed)
[13:35:07.848]                 args <- list()
[13:35:07.848]                 for (kk in seq_along(NAMES)) {
[13:35:07.848]                   name <- changed[[kk]]
[13:35:07.848]                   NAME <- NAMES[[kk]]
[13:35:07.848]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.848]                     next
[13:35:07.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.848]                 }
[13:35:07.848]                 NAMES <- toupper(added)
[13:35:07.848]                 for (kk in seq_along(NAMES)) {
[13:35:07.848]                   name <- added[[kk]]
[13:35:07.848]                   NAME <- NAMES[[kk]]
[13:35:07.848]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.848]                     next
[13:35:07.848]                   args[[name]] <- ""
[13:35:07.848]                 }
[13:35:07.848]                 NAMES <- toupper(removed)
[13:35:07.848]                 for (kk in seq_along(NAMES)) {
[13:35:07.848]                   name <- removed[[kk]]
[13:35:07.848]                   NAME <- NAMES[[kk]]
[13:35:07.848]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.848]                     next
[13:35:07.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.848]                 }
[13:35:07.848]                 if (length(args) > 0) 
[13:35:07.848]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.848]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.848]             }
[13:35:07.848]             else {
[13:35:07.848]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.848]             }
[13:35:07.848]             {
[13:35:07.848]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.848]                   0L) {
[13:35:07.848]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.848]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.848]                   base::options(opts)
[13:35:07.848]                 }
[13:35:07.848]                 {
[13:35:07.848]                   {
[13:35:07.848]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.848]                     NULL
[13:35:07.848]                   }
[13:35:07.848]                   options(future.plan = NULL)
[13:35:07.848]                   if (is.na(NA_character_)) 
[13:35:07.848]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.848]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.848]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.848]                     .init = FALSE)
[13:35:07.848]                 }
[13:35:07.848]             }
[13:35:07.848]         }
[13:35:07.848]     })
[13:35:07.848]     if (TRUE) {
[13:35:07.848]         base::sink(type = "output", split = FALSE)
[13:35:07.848]         if (TRUE) {
[13:35:07.848]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.848]         }
[13:35:07.848]         else {
[13:35:07.848]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.848]         }
[13:35:07.848]         base::close(...future.stdout)
[13:35:07.848]         ...future.stdout <- NULL
[13:35:07.848]     }
[13:35:07.848]     ...future.result$conditions <- ...future.conditions
[13:35:07.848]     ...future.result$finished <- base::Sys.time()
[13:35:07.848]     ...future.result
[13:35:07.848] }
[13:35:07.851] assign_globals() ...
[13:35:07.851] List of 5
[13:35:07.851]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[13:35:07.851]  $ future.call.arguments    : list()
[13:35:07.851]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.851]  $ ...future.elements_ii    :List of 3
[13:35:07.851]   ..$ : int [1:7] 1 2 3 4 5 6 7
[13:35:07.851]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[13:35:07.851]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[13:35:07.851]  $ ...future.seeds_ii       : NULL
[13:35:07.851]  $ ...future.globals.maxSize: NULL
[13:35:07.851]  - attr(*, "where")=List of 5
[13:35:07.851]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.851]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.851]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.851]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.851]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.851]  - attr(*, "resolved")= logi FALSE
[13:35:07.851]  - attr(*, "total_size")= num 46960
[13:35:07.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.851]  - attr(*, "already-done")= logi TRUE
[13:35:07.859] - copied ‘...future.FUN’ to environment
[13:35:07.860] - copied ‘future.call.arguments’ to environment
[13:35:07.860] - copied ‘...future.elements_ii’ to environment
[13:35:07.860] - copied ‘...future.seeds_ii’ to environment
[13:35:07.860] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.860] assign_globals() ... done
[13:35:07.860] requestCore(): workers = 2
[13:35:07.862] MulticoreFuture started
[13:35:07.863] - Launch lazy future ... done
[13:35:07.863] run() for ‘MulticoreFuture’ ... done
[13:35:07.863] Created future:
[13:35:07.864] plan(): Setting new future strategy stack:
[13:35:07.864] List of future strategies:
[13:35:07.864] 1. sequential:
[13:35:07.864]    - args: function (..., envir = parent.frame())
[13:35:07.864]    - tweaked: FALSE
[13:35:07.864]    - call: NULL
[13:35:07.865] plan(): nbrOfWorkers() = 1
[13:35:07.867] plan(): Setting new future strategy stack:
[13:35:07.868] List of future strategies:
[13:35:07.868] 1. multicore:
[13:35:07.868]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.868]    - tweaked: FALSE
[13:35:07.868]    - call: plan(strategy)
[13:35:07.873] plan(): nbrOfWorkers() = 2
[13:35:07.864] MulticoreFuture:
[13:35:07.864] Label: ‘future_sapply-2’
[13:35:07.864] Expression:
[13:35:07.864] {
[13:35:07.864]     do.call(function(...) {
[13:35:07.864]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.864]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.864]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.864]             on.exit(options(oopts), add = TRUE)
[13:35:07.864]         }
[13:35:07.864]         {
[13:35:07.864]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.864]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.864]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.864]             })
[13:35:07.864]         }
[13:35:07.864]     }, args = future.call.arguments)
[13:35:07.864] }
[13:35:07.864] Lazy evaluation: FALSE
[13:35:07.864] Asynchronous evaluation: TRUE
[13:35:07.864] Local evaluation: TRUE
[13:35:07.864] Environment: R_GlobalEnv
[13:35:07.864] Capture standard output: TRUE
[13:35:07.864] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.864] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:07.864] Packages: 1 packages (‘stats’)
[13:35:07.864] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.864] Resolved: TRUE
[13:35:07.864] Value: <not collected>
[13:35:07.864] Conditions captured: <none>
[13:35:07.864] Early signaling: FALSE
[13:35:07.864] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.864] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.874] Chunk #2 of 2 ... DONE
[13:35:07.874] Launching 2 futures (chunks) ... DONE
[13:35:07.874] Resolving 2 futures (chunks) ...
[13:35:07.874] resolve() on list ...
[13:35:07.875]  recursive: 0
[13:35:07.875]  length: 2
[13:35:07.875] 
[13:35:07.875] Future #1
[13:35:07.875] result() for MulticoreFuture ...
[13:35:07.876] result() for MulticoreFuture ...
[13:35:07.876] result() for MulticoreFuture ... done
[13:35:07.876] result() for MulticoreFuture ... done
[13:35:07.877] result() for MulticoreFuture ...
[13:35:07.877] result() for MulticoreFuture ... done
[13:35:07.877] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:07.877] - nx: 2
[13:35:07.877] - relay: TRUE
[13:35:07.877] - stdout: TRUE
[13:35:07.878] - signal: TRUE
[13:35:07.878] - resignal: FALSE
[13:35:07.878] - force: TRUE
[13:35:07.878] - relayed: [n=2] FALSE, FALSE
[13:35:07.878] - queued futures: [n=2] FALSE, FALSE
[13:35:07.878]  - until=1
[13:35:07.878]  - relaying element #1
[13:35:07.879] result() for MulticoreFuture ...
[13:35:07.879] result() for MulticoreFuture ... done
[13:35:07.879] result() for MulticoreFuture ...
[13:35:07.879] result() for MulticoreFuture ... done
[13:35:07.879] result() for MulticoreFuture ...
[13:35:07.879] result() for MulticoreFuture ... done
[13:35:07.880] result() for MulticoreFuture ...
[13:35:07.880] result() for MulticoreFuture ... done
[13:35:07.880] - relayed: [n=2] TRUE, FALSE
[13:35:07.880] - queued futures: [n=2] TRUE, FALSE
[13:35:07.880] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:07.880]  length: 1 (resolved future 1)
[13:35:07.881] Future #2
[13:35:07.881] result() for MulticoreFuture ...
[13:35:07.881] result() for MulticoreFuture ...
[13:35:07.882] result() for MulticoreFuture ... done
[13:35:07.882] result() for MulticoreFuture ... done
[13:35:07.882] result() for MulticoreFuture ...
[13:35:07.882] result() for MulticoreFuture ... done
[13:35:07.882] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:07.882] - nx: 2
[13:35:07.883] - relay: TRUE
[13:35:07.883] - stdout: TRUE
[13:35:07.883] - signal: TRUE
[13:35:07.883] - resignal: FALSE
[13:35:07.883] - force: TRUE
[13:35:07.883] - relayed: [n=2] TRUE, FALSE
[13:35:07.883] - queued futures: [n=2] TRUE, FALSE
[13:35:07.883]  - until=2
[13:35:07.884]  - relaying element #2
[13:35:07.884] result() for MulticoreFuture ...
[13:35:07.884] result() for MulticoreFuture ... done
[13:35:07.884] result() for MulticoreFuture ...
[13:35:07.887] result() for MulticoreFuture ... done
[13:35:07.887] result() for MulticoreFuture ...
[13:35:07.887] result() for MulticoreFuture ... done
[13:35:07.888] result() for MulticoreFuture ...
[13:35:07.888] result() for MulticoreFuture ... done
[13:35:07.888] - relayed: [n=2] TRUE, TRUE
[13:35:07.888] - queued futures: [n=2] TRUE, TRUE
[13:35:07.888] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:07.889]  length: 0 (resolved future 2)
[13:35:07.889] Relaying remaining futures
[13:35:07.889] signalConditionsASAP(NULL, pos=0) ...
[13:35:07.889] - nx: 2
[13:35:07.889] - relay: TRUE
[13:35:07.889] - stdout: TRUE
[13:35:07.889] - signal: TRUE
[13:35:07.890] - resignal: FALSE
[13:35:07.890] - force: TRUE
[13:35:07.890] - relayed: [n=2] TRUE, TRUE
[13:35:07.890] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:07.890] - relayed: [n=2] TRUE, TRUE
[13:35:07.890] - queued futures: [n=2] TRUE, TRUE
[13:35:07.891] signalConditionsASAP(NULL, pos=0) ... done
[13:35:07.891] resolve() on list ... DONE
[13:35:07.891] result() for MulticoreFuture ...
[13:35:07.891] result() for MulticoreFuture ... done
[13:35:07.891] result() for MulticoreFuture ...
[13:35:07.891] result() for MulticoreFuture ... done
[13:35:07.892] result() for MulticoreFuture ...
[13:35:07.892] result() for MulticoreFuture ... done
[13:35:07.892] result() for MulticoreFuture ...
[13:35:07.892] result() for MulticoreFuture ... done
[13:35:07.892]  - Number of value chunks collected: 2
[13:35:07.892] Resolving 2 futures (chunks) ... DONE
[13:35:07.892] Reducing values from 2 chunks ...
[13:35:07.893]  - Number of values collected after concatenation: 7
[13:35:07.893]  - Number of values expected: 7
[13:35:07.893] Reducing values from 2 chunks ... DONE
[13:35:07.893] future_lapply() ... DONE
[13:35:07.894] future_lapply() ...
[13:35:07.900] Number of chunks: 2
[13:35:07.900] getGlobalsAndPackagesXApply() ...
[13:35:07.901]  - future.globals: TRUE
[13:35:07.901] getGlobalsAndPackages() ...
[13:35:07.901] Searching for globals...
[13:35:07.908] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:35:07.908] Searching for globals ... DONE
[13:35:07.908] Resolving globals: FALSE
[13:35:07.912] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[13:35:07.912] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[13:35:07.913] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:07.913] - packages: [2] ‘stats’, ‘future.apply’
[13:35:07.913] getGlobalsAndPackages() ... DONE
[13:35:07.913]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:07.913]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:35:07.913] Finding globals ... DONE
[13:35:07.913]  - use_args: TRUE
[13:35:07.913]  - Getting '...' globals ...
[13:35:07.914] resolve() on list ...
[13:35:07.914]  recursive: 0
[13:35:07.914]  length: 1
[13:35:07.914]  elements: ‘...’
[13:35:07.914]  length: 0 (resolved future 1)
[13:35:07.914] resolve() on list ... DONE
[13:35:07.914]    - '...' content: [n=0] 
[13:35:07.915] List of 1
[13:35:07.915]  $ ...: list()
[13:35:07.915]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.915]  - attr(*, "where")=List of 1
[13:35:07.915]   ..$ ...:<environment: 0x5574cef5b468> 
[13:35:07.915]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.915]  - attr(*, "resolved")= logi TRUE
[13:35:07.915]  - attr(*, "total_size")= num NA
[13:35:07.917]  - Getting '...' globals ... DONE
[13:35:07.918] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:07.918] List of 8
[13:35:07.918]  $ ...future.FUN:function (x, ...)  
[13:35:07.918]  $ x_FUN        :function (x, na.rm = TRUE)  
[13:35:07.918]  $ times        : int 5
[13:35:07.918]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.918]  $ stop_if_not  :function (...)  
[13:35:07.918]  $ dim          : NULL
[13:35:07.918]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:07.918]  $ ...          : list()
[13:35:07.918]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.918]  - attr(*, "where")=List of 8
[13:35:07.918]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:07.918]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:07.918]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:07.918]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:07.918]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:07.918]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:07.918]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:07.918]   ..$ ...          :<environment: 0x5574cef5b468> 
[13:35:07.918]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.918]  - attr(*, "resolved")= logi FALSE
[13:35:07.918]  - attr(*, "total_size")= num 141240
[13:35:07.923] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:35:07.923] getGlobalsAndPackagesXApply() ... DONE
[13:35:07.923] Number of futures (= number of chunks): 2
[13:35:07.924] Launching 2 futures (chunks) ...
[13:35:07.924] Chunk #1 of 2 ...
[13:35:07.924]  - Finding globals in 'X' for chunk #1 ...
[13:35:07.924] getGlobalsAndPackages() ...
[13:35:07.924] Searching for globals...
[13:35:07.924] 
[13:35:07.924] Searching for globals ... DONE
[13:35:07.924] - globals: [0] <none>
[13:35:07.925] getGlobalsAndPackages() ... DONE
[13:35:07.925]    + additional globals found: [n=0] 
[13:35:07.925]    + additional namespaces needed: [n=0] 
[13:35:07.925]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:07.925]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.925]  - seeds: <none>
[13:35:07.925]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.925] getGlobalsAndPackages() ...
[13:35:07.925] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.925] Resolving globals: FALSE
[13:35:07.925] Tweak future expression to call with '...' arguments ...
[13:35:07.926] {
[13:35:07.926]     do.call(function(...) {
[13:35:07.926]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.926]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.926]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.926]             on.exit(options(oopts), add = TRUE)
[13:35:07.926]         }
[13:35:07.926]         {
[13:35:07.926]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.926]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.926]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.926]             })
[13:35:07.926]         }
[13:35:07.926]     }, args = future.call.arguments)
[13:35:07.926] }
[13:35:07.926] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.926] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.927] - packages: [2] ‘stats’, ‘future.apply’
[13:35:07.927] getGlobalsAndPackages() ... DONE
[13:35:07.927] run() for ‘Future’ ...
[13:35:07.927] - state: ‘created’
[13:35:07.927] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.931] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.931] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.931]   - Field: ‘label’
[13:35:07.931]   - Field: ‘local’
[13:35:07.932]   - Field: ‘owner’
[13:35:07.932]   - Field: ‘envir’
[13:35:07.932]   - Field: ‘workers’
[13:35:07.934]   - Field: ‘packages’
[13:35:07.934]   - Field: ‘gc’
[13:35:07.934]   - Field: ‘job’
[13:35:07.934]   - Field: ‘conditions’
[13:35:07.935]   - Field: ‘expr’
[13:35:07.935]   - Field: ‘uuid’
[13:35:07.935]   - Field: ‘seed’
[13:35:07.935]   - Field: ‘version’
[13:35:07.935]   - Field: ‘result’
[13:35:07.935]   - Field: ‘asynchronous’
[13:35:07.935]   - Field: ‘calls’
[13:35:07.935]   - Field: ‘globals’
[13:35:07.935]   - Field: ‘stdout’
[13:35:07.935]   - Field: ‘earlySignal’
[13:35:07.935]   - Field: ‘lazy’
[13:35:07.936]   - Field: ‘state’
[13:35:07.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.936] - Launch lazy future ...
[13:35:07.936] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:35:07.936] Packages needed by future strategies (n = 0): <none>
[13:35:07.937] {
[13:35:07.937]     {
[13:35:07.937]         {
[13:35:07.937]             ...future.startTime <- base::Sys.time()
[13:35:07.937]             {
[13:35:07.937]                 {
[13:35:07.937]                   {
[13:35:07.937]                     {
[13:35:07.937]                       {
[13:35:07.937]                         base::local({
[13:35:07.937]                           has_future <- base::requireNamespace("future", 
[13:35:07.937]                             quietly = TRUE)
[13:35:07.937]                           if (has_future) {
[13:35:07.937]                             ns <- base::getNamespace("future")
[13:35:07.937]                             version <- ns[[".package"]][["version"]]
[13:35:07.937]                             if (is.null(version)) 
[13:35:07.937]                               version <- utils::packageVersion("future")
[13:35:07.937]                           }
[13:35:07.937]                           else {
[13:35:07.937]                             version <- NULL
[13:35:07.937]                           }
[13:35:07.937]                           if (!has_future || version < "1.8.0") {
[13:35:07.937]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.937]                               "", base::R.version$version.string), 
[13:35:07.937]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.937]                                 base::R.version$platform, 8 * 
[13:35:07.937]                                   base::.Machine$sizeof.pointer), 
[13:35:07.937]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.937]                                 "release", "version")], collapse = " "), 
[13:35:07.937]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.937]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.937]                               info)
[13:35:07.937]                             info <- base::paste(info, collapse = "; ")
[13:35:07.937]                             if (!has_future) {
[13:35:07.937]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.937]                                 info)
[13:35:07.937]                             }
[13:35:07.937]                             else {
[13:35:07.937]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.937]                                 info, version)
[13:35:07.937]                             }
[13:35:07.937]                             base::stop(msg)
[13:35:07.937]                           }
[13:35:07.937]                         })
[13:35:07.937]                       }
[13:35:07.937]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.937]                       base::options(mc.cores = 1L)
[13:35:07.937]                     }
[13:35:07.937]                     base::local({
[13:35:07.937]                       for (pkg in c("stats", "future.apply")) {
[13:35:07.937]                         base::loadNamespace(pkg)
[13:35:07.937]                         base::library(pkg, character.only = TRUE)
[13:35:07.937]                       }
[13:35:07.937]                     })
[13:35:07.937]                   }
[13:35:07.937]                   ...future.strategy.old <- future::plan("list")
[13:35:07.937]                   options(future.plan = NULL)
[13:35:07.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.937]                 }
[13:35:07.937]                 ...future.workdir <- getwd()
[13:35:07.937]             }
[13:35:07.937]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.937]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.937]         }
[13:35:07.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.937]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.937]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.937]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.937]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.937]             base::names(...future.oldOptions))
[13:35:07.937]     }
[13:35:07.937]     if (FALSE) {
[13:35:07.937]     }
[13:35:07.937]     else {
[13:35:07.937]         if (TRUE) {
[13:35:07.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.937]                 open = "w")
[13:35:07.937]         }
[13:35:07.937]         else {
[13:35:07.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.937]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.937]         }
[13:35:07.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.937]             base::sink(type = "output", split = FALSE)
[13:35:07.937]             base::close(...future.stdout)
[13:35:07.937]         }, add = TRUE)
[13:35:07.937]     }
[13:35:07.937]     ...future.frame <- base::sys.nframe()
[13:35:07.937]     ...future.conditions <- base::list()
[13:35:07.937]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.937]     if (FALSE) {
[13:35:07.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.937]     }
[13:35:07.937]     ...future.result <- base::tryCatch({
[13:35:07.937]         base::withCallingHandlers({
[13:35:07.937]             ...future.value <- base::withVisible(base::local({
[13:35:07.937]                 withCallingHandlers({
[13:35:07.937]                   {
[13:35:07.937]                     do.call(function(...) {
[13:35:07.937]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.937]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.937]                         ...future.globals.maxSize)) {
[13:35:07.937]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.937]                         on.exit(options(oopts), add = TRUE)
[13:35:07.937]                       }
[13:35:07.937]                       {
[13:35:07.937]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.937]                           FUN = function(jj) {
[13:35:07.937]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.937]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.937]                           })
[13:35:07.937]                       }
[13:35:07.937]                     }, args = future.call.arguments)
[13:35:07.937]                   }
[13:35:07.937]                 }, immediateCondition = function(cond) {
[13:35:07.937]                   save_rds <- function (object, pathname, ...) 
[13:35:07.937]                   {
[13:35:07.937]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.937]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.937]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.937]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.937]                         fi_tmp[["mtime"]])
[13:35:07.937]                     }
[13:35:07.937]                     tryCatch({
[13:35:07.937]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.937]                     }, error = function(ex) {
[13:35:07.937]                       msg <- conditionMessage(ex)
[13:35:07.937]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.937]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.937]                         fi_tmp[["mtime"]], msg)
[13:35:07.937]                       ex$message <- msg
[13:35:07.937]                       stop(ex)
[13:35:07.937]                     })
[13:35:07.937]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.937]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.937]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.937]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.937]                       fi <- file.info(pathname)
[13:35:07.937]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.937]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.937]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.937]                         fi[["size"]], fi[["mtime"]])
[13:35:07.937]                       stop(msg)
[13:35:07.937]                     }
[13:35:07.937]                     invisible(pathname)
[13:35:07.937]                   }
[13:35:07.937]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.937]                     rootPath = tempdir()) 
[13:35:07.937]                   {
[13:35:07.937]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.937]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.937]                       tmpdir = path, fileext = ".rds")
[13:35:07.937]                     save_rds(obj, file)
[13:35:07.937]                   }
[13:35:07.937]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.937]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.937]                   {
[13:35:07.937]                     inherits <- base::inherits
[13:35:07.937]                     invokeRestart <- base::invokeRestart
[13:35:07.937]                     is.null <- base::is.null
[13:35:07.937]                     muffled <- FALSE
[13:35:07.937]                     if (inherits(cond, "message")) {
[13:35:07.937]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.937]                       if (muffled) 
[13:35:07.937]                         invokeRestart("muffleMessage")
[13:35:07.937]                     }
[13:35:07.937]                     else if (inherits(cond, "warning")) {
[13:35:07.937]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.937]                       if (muffled) 
[13:35:07.937]                         invokeRestart("muffleWarning")
[13:35:07.937]                     }
[13:35:07.937]                     else if (inherits(cond, "condition")) {
[13:35:07.937]                       if (!is.null(pattern)) {
[13:35:07.937]                         computeRestarts <- base::computeRestarts
[13:35:07.937]                         grepl <- base::grepl
[13:35:07.937]                         restarts <- computeRestarts(cond)
[13:35:07.937]                         for (restart in restarts) {
[13:35:07.937]                           name <- restart$name
[13:35:07.937]                           if (is.null(name)) 
[13:35:07.937]                             next
[13:35:07.937]                           if (!grepl(pattern, name)) 
[13:35:07.937]                             next
[13:35:07.937]                           invokeRestart(restart)
[13:35:07.937]                           muffled <- TRUE
[13:35:07.937]                           break
[13:35:07.937]                         }
[13:35:07.937]                       }
[13:35:07.937]                     }
[13:35:07.937]                     invisible(muffled)
[13:35:07.937]                   }
[13:35:07.937]                   muffleCondition(cond)
[13:35:07.937]                 })
[13:35:07.937]             }))
[13:35:07.937]             future::FutureResult(value = ...future.value$value, 
[13:35:07.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.937]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.937]                     ...future.globalenv.names))
[13:35:07.937]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.937]         }, condition = base::local({
[13:35:07.937]             c <- base::c
[13:35:07.937]             inherits <- base::inherits
[13:35:07.937]             invokeRestart <- base::invokeRestart
[13:35:07.937]             length <- base::length
[13:35:07.937]             list <- base::list
[13:35:07.937]             seq.int <- base::seq.int
[13:35:07.937]             signalCondition <- base::signalCondition
[13:35:07.937]             sys.calls <- base::sys.calls
[13:35:07.937]             `[[` <- base::`[[`
[13:35:07.937]             `+` <- base::`+`
[13:35:07.937]             `<<-` <- base::`<<-`
[13:35:07.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.937]                   3L)]
[13:35:07.937]             }
[13:35:07.937]             function(cond) {
[13:35:07.937]                 is_error <- inherits(cond, "error")
[13:35:07.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.937]                   NULL)
[13:35:07.937]                 if (is_error) {
[13:35:07.937]                   sessionInformation <- function() {
[13:35:07.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.937]                       search = base::search(), system = base::Sys.info())
[13:35:07.937]                   }
[13:35:07.937]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.937]                     cond$call), session = sessionInformation(), 
[13:35:07.937]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.937]                   signalCondition(cond)
[13:35:07.937]                 }
[13:35:07.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.937]                 "immediateCondition"))) {
[13:35:07.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.937]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.937]                   if (TRUE && !signal) {
[13:35:07.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.937]                     {
[13:35:07.937]                       inherits <- base::inherits
[13:35:07.937]                       invokeRestart <- base::invokeRestart
[13:35:07.937]                       is.null <- base::is.null
[13:35:07.937]                       muffled <- FALSE
[13:35:07.937]                       if (inherits(cond, "message")) {
[13:35:07.937]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.937]                         if (muffled) 
[13:35:07.937]                           invokeRestart("muffleMessage")
[13:35:07.937]                       }
[13:35:07.937]                       else if (inherits(cond, "warning")) {
[13:35:07.937]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.937]                         if (muffled) 
[13:35:07.937]                           invokeRestart("muffleWarning")
[13:35:07.937]                       }
[13:35:07.937]                       else if (inherits(cond, "condition")) {
[13:35:07.937]                         if (!is.null(pattern)) {
[13:35:07.937]                           computeRestarts <- base::computeRestarts
[13:35:07.937]                           grepl <- base::grepl
[13:35:07.937]                           restarts <- computeRestarts(cond)
[13:35:07.937]                           for (restart in restarts) {
[13:35:07.937]                             name <- restart$name
[13:35:07.937]                             if (is.null(name)) 
[13:35:07.937]                               next
[13:35:07.937]                             if (!grepl(pattern, name)) 
[13:35:07.937]                               next
[13:35:07.937]                             invokeRestart(restart)
[13:35:07.937]                             muffled <- TRUE
[13:35:07.937]                             break
[13:35:07.937]                           }
[13:35:07.937]                         }
[13:35:07.937]                       }
[13:35:07.937]                       invisible(muffled)
[13:35:07.937]                     }
[13:35:07.937]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.937]                   }
[13:35:07.937]                 }
[13:35:07.937]                 else {
[13:35:07.937]                   if (TRUE) {
[13:35:07.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.937]                     {
[13:35:07.937]                       inherits <- base::inherits
[13:35:07.937]                       invokeRestart <- base::invokeRestart
[13:35:07.937]                       is.null <- base::is.null
[13:35:07.937]                       muffled <- FALSE
[13:35:07.937]                       if (inherits(cond, "message")) {
[13:35:07.937]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.937]                         if (muffled) 
[13:35:07.937]                           invokeRestart("muffleMessage")
[13:35:07.937]                       }
[13:35:07.937]                       else if (inherits(cond, "warning")) {
[13:35:07.937]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.937]                         if (muffled) 
[13:35:07.937]                           invokeRestart("muffleWarning")
[13:35:07.937]                       }
[13:35:07.937]                       else if (inherits(cond, "condition")) {
[13:35:07.937]                         if (!is.null(pattern)) {
[13:35:07.937]                           computeRestarts <- base::computeRestarts
[13:35:07.937]                           grepl <- base::grepl
[13:35:07.937]                           restarts <- computeRestarts(cond)
[13:35:07.937]                           for (restart in restarts) {
[13:35:07.937]                             name <- restart$name
[13:35:07.937]                             if (is.null(name)) 
[13:35:07.937]                               next
[13:35:07.937]                             if (!grepl(pattern, name)) 
[13:35:07.937]                               next
[13:35:07.937]                             invokeRestart(restart)
[13:35:07.937]                             muffled <- TRUE
[13:35:07.937]                             break
[13:35:07.937]                           }
[13:35:07.937]                         }
[13:35:07.937]                       }
[13:35:07.937]                       invisible(muffled)
[13:35:07.937]                     }
[13:35:07.937]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.937]                   }
[13:35:07.937]                 }
[13:35:07.937]             }
[13:35:07.937]         }))
[13:35:07.937]     }, error = function(ex) {
[13:35:07.937]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.937]                 ...future.rng), started = ...future.startTime, 
[13:35:07.937]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.937]             version = "1.8"), class = "FutureResult")
[13:35:07.937]     }, finally = {
[13:35:07.937]         if (!identical(...future.workdir, getwd())) 
[13:35:07.937]             setwd(...future.workdir)
[13:35:07.937]         {
[13:35:07.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.937]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.937]             }
[13:35:07.937]             base::options(...future.oldOptions)
[13:35:07.937]             if (.Platform$OS.type == "windows") {
[13:35:07.937]                 old_names <- names(...future.oldEnvVars)
[13:35:07.937]                 envs <- base::Sys.getenv()
[13:35:07.937]                 names <- names(envs)
[13:35:07.937]                 common <- intersect(names, old_names)
[13:35:07.937]                 added <- setdiff(names, old_names)
[13:35:07.937]                 removed <- setdiff(old_names, names)
[13:35:07.937]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.937]                   envs[common]]
[13:35:07.937]                 NAMES <- toupper(changed)
[13:35:07.937]                 args <- list()
[13:35:07.937]                 for (kk in seq_along(NAMES)) {
[13:35:07.937]                   name <- changed[[kk]]
[13:35:07.937]                   NAME <- NAMES[[kk]]
[13:35:07.937]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.937]                     next
[13:35:07.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.937]                 }
[13:35:07.937]                 NAMES <- toupper(added)
[13:35:07.937]                 for (kk in seq_along(NAMES)) {
[13:35:07.937]                   name <- added[[kk]]
[13:35:07.937]                   NAME <- NAMES[[kk]]
[13:35:07.937]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.937]                     next
[13:35:07.937]                   args[[name]] <- ""
[13:35:07.937]                 }
[13:35:07.937]                 NAMES <- toupper(removed)
[13:35:07.937]                 for (kk in seq_along(NAMES)) {
[13:35:07.937]                   name <- removed[[kk]]
[13:35:07.937]                   NAME <- NAMES[[kk]]
[13:35:07.937]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.937]                     next
[13:35:07.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.937]                 }
[13:35:07.937]                 if (length(args) > 0) 
[13:35:07.937]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.937]             }
[13:35:07.937]             else {
[13:35:07.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.937]             }
[13:35:07.937]             {
[13:35:07.937]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.937]                   0L) {
[13:35:07.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.937]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.937]                   base::options(opts)
[13:35:07.937]                 }
[13:35:07.937]                 {
[13:35:07.937]                   {
[13:35:07.937]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.937]                     NULL
[13:35:07.937]                   }
[13:35:07.937]                   options(future.plan = NULL)
[13:35:07.937]                   if (is.na(NA_character_)) 
[13:35:07.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.937]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.937]                     .init = FALSE)
[13:35:07.937]                 }
[13:35:07.937]             }
[13:35:07.937]         }
[13:35:07.937]     })
[13:35:07.937]     if (TRUE) {
[13:35:07.937]         base::sink(type = "output", split = FALSE)
[13:35:07.937]         if (TRUE) {
[13:35:07.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.937]         }
[13:35:07.937]         else {
[13:35:07.937]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.937]         }
[13:35:07.937]         base::close(...future.stdout)
[13:35:07.937]         ...future.stdout <- NULL
[13:35:07.937]     }
[13:35:07.937]     ...future.result$conditions <- ...future.conditions
[13:35:07.937]     ...future.result$finished <- base::Sys.time()
[13:35:07.937]     ...future.result
[13:35:07.937] }
[13:35:07.939] assign_globals() ...
[13:35:07.939] List of 11
[13:35:07.939]  $ ...future.FUN            :function (x, ...)  
[13:35:07.939]  $ x_FUN                    :function (x, na.rm = TRUE)  
[13:35:07.939]  $ times                    : int 5
[13:35:07.939]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.939]  $ stop_if_not              :function (...)  
[13:35:07.939]  $ dim                      : NULL
[13:35:07.939]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:07.939]  $ future.call.arguments    : list()
[13:35:07.939]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.939]  $ ...future.elements_ii    :List of 4
[13:35:07.939]   ..$ : int [1:3] 1 2 3
[13:35:07.939]   ..$ : int [1:4] 1 2 3 4
[13:35:07.939]   ..$ : int [1:5] 1 2 3 4 5
[13:35:07.939]   ..$ : int [1:6] 1 2 3 4 5 6
[13:35:07.939]  $ ...future.seeds_ii       : NULL
[13:35:07.939]  $ ...future.globals.maxSize: NULL
[13:35:07.939]  - attr(*, "where")=List of 11
[13:35:07.939]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.939]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:07.939]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:07.939]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:07.939]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:07.939]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:07.939]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:07.939]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.939]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.939]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.939]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.939]  - attr(*, "resolved")= logi FALSE
[13:35:07.939]  - attr(*, "total_size")= num 141240
[13:35:07.939]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.939]  - attr(*, "already-done")= logi TRUE
[13:35:07.948] - copied ‘...future.FUN’ to environment
[13:35:07.948] - copied ‘x_FUN’ to environment
[13:35:07.948] - copied ‘times’ to environment
[13:35:07.948] - copied ‘stopf’ to environment
[13:35:07.948] - copied ‘stop_if_not’ to environment
[13:35:07.948] - copied ‘dim’ to environment
[13:35:07.948] - copied ‘valid_types’ to environment
[13:35:07.948] - copied ‘future.call.arguments’ to environment
[13:35:07.948] - copied ‘...future.elements_ii’ to environment
[13:35:07.948] - copied ‘...future.seeds_ii’ to environment
[13:35:07.949] - copied ‘...future.globals.maxSize’ to environment
[13:35:07.949] assign_globals() ... done
[13:35:07.949] requestCore(): workers = 2
[13:35:07.951] MulticoreFuture started
[13:35:07.951] - Launch lazy future ... done
[13:35:07.951] run() for ‘MulticoreFuture’ ... done
[13:35:07.952] Created future:
[13:35:07.953] plan(): Setting new future strategy stack:
[13:35:07.953] List of future strategies:
[13:35:07.953] 1. sequential:
[13:35:07.953]    - args: function (..., envir = parent.frame())
[13:35:07.953]    - tweaked: FALSE
[13:35:07.953]    - call: NULL
[13:35:07.954] plan(): nbrOfWorkers() = 1
[13:35:07.956] plan(): Setting new future strategy stack:
[13:35:07.956] List of future strategies:
[13:35:07.956] 1. multicore:
[13:35:07.956]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:07.956]    - tweaked: FALSE
[13:35:07.956]    - call: plan(strategy)
[13:35:07.961] plan(): nbrOfWorkers() = 2
[13:35:07.952] MulticoreFuture:
[13:35:07.952] Label: ‘future_vapply-1’
[13:35:07.952] Expression:
[13:35:07.952] {
[13:35:07.952]     do.call(function(...) {
[13:35:07.952]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.952]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.952]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.952]             on.exit(options(oopts), add = TRUE)
[13:35:07.952]         }
[13:35:07.952]         {
[13:35:07.952]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.952]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.952]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.952]             })
[13:35:07.952]         }
[13:35:07.952]     }, args = future.call.arguments)
[13:35:07.952] }
[13:35:07.952] Lazy evaluation: FALSE
[13:35:07.952] Asynchronous evaluation: TRUE
[13:35:07.952] Local evaluation: TRUE
[13:35:07.952] Environment: R_GlobalEnv
[13:35:07.952] Capture standard output: TRUE
[13:35:07.952] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:07.952] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:07.952] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:35:07.952] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:07.952] Resolved: TRUE
[13:35:07.952] Value: <not collected>
[13:35:07.952] Conditions captured: <none>
[13:35:07.952] Early signaling: FALSE
[13:35:07.952] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:07.952] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.962] Chunk #1 of 2 ... DONE
[13:35:07.962] Chunk #2 of 2 ...
[13:35:07.963]  - Finding globals in 'X' for chunk #2 ...
[13:35:07.963] getGlobalsAndPackages() ...
[13:35:07.963] Searching for globals...
[13:35:07.963] 
[13:35:07.963] Searching for globals ... DONE
[13:35:07.964] - globals: [0] <none>
[13:35:07.964] getGlobalsAndPackages() ... DONE
[13:35:07.964]    + additional globals found: [n=0] 
[13:35:07.964]    + additional namespaces needed: [n=0] 
[13:35:07.964]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:07.964]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:07.964]  - seeds: <none>
[13:35:07.964]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.965] getGlobalsAndPackages() ...
[13:35:07.965] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.965] Resolving globals: FALSE
[13:35:07.965] Tweak future expression to call with '...' arguments ...
[13:35:07.969] {
[13:35:07.969]     do.call(function(...) {
[13:35:07.969]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.969]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:07.969]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.969]             on.exit(options(oopts), add = TRUE)
[13:35:07.969]         }
[13:35:07.969]         {
[13:35:07.969]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:07.969]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.969]                 ...future.FUN(...future.X_jj, ...)
[13:35:07.969]             })
[13:35:07.969]         }
[13:35:07.969]     }, args = future.call.arguments)
[13:35:07.969] }
[13:35:07.969] Tweak future expression to call with '...' arguments ... DONE
[13:35:07.971] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:07.972] - packages: [2] ‘stats’, ‘future.apply’
[13:35:07.972] getGlobalsAndPackages() ... DONE
[13:35:07.973] run() for ‘Future’ ...
[13:35:07.973] - state: ‘created’
[13:35:07.974] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:07.979] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:07.980] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:07.980]   - Field: ‘label’
[13:35:07.980]   - Field: ‘local’
[13:35:07.980]   - Field: ‘owner’
[13:35:07.980]   - Field: ‘envir’
[13:35:07.981]   - Field: ‘workers’
[13:35:07.981]   - Field: ‘packages’
[13:35:07.981]   - Field: ‘gc’
[13:35:07.981]   - Field: ‘job’
[13:35:07.982]   - Field: ‘conditions’
[13:35:07.982]   - Field: ‘expr’
[13:35:07.982]   - Field: ‘uuid’
[13:35:07.982]   - Field: ‘seed’
[13:35:07.983]   - Field: ‘version’
[13:35:07.983]   - Field: ‘result’
[13:35:07.983]   - Field: ‘asynchronous’
[13:35:07.983]   - Field: ‘calls’
[13:35:07.983]   - Field: ‘globals’
[13:35:07.983]   - Field: ‘stdout’
[13:35:07.984]   - Field: ‘earlySignal’
[13:35:07.984]   - Field: ‘lazy’
[13:35:07.984]   - Field: ‘state’
[13:35:07.984] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:07.984] - Launch lazy future ...
[13:35:07.985] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:35:07.985] Packages needed by future strategies (n = 0): <none>
[13:35:07.986] {
[13:35:07.986]     {
[13:35:07.986]         {
[13:35:07.986]             ...future.startTime <- base::Sys.time()
[13:35:07.986]             {
[13:35:07.986]                 {
[13:35:07.986]                   {
[13:35:07.986]                     {
[13:35:07.986]                       {
[13:35:07.986]                         base::local({
[13:35:07.986]                           has_future <- base::requireNamespace("future", 
[13:35:07.986]                             quietly = TRUE)
[13:35:07.986]                           if (has_future) {
[13:35:07.986]                             ns <- base::getNamespace("future")
[13:35:07.986]                             version <- ns[[".package"]][["version"]]
[13:35:07.986]                             if (is.null(version)) 
[13:35:07.986]                               version <- utils::packageVersion("future")
[13:35:07.986]                           }
[13:35:07.986]                           else {
[13:35:07.986]                             version <- NULL
[13:35:07.986]                           }
[13:35:07.986]                           if (!has_future || version < "1.8.0") {
[13:35:07.986]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:07.986]                               "", base::R.version$version.string), 
[13:35:07.986]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:07.986]                                 base::R.version$platform, 8 * 
[13:35:07.986]                                   base::.Machine$sizeof.pointer), 
[13:35:07.986]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:07.986]                                 "release", "version")], collapse = " "), 
[13:35:07.986]                               hostname = base::Sys.info()[["nodename"]])
[13:35:07.986]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:07.986]                               info)
[13:35:07.986]                             info <- base::paste(info, collapse = "; ")
[13:35:07.986]                             if (!has_future) {
[13:35:07.986]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:07.986]                                 info)
[13:35:07.986]                             }
[13:35:07.986]                             else {
[13:35:07.986]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:07.986]                                 info, version)
[13:35:07.986]                             }
[13:35:07.986]                             base::stop(msg)
[13:35:07.986]                           }
[13:35:07.986]                         })
[13:35:07.986]                       }
[13:35:07.986]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:07.986]                       base::options(mc.cores = 1L)
[13:35:07.986]                     }
[13:35:07.986]                     base::local({
[13:35:07.986]                       for (pkg in c("stats", "future.apply")) {
[13:35:07.986]                         base::loadNamespace(pkg)
[13:35:07.986]                         base::library(pkg, character.only = TRUE)
[13:35:07.986]                       }
[13:35:07.986]                     })
[13:35:07.986]                   }
[13:35:07.986]                   ...future.strategy.old <- future::plan("list")
[13:35:07.986]                   options(future.plan = NULL)
[13:35:07.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:07.986]                 }
[13:35:07.986]                 ...future.workdir <- getwd()
[13:35:07.986]             }
[13:35:07.986]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:07.986]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:07.986]         }
[13:35:07.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:07.986]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:07.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:07.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:07.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:07.986]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:07.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:07.986]             base::names(...future.oldOptions))
[13:35:07.986]     }
[13:35:07.986]     if (FALSE) {
[13:35:07.986]     }
[13:35:07.986]     else {
[13:35:07.986]         if (TRUE) {
[13:35:07.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:07.986]                 open = "w")
[13:35:07.986]         }
[13:35:07.986]         else {
[13:35:07.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:07.986]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:07.986]         }
[13:35:07.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:07.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:07.986]             base::sink(type = "output", split = FALSE)
[13:35:07.986]             base::close(...future.stdout)
[13:35:07.986]         }, add = TRUE)
[13:35:07.986]     }
[13:35:07.986]     ...future.frame <- base::sys.nframe()
[13:35:07.986]     ...future.conditions <- base::list()
[13:35:07.986]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:07.986]     if (FALSE) {
[13:35:07.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:07.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:07.986]     }
[13:35:07.986]     ...future.result <- base::tryCatch({
[13:35:07.986]         base::withCallingHandlers({
[13:35:07.986]             ...future.value <- base::withVisible(base::local({
[13:35:07.986]                 withCallingHandlers({
[13:35:07.986]                   {
[13:35:07.986]                     do.call(function(...) {
[13:35:07.986]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:07.986]                       if (!identical(...future.globals.maxSize.org, 
[13:35:07.986]                         ...future.globals.maxSize)) {
[13:35:07.986]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:07.986]                         on.exit(options(oopts), add = TRUE)
[13:35:07.986]                       }
[13:35:07.986]                       {
[13:35:07.986]                         lapply(seq_along(...future.elements_ii), 
[13:35:07.986]                           FUN = function(jj) {
[13:35:07.986]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:07.986]                             ...future.FUN(...future.X_jj, ...)
[13:35:07.986]                           })
[13:35:07.986]                       }
[13:35:07.986]                     }, args = future.call.arguments)
[13:35:07.986]                   }
[13:35:07.986]                 }, immediateCondition = function(cond) {
[13:35:07.986]                   save_rds <- function (object, pathname, ...) 
[13:35:07.986]                   {
[13:35:07.986]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:07.986]                     if (file_test("-f", pathname_tmp)) {
[13:35:07.986]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.986]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:07.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.986]                         fi_tmp[["mtime"]])
[13:35:07.986]                     }
[13:35:07.986]                     tryCatch({
[13:35:07.986]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:07.986]                     }, error = function(ex) {
[13:35:07.986]                       msg <- conditionMessage(ex)
[13:35:07.986]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.986]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:07.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.986]                         fi_tmp[["mtime"]], msg)
[13:35:07.986]                       ex$message <- msg
[13:35:07.986]                       stop(ex)
[13:35:07.986]                     })
[13:35:07.986]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:07.986]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:07.986]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:07.986]                       fi_tmp <- file.info(pathname_tmp)
[13:35:07.986]                       fi <- file.info(pathname)
[13:35:07.986]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:07.986]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:07.986]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:07.986]                         fi[["size"]], fi[["mtime"]])
[13:35:07.986]                       stop(msg)
[13:35:07.986]                     }
[13:35:07.986]                     invisible(pathname)
[13:35:07.986]                   }
[13:35:07.986]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:07.986]                     rootPath = tempdir()) 
[13:35:07.986]                   {
[13:35:07.986]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:07.986]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:07.986]                       tmpdir = path, fileext = ".rds")
[13:35:07.986]                     save_rds(obj, file)
[13:35:07.986]                   }
[13:35:07.986]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:07.986]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.986]                   {
[13:35:07.986]                     inherits <- base::inherits
[13:35:07.986]                     invokeRestart <- base::invokeRestart
[13:35:07.986]                     is.null <- base::is.null
[13:35:07.986]                     muffled <- FALSE
[13:35:07.986]                     if (inherits(cond, "message")) {
[13:35:07.986]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:07.986]                       if (muffled) 
[13:35:07.986]                         invokeRestart("muffleMessage")
[13:35:07.986]                     }
[13:35:07.986]                     else if (inherits(cond, "warning")) {
[13:35:07.986]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:07.986]                       if (muffled) 
[13:35:07.986]                         invokeRestart("muffleWarning")
[13:35:07.986]                     }
[13:35:07.986]                     else if (inherits(cond, "condition")) {
[13:35:07.986]                       if (!is.null(pattern)) {
[13:35:07.986]                         computeRestarts <- base::computeRestarts
[13:35:07.986]                         grepl <- base::grepl
[13:35:07.986]                         restarts <- computeRestarts(cond)
[13:35:07.986]                         for (restart in restarts) {
[13:35:07.986]                           name <- restart$name
[13:35:07.986]                           if (is.null(name)) 
[13:35:07.986]                             next
[13:35:07.986]                           if (!grepl(pattern, name)) 
[13:35:07.986]                             next
[13:35:07.986]                           invokeRestart(restart)
[13:35:07.986]                           muffled <- TRUE
[13:35:07.986]                           break
[13:35:07.986]                         }
[13:35:07.986]                       }
[13:35:07.986]                     }
[13:35:07.986]                     invisible(muffled)
[13:35:07.986]                   }
[13:35:07.986]                   muffleCondition(cond)
[13:35:07.986]                 })
[13:35:07.986]             }))
[13:35:07.986]             future::FutureResult(value = ...future.value$value, 
[13:35:07.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.986]                   ...future.rng), globalenv = if (FALSE) 
[13:35:07.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:07.986]                     ...future.globalenv.names))
[13:35:07.986]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:07.986]         }, condition = base::local({
[13:35:07.986]             c <- base::c
[13:35:07.986]             inherits <- base::inherits
[13:35:07.986]             invokeRestart <- base::invokeRestart
[13:35:07.986]             length <- base::length
[13:35:07.986]             list <- base::list
[13:35:07.986]             seq.int <- base::seq.int
[13:35:07.986]             signalCondition <- base::signalCondition
[13:35:07.986]             sys.calls <- base::sys.calls
[13:35:07.986]             `[[` <- base::`[[`
[13:35:07.986]             `+` <- base::`+`
[13:35:07.986]             `<<-` <- base::`<<-`
[13:35:07.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:07.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:07.986]                   3L)]
[13:35:07.986]             }
[13:35:07.986]             function(cond) {
[13:35:07.986]                 is_error <- inherits(cond, "error")
[13:35:07.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:07.986]                   NULL)
[13:35:07.986]                 if (is_error) {
[13:35:07.986]                   sessionInformation <- function() {
[13:35:07.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:07.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:07.986]                       search = base::search(), system = base::Sys.info())
[13:35:07.986]                   }
[13:35:07.986]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:07.986]                     cond$call), session = sessionInformation(), 
[13:35:07.986]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:07.986]                   signalCondition(cond)
[13:35:07.986]                 }
[13:35:07.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:07.986]                 "immediateCondition"))) {
[13:35:07.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:07.986]                   ...future.conditions[[length(...future.conditions) + 
[13:35:07.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:07.986]                   if (TRUE && !signal) {
[13:35:07.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.986]                     {
[13:35:07.986]                       inherits <- base::inherits
[13:35:07.986]                       invokeRestart <- base::invokeRestart
[13:35:07.986]                       is.null <- base::is.null
[13:35:07.986]                       muffled <- FALSE
[13:35:07.986]                       if (inherits(cond, "message")) {
[13:35:07.986]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.986]                         if (muffled) 
[13:35:07.986]                           invokeRestart("muffleMessage")
[13:35:07.986]                       }
[13:35:07.986]                       else if (inherits(cond, "warning")) {
[13:35:07.986]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.986]                         if (muffled) 
[13:35:07.986]                           invokeRestart("muffleWarning")
[13:35:07.986]                       }
[13:35:07.986]                       else if (inherits(cond, "condition")) {
[13:35:07.986]                         if (!is.null(pattern)) {
[13:35:07.986]                           computeRestarts <- base::computeRestarts
[13:35:07.986]                           grepl <- base::grepl
[13:35:07.986]                           restarts <- computeRestarts(cond)
[13:35:07.986]                           for (restart in restarts) {
[13:35:07.986]                             name <- restart$name
[13:35:07.986]                             if (is.null(name)) 
[13:35:07.986]                               next
[13:35:07.986]                             if (!grepl(pattern, name)) 
[13:35:07.986]                               next
[13:35:07.986]                             invokeRestart(restart)
[13:35:07.986]                             muffled <- TRUE
[13:35:07.986]                             break
[13:35:07.986]                           }
[13:35:07.986]                         }
[13:35:07.986]                       }
[13:35:07.986]                       invisible(muffled)
[13:35:07.986]                     }
[13:35:07.986]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.986]                   }
[13:35:07.986]                 }
[13:35:07.986]                 else {
[13:35:07.986]                   if (TRUE) {
[13:35:07.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:07.986]                     {
[13:35:07.986]                       inherits <- base::inherits
[13:35:07.986]                       invokeRestart <- base::invokeRestart
[13:35:07.986]                       is.null <- base::is.null
[13:35:07.986]                       muffled <- FALSE
[13:35:07.986]                       if (inherits(cond, "message")) {
[13:35:07.986]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:07.986]                         if (muffled) 
[13:35:07.986]                           invokeRestart("muffleMessage")
[13:35:07.986]                       }
[13:35:07.986]                       else if (inherits(cond, "warning")) {
[13:35:07.986]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:07.986]                         if (muffled) 
[13:35:07.986]                           invokeRestart("muffleWarning")
[13:35:07.986]                       }
[13:35:07.986]                       else if (inherits(cond, "condition")) {
[13:35:07.986]                         if (!is.null(pattern)) {
[13:35:07.986]                           computeRestarts <- base::computeRestarts
[13:35:07.986]                           grepl <- base::grepl
[13:35:07.986]                           restarts <- computeRestarts(cond)
[13:35:07.986]                           for (restart in restarts) {
[13:35:07.986]                             name <- restart$name
[13:35:07.986]                             if (is.null(name)) 
[13:35:07.986]                               next
[13:35:07.986]                             if (!grepl(pattern, name)) 
[13:35:07.986]                               next
[13:35:07.986]                             invokeRestart(restart)
[13:35:07.986]                             muffled <- TRUE
[13:35:07.986]                             break
[13:35:07.986]                           }
[13:35:07.986]                         }
[13:35:07.986]                       }
[13:35:07.986]                       invisible(muffled)
[13:35:07.986]                     }
[13:35:07.986]                     muffleCondition(cond, pattern = "^muffle")
[13:35:07.986]                   }
[13:35:07.986]                 }
[13:35:07.986]             }
[13:35:07.986]         }))
[13:35:07.986]     }, error = function(ex) {
[13:35:07.986]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:07.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:07.986]                 ...future.rng), started = ...future.startTime, 
[13:35:07.986]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:07.986]             version = "1.8"), class = "FutureResult")
[13:35:07.986]     }, finally = {
[13:35:07.986]         if (!identical(...future.workdir, getwd())) 
[13:35:07.986]             setwd(...future.workdir)
[13:35:07.986]         {
[13:35:07.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:07.986]                 ...future.oldOptions$nwarnings <- NULL
[13:35:07.986]             }
[13:35:07.986]             base::options(...future.oldOptions)
[13:35:07.986]             if (.Platform$OS.type == "windows") {
[13:35:07.986]                 old_names <- names(...future.oldEnvVars)
[13:35:07.986]                 envs <- base::Sys.getenv()
[13:35:07.986]                 names <- names(envs)
[13:35:07.986]                 common <- intersect(names, old_names)
[13:35:07.986]                 added <- setdiff(names, old_names)
[13:35:07.986]                 removed <- setdiff(old_names, names)
[13:35:07.986]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:07.986]                   envs[common]]
[13:35:07.986]                 NAMES <- toupper(changed)
[13:35:07.986]                 args <- list()
[13:35:07.986]                 for (kk in seq_along(NAMES)) {
[13:35:07.986]                   name <- changed[[kk]]
[13:35:07.986]                   NAME <- NAMES[[kk]]
[13:35:07.986]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.986]                     next
[13:35:07.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.986]                 }
[13:35:07.986]                 NAMES <- toupper(added)
[13:35:07.986]                 for (kk in seq_along(NAMES)) {
[13:35:07.986]                   name <- added[[kk]]
[13:35:07.986]                   NAME <- NAMES[[kk]]
[13:35:07.986]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.986]                     next
[13:35:07.986]                   args[[name]] <- ""
[13:35:07.986]                 }
[13:35:07.986]                 NAMES <- toupper(removed)
[13:35:07.986]                 for (kk in seq_along(NAMES)) {
[13:35:07.986]                   name <- removed[[kk]]
[13:35:07.986]                   NAME <- NAMES[[kk]]
[13:35:07.986]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:07.986]                     next
[13:35:07.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:07.986]                 }
[13:35:07.986]                 if (length(args) > 0) 
[13:35:07.986]                   base::do.call(base::Sys.setenv, args = args)
[13:35:07.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:07.986]             }
[13:35:07.986]             else {
[13:35:07.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:07.986]             }
[13:35:07.986]             {
[13:35:07.986]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:07.986]                   0L) {
[13:35:07.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:07.986]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:07.986]                   base::options(opts)
[13:35:07.986]                 }
[13:35:07.986]                 {
[13:35:07.986]                   {
[13:35:07.986]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:07.986]                     NULL
[13:35:07.986]                   }
[13:35:07.986]                   options(future.plan = NULL)
[13:35:07.986]                   if (is.na(NA_character_)) 
[13:35:07.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:07.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:07.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:07.986]                     .init = FALSE)
[13:35:07.986]                 }
[13:35:07.986]             }
[13:35:07.986]         }
[13:35:07.986]     })
[13:35:07.986]     if (TRUE) {
[13:35:07.986]         base::sink(type = "output", split = FALSE)
[13:35:07.986]         if (TRUE) {
[13:35:07.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:07.986]         }
[13:35:07.986]         else {
[13:35:07.986]             ...future.result["stdout"] <- base::list(NULL)
[13:35:07.986]         }
[13:35:07.986]         base::close(...future.stdout)
[13:35:07.986]         ...future.stdout <- NULL
[13:35:07.986]     }
[13:35:07.986]     ...future.result$conditions <- ...future.conditions
[13:35:07.986]     ...future.result$finished <- base::Sys.time()
[13:35:07.986]     ...future.result
[13:35:07.986] }
[13:35:07.989] assign_globals() ...
[13:35:07.989] List of 11
[13:35:07.989]  $ ...future.FUN            :function (x, ...)  
[13:35:07.989]  $ x_FUN                    :function (x, na.rm = TRUE)  
[13:35:07.989]  $ times                    : int 5
[13:35:07.989]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:07.989]  $ stop_if_not              :function (...)  
[13:35:07.989]  $ dim                      : NULL
[13:35:07.989]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:07.989]  $ future.call.arguments    : list()
[13:35:07.989]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:07.989]  $ ...future.elements_ii    :List of 3
[13:35:07.989]   ..$ : int [1:7] 1 2 3 4 5 6 7
[13:35:07.989]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[13:35:07.989]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[13:35:07.989]  $ ...future.seeds_ii       : NULL
[13:35:07.989]  $ ...future.globals.maxSize: NULL
[13:35:07.989]  - attr(*, "where")=List of 11
[13:35:07.989]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:07.989]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:07.989]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:07.989]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:07.989]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:07.989]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:07.989]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:07.989]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:07.989]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:07.989]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:07.989]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:07.989]  - attr(*, "resolved")= logi FALSE
[13:35:07.989]  - attr(*, "total_size")= num 141240
[13:35:07.989]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:07.989]  - attr(*, "already-done")= logi TRUE
[13:35:07.999] - copied ‘...future.FUN’ to environment
[13:35:07.999] - copied ‘x_FUN’ to environment
[13:35:07.999] - copied ‘times’ to environment
[13:35:07.999] - copied ‘stopf’ to environment
[13:35:08.000] - copied ‘stop_if_not’ to environment
[13:35:08.000] - copied ‘dim’ to environment
[13:35:08.000] - copied ‘valid_types’ to environment
[13:35:08.000] - copied ‘future.call.arguments’ to environment
[13:35:08.000] - copied ‘...future.elements_ii’ to environment
[13:35:08.000] - copied ‘...future.seeds_ii’ to environment
[13:35:08.000] - copied ‘...future.globals.maxSize’ to environment
[13:35:08.000] assign_globals() ... done
[13:35:08.000] requestCore(): workers = 2
[13:35:08.003] MulticoreFuture started
[13:35:08.003] - Launch lazy future ... done
[13:35:08.003] run() for ‘MulticoreFuture’ ... done
[13:35:08.004] Created future:
[13:35:08.014] plan(): Setting new future strategy stack:
[13:35:08.014] List of future strategies:
[13:35:08.014] 1. sequential:
[13:35:08.014]    - args: function (..., envir = parent.frame())
[13:35:08.014]    - tweaked: FALSE
[13:35:08.014]    - call: NULL
[13:35:08.015] plan(): nbrOfWorkers() = 1
[13:35:08.017] plan(): Setting new future strategy stack:
[13:35:08.017] List of future strategies:
[13:35:08.017] 1. multicore:
[13:35:08.017]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:08.017]    - tweaked: FALSE
[13:35:08.017]    - call: plan(strategy)
[13:35:08.023] plan(): nbrOfWorkers() = 2
[13:35:08.004] MulticoreFuture:
[13:35:08.004] Label: ‘future_vapply-2’
[13:35:08.004] Expression:
[13:35:08.004] {
[13:35:08.004]     do.call(function(...) {
[13:35:08.004]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.004]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.004]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.004]             on.exit(options(oopts), add = TRUE)
[13:35:08.004]         }
[13:35:08.004]         {
[13:35:08.004]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.004]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.004]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.004]             })
[13:35:08.004]         }
[13:35:08.004]     }, args = future.call.arguments)
[13:35:08.004] }
[13:35:08.004] Lazy evaluation: FALSE
[13:35:08.004] Asynchronous evaluation: TRUE
[13:35:08.004] Local evaluation: TRUE
[13:35:08.004] Environment: R_GlobalEnv
[13:35:08.004] Capture standard output: TRUE
[13:35:08.004] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:08.004] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:08.004] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:35:08.004] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:08.004] Resolved: TRUE
[13:35:08.004] Value: <not collected>
[13:35:08.004] Conditions captured: <none>
[13:35:08.004] Early signaling: FALSE
[13:35:08.004] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:08.004] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.024] Chunk #2 of 2 ... DONE
[13:35:08.024] Launching 2 futures (chunks) ... DONE
[13:35:08.025] Resolving 2 futures (chunks) ...
[13:35:08.025] resolve() on list ...
[13:35:08.025]  recursive: 0
[13:35:08.025]  length: 2
[13:35:08.025] 
[13:35:08.026] Future #1
[13:35:08.026] result() for MulticoreFuture ...
[13:35:08.027] result() for MulticoreFuture ...
[13:35:08.027] result() for MulticoreFuture ... done
[13:35:08.027] result() for MulticoreFuture ... done
[13:35:08.027] result() for MulticoreFuture ...
[13:35:08.028] result() for MulticoreFuture ... done
[13:35:08.028] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:08.028] - nx: 2
[13:35:08.028] - relay: TRUE
[13:35:08.028] - stdout: TRUE
[13:35:08.029] - signal: TRUE
[13:35:08.029] - resignal: FALSE
[13:35:08.029] - force: TRUE
[13:35:08.029] - relayed: [n=2] FALSE, FALSE
[13:35:08.029] - queued futures: [n=2] FALSE, FALSE
[13:35:08.030]  - until=1
[13:35:08.030]  - relaying element #1
[13:35:08.030] result() for MulticoreFuture ...
[13:35:08.030] result() for MulticoreFuture ... done
[13:35:08.031] result() for MulticoreFuture ...
[13:35:08.031] result() for MulticoreFuture ... done
[13:35:08.031] result() for MulticoreFuture ...
[13:35:08.031] result() for MulticoreFuture ... done
[13:35:08.031] result() for MulticoreFuture ...
[13:35:08.032] result() for MulticoreFuture ... done
[13:35:08.032] - relayed: [n=2] TRUE, FALSE
[13:35:08.032] - queued futures: [n=2] TRUE, FALSE
[13:35:08.032] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:08.033]  length: 1 (resolved future 1)
[13:35:08.033] Future #2
[13:35:08.033] result() for MulticoreFuture ...
[13:35:08.034] result() for MulticoreFuture ...
[13:35:08.034] result() for MulticoreFuture ... done
[13:35:08.034] result() for MulticoreFuture ... done
[13:35:08.034] result() for MulticoreFuture ...
[13:35:08.035] result() for MulticoreFuture ... done
[13:35:08.035] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:08.035] - nx: 2
[13:35:08.035] - relay: TRUE
[13:35:08.035] - stdout: TRUE
[13:35:08.035] - signal: TRUE
[13:35:08.035] - resignal: FALSE
[13:35:08.035] - force: TRUE
[13:35:08.036] - relayed: [n=2] TRUE, FALSE
[13:35:08.036] - queued futures: [n=2] TRUE, FALSE
[13:35:08.036]  - until=2
[13:35:08.036]  - relaying element #2
[13:35:08.036] result() for MulticoreFuture ...
[13:35:08.036] result() for MulticoreFuture ... done
[13:35:08.036] result() for MulticoreFuture ...
[13:35:08.037] result() for MulticoreFuture ... done
[13:35:08.037] result() for MulticoreFuture ...
[13:35:08.037] result() for MulticoreFuture ... done
[13:35:08.037] result() for MulticoreFuture ...
[13:35:08.037] result() for MulticoreFuture ... done
[13:35:08.037] - relayed: [n=2] TRUE, TRUE
[13:35:08.037] - queued futures: [n=2] TRUE, TRUE
[13:35:08.037] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:08.038]  length: 0 (resolved future 2)
[13:35:08.038] Relaying remaining futures
[13:35:08.038] signalConditionsASAP(NULL, pos=0) ...
[13:35:08.038] - nx: 2
[13:35:08.038] - relay: TRUE
[13:35:08.038] - stdout: TRUE
[13:35:08.038] - signal: TRUE
[13:35:08.038] - resignal: FALSE
[13:35:08.038] - force: TRUE
[13:35:08.038] - relayed: [n=2] TRUE, TRUE
[13:35:08.039] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:08.039] - relayed: [n=2] TRUE, TRUE
[13:35:08.039] - queued futures: [n=2] TRUE, TRUE
[13:35:08.039] signalConditionsASAP(NULL, pos=0) ... done
[13:35:08.039] resolve() on list ... DONE
[13:35:08.039] result() for MulticoreFuture ...
[13:35:08.039] result() for MulticoreFuture ... done
[13:35:08.039] result() for MulticoreFuture ...
[13:35:08.039] result() for MulticoreFuture ... done
[13:35:08.040] result() for MulticoreFuture ...
[13:35:08.040] result() for MulticoreFuture ... done
[13:35:08.040] result() for MulticoreFuture ...
[13:35:08.040] result() for MulticoreFuture ... done
[13:35:08.040]  - Number of value chunks collected: 2
[13:35:08.040] Resolving 2 futures (chunks) ... DONE
[13:35:08.040] Reducing values from 2 chunks ...
[13:35:08.040]  - Number of values collected after concatenation: 7
[13:35:08.040]  - Number of values expected: 7
[13:35:08.040] Reducing values from 2 chunks ... DONE
[13:35:08.041] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[13:35:08.043] future_lapply() ...
[13:35:08.047] Number of chunks: 2
[13:35:08.048] getGlobalsAndPackagesXApply() ...
[13:35:08.048]  - future.globals: TRUE
[13:35:08.048] getGlobalsAndPackages() ...
[13:35:08.048] Searching for globals...
[13:35:08.050] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[13:35:08.050] Searching for globals ... DONE
[13:35:08.050] Resolving globals: FALSE
[13:35:08.050] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[13:35:08.051] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[13:35:08.051] - globals: [1] ‘FUN’
[13:35:08.051] 
[13:35:08.051] getGlobalsAndPackages() ... DONE
[13:35:08.051]  - globals found/used: [n=1] ‘FUN’
[13:35:08.051]  - needed namespaces: [n=0] 
[13:35:08.051] Finding globals ... DONE
[13:35:08.051]  - use_args: TRUE
[13:35:08.051]  - Getting '...' globals ...
[13:35:08.052] resolve() on list ...
[13:35:08.052]  recursive: 0
[13:35:08.052]  length: 1
[13:35:08.052]  elements: ‘...’
[13:35:08.052]  length: 0 (resolved future 1)
[13:35:08.052] resolve() on list ... DONE
[13:35:08.052]    - '...' content: [n=1] ‘y’
[13:35:08.053] List of 1
[13:35:08.053]  $ ...:List of 1
[13:35:08.053]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:08.053]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.053]  - attr(*, "where")=List of 1
[13:35:08.053]   ..$ ...:<environment: 0x5574d003ac88> 
[13:35:08.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.053]  - attr(*, "resolved")= logi TRUE
[13:35:08.053]  - attr(*, "total_size")= num NA
[13:35:08.059]  - Getting '...' globals ... DONE
[13:35:08.059] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:08.059] List of 2
[13:35:08.059]  $ ...future.FUN:function (x, y)  
[13:35:08.059]  $ ...          :List of 1
[13:35:08.059]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:08.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.059]  - attr(*, "where")=List of 2
[13:35:08.059]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:08.059]   ..$ ...          :<environment: 0x5574d003ac88> 
[13:35:08.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.059]  - attr(*, "resolved")= logi FALSE
[13:35:08.059]  - attr(*, "total_size")= num 4264
[13:35:08.062] Packages to be attached in all futures: [n=0] 
[13:35:08.063] getGlobalsAndPackagesXApply() ... DONE
[13:35:08.063] Number of futures (= number of chunks): 2
[13:35:08.063] Launching 2 futures (chunks) ...
[13:35:08.063] Chunk #1 of 2 ...
[13:35:08.063]  - Finding globals in 'X' for chunk #1 ...
[13:35:08.063] getGlobalsAndPackages() ...
[13:35:08.063] Searching for globals...
[13:35:08.064] 
[13:35:08.064] Searching for globals ... DONE
[13:35:08.064] - globals: [0] <none>
[13:35:08.064] getGlobalsAndPackages() ... DONE
[13:35:08.064]    + additional globals found: [n=0] 
[13:35:08.064]    + additional namespaces needed: [n=0] 
[13:35:08.064]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:08.064]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:08.064]  - seeds: <none>
[13:35:08.064]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.065] getGlobalsAndPackages() ...
[13:35:08.065] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.065] Resolving globals: FALSE
[13:35:08.065] Tweak future expression to call with '...' arguments ...
[13:35:08.065] {
[13:35:08.065]     do.call(function(...) {
[13:35:08.065]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.065]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.065]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.065]             on.exit(options(oopts), add = TRUE)
[13:35:08.065]         }
[13:35:08.065]         {
[13:35:08.065]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.065]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.065]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.065]             })
[13:35:08.065]         }
[13:35:08.065]     }, args = future.call.arguments)
[13:35:08.065] }
[13:35:08.065] Tweak future expression to call with '...' arguments ... DONE
[13:35:08.066] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.066] 
[13:35:08.066] getGlobalsAndPackages() ... DONE
[13:35:08.066] run() for ‘Future’ ...
[13:35:08.066] - state: ‘created’
[13:35:08.066] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:08.070] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.070] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:08.070]   - Field: ‘label’
[13:35:08.070]   - Field: ‘local’
[13:35:08.071]   - Field: ‘owner’
[13:35:08.071]   - Field: ‘envir’
[13:35:08.071]   - Field: ‘workers’
[13:35:08.071]   - Field: ‘packages’
[13:35:08.071]   - Field: ‘gc’
[13:35:08.071]   - Field: ‘job’
[13:35:08.071]   - Field: ‘conditions’
[13:35:08.071]   - Field: ‘expr’
[13:35:08.071]   - Field: ‘uuid’
[13:35:08.071]   - Field: ‘seed’
[13:35:08.071]   - Field: ‘version’
[13:35:08.072]   - Field: ‘result’
[13:35:08.072]   - Field: ‘asynchronous’
[13:35:08.072]   - Field: ‘calls’
[13:35:08.072]   - Field: ‘globals’
[13:35:08.072]   - Field: ‘stdout’
[13:35:08.072]   - Field: ‘earlySignal’
[13:35:08.072]   - Field: ‘lazy’
[13:35:08.072]   - Field: ‘state’
[13:35:08.072] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:08.072] - Launch lazy future ...
[13:35:08.073] Packages needed by the future expression (n = 0): <none>
[13:35:08.073] Packages needed by future strategies (n = 0): <none>
[13:35:08.073] {
[13:35:08.073]     {
[13:35:08.073]         {
[13:35:08.073]             ...future.startTime <- base::Sys.time()
[13:35:08.073]             {
[13:35:08.073]                 {
[13:35:08.073]                   {
[13:35:08.073]                     {
[13:35:08.073]                       base::local({
[13:35:08.073]                         has_future <- base::requireNamespace("future", 
[13:35:08.073]                           quietly = TRUE)
[13:35:08.073]                         if (has_future) {
[13:35:08.073]                           ns <- base::getNamespace("future")
[13:35:08.073]                           version <- ns[[".package"]][["version"]]
[13:35:08.073]                           if (is.null(version)) 
[13:35:08.073]                             version <- utils::packageVersion("future")
[13:35:08.073]                         }
[13:35:08.073]                         else {
[13:35:08.073]                           version <- NULL
[13:35:08.073]                         }
[13:35:08.073]                         if (!has_future || version < "1.8.0") {
[13:35:08.073]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:08.073]                             "", base::R.version$version.string), 
[13:35:08.073]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:08.073]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:08.073]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:08.073]                               "release", "version")], collapse = " "), 
[13:35:08.073]                             hostname = base::Sys.info()[["nodename"]])
[13:35:08.073]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:08.073]                             info)
[13:35:08.073]                           info <- base::paste(info, collapse = "; ")
[13:35:08.073]                           if (!has_future) {
[13:35:08.073]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:08.073]                               info)
[13:35:08.073]                           }
[13:35:08.073]                           else {
[13:35:08.073]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:08.073]                               info, version)
[13:35:08.073]                           }
[13:35:08.073]                           base::stop(msg)
[13:35:08.073]                         }
[13:35:08.073]                       })
[13:35:08.073]                     }
[13:35:08.073]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:08.073]                     base::options(mc.cores = 1L)
[13:35:08.073]                   }
[13:35:08.073]                   ...future.strategy.old <- future::plan("list")
[13:35:08.073]                   options(future.plan = NULL)
[13:35:08.073]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.073]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:08.073]                 }
[13:35:08.073]                 ...future.workdir <- getwd()
[13:35:08.073]             }
[13:35:08.073]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:08.073]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:08.073]         }
[13:35:08.073]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:08.073]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:08.073]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:08.073]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:08.073]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:08.073]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:08.073]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:08.073]             base::names(...future.oldOptions))
[13:35:08.073]     }
[13:35:08.073]     if (FALSE) {
[13:35:08.073]     }
[13:35:08.073]     else {
[13:35:08.073]         if (TRUE) {
[13:35:08.073]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:08.073]                 open = "w")
[13:35:08.073]         }
[13:35:08.073]         else {
[13:35:08.073]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:08.073]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:08.073]         }
[13:35:08.073]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:08.073]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:08.073]             base::sink(type = "output", split = FALSE)
[13:35:08.073]             base::close(...future.stdout)
[13:35:08.073]         }, add = TRUE)
[13:35:08.073]     }
[13:35:08.073]     ...future.frame <- base::sys.nframe()
[13:35:08.073]     ...future.conditions <- base::list()
[13:35:08.073]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:08.073]     if (FALSE) {
[13:35:08.073]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:08.073]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:08.073]     }
[13:35:08.073]     ...future.result <- base::tryCatch({
[13:35:08.073]         base::withCallingHandlers({
[13:35:08.073]             ...future.value <- base::withVisible(base::local({
[13:35:08.073]                 withCallingHandlers({
[13:35:08.073]                   {
[13:35:08.073]                     do.call(function(...) {
[13:35:08.073]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.073]                       if (!identical(...future.globals.maxSize.org, 
[13:35:08.073]                         ...future.globals.maxSize)) {
[13:35:08.073]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.073]                         on.exit(options(oopts), add = TRUE)
[13:35:08.073]                       }
[13:35:08.073]                       {
[13:35:08.073]                         lapply(seq_along(...future.elements_ii), 
[13:35:08.073]                           FUN = function(jj) {
[13:35:08.073]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.073]                             ...future.FUN(...future.X_jj, ...)
[13:35:08.073]                           })
[13:35:08.073]                       }
[13:35:08.073]                     }, args = future.call.arguments)
[13:35:08.073]                   }
[13:35:08.073]                 }, immediateCondition = function(cond) {
[13:35:08.073]                   save_rds <- function (object, pathname, ...) 
[13:35:08.073]                   {
[13:35:08.073]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:08.073]                     if (file_test("-f", pathname_tmp)) {
[13:35:08.073]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.073]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:08.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.073]                         fi_tmp[["mtime"]])
[13:35:08.073]                     }
[13:35:08.073]                     tryCatch({
[13:35:08.073]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:08.073]                     }, error = function(ex) {
[13:35:08.073]                       msg <- conditionMessage(ex)
[13:35:08.073]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.073]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:08.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.073]                         fi_tmp[["mtime"]], msg)
[13:35:08.073]                       ex$message <- msg
[13:35:08.073]                       stop(ex)
[13:35:08.073]                     })
[13:35:08.073]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:08.073]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:08.073]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:08.073]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.073]                       fi <- file.info(pathname)
[13:35:08.073]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:08.073]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.073]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:08.073]                         fi[["size"]], fi[["mtime"]])
[13:35:08.073]                       stop(msg)
[13:35:08.073]                     }
[13:35:08.073]                     invisible(pathname)
[13:35:08.073]                   }
[13:35:08.073]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:08.073]                     rootPath = tempdir()) 
[13:35:08.073]                   {
[13:35:08.073]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:08.073]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:08.073]                       tmpdir = path, fileext = ".rds")
[13:35:08.073]                     save_rds(obj, file)
[13:35:08.073]                   }
[13:35:08.073]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:08.073]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.073]                   {
[13:35:08.073]                     inherits <- base::inherits
[13:35:08.073]                     invokeRestart <- base::invokeRestart
[13:35:08.073]                     is.null <- base::is.null
[13:35:08.073]                     muffled <- FALSE
[13:35:08.073]                     if (inherits(cond, "message")) {
[13:35:08.073]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:08.073]                       if (muffled) 
[13:35:08.073]                         invokeRestart("muffleMessage")
[13:35:08.073]                     }
[13:35:08.073]                     else if (inherits(cond, "warning")) {
[13:35:08.073]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:08.073]                       if (muffled) 
[13:35:08.073]                         invokeRestart("muffleWarning")
[13:35:08.073]                     }
[13:35:08.073]                     else if (inherits(cond, "condition")) {
[13:35:08.073]                       if (!is.null(pattern)) {
[13:35:08.073]                         computeRestarts <- base::computeRestarts
[13:35:08.073]                         grepl <- base::grepl
[13:35:08.073]                         restarts <- computeRestarts(cond)
[13:35:08.073]                         for (restart in restarts) {
[13:35:08.073]                           name <- restart$name
[13:35:08.073]                           if (is.null(name)) 
[13:35:08.073]                             next
[13:35:08.073]                           if (!grepl(pattern, name)) 
[13:35:08.073]                             next
[13:35:08.073]                           invokeRestart(restart)
[13:35:08.073]                           muffled <- TRUE
[13:35:08.073]                           break
[13:35:08.073]                         }
[13:35:08.073]                       }
[13:35:08.073]                     }
[13:35:08.073]                     invisible(muffled)
[13:35:08.073]                   }
[13:35:08.073]                   muffleCondition(cond)
[13:35:08.073]                 })
[13:35:08.073]             }))
[13:35:08.073]             future::FutureResult(value = ...future.value$value, 
[13:35:08.073]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.073]                   ...future.rng), globalenv = if (FALSE) 
[13:35:08.073]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:08.073]                     ...future.globalenv.names))
[13:35:08.073]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:08.073]         }, condition = base::local({
[13:35:08.073]             c <- base::c
[13:35:08.073]             inherits <- base::inherits
[13:35:08.073]             invokeRestart <- base::invokeRestart
[13:35:08.073]             length <- base::length
[13:35:08.073]             list <- base::list
[13:35:08.073]             seq.int <- base::seq.int
[13:35:08.073]             signalCondition <- base::signalCondition
[13:35:08.073]             sys.calls <- base::sys.calls
[13:35:08.073]             `[[` <- base::`[[`
[13:35:08.073]             `+` <- base::`+`
[13:35:08.073]             `<<-` <- base::`<<-`
[13:35:08.073]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:08.073]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:08.073]                   3L)]
[13:35:08.073]             }
[13:35:08.073]             function(cond) {
[13:35:08.073]                 is_error <- inherits(cond, "error")
[13:35:08.073]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:08.073]                   NULL)
[13:35:08.073]                 if (is_error) {
[13:35:08.073]                   sessionInformation <- function() {
[13:35:08.073]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:08.073]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:08.073]                       search = base::search(), system = base::Sys.info())
[13:35:08.073]                   }
[13:35:08.073]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.073]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:08.073]                     cond$call), session = sessionInformation(), 
[13:35:08.073]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:08.073]                   signalCondition(cond)
[13:35:08.073]                 }
[13:35:08.073]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:08.073]                 "immediateCondition"))) {
[13:35:08.073]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:08.073]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.073]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:08.073]                   if (TRUE && !signal) {
[13:35:08.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.073]                     {
[13:35:08.073]                       inherits <- base::inherits
[13:35:08.073]                       invokeRestart <- base::invokeRestart
[13:35:08.073]                       is.null <- base::is.null
[13:35:08.073]                       muffled <- FALSE
[13:35:08.073]                       if (inherits(cond, "message")) {
[13:35:08.073]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.073]                         if (muffled) 
[13:35:08.073]                           invokeRestart("muffleMessage")
[13:35:08.073]                       }
[13:35:08.073]                       else if (inherits(cond, "warning")) {
[13:35:08.073]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.073]                         if (muffled) 
[13:35:08.073]                           invokeRestart("muffleWarning")
[13:35:08.073]                       }
[13:35:08.073]                       else if (inherits(cond, "condition")) {
[13:35:08.073]                         if (!is.null(pattern)) {
[13:35:08.073]                           computeRestarts <- base::computeRestarts
[13:35:08.073]                           grepl <- base::grepl
[13:35:08.073]                           restarts <- computeRestarts(cond)
[13:35:08.073]                           for (restart in restarts) {
[13:35:08.073]                             name <- restart$name
[13:35:08.073]                             if (is.null(name)) 
[13:35:08.073]                               next
[13:35:08.073]                             if (!grepl(pattern, name)) 
[13:35:08.073]                               next
[13:35:08.073]                             invokeRestart(restart)
[13:35:08.073]                             muffled <- TRUE
[13:35:08.073]                             break
[13:35:08.073]                           }
[13:35:08.073]                         }
[13:35:08.073]                       }
[13:35:08.073]                       invisible(muffled)
[13:35:08.073]                     }
[13:35:08.073]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.073]                   }
[13:35:08.073]                 }
[13:35:08.073]                 else {
[13:35:08.073]                   if (TRUE) {
[13:35:08.073]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.073]                     {
[13:35:08.073]                       inherits <- base::inherits
[13:35:08.073]                       invokeRestart <- base::invokeRestart
[13:35:08.073]                       is.null <- base::is.null
[13:35:08.073]                       muffled <- FALSE
[13:35:08.073]                       if (inherits(cond, "message")) {
[13:35:08.073]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.073]                         if (muffled) 
[13:35:08.073]                           invokeRestart("muffleMessage")
[13:35:08.073]                       }
[13:35:08.073]                       else if (inherits(cond, "warning")) {
[13:35:08.073]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.073]                         if (muffled) 
[13:35:08.073]                           invokeRestart("muffleWarning")
[13:35:08.073]                       }
[13:35:08.073]                       else if (inherits(cond, "condition")) {
[13:35:08.073]                         if (!is.null(pattern)) {
[13:35:08.073]                           computeRestarts <- base::computeRestarts
[13:35:08.073]                           grepl <- base::grepl
[13:35:08.073]                           restarts <- computeRestarts(cond)
[13:35:08.073]                           for (restart in restarts) {
[13:35:08.073]                             name <- restart$name
[13:35:08.073]                             if (is.null(name)) 
[13:35:08.073]                               next
[13:35:08.073]                             if (!grepl(pattern, name)) 
[13:35:08.073]                               next
[13:35:08.073]                             invokeRestart(restart)
[13:35:08.073]                             muffled <- TRUE
[13:35:08.073]                             break
[13:35:08.073]                           }
[13:35:08.073]                         }
[13:35:08.073]                       }
[13:35:08.073]                       invisible(muffled)
[13:35:08.073]                     }
[13:35:08.073]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.073]                   }
[13:35:08.073]                 }
[13:35:08.073]             }
[13:35:08.073]         }))
[13:35:08.073]     }, error = function(ex) {
[13:35:08.073]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:08.073]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.073]                 ...future.rng), started = ...future.startTime, 
[13:35:08.073]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:08.073]             version = "1.8"), class = "FutureResult")
[13:35:08.073]     }, finally = {
[13:35:08.073]         if (!identical(...future.workdir, getwd())) 
[13:35:08.073]             setwd(...future.workdir)
[13:35:08.073]         {
[13:35:08.073]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:08.073]                 ...future.oldOptions$nwarnings <- NULL
[13:35:08.073]             }
[13:35:08.073]             base::options(...future.oldOptions)
[13:35:08.073]             if (.Platform$OS.type == "windows") {
[13:35:08.073]                 old_names <- names(...future.oldEnvVars)
[13:35:08.073]                 envs <- base::Sys.getenv()
[13:35:08.073]                 names <- names(envs)
[13:35:08.073]                 common <- intersect(names, old_names)
[13:35:08.073]                 added <- setdiff(names, old_names)
[13:35:08.073]                 removed <- setdiff(old_names, names)
[13:35:08.073]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:08.073]                   envs[common]]
[13:35:08.073]                 NAMES <- toupper(changed)
[13:35:08.073]                 args <- list()
[13:35:08.073]                 for (kk in seq_along(NAMES)) {
[13:35:08.073]                   name <- changed[[kk]]
[13:35:08.073]                   NAME <- NAMES[[kk]]
[13:35:08.073]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.073]                     next
[13:35:08.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.073]                 }
[13:35:08.073]                 NAMES <- toupper(added)
[13:35:08.073]                 for (kk in seq_along(NAMES)) {
[13:35:08.073]                   name <- added[[kk]]
[13:35:08.073]                   NAME <- NAMES[[kk]]
[13:35:08.073]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.073]                     next
[13:35:08.073]                   args[[name]] <- ""
[13:35:08.073]                 }
[13:35:08.073]                 NAMES <- toupper(removed)
[13:35:08.073]                 for (kk in seq_along(NAMES)) {
[13:35:08.073]                   name <- removed[[kk]]
[13:35:08.073]                   NAME <- NAMES[[kk]]
[13:35:08.073]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.073]                     next
[13:35:08.073]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.073]                 }
[13:35:08.073]                 if (length(args) > 0) 
[13:35:08.073]                   base::do.call(base::Sys.setenv, args = args)
[13:35:08.073]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:08.073]             }
[13:35:08.073]             else {
[13:35:08.073]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:08.073]             }
[13:35:08.073]             {
[13:35:08.073]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:08.073]                   0L) {
[13:35:08.073]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:08.073]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:08.073]                   base::options(opts)
[13:35:08.073]                 }
[13:35:08.073]                 {
[13:35:08.073]                   {
[13:35:08.073]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:08.073]                     NULL
[13:35:08.073]                   }
[13:35:08.073]                   options(future.plan = NULL)
[13:35:08.073]                   if (is.na(NA_character_)) 
[13:35:08.073]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.073]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:08.073]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:08.073]                     .init = FALSE)
[13:35:08.073]                 }
[13:35:08.073]             }
[13:35:08.073]         }
[13:35:08.073]     })
[13:35:08.073]     if (TRUE) {
[13:35:08.073]         base::sink(type = "output", split = FALSE)
[13:35:08.073]         if (TRUE) {
[13:35:08.073]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:08.073]         }
[13:35:08.073]         else {
[13:35:08.073]             ...future.result["stdout"] <- base::list(NULL)
[13:35:08.073]         }
[13:35:08.073]         base::close(...future.stdout)
[13:35:08.073]         ...future.stdout <- NULL
[13:35:08.073]     }
[13:35:08.073]     ...future.result$conditions <- ...future.conditions
[13:35:08.073]     ...future.result$finished <- base::Sys.time()
[13:35:08.073]     ...future.result
[13:35:08.073] }
[13:35:08.076] assign_globals() ...
[13:35:08.076] List of 5
[13:35:08.076]  $ ...future.FUN            :function (x, y)  
[13:35:08.076]  $ future.call.arguments    :List of 1
[13:35:08.076]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:08.076]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.076]  $ ...future.elements_ii    :List of 2
[13:35:08.076]   ..$ A: num 50
[13:35:08.076]   ..$ B: num 60
[13:35:08.076]  $ ...future.seeds_ii       : NULL
[13:35:08.076]  $ ...future.globals.maxSize: NULL
[13:35:08.076]  - attr(*, "where")=List of 5
[13:35:08.076]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:08.076]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:08.076]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:08.076]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:08.076]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:08.076]  - attr(*, "resolved")= logi FALSE
[13:35:08.076]  - attr(*, "total_size")= num 4264
[13:35:08.076]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.076]  - attr(*, "already-done")= logi TRUE
[13:35:08.083] - reassign environment for ‘...future.FUN’
[13:35:08.083] - copied ‘...future.FUN’ to environment
[13:35:08.084] - copied ‘future.call.arguments’ to environment
[13:35:08.084] - copied ‘...future.elements_ii’ to environment
[13:35:08.084] - copied ‘...future.seeds_ii’ to environment
[13:35:08.084] - copied ‘...future.globals.maxSize’ to environment
[13:35:08.084] assign_globals() ... done
[13:35:08.084] requestCore(): workers = 2
[13:35:08.086] MulticoreFuture started
[13:35:08.087] - Launch lazy future ... done
[13:35:08.087] run() for ‘MulticoreFuture’ ... done
[13:35:08.088] plan(): Setting new future strategy stack:
[13:35:08.088] Created future:
[13:35:08.088] List of future strategies:
[13:35:08.088] 1. sequential:
[13:35:08.088]    - args: function (..., envir = parent.frame())
[13:35:08.088]    - tweaked: FALSE
[13:35:08.088]    - call: NULL
[13:35:08.090] plan(): nbrOfWorkers() = 1
[13:35:08.093] plan(): Setting new future strategy stack:
[13:35:08.093] List of future strategies:
[13:35:08.093] 1. multicore:
[13:35:08.093]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:08.093]    - tweaked: FALSE
[13:35:08.093]    - call: plan(strategy)
[13:35:08.100] plan(): nbrOfWorkers() = 2
[13:35:08.089] MulticoreFuture:
[13:35:08.089] Label: ‘future_sapply-1’
[13:35:08.089] Expression:
[13:35:08.089] {
[13:35:08.089]     do.call(function(...) {
[13:35:08.089]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.089]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.089]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.089]             on.exit(options(oopts), add = TRUE)
[13:35:08.089]         }
[13:35:08.089]         {
[13:35:08.089]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.089]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.089]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.089]             })
[13:35:08.089]         }
[13:35:08.089]     }, args = future.call.arguments)
[13:35:08.089] }
[13:35:08.089] Lazy evaluation: FALSE
[13:35:08.089] Asynchronous evaluation: TRUE
[13:35:08.089] Local evaluation: TRUE
[13:35:08.089] Environment: R_GlobalEnv
[13:35:08.089] Capture standard output: TRUE
[13:35:08.089] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:08.089] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:08.089] Packages: <none>
[13:35:08.089] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:08.089] Resolved: TRUE
[13:35:08.089] Value: <not collected>
[13:35:08.089] Conditions captured: <none>
[13:35:08.089] Early signaling: FALSE
[13:35:08.089] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:08.089] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.101] Chunk #1 of 2 ... DONE
[13:35:08.101] Chunk #2 of 2 ...
[13:35:08.101]  - Finding globals in 'X' for chunk #2 ...
[13:35:08.102] getGlobalsAndPackages() ...
[13:35:08.102] Searching for globals...
[13:35:08.103] 
[13:35:08.103] Searching for globals ... DONE
[13:35:08.103] - globals: [0] <none>
[13:35:08.103] getGlobalsAndPackages() ... DONE
[13:35:08.103]    + additional globals found: [n=0] 
[13:35:08.103]    + additional namespaces needed: [n=0] 
[13:35:08.104]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:08.104]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:08.104]  - seeds: <none>
[13:35:08.104]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.104] getGlobalsAndPackages() ...
[13:35:08.104] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.105] Resolving globals: FALSE
[13:35:08.105] Tweak future expression to call with '...' arguments ...
[13:35:08.105] {
[13:35:08.105]     do.call(function(...) {
[13:35:08.105]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.105]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.105]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.105]             on.exit(options(oopts), add = TRUE)
[13:35:08.105]         }
[13:35:08.105]         {
[13:35:08.105]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.105]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.105]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.105]             })
[13:35:08.105]         }
[13:35:08.105]     }, args = future.call.arguments)
[13:35:08.105] }
[13:35:08.105] Tweak future expression to call with '...' arguments ... DONE
[13:35:08.106] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.106] 
[13:35:08.107] getGlobalsAndPackages() ... DONE
[13:35:08.107] run() for ‘Future’ ...
[13:35:08.108] - state: ‘created’
[13:35:08.108] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:08.112] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.113] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:08.113]   - Field: ‘label’
[13:35:08.113]   - Field: ‘local’
[13:35:08.113]   - Field: ‘owner’
[13:35:08.113]   - Field: ‘envir’
[13:35:08.113]   - Field: ‘workers’
[13:35:08.113]   - Field: ‘packages’
[13:35:08.114]   - Field: ‘gc’
[13:35:08.114]   - Field: ‘job’
[13:35:08.114]   - Field: ‘conditions’
[13:35:08.114]   - Field: ‘expr’
[13:35:08.114]   - Field: ‘uuid’
[13:35:08.114]   - Field: ‘seed’
[13:35:08.114]   - Field: ‘version’
[13:35:08.115]   - Field: ‘result’
[13:35:08.115]   - Field: ‘asynchronous’
[13:35:08.115]   - Field: ‘calls’
[13:35:08.115]   - Field: ‘globals’
[13:35:08.115]   - Field: ‘stdout’
[13:35:08.115]   - Field: ‘earlySignal’
[13:35:08.115]   - Field: ‘lazy’
[13:35:08.115]   - Field: ‘state’
[13:35:08.116] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:08.116] - Launch lazy future ...
[13:35:08.116] Packages needed by the future expression (n = 0): <none>
[13:35:08.116] Packages needed by future strategies (n = 0): <none>
[13:35:08.117] {
[13:35:08.117]     {
[13:35:08.117]         {
[13:35:08.117]             ...future.startTime <- base::Sys.time()
[13:35:08.117]             {
[13:35:08.117]                 {
[13:35:08.117]                   {
[13:35:08.117]                     {
[13:35:08.117]                       base::local({
[13:35:08.117]                         has_future <- base::requireNamespace("future", 
[13:35:08.117]                           quietly = TRUE)
[13:35:08.117]                         if (has_future) {
[13:35:08.117]                           ns <- base::getNamespace("future")
[13:35:08.117]                           version <- ns[[".package"]][["version"]]
[13:35:08.117]                           if (is.null(version)) 
[13:35:08.117]                             version <- utils::packageVersion("future")
[13:35:08.117]                         }
[13:35:08.117]                         else {
[13:35:08.117]                           version <- NULL
[13:35:08.117]                         }
[13:35:08.117]                         if (!has_future || version < "1.8.0") {
[13:35:08.117]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:08.117]                             "", base::R.version$version.string), 
[13:35:08.117]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:08.117]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:08.117]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:08.117]                               "release", "version")], collapse = " "), 
[13:35:08.117]                             hostname = base::Sys.info()[["nodename"]])
[13:35:08.117]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:08.117]                             info)
[13:35:08.117]                           info <- base::paste(info, collapse = "; ")
[13:35:08.117]                           if (!has_future) {
[13:35:08.117]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:08.117]                               info)
[13:35:08.117]                           }
[13:35:08.117]                           else {
[13:35:08.117]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:08.117]                               info, version)
[13:35:08.117]                           }
[13:35:08.117]                           base::stop(msg)
[13:35:08.117]                         }
[13:35:08.117]                       })
[13:35:08.117]                     }
[13:35:08.117]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:08.117]                     base::options(mc.cores = 1L)
[13:35:08.117]                   }
[13:35:08.117]                   ...future.strategy.old <- future::plan("list")
[13:35:08.117]                   options(future.plan = NULL)
[13:35:08.117]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.117]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:08.117]                 }
[13:35:08.117]                 ...future.workdir <- getwd()
[13:35:08.117]             }
[13:35:08.117]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:08.117]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:08.117]         }
[13:35:08.117]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:08.117]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:08.117]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:08.117]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:08.117]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:08.117]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:08.117]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:08.117]             base::names(...future.oldOptions))
[13:35:08.117]     }
[13:35:08.117]     if (FALSE) {
[13:35:08.117]     }
[13:35:08.117]     else {
[13:35:08.117]         if (TRUE) {
[13:35:08.117]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:08.117]                 open = "w")
[13:35:08.117]         }
[13:35:08.117]         else {
[13:35:08.117]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:08.117]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:08.117]         }
[13:35:08.117]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:08.117]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:08.117]             base::sink(type = "output", split = FALSE)
[13:35:08.117]             base::close(...future.stdout)
[13:35:08.117]         }, add = TRUE)
[13:35:08.117]     }
[13:35:08.117]     ...future.frame <- base::sys.nframe()
[13:35:08.117]     ...future.conditions <- base::list()
[13:35:08.117]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:08.117]     if (FALSE) {
[13:35:08.117]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:08.117]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:08.117]     }
[13:35:08.117]     ...future.result <- base::tryCatch({
[13:35:08.117]         base::withCallingHandlers({
[13:35:08.117]             ...future.value <- base::withVisible(base::local({
[13:35:08.117]                 withCallingHandlers({
[13:35:08.117]                   {
[13:35:08.117]                     do.call(function(...) {
[13:35:08.117]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.117]                       if (!identical(...future.globals.maxSize.org, 
[13:35:08.117]                         ...future.globals.maxSize)) {
[13:35:08.117]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.117]                         on.exit(options(oopts), add = TRUE)
[13:35:08.117]                       }
[13:35:08.117]                       {
[13:35:08.117]                         lapply(seq_along(...future.elements_ii), 
[13:35:08.117]                           FUN = function(jj) {
[13:35:08.117]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.117]                             ...future.FUN(...future.X_jj, ...)
[13:35:08.117]                           })
[13:35:08.117]                       }
[13:35:08.117]                     }, args = future.call.arguments)
[13:35:08.117]                   }
[13:35:08.117]                 }, immediateCondition = function(cond) {
[13:35:08.117]                   save_rds <- function (object, pathname, ...) 
[13:35:08.117]                   {
[13:35:08.117]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:08.117]                     if (file_test("-f", pathname_tmp)) {
[13:35:08.117]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.117]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:08.117]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.117]                         fi_tmp[["mtime"]])
[13:35:08.117]                     }
[13:35:08.117]                     tryCatch({
[13:35:08.117]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:08.117]                     }, error = function(ex) {
[13:35:08.117]                       msg <- conditionMessage(ex)
[13:35:08.117]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.117]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:08.117]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.117]                         fi_tmp[["mtime"]], msg)
[13:35:08.117]                       ex$message <- msg
[13:35:08.117]                       stop(ex)
[13:35:08.117]                     })
[13:35:08.117]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:08.117]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:08.117]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:08.117]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.117]                       fi <- file.info(pathname)
[13:35:08.117]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:08.117]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.117]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:08.117]                         fi[["size"]], fi[["mtime"]])
[13:35:08.117]                       stop(msg)
[13:35:08.117]                     }
[13:35:08.117]                     invisible(pathname)
[13:35:08.117]                   }
[13:35:08.117]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:08.117]                     rootPath = tempdir()) 
[13:35:08.117]                   {
[13:35:08.117]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:08.117]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:08.117]                       tmpdir = path, fileext = ".rds")
[13:35:08.117]                     save_rds(obj, file)
[13:35:08.117]                   }
[13:35:08.117]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:08.117]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.117]                   {
[13:35:08.117]                     inherits <- base::inherits
[13:35:08.117]                     invokeRestart <- base::invokeRestart
[13:35:08.117]                     is.null <- base::is.null
[13:35:08.117]                     muffled <- FALSE
[13:35:08.117]                     if (inherits(cond, "message")) {
[13:35:08.117]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:08.117]                       if (muffled) 
[13:35:08.117]                         invokeRestart("muffleMessage")
[13:35:08.117]                     }
[13:35:08.117]                     else if (inherits(cond, "warning")) {
[13:35:08.117]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:08.117]                       if (muffled) 
[13:35:08.117]                         invokeRestart("muffleWarning")
[13:35:08.117]                     }
[13:35:08.117]                     else if (inherits(cond, "condition")) {
[13:35:08.117]                       if (!is.null(pattern)) {
[13:35:08.117]                         computeRestarts <- base::computeRestarts
[13:35:08.117]                         grepl <- base::grepl
[13:35:08.117]                         restarts <- computeRestarts(cond)
[13:35:08.117]                         for (restart in restarts) {
[13:35:08.117]                           name <- restart$name
[13:35:08.117]                           if (is.null(name)) 
[13:35:08.117]                             next
[13:35:08.117]                           if (!grepl(pattern, name)) 
[13:35:08.117]                             next
[13:35:08.117]                           invokeRestart(restart)
[13:35:08.117]                           muffled <- TRUE
[13:35:08.117]                           break
[13:35:08.117]                         }
[13:35:08.117]                       }
[13:35:08.117]                     }
[13:35:08.117]                     invisible(muffled)
[13:35:08.117]                   }
[13:35:08.117]                   muffleCondition(cond)
[13:35:08.117]                 })
[13:35:08.117]             }))
[13:35:08.117]             future::FutureResult(value = ...future.value$value, 
[13:35:08.117]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.117]                   ...future.rng), globalenv = if (FALSE) 
[13:35:08.117]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:08.117]                     ...future.globalenv.names))
[13:35:08.117]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:08.117]         }, condition = base::local({
[13:35:08.117]             c <- base::c
[13:35:08.117]             inherits <- base::inherits
[13:35:08.117]             invokeRestart <- base::invokeRestart
[13:35:08.117]             length <- base::length
[13:35:08.117]             list <- base::list
[13:35:08.117]             seq.int <- base::seq.int
[13:35:08.117]             signalCondition <- base::signalCondition
[13:35:08.117]             sys.calls <- base::sys.calls
[13:35:08.117]             `[[` <- base::`[[`
[13:35:08.117]             `+` <- base::`+`
[13:35:08.117]             `<<-` <- base::`<<-`
[13:35:08.117]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:08.117]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:08.117]                   3L)]
[13:35:08.117]             }
[13:35:08.117]             function(cond) {
[13:35:08.117]                 is_error <- inherits(cond, "error")
[13:35:08.117]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:08.117]                   NULL)
[13:35:08.117]                 if (is_error) {
[13:35:08.117]                   sessionInformation <- function() {
[13:35:08.117]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:08.117]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:08.117]                       search = base::search(), system = base::Sys.info())
[13:35:08.117]                   }
[13:35:08.117]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.117]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:08.117]                     cond$call), session = sessionInformation(), 
[13:35:08.117]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:08.117]                   signalCondition(cond)
[13:35:08.117]                 }
[13:35:08.117]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:08.117]                 "immediateCondition"))) {
[13:35:08.117]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:08.117]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.117]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:08.117]                   if (TRUE && !signal) {
[13:35:08.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.117]                     {
[13:35:08.117]                       inherits <- base::inherits
[13:35:08.117]                       invokeRestart <- base::invokeRestart
[13:35:08.117]                       is.null <- base::is.null
[13:35:08.117]                       muffled <- FALSE
[13:35:08.117]                       if (inherits(cond, "message")) {
[13:35:08.117]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.117]                         if (muffled) 
[13:35:08.117]                           invokeRestart("muffleMessage")
[13:35:08.117]                       }
[13:35:08.117]                       else if (inherits(cond, "warning")) {
[13:35:08.117]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.117]                         if (muffled) 
[13:35:08.117]                           invokeRestart("muffleWarning")
[13:35:08.117]                       }
[13:35:08.117]                       else if (inherits(cond, "condition")) {
[13:35:08.117]                         if (!is.null(pattern)) {
[13:35:08.117]                           computeRestarts <- base::computeRestarts
[13:35:08.117]                           grepl <- base::grepl
[13:35:08.117]                           restarts <- computeRestarts(cond)
[13:35:08.117]                           for (restart in restarts) {
[13:35:08.117]                             name <- restart$name
[13:35:08.117]                             if (is.null(name)) 
[13:35:08.117]                               next
[13:35:08.117]                             if (!grepl(pattern, name)) 
[13:35:08.117]                               next
[13:35:08.117]                             invokeRestart(restart)
[13:35:08.117]                             muffled <- TRUE
[13:35:08.117]                             break
[13:35:08.117]                           }
[13:35:08.117]                         }
[13:35:08.117]                       }
[13:35:08.117]                       invisible(muffled)
[13:35:08.117]                     }
[13:35:08.117]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.117]                   }
[13:35:08.117]                 }
[13:35:08.117]                 else {
[13:35:08.117]                   if (TRUE) {
[13:35:08.117]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.117]                     {
[13:35:08.117]                       inherits <- base::inherits
[13:35:08.117]                       invokeRestart <- base::invokeRestart
[13:35:08.117]                       is.null <- base::is.null
[13:35:08.117]                       muffled <- FALSE
[13:35:08.117]                       if (inherits(cond, "message")) {
[13:35:08.117]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.117]                         if (muffled) 
[13:35:08.117]                           invokeRestart("muffleMessage")
[13:35:08.117]                       }
[13:35:08.117]                       else if (inherits(cond, "warning")) {
[13:35:08.117]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.117]                         if (muffled) 
[13:35:08.117]                           invokeRestart("muffleWarning")
[13:35:08.117]                       }
[13:35:08.117]                       else if (inherits(cond, "condition")) {
[13:35:08.117]                         if (!is.null(pattern)) {
[13:35:08.117]                           computeRestarts <- base::computeRestarts
[13:35:08.117]                           grepl <- base::grepl
[13:35:08.117]                           restarts <- computeRestarts(cond)
[13:35:08.117]                           for (restart in restarts) {
[13:35:08.117]                             name <- restart$name
[13:35:08.117]                             if (is.null(name)) 
[13:35:08.117]                               next
[13:35:08.117]                             if (!grepl(pattern, name)) 
[13:35:08.117]                               next
[13:35:08.117]                             invokeRestart(restart)
[13:35:08.117]                             muffled <- TRUE
[13:35:08.117]                             break
[13:35:08.117]                           }
[13:35:08.117]                         }
[13:35:08.117]                       }
[13:35:08.117]                       invisible(muffled)
[13:35:08.117]                     }
[13:35:08.117]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.117]                   }
[13:35:08.117]                 }
[13:35:08.117]             }
[13:35:08.117]         }))
[13:35:08.117]     }, error = function(ex) {
[13:35:08.117]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:08.117]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.117]                 ...future.rng), started = ...future.startTime, 
[13:35:08.117]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:08.117]             version = "1.8"), class = "FutureResult")
[13:35:08.117]     }, finally = {
[13:35:08.117]         if (!identical(...future.workdir, getwd())) 
[13:35:08.117]             setwd(...future.workdir)
[13:35:08.117]         {
[13:35:08.117]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:08.117]                 ...future.oldOptions$nwarnings <- NULL
[13:35:08.117]             }
[13:35:08.117]             base::options(...future.oldOptions)
[13:35:08.117]             if (.Platform$OS.type == "windows") {
[13:35:08.117]                 old_names <- names(...future.oldEnvVars)
[13:35:08.117]                 envs <- base::Sys.getenv()
[13:35:08.117]                 names <- names(envs)
[13:35:08.117]                 common <- intersect(names, old_names)
[13:35:08.117]                 added <- setdiff(names, old_names)
[13:35:08.117]                 removed <- setdiff(old_names, names)
[13:35:08.117]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:08.117]                   envs[common]]
[13:35:08.117]                 NAMES <- toupper(changed)
[13:35:08.117]                 args <- list()
[13:35:08.117]                 for (kk in seq_along(NAMES)) {
[13:35:08.117]                   name <- changed[[kk]]
[13:35:08.117]                   NAME <- NAMES[[kk]]
[13:35:08.117]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.117]                     next
[13:35:08.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.117]                 }
[13:35:08.117]                 NAMES <- toupper(added)
[13:35:08.117]                 for (kk in seq_along(NAMES)) {
[13:35:08.117]                   name <- added[[kk]]
[13:35:08.117]                   NAME <- NAMES[[kk]]
[13:35:08.117]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.117]                     next
[13:35:08.117]                   args[[name]] <- ""
[13:35:08.117]                 }
[13:35:08.117]                 NAMES <- toupper(removed)
[13:35:08.117]                 for (kk in seq_along(NAMES)) {
[13:35:08.117]                   name <- removed[[kk]]
[13:35:08.117]                   NAME <- NAMES[[kk]]
[13:35:08.117]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.117]                     next
[13:35:08.117]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.117]                 }
[13:35:08.117]                 if (length(args) > 0) 
[13:35:08.117]                   base::do.call(base::Sys.setenv, args = args)
[13:35:08.117]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:08.117]             }
[13:35:08.117]             else {
[13:35:08.117]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:08.117]             }
[13:35:08.117]             {
[13:35:08.117]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:08.117]                   0L) {
[13:35:08.117]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:08.117]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:08.117]                   base::options(opts)
[13:35:08.117]                 }
[13:35:08.117]                 {
[13:35:08.117]                   {
[13:35:08.117]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:08.117]                     NULL
[13:35:08.117]                   }
[13:35:08.117]                   options(future.plan = NULL)
[13:35:08.117]                   if (is.na(NA_character_)) 
[13:35:08.117]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.117]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:08.117]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:08.117]                     .init = FALSE)
[13:35:08.117]                 }
[13:35:08.117]             }
[13:35:08.117]         }
[13:35:08.117]     })
[13:35:08.117]     if (TRUE) {
[13:35:08.117]         base::sink(type = "output", split = FALSE)
[13:35:08.117]         if (TRUE) {
[13:35:08.117]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:08.117]         }
[13:35:08.117]         else {
[13:35:08.117]             ...future.result["stdout"] <- base::list(NULL)
[13:35:08.117]         }
[13:35:08.117]         base::close(...future.stdout)
[13:35:08.117]         ...future.stdout <- NULL
[13:35:08.117]     }
[13:35:08.117]     ...future.result$conditions <- ...future.conditions
[13:35:08.117]     ...future.result$finished <- base::Sys.time()
[13:35:08.117]     ...future.result
[13:35:08.117] }
[13:35:08.120] assign_globals() ...
[13:35:08.120] List of 5
[13:35:08.120]  $ ...future.FUN            :function (x, y)  
[13:35:08.120]  $ future.call.arguments    :List of 1
[13:35:08.120]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:08.120]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.120]  $ ...future.elements_ii    :List of 2
[13:35:08.120]   ..$ C: num 70
[13:35:08.120]   ..$ D: num 80
[13:35:08.120]  $ ...future.seeds_ii       : NULL
[13:35:08.120]  $ ...future.globals.maxSize: NULL
[13:35:08.120]  - attr(*, "where")=List of 5
[13:35:08.120]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:08.120]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:08.120]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:08.120]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:08.120]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:08.120]  - attr(*, "resolved")= logi FALSE
[13:35:08.120]  - attr(*, "total_size")= num 4264
[13:35:08.120]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.120]  - attr(*, "already-done")= logi TRUE
[13:35:08.130] - reassign environment for ‘...future.FUN’
[13:35:08.130] - copied ‘...future.FUN’ to environment
[13:35:08.131] - copied ‘future.call.arguments’ to environment
[13:35:08.131] - copied ‘...future.elements_ii’ to environment
[13:35:08.131] - copied ‘...future.seeds_ii’ to environment
[13:35:08.131] - copied ‘...future.globals.maxSize’ to environment
[13:35:08.131] assign_globals() ... done
[13:35:08.131] requestCore(): workers = 2
[13:35:08.134] MulticoreFuture started
[13:35:08.135] - Launch lazy future ... done
[13:35:08.135] plan(): Setting new future strategy stack:
[13:35:08.135] run() for ‘MulticoreFuture’ ... done
[13:35:08.136] Created future:
[13:35:08.136] List of future strategies:
[13:35:08.136] 1. sequential:
[13:35:08.136]    - args: function (..., envir = parent.frame())
[13:35:08.136]    - tweaked: FALSE
[13:35:08.136]    - call: NULL
[13:35:08.137] plan(): nbrOfWorkers() = 1
[13:35:08.140] plan(): Setting new future strategy stack:
[13:35:08.140] List of future strategies:
[13:35:08.140] 1. multicore:
[13:35:08.140]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:08.140]    - tweaked: FALSE
[13:35:08.140]    - call: plan(strategy)
[13:35:08.147] plan(): nbrOfWorkers() = 2
[13:35:08.136] MulticoreFuture:
[13:35:08.136] Label: ‘future_sapply-2’
[13:35:08.136] Expression:
[13:35:08.136] {
[13:35:08.136]     do.call(function(...) {
[13:35:08.136]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.136]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.136]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.136]             on.exit(options(oopts), add = TRUE)
[13:35:08.136]         }
[13:35:08.136]         {
[13:35:08.136]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.136]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.136]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.136]             })
[13:35:08.136]         }
[13:35:08.136]     }, args = future.call.arguments)
[13:35:08.136] }
[13:35:08.136] Lazy evaluation: FALSE
[13:35:08.136] Asynchronous evaluation: TRUE
[13:35:08.136] Local evaluation: TRUE
[13:35:08.136] Environment: R_GlobalEnv
[13:35:08.136] Capture standard output: TRUE
[13:35:08.136] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:08.136] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:08.136] Packages: <none>
[13:35:08.136] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:08.136] Resolved: TRUE
[13:35:08.136] Value: <not collected>
[13:35:08.136] Conditions captured: <none>
[13:35:08.136] Early signaling: FALSE
[13:35:08.136] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:08.136] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.148] Chunk #2 of 2 ... DONE
[13:35:08.148] Launching 2 futures (chunks) ... DONE
[13:35:08.149] Resolving 2 futures (chunks) ...
[13:35:08.149] resolve() on list ...
[13:35:08.149]  recursive: 0
[13:35:08.149]  length: 2
[13:35:08.150] 
[13:35:08.150] Future #1
[13:35:08.150] result() for MulticoreFuture ...
[13:35:08.151] result() for MulticoreFuture ...
[13:35:08.151] result() for MulticoreFuture ... done
[13:35:08.152] result() for MulticoreFuture ... done
[13:35:08.152] result() for MulticoreFuture ...
[13:35:08.152] result() for MulticoreFuture ... done
[13:35:08.153] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:08.153] - nx: 2
[13:35:08.153] - relay: TRUE
[13:35:08.153] - stdout: TRUE
[13:35:08.153] - signal: TRUE
[13:35:08.154] - resignal: FALSE
[13:35:08.154] - force: TRUE
[13:35:08.154] - relayed: [n=2] FALSE, FALSE
[13:35:08.154] - queued futures: [n=2] FALSE, FALSE
[13:35:08.155]  - until=1
[13:35:08.155]  - relaying element #1
[13:35:08.155] result() for MulticoreFuture ...
[13:35:08.155] result() for MulticoreFuture ... done
[13:35:08.155] result() for MulticoreFuture ...
[13:35:08.155] result() for MulticoreFuture ... done
[13:35:08.156] result() for MulticoreFuture ...
[13:35:08.156] result() for MulticoreFuture ... done
[13:35:08.156] result() for MulticoreFuture ...
[13:35:08.156] result() for MulticoreFuture ... done
[13:35:08.156] - relayed: [n=2] TRUE, FALSE
[13:35:08.156] - queued futures: [n=2] TRUE, FALSE
[13:35:08.157] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:08.157]  length: 1 (resolved future 1)
[13:35:08.157] Future #2
[13:35:08.158] result() for MulticoreFuture ...
[13:35:08.158] result() for MulticoreFuture ...
[13:35:08.158] result() for MulticoreFuture ... done
[13:35:08.159] result() for MulticoreFuture ... done
[13:35:08.159] result() for MulticoreFuture ...
[13:35:08.159] result() for MulticoreFuture ... done
[13:35:08.159] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:08.159] - nx: 2
[13:35:08.159] - relay: TRUE
[13:35:08.159] - stdout: TRUE
[13:35:08.160] - signal: TRUE
[13:35:08.160] - resignal: FALSE
[13:35:08.160] - force: TRUE
[13:35:08.160] - relayed: [n=2] TRUE, FALSE
[13:35:08.160] - queued futures: [n=2] TRUE, FALSE
[13:35:08.160]  - until=2
[13:35:08.160]  - relaying element #2
[13:35:08.160] result() for MulticoreFuture ...
[13:35:08.160] result() for MulticoreFuture ... done
[13:35:08.161] result() for MulticoreFuture ...
[13:35:08.161] result() for MulticoreFuture ... done
[13:35:08.161] result() for MulticoreFuture ...
[13:35:08.161] result() for MulticoreFuture ... done
[13:35:08.161] result() for MulticoreFuture ...
[13:35:08.161] result() for MulticoreFuture ... done
[13:35:08.161] - relayed: [n=2] TRUE, TRUE
[13:35:08.161] - queued futures: [n=2] TRUE, TRUE
[13:35:08.162] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:08.162]  length: 0 (resolved future 2)
[13:35:08.162] Relaying remaining futures
[13:35:08.162] signalConditionsASAP(NULL, pos=0) ...
[13:35:08.162] - nx: 2
[13:35:08.162] - relay: TRUE
[13:35:08.162] - stdout: TRUE
[13:35:08.162] - signal: TRUE
[13:35:08.162] - resignal: FALSE
[13:35:08.162] - force: TRUE
[13:35:08.163] - relayed: [n=2] TRUE, TRUE
[13:35:08.163] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:08.163] - relayed: [n=2] TRUE, TRUE
[13:35:08.163] - queued futures: [n=2] TRUE, TRUE
[13:35:08.163] signalConditionsASAP(NULL, pos=0) ... done
[13:35:08.163] resolve() on list ... DONE
[13:35:08.163] result() for MulticoreFuture ...
[13:35:08.163] result() for MulticoreFuture ... done
[13:35:08.163] result() for MulticoreFuture ...
[13:35:08.164] result() for MulticoreFuture ... done
[13:35:08.164] result() for MulticoreFuture ...
[13:35:08.164] result() for MulticoreFuture ... done
[13:35:08.164] result() for MulticoreFuture ...
[13:35:08.164] result() for MulticoreFuture ... done
[13:35:08.164]  - Number of value chunks collected: 2
[13:35:08.164] Resolving 2 futures (chunks) ... DONE
[13:35:08.164] Reducing values from 2 chunks ...
[13:35:08.164]  - Number of values collected after concatenation: 4
[13:35:08.165]  - Number of values expected: 4
[13:35:08.165] Reducing values from 2 chunks ... DONE
[13:35:08.165] future_lapply() ... DONE
[13:35:08.165] future_lapply() ...
[13:35:08.171] Number of chunks: 2
[13:35:08.171] getGlobalsAndPackagesXApply() ...
[13:35:08.172]  - future.globals: TRUE
[13:35:08.172] getGlobalsAndPackages() ...
[13:35:08.172] Searching for globals...
[13:35:08.179] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[13:35:08.179] Searching for globals ... DONE
[13:35:08.179] Resolving globals: FALSE
[13:35:08.180] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[13:35:08.180] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:08.181] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:08.181] - packages: [1] ‘future.apply’
[13:35:08.181] getGlobalsAndPackages() ... DONE
[13:35:08.181]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:08.181]  - needed namespaces: [n=1] ‘future.apply’
[13:35:08.181] Finding globals ... DONE
[13:35:08.181]  - use_args: TRUE
[13:35:08.181]  - Getting '...' globals ...
[13:35:08.182] resolve() on list ...
[13:35:08.182]  recursive: 0
[13:35:08.182]  length: 1
[13:35:08.182]  elements: ‘...’
[13:35:08.182]  length: 0 (resolved future 1)
[13:35:08.182] resolve() on list ... DONE
[13:35:08.182]    - '...' content: [n=1] ‘y’
[13:35:08.183] List of 1
[13:35:08.183]  $ ...:List of 1
[13:35:08.183]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:08.183]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.183]  - attr(*, "where")=List of 1
[13:35:08.183]   ..$ ...:<environment: 0x5574d05a49c0> 
[13:35:08.183]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.183]  - attr(*, "resolved")= logi TRUE
[13:35:08.183]  - attr(*, "total_size")= num NA
[13:35:08.186]  - Getting '...' globals ... DONE
[13:35:08.186] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:08.186] List of 8
[13:35:08.186]  $ ...future.FUN:function (x, ...)  
[13:35:08.186]  $ x_FUN        :function (x, y)  
[13:35:08.186]  $ times        : int 15
[13:35:08.186]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:08.186]  $ stop_if_not  :function (...)  
[13:35:08.186]  $ dim          : int [1:2] 3 5
[13:35:08.186]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:08.186]  $ ...          :List of 1
[13:35:08.186]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:08.186]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.186]  - attr(*, "where")=List of 8
[13:35:08.186]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:08.186]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:08.186]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:08.186]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:08.186]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:08.186]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:08.186]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:08.186]   ..$ ...          :<environment: 0x5574d05a49c0> 
[13:35:08.186]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.186]  - attr(*, "resolved")= logi FALSE
[13:35:08.186]  - attr(*, "total_size")= num 98600
[13:35:08.192] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:08.192] getGlobalsAndPackagesXApply() ... DONE
[13:35:08.192] Number of futures (= number of chunks): 2
[13:35:08.192] Launching 2 futures (chunks) ...
[13:35:08.192] Chunk #1 of 2 ...
[13:35:08.193]  - Finding globals in 'X' for chunk #1 ...
[13:35:08.193] getGlobalsAndPackages() ...
[13:35:08.193] Searching for globals...
[13:35:08.195] 
[13:35:08.195] Searching for globals ... DONE
[13:35:08.195] - globals: [0] <none>
[13:35:08.195] getGlobalsAndPackages() ... DONE
[13:35:08.196]    + additional globals found: [n=0] 
[13:35:08.196]    + additional namespaces needed: [n=0] 
[13:35:08.196]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:08.196]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:08.196]  - seeds: <none>
[13:35:08.196]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.196] getGlobalsAndPackages() ...
[13:35:08.196] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.196] Resolving globals: FALSE
[13:35:08.197] Tweak future expression to call with '...' arguments ...
[13:35:08.197] {
[13:35:08.197]     do.call(function(...) {
[13:35:08.197]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.197]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.197]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.197]             on.exit(options(oopts), add = TRUE)
[13:35:08.197]         }
[13:35:08.197]         {
[13:35:08.197]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.197]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.197]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.197]             })
[13:35:08.197]         }
[13:35:08.197]     }, args = future.call.arguments)
[13:35:08.197] }
[13:35:08.197] Tweak future expression to call with '...' arguments ... DONE
[13:35:08.198] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.198] - packages: [1] ‘future.apply’
[13:35:08.198] getGlobalsAndPackages() ... DONE
[13:35:08.198] run() for ‘Future’ ...
[13:35:08.198] - state: ‘created’
[13:35:08.198] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:08.202] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.202] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:08.202]   - Field: ‘label’
[13:35:08.202]   - Field: ‘local’
[13:35:08.202]   - Field: ‘owner’
[13:35:08.203]   - Field: ‘envir’
[13:35:08.203]   - Field: ‘workers’
[13:35:08.203]   - Field: ‘packages’
[13:35:08.203]   - Field: ‘gc’
[13:35:08.203]   - Field: ‘job’
[13:35:08.203]   - Field: ‘conditions’
[13:35:08.203]   - Field: ‘expr’
[13:35:08.203]   - Field: ‘uuid’
[13:35:08.203]   - Field: ‘seed’
[13:35:08.203]   - Field: ‘version’
[13:35:08.204]   - Field: ‘result’
[13:35:08.204]   - Field: ‘asynchronous’
[13:35:08.204]   - Field: ‘calls’
[13:35:08.204]   - Field: ‘globals’
[13:35:08.204]   - Field: ‘stdout’
[13:35:08.204]   - Field: ‘earlySignal’
[13:35:08.204]   - Field: ‘lazy’
[13:35:08.204]   - Field: ‘state’
[13:35:08.204] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:08.204] - Launch lazy future ...
[13:35:08.205] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:08.205] Packages needed by future strategies (n = 0): <none>
[13:35:08.205] {
[13:35:08.205]     {
[13:35:08.205]         {
[13:35:08.205]             ...future.startTime <- base::Sys.time()
[13:35:08.205]             {
[13:35:08.205]                 {
[13:35:08.205]                   {
[13:35:08.205]                     {
[13:35:08.205]                       {
[13:35:08.205]                         base::local({
[13:35:08.205]                           has_future <- base::requireNamespace("future", 
[13:35:08.205]                             quietly = TRUE)
[13:35:08.205]                           if (has_future) {
[13:35:08.205]                             ns <- base::getNamespace("future")
[13:35:08.205]                             version <- ns[[".package"]][["version"]]
[13:35:08.205]                             if (is.null(version)) 
[13:35:08.205]                               version <- utils::packageVersion("future")
[13:35:08.205]                           }
[13:35:08.205]                           else {
[13:35:08.205]                             version <- NULL
[13:35:08.205]                           }
[13:35:08.205]                           if (!has_future || version < "1.8.0") {
[13:35:08.205]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:08.205]                               "", base::R.version$version.string), 
[13:35:08.205]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:08.205]                                 base::R.version$platform, 8 * 
[13:35:08.205]                                   base::.Machine$sizeof.pointer), 
[13:35:08.205]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:08.205]                                 "release", "version")], collapse = " "), 
[13:35:08.205]                               hostname = base::Sys.info()[["nodename"]])
[13:35:08.205]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:08.205]                               info)
[13:35:08.205]                             info <- base::paste(info, collapse = "; ")
[13:35:08.205]                             if (!has_future) {
[13:35:08.205]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:08.205]                                 info)
[13:35:08.205]                             }
[13:35:08.205]                             else {
[13:35:08.205]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:08.205]                                 info, version)
[13:35:08.205]                             }
[13:35:08.205]                             base::stop(msg)
[13:35:08.205]                           }
[13:35:08.205]                         })
[13:35:08.205]                       }
[13:35:08.205]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:08.205]                       base::options(mc.cores = 1L)
[13:35:08.205]                     }
[13:35:08.205]                     base::local({
[13:35:08.205]                       for (pkg in "future.apply") {
[13:35:08.205]                         base::loadNamespace(pkg)
[13:35:08.205]                         base::library(pkg, character.only = TRUE)
[13:35:08.205]                       }
[13:35:08.205]                     })
[13:35:08.205]                   }
[13:35:08.205]                   ...future.strategy.old <- future::plan("list")
[13:35:08.205]                   options(future.plan = NULL)
[13:35:08.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:08.205]                 }
[13:35:08.205]                 ...future.workdir <- getwd()
[13:35:08.205]             }
[13:35:08.205]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:08.205]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:08.205]         }
[13:35:08.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:08.205]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:08.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:08.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:08.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:08.205]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:08.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:08.205]             base::names(...future.oldOptions))
[13:35:08.205]     }
[13:35:08.205]     if (FALSE) {
[13:35:08.205]     }
[13:35:08.205]     else {
[13:35:08.205]         if (TRUE) {
[13:35:08.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:08.205]                 open = "w")
[13:35:08.205]         }
[13:35:08.205]         else {
[13:35:08.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:08.205]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:08.205]         }
[13:35:08.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:08.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:08.205]             base::sink(type = "output", split = FALSE)
[13:35:08.205]             base::close(...future.stdout)
[13:35:08.205]         }, add = TRUE)
[13:35:08.205]     }
[13:35:08.205]     ...future.frame <- base::sys.nframe()
[13:35:08.205]     ...future.conditions <- base::list()
[13:35:08.205]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:08.205]     if (FALSE) {
[13:35:08.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:08.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:08.205]     }
[13:35:08.205]     ...future.result <- base::tryCatch({
[13:35:08.205]         base::withCallingHandlers({
[13:35:08.205]             ...future.value <- base::withVisible(base::local({
[13:35:08.205]                 withCallingHandlers({
[13:35:08.205]                   {
[13:35:08.205]                     do.call(function(...) {
[13:35:08.205]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.205]                       if (!identical(...future.globals.maxSize.org, 
[13:35:08.205]                         ...future.globals.maxSize)) {
[13:35:08.205]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.205]                         on.exit(options(oopts), add = TRUE)
[13:35:08.205]                       }
[13:35:08.205]                       {
[13:35:08.205]                         lapply(seq_along(...future.elements_ii), 
[13:35:08.205]                           FUN = function(jj) {
[13:35:08.205]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.205]                             ...future.FUN(...future.X_jj, ...)
[13:35:08.205]                           })
[13:35:08.205]                       }
[13:35:08.205]                     }, args = future.call.arguments)
[13:35:08.205]                   }
[13:35:08.205]                 }, immediateCondition = function(cond) {
[13:35:08.205]                   save_rds <- function (object, pathname, ...) 
[13:35:08.205]                   {
[13:35:08.205]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:08.205]                     if (file_test("-f", pathname_tmp)) {
[13:35:08.205]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.205]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:08.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.205]                         fi_tmp[["mtime"]])
[13:35:08.205]                     }
[13:35:08.205]                     tryCatch({
[13:35:08.205]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:08.205]                     }, error = function(ex) {
[13:35:08.205]                       msg <- conditionMessage(ex)
[13:35:08.205]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.205]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:08.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.205]                         fi_tmp[["mtime"]], msg)
[13:35:08.205]                       ex$message <- msg
[13:35:08.205]                       stop(ex)
[13:35:08.205]                     })
[13:35:08.205]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:08.205]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:08.205]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:08.205]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.205]                       fi <- file.info(pathname)
[13:35:08.205]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:08.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.205]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:08.205]                         fi[["size"]], fi[["mtime"]])
[13:35:08.205]                       stop(msg)
[13:35:08.205]                     }
[13:35:08.205]                     invisible(pathname)
[13:35:08.205]                   }
[13:35:08.205]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:08.205]                     rootPath = tempdir()) 
[13:35:08.205]                   {
[13:35:08.205]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:08.205]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:08.205]                       tmpdir = path, fileext = ".rds")
[13:35:08.205]                     save_rds(obj, file)
[13:35:08.205]                   }
[13:35:08.205]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:08.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.205]                   {
[13:35:08.205]                     inherits <- base::inherits
[13:35:08.205]                     invokeRestart <- base::invokeRestart
[13:35:08.205]                     is.null <- base::is.null
[13:35:08.205]                     muffled <- FALSE
[13:35:08.205]                     if (inherits(cond, "message")) {
[13:35:08.205]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:08.205]                       if (muffled) 
[13:35:08.205]                         invokeRestart("muffleMessage")
[13:35:08.205]                     }
[13:35:08.205]                     else if (inherits(cond, "warning")) {
[13:35:08.205]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:08.205]                       if (muffled) 
[13:35:08.205]                         invokeRestart("muffleWarning")
[13:35:08.205]                     }
[13:35:08.205]                     else if (inherits(cond, "condition")) {
[13:35:08.205]                       if (!is.null(pattern)) {
[13:35:08.205]                         computeRestarts <- base::computeRestarts
[13:35:08.205]                         grepl <- base::grepl
[13:35:08.205]                         restarts <- computeRestarts(cond)
[13:35:08.205]                         for (restart in restarts) {
[13:35:08.205]                           name <- restart$name
[13:35:08.205]                           if (is.null(name)) 
[13:35:08.205]                             next
[13:35:08.205]                           if (!grepl(pattern, name)) 
[13:35:08.205]                             next
[13:35:08.205]                           invokeRestart(restart)
[13:35:08.205]                           muffled <- TRUE
[13:35:08.205]                           break
[13:35:08.205]                         }
[13:35:08.205]                       }
[13:35:08.205]                     }
[13:35:08.205]                     invisible(muffled)
[13:35:08.205]                   }
[13:35:08.205]                   muffleCondition(cond)
[13:35:08.205]                 })
[13:35:08.205]             }))
[13:35:08.205]             future::FutureResult(value = ...future.value$value, 
[13:35:08.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.205]                   ...future.rng), globalenv = if (FALSE) 
[13:35:08.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:08.205]                     ...future.globalenv.names))
[13:35:08.205]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:08.205]         }, condition = base::local({
[13:35:08.205]             c <- base::c
[13:35:08.205]             inherits <- base::inherits
[13:35:08.205]             invokeRestart <- base::invokeRestart
[13:35:08.205]             length <- base::length
[13:35:08.205]             list <- base::list
[13:35:08.205]             seq.int <- base::seq.int
[13:35:08.205]             signalCondition <- base::signalCondition
[13:35:08.205]             sys.calls <- base::sys.calls
[13:35:08.205]             `[[` <- base::`[[`
[13:35:08.205]             `+` <- base::`+`
[13:35:08.205]             `<<-` <- base::`<<-`
[13:35:08.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:08.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:08.205]                   3L)]
[13:35:08.205]             }
[13:35:08.205]             function(cond) {
[13:35:08.205]                 is_error <- inherits(cond, "error")
[13:35:08.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:08.205]                   NULL)
[13:35:08.205]                 if (is_error) {
[13:35:08.205]                   sessionInformation <- function() {
[13:35:08.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:08.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:08.205]                       search = base::search(), system = base::Sys.info())
[13:35:08.205]                   }
[13:35:08.205]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:08.205]                     cond$call), session = sessionInformation(), 
[13:35:08.205]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:08.205]                   signalCondition(cond)
[13:35:08.205]                 }
[13:35:08.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:08.205]                 "immediateCondition"))) {
[13:35:08.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:08.205]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:08.205]                   if (TRUE && !signal) {
[13:35:08.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.205]                     {
[13:35:08.205]                       inherits <- base::inherits
[13:35:08.205]                       invokeRestart <- base::invokeRestart
[13:35:08.205]                       is.null <- base::is.null
[13:35:08.205]                       muffled <- FALSE
[13:35:08.205]                       if (inherits(cond, "message")) {
[13:35:08.205]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.205]                         if (muffled) 
[13:35:08.205]                           invokeRestart("muffleMessage")
[13:35:08.205]                       }
[13:35:08.205]                       else if (inherits(cond, "warning")) {
[13:35:08.205]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.205]                         if (muffled) 
[13:35:08.205]                           invokeRestart("muffleWarning")
[13:35:08.205]                       }
[13:35:08.205]                       else if (inherits(cond, "condition")) {
[13:35:08.205]                         if (!is.null(pattern)) {
[13:35:08.205]                           computeRestarts <- base::computeRestarts
[13:35:08.205]                           grepl <- base::grepl
[13:35:08.205]                           restarts <- computeRestarts(cond)
[13:35:08.205]                           for (restart in restarts) {
[13:35:08.205]                             name <- restart$name
[13:35:08.205]                             if (is.null(name)) 
[13:35:08.205]                               next
[13:35:08.205]                             if (!grepl(pattern, name)) 
[13:35:08.205]                               next
[13:35:08.205]                             invokeRestart(restart)
[13:35:08.205]                             muffled <- TRUE
[13:35:08.205]                             break
[13:35:08.205]                           }
[13:35:08.205]                         }
[13:35:08.205]                       }
[13:35:08.205]                       invisible(muffled)
[13:35:08.205]                     }
[13:35:08.205]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.205]                   }
[13:35:08.205]                 }
[13:35:08.205]                 else {
[13:35:08.205]                   if (TRUE) {
[13:35:08.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.205]                     {
[13:35:08.205]                       inherits <- base::inherits
[13:35:08.205]                       invokeRestart <- base::invokeRestart
[13:35:08.205]                       is.null <- base::is.null
[13:35:08.205]                       muffled <- FALSE
[13:35:08.205]                       if (inherits(cond, "message")) {
[13:35:08.205]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.205]                         if (muffled) 
[13:35:08.205]                           invokeRestart("muffleMessage")
[13:35:08.205]                       }
[13:35:08.205]                       else if (inherits(cond, "warning")) {
[13:35:08.205]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.205]                         if (muffled) 
[13:35:08.205]                           invokeRestart("muffleWarning")
[13:35:08.205]                       }
[13:35:08.205]                       else if (inherits(cond, "condition")) {
[13:35:08.205]                         if (!is.null(pattern)) {
[13:35:08.205]                           computeRestarts <- base::computeRestarts
[13:35:08.205]                           grepl <- base::grepl
[13:35:08.205]                           restarts <- computeRestarts(cond)
[13:35:08.205]                           for (restart in restarts) {
[13:35:08.205]                             name <- restart$name
[13:35:08.205]                             if (is.null(name)) 
[13:35:08.205]                               next
[13:35:08.205]                             if (!grepl(pattern, name)) 
[13:35:08.205]                               next
[13:35:08.205]                             invokeRestart(restart)
[13:35:08.205]                             muffled <- TRUE
[13:35:08.205]                             break
[13:35:08.205]                           }
[13:35:08.205]                         }
[13:35:08.205]                       }
[13:35:08.205]                       invisible(muffled)
[13:35:08.205]                     }
[13:35:08.205]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.205]                   }
[13:35:08.205]                 }
[13:35:08.205]             }
[13:35:08.205]         }))
[13:35:08.205]     }, error = function(ex) {
[13:35:08.205]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:08.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.205]                 ...future.rng), started = ...future.startTime, 
[13:35:08.205]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:08.205]             version = "1.8"), class = "FutureResult")
[13:35:08.205]     }, finally = {
[13:35:08.205]         if (!identical(...future.workdir, getwd())) 
[13:35:08.205]             setwd(...future.workdir)
[13:35:08.205]         {
[13:35:08.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:08.205]                 ...future.oldOptions$nwarnings <- NULL
[13:35:08.205]             }
[13:35:08.205]             base::options(...future.oldOptions)
[13:35:08.205]             if (.Platform$OS.type == "windows") {
[13:35:08.205]                 old_names <- names(...future.oldEnvVars)
[13:35:08.205]                 envs <- base::Sys.getenv()
[13:35:08.205]                 names <- names(envs)
[13:35:08.205]                 common <- intersect(names, old_names)
[13:35:08.205]                 added <- setdiff(names, old_names)
[13:35:08.205]                 removed <- setdiff(old_names, names)
[13:35:08.205]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:08.205]                   envs[common]]
[13:35:08.205]                 NAMES <- toupper(changed)
[13:35:08.205]                 args <- list()
[13:35:08.205]                 for (kk in seq_along(NAMES)) {
[13:35:08.205]                   name <- changed[[kk]]
[13:35:08.205]                   NAME <- NAMES[[kk]]
[13:35:08.205]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.205]                     next
[13:35:08.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.205]                 }
[13:35:08.205]                 NAMES <- toupper(added)
[13:35:08.205]                 for (kk in seq_along(NAMES)) {
[13:35:08.205]                   name <- added[[kk]]
[13:35:08.205]                   NAME <- NAMES[[kk]]
[13:35:08.205]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.205]                     next
[13:35:08.205]                   args[[name]] <- ""
[13:35:08.205]                 }
[13:35:08.205]                 NAMES <- toupper(removed)
[13:35:08.205]                 for (kk in seq_along(NAMES)) {
[13:35:08.205]                   name <- removed[[kk]]
[13:35:08.205]                   NAME <- NAMES[[kk]]
[13:35:08.205]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.205]                     next
[13:35:08.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.205]                 }
[13:35:08.205]                 if (length(args) > 0) 
[13:35:08.205]                   base::do.call(base::Sys.setenv, args = args)
[13:35:08.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:08.205]             }
[13:35:08.205]             else {
[13:35:08.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:08.205]             }
[13:35:08.205]             {
[13:35:08.205]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:08.205]                   0L) {
[13:35:08.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:08.205]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:08.205]                   base::options(opts)
[13:35:08.205]                 }
[13:35:08.205]                 {
[13:35:08.205]                   {
[13:35:08.205]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:08.205]                     NULL
[13:35:08.205]                   }
[13:35:08.205]                   options(future.plan = NULL)
[13:35:08.205]                   if (is.na(NA_character_)) 
[13:35:08.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:08.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:08.205]                     .init = FALSE)
[13:35:08.205]                 }
[13:35:08.205]             }
[13:35:08.205]         }
[13:35:08.205]     })
[13:35:08.205]     if (TRUE) {
[13:35:08.205]         base::sink(type = "output", split = FALSE)
[13:35:08.205]         if (TRUE) {
[13:35:08.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:08.205]         }
[13:35:08.205]         else {
[13:35:08.205]             ...future.result["stdout"] <- base::list(NULL)
[13:35:08.205]         }
[13:35:08.205]         base::close(...future.stdout)
[13:35:08.205]         ...future.stdout <- NULL
[13:35:08.205]     }
[13:35:08.205]     ...future.result$conditions <- ...future.conditions
[13:35:08.205]     ...future.result$finished <- base::Sys.time()
[13:35:08.205]     ...future.result
[13:35:08.205] }
[13:35:08.208] assign_globals() ...
[13:35:08.208] List of 11
[13:35:08.208]  $ ...future.FUN            :function (x, ...)  
[13:35:08.208]  $ x_FUN                    :function (x, y)  
[13:35:08.208]  $ times                    : int 15
[13:35:08.208]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:08.208]  $ stop_if_not              :function (...)  
[13:35:08.208]  $ dim                      : int [1:2] 3 5
[13:35:08.208]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:08.208]  $ future.call.arguments    :List of 1
[13:35:08.208]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:08.208]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.208]  $ ...future.elements_ii    :List of 2
[13:35:08.208]   ..$ A: num 50
[13:35:08.208]   ..$ B: num 60
[13:35:08.208]  $ ...future.seeds_ii       : NULL
[13:35:08.208]  $ ...future.globals.maxSize: NULL
[13:35:08.208]  - attr(*, "where")=List of 11
[13:35:08.208]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:08.208]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:08.208]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:08.208]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:08.208]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:08.208]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:08.208]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:08.208]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:08.208]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:08.208]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:08.208]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:08.208]  - attr(*, "resolved")= logi FALSE
[13:35:08.208]  - attr(*, "total_size")= num 98600
[13:35:08.208]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.208]  - attr(*, "already-done")= logi TRUE
[13:35:08.216] - copied ‘...future.FUN’ to environment
[13:35:08.216] - reassign environment for ‘x_FUN’
[13:35:08.216] - copied ‘x_FUN’ to environment
[13:35:08.216] - copied ‘times’ to environment
[13:35:08.216] - copied ‘stopf’ to environment
[13:35:08.217] - copied ‘stop_if_not’ to environment
[13:35:08.217] - copied ‘dim’ to environment
[13:35:08.217] - copied ‘valid_types’ to environment
[13:35:08.219] - copied ‘future.call.arguments’ to environment
[13:35:08.219] - copied ‘...future.elements_ii’ to environment
[13:35:08.219] - copied ‘...future.seeds_ii’ to environment
[13:35:08.219] - copied ‘...future.globals.maxSize’ to environment
[13:35:08.219] assign_globals() ... done
[13:35:08.220] requestCore(): workers = 2
[13:35:08.222] MulticoreFuture started
[13:35:08.223] - Launch lazy future ... done
[13:35:08.223] run() for ‘MulticoreFuture’ ... done
[13:35:08.224] Created future:
[13:35:08.224] plan(): Setting new future strategy stack:
[13:35:08.224] List of future strategies:
[13:35:08.224] 1. sequential:
[13:35:08.224]    - args: function (..., envir = parent.frame())
[13:35:08.224]    - tweaked: FALSE
[13:35:08.224]    - call: NULL
[13:35:08.226] plan(): nbrOfWorkers() = 1
[13:35:08.229] plan(): Setting new future strategy stack:
[13:35:08.229] List of future strategies:
[13:35:08.229] 1. multicore:
[13:35:08.229]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:08.229]    - tweaked: FALSE
[13:35:08.229]    - call: plan(strategy)
[13:35:08.236] plan(): nbrOfWorkers() = 2
[13:35:08.224] MulticoreFuture:
[13:35:08.224] Label: ‘future_vapply-1’
[13:35:08.224] Expression:
[13:35:08.224] {
[13:35:08.224]     do.call(function(...) {
[13:35:08.224]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.224]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.224]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.224]             on.exit(options(oopts), add = TRUE)
[13:35:08.224]         }
[13:35:08.224]         {
[13:35:08.224]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.224]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.224]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.224]             })
[13:35:08.224]         }
[13:35:08.224]     }, args = future.call.arguments)
[13:35:08.224] }
[13:35:08.224] Lazy evaluation: FALSE
[13:35:08.224] Asynchronous evaluation: TRUE
[13:35:08.224] Local evaluation: TRUE
[13:35:08.224] Environment: R_GlobalEnv
[13:35:08.224] Capture standard output: TRUE
[13:35:08.224] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:08.224] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:08.224] Packages: 1 packages (‘future.apply’)
[13:35:08.224] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:08.224] Resolved: TRUE
[13:35:08.224] Value: <not collected>
[13:35:08.224] Conditions captured: <none>
[13:35:08.224] Early signaling: FALSE
[13:35:08.224] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:08.224] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.237] Chunk #1 of 2 ... DONE
[13:35:08.237] Chunk #2 of 2 ...
[13:35:08.237]  - Finding globals in 'X' for chunk #2 ...
[13:35:08.238] getGlobalsAndPackages() ...
[13:35:08.238] Searching for globals...
[13:35:08.238] 
[13:35:08.239] Searching for globals ... DONE
[13:35:08.239] - globals: [0] <none>
[13:35:08.239] getGlobalsAndPackages() ... DONE
[13:35:08.239]    + additional globals found: [n=0] 
[13:35:08.239]    + additional namespaces needed: [n=0] 
[13:35:08.240]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:08.240]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:08.240]  - seeds: <none>
[13:35:08.240]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.240] getGlobalsAndPackages() ...
[13:35:08.241] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.241] Resolving globals: FALSE
[13:35:08.241] Tweak future expression to call with '...' arguments ...
[13:35:08.241] {
[13:35:08.241]     do.call(function(...) {
[13:35:08.241]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.241]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.241]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.241]             on.exit(options(oopts), add = TRUE)
[13:35:08.241]         }
[13:35:08.241]         {
[13:35:08.241]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.241]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.241]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.241]             })
[13:35:08.241]         }
[13:35:08.241]     }, args = future.call.arguments)
[13:35:08.241] }
[13:35:08.242] Tweak future expression to call with '...' arguments ... DONE
[13:35:08.243] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.244] - packages: [1] ‘future.apply’
[13:35:08.244] getGlobalsAndPackages() ... DONE
[13:35:08.245] run() for ‘Future’ ...
[13:35:08.245] - state: ‘created’
[13:35:08.245] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:08.250] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.251] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:08.251]   - Field: ‘label’
[13:35:08.251]   - Field: ‘local’
[13:35:08.251]   - Field: ‘owner’
[13:35:08.251]   - Field: ‘envir’
[13:35:08.251]   - Field: ‘workers’
[13:35:08.251]   - Field: ‘packages’
[13:35:08.252]   - Field: ‘gc’
[13:35:08.252]   - Field: ‘job’
[13:35:08.252]   - Field: ‘conditions’
[13:35:08.252]   - Field: ‘expr’
[13:35:08.252]   - Field: ‘uuid’
[13:35:08.252]   - Field: ‘seed’
[13:35:08.252]   - Field: ‘version’
[13:35:08.253]   - Field: ‘result’
[13:35:08.253]   - Field: ‘asynchronous’
[13:35:08.253]   - Field: ‘calls’
[13:35:08.253]   - Field: ‘globals’
[13:35:08.253]   - Field: ‘stdout’
[13:35:08.253]   - Field: ‘earlySignal’
[13:35:08.253]   - Field: ‘lazy’
[13:35:08.253]   - Field: ‘state’
[13:35:08.254] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:08.254] - Launch lazy future ...
[13:35:08.254] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:08.254] Packages needed by future strategies (n = 0): <none>
[13:35:08.255] {
[13:35:08.255]     {
[13:35:08.255]         {
[13:35:08.255]             ...future.startTime <- base::Sys.time()
[13:35:08.255]             {
[13:35:08.255]                 {
[13:35:08.255]                   {
[13:35:08.255]                     {
[13:35:08.255]                       {
[13:35:08.255]                         base::local({
[13:35:08.255]                           has_future <- base::requireNamespace("future", 
[13:35:08.255]                             quietly = TRUE)
[13:35:08.255]                           if (has_future) {
[13:35:08.255]                             ns <- base::getNamespace("future")
[13:35:08.255]                             version <- ns[[".package"]][["version"]]
[13:35:08.255]                             if (is.null(version)) 
[13:35:08.255]                               version <- utils::packageVersion("future")
[13:35:08.255]                           }
[13:35:08.255]                           else {
[13:35:08.255]                             version <- NULL
[13:35:08.255]                           }
[13:35:08.255]                           if (!has_future || version < "1.8.0") {
[13:35:08.255]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:08.255]                               "", base::R.version$version.string), 
[13:35:08.255]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:08.255]                                 base::R.version$platform, 8 * 
[13:35:08.255]                                   base::.Machine$sizeof.pointer), 
[13:35:08.255]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:08.255]                                 "release", "version")], collapse = " "), 
[13:35:08.255]                               hostname = base::Sys.info()[["nodename"]])
[13:35:08.255]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:08.255]                               info)
[13:35:08.255]                             info <- base::paste(info, collapse = "; ")
[13:35:08.255]                             if (!has_future) {
[13:35:08.255]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:08.255]                                 info)
[13:35:08.255]                             }
[13:35:08.255]                             else {
[13:35:08.255]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:08.255]                                 info, version)
[13:35:08.255]                             }
[13:35:08.255]                             base::stop(msg)
[13:35:08.255]                           }
[13:35:08.255]                         })
[13:35:08.255]                       }
[13:35:08.255]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:08.255]                       base::options(mc.cores = 1L)
[13:35:08.255]                     }
[13:35:08.255]                     base::local({
[13:35:08.255]                       for (pkg in "future.apply") {
[13:35:08.255]                         base::loadNamespace(pkg)
[13:35:08.255]                         base::library(pkg, character.only = TRUE)
[13:35:08.255]                       }
[13:35:08.255]                     })
[13:35:08.255]                   }
[13:35:08.255]                   ...future.strategy.old <- future::plan("list")
[13:35:08.255]                   options(future.plan = NULL)
[13:35:08.255]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.255]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:08.255]                 }
[13:35:08.255]                 ...future.workdir <- getwd()
[13:35:08.255]             }
[13:35:08.255]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:08.255]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:08.255]         }
[13:35:08.255]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:08.255]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:08.255]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:08.255]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:08.255]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:08.255]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:08.255]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:08.255]             base::names(...future.oldOptions))
[13:35:08.255]     }
[13:35:08.255]     if (FALSE) {
[13:35:08.255]     }
[13:35:08.255]     else {
[13:35:08.255]         if (TRUE) {
[13:35:08.255]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:08.255]                 open = "w")
[13:35:08.255]         }
[13:35:08.255]         else {
[13:35:08.255]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:08.255]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:08.255]         }
[13:35:08.255]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:08.255]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:08.255]             base::sink(type = "output", split = FALSE)
[13:35:08.255]             base::close(...future.stdout)
[13:35:08.255]         }, add = TRUE)
[13:35:08.255]     }
[13:35:08.255]     ...future.frame <- base::sys.nframe()
[13:35:08.255]     ...future.conditions <- base::list()
[13:35:08.255]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:08.255]     if (FALSE) {
[13:35:08.255]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:08.255]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:08.255]     }
[13:35:08.255]     ...future.result <- base::tryCatch({
[13:35:08.255]         base::withCallingHandlers({
[13:35:08.255]             ...future.value <- base::withVisible(base::local({
[13:35:08.255]                 withCallingHandlers({
[13:35:08.255]                   {
[13:35:08.255]                     do.call(function(...) {
[13:35:08.255]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.255]                       if (!identical(...future.globals.maxSize.org, 
[13:35:08.255]                         ...future.globals.maxSize)) {
[13:35:08.255]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.255]                         on.exit(options(oopts), add = TRUE)
[13:35:08.255]                       }
[13:35:08.255]                       {
[13:35:08.255]                         lapply(seq_along(...future.elements_ii), 
[13:35:08.255]                           FUN = function(jj) {
[13:35:08.255]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.255]                             ...future.FUN(...future.X_jj, ...)
[13:35:08.255]                           })
[13:35:08.255]                       }
[13:35:08.255]                     }, args = future.call.arguments)
[13:35:08.255]                   }
[13:35:08.255]                 }, immediateCondition = function(cond) {
[13:35:08.255]                   save_rds <- function (object, pathname, ...) 
[13:35:08.255]                   {
[13:35:08.255]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:08.255]                     if (file_test("-f", pathname_tmp)) {
[13:35:08.255]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.255]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:08.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.255]                         fi_tmp[["mtime"]])
[13:35:08.255]                     }
[13:35:08.255]                     tryCatch({
[13:35:08.255]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:08.255]                     }, error = function(ex) {
[13:35:08.255]                       msg <- conditionMessage(ex)
[13:35:08.255]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.255]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:08.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.255]                         fi_tmp[["mtime"]], msg)
[13:35:08.255]                       ex$message <- msg
[13:35:08.255]                       stop(ex)
[13:35:08.255]                     })
[13:35:08.255]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:08.255]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:08.255]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:08.255]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.255]                       fi <- file.info(pathname)
[13:35:08.255]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:08.255]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.255]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:08.255]                         fi[["size"]], fi[["mtime"]])
[13:35:08.255]                       stop(msg)
[13:35:08.255]                     }
[13:35:08.255]                     invisible(pathname)
[13:35:08.255]                   }
[13:35:08.255]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:08.255]                     rootPath = tempdir()) 
[13:35:08.255]                   {
[13:35:08.255]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:08.255]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:08.255]                       tmpdir = path, fileext = ".rds")
[13:35:08.255]                     save_rds(obj, file)
[13:35:08.255]                   }
[13:35:08.255]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:08.255]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.255]                   {
[13:35:08.255]                     inherits <- base::inherits
[13:35:08.255]                     invokeRestart <- base::invokeRestart
[13:35:08.255]                     is.null <- base::is.null
[13:35:08.255]                     muffled <- FALSE
[13:35:08.255]                     if (inherits(cond, "message")) {
[13:35:08.255]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:08.255]                       if (muffled) 
[13:35:08.255]                         invokeRestart("muffleMessage")
[13:35:08.255]                     }
[13:35:08.255]                     else if (inherits(cond, "warning")) {
[13:35:08.255]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:08.255]                       if (muffled) 
[13:35:08.255]                         invokeRestart("muffleWarning")
[13:35:08.255]                     }
[13:35:08.255]                     else if (inherits(cond, "condition")) {
[13:35:08.255]                       if (!is.null(pattern)) {
[13:35:08.255]                         computeRestarts <- base::computeRestarts
[13:35:08.255]                         grepl <- base::grepl
[13:35:08.255]                         restarts <- computeRestarts(cond)
[13:35:08.255]                         for (restart in restarts) {
[13:35:08.255]                           name <- restart$name
[13:35:08.255]                           if (is.null(name)) 
[13:35:08.255]                             next
[13:35:08.255]                           if (!grepl(pattern, name)) 
[13:35:08.255]                             next
[13:35:08.255]                           invokeRestart(restart)
[13:35:08.255]                           muffled <- TRUE
[13:35:08.255]                           break
[13:35:08.255]                         }
[13:35:08.255]                       }
[13:35:08.255]                     }
[13:35:08.255]                     invisible(muffled)
[13:35:08.255]                   }
[13:35:08.255]                   muffleCondition(cond)
[13:35:08.255]                 })
[13:35:08.255]             }))
[13:35:08.255]             future::FutureResult(value = ...future.value$value, 
[13:35:08.255]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.255]                   ...future.rng), globalenv = if (FALSE) 
[13:35:08.255]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:08.255]                     ...future.globalenv.names))
[13:35:08.255]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:08.255]         }, condition = base::local({
[13:35:08.255]             c <- base::c
[13:35:08.255]             inherits <- base::inherits
[13:35:08.255]             invokeRestart <- base::invokeRestart
[13:35:08.255]             length <- base::length
[13:35:08.255]             list <- base::list
[13:35:08.255]             seq.int <- base::seq.int
[13:35:08.255]             signalCondition <- base::signalCondition
[13:35:08.255]             sys.calls <- base::sys.calls
[13:35:08.255]             `[[` <- base::`[[`
[13:35:08.255]             `+` <- base::`+`
[13:35:08.255]             `<<-` <- base::`<<-`
[13:35:08.255]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:08.255]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:08.255]                   3L)]
[13:35:08.255]             }
[13:35:08.255]             function(cond) {
[13:35:08.255]                 is_error <- inherits(cond, "error")
[13:35:08.255]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:08.255]                   NULL)
[13:35:08.255]                 if (is_error) {
[13:35:08.255]                   sessionInformation <- function() {
[13:35:08.255]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:08.255]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:08.255]                       search = base::search(), system = base::Sys.info())
[13:35:08.255]                   }
[13:35:08.255]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.255]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:08.255]                     cond$call), session = sessionInformation(), 
[13:35:08.255]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:08.255]                   signalCondition(cond)
[13:35:08.255]                 }
[13:35:08.255]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:08.255]                 "immediateCondition"))) {
[13:35:08.255]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:08.255]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.255]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:08.255]                   if (TRUE && !signal) {
[13:35:08.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.255]                     {
[13:35:08.255]                       inherits <- base::inherits
[13:35:08.255]                       invokeRestart <- base::invokeRestart
[13:35:08.255]                       is.null <- base::is.null
[13:35:08.255]                       muffled <- FALSE
[13:35:08.255]                       if (inherits(cond, "message")) {
[13:35:08.255]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.255]                         if (muffled) 
[13:35:08.255]                           invokeRestart("muffleMessage")
[13:35:08.255]                       }
[13:35:08.255]                       else if (inherits(cond, "warning")) {
[13:35:08.255]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.255]                         if (muffled) 
[13:35:08.255]                           invokeRestart("muffleWarning")
[13:35:08.255]                       }
[13:35:08.255]                       else if (inherits(cond, "condition")) {
[13:35:08.255]                         if (!is.null(pattern)) {
[13:35:08.255]                           computeRestarts <- base::computeRestarts
[13:35:08.255]                           grepl <- base::grepl
[13:35:08.255]                           restarts <- computeRestarts(cond)
[13:35:08.255]                           for (restart in restarts) {
[13:35:08.255]                             name <- restart$name
[13:35:08.255]                             if (is.null(name)) 
[13:35:08.255]                               next
[13:35:08.255]                             if (!grepl(pattern, name)) 
[13:35:08.255]                               next
[13:35:08.255]                             invokeRestart(restart)
[13:35:08.255]                             muffled <- TRUE
[13:35:08.255]                             break
[13:35:08.255]                           }
[13:35:08.255]                         }
[13:35:08.255]                       }
[13:35:08.255]                       invisible(muffled)
[13:35:08.255]                     }
[13:35:08.255]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.255]                   }
[13:35:08.255]                 }
[13:35:08.255]                 else {
[13:35:08.255]                   if (TRUE) {
[13:35:08.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.255]                     {
[13:35:08.255]                       inherits <- base::inherits
[13:35:08.255]                       invokeRestart <- base::invokeRestart
[13:35:08.255]                       is.null <- base::is.null
[13:35:08.255]                       muffled <- FALSE
[13:35:08.255]                       if (inherits(cond, "message")) {
[13:35:08.255]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.255]                         if (muffled) 
[13:35:08.255]                           invokeRestart("muffleMessage")
[13:35:08.255]                       }
[13:35:08.255]                       else if (inherits(cond, "warning")) {
[13:35:08.255]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.255]                         if (muffled) 
[13:35:08.255]                           invokeRestart("muffleWarning")
[13:35:08.255]                       }
[13:35:08.255]                       else if (inherits(cond, "condition")) {
[13:35:08.255]                         if (!is.null(pattern)) {
[13:35:08.255]                           computeRestarts <- base::computeRestarts
[13:35:08.255]                           grepl <- base::grepl
[13:35:08.255]                           restarts <- computeRestarts(cond)
[13:35:08.255]                           for (restart in restarts) {
[13:35:08.255]                             name <- restart$name
[13:35:08.255]                             if (is.null(name)) 
[13:35:08.255]                               next
[13:35:08.255]                             if (!grepl(pattern, name)) 
[13:35:08.255]                               next
[13:35:08.255]                             invokeRestart(restart)
[13:35:08.255]                             muffled <- TRUE
[13:35:08.255]                             break
[13:35:08.255]                           }
[13:35:08.255]                         }
[13:35:08.255]                       }
[13:35:08.255]                       invisible(muffled)
[13:35:08.255]                     }
[13:35:08.255]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.255]                   }
[13:35:08.255]                 }
[13:35:08.255]             }
[13:35:08.255]         }))
[13:35:08.255]     }, error = function(ex) {
[13:35:08.255]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:08.255]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.255]                 ...future.rng), started = ...future.startTime, 
[13:35:08.255]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:08.255]             version = "1.8"), class = "FutureResult")
[13:35:08.255]     }, finally = {
[13:35:08.255]         if (!identical(...future.workdir, getwd())) 
[13:35:08.255]             setwd(...future.workdir)
[13:35:08.255]         {
[13:35:08.255]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:08.255]                 ...future.oldOptions$nwarnings <- NULL
[13:35:08.255]             }
[13:35:08.255]             base::options(...future.oldOptions)
[13:35:08.255]             if (.Platform$OS.type == "windows") {
[13:35:08.255]                 old_names <- names(...future.oldEnvVars)
[13:35:08.255]                 envs <- base::Sys.getenv()
[13:35:08.255]                 names <- names(envs)
[13:35:08.255]                 common <- intersect(names, old_names)
[13:35:08.255]                 added <- setdiff(names, old_names)
[13:35:08.255]                 removed <- setdiff(old_names, names)
[13:35:08.255]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:08.255]                   envs[common]]
[13:35:08.255]                 NAMES <- toupper(changed)
[13:35:08.255]                 args <- list()
[13:35:08.255]                 for (kk in seq_along(NAMES)) {
[13:35:08.255]                   name <- changed[[kk]]
[13:35:08.255]                   NAME <- NAMES[[kk]]
[13:35:08.255]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.255]                     next
[13:35:08.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.255]                 }
[13:35:08.255]                 NAMES <- toupper(added)
[13:35:08.255]                 for (kk in seq_along(NAMES)) {
[13:35:08.255]                   name <- added[[kk]]
[13:35:08.255]                   NAME <- NAMES[[kk]]
[13:35:08.255]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.255]                     next
[13:35:08.255]                   args[[name]] <- ""
[13:35:08.255]                 }
[13:35:08.255]                 NAMES <- toupper(removed)
[13:35:08.255]                 for (kk in seq_along(NAMES)) {
[13:35:08.255]                   name <- removed[[kk]]
[13:35:08.255]                   NAME <- NAMES[[kk]]
[13:35:08.255]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.255]                     next
[13:35:08.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.255]                 }
[13:35:08.255]                 if (length(args) > 0) 
[13:35:08.255]                   base::do.call(base::Sys.setenv, args = args)
[13:35:08.255]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:08.255]             }
[13:35:08.255]             else {
[13:35:08.255]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:08.255]             }
[13:35:08.255]             {
[13:35:08.255]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:08.255]                   0L) {
[13:35:08.255]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:08.255]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:08.255]                   base::options(opts)
[13:35:08.255]                 }
[13:35:08.255]                 {
[13:35:08.255]                   {
[13:35:08.255]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:08.255]                     NULL
[13:35:08.255]                   }
[13:35:08.255]                   options(future.plan = NULL)
[13:35:08.255]                   if (is.na(NA_character_)) 
[13:35:08.255]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.255]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:08.255]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:08.255]                     .init = FALSE)
[13:35:08.255]                 }
[13:35:08.255]             }
[13:35:08.255]         }
[13:35:08.255]     })
[13:35:08.255]     if (TRUE) {
[13:35:08.255]         base::sink(type = "output", split = FALSE)
[13:35:08.255]         if (TRUE) {
[13:35:08.255]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:08.255]         }
[13:35:08.255]         else {
[13:35:08.255]             ...future.result["stdout"] <- base::list(NULL)
[13:35:08.255]         }
[13:35:08.255]         base::close(...future.stdout)
[13:35:08.255]         ...future.stdout <- NULL
[13:35:08.255]     }
[13:35:08.255]     ...future.result$conditions <- ...future.conditions
[13:35:08.255]     ...future.result$finished <- base::Sys.time()
[13:35:08.255]     ...future.result
[13:35:08.255] }
[13:35:08.258] assign_globals() ...
[13:35:08.258] List of 11
[13:35:08.258]  $ ...future.FUN            :function (x, ...)  
[13:35:08.258]  $ x_FUN                    :function (x, y)  
[13:35:08.258]  $ times                    : int 15
[13:35:08.258]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:08.258]  $ stop_if_not              :function (...)  
[13:35:08.258]  $ dim                      : int [1:2] 3 5
[13:35:08.258]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:08.258]  $ future.call.arguments    :List of 1
[13:35:08.258]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:08.258]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.258]  $ ...future.elements_ii    :List of 2
[13:35:08.258]   ..$ C: num 70
[13:35:08.258]   ..$ D: num 80
[13:35:08.258]  $ ...future.seeds_ii       : NULL
[13:35:08.258]  $ ...future.globals.maxSize: NULL
[13:35:08.258]  - attr(*, "where")=List of 11
[13:35:08.258]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:08.258]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:08.258]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:08.258]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:08.258]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:08.258]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:08.258]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:08.258]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:08.258]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:08.258]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:08.258]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:08.258]  - attr(*, "resolved")= logi FALSE
[13:35:08.258]  - attr(*, "total_size")= num 98600
[13:35:08.258]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.258]  - attr(*, "already-done")= logi TRUE
[13:35:08.271] - copied ‘...future.FUN’ to environment
[13:35:08.271] - reassign environment for ‘x_FUN’
[13:35:08.271] - copied ‘x_FUN’ to environment
[13:35:08.271] - copied ‘times’ to environment
[13:35:08.271] - copied ‘stopf’ to environment
[13:35:08.272] - copied ‘stop_if_not’ to environment
[13:35:08.272] - copied ‘dim’ to environment
[13:35:08.272] - copied ‘valid_types’ to environment
[13:35:08.272] - copied ‘future.call.arguments’ to environment
[13:35:08.272] - copied ‘...future.elements_ii’ to environment
[13:35:08.272] - copied ‘...future.seeds_ii’ to environment
[13:35:08.272] - copied ‘...future.globals.maxSize’ to environment
[13:35:08.272] assign_globals() ... done
[13:35:08.272] requestCore(): workers = 2
[13:35:08.275] MulticoreFuture started
[13:35:08.276] - Launch lazy future ... done
[13:35:08.276] run() for ‘MulticoreFuture’ ... done
[13:35:08.277] Created future:
[13:35:08.277] plan(): Setting new future strategy stack:
[13:35:08.277] List of future strategies:
[13:35:08.277] 1. sequential:
[13:35:08.277]    - args: function (..., envir = parent.frame())
[13:35:08.277]    - tweaked: FALSE
[13:35:08.277]    - call: NULL
[13:35:08.279] plan(): nbrOfWorkers() = 1
[13:35:08.282] plan(): Setting new future strategy stack:
[13:35:08.282] List of future strategies:
[13:35:08.282] 1. multicore:
[13:35:08.282]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:08.282]    - tweaked: FALSE
[13:35:08.282]    - call: plan(strategy)
[13:35:08.288] plan(): nbrOfWorkers() = 2
[13:35:08.277] MulticoreFuture:
[13:35:08.277] Label: ‘future_vapply-2’
[13:35:08.277] Expression:
[13:35:08.277] {
[13:35:08.277]     do.call(function(...) {
[13:35:08.277]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.277]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.277]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.277]             on.exit(options(oopts), add = TRUE)
[13:35:08.277]         }
[13:35:08.277]         {
[13:35:08.277]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.277]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.277]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.277]             })
[13:35:08.277]         }
[13:35:08.277]     }, args = future.call.arguments)
[13:35:08.277] }
[13:35:08.277] Lazy evaluation: FALSE
[13:35:08.277] Asynchronous evaluation: TRUE
[13:35:08.277] Local evaluation: TRUE
[13:35:08.277] Environment: R_GlobalEnv
[13:35:08.277] Capture standard output: TRUE
[13:35:08.277] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:08.277] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:08.277] Packages: 1 packages (‘future.apply’)
[13:35:08.277] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:08.277] Resolved: TRUE
[13:35:08.277] Value: <not collected>
[13:35:08.277] Conditions captured: <none>
[13:35:08.277] Early signaling: FALSE
[13:35:08.277] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:08.277] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.289] Chunk #2 of 2 ... DONE
[13:35:08.289] Launching 2 futures (chunks) ... DONE
[13:35:08.289] Resolving 2 futures (chunks) ...
[13:35:08.289] resolve() on list ...
[13:35:08.290]  recursive: 0
[13:35:08.290]  length: 2
[13:35:08.290] 
[13:35:08.290] Future #1
[13:35:08.290] result() for MulticoreFuture ...
[13:35:08.291] result() for MulticoreFuture ...
[13:35:08.291] result() for MulticoreFuture ... done
[13:35:08.291] result() for MulticoreFuture ... done
[13:35:08.292] result() for MulticoreFuture ...
[13:35:08.292] result() for MulticoreFuture ... done
[13:35:08.292] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:08.292] - nx: 2
[13:35:08.292] - relay: TRUE
[13:35:08.293] - stdout: TRUE
[13:35:08.293] - signal: TRUE
[13:35:08.293] - resignal: FALSE
[13:35:08.293] - force: TRUE
[13:35:08.293] - relayed: [n=2] FALSE, FALSE
[13:35:08.294] - queued futures: [n=2] FALSE, FALSE
[13:35:08.294]  - until=1
[13:35:08.294]  - relaying element #1
[13:35:08.294] result() for MulticoreFuture ...
[13:35:08.294] result() for MulticoreFuture ... done
[13:35:08.294] result() for MulticoreFuture ...
[13:35:08.295] result() for MulticoreFuture ... done
[13:35:08.295] result() for MulticoreFuture ...
[13:35:08.295] result() for MulticoreFuture ... done
[13:35:08.295] result() for MulticoreFuture ...
[13:35:08.295] result() for MulticoreFuture ... done
[13:35:08.295] - relayed: [n=2] TRUE, FALSE
[13:35:08.296] - queued futures: [n=2] TRUE, FALSE
[13:35:08.296] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:08.296]  length: 1 (resolved future 1)
[13:35:08.296] Future #2
[13:35:08.296] result() for MulticoreFuture ...
[13:35:08.297] result() for MulticoreFuture ...
[13:35:08.297] result() for MulticoreFuture ... done
[13:35:08.297] result() for MulticoreFuture ... done
[13:35:08.297] result() for MulticoreFuture ...
[13:35:08.298] result() for MulticoreFuture ... done
[13:35:08.298] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:08.298] - nx: 2
[13:35:08.298] - relay: TRUE
[13:35:08.298] - stdout: TRUE
[13:35:08.298] - signal: TRUE
[13:35:08.298] - resignal: FALSE
[13:35:08.298] - force: TRUE
[13:35:08.299] - relayed: [n=2] TRUE, FALSE
[13:35:08.299] - queued futures: [n=2] TRUE, FALSE
[13:35:08.299]  - until=2
[13:35:08.299]  - relaying element #2
[13:35:08.299] result() for MulticoreFuture ...
[13:35:08.299] result() for MulticoreFuture ... done
[13:35:08.299] result() for MulticoreFuture ...
[13:35:08.299] result() for MulticoreFuture ... done
[13:35:08.300] result() for MulticoreFuture ...
[13:35:08.300] result() for MulticoreFuture ... done
[13:35:08.300] result() for MulticoreFuture ...
[13:35:08.300] result() for MulticoreFuture ... done
[13:35:08.300] - relayed: [n=2] TRUE, TRUE
[13:35:08.300] - queued futures: [n=2] TRUE, TRUE
[13:35:08.300] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:08.300]  length: 0 (resolved future 2)
[13:35:08.301] Relaying remaining futures
[13:35:08.301] signalConditionsASAP(NULL, pos=0) ...
[13:35:08.301] - nx: 2
[13:35:08.301] - relay: TRUE
[13:35:08.301] - stdout: TRUE
[13:35:08.301] - signal: TRUE
[13:35:08.301] - resignal: FALSE
[13:35:08.301] - force: TRUE
[13:35:08.301] - relayed: [n=2] TRUE, TRUE
[13:35:08.301] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:08.302] - relayed: [n=2] TRUE, TRUE
[13:35:08.302] - queued futures: [n=2] TRUE, TRUE
[13:35:08.302] signalConditionsASAP(NULL, pos=0) ... done
[13:35:08.302] resolve() on list ... DONE
[13:35:08.302] result() for MulticoreFuture ...
[13:35:08.302] result() for MulticoreFuture ... done
[13:35:08.302] result() for MulticoreFuture ...
[13:35:08.302] result() for MulticoreFuture ... done
[13:35:08.302] result() for MulticoreFuture ...
[13:35:08.303] result() for MulticoreFuture ... done
[13:35:08.303] result() for MulticoreFuture ...
[13:35:08.303] result() for MulticoreFuture ... done
[13:35:08.303]  - Number of value chunks collected: 2
[13:35:08.303] Resolving 2 futures (chunks) ... DONE
[13:35:08.303] Reducing values from 2 chunks ...
[13:35:08.303]  - Number of values collected after concatenation: 4
[13:35:08.303]  - Number of values expected: 4
[13:35:08.303] Reducing values from 2 chunks ... DONE
[13:35:08.304] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[13:35:08.306] future_lapply() ...
[13:35:08.315] Number of chunks: 2
[13:35:08.315] getGlobalsAndPackagesXApply() ...
[13:35:08.315]  - future.globals: TRUE
[13:35:08.316] getGlobalsAndPackages() ...
[13:35:08.316] Searching for globals...
[13:35:08.320] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:08.320] Searching for globals ... DONE
[13:35:08.320] Resolving globals: FALSE
[13:35:08.321] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[13:35:08.321] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:08.321] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:08.321] - packages: [1] ‘future.apply’
[13:35:08.322] getGlobalsAndPackages() ... DONE
[13:35:08.322]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:08.322]  - needed namespaces: [n=1] ‘future.apply’
[13:35:08.322] Finding globals ... DONE
[13:35:08.322]  - use_args: TRUE
[13:35:08.322]  - Getting '...' globals ...
[13:35:08.322] resolve() on list ...
[13:35:08.322]  recursive: 0
[13:35:08.323]  length: 1
[13:35:08.323]  elements: ‘...’
[13:35:08.323]  length: 0 (resolved future 1)
[13:35:08.323] resolve() on list ... DONE
[13:35:08.323]    - '...' content: [n=0] 
[13:35:08.323] List of 1
[13:35:08.323]  $ ...: list()
[13:35:08.323]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.323]  - attr(*, "where")=List of 1
[13:35:08.323]   ..$ ...:<environment: 0x5574d09188e8> 
[13:35:08.323]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.323]  - attr(*, "resolved")= logi TRUE
[13:35:08.323]  - attr(*, "total_size")= num NA
[13:35:08.326]  - Getting '...' globals ... DONE
[13:35:08.326] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:08.326] List of 8
[13:35:08.326]  $ ...future.FUN:function (x, ...)  
[13:35:08.326]  $ x_FUN        :function (x)  
[13:35:08.326]  $ times        : int 1
[13:35:08.326]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:08.326]  $ stop_if_not  :function (...)  
[13:35:08.326]  $ dim          : NULL
[13:35:08.326]  $ valid_types  : chr "logical"
[13:35:08.326]  $ ...          : list()
[13:35:08.326]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.326]  - attr(*, "where")=List of 8
[13:35:08.326]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:08.326]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:08.326]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:08.326]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:08.326]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:08.326]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:08.326]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:08.326]   ..$ ...          :<environment: 0x5574d09188e8> 
[13:35:08.326]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.326]  - attr(*, "resolved")= logi FALSE
[13:35:08.326]  - attr(*, "total_size")= num 94200
[13:35:08.334] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:08.334] getGlobalsAndPackagesXApply() ... DONE
[13:35:08.334] Number of futures (= number of chunks): 2
[13:35:08.334] Launching 2 futures (chunks) ...
[13:35:08.334] Chunk #1 of 2 ...
[13:35:08.335]  - Finding globals in 'X' for chunk #1 ...
[13:35:08.335] getGlobalsAndPackages() ...
[13:35:08.335] Searching for globals...
[13:35:08.335] 
[13:35:08.335] Searching for globals ... DONE
[13:35:08.335] - globals: [0] <none>
[13:35:08.335] getGlobalsAndPackages() ... DONE
[13:35:08.336]    + additional globals found: [n=0] 
[13:35:08.336]    + additional namespaces needed: [n=0] 
[13:35:08.336]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:08.336]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:08.336]  - seeds: <none>
[13:35:08.336]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.336] getGlobalsAndPackages() ...
[13:35:08.336] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.336] Resolving globals: FALSE
[13:35:08.337] Tweak future expression to call with '...' arguments ...
[13:35:08.337] {
[13:35:08.337]     do.call(function(...) {
[13:35:08.337]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.337]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.337]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.337]             on.exit(options(oopts), add = TRUE)
[13:35:08.337]         }
[13:35:08.337]         {
[13:35:08.337]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.337]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.337]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.337]             })
[13:35:08.337]         }
[13:35:08.337]     }, args = future.call.arguments)
[13:35:08.337] }
[13:35:08.337] Tweak future expression to call with '...' arguments ... DONE
[13:35:08.337] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.338] - packages: [1] ‘future.apply’
[13:35:08.338] getGlobalsAndPackages() ... DONE
[13:35:08.338] run() for ‘Future’ ...
[13:35:08.338] - state: ‘created’
[13:35:08.338] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:08.342] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.342] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:08.343]   - Field: ‘label’
[13:35:08.343]   - Field: ‘local’
[13:35:08.343]   - Field: ‘owner’
[13:35:08.343]   - Field: ‘envir’
[13:35:08.343]   - Field: ‘workers’
[13:35:08.343]   - Field: ‘packages’
[13:35:08.343]   - Field: ‘gc’
[13:35:08.343]   - Field: ‘job’
[13:35:08.344]   - Field: ‘conditions’
[13:35:08.344]   - Field: ‘expr’
[13:35:08.344]   - Field: ‘uuid’
[13:35:08.344]   - Field: ‘seed’
[13:35:08.344]   - Field: ‘version’
[13:35:08.344]   - Field: ‘result’
[13:35:08.344]   - Field: ‘asynchronous’
[13:35:08.344]   - Field: ‘calls’
[13:35:08.344]   - Field: ‘globals’
[13:35:08.345]   - Field: ‘stdout’
[13:35:08.345]   - Field: ‘earlySignal’
[13:35:08.345]   - Field: ‘lazy’
[13:35:08.345]   - Field: ‘state’
[13:35:08.345] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:08.345] - Launch lazy future ...
[13:35:08.345] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:08.345] Packages needed by future strategies (n = 0): <none>
[13:35:08.346] {
[13:35:08.346]     {
[13:35:08.346]         {
[13:35:08.346]             ...future.startTime <- base::Sys.time()
[13:35:08.346]             {
[13:35:08.346]                 {
[13:35:08.346]                   {
[13:35:08.346]                     {
[13:35:08.346]                       {
[13:35:08.346]                         base::local({
[13:35:08.346]                           has_future <- base::requireNamespace("future", 
[13:35:08.346]                             quietly = TRUE)
[13:35:08.346]                           if (has_future) {
[13:35:08.346]                             ns <- base::getNamespace("future")
[13:35:08.346]                             version <- ns[[".package"]][["version"]]
[13:35:08.346]                             if (is.null(version)) 
[13:35:08.346]                               version <- utils::packageVersion("future")
[13:35:08.346]                           }
[13:35:08.346]                           else {
[13:35:08.346]                             version <- NULL
[13:35:08.346]                           }
[13:35:08.346]                           if (!has_future || version < "1.8.0") {
[13:35:08.346]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:08.346]                               "", base::R.version$version.string), 
[13:35:08.346]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:08.346]                                 base::R.version$platform, 8 * 
[13:35:08.346]                                   base::.Machine$sizeof.pointer), 
[13:35:08.346]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:08.346]                                 "release", "version")], collapse = " "), 
[13:35:08.346]                               hostname = base::Sys.info()[["nodename"]])
[13:35:08.346]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:08.346]                               info)
[13:35:08.346]                             info <- base::paste(info, collapse = "; ")
[13:35:08.346]                             if (!has_future) {
[13:35:08.346]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:08.346]                                 info)
[13:35:08.346]                             }
[13:35:08.346]                             else {
[13:35:08.346]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:08.346]                                 info, version)
[13:35:08.346]                             }
[13:35:08.346]                             base::stop(msg)
[13:35:08.346]                           }
[13:35:08.346]                         })
[13:35:08.346]                       }
[13:35:08.346]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:08.346]                       base::options(mc.cores = 1L)
[13:35:08.346]                     }
[13:35:08.346]                     base::local({
[13:35:08.346]                       for (pkg in "future.apply") {
[13:35:08.346]                         base::loadNamespace(pkg)
[13:35:08.346]                         base::library(pkg, character.only = TRUE)
[13:35:08.346]                       }
[13:35:08.346]                     })
[13:35:08.346]                   }
[13:35:08.346]                   ...future.strategy.old <- future::plan("list")
[13:35:08.346]                   options(future.plan = NULL)
[13:35:08.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:08.346]                 }
[13:35:08.346]                 ...future.workdir <- getwd()
[13:35:08.346]             }
[13:35:08.346]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:08.346]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:08.346]         }
[13:35:08.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:08.346]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:08.346]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:08.346]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:08.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:08.346]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:08.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:08.346]             base::names(...future.oldOptions))
[13:35:08.346]     }
[13:35:08.346]     if (FALSE) {
[13:35:08.346]     }
[13:35:08.346]     else {
[13:35:08.346]         if (TRUE) {
[13:35:08.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:08.346]                 open = "w")
[13:35:08.346]         }
[13:35:08.346]         else {
[13:35:08.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:08.346]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:08.346]         }
[13:35:08.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:08.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:08.346]             base::sink(type = "output", split = FALSE)
[13:35:08.346]             base::close(...future.stdout)
[13:35:08.346]         }, add = TRUE)
[13:35:08.346]     }
[13:35:08.346]     ...future.frame <- base::sys.nframe()
[13:35:08.346]     ...future.conditions <- base::list()
[13:35:08.346]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:08.346]     if (FALSE) {
[13:35:08.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:08.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:08.346]     }
[13:35:08.346]     ...future.result <- base::tryCatch({
[13:35:08.346]         base::withCallingHandlers({
[13:35:08.346]             ...future.value <- base::withVisible(base::local({
[13:35:08.346]                 withCallingHandlers({
[13:35:08.346]                   {
[13:35:08.346]                     do.call(function(...) {
[13:35:08.346]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.346]                       if (!identical(...future.globals.maxSize.org, 
[13:35:08.346]                         ...future.globals.maxSize)) {
[13:35:08.346]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.346]                         on.exit(options(oopts), add = TRUE)
[13:35:08.346]                       }
[13:35:08.346]                       {
[13:35:08.346]                         lapply(seq_along(...future.elements_ii), 
[13:35:08.346]                           FUN = function(jj) {
[13:35:08.346]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.346]                             ...future.FUN(...future.X_jj, ...)
[13:35:08.346]                           })
[13:35:08.346]                       }
[13:35:08.346]                     }, args = future.call.arguments)
[13:35:08.346]                   }
[13:35:08.346]                 }, immediateCondition = function(cond) {
[13:35:08.346]                   save_rds <- function (object, pathname, ...) 
[13:35:08.346]                   {
[13:35:08.346]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:08.346]                     if (file_test("-f", pathname_tmp)) {
[13:35:08.346]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.346]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:08.346]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.346]                         fi_tmp[["mtime"]])
[13:35:08.346]                     }
[13:35:08.346]                     tryCatch({
[13:35:08.346]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:08.346]                     }, error = function(ex) {
[13:35:08.346]                       msg <- conditionMessage(ex)
[13:35:08.346]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.346]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:08.346]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.346]                         fi_tmp[["mtime"]], msg)
[13:35:08.346]                       ex$message <- msg
[13:35:08.346]                       stop(ex)
[13:35:08.346]                     })
[13:35:08.346]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:08.346]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:08.346]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:08.346]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.346]                       fi <- file.info(pathname)
[13:35:08.346]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:08.346]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.346]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:08.346]                         fi[["size"]], fi[["mtime"]])
[13:35:08.346]                       stop(msg)
[13:35:08.346]                     }
[13:35:08.346]                     invisible(pathname)
[13:35:08.346]                   }
[13:35:08.346]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:08.346]                     rootPath = tempdir()) 
[13:35:08.346]                   {
[13:35:08.346]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:08.346]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:08.346]                       tmpdir = path, fileext = ".rds")
[13:35:08.346]                     save_rds(obj, file)
[13:35:08.346]                   }
[13:35:08.346]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:08.346]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.346]                   {
[13:35:08.346]                     inherits <- base::inherits
[13:35:08.346]                     invokeRestart <- base::invokeRestart
[13:35:08.346]                     is.null <- base::is.null
[13:35:08.346]                     muffled <- FALSE
[13:35:08.346]                     if (inherits(cond, "message")) {
[13:35:08.346]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:08.346]                       if (muffled) 
[13:35:08.346]                         invokeRestart("muffleMessage")
[13:35:08.346]                     }
[13:35:08.346]                     else if (inherits(cond, "warning")) {
[13:35:08.346]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:08.346]                       if (muffled) 
[13:35:08.346]                         invokeRestart("muffleWarning")
[13:35:08.346]                     }
[13:35:08.346]                     else if (inherits(cond, "condition")) {
[13:35:08.346]                       if (!is.null(pattern)) {
[13:35:08.346]                         computeRestarts <- base::computeRestarts
[13:35:08.346]                         grepl <- base::grepl
[13:35:08.346]                         restarts <- computeRestarts(cond)
[13:35:08.346]                         for (restart in restarts) {
[13:35:08.346]                           name <- restart$name
[13:35:08.346]                           if (is.null(name)) 
[13:35:08.346]                             next
[13:35:08.346]                           if (!grepl(pattern, name)) 
[13:35:08.346]                             next
[13:35:08.346]                           invokeRestart(restart)
[13:35:08.346]                           muffled <- TRUE
[13:35:08.346]                           break
[13:35:08.346]                         }
[13:35:08.346]                       }
[13:35:08.346]                     }
[13:35:08.346]                     invisible(muffled)
[13:35:08.346]                   }
[13:35:08.346]                   muffleCondition(cond)
[13:35:08.346]                 })
[13:35:08.346]             }))
[13:35:08.346]             future::FutureResult(value = ...future.value$value, 
[13:35:08.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.346]                   ...future.rng), globalenv = if (FALSE) 
[13:35:08.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:08.346]                     ...future.globalenv.names))
[13:35:08.346]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:08.346]         }, condition = base::local({
[13:35:08.346]             c <- base::c
[13:35:08.346]             inherits <- base::inherits
[13:35:08.346]             invokeRestart <- base::invokeRestart
[13:35:08.346]             length <- base::length
[13:35:08.346]             list <- base::list
[13:35:08.346]             seq.int <- base::seq.int
[13:35:08.346]             signalCondition <- base::signalCondition
[13:35:08.346]             sys.calls <- base::sys.calls
[13:35:08.346]             `[[` <- base::`[[`
[13:35:08.346]             `+` <- base::`+`
[13:35:08.346]             `<<-` <- base::`<<-`
[13:35:08.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:08.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:08.346]                   3L)]
[13:35:08.346]             }
[13:35:08.346]             function(cond) {
[13:35:08.346]                 is_error <- inherits(cond, "error")
[13:35:08.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:08.346]                   NULL)
[13:35:08.346]                 if (is_error) {
[13:35:08.346]                   sessionInformation <- function() {
[13:35:08.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:08.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:08.346]                       search = base::search(), system = base::Sys.info())
[13:35:08.346]                   }
[13:35:08.346]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:08.346]                     cond$call), session = sessionInformation(), 
[13:35:08.346]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:08.346]                   signalCondition(cond)
[13:35:08.346]                 }
[13:35:08.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:08.346]                 "immediateCondition"))) {
[13:35:08.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:08.346]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:08.346]                   if (TRUE && !signal) {
[13:35:08.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.346]                     {
[13:35:08.346]                       inherits <- base::inherits
[13:35:08.346]                       invokeRestart <- base::invokeRestart
[13:35:08.346]                       is.null <- base::is.null
[13:35:08.346]                       muffled <- FALSE
[13:35:08.346]                       if (inherits(cond, "message")) {
[13:35:08.346]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.346]                         if (muffled) 
[13:35:08.346]                           invokeRestart("muffleMessage")
[13:35:08.346]                       }
[13:35:08.346]                       else if (inherits(cond, "warning")) {
[13:35:08.346]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.346]                         if (muffled) 
[13:35:08.346]                           invokeRestart("muffleWarning")
[13:35:08.346]                       }
[13:35:08.346]                       else if (inherits(cond, "condition")) {
[13:35:08.346]                         if (!is.null(pattern)) {
[13:35:08.346]                           computeRestarts <- base::computeRestarts
[13:35:08.346]                           grepl <- base::grepl
[13:35:08.346]                           restarts <- computeRestarts(cond)
[13:35:08.346]                           for (restart in restarts) {
[13:35:08.346]                             name <- restart$name
[13:35:08.346]                             if (is.null(name)) 
[13:35:08.346]                               next
[13:35:08.346]                             if (!grepl(pattern, name)) 
[13:35:08.346]                               next
[13:35:08.346]                             invokeRestart(restart)
[13:35:08.346]                             muffled <- TRUE
[13:35:08.346]                             break
[13:35:08.346]                           }
[13:35:08.346]                         }
[13:35:08.346]                       }
[13:35:08.346]                       invisible(muffled)
[13:35:08.346]                     }
[13:35:08.346]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.346]                   }
[13:35:08.346]                 }
[13:35:08.346]                 else {
[13:35:08.346]                   if (TRUE) {
[13:35:08.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.346]                     {
[13:35:08.346]                       inherits <- base::inherits
[13:35:08.346]                       invokeRestart <- base::invokeRestart
[13:35:08.346]                       is.null <- base::is.null
[13:35:08.346]                       muffled <- FALSE
[13:35:08.346]                       if (inherits(cond, "message")) {
[13:35:08.346]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.346]                         if (muffled) 
[13:35:08.346]                           invokeRestart("muffleMessage")
[13:35:08.346]                       }
[13:35:08.346]                       else if (inherits(cond, "warning")) {
[13:35:08.346]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.346]                         if (muffled) 
[13:35:08.346]                           invokeRestart("muffleWarning")
[13:35:08.346]                       }
[13:35:08.346]                       else if (inherits(cond, "condition")) {
[13:35:08.346]                         if (!is.null(pattern)) {
[13:35:08.346]                           computeRestarts <- base::computeRestarts
[13:35:08.346]                           grepl <- base::grepl
[13:35:08.346]                           restarts <- computeRestarts(cond)
[13:35:08.346]                           for (restart in restarts) {
[13:35:08.346]                             name <- restart$name
[13:35:08.346]                             if (is.null(name)) 
[13:35:08.346]                               next
[13:35:08.346]                             if (!grepl(pattern, name)) 
[13:35:08.346]                               next
[13:35:08.346]                             invokeRestart(restart)
[13:35:08.346]                             muffled <- TRUE
[13:35:08.346]                             break
[13:35:08.346]                           }
[13:35:08.346]                         }
[13:35:08.346]                       }
[13:35:08.346]                       invisible(muffled)
[13:35:08.346]                     }
[13:35:08.346]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.346]                   }
[13:35:08.346]                 }
[13:35:08.346]             }
[13:35:08.346]         }))
[13:35:08.346]     }, error = function(ex) {
[13:35:08.346]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:08.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.346]                 ...future.rng), started = ...future.startTime, 
[13:35:08.346]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:08.346]             version = "1.8"), class = "FutureResult")
[13:35:08.346]     }, finally = {
[13:35:08.346]         if (!identical(...future.workdir, getwd())) 
[13:35:08.346]             setwd(...future.workdir)
[13:35:08.346]         {
[13:35:08.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:08.346]                 ...future.oldOptions$nwarnings <- NULL
[13:35:08.346]             }
[13:35:08.346]             base::options(...future.oldOptions)
[13:35:08.346]             if (.Platform$OS.type == "windows") {
[13:35:08.346]                 old_names <- names(...future.oldEnvVars)
[13:35:08.346]                 envs <- base::Sys.getenv()
[13:35:08.346]                 names <- names(envs)
[13:35:08.346]                 common <- intersect(names, old_names)
[13:35:08.346]                 added <- setdiff(names, old_names)
[13:35:08.346]                 removed <- setdiff(old_names, names)
[13:35:08.346]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:08.346]                   envs[common]]
[13:35:08.346]                 NAMES <- toupper(changed)
[13:35:08.346]                 args <- list()
[13:35:08.346]                 for (kk in seq_along(NAMES)) {
[13:35:08.346]                   name <- changed[[kk]]
[13:35:08.346]                   NAME <- NAMES[[kk]]
[13:35:08.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.346]                     next
[13:35:08.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.346]                 }
[13:35:08.346]                 NAMES <- toupper(added)
[13:35:08.346]                 for (kk in seq_along(NAMES)) {
[13:35:08.346]                   name <- added[[kk]]
[13:35:08.346]                   NAME <- NAMES[[kk]]
[13:35:08.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.346]                     next
[13:35:08.346]                   args[[name]] <- ""
[13:35:08.346]                 }
[13:35:08.346]                 NAMES <- toupper(removed)
[13:35:08.346]                 for (kk in seq_along(NAMES)) {
[13:35:08.346]                   name <- removed[[kk]]
[13:35:08.346]                   NAME <- NAMES[[kk]]
[13:35:08.346]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.346]                     next
[13:35:08.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.346]                 }
[13:35:08.346]                 if (length(args) > 0) 
[13:35:08.346]                   base::do.call(base::Sys.setenv, args = args)
[13:35:08.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:08.346]             }
[13:35:08.346]             else {
[13:35:08.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:08.346]             }
[13:35:08.346]             {
[13:35:08.346]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:08.346]                   0L) {
[13:35:08.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:08.346]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:08.346]                   base::options(opts)
[13:35:08.346]                 }
[13:35:08.346]                 {
[13:35:08.346]                   {
[13:35:08.346]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:08.346]                     NULL
[13:35:08.346]                   }
[13:35:08.346]                   options(future.plan = NULL)
[13:35:08.346]                   if (is.na(NA_character_)) 
[13:35:08.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:08.346]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:08.346]                     .init = FALSE)
[13:35:08.346]                 }
[13:35:08.346]             }
[13:35:08.346]         }
[13:35:08.346]     })
[13:35:08.346]     if (TRUE) {
[13:35:08.346]         base::sink(type = "output", split = FALSE)
[13:35:08.346]         if (TRUE) {
[13:35:08.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:08.346]         }
[13:35:08.346]         else {
[13:35:08.346]             ...future.result["stdout"] <- base::list(NULL)
[13:35:08.346]         }
[13:35:08.346]         base::close(...future.stdout)
[13:35:08.346]         ...future.stdout <- NULL
[13:35:08.346]     }
[13:35:08.346]     ...future.result$conditions <- ...future.conditions
[13:35:08.346]     ...future.result$finished <- base::Sys.time()
[13:35:08.346]     ...future.result
[13:35:08.346] }
[13:35:08.349] assign_globals() ...
[13:35:08.349] List of 11
[13:35:08.349]  $ ...future.FUN            :function (x, ...)  
[13:35:08.349]  $ x_FUN                    :function (x)  
[13:35:08.349]  $ times                    : int 1
[13:35:08.349]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:08.349]  $ stop_if_not              :function (...)  
[13:35:08.349]  $ dim                      : NULL
[13:35:08.349]  $ valid_types              : chr "logical"
[13:35:08.349]  $ future.call.arguments    : list()
[13:35:08.349]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.349]  $ ...future.elements_ii    :List of 6
[13:35:08.349]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[13:35:08.349]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[13:35:08.349]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[13:35:08.349]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[13:35:08.349]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[13:35:08.349]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[13:35:08.349]  $ ...future.seeds_ii       : NULL
[13:35:08.349]  $ ...future.globals.maxSize: NULL
[13:35:08.349]  - attr(*, "where")=List of 11
[13:35:08.349]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:08.349]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:08.349]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:08.349]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:08.349]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:08.349]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:08.349]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:08.349]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:08.349]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:08.349]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:08.349]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:08.349]  - attr(*, "resolved")= logi FALSE
[13:35:08.349]  - attr(*, "total_size")= num 94200
[13:35:08.349]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.349]  - attr(*, "already-done")= logi TRUE
[13:35:08.360] - copied ‘...future.FUN’ to environment
[13:35:08.360] - copied ‘x_FUN’ to environment
[13:35:08.360] - copied ‘times’ to environment
[13:35:08.360] - copied ‘stopf’ to environment
[13:35:08.361] - copied ‘stop_if_not’ to environment
[13:35:08.361] - copied ‘dim’ to environment
[13:35:08.361] - copied ‘valid_types’ to environment
[13:35:08.361] - copied ‘future.call.arguments’ to environment
[13:35:08.361] - copied ‘...future.elements_ii’ to environment
[13:35:08.361] - copied ‘...future.seeds_ii’ to environment
[13:35:08.361] - copied ‘...future.globals.maxSize’ to environment
[13:35:08.361] assign_globals() ... done
[13:35:08.361] requestCore(): workers = 2
[13:35:08.364] MulticoreFuture started
[13:35:08.364] - Launch lazy future ... done
[13:35:08.365] run() for ‘MulticoreFuture’ ... done
[13:35:08.365] Created future:
[13:35:08.366] plan(): Setting new future strategy stack:
[13:35:08.366] List of future strategies:
[13:35:08.366] 1. sequential:
[13:35:08.366]    - args: function (..., envir = parent.frame())
[13:35:08.366]    - tweaked: FALSE
[13:35:08.366]    - call: NULL
[13:35:08.368] plan(): nbrOfWorkers() = 1
[13:35:08.370] plan(): Setting new future strategy stack:
[13:35:08.370] List of future strategies:
[13:35:08.370] 1. multicore:
[13:35:08.370]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:08.370]    - tweaked: FALSE
[13:35:08.370]    - call: plan(strategy)
[13:35:08.376] plan(): nbrOfWorkers() = 2
[13:35:08.366] MulticoreFuture:
[13:35:08.366] Label: ‘future_vapply-1’
[13:35:08.366] Expression:
[13:35:08.366] {
[13:35:08.366]     do.call(function(...) {
[13:35:08.366]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.366]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.366]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.366]             on.exit(options(oopts), add = TRUE)
[13:35:08.366]         }
[13:35:08.366]         {
[13:35:08.366]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.366]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.366]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.366]             })
[13:35:08.366]         }
[13:35:08.366]     }, args = future.call.arguments)
[13:35:08.366] }
[13:35:08.366] Lazy evaluation: FALSE
[13:35:08.366] Asynchronous evaluation: TRUE
[13:35:08.366] Local evaluation: TRUE
[13:35:08.366] Environment: R_GlobalEnv
[13:35:08.366] Capture standard output: TRUE
[13:35:08.366] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:08.366] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:08.366] Packages: 1 packages (‘future.apply’)
[13:35:08.366] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:08.366] Resolved: TRUE
[13:35:08.366] Value: <not collected>
[13:35:08.366] Conditions captured: <none>
[13:35:08.366] Early signaling: FALSE
[13:35:08.366] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:08.366] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.377] Chunk #1 of 2 ... DONE
[13:35:08.378] Chunk #2 of 2 ...
[13:35:08.378]  - Finding globals in 'X' for chunk #2 ...
[13:35:08.378] getGlobalsAndPackages() ...
[13:35:08.378] Searching for globals...
[13:35:08.379] 
[13:35:08.379] Searching for globals ... DONE
[13:35:08.379] - globals: [0] <none>
[13:35:08.379] getGlobalsAndPackages() ... DONE
[13:35:08.379]    + additional globals found: [n=0] 
[13:35:08.380]    + additional namespaces needed: [n=0] 
[13:35:08.380]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:08.380]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:08.380]  - seeds: <none>
[13:35:08.380]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.380] getGlobalsAndPackages() ...
[13:35:08.381] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.381] Resolving globals: FALSE
[13:35:08.381] Tweak future expression to call with '...' arguments ...
[13:35:08.381] {
[13:35:08.381]     do.call(function(...) {
[13:35:08.381]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.381]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.381]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.381]             on.exit(options(oopts), add = TRUE)
[13:35:08.381]         }
[13:35:08.381]         {
[13:35:08.381]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.381]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.381]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.381]             })
[13:35:08.381]         }
[13:35:08.381]     }, args = future.call.arguments)
[13:35:08.381] }
[13:35:08.382] Tweak future expression to call with '...' arguments ... DONE
[13:35:08.383] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.383] - packages: [1] ‘future.apply’
[13:35:08.383] getGlobalsAndPackages() ... DONE
[13:35:08.384] run() for ‘Future’ ...
[13:35:08.384] - state: ‘created’
[13:35:08.384] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:08.389] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.389] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:08.389]   - Field: ‘label’
[13:35:08.389]   - Field: ‘local’
[13:35:08.389]   - Field: ‘owner’
[13:35:08.389]   - Field: ‘envir’
[13:35:08.390]   - Field: ‘workers’
[13:35:08.390]   - Field: ‘packages’
[13:35:08.390]   - Field: ‘gc’
[13:35:08.390]   - Field: ‘job’
[13:35:08.390]   - Field: ‘conditions’
[13:35:08.390]   - Field: ‘expr’
[13:35:08.391]   - Field: ‘uuid’
[13:35:08.391]   - Field: ‘seed’
[13:35:08.391]   - Field: ‘version’
[13:35:08.391]   - Field: ‘result’
[13:35:08.391]   - Field: ‘asynchronous’
[13:35:08.391]   - Field: ‘calls’
[13:35:08.391]   - Field: ‘globals’
[13:35:08.391]   - Field: ‘stdout’
[13:35:08.392]   - Field: ‘earlySignal’
[13:35:08.392]   - Field: ‘lazy’
[13:35:08.392]   - Field: ‘state’
[13:35:08.392] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:08.392] - Launch lazy future ...
[13:35:08.393] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:08.393] Packages needed by future strategies (n = 0): <none>
[13:35:08.394] {
[13:35:08.394]     {
[13:35:08.394]         {
[13:35:08.394]             ...future.startTime <- base::Sys.time()
[13:35:08.394]             {
[13:35:08.394]                 {
[13:35:08.394]                   {
[13:35:08.394]                     {
[13:35:08.394]                       {
[13:35:08.394]                         base::local({
[13:35:08.394]                           has_future <- base::requireNamespace("future", 
[13:35:08.394]                             quietly = TRUE)
[13:35:08.394]                           if (has_future) {
[13:35:08.394]                             ns <- base::getNamespace("future")
[13:35:08.394]                             version <- ns[[".package"]][["version"]]
[13:35:08.394]                             if (is.null(version)) 
[13:35:08.394]                               version <- utils::packageVersion("future")
[13:35:08.394]                           }
[13:35:08.394]                           else {
[13:35:08.394]                             version <- NULL
[13:35:08.394]                           }
[13:35:08.394]                           if (!has_future || version < "1.8.0") {
[13:35:08.394]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:08.394]                               "", base::R.version$version.string), 
[13:35:08.394]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:08.394]                                 base::R.version$platform, 8 * 
[13:35:08.394]                                   base::.Machine$sizeof.pointer), 
[13:35:08.394]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:08.394]                                 "release", "version")], collapse = " "), 
[13:35:08.394]                               hostname = base::Sys.info()[["nodename"]])
[13:35:08.394]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:08.394]                               info)
[13:35:08.394]                             info <- base::paste(info, collapse = "; ")
[13:35:08.394]                             if (!has_future) {
[13:35:08.394]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:08.394]                                 info)
[13:35:08.394]                             }
[13:35:08.394]                             else {
[13:35:08.394]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:08.394]                                 info, version)
[13:35:08.394]                             }
[13:35:08.394]                             base::stop(msg)
[13:35:08.394]                           }
[13:35:08.394]                         })
[13:35:08.394]                       }
[13:35:08.394]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:08.394]                       base::options(mc.cores = 1L)
[13:35:08.394]                     }
[13:35:08.394]                     base::local({
[13:35:08.394]                       for (pkg in "future.apply") {
[13:35:08.394]                         base::loadNamespace(pkg)
[13:35:08.394]                         base::library(pkg, character.only = TRUE)
[13:35:08.394]                       }
[13:35:08.394]                     })
[13:35:08.394]                   }
[13:35:08.394]                   ...future.strategy.old <- future::plan("list")
[13:35:08.394]                   options(future.plan = NULL)
[13:35:08.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:08.394]                 }
[13:35:08.394]                 ...future.workdir <- getwd()
[13:35:08.394]             }
[13:35:08.394]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:08.394]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:08.394]         }
[13:35:08.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:08.394]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:08.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:08.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:08.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:08.394]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:08.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:08.394]             base::names(...future.oldOptions))
[13:35:08.394]     }
[13:35:08.394]     if (FALSE) {
[13:35:08.394]     }
[13:35:08.394]     else {
[13:35:08.394]         if (TRUE) {
[13:35:08.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:08.394]                 open = "w")
[13:35:08.394]         }
[13:35:08.394]         else {
[13:35:08.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:08.394]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:08.394]         }
[13:35:08.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:08.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:08.394]             base::sink(type = "output", split = FALSE)
[13:35:08.394]             base::close(...future.stdout)
[13:35:08.394]         }, add = TRUE)
[13:35:08.394]     }
[13:35:08.394]     ...future.frame <- base::sys.nframe()
[13:35:08.394]     ...future.conditions <- base::list()
[13:35:08.394]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:08.394]     if (FALSE) {
[13:35:08.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:08.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:08.394]     }
[13:35:08.394]     ...future.result <- base::tryCatch({
[13:35:08.394]         base::withCallingHandlers({
[13:35:08.394]             ...future.value <- base::withVisible(base::local({
[13:35:08.394]                 withCallingHandlers({
[13:35:08.394]                   {
[13:35:08.394]                     do.call(function(...) {
[13:35:08.394]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.394]                       if (!identical(...future.globals.maxSize.org, 
[13:35:08.394]                         ...future.globals.maxSize)) {
[13:35:08.394]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.394]                         on.exit(options(oopts), add = TRUE)
[13:35:08.394]                       }
[13:35:08.394]                       {
[13:35:08.394]                         lapply(seq_along(...future.elements_ii), 
[13:35:08.394]                           FUN = function(jj) {
[13:35:08.394]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.394]                             ...future.FUN(...future.X_jj, ...)
[13:35:08.394]                           })
[13:35:08.394]                       }
[13:35:08.394]                     }, args = future.call.arguments)
[13:35:08.394]                   }
[13:35:08.394]                 }, immediateCondition = function(cond) {
[13:35:08.394]                   save_rds <- function (object, pathname, ...) 
[13:35:08.394]                   {
[13:35:08.394]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:08.394]                     if (file_test("-f", pathname_tmp)) {
[13:35:08.394]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.394]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:08.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.394]                         fi_tmp[["mtime"]])
[13:35:08.394]                     }
[13:35:08.394]                     tryCatch({
[13:35:08.394]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:08.394]                     }, error = function(ex) {
[13:35:08.394]                       msg <- conditionMessage(ex)
[13:35:08.394]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.394]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:08.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.394]                         fi_tmp[["mtime"]], msg)
[13:35:08.394]                       ex$message <- msg
[13:35:08.394]                       stop(ex)
[13:35:08.394]                     })
[13:35:08.394]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:08.394]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:08.394]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:08.394]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.394]                       fi <- file.info(pathname)
[13:35:08.394]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:08.394]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.394]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:08.394]                         fi[["size"]], fi[["mtime"]])
[13:35:08.394]                       stop(msg)
[13:35:08.394]                     }
[13:35:08.394]                     invisible(pathname)
[13:35:08.394]                   }
[13:35:08.394]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:08.394]                     rootPath = tempdir()) 
[13:35:08.394]                   {
[13:35:08.394]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:08.394]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:08.394]                       tmpdir = path, fileext = ".rds")
[13:35:08.394]                     save_rds(obj, file)
[13:35:08.394]                   }
[13:35:08.394]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:08.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.394]                   {
[13:35:08.394]                     inherits <- base::inherits
[13:35:08.394]                     invokeRestart <- base::invokeRestart
[13:35:08.394]                     is.null <- base::is.null
[13:35:08.394]                     muffled <- FALSE
[13:35:08.394]                     if (inherits(cond, "message")) {
[13:35:08.394]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:08.394]                       if (muffled) 
[13:35:08.394]                         invokeRestart("muffleMessage")
[13:35:08.394]                     }
[13:35:08.394]                     else if (inherits(cond, "warning")) {
[13:35:08.394]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:08.394]                       if (muffled) 
[13:35:08.394]                         invokeRestart("muffleWarning")
[13:35:08.394]                     }
[13:35:08.394]                     else if (inherits(cond, "condition")) {
[13:35:08.394]                       if (!is.null(pattern)) {
[13:35:08.394]                         computeRestarts <- base::computeRestarts
[13:35:08.394]                         grepl <- base::grepl
[13:35:08.394]                         restarts <- computeRestarts(cond)
[13:35:08.394]                         for (restart in restarts) {
[13:35:08.394]                           name <- restart$name
[13:35:08.394]                           if (is.null(name)) 
[13:35:08.394]                             next
[13:35:08.394]                           if (!grepl(pattern, name)) 
[13:35:08.394]                             next
[13:35:08.394]                           invokeRestart(restart)
[13:35:08.394]                           muffled <- TRUE
[13:35:08.394]                           break
[13:35:08.394]                         }
[13:35:08.394]                       }
[13:35:08.394]                     }
[13:35:08.394]                     invisible(muffled)
[13:35:08.394]                   }
[13:35:08.394]                   muffleCondition(cond)
[13:35:08.394]                 })
[13:35:08.394]             }))
[13:35:08.394]             future::FutureResult(value = ...future.value$value, 
[13:35:08.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.394]                   ...future.rng), globalenv = if (FALSE) 
[13:35:08.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:08.394]                     ...future.globalenv.names))
[13:35:08.394]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:08.394]         }, condition = base::local({
[13:35:08.394]             c <- base::c
[13:35:08.394]             inherits <- base::inherits
[13:35:08.394]             invokeRestart <- base::invokeRestart
[13:35:08.394]             length <- base::length
[13:35:08.394]             list <- base::list
[13:35:08.394]             seq.int <- base::seq.int
[13:35:08.394]             signalCondition <- base::signalCondition
[13:35:08.394]             sys.calls <- base::sys.calls
[13:35:08.394]             `[[` <- base::`[[`
[13:35:08.394]             `+` <- base::`+`
[13:35:08.394]             `<<-` <- base::`<<-`
[13:35:08.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:08.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:08.394]                   3L)]
[13:35:08.394]             }
[13:35:08.394]             function(cond) {
[13:35:08.394]                 is_error <- inherits(cond, "error")
[13:35:08.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:08.394]                   NULL)
[13:35:08.394]                 if (is_error) {
[13:35:08.394]                   sessionInformation <- function() {
[13:35:08.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:08.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:08.394]                       search = base::search(), system = base::Sys.info())
[13:35:08.394]                   }
[13:35:08.394]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:08.394]                     cond$call), session = sessionInformation(), 
[13:35:08.394]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:08.394]                   signalCondition(cond)
[13:35:08.394]                 }
[13:35:08.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:08.394]                 "immediateCondition"))) {
[13:35:08.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:08.394]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:08.394]                   if (TRUE && !signal) {
[13:35:08.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.394]                     {
[13:35:08.394]                       inherits <- base::inherits
[13:35:08.394]                       invokeRestart <- base::invokeRestart
[13:35:08.394]                       is.null <- base::is.null
[13:35:08.394]                       muffled <- FALSE
[13:35:08.394]                       if (inherits(cond, "message")) {
[13:35:08.394]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.394]                         if (muffled) 
[13:35:08.394]                           invokeRestart("muffleMessage")
[13:35:08.394]                       }
[13:35:08.394]                       else if (inherits(cond, "warning")) {
[13:35:08.394]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.394]                         if (muffled) 
[13:35:08.394]                           invokeRestart("muffleWarning")
[13:35:08.394]                       }
[13:35:08.394]                       else if (inherits(cond, "condition")) {
[13:35:08.394]                         if (!is.null(pattern)) {
[13:35:08.394]                           computeRestarts <- base::computeRestarts
[13:35:08.394]                           grepl <- base::grepl
[13:35:08.394]                           restarts <- computeRestarts(cond)
[13:35:08.394]                           for (restart in restarts) {
[13:35:08.394]                             name <- restart$name
[13:35:08.394]                             if (is.null(name)) 
[13:35:08.394]                               next
[13:35:08.394]                             if (!grepl(pattern, name)) 
[13:35:08.394]                               next
[13:35:08.394]                             invokeRestart(restart)
[13:35:08.394]                             muffled <- TRUE
[13:35:08.394]                             break
[13:35:08.394]                           }
[13:35:08.394]                         }
[13:35:08.394]                       }
[13:35:08.394]                       invisible(muffled)
[13:35:08.394]                     }
[13:35:08.394]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.394]                   }
[13:35:08.394]                 }
[13:35:08.394]                 else {
[13:35:08.394]                   if (TRUE) {
[13:35:08.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.394]                     {
[13:35:08.394]                       inherits <- base::inherits
[13:35:08.394]                       invokeRestart <- base::invokeRestart
[13:35:08.394]                       is.null <- base::is.null
[13:35:08.394]                       muffled <- FALSE
[13:35:08.394]                       if (inherits(cond, "message")) {
[13:35:08.394]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.394]                         if (muffled) 
[13:35:08.394]                           invokeRestart("muffleMessage")
[13:35:08.394]                       }
[13:35:08.394]                       else if (inherits(cond, "warning")) {
[13:35:08.394]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.394]                         if (muffled) 
[13:35:08.394]                           invokeRestart("muffleWarning")
[13:35:08.394]                       }
[13:35:08.394]                       else if (inherits(cond, "condition")) {
[13:35:08.394]                         if (!is.null(pattern)) {
[13:35:08.394]                           computeRestarts <- base::computeRestarts
[13:35:08.394]                           grepl <- base::grepl
[13:35:08.394]                           restarts <- computeRestarts(cond)
[13:35:08.394]                           for (restart in restarts) {
[13:35:08.394]                             name <- restart$name
[13:35:08.394]                             if (is.null(name)) 
[13:35:08.394]                               next
[13:35:08.394]                             if (!grepl(pattern, name)) 
[13:35:08.394]                               next
[13:35:08.394]                             invokeRestart(restart)
[13:35:08.394]                             muffled <- TRUE
[13:35:08.394]                             break
[13:35:08.394]                           }
[13:35:08.394]                         }
[13:35:08.394]                       }
[13:35:08.394]                       invisible(muffled)
[13:35:08.394]                     }
[13:35:08.394]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.394]                   }
[13:35:08.394]                 }
[13:35:08.394]             }
[13:35:08.394]         }))
[13:35:08.394]     }, error = function(ex) {
[13:35:08.394]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:08.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.394]                 ...future.rng), started = ...future.startTime, 
[13:35:08.394]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:08.394]             version = "1.8"), class = "FutureResult")
[13:35:08.394]     }, finally = {
[13:35:08.394]         if (!identical(...future.workdir, getwd())) 
[13:35:08.394]             setwd(...future.workdir)
[13:35:08.394]         {
[13:35:08.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:08.394]                 ...future.oldOptions$nwarnings <- NULL
[13:35:08.394]             }
[13:35:08.394]             base::options(...future.oldOptions)
[13:35:08.394]             if (.Platform$OS.type == "windows") {
[13:35:08.394]                 old_names <- names(...future.oldEnvVars)
[13:35:08.394]                 envs <- base::Sys.getenv()
[13:35:08.394]                 names <- names(envs)
[13:35:08.394]                 common <- intersect(names, old_names)
[13:35:08.394]                 added <- setdiff(names, old_names)
[13:35:08.394]                 removed <- setdiff(old_names, names)
[13:35:08.394]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:08.394]                   envs[common]]
[13:35:08.394]                 NAMES <- toupper(changed)
[13:35:08.394]                 args <- list()
[13:35:08.394]                 for (kk in seq_along(NAMES)) {
[13:35:08.394]                   name <- changed[[kk]]
[13:35:08.394]                   NAME <- NAMES[[kk]]
[13:35:08.394]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.394]                     next
[13:35:08.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.394]                 }
[13:35:08.394]                 NAMES <- toupper(added)
[13:35:08.394]                 for (kk in seq_along(NAMES)) {
[13:35:08.394]                   name <- added[[kk]]
[13:35:08.394]                   NAME <- NAMES[[kk]]
[13:35:08.394]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.394]                     next
[13:35:08.394]                   args[[name]] <- ""
[13:35:08.394]                 }
[13:35:08.394]                 NAMES <- toupper(removed)
[13:35:08.394]                 for (kk in seq_along(NAMES)) {
[13:35:08.394]                   name <- removed[[kk]]
[13:35:08.394]                   NAME <- NAMES[[kk]]
[13:35:08.394]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.394]                     next
[13:35:08.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.394]                 }
[13:35:08.394]                 if (length(args) > 0) 
[13:35:08.394]                   base::do.call(base::Sys.setenv, args = args)
[13:35:08.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:08.394]             }
[13:35:08.394]             else {
[13:35:08.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:08.394]             }
[13:35:08.394]             {
[13:35:08.394]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:08.394]                   0L) {
[13:35:08.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:08.394]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:08.394]                   base::options(opts)
[13:35:08.394]                 }
[13:35:08.394]                 {
[13:35:08.394]                   {
[13:35:08.394]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:08.394]                     NULL
[13:35:08.394]                   }
[13:35:08.394]                   options(future.plan = NULL)
[13:35:08.394]                   if (is.na(NA_character_)) 
[13:35:08.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:08.394]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:08.394]                     .init = FALSE)
[13:35:08.394]                 }
[13:35:08.394]             }
[13:35:08.394]         }
[13:35:08.394]     })
[13:35:08.394]     if (TRUE) {
[13:35:08.394]         base::sink(type = "output", split = FALSE)
[13:35:08.394]         if (TRUE) {
[13:35:08.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:08.394]         }
[13:35:08.394]         else {
[13:35:08.394]             ...future.result["stdout"] <- base::list(NULL)
[13:35:08.394]         }
[13:35:08.394]         base::close(...future.stdout)
[13:35:08.394]         ...future.stdout <- NULL
[13:35:08.394]     }
[13:35:08.394]     ...future.result$conditions <- ...future.conditions
[13:35:08.394]     ...future.result$finished <- base::Sys.time()
[13:35:08.394]     ...future.result
[13:35:08.394] }
[13:35:08.397] assign_globals() ...
[13:35:08.397] List of 11
[13:35:08.397]  $ ...future.FUN            :function (x, ...)  
[13:35:08.397]  $ x_FUN                    :function (x)  
[13:35:08.397]  $ times                    : int 1
[13:35:08.397]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:08.397]  $ stop_if_not              :function (...)  
[13:35:08.397]  $ dim                      : NULL
[13:35:08.397]  $ valid_types              : chr "logical"
[13:35:08.397]  $ future.call.arguments    : list()
[13:35:08.397]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.397]  $ ...future.elements_ii    :List of 5
[13:35:08.397]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[13:35:08.397]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[13:35:08.397]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[13:35:08.397]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[13:35:08.397]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[13:35:08.397]  $ ...future.seeds_ii       : NULL
[13:35:08.397]  $ ...future.globals.maxSize: NULL
[13:35:08.397]  - attr(*, "where")=List of 11
[13:35:08.397]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:08.397]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:08.397]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:08.397]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:08.397]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:08.397]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:08.397]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:08.397]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:08.397]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:08.397]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:08.397]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:08.397]  - attr(*, "resolved")= logi FALSE
[13:35:08.397]  - attr(*, "total_size")= num 94200
[13:35:08.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.397]  - attr(*, "already-done")= logi TRUE
[13:35:08.413] - copied ‘...future.FUN’ to environment
[13:35:08.414] - copied ‘x_FUN’ to environment
[13:35:08.414] - copied ‘times’ to environment
[13:35:08.414] - copied ‘stopf’ to environment
[13:35:08.414] - copied ‘stop_if_not’ to environment
[13:35:08.414] - copied ‘dim’ to environment
[13:35:08.414] - copied ‘valid_types’ to environment
[13:35:08.414] - copied ‘future.call.arguments’ to environment
[13:35:08.414] - copied ‘...future.elements_ii’ to environment
[13:35:08.414] - copied ‘...future.seeds_ii’ to environment
[13:35:08.415] - copied ‘...future.globals.maxSize’ to environment
[13:35:08.415] assign_globals() ... done
[13:35:08.415] requestCore(): workers = 2
[13:35:08.417] MulticoreFuture started
[13:35:08.418] - Launch lazy future ... done
[13:35:08.418] run() for ‘MulticoreFuture’ ... done
[13:35:08.418] Created future:
[13:35:08.419] plan(): Setting new future strategy stack:
[13:35:08.419] List of future strategies:
[13:35:08.419] 1. sequential:
[13:35:08.419]    - args: function (..., envir = parent.frame())
[13:35:08.419]    - tweaked: FALSE
[13:35:08.419]    - call: NULL
[13:35:08.420] plan(): nbrOfWorkers() = 1
[13:35:08.422] plan(): Setting new future strategy stack:
[13:35:08.422] List of future strategies:
[13:35:08.422] 1. multicore:
[13:35:08.422]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:08.422]    - tweaked: FALSE
[13:35:08.422]    - call: plan(strategy)
[13:35:08.428] plan(): nbrOfWorkers() = 2
[13:35:08.418] MulticoreFuture:
[13:35:08.418] Label: ‘future_vapply-2’
[13:35:08.418] Expression:
[13:35:08.418] {
[13:35:08.418]     do.call(function(...) {
[13:35:08.418]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.418]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.418]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.418]             on.exit(options(oopts), add = TRUE)
[13:35:08.418]         }
[13:35:08.418]         {
[13:35:08.418]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.418]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.418]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.418]             })
[13:35:08.418]         }
[13:35:08.418]     }, args = future.call.arguments)
[13:35:08.418] }
[13:35:08.418] Lazy evaluation: FALSE
[13:35:08.418] Asynchronous evaluation: TRUE
[13:35:08.418] Local evaluation: TRUE
[13:35:08.418] Environment: R_GlobalEnv
[13:35:08.418] Capture standard output: TRUE
[13:35:08.418] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:08.418] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:08.418] Packages: 1 packages (‘future.apply’)
[13:35:08.418] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:08.418] Resolved: TRUE
[13:35:08.418] Value: <not collected>
[13:35:08.418] Conditions captured: <none>
[13:35:08.418] Early signaling: FALSE
[13:35:08.418] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:08.418] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.429] Chunk #2 of 2 ... DONE
[13:35:08.429] Launching 2 futures (chunks) ... DONE
[13:35:08.429] Resolving 2 futures (chunks) ...
[13:35:08.429] resolve() on list ...
[13:35:08.429]  recursive: 0
[13:35:08.430]  length: 2
[13:35:08.430] 
[13:35:08.430] Future #1
[13:35:08.430] result() for MulticoreFuture ...
[13:35:08.431] result() for MulticoreFuture ...
[13:35:08.431] result() for MulticoreFuture ... done
[13:35:08.431] result() for MulticoreFuture ... done
[13:35:08.432] result() for MulticoreFuture ...
[13:35:08.432] result() for MulticoreFuture ... done
[13:35:08.432] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:08.432] - nx: 2
[13:35:08.432] - relay: TRUE
[13:35:08.432] - stdout: TRUE
[13:35:08.432] - signal: TRUE
[13:35:08.433] - resignal: FALSE
[13:35:08.433] - force: TRUE
[13:35:08.433] - relayed: [n=2] FALSE, FALSE
[13:35:08.433] - queued futures: [n=2] FALSE, FALSE
[13:35:08.433]  - until=1
[13:35:08.433]  - relaying element #1
[13:35:08.434] result() for MulticoreFuture ...
[13:35:08.434] result() for MulticoreFuture ... done
[13:35:08.434] result() for MulticoreFuture ...
[13:35:08.434] result() for MulticoreFuture ... done
[13:35:08.434] result() for MulticoreFuture ...
[13:35:08.434] result() for MulticoreFuture ... done
[13:35:08.434] result() for MulticoreFuture ...
[13:35:08.435] result() for MulticoreFuture ... done
[13:35:08.435] - relayed: [n=2] TRUE, FALSE
[13:35:08.435] - queued futures: [n=2] TRUE, FALSE
[13:35:08.435] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:08.435]  length: 1 (resolved future 1)
[13:35:08.436] Future #2
[13:35:08.436] result() for MulticoreFuture ...
[13:35:08.437] result() for MulticoreFuture ...
[13:35:08.437] result() for MulticoreFuture ... done
[13:35:08.437] result() for MulticoreFuture ... done
[13:35:08.437] result() for MulticoreFuture ...
[13:35:08.437] result() for MulticoreFuture ... done
[13:35:08.437] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:08.438] - nx: 2
[13:35:08.438] - relay: TRUE
[13:35:08.438] - stdout: TRUE
[13:35:08.438] - signal: TRUE
[13:35:08.438] - resignal: FALSE
[13:35:08.438] - force: TRUE
[13:35:08.438] - relayed: [n=2] TRUE, FALSE
[13:35:08.438] - queued futures: [n=2] TRUE, FALSE
[13:35:08.439]  - until=2
[13:35:08.439]  - relaying element #2
[13:35:08.439] result() for MulticoreFuture ...
[13:35:08.441] result() for MulticoreFuture ... done
[13:35:08.442] result() for MulticoreFuture ...
[13:35:08.442] result() for MulticoreFuture ... done
[13:35:08.442] result() for MulticoreFuture ...
[13:35:08.442] result() for MulticoreFuture ... done
[13:35:08.443] result() for MulticoreFuture ...
[13:35:08.443] result() for MulticoreFuture ... done
[13:35:08.443] - relayed: [n=2] TRUE, TRUE
[13:35:08.443] - queued futures: [n=2] TRUE, TRUE
[13:35:08.443] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:08.444]  length: 0 (resolved future 2)
[13:35:08.444] Relaying remaining futures
[13:35:08.444] signalConditionsASAP(NULL, pos=0) ...
[13:35:08.444] - nx: 2
[13:35:08.444] - relay: TRUE
[13:35:08.445] - stdout: TRUE
[13:35:08.445] - signal: TRUE
[13:35:08.445] - resignal: FALSE
[13:35:08.445] - force: TRUE
[13:35:08.445] - relayed: [n=2] TRUE, TRUE
[13:35:08.446] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:08.446] - relayed: [n=2] TRUE, TRUE
[13:35:08.446] - queued futures: [n=2] TRUE, TRUE
[13:35:08.446] signalConditionsASAP(NULL, pos=0) ... done
[13:35:08.447] resolve() on list ... DONE
[13:35:08.447] result() for MulticoreFuture ...
[13:35:08.447] result() for MulticoreFuture ... done
[13:35:08.447] result() for MulticoreFuture ...
[13:35:08.447] result() for MulticoreFuture ... done
[13:35:08.448] result() for MulticoreFuture ...
[13:35:08.448] result() for MulticoreFuture ... done
[13:35:08.448] result() for MulticoreFuture ...
[13:35:08.448] result() for MulticoreFuture ... done
[13:35:08.448]  - Number of value chunks collected: 2
[13:35:08.449] Resolving 2 futures (chunks) ... DONE
[13:35:08.449] Reducing values from 2 chunks ...
[13:35:08.449]  - Number of values collected after concatenation: 11
[13:35:08.449]  - Number of values expected: 11
[13:35:08.449] Reducing values from 2 chunks ... DONE
[13:35:08.449] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[13:35:08.451] future_lapply() ...
[13:35:08.457] Number of chunks: 2
[13:35:08.457] getGlobalsAndPackagesXApply() ...
[13:35:08.457]  - future.globals: TRUE
[13:35:08.457] getGlobalsAndPackages() ...
[13:35:08.457] Searching for globals...
[13:35:08.461] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:08.461] Searching for globals ... DONE
[13:35:08.461] Resolving globals: FALSE
[13:35:08.462] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[13:35:08.462] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:08.462] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:08.463] - packages: [1] ‘future.apply’
[13:35:08.463] getGlobalsAndPackages() ... DONE
[13:35:08.463]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:08.463]  - needed namespaces: [n=1] ‘future.apply’
[13:35:08.463] Finding globals ... DONE
[13:35:08.463]  - use_args: TRUE
[13:35:08.463]  - Getting '...' globals ...
[13:35:08.463] resolve() on list ...
[13:35:08.464]  recursive: 0
[13:35:08.464]  length: 1
[13:35:08.464]  elements: ‘...’
[13:35:08.464]  length: 0 (resolved future 1)
[13:35:08.464] resolve() on list ... DONE
[13:35:08.464]    - '...' content: [n=0] 
[13:35:08.464] List of 1
[13:35:08.464]  $ ...: list()
[13:35:08.464]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.464]  - attr(*, "where")=List of 1
[13:35:08.464]   ..$ ...:<environment: 0x5574d0f7c648> 
[13:35:08.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.464]  - attr(*, "resolved")= logi TRUE
[13:35:08.464]  - attr(*, "total_size")= num NA
[13:35:08.470]  - Getting '...' globals ... DONE
[13:35:08.470] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:08.470] List of 8
[13:35:08.470]  $ ...future.FUN:function (x, ...)  
[13:35:08.470]  $ x_FUN        :function (x)  
[13:35:08.470]  $ times        : int 1
[13:35:08.470]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:08.470]  $ stop_if_not  :function (...)  
[13:35:08.470]  $ dim          : NULL
[13:35:08.470]  $ valid_types  : chr [1:2] "logical" "integer"
[13:35:08.470]  $ ...          : list()
[13:35:08.470]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.470]  - attr(*, "where")=List of 8
[13:35:08.470]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:08.470]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:08.470]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:08.470]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:08.470]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:08.470]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:08.470]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:08.470]   ..$ ...          :<environment: 0x5574d0f7c648> 
[13:35:08.470]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.470]  - attr(*, "resolved")= logi FALSE
[13:35:08.470]  - attr(*, "total_size")= num 94264
[13:35:08.476] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:08.476] getGlobalsAndPackagesXApply() ... DONE
[13:35:08.477] Number of futures (= number of chunks): 2
[13:35:08.477] Launching 2 futures (chunks) ...
[13:35:08.477] Chunk #1 of 2 ...
[13:35:08.477]  - Finding globals in 'X' for chunk #1 ...
[13:35:08.477] getGlobalsAndPackages() ...
[13:35:08.477] Searching for globals...
[13:35:08.477] 
[13:35:08.478] Searching for globals ... DONE
[13:35:08.478] - globals: [0] <none>
[13:35:08.478] getGlobalsAndPackages() ... DONE
[13:35:08.478]    + additional globals found: [n=0] 
[13:35:08.478]    + additional namespaces needed: [n=0] 
[13:35:08.478]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:08.478]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:08.478]  - seeds: <none>
[13:35:08.478]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.478] getGlobalsAndPackages() ...
[13:35:08.479] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.479] Resolving globals: FALSE
[13:35:08.479] Tweak future expression to call with '...' arguments ...
[13:35:08.479] {
[13:35:08.479]     do.call(function(...) {
[13:35:08.479]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.479]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.479]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.479]             on.exit(options(oopts), add = TRUE)
[13:35:08.479]         }
[13:35:08.479]         {
[13:35:08.479]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.479]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.479]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.479]             })
[13:35:08.479]         }
[13:35:08.479]     }, args = future.call.arguments)
[13:35:08.479] }
[13:35:08.479] Tweak future expression to call with '...' arguments ... DONE
[13:35:08.480] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.480] - packages: [1] ‘future.apply’
[13:35:08.480] getGlobalsAndPackages() ... DONE
[13:35:08.480] run() for ‘Future’ ...
[13:35:08.480] - state: ‘created’
[13:35:08.480] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:08.484] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.484] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:08.484]   - Field: ‘label’
[13:35:08.484]   - Field: ‘local’
[13:35:08.485]   - Field: ‘owner’
[13:35:08.485]   - Field: ‘envir’
[13:35:08.485]   - Field: ‘workers’
[13:35:08.485]   - Field: ‘packages’
[13:35:08.485]   - Field: ‘gc’
[13:35:08.485]   - Field: ‘job’
[13:35:08.485]   - Field: ‘conditions’
[13:35:08.485]   - Field: ‘expr’
[13:35:08.485]   - Field: ‘uuid’
[13:35:08.485]   - Field: ‘seed’
[13:35:08.486]   - Field: ‘version’
[13:35:08.486]   - Field: ‘result’
[13:35:08.486]   - Field: ‘asynchronous’
[13:35:08.486]   - Field: ‘calls’
[13:35:08.486]   - Field: ‘globals’
[13:35:08.486]   - Field: ‘stdout’
[13:35:08.486]   - Field: ‘earlySignal’
[13:35:08.486]   - Field: ‘lazy’
[13:35:08.486]   - Field: ‘state’
[13:35:08.486] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:08.486] - Launch lazy future ...
[13:35:08.487] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:08.487] Packages needed by future strategies (n = 0): <none>
[13:35:08.487] {
[13:35:08.487]     {
[13:35:08.487]         {
[13:35:08.487]             ...future.startTime <- base::Sys.time()
[13:35:08.487]             {
[13:35:08.487]                 {
[13:35:08.487]                   {
[13:35:08.487]                     {
[13:35:08.487]                       {
[13:35:08.487]                         base::local({
[13:35:08.487]                           has_future <- base::requireNamespace("future", 
[13:35:08.487]                             quietly = TRUE)
[13:35:08.487]                           if (has_future) {
[13:35:08.487]                             ns <- base::getNamespace("future")
[13:35:08.487]                             version <- ns[[".package"]][["version"]]
[13:35:08.487]                             if (is.null(version)) 
[13:35:08.487]                               version <- utils::packageVersion("future")
[13:35:08.487]                           }
[13:35:08.487]                           else {
[13:35:08.487]                             version <- NULL
[13:35:08.487]                           }
[13:35:08.487]                           if (!has_future || version < "1.8.0") {
[13:35:08.487]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:08.487]                               "", base::R.version$version.string), 
[13:35:08.487]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:08.487]                                 base::R.version$platform, 8 * 
[13:35:08.487]                                   base::.Machine$sizeof.pointer), 
[13:35:08.487]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:08.487]                                 "release", "version")], collapse = " "), 
[13:35:08.487]                               hostname = base::Sys.info()[["nodename"]])
[13:35:08.487]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:08.487]                               info)
[13:35:08.487]                             info <- base::paste(info, collapse = "; ")
[13:35:08.487]                             if (!has_future) {
[13:35:08.487]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:08.487]                                 info)
[13:35:08.487]                             }
[13:35:08.487]                             else {
[13:35:08.487]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:08.487]                                 info, version)
[13:35:08.487]                             }
[13:35:08.487]                             base::stop(msg)
[13:35:08.487]                           }
[13:35:08.487]                         })
[13:35:08.487]                       }
[13:35:08.487]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:08.487]                       base::options(mc.cores = 1L)
[13:35:08.487]                     }
[13:35:08.487]                     base::local({
[13:35:08.487]                       for (pkg in "future.apply") {
[13:35:08.487]                         base::loadNamespace(pkg)
[13:35:08.487]                         base::library(pkg, character.only = TRUE)
[13:35:08.487]                       }
[13:35:08.487]                     })
[13:35:08.487]                   }
[13:35:08.487]                   ...future.strategy.old <- future::plan("list")
[13:35:08.487]                   options(future.plan = NULL)
[13:35:08.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:08.487]                 }
[13:35:08.487]                 ...future.workdir <- getwd()
[13:35:08.487]             }
[13:35:08.487]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:08.487]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:08.487]         }
[13:35:08.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:08.487]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:08.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:08.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:08.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:08.487]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:08.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:08.487]             base::names(...future.oldOptions))
[13:35:08.487]     }
[13:35:08.487]     if (FALSE) {
[13:35:08.487]     }
[13:35:08.487]     else {
[13:35:08.487]         if (TRUE) {
[13:35:08.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:08.487]                 open = "w")
[13:35:08.487]         }
[13:35:08.487]         else {
[13:35:08.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:08.487]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:08.487]         }
[13:35:08.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:08.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:08.487]             base::sink(type = "output", split = FALSE)
[13:35:08.487]             base::close(...future.stdout)
[13:35:08.487]         }, add = TRUE)
[13:35:08.487]     }
[13:35:08.487]     ...future.frame <- base::sys.nframe()
[13:35:08.487]     ...future.conditions <- base::list()
[13:35:08.487]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:08.487]     if (FALSE) {
[13:35:08.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:08.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:08.487]     }
[13:35:08.487]     ...future.result <- base::tryCatch({
[13:35:08.487]         base::withCallingHandlers({
[13:35:08.487]             ...future.value <- base::withVisible(base::local({
[13:35:08.487]                 withCallingHandlers({
[13:35:08.487]                   {
[13:35:08.487]                     do.call(function(...) {
[13:35:08.487]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.487]                       if (!identical(...future.globals.maxSize.org, 
[13:35:08.487]                         ...future.globals.maxSize)) {
[13:35:08.487]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.487]                         on.exit(options(oopts), add = TRUE)
[13:35:08.487]                       }
[13:35:08.487]                       {
[13:35:08.487]                         lapply(seq_along(...future.elements_ii), 
[13:35:08.487]                           FUN = function(jj) {
[13:35:08.487]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.487]                             ...future.FUN(...future.X_jj, ...)
[13:35:08.487]                           })
[13:35:08.487]                       }
[13:35:08.487]                     }, args = future.call.arguments)
[13:35:08.487]                   }
[13:35:08.487]                 }, immediateCondition = function(cond) {
[13:35:08.487]                   save_rds <- function (object, pathname, ...) 
[13:35:08.487]                   {
[13:35:08.487]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:08.487]                     if (file_test("-f", pathname_tmp)) {
[13:35:08.487]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.487]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:08.487]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.487]                         fi_tmp[["mtime"]])
[13:35:08.487]                     }
[13:35:08.487]                     tryCatch({
[13:35:08.487]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:08.487]                     }, error = function(ex) {
[13:35:08.487]                       msg <- conditionMessage(ex)
[13:35:08.487]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.487]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:08.487]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.487]                         fi_tmp[["mtime"]], msg)
[13:35:08.487]                       ex$message <- msg
[13:35:08.487]                       stop(ex)
[13:35:08.487]                     })
[13:35:08.487]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:08.487]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:08.487]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:08.487]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.487]                       fi <- file.info(pathname)
[13:35:08.487]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:08.487]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.487]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:08.487]                         fi[["size"]], fi[["mtime"]])
[13:35:08.487]                       stop(msg)
[13:35:08.487]                     }
[13:35:08.487]                     invisible(pathname)
[13:35:08.487]                   }
[13:35:08.487]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:08.487]                     rootPath = tempdir()) 
[13:35:08.487]                   {
[13:35:08.487]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:08.487]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:08.487]                       tmpdir = path, fileext = ".rds")
[13:35:08.487]                     save_rds(obj, file)
[13:35:08.487]                   }
[13:35:08.487]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:08.487]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.487]                   {
[13:35:08.487]                     inherits <- base::inherits
[13:35:08.487]                     invokeRestart <- base::invokeRestart
[13:35:08.487]                     is.null <- base::is.null
[13:35:08.487]                     muffled <- FALSE
[13:35:08.487]                     if (inherits(cond, "message")) {
[13:35:08.487]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:08.487]                       if (muffled) 
[13:35:08.487]                         invokeRestart("muffleMessage")
[13:35:08.487]                     }
[13:35:08.487]                     else if (inherits(cond, "warning")) {
[13:35:08.487]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:08.487]                       if (muffled) 
[13:35:08.487]                         invokeRestart("muffleWarning")
[13:35:08.487]                     }
[13:35:08.487]                     else if (inherits(cond, "condition")) {
[13:35:08.487]                       if (!is.null(pattern)) {
[13:35:08.487]                         computeRestarts <- base::computeRestarts
[13:35:08.487]                         grepl <- base::grepl
[13:35:08.487]                         restarts <- computeRestarts(cond)
[13:35:08.487]                         for (restart in restarts) {
[13:35:08.487]                           name <- restart$name
[13:35:08.487]                           if (is.null(name)) 
[13:35:08.487]                             next
[13:35:08.487]                           if (!grepl(pattern, name)) 
[13:35:08.487]                             next
[13:35:08.487]                           invokeRestart(restart)
[13:35:08.487]                           muffled <- TRUE
[13:35:08.487]                           break
[13:35:08.487]                         }
[13:35:08.487]                       }
[13:35:08.487]                     }
[13:35:08.487]                     invisible(muffled)
[13:35:08.487]                   }
[13:35:08.487]                   muffleCondition(cond)
[13:35:08.487]                 })
[13:35:08.487]             }))
[13:35:08.487]             future::FutureResult(value = ...future.value$value, 
[13:35:08.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.487]                   ...future.rng), globalenv = if (FALSE) 
[13:35:08.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:08.487]                     ...future.globalenv.names))
[13:35:08.487]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:08.487]         }, condition = base::local({
[13:35:08.487]             c <- base::c
[13:35:08.487]             inherits <- base::inherits
[13:35:08.487]             invokeRestart <- base::invokeRestart
[13:35:08.487]             length <- base::length
[13:35:08.487]             list <- base::list
[13:35:08.487]             seq.int <- base::seq.int
[13:35:08.487]             signalCondition <- base::signalCondition
[13:35:08.487]             sys.calls <- base::sys.calls
[13:35:08.487]             `[[` <- base::`[[`
[13:35:08.487]             `+` <- base::`+`
[13:35:08.487]             `<<-` <- base::`<<-`
[13:35:08.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:08.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:08.487]                   3L)]
[13:35:08.487]             }
[13:35:08.487]             function(cond) {
[13:35:08.487]                 is_error <- inherits(cond, "error")
[13:35:08.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:08.487]                   NULL)
[13:35:08.487]                 if (is_error) {
[13:35:08.487]                   sessionInformation <- function() {
[13:35:08.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:08.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:08.487]                       search = base::search(), system = base::Sys.info())
[13:35:08.487]                   }
[13:35:08.487]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:08.487]                     cond$call), session = sessionInformation(), 
[13:35:08.487]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:08.487]                   signalCondition(cond)
[13:35:08.487]                 }
[13:35:08.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:08.487]                 "immediateCondition"))) {
[13:35:08.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:08.487]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:08.487]                   if (TRUE && !signal) {
[13:35:08.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.487]                     {
[13:35:08.487]                       inherits <- base::inherits
[13:35:08.487]                       invokeRestart <- base::invokeRestart
[13:35:08.487]                       is.null <- base::is.null
[13:35:08.487]                       muffled <- FALSE
[13:35:08.487]                       if (inherits(cond, "message")) {
[13:35:08.487]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.487]                         if (muffled) 
[13:35:08.487]                           invokeRestart("muffleMessage")
[13:35:08.487]                       }
[13:35:08.487]                       else if (inherits(cond, "warning")) {
[13:35:08.487]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.487]                         if (muffled) 
[13:35:08.487]                           invokeRestart("muffleWarning")
[13:35:08.487]                       }
[13:35:08.487]                       else if (inherits(cond, "condition")) {
[13:35:08.487]                         if (!is.null(pattern)) {
[13:35:08.487]                           computeRestarts <- base::computeRestarts
[13:35:08.487]                           grepl <- base::grepl
[13:35:08.487]                           restarts <- computeRestarts(cond)
[13:35:08.487]                           for (restart in restarts) {
[13:35:08.487]                             name <- restart$name
[13:35:08.487]                             if (is.null(name)) 
[13:35:08.487]                               next
[13:35:08.487]                             if (!grepl(pattern, name)) 
[13:35:08.487]                               next
[13:35:08.487]                             invokeRestart(restart)
[13:35:08.487]                             muffled <- TRUE
[13:35:08.487]                             break
[13:35:08.487]                           }
[13:35:08.487]                         }
[13:35:08.487]                       }
[13:35:08.487]                       invisible(muffled)
[13:35:08.487]                     }
[13:35:08.487]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.487]                   }
[13:35:08.487]                 }
[13:35:08.487]                 else {
[13:35:08.487]                   if (TRUE) {
[13:35:08.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.487]                     {
[13:35:08.487]                       inherits <- base::inherits
[13:35:08.487]                       invokeRestart <- base::invokeRestart
[13:35:08.487]                       is.null <- base::is.null
[13:35:08.487]                       muffled <- FALSE
[13:35:08.487]                       if (inherits(cond, "message")) {
[13:35:08.487]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.487]                         if (muffled) 
[13:35:08.487]                           invokeRestart("muffleMessage")
[13:35:08.487]                       }
[13:35:08.487]                       else if (inherits(cond, "warning")) {
[13:35:08.487]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.487]                         if (muffled) 
[13:35:08.487]                           invokeRestart("muffleWarning")
[13:35:08.487]                       }
[13:35:08.487]                       else if (inherits(cond, "condition")) {
[13:35:08.487]                         if (!is.null(pattern)) {
[13:35:08.487]                           computeRestarts <- base::computeRestarts
[13:35:08.487]                           grepl <- base::grepl
[13:35:08.487]                           restarts <- computeRestarts(cond)
[13:35:08.487]                           for (restart in restarts) {
[13:35:08.487]                             name <- restart$name
[13:35:08.487]                             if (is.null(name)) 
[13:35:08.487]                               next
[13:35:08.487]                             if (!grepl(pattern, name)) 
[13:35:08.487]                               next
[13:35:08.487]                             invokeRestart(restart)
[13:35:08.487]                             muffled <- TRUE
[13:35:08.487]                             break
[13:35:08.487]                           }
[13:35:08.487]                         }
[13:35:08.487]                       }
[13:35:08.487]                       invisible(muffled)
[13:35:08.487]                     }
[13:35:08.487]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.487]                   }
[13:35:08.487]                 }
[13:35:08.487]             }
[13:35:08.487]         }))
[13:35:08.487]     }, error = function(ex) {
[13:35:08.487]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:08.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.487]                 ...future.rng), started = ...future.startTime, 
[13:35:08.487]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:08.487]             version = "1.8"), class = "FutureResult")
[13:35:08.487]     }, finally = {
[13:35:08.487]         if (!identical(...future.workdir, getwd())) 
[13:35:08.487]             setwd(...future.workdir)
[13:35:08.487]         {
[13:35:08.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:08.487]                 ...future.oldOptions$nwarnings <- NULL
[13:35:08.487]             }
[13:35:08.487]             base::options(...future.oldOptions)
[13:35:08.487]             if (.Platform$OS.type == "windows") {
[13:35:08.487]                 old_names <- names(...future.oldEnvVars)
[13:35:08.487]                 envs <- base::Sys.getenv()
[13:35:08.487]                 names <- names(envs)
[13:35:08.487]                 common <- intersect(names, old_names)
[13:35:08.487]                 added <- setdiff(names, old_names)
[13:35:08.487]                 removed <- setdiff(old_names, names)
[13:35:08.487]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:08.487]                   envs[common]]
[13:35:08.487]                 NAMES <- toupper(changed)
[13:35:08.487]                 args <- list()
[13:35:08.487]                 for (kk in seq_along(NAMES)) {
[13:35:08.487]                   name <- changed[[kk]]
[13:35:08.487]                   NAME <- NAMES[[kk]]
[13:35:08.487]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.487]                     next
[13:35:08.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.487]                 }
[13:35:08.487]                 NAMES <- toupper(added)
[13:35:08.487]                 for (kk in seq_along(NAMES)) {
[13:35:08.487]                   name <- added[[kk]]
[13:35:08.487]                   NAME <- NAMES[[kk]]
[13:35:08.487]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.487]                     next
[13:35:08.487]                   args[[name]] <- ""
[13:35:08.487]                 }
[13:35:08.487]                 NAMES <- toupper(removed)
[13:35:08.487]                 for (kk in seq_along(NAMES)) {
[13:35:08.487]                   name <- removed[[kk]]
[13:35:08.487]                   NAME <- NAMES[[kk]]
[13:35:08.487]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.487]                     next
[13:35:08.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.487]                 }
[13:35:08.487]                 if (length(args) > 0) 
[13:35:08.487]                   base::do.call(base::Sys.setenv, args = args)
[13:35:08.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:08.487]             }
[13:35:08.487]             else {
[13:35:08.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:08.487]             }
[13:35:08.487]             {
[13:35:08.487]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:08.487]                   0L) {
[13:35:08.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:08.487]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:08.487]                   base::options(opts)
[13:35:08.487]                 }
[13:35:08.487]                 {
[13:35:08.487]                   {
[13:35:08.487]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:08.487]                     NULL
[13:35:08.487]                   }
[13:35:08.487]                   options(future.plan = NULL)
[13:35:08.487]                   if (is.na(NA_character_)) 
[13:35:08.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:08.487]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:08.487]                     .init = FALSE)
[13:35:08.487]                 }
[13:35:08.487]             }
[13:35:08.487]         }
[13:35:08.487]     })
[13:35:08.487]     if (TRUE) {
[13:35:08.487]         base::sink(type = "output", split = FALSE)
[13:35:08.487]         if (TRUE) {
[13:35:08.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:08.487]         }
[13:35:08.487]         else {
[13:35:08.487]             ...future.result["stdout"] <- base::list(NULL)
[13:35:08.487]         }
[13:35:08.487]         base::close(...future.stdout)
[13:35:08.487]         ...future.stdout <- NULL
[13:35:08.487]     }
[13:35:08.487]     ...future.result$conditions <- ...future.conditions
[13:35:08.487]     ...future.result$finished <- base::Sys.time()
[13:35:08.487]     ...future.result
[13:35:08.487] }
[13:35:08.490] assign_globals() ...
[13:35:08.490] List of 11
[13:35:08.490]  $ ...future.FUN            :function (x, ...)  
[13:35:08.490]  $ x_FUN                    :function (x)  
[13:35:08.490]  $ times                    : int 1
[13:35:08.490]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:08.490]  $ stop_if_not              :function (...)  
[13:35:08.490]  $ dim                      : NULL
[13:35:08.490]  $ valid_types              : chr [1:2] "logical" "integer"
[13:35:08.490]  $ future.call.arguments    : list()
[13:35:08.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.490]  $ ...future.elements_ii    :List of 1
[13:35:08.490]   ..$ a: num 1
[13:35:08.490]  $ ...future.seeds_ii       : NULL
[13:35:08.490]  $ ...future.globals.maxSize: NULL
[13:35:08.490]  - attr(*, "where")=List of 11
[13:35:08.490]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:08.490]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:08.490]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:08.490]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:08.490]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:08.490]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:08.490]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:08.490]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:08.490]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:08.490]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:08.490]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:08.490]  - attr(*, "resolved")= logi FALSE
[13:35:08.490]  - attr(*, "total_size")= num 94264
[13:35:08.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.490]  - attr(*, "already-done")= logi TRUE
[13:35:08.500] - copied ‘...future.FUN’ to environment
[13:35:08.500] - copied ‘x_FUN’ to environment
[13:35:08.500] - copied ‘times’ to environment
[13:35:08.500] - copied ‘stopf’ to environment
[13:35:08.500] - copied ‘stop_if_not’ to environment
[13:35:08.500] - copied ‘dim’ to environment
[13:35:08.501] - copied ‘valid_types’ to environment
[13:35:08.501] - copied ‘future.call.arguments’ to environment
[13:35:08.501] - copied ‘...future.elements_ii’ to environment
[13:35:08.501] - copied ‘...future.seeds_ii’ to environment
[13:35:08.501] - copied ‘...future.globals.maxSize’ to environment
[13:35:08.501] assign_globals() ... done
[13:35:08.501] requestCore(): workers = 2
[13:35:08.503] MulticoreFuture started
[13:35:08.504] - Launch lazy future ... done
[13:35:08.504] run() for ‘MulticoreFuture’ ... done
[13:35:08.505] Created future:
[13:35:08.505] plan(): Setting new future strategy stack:
[13:35:08.505] List of future strategies:
[13:35:08.505] 1. sequential:
[13:35:08.505]    - args: function (..., envir = parent.frame())
[13:35:08.505]    - tweaked: FALSE
[13:35:08.505]    - call: NULL
[13:35:08.506] plan(): nbrOfWorkers() = 1
[13:35:08.508] plan(): Setting new future strategy stack:
[13:35:08.509] List of future strategies:
[13:35:08.509] 1. multicore:
[13:35:08.509]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:08.509]    - tweaked: FALSE
[13:35:08.509]    - call: plan(strategy)
[13:35:08.515] plan(): nbrOfWorkers() = 2
[13:35:08.505] MulticoreFuture:
[13:35:08.505] Label: ‘future_vapply-1’
[13:35:08.505] Expression:
[13:35:08.505] {
[13:35:08.505]     do.call(function(...) {
[13:35:08.505]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.505]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.505]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.505]             on.exit(options(oopts), add = TRUE)
[13:35:08.505]         }
[13:35:08.505]         {
[13:35:08.505]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.505]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.505]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.505]             })
[13:35:08.505]         }
[13:35:08.505]     }, args = future.call.arguments)
[13:35:08.505] }
[13:35:08.505] Lazy evaluation: FALSE
[13:35:08.505] Asynchronous evaluation: TRUE
[13:35:08.505] Local evaluation: TRUE
[13:35:08.505] Environment: R_GlobalEnv
[13:35:08.505] Capture standard output: TRUE
[13:35:08.505] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:08.505] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:08.505] Packages: 1 packages (‘future.apply’)
[13:35:08.505] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:08.505] Resolved: TRUE
[13:35:08.505] Value: <not collected>
[13:35:08.505] Conditions captured: <none>
[13:35:08.505] Early signaling: FALSE
[13:35:08.505] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:08.505] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.516] Chunk #1 of 2 ... DONE
[13:35:08.516] Chunk #2 of 2 ...
[13:35:08.516]  - Finding globals in 'X' for chunk #2 ...
[13:35:08.516] getGlobalsAndPackages() ...
[13:35:08.517] Searching for globals...
[13:35:08.517] 
[13:35:08.517] Searching for globals ... DONE
[13:35:08.517] - globals: [0] <none>
[13:35:08.517] getGlobalsAndPackages() ... DONE
[13:35:08.518]    + additional globals found: [n=0] 
[13:35:08.518]    + additional namespaces needed: [n=0] 
[13:35:08.518]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:08.518]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:08.518]  - seeds: <none>
[13:35:08.518]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.519] getGlobalsAndPackages() ...
[13:35:08.519] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.519] Resolving globals: FALSE
[13:35:08.519] Tweak future expression to call with '...' arguments ...
[13:35:08.519] {
[13:35:08.519]     do.call(function(...) {
[13:35:08.519]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.519]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.519]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.519]             on.exit(options(oopts), add = TRUE)
[13:35:08.519]         }
[13:35:08.519]         {
[13:35:08.519]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.519]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.519]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.519]             })
[13:35:08.519]         }
[13:35:08.519]     }, args = future.call.arguments)
[13:35:08.519] }
[13:35:08.520] Tweak future expression to call with '...' arguments ... DONE
[13:35:08.521] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.521] - packages: [1] ‘future.apply’
[13:35:08.521] getGlobalsAndPackages() ... DONE
[13:35:08.522] run() for ‘Future’ ...
[13:35:08.522] - state: ‘created’
[13:35:08.522] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:08.527] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.527] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:08.527]   - Field: ‘label’
[13:35:08.527]   - Field: ‘local’
[13:35:08.527]   - Field: ‘owner’
[13:35:08.527]   - Field: ‘envir’
[13:35:08.528]   - Field: ‘workers’
[13:35:08.528]   - Field: ‘packages’
[13:35:08.528]   - Field: ‘gc’
[13:35:08.528]   - Field: ‘job’
[13:35:08.528]   - Field: ‘conditions’
[13:35:08.528]   - Field: ‘expr’
[13:35:08.528]   - Field: ‘uuid’
[13:35:08.529]   - Field: ‘seed’
[13:35:08.529]   - Field: ‘version’
[13:35:08.529]   - Field: ‘result’
[13:35:08.529]   - Field: ‘asynchronous’
[13:35:08.529]   - Field: ‘calls’
[13:35:08.529]   - Field: ‘globals’
[13:35:08.530]   - Field: ‘stdout’
[13:35:08.530]   - Field: ‘earlySignal’
[13:35:08.530]   - Field: ‘lazy’
[13:35:08.530]   - Field: ‘state’
[13:35:08.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:08.530] - Launch lazy future ...
[13:35:08.531] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:08.531] Packages needed by future strategies (n = 0): <none>
[13:35:08.532] {
[13:35:08.532]     {
[13:35:08.532]         {
[13:35:08.532]             ...future.startTime <- base::Sys.time()
[13:35:08.532]             {
[13:35:08.532]                 {
[13:35:08.532]                   {
[13:35:08.532]                     {
[13:35:08.532]                       {
[13:35:08.532]                         base::local({
[13:35:08.532]                           has_future <- base::requireNamespace("future", 
[13:35:08.532]                             quietly = TRUE)
[13:35:08.532]                           if (has_future) {
[13:35:08.532]                             ns <- base::getNamespace("future")
[13:35:08.532]                             version <- ns[[".package"]][["version"]]
[13:35:08.532]                             if (is.null(version)) 
[13:35:08.532]                               version <- utils::packageVersion("future")
[13:35:08.532]                           }
[13:35:08.532]                           else {
[13:35:08.532]                             version <- NULL
[13:35:08.532]                           }
[13:35:08.532]                           if (!has_future || version < "1.8.0") {
[13:35:08.532]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:08.532]                               "", base::R.version$version.string), 
[13:35:08.532]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:08.532]                                 base::R.version$platform, 8 * 
[13:35:08.532]                                   base::.Machine$sizeof.pointer), 
[13:35:08.532]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:08.532]                                 "release", "version")], collapse = " "), 
[13:35:08.532]                               hostname = base::Sys.info()[["nodename"]])
[13:35:08.532]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:08.532]                               info)
[13:35:08.532]                             info <- base::paste(info, collapse = "; ")
[13:35:08.532]                             if (!has_future) {
[13:35:08.532]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:08.532]                                 info)
[13:35:08.532]                             }
[13:35:08.532]                             else {
[13:35:08.532]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:08.532]                                 info, version)
[13:35:08.532]                             }
[13:35:08.532]                             base::stop(msg)
[13:35:08.532]                           }
[13:35:08.532]                         })
[13:35:08.532]                       }
[13:35:08.532]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:08.532]                       base::options(mc.cores = 1L)
[13:35:08.532]                     }
[13:35:08.532]                     base::local({
[13:35:08.532]                       for (pkg in "future.apply") {
[13:35:08.532]                         base::loadNamespace(pkg)
[13:35:08.532]                         base::library(pkg, character.only = TRUE)
[13:35:08.532]                       }
[13:35:08.532]                     })
[13:35:08.532]                   }
[13:35:08.532]                   ...future.strategy.old <- future::plan("list")
[13:35:08.532]                   options(future.plan = NULL)
[13:35:08.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.532]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:08.532]                 }
[13:35:08.532]                 ...future.workdir <- getwd()
[13:35:08.532]             }
[13:35:08.532]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:08.532]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:08.532]         }
[13:35:08.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:08.532]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:08.532]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:08.532]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:08.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:08.532]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:08.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:08.532]             base::names(...future.oldOptions))
[13:35:08.532]     }
[13:35:08.532]     if (FALSE) {
[13:35:08.532]     }
[13:35:08.532]     else {
[13:35:08.532]         if (TRUE) {
[13:35:08.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:08.532]                 open = "w")
[13:35:08.532]         }
[13:35:08.532]         else {
[13:35:08.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:08.532]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:08.532]         }
[13:35:08.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:08.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:08.532]             base::sink(type = "output", split = FALSE)
[13:35:08.532]             base::close(...future.stdout)
[13:35:08.532]         }, add = TRUE)
[13:35:08.532]     }
[13:35:08.532]     ...future.frame <- base::sys.nframe()
[13:35:08.532]     ...future.conditions <- base::list()
[13:35:08.532]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:08.532]     if (FALSE) {
[13:35:08.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:08.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:08.532]     }
[13:35:08.532]     ...future.result <- base::tryCatch({
[13:35:08.532]         base::withCallingHandlers({
[13:35:08.532]             ...future.value <- base::withVisible(base::local({
[13:35:08.532]                 withCallingHandlers({
[13:35:08.532]                   {
[13:35:08.532]                     do.call(function(...) {
[13:35:08.532]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.532]                       if (!identical(...future.globals.maxSize.org, 
[13:35:08.532]                         ...future.globals.maxSize)) {
[13:35:08.532]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.532]                         on.exit(options(oopts), add = TRUE)
[13:35:08.532]                       }
[13:35:08.532]                       {
[13:35:08.532]                         lapply(seq_along(...future.elements_ii), 
[13:35:08.532]                           FUN = function(jj) {
[13:35:08.532]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.532]                             ...future.FUN(...future.X_jj, ...)
[13:35:08.532]                           })
[13:35:08.532]                       }
[13:35:08.532]                     }, args = future.call.arguments)
[13:35:08.532]                   }
[13:35:08.532]                 }, immediateCondition = function(cond) {
[13:35:08.532]                   save_rds <- function (object, pathname, ...) 
[13:35:08.532]                   {
[13:35:08.532]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:08.532]                     if (file_test("-f", pathname_tmp)) {
[13:35:08.532]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.532]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:08.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.532]                         fi_tmp[["mtime"]])
[13:35:08.532]                     }
[13:35:08.532]                     tryCatch({
[13:35:08.532]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:08.532]                     }, error = function(ex) {
[13:35:08.532]                       msg <- conditionMessage(ex)
[13:35:08.532]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.532]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:08.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.532]                         fi_tmp[["mtime"]], msg)
[13:35:08.532]                       ex$message <- msg
[13:35:08.532]                       stop(ex)
[13:35:08.532]                     })
[13:35:08.532]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:08.532]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:08.532]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:08.532]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.532]                       fi <- file.info(pathname)
[13:35:08.532]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:08.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.532]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:08.532]                         fi[["size"]], fi[["mtime"]])
[13:35:08.532]                       stop(msg)
[13:35:08.532]                     }
[13:35:08.532]                     invisible(pathname)
[13:35:08.532]                   }
[13:35:08.532]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:08.532]                     rootPath = tempdir()) 
[13:35:08.532]                   {
[13:35:08.532]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:08.532]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:08.532]                       tmpdir = path, fileext = ".rds")
[13:35:08.532]                     save_rds(obj, file)
[13:35:08.532]                   }
[13:35:08.532]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:08.532]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.532]                   {
[13:35:08.532]                     inherits <- base::inherits
[13:35:08.532]                     invokeRestart <- base::invokeRestart
[13:35:08.532]                     is.null <- base::is.null
[13:35:08.532]                     muffled <- FALSE
[13:35:08.532]                     if (inherits(cond, "message")) {
[13:35:08.532]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:08.532]                       if (muffled) 
[13:35:08.532]                         invokeRestart("muffleMessage")
[13:35:08.532]                     }
[13:35:08.532]                     else if (inherits(cond, "warning")) {
[13:35:08.532]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:08.532]                       if (muffled) 
[13:35:08.532]                         invokeRestart("muffleWarning")
[13:35:08.532]                     }
[13:35:08.532]                     else if (inherits(cond, "condition")) {
[13:35:08.532]                       if (!is.null(pattern)) {
[13:35:08.532]                         computeRestarts <- base::computeRestarts
[13:35:08.532]                         grepl <- base::grepl
[13:35:08.532]                         restarts <- computeRestarts(cond)
[13:35:08.532]                         for (restart in restarts) {
[13:35:08.532]                           name <- restart$name
[13:35:08.532]                           if (is.null(name)) 
[13:35:08.532]                             next
[13:35:08.532]                           if (!grepl(pattern, name)) 
[13:35:08.532]                             next
[13:35:08.532]                           invokeRestart(restart)
[13:35:08.532]                           muffled <- TRUE
[13:35:08.532]                           break
[13:35:08.532]                         }
[13:35:08.532]                       }
[13:35:08.532]                     }
[13:35:08.532]                     invisible(muffled)
[13:35:08.532]                   }
[13:35:08.532]                   muffleCondition(cond)
[13:35:08.532]                 })
[13:35:08.532]             }))
[13:35:08.532]             future::FutureResult(value = ...future.value$value, 
[13:35:08.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.532]                   ...future.rng), globalenv = if (FALSE) 
[13:35:08.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:08.532]                     ...future.globalenv.names))
[13:35:08.532]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:08.532]         }, condition = base::local({
[13:35:08.532]             c <- base::c
[13:35:08.532]             inherits <- base::inherits
[13:35:08.532]             invokeRestart <- base::invokeRestart
[13:35:08.532]             length <- base::length
[13:35:08.532]             list <- base::list
[13:35:08.532]             seq.int <- base::seq.int
[13:35:08.532]             signalCondition <- base::signalCondition
[13:35:08.532]             sys.calls <- base::sys.calls
[13:35:08.532]             `[[` <- base::`[[`
[13:35:08.532]             `+` <- base::`+`
[13:35:08.532]             `<<-` <- base::`<<-`
[13:35:08.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:08.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:08.532]                   3L)]
[13:35:08.532]             }
[13:35:08.532]             function(cond) {
[13:35:08.532]                 is_error <- inherits(cond, "error")
[13:35:08.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:08.532]                   NULL)
[13:35:08.532]                 if (is_error) {
[13:35:08.532]                   sessionInformation <- function() {
[13:35:08.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:08.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:08.532]                       search = base::search(), system = base::Sys.info())
[13:35:08.532]                   }
[13:35:08.532]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:08.532]                     cond$call), session = sessionInformation(), 
[13:35:08.532]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:08.532]                   signalCondition(cond)
[13:35:08.532]                 }
[13:35:08.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:08.532]                 "immediateCondition"))) {
[13:35:08.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:08.532]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:08.532]                   if (TRUE && !signal) {
[13:35:08.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.532]                     {
[13:35:08.532]                       inherits <- base::inherits
[13:35:08.532]                       invokeRestart <- base::invokeRestart
[13:35:08.532]                       is.null <- base::is.null
[13:35:08.532]                       muffled <- FALSE
[13:35:08.532]                       if (inherits(cond, "message")) {
[13:35:08.532]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.532]                         if (muffled) 
[13:35:08.532]                           invokeRestart("muffleMessage")
[13:35:08.532]                       }
[13:35:08.532]                       else if (inherits(cond, "warning")) {
[13:35:08.532]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.532]                         if (muffled) 
[13:35:08.532]                           invokeRestart("muffleWarning")
[13:35:08.532]                       }
[13:35:08.532]                       else if (inherits(cond, "condition")) {
[13:35:08.532]                         if (!is.null(pattern)) {
[13:35:08.532]                           computeRestarts <- base::computeRestarts
[13:35:08.532]                           grepl <- base::grepl
[13:35:08.532]                           restarts <- computeRestarts(cond)
[13:35:08.532]                           for (restart in restarts) {
[13:35:08.532]                             name <- restart$name
[13:35:08.532]                             if (is.null(name)) 
[13:35:08.532]                               next
[13:35:08.532]                             if (!grepl(pattern, name)) 
[13:35:08.532]                               next
[13:35:08.532]                             invokeRestart(restart)
[13:35:08.532]                             muffled <- TRUE
[13:35:08.532]                             break
[13:35:08.532]                           }
[13:35:08.532]                         }
[13:35:08.532]                       }
[13:35:08.532]                       invisible(muffled)
[13:35:08.532]                     }
[13:35:08.532]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.532]                   }
[13:35:08.532]                 }
[13:35:08.532]                 else {
[13:35:08.532]                   if (TRUE) {
[13:35:08.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.532]                     {
[13:35:08.532]                       inherits <- base::inherits
[13:35:08.532]                       invokeRestart <- base::invokeRestart
[13:35:08.532]                       is.null <- base::is.null
[13:35:08.532]                       muffled <- FALSE
[13:35:08.532]                       if (inherits(cond, "message")) {
[13:35:08.532]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.532]                         if (muffled) 
[13:35:08.532]                           invokeRestart("muffleMessage")
[13:35:08.532]                       }
[13:35:08.532]                       else if (inherits(cond, "warning")) {
[13:35:08.532]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.532]                         if (muffled) 
[13:35:08.532]                           invokeRestart("muffleWarning")
[13:35:08.532]                       }
[13:35:08.532]                       else if (inherits(cond, "condition")) {
[13:35:08.532]                         if (!is.null(pattern)) {
[13:35:08.532]                           computeRestarts <- base::computeRestarts
[13:35:08.532]                           grepl <- base::grepl
[13:35:08.532]                           restarts <- computeRestarts(cond)
[13:35:08.532]                           for (restart in restarts) {
[13:35:08.532]                             name <- restart$name
[13:35:08.532]                             if (is.null(name)) 
[13:35:08.532]                               next
[13:35:08.532]                             if (!grepl(pattern, name)) 
[13:35:08.532]                               next
[13:35:08.532]                             invokeRestart(restart)
[13:35:08.532]                             muffled <- TRUE
[13:35:08.532]                             break
[13:35:08.532]                           }
[13:35:08.532]                         }
[13:35:08.532]                       }
[13:35:08.532]                       invisible(muffled)
[13:35:08.532]                     }
[13:35:08.532]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.532]                   }
[13:35:08.532]                 }
[13:35:08.532]             }
[13:35:08.532]         }))
[13:35:08.532]     }, error = function(ex) {
[13:35:08.532]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:08.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.532]                 ...future.rng), started = ...future.startTime, 
[13:35:08.532]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:08.532]             version = "1.8"), class = "FutureResult")
[13:35:08.532]     }, finally = {
[13:35:08.532]         if (!identical(...future.workdir, getwd())) 
[13:35:08.532]             setwd(...future.workdir)
[13:35:08.532]         {
[13:35:08.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:08.532]                 ...future.oldOptions$nwarnings <- NULL
[13:35:08.532]             }
[13:35:08.532]             base::options(...future.oldOptions)
[13:35:08.532]             if (.Platform$OS.type == "windows") {
[13:35:08.532]                 old_names <- names(...future.oldEnvVars)
[13:35:08.532]                 envs <- base::Sys.getenv()
[13:35:08.532]                 names <- names(envs)
[13:35:08.532]                 common <- intersect(names, old_names)
[13:35:08.532]                 added <- setdiff(names, old_names)
[13:35:08.532]                 removed <- setdiff(old_names, names)
[13:35:08.532]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:08.532]                   envs[common]]
[13:35:08.532]                 NAMES <- toupper(changed)
[13:35:08.532]                 args <- list()
[13:35:08.532]                 for (kk in seq_along(NAMES)) {
[13:35:08.532]                   name <- changed[[kk]]
[13:35:08.532]                   NAME <- NAMES[[kk]]
[13:35:08.532]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.532]                     next
[13:35:08.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.532]                 }
[13:35:08.532]                 NAMES <- toupper(added)
[13:35:08.532]                 for (kk in seq_along(NAMES)) {
[13:35:08.532]                   name <- added[[kk]]
[13:35:08.532]                   NAME <- NAMES[[kk]]
[13:35:08.532]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.532]                     next
[13:35:08.532]                   args[[name]] <- ""
[13:35:08.532]                 }
[13:35:08.532]                 NAMES <- toupper(removed)
[13:35:08.532]                 for (kk in seq_along(NAMES)) {
[13:35:08.532]                   name <- removed[[kk]]
[13:35:08.532]                   NAME <- NAMES[[kk]]
[13:35:08.532]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.532]                     next
[13:35:08.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.532]                 }
[13:35:08.532]                 if (length(args) > 0) 
[13:35:08.532]                   base::do.call(base::Sys.setenv, args = args)
[13:35:08.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:08.532]             }
[13:35:08.532]             else {
[13:35:08.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:08.532]             }
[13:35:08.532]             {
[13:35:08.532]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:08.532]                   0L) {
[13:35:08.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:08.532]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:08.532]                   base::options(opts)
[13:35:08.532]                 }
[13:35:08.532]                 {
[13:35:08.532]                   {
[13:35:08.532]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:08.532]                     NULL
[13:35:08.532]                   }
[13:35:08.532]                   options(future.plan = NULL)
[13:35:08.532]                   if (is.na(NA_character_)) 
[13:35:08.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:08.532]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:08.532]                     .init = FALSE)
[13:35:08.532]                 }
[13:35:08.532]             }
[13:35:08.532]         }
[13:35:08.532]     })
[13:35:08.532]     if (TRUE) {
[13:35:08.532]         base::sink(type = "output", split = FALSE)
[13:35:08.532]         if (TRUE) {
[13:35:08.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:08.532]         }
[13:35:08.532]         else {
[13:35:08.532]             ...future.result["stdout"] <- base::list(NULL)
[13:35:08.532]         }
[13:35:08.532]         base::close(...future.stdout)
[13:35:08.532]         ...future.stdout <- NULL
[13:35:08.532]     }
[13:35:08.532]     ...future.result$conditions <- ...future.conditions
[13:35:08.532]     ...future.result$finished <- base::Sys.time()
[13:35:08.532]     ...future.result
[13:35:08.532] }
[13:35:08.538] assign_globals() ...
[13:35:08.539] List of 11
[13:35:08.539]  $ ...future.FUN            :function (x, ...)  
[13:35:08.539]  $ x_FUN                    :function (x)  
[13:35:08.539]  $ times                    : int 1
[13:35:08.539]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:08.539]  $ stop_if_not              :function (...)  
[13:35:08.539]  $ dim                      : NULL
[13:35:08.539]  $ valid_types              : chr [1:2] "logical" "integer"
[13:35:08.539]  $ future.call.arguments    : list()
[13:35:08.539]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.539]  $ ...future.elements_ii    :List of 2
[13:35:08.539]   ..$ b: num 2
[13:35:08.539]   ..$ c: num 3
[13:35:08.539]  $ ...future.seeds_ii       : NULL
[13:35:08.539]  $ ...future.globals.maxSize: NULL
[13:35:08.539]  - attr(*, "where")=List of 11
[13:35:08.539]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:08.539]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:08.539]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:08.539]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:08.539]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:08.539]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:08.539]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:08.539]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:08.539]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:08.539]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:08.539]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:08.539]  - attr(*, "resolved")= logi FALSE
[13:35:08.539]  - attr(*, "total_size")= num 94264
[13:35:08.539]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.539]  - attr(*, "already-done")= logi TRUE
[13:35:08.553] - copied ‘...future.FUN’ to environment
[13:35:08.553] - copied ‘x_FUN’ to environment
[13:35:08.553] - copied ‘times’ to environment
[13:35:08.553] - copied ‘stopf’ to environment
[13:35:08.553] - copied ‘stop_if_not’ to environment
[13:35:08.553] - copied ‘dim’ to environment
[13:35:08.553] - copied ‘valid_types’ to environment
[13:35:08.553] - copied ‘future.call.arguments’ to environment
[13:35:08.553] - copied ‘...future.elements_ii’ to environment
[13:35:08.554] - copied ‘...future.seeds_ii’ to environment
[13:35:08.554] - copied ‘...future.globals.maxSize’ to environment
[13:35:08.554] assign_globals() ... done
[13:35:08.554] requestCore(): workers = 2
[13:35:08.556] MulticoreFuture started
[13:35:08.557] - Launch lazy future ... done
[13:35:08.557] run() for ‘MulticoreFuture’ ... done
[13:35:08.557] Created future:
[13:35:08.558] plan(): Setting new future strategy stack:
[13:35:08.558] List of future strategies:
[13:35:08.558] 1. sequential:
[13:35:08.558]    - args: function (..., envir = parent.frame())
[13:35:08.558]    - tweaked: FALSE
[13:35:08.558]    - call: NULL
[13:35:08.559] plan(): nbrOfWorkers() = 1
[13:35:08.561] plan(): Setting new future strategy stack:
[13:35:08.561] List of future strategies:
[13:35:08.561] 1. multicore:
[13:35:08.561]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:08.561]    - tweaked: FALSE
[13:35:08.561]    - call: plan(strategy)
[13:35:08.567] plan(): nbrOfWorkers() = 2
[13:35:08.557] MulticoreFuture:
[13:35:08.557] Label: ‘future_vapply-2’
[13:35:08.557] Expression:
[13:35:08.557] {
[13:35:08.557]     do.call(function(...) {
[13:35:08.557]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.557]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.557]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.557]             on.exit(options(oopts), add = TRUE)
[13:35:08.557]         }
[13:35:08.557]         {
[13:35:08.557]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.557]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.557]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.557]             })
[13:35:08.557]         }
[13:35:08.557]     }, args = future.call.arguments)
[13:35:08.557] }
[13:35:08.557] Lazy evaluation: FALSE
[13:35:08.557] Asynchronous evaluation: TRUE
[13:35:08.557] Local evaluation: TRUE
[13:35:08.557] Environment: R_GlobalEnv
[13:35:08.557] Capture standard output: TRUE
[13:35:08.557] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:08.557] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:08.557] Packages: 1 packages (‘future.apply’)
[13:35:08.557] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:08.557] Resolved: TRUE
[13:35:08.557] Value: <not collected>
[13:35:08.557] Conditions captured: <none>
[13:35:08.557] Early signaling: FALSE
[13:35:08.557] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:08.557] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.568] Chunk #2 of 2 ... DONE
[13:35:08.568] Launching 2 futures (chunks) ... DONE
[13:35:08.568] Resolving 2 futures (chunks) ...
[13:35:08.568] resolve() on list ...
[13:35:08.568]  recursive: 0
[13:35:08.569]  length: 2
[13:35:08.569] 
[13:35:08.569] Future #1
[13:35:08.569] result() for MulticoreFuture ...
[13:35:08.570] result() for MulticoreFuture ...
[13:35:08.570] result() for MulticoreFuture ... done
[13:35:08.570] result() for MulticoreFuture ... done
[13:35:08.571] result() for MulticoreFuture ...
[13:35:08.571] result() for MulticoreFuture ... done
[13:35:08.571] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:08.571] - nx: 2
[13:35:08.571] - relay: TRUE
[13:35:08.571] - stdout: TRUE
[13:35:08.572] - signal: TRUE
[13:35:08.572] - resignal: FALSE
[13:35:08.572] - force: TRUE
[13:35:08.572] - relayed: [n=2] FALSE, FALSE
[13:35:08.572] - queued futures: [n=2] FALSE, FALSE
[13:35:08.572]  - until=1
[13:35:08.572]  - relaying element #1
[13:35:08.573] result() for MulticoreFuture ...
[13:35:08.573] result() for MulticoreFuture ... done
[13:35:08.573] result() for MulticoreFuture ...
[13:35:08.573] result() for MulticoreFuture ... done
[13:35:08.573] result() for MulticoreFuture ...
[13:35:08.573] result() for MulticoreFuture ... done
[13:35:08.574] result() for MulticoreFuture ...
[13:35:08.574] result() for MulticoreFuture ... done
[13:35:08.574] - relayed: [n=2] TRUE, FALSE
[13:35:08.574] - queued futures: [n=2] TRUE, FALSE
[13:35:08.574] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:08.574]  length: 1 (resolved future 1)
[13:35:08.575] Future #2
[13:35:08.575] result() for MulticoreFuture ...
[13:35:08.576] result() for MulticoreFuture ...
[13:35:08.576] result() for MulticoreFuture ... done
[13:35:08.576] result() for MulticoreFuture ... done
[13:35:08.576] result() for MulticoreFuture ...
[13:35:08.576] result() for MulticoreFuture ... done
[13:35:08.576] signalConditionsASAP(MulticoreFuture, pos=2) ...
[13:35:08.577] - nx: 2
[13:35:08.577] - relay: TRUE
[13:35:08.577] - stdout: TRUE
[13:35:08.577] - signal: TRUE
[13:35:08.577] - resignal: FALSE
[13:35:08.577] - force: TRUE
[13:35:08.577] - relayed: [n=2] TRUE, FALSE
[13:35:08.580] - queued futures: [n=2] TRUE, FALSE
[13:35:08.581]  - until=2
[13:35:08.581]  - relaying element #2
[13:35:08.581] result() for MulticoreFuture ...
[13:35:08.581] result() for MulticoreFuture ... done
[13:35:08.581] result() for MulticoreFuture ...
[13:35:08.582] result() for MulticoreFuture ... done
[13:35:08.582] result() for MulticoreFuture ...
[13:35:08.582] result() for MulticoreFuture ... done
[13:35:08.582] result() for MulticoreFuture ...
[13:35:08.582] result() for MulticoreFuture ... done
[13:35:08.583] - relayed: [n=2] TRUE, TRUE
[13:35:08.583] - queued futures: [n=2] TRUE, TRUE
[13:35:08.583] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[13:35:08.583]  length: 0 (resolved future 2)
[13:35:08.583] Relaying remaining futures
[13:35:08.583] signalConditionsASAP(NULL, pos=0) ...
[13:35:08.584] - nx: 2
[13:35:08.584] - relay: TRUE
[13:35:08.584] - stdout: TRUE
[13:35:08.584] - signal: TRUE
[13:35:08.584] - resignal: FALSE
[13:35:08.584] - force: TRUE
[13:35:08.584] - relayed: [n=2] TRUE, TRUE
[13:35:08.584] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:08.585] - relayed: [n=2] TRUE, TRUE
[13:35:08.585] - queued futures: [n=2] TRUE, TRUE
[13:35:08.585] signalConditionsASAP(NULL, pos=0) ... done
[13:35:08.585] resolve() on list ... DONE
[13:35:08.585] result() for MulticoreFuture ...
[13:35:08.585] result() for MulticoreFuture ... done
[13:35:08.586] result() for MulticoreFuture ...
[13:35:08.586] result() for MulticoreFuture ... done
[13:35:08.586] result() for MulticoreFuture ...
[13:35:08.586] result() for MulticoreFuture ... done
[13:35:08.586] result() for MulticoreFuture ...
[13:35:08.586] result() for MulticoreFuture ... done
[13:35:08.587]  - Number of value chunks collected: 2
[13:35:08.587] Resolving 2 futures (chunks) ... DONE
[13:35:08.587] Reducing values from 2 chunks ...
[13:35:08.587]  - Number of values collected after concatenation: 3
[13:35:08.587]  - Number of values expected: 3
[13:35:08.587] Reducing values from 2 chunks ... DONE
[13:35:08.587] future_lapply() ... DONE
- exceptions ...
[13:35:08.588] future_lapply() ...
[13:35:08.594] Number of chunks: 2
[13:35:08.594] getGlobalsAndPackagesXApply() ...
[13:35:08.595]  - future.globals: TRUE
[13:35:08.595] getGlobalsAndPackages() ...
[13:35:08.595] Searching for globals...
[13:35:08.599] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:08.599] Searching for globals ... DONE
[13:35:08.599] Resolving globals: FALSE
[13:35:08.600] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[13:35:08.600] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:08.600] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:08.600] - packages: [1] ‘future.apply’
[13:35:08.600] getGlobalsAndPackages() ... DONE
[13:35:08.601]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:08.601]  - needed namespaces: [n=1] ‘future.apply’
[13:35:08.601] Finding globals ... DONE
[13:35:08.601]  - use_args: TRUE
[13:35:08.601]  - Getting '...' globals ...
[13:35:08.601] resolve() on list ...
[13:35:08.601]  recursive: 0
[13:35:08.601]  length: 1
[13:35:08.602]  elements: ‘...’
[13:35:08.602]  length: 0 (resolved future 1)
[13:35:08.602] resolve() on list ... DONE
[13:35:08.602]    - '...' content: [n=0] 
[13:35:08.602] List of 1
[13:35:08.602]  $ ...: list()
[13:35:08.602]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.602]  - attr(*, "where")=List of 1
[13:35:08.602]   ..$ ...:<environment: 0x5574ceffa310> 
[13:35:08.602]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.602]  - attr(*, "resolved")= logi TRUE
[13:35:08.602]  - attr(*, "total_size")= num NA
[13:35:08.607]  - Getting '...' globals ... DONE
[13:35:08.607] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:08.607] List of 8
[13:35:08.607]  $ ...future.FUN:function (x, ...)  
[13:35:08.607]  $ x_FUN        :function (x)  
[13:35:08.607]  $ times        : int 2
[13:35:08.607]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:08.607]  $ stop_if_not  :function (...)  
[13:35:08.607]  $ dim          : NULL
[13:35:08.607]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:08.607]  $ ...          : list()
[13:35:08.607]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.607]  - attr(*, "where")=List of 8
[13:35:08.607]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:08.607]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:08.607]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:08.607]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:08.607]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:08.607]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:08.607]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:08.607]   ..$ ...          :<environment: 0x5574ceffa310> 
[13:35:08.607]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.607]  - attr(*, "resolved")= logi FALSE
[13:35:08.607]  - attr(*, "total_size")= num 95128
[13:35:08.613] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:08.614] getGlobalsAndPackagesXApply() ... DONE
[13:35:08.614] Number of futures (= number of chunks): 2
[13:35:08.614] Launching 2 futures (chunks) ...
[13:35:08.614] Chunk #1 of 2 ...
[13:35:08.614]  - Finding globals in 'X' for chunk #1 ...
[13:35:08.614] getGlobalsAndPackages() ...
[13:35:08.614] Searching for globals...
[13:35:08.615] 
[13:35:08.615] Searching for globals ... DONE
[13:35:08.615] - globals: [0] <none>
[13:35:08.615] getGlobalsAndPackages() ... DONE
[13:35:08.615]    + additional globals found: [n=0] 
[13:35:08.615]    + additional namespaces needed: [n=0] 
[13:35:08.615]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:08.615]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:08.615]  - seeds: <none>
[13:35:08.615]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.616] getGlobalsAndPackages() ...
[13:35:08.616] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.616] Resolving globals: FALSE
[13:35:08.616] Tweak future expression to call with '...' arguments ...
[13:35:08.616] {
[13:35:08.616]     do.call(function(...) {
[13:35:08.616]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.616]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.616]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.616]             on.exit(options(oopts), add = TRUE)
[13:35:08.616]         }
[13:35:08.616]         {
[13:35:08.616]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.616]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.616]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.616]             })
[13:35:08.616]         }
[13:35:08.616]     }, args = future.call.arguments)
[13:35:08.616] }
[13:35:08.616] Tweak future expression to call with '...' arguments ... DONE
[13:35:08.617] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.617] - packages: [1] ‘future.apply’
[13:35:08.617] getGlobalsAndPackages() ... DONE
[13:35:08.617] run() for ‘Future’ ...
[13:35:08.617] - state: ‘created’
[13:35:08.618] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:08.621] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:08.621]   - Field: ‘label’
[13:35:08.621]   - Field: ‘local’
[13:35:08.622]   - Field: ‘owner’
[13:35:08.622]   - Field: ‘envir’
[13:35:08.622]   - Field: ‘workers’
[13:35:08.622]   - Field: ‘packages’
[13:35:08.622]   - Field: ‘gc’
[13:35:08.622]   - Field: ‘job’
[13:35:08.622]   - Field: ‘conditions’
[13:35:08.622]   - Field: ‘expr’
[13:35:08.622]   - Field: ‘uuid’
[13:35:08.622]   - Field: ‘seed’
[13:35:08.623]   - Field: ‘version’
[13:35:08.623]   - Field: ‘result’
[13:35:08.623]   - Field: ‘asynchronous’
[13:35:08.623]   - Field: ‘calls’
[13:35:08.623]   - Field: ‘globals’
[13:35:08.623]   - Field: ‘stdout’
[13:35:08.623]   - Field: ‘earlySignal’
[13:35:08.623]   - Field: ‘lazy’
[13:35:08.623]   - Field: ‘state’
[13:35:08.623] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:08.623] - Launch lazy future ...
[13:35:08.624] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:08.624] Packages needed by future strategies (n = 0): <none>
[13:35:08.624] {
[13:35:08.624]     {
[13:35:08.624]         {
[13:35:08.624]             ...future.startTime <- base::Sys.time()
[13:35:08.624]             {
[13:35:08.624]                 {
[13:35:08.624]                   {
[13:35:08.624]                     {
[13:35:08.624]                       {
[13:35:08.624]                         base::local({
[13:35:08.624]                           has_future <- base::requireNamespace("future", 
[13:35:08.624]                             quietly = TRUE)
[13:35:08.624]                           if (has_future) {
[13:35:08.624]                             ns <- base::getNamespace("future")
[13:35:08.624]                             version <- ns[[".package"]][["version"]]
[13:35:08.624]                             if (is.null(version)) 
[13:35:08.624]                               version <- utils::packageVersion("future")
[13:35:08.624]                           }
[13:35:08.624]                           else {
[13:35:08.624]                             version <- NULL
[13:35:08.624]                           }
[13:35:08.624]                           if (!has_future || version < "1.8.0") {
[13:35:08.624]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:08.624]                               "", base::R.version$version.string), 
[13:35:08.624]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:08.624]                                 base::R.version$platform, 8 * 
[13:35:08.624]                                   base::.Machine$sizeof.pointer), 
[13:35:08.624]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:08.624]                                 "release", "version")], collapse = " "), 
[13:35:08.624]                               hostname = base::Sys.info()[["nodename"]])
[13:35:08.624]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:08.624]                               info)
[13:35:08.624]                             info <- base::paste(info, collapse = "; ")
[13:35:08.624]                             if (!has_future) {
[13:35:08.624]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:08.624]                                 info)
[13:35:08.624]                             }
[13:35:08.624]                             else {
[13:35:08.624]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:08.624]                                 info, version)
[13:35:08.624]                             }
[13:35:08.624]                             base::stop(msg)
[13:35:08.624]                           }
[13:35:08.624]                         })
[13:35:08.624]                       }
[13:35:08.624]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:08.624]                       base::options(mc.cores = 1L)
[13:35:08.624]                     }
[13:35:08.624]                     base::local({
[13:35:08.624]                       for (pkg in "future.apply") {
[13:35:08.624]                         base::loadNamespace(pkg)
[13:35:08.624]                         base::library(pkg, character.only = TRUE)
[13:35:08.624]                       }
[13:35:08.624]                     })
[13:35:08.624]                   }
[13:35:08.624]                   ...future.strategy.old <- future::plan("list")
[13:35:08.624]                   options(future.plan = NULL)
[13:35:08.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:08.624]                 }
[13:35:08.624]                 ...future.workdir <- getwd()
[13:35:08.624]             }
[13:35:08.624]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:08.624]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:08.624]         }
[13:35:08.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:08.624]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:08.624]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:08.624]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:08.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:08.624]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:08.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:08.624]             base::names(...future.oldOptions))
[13:35:08.624]     }
[13:35:08.624]     if (FALSE) {
[13:35:08.624]     }
[13:35:08.624]     else {
[13:35:08.624]         if (TRUE) {
[13:35:08.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:08.624]                 open = "w")
[13:35:08.624]         }
[13:35:08.624]         else {
[13:35:08.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:08.624]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:08.624]         }
[13:35:08.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:08.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:08.624]             base::sink(type = "output", split = FALSE)
[13:35:08.624]             base::close(...future.stdout)
[13:35:08.624]         }, add = TRUE)
[13:35:08.624]     }
[13:35:08.624]     ...future.frame <- base::sys.nframe()
[13:35:08.624]     ...future.conditions <- base::list()
[13:35:08.624]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:08.624]     if (FALSE) {
[13:35:08.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:08.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:08.624]     }
[13:35:08.624]     ...future.result <- base::tryCatch({
[13:35:08.624]         base::withCallingHandlers({
[13:35:08.624]             ...future.value <- base::withVisible(base::local({
[13:35:08.624]                 withCallingHandlers({
[13:35:08.624]                   {
[13:35:08.624]                     do.call(function(...) {
[13:35:08.624]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.624]                       if (!identical(...future.globals.maxSize.org, 
[13:35:08.624]                         ...future.globals.maxSize)) {
[13:35:08.624]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.624]                         on.exit(options(oopts), add = TRUE)
[13:35:08.624]                       }
[13:35:08.624]                       {
[13:35:08.624]                         lapply(seq_along(...future.elements_ii), 
[13:35:08.624]                           FUN = function(jj) {
[13:35:08.624]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.624]                             ...future.FUN(...future.X_jj, ...)
[13:35:08.624]                           })
[13:35:08.624]                       }
[13:35:08.624]                     }, args = future.call.arguments)
[13:35:08.624]                   }
[13:35:08.624]                 }, immediateCondition = function(cond) {
[13:35:08.624]                   save_rds <- function (object, pathname, ...) 
[13:35:08.624]                   {
[13:35:08.624]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:08.624]                     if (file_test("-f", pathname_tmp)) {
[13:35:08.624]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.624]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:08.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.624]                         fi_tmp[["mtime"]])
[13:35:08.624]                     }
[13:35:08.624]                     tryCatch({
[13:35:08.624]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:08.624]                     }, error = function(ex) {
[13:35:08.624]                       msg <- conditionMessage(ex)
[13:35:08.624]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.624]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:08.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.624]                         fi_tmp[["mtime"]], msg)
[13:35:08.624]                       ex$message <- msg
[13:35:08.624]                       stop(ex)
[13:35:08.624]                     })
[13:35:08.624]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:08.624]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:08.624]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:08.624]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.624]                       fi <- file.info(pathname)
[13:35:08.624]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:08.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.624]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:08.624]                         fi[["size"]], fi[["mtime"]])
[13:35:08.624]                       stop(msg)
[13:35:08.624]                     }
[13:35:08.624]                     invisible(pathname)
[13:35:08.624]                   }
[13:35:08.624]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:08.624]                     rootPath = tempdir()) 
[13:35:08.624]                   {
[13:35:08.624]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:08.624]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:08.624]                       tmpdir = path, fileext = ".rds")
[13:35:08.624]                     save_rds(obj, file)
[13:35:08.624]                   }
[13:35:08.624]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:08.624]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.624]                   {
[13:35:08.624]                     inherits <- base::inherits
[13:35:08.624]                     invokeRestart <- base::invokeRestart
[13:35:08.624]                     is.null <- base::is.null
[13:35:08.624]                     muffled <- FALSE
[13:35:08.624]                     if (inherits(cond, "message")) {
[13:35:08.624]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:08.624]                       if (muffled) 
[13:35:08.624]                         invokeRestart("muffleMessage")
[13:35:08.624]                     }
[13:35:08.624]                     else if (inherits(cond, "warning")) {
[13:35:08.624]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:08.624]                       if (muffled) 
[13:35:08.624]                         invokeRestart("muffleWarning")
[13:35:08.624]                     }
[13:35:08.624]                     else if (inherits(cond, "condition")) {
[13:35:08.624]                       if (!is.null(pattern)) {
[13:35:08.624]                         computeRestarts <- base::computeRestarts
[13:35:08.624]                         grepl <- base::grepl
[13:35:08.624]                         restarts <- computeRestarts(cond)
[13:35:08.624]                         for (restart in restarts) {
[13:35:08.624]                           name <- restart$name
[13:35:08.624]                           if (is.null(name)) 
[13:35:08.624]                             next
[13:35:08.624]                           if (!grepl(pattern, name)) 
[13:35:08.624]                             next
[13:35:08.624]                           invokeRestart(restart)
[13:35:08.624]                           muffled <- TRUE
[13:35:08.624]                           break
[13:35:08.624]                         }
[13:35:08.624]                       }
[13:35:08.624]                     }
[13:35:08.624]                     invisible(muffled)
[13:35:08.624]                   }
[13:35:08.624]                   muffleCondition(cond)
[13:35:08.624]                 })
[13:35:08.624]             }))
[13:35:08.624]             future::FutureResult(value = ...future.value$value, 
[13:35:08.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.624]                   ...future.rng), globalenv = if (FALSE) 
[13:35:08.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:08.624]                     ...future.globalenv.names))
[13:35:08.624]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:08.624]         }, condition = base::local({
[13:35:08.624]             c <- base::c
[13:35:08.624]             inherits <- base::inherits
[13:35:08.624]             invokeRestart <- base::invokeRestart
[13:35:08.624]             length <- base::length
[13:35:08.624]             list <- base::list
[13:35:08.624]             seq.int <- base::seq.int
[13:35:08.624]             signalCondition <- base::signalCondition
[13:35:08.624]             sys.calls <- base::sys.calls
[13:35:08.624]             `[[` <- base::`[[`
[13:35:08.624]             `+` <- base::`+`
[13:35:08.624]             `<<-` <- base::`<<-`
[13:35:08.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:08.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:08.624]                   3L)]
[13:35:08.624]             }
[13:35:08.624]             function(cond) {
[13:35:08.624]                 is_error <- inherits(cond, "error")
[13:35:08.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:08.624]                   NULL)
[13:35:08.624]                 if (is_error) {
[13:35:08.624]                   sessionInformation <- function() {
[13:35:08.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:08.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:08.624]                       search = base::search(), system = base::Sys.info())
[13:35:08.624]                   }
[13:35:08.624]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:08.624]                     cond$call), session = sessionInformation(), 
[13:35:08.624]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:08.624]                   signalCondition(cond)
[13:35:08.624]                 }
[13:35:08.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:08.624]                 "immediateCondition"))) {
[13:35:08.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:08.624]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:08.624]                   if (TRUE && !signal) {
[13:35:08.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.624]                     {
[13:35:08.624]                       inherits <- base::inherits
[13:35:08.624]                       invokeRestart <- base::invokeRestart
[13:35:08.624]                       is.null <- base::is.null
[13:35:08.624]                       muffled <- FALSE
[13:35:08.624]                       if (inherits(cond, "message")) {
[13:35:08.624]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.624]                         if (muffled) 
[13:35:08.624]                           invokeRestart("muffleMessage")
[13:35:08.624]                       }
[13:35:08.624]                       else if (inherits(cond, "warning")) {
[13:35:08.624]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.624]                         if (muffled) 
[13:35:08.624]                           invokeRestart("muffleWarning")
[13:35:08.624]                       }
[13:35:08.624]                       else if (inherits(cond, "condition")) {
[13:35:08.624]                         if (!is.null(pattern)) {
[13:35:08.624]                           computeRestarts <- base::computeRestarts
[13:35:08.624]                           grepl <- base::grepl
[13:35:08.624]                           restarts <- computeRestarts(cond)
[13:35:08.624]                           for (restart in restarts) {
[13:35:08.624]                             name <- restart$name
[13:35:08.624]                             if (is.null(name)) 
[13:35:08.624]                               next
[13:35:08.624]                             if (!grepl(pattern, name)) 
[13:35:08.624]                               next
[13:35:08.624]                             invokeRestart(restart)
[13:35:08.624]                             muffled <- TRUE
[13:35:08.624]                             break
[13:35:08.624]                           }
[13:35:08.624]                         }
[13:35:08.624]                       }
[13:35:08.624]                       invisible(muffled)
[13:35:08.624]                     }
[13:35:08.624]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.624]                   }
[13:35:08.624]                 }
[13:35:08.624]                 else {
[13:35:08.624]                   if (TRUE) {
[13:35:08.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.624]                     {
[13:35:08.624]                       inherits <- base::inherits
[13:35:08.624]                       invokeRestart <- base::invokeRestart
[13:35:08.624]                       is.null <- base::is.null
[13:35:08.624]                       muffled <- FALSE
[13:35:08.624]                       if (inherits(cond, "message")) {
[13:35:08.624]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.624]                         if (muffled) 
[13:35:08.624]                           invokeRestart("muffleMessage")
[13:35:08.624]                       }
[13:35:08.624]                       else if (inherits(cond, "warning")) {
[13:35:08.624]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.624]                         if (muffled) 
[13:35:08.624]                           invokeRestart("muffleWarning")
[13:35:08.624]                       }
[13:35:08.624]                       else if (inherits(cond, "condition")) {
[13:35:08.624]                         if (!is.null(pattern)) {
[13:35:08.624]                           computeRestarts <- base::computeRestarts
[13:35:08.624]                           grepl <- base::grepl
[13:35:08.624]                           restarts <- computeRestarts(cond)
[13:35:08.624]                           for (restart in restarts) {
[13:35:08.624]                             name <- restart$name
[13:35:08.624]                             if (is.null(name)) 
[13:35:08.624]                               next
[13:35:08.624]                             if (!grepl(pattern, name)) 
[13:35:08.624]                               next
[13:35:08.624]                             invokeRestart(restart)
[13:35:08.624]                             muffled <- TRUE
[13:35:08.624]                             break
[13:35:08.624]                           }
[13:35:08.624]                         }
[13:35:08.624]                       }
[13:35:08.624]                       invisible(muffled)
[13:35:08.624]                     }
[13:35:08.624]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.624]                   }
[13:35:08.624]                 }
[13:35:08.624]             }
[13:35:08.624]         }))
[13:35:08.624]     }, error = function(ex) {
[13:35:08.624]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:08.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.624]                 ...future.rng), started = ...future.startTime, 
[13:35:08.624]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:08.624]             version = "1.8"), class = "FutureResult")
[13:35:08.624]     }, finally = {
[13:35:08.624]         if (!identical(...future.workdir, getwd())) 
[13:35:08.624]             setwd(...future.workdir)
[13:35:08.624]         {
[13:35:08.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:08.624]                 ...future.oldOptions$nwarnings <- NULL
[13:35:08.624]             }
[13:35:08.624]             base::options(...future.oldOptions)
[13:35:08.624]             if (.Platform$OS.type == "windows") {
[13:35:08.624]                 old_names <- names(...future.oldEnvVars)
[13:35:08.624]                 envs <- base::Sys.getenv()
[13:35:08.624]                 names <- names(envs)
[13:35:08.624]                 common <- intersect(names, old_names)
[13:35:08.624]                 added <- setdiff(names, old_names)
[13:35:08.624]                 removed <- setdiff(old_names, names)
[13:35:08.624]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:08.624]                   envs[common]]
[13:35:08.624]                 NAMES <- toupper(changed)
[13:35:08.624]                 args <- list()
[13:35:08.624]                 for (kk in seq_along(NAMES)) {
[13:35:08.624]                   name <- changed[[kk]]
[13:35:08.624]                   NAME <- NAMES[[kk]]
[13:35:08.624]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.624]                     next
[13:35:08.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.624]                 }
[13:35:08.624]                 NAMES <- toupper(added)
[13:35:08.624]                 for (kk in seq_along(NAMES)) {
[13:35:08.624]                   name <- added[[kk]]
[13:35:08.624]                   NAME <- NAMES[[kk]]
[13:35:08.624]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.624]                     next
[13:35:08.624]                   args[[name]] <- ""
[13:35:08.624]                 }
[13:35:08.624]                 NAMES <- toupper(removed)
[13:35:08.624]                 for (kk in seq_along(NAMES)) {
[13:35:08.624]                   name <- removed[[kk]]
[13:35:08.624]                   NAME <- NAMES[[kk]]
[13:35:08.624]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.624]                     next
[13:35:08.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.624]                 }
[13:35:08.624]                 if (length(args) > 0) 
[13:35:08.624]                   base::do.call(base::Sys.setenv, args = args)
[13:35:08.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:08.624]             }
[13:35:08.624]             else {
[13:35:08.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:08.624]             }
[13:35:08.624]             {
[13:35:08.624]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:08.624]                   0L) {
[13:35:08.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:08.624]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:08.624]                   base::options(opts)
[13:35:08.624]                 }
[13:35:08.624]                 {
[13:35:08.624]                   {
[13:35:08.624]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:08.624]                     NULL
[13:35:08.624]                   }
[13:35:08.624]                   options(future.plan = NULL)
[13:35:08.624]                   if (is.na(NA_character_)) 
[13:35:08.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:08.624]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:08.624]                     .init = FALSE)
[13:35:08.624]                 }
[13:35:08.624]             }
[13:35:08.624]         }
[13:35:08.624]     })
[13:35:08.624]     if (TRUE) {
[13:35:08.624]         base::sink(type = "output", split = FALSE)
[13:35:08.624]         if (TRUE) {
[13:35:08.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:08.624]         }
[13:35:08.624]         else {
[13:35:08.624]             ...future.result["stdout"] <- base::list(NULL)
[13:35:08.624]         }
[13:35:08.624]         base::close(...future.stdout)
[13:35:08.624]         ...future.stdout <- NULL
[13:35:08.624]     }
[13:35:08.624]     ...future.result$conditions <- ...future.conditions
[13:35:08.624]     ...future.result$finished <- base::Sys.time()
[13:35:08.624]     ...future.result
[13:35:08.624] }
[13:35:08.627] assign_globals() ...
[13:35:08.627] List of 11
[13:35:08.627]  $ ...future.FUN            :function (x, ...)  
[13:35:08.627]  $ x_FUN                    :function (x)  
[13:35:08.627]  $ times                    : int 2
[13:35:08.627]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:08.627]  $ stop_if_not              :function (...)  
[13:35:08.627]  $ dim                      : NULL
[13:35:08.627]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:08.627]  $ future.call.arguments    : list()
[13:35:08.627]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.627]  $ ...future.elements_ii    :List of 1
[13:35:08.627]   ..$ : int 1
[13:35:08.627]  $ ...future.seeds_ii       : NULL
[13:35:08.627]  $ ...future.globals.maxSize: NULL
[13:35:08.627]  - attr(*, "where")=List of 11
[13:35:08.627]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:08.627]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:08.627]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:08.627]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:08.627]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:08.627]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:08.627]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:08.627]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:08.627]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:08.627]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:08.627]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:08.627]  - attr(*, "resolved")= logi FALSE
[13:35:08.627]  - attr(*, "total_size")= num 95128
[13:35:08.627]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.627]  - attr(*, "already-done")= logi TRUE
[13:35:08.637] - copied ‘...future.FUN’ to environment
[13:35:08.637] - copied ‘x_FUN’ to environment
[13:35:08.637] - copied ‘times’ to environment
[13:35:08.637] - copied ‘stopf’ to environment
[13:35:08.638] - copied ‘stop_if_not’ to environment
[13:35:08.638] - copied ‘dim’ to environment
[13:35:08.638] - copied ‘valid_types’ to environment
[13:35:08.638] - copied ‘future.call.arguments’ to environment
[13:35:08.638] - copied ‘...future.elements_ii’ to environment
[13:35:08.638] - copied ‘...future.seeds_ii’ to environment
[13:35:08.638] - copied ‘...future.globals.maxSize’ to environment
[13:35:08.638] assign_globals() ... done
[13:35:08.638] requestCore(): workers = 2
[13:35:08.640] MulticoreFuture started
[13:35:08.641] - Launch lazy future ... done
[13:35:08.641] run() for ‘MulticoreFuture’ ... done
[13:35:08.642] Created future:
[13:35:08.642] plan(): Setting new future strategy stack:
[13:35:08.642] List of future strategies:
[13:35:08.642] 1. sequential:
[13:35:08.642]    - args: function (..., envir = parent.frame())
[13:35:08.642]    - tweaked: FALSE
[13:35:08.642]    - call: NULL
[13:35:08.643] plan(): nbrOfWorkers() = 1
[13:35:08.646] plan(): Setting new future strategy stack:
[13:35:08.646] List of future strategies:
[13:35:08.646] 1. multicore:
[13:35:08.646]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:08.646]    - tweaked: FALSE
[13:35:08.646]    - call: plan(strategy)
[13:35:08.652] plan(): nbrOfWorkers() = 2
[13:35:08.642] MulticoreFuture:
[13:35:08.642] Label: ‘future_vapply-1’
[13:35:08.642] Expression:
[13:35:08.642] {
[13:35:08.642]     do.call(function(...) {
[13:35:08.642]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.642]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.642]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.642]             on.exit(options(oopts), add = TRUE)
[13:35:08.642]         }
[13:35:08.642]         {
[13:35:08.642]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.642]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.642]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.642]             })
[13:35:08.642]         }
[13:35:08.642]     }, args = future.call.arguments)
[13:35:08.642] }
[13:35:08.642] Lazy evaluation: FALSE
[13:35:08.642] Asynchronous evaluation: TRUE
[13:35:08.642] Local evaluation: TRUE
[13:35:08.642] Environment: R_GlobalEnv
[13:35:08.642] Capture standard output: TRUE
[13:35:08.642] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:08.642] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:08.642] Packages: 1 packages (‘future.apply’)
[13:35:08.642] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:08.642] Resolved: FALSE
[13:35:08.642] Value: <not collected>
[13:35:08.642] Conditions captured: <none>
[13:35:08.642] Early signaling: FALSE
[13:35:08.642] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:08.642] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.656] Chunk #1 of 2 ... DONE
[13:35:08.656] Chunk #2 of 2 ...
[13:35:08.656]  - Finding globals in 'X' for chunk #2 ...
[13:35:08.657] getGlobalsAndPackages() ...
[13:35:08.657] Searching for globals...
[13:35:08.657] 
[13:35:08.658] Searching for globals ... DONE
[13:35:08.658] - globals: [0] <none>
[13:35:08.658] getGlobalsAndPackages() ... DONE
[13:35:08.658]    + additional globals found: [n=0] 
[13:35:08.658]    + additional namespaces needed: [n=0] 
[13:35:08.659]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:08.659]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:08.659]  - seeds: <none>
[13:35:08.659]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.659] getGlobalsAndPackages() ...
[13:35:08.660] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.660] Resolving globals: FALSE
[13:35:08.660] Tweak future expression to call with '...' arguments ...
[13:35:08.660] {
[13:35:08.660]     do.call(function(...) {
[13:35:08.660]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.660]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.660]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.660]             on.exit(options(oopts), add = TRUE)
[13:35:08.660]         }
[13:35:08.660]         {
[13:35:08.660]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.660]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.660]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.660]             })
[13:35:08.660]         }
[13:35:08.660]     }, args = future.call.arguments)
[13:35:08.660] }
[13:35:08.661] Tweak future expression to call with '...' arguments ... DONE
[13:35:08.662] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:08.662] - packages: [1] ‘future.apply’
[13:35:08.662] getGlobalsAndPackages() ... DONE
[13:35:08.663] run() for ‘Future’ ...
[13:35:08.663] - state: ‘created’
[13:35:08.663] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[13:35:08.667] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.668] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[13:35:08.668]   - Field: ‘label’
[13:35:08.668]   - Field: ‘local’
[13:35:08.668]   - Field: ‘owner’
[13:35:08.668]   - Field: ‘envir’
[13:35:08.668]   - Field: ‘workers’
[13:35:08.669]   - Field: ‘packages’
[13:35:08.669]   - Field: ‘gc’
[13:35:08.669]   - Field: ‘job’
[13:35:08.669]   - Field: ‘conditions’
[13:35:08.669]   - Field: ‘expr’
[13:35:08.669]   - Field: ‘uuid’
[13:35:08.670]   - Field: ‘seed’
[13:35:08.670]   - Field: ‘version’
[13:35:08.670]   - Field: ‘result’
[13:35:08.670]   - Field: ‘asynchronous’
[13:35:08.670]   - Field: ‘calls’
[13:35:08.670]   - Field: ‘globals’
[13:35:08.671]   - Field: ‘stdout’
[13:35:08.671]   - Field: ‘earlySignal’
[13:35:08.671]   - Field: ‘lazy’
[13:35:08.671]   - Field: ‘state’
[13:35:08.671] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[13:35:08.671] - Launch lazy future ...
[13:35:08.672] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:08.675] Packages needed by future strategies (n = 0): <none>
[13:35:08.676] {
[13:35:08.676]     {
[13:35:08.676]         {
[13:35:08.676]             ...future.startTime <- base::Sys.time()
[13:35:08.676]             {
[13:35:08.676]                 {
[13:35:08.676]                   {
[13:35:08.676]                     {
[13:35:08.676]                       {
[13:35:08.676]                         base::local({
[13:35:08.676]                           has_future <- base::requireNamespace("future", 
[13:35:08.676]                             quietly = TRUE)
[13:35:08.676]                           if (has_future) {
[13:35:08.676]                             ns <- base::getNamespace("future")
[13:35:08.676]                             version <- ns[[".package"]][["version"]]
[13:35:08.676]                             if (is.null(version)) 
[13:35:08.676]                               version <- utils::packageVersion("future")
[13:35:08.676]                           }
[13:35:08.676]                           else {
[13:35:08.676]                             version <- NULL
[13:35:08.676]                           }
[13:35:08.676]                           if (!has_future || version < "1.8.0") {
[13:35:08.676]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:08.676]                               "", base::R.version$version.string), 
[13:35:08.676]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:08.676]                                 base::R.version$platform, 8 * 
[13:35:08.676]                                   base::.Machine$sizeof.pointer), 
[13:35:08.676]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:08.676]                                 "release", "version")], collapse = " "), 
[13:35:08.676]                               hostname = base::Sys.info()[["nodename"]])
[13:35:08.676]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:08.676]                               info)
[13:35:08.676]                             info <- base::paste(info, collapse = "; ")
[13:35:08.676]                             if (!has_future) {
[13:35:08.676]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:08.676]                                 info)
[13:35:08.676]                             }
[13:35:08.676]                             else {
[13:35:08.676]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:08.676]                                 info, version)
[13:35:08.676]                             }
[13:35:08.676]                             base::stop(msg)
[13:35:08.676]                           }
[13:35:08.676]                         })
[13:35:08.676]                       }
[13:35:08.676]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:08.676]                       base::options(mc.cores = 1L)
[13:35:08.676]                     }
[13:35:08.676]                     base::local({
[13:35:08.676]                       for (pkg in "future.apply") {
[13:35:08.676]                         base::loadNamespace(pkg)
[13:35:08.676]                         base::library(pkg, character.only = TRUE)
[13:35:08.676]                       }
[13:35:08.676]                     })
[13:35:08.676]                   }
[13:35:08.676]                   ...future.strategy.old <- future::plan("list")
[13:35:08.676]                   options(future.plan = NULL)
[13:35:08.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:08.676]                 }
[13:35:08.676]                 ...future.workdir <- getwd()
[13:35:08.676]             }
[13:35:08.676]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:08.676]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:08.676]         }
[13:35:08.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:08.676]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:08.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:08.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:08.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:08.676]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:08.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:08.676]             base::names(...future.oldOptions))
[13:35:08.676]     }
[13:35:08.676]     if (FALSE) {
[13:35:08.676]     }
[13:35:08.676]     else {
[13:35:08.676]         if (TRUE) {
[13:35:08.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:08.676]                 open = "w")
[13:35:08.676]         }
[13:35:08.676]         else {
[13:35:08.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:08.676]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:08.676]         }
[13:35:08.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:08.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:08.676]             base::sink(type = "output", split = FALSE)
[13:35:08.676]             base::close(...future.stdout)
[13:35:08.676]         }, add = TRUE)
[13:35:08.676]     }
[13:35:08.676]     ...future.frame <- base::sys.nframe()
[13:35:08.676]     ...future.conditions <- base::list()
[13:35:08.676]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:08.676]     if (FALSE) {
[13:35:08.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:08.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:08.676]     }
[13:35:08.676]     ...future.result <- base::tryCatch({
[13:35:08.676]         base::withCallingHandlers({
[13:35:08.676]             ...future.value <- base::withVisible(base::local({
[13:35:08.676]                 withCallingHandlers({
[13:35:08.676]                   {
[13:35:08.676]                     do.call(function(...) {
[13:35:08.676]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.676]                       if (!identical(...future.globals.maxSize.org, 
[13:35:08.676]                         ...future.globals.maxSize)) {
[13:35:08.676]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.676]                         on.exit(options(oopts), add = TRUE)
[13:35:08.676]                       }
[13:35:08.676]                       {
[13:35:08.676]                         lapply(seq_along(...future.elements_ii), 
[13:35:08.676]                           FUN = function(jj) {
[13:35:08.676]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.676]                             ...future.FUN(...future.X_jj, ...)
[13:35:08.676]                           })
[13:35:08.676]                       }
[13:35:08.676]                     }, args = future.call.arguments)
[13:35:08.676]                   }
[13:35:08.676]                 }, immediateCondition = function(cond) {
[13:35:08.676]                   save_rds <- function (object, pathname, ...) 
[13:35:08.676]                   {
[13:35:08.676]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[13:35:08.676]                     if (file_test("-f", pathname_tmp)) {
[13:35:08.676]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.676]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[13:35:08.676]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.676]                         fi_tmp[["mtime"]])
[13:35:08.676]                     }
[13:35:08.676]                     tryCatch({
[13:35:08.676]                       saveRDS(object, file = pathname_tmp, ...)
[13:35:08.676]                     }, error = function(ex) {
[13:35:08.676]                       msg <- conditionMessage(ex)
[13:35:08.676]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.676]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[13:35:08.676]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.676]                         fi_tmp[["mtime"]], msg)
[13:35:08.676]                       ex$message <- msg
[13:35:08.676]                       stop(ex)
[13:35:08.676]                     })
[13:35:08.676]                     stopifnot(file_test("-f", pathname_tmp))
[13:35:08.676]                     res <- file.rename(from = pathname_tmp, to = pathname)
[13:35:08.676]                     if (!res || file_test("-f", pathname_tmp)) {
[13:35:08.676]                       fi_tmp <- file.info(pathname_tmp)
[13:35:08.676]                       fi <- file.info(pathname)
[13:35:08.676]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[13:35:08.676]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[13:35:08.676]                         fi_tmp[["mtime"]], sQuote(pathname), 
[13:35:08.676]                         fi[["size"]], fi[["mtime"]])
[13:35:08.676]                       stop(msg)
[13:35:08.676]                     }
[13:35:08.676]                     invisible(pathname)
[13:35:08.676]                   }
[13:35:08.676]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[13:35:08.676]                     rootPath = tempdir()) 
[13:35:08.676]                   {
[13:35:08.676]                     obj <- list(time = Sys.time(), condition = cond)
[13:35:08.676]                     file <- tempfile(pattern = class(cond)[1], 
[13:35:08.676]                       tmpdir = path, fileext = ".rds")
[13:35:08.676]                     save_rds(obj, file)
[13:35:08.676]                   }
[13:35:08.676]                   saveImmediateCondition(cond, path = "/tmp/RtmpMAm5my/.future/immediateConditions")
[13:35:08.676]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.676]                   {
[13:35:08.676]                     inherits <- base::inherits
[13:35:08.676]                     invokeRestart <- base::invokeRestart
[13:35:08.676]                     is.null <- base::is.null
[13:35:08.676]                     muffled <- FALSE
[13:35:08.676]                     if (inherits(cond, "message")) {
[13:35:08.676]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:08.676]                       if (muffled) 
[13:35:08.676]                         invokeRestart("muffleMessage")
[13:35:08.676]                     }
[13:35:08.676]                     else if (inherits(cond, "warning")) {
[13:35:08.676]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:08.676]                       if (muffled) 
[13:35:08.676]                         invokeRestart("muffleWarning")
[13:35:08.676]                     }
[13:35:08.676]                     else if (inherits(cond, "condition")) {
[13:35:08.676]                       if (!is.null(pattern)) {
[13:35:08.676]                         computeRestarts <- base::computeRestarts
[13:35:08.676]                         grepl <- base::grepl
[13:35:08.676]                         restarts <- computeRestarts(cond)
[13:35:08.676]                         for (restart in restarts) {
[13:35:08.676]                           name <- restart$name
[13:35:08.676]                           if (is.null(name)) 
[13:35:08.676]                             next
[13:35:08.676]                           if (!grepl(pattern, name)) 
[13:35:08.676]                             next
[13:35:08.676]                           invokeRestart(restart)
[13:35:08.676]                           muffled <- TRUE
[13:35:08.676]                           break
[13:35:08.676]                         }
[13:35:08.676]                       }
[13:35:08.676]                     }
[13:35:08.676]                     invisible(muffled)
[13:35:08.676]                   }
[13:35:08.676]                   muffleCondition(cond)
[13:35:08.676]                 })
[13:35:08.676]             }))
[13:35:08.676]             future::FutureResult(value = ...future.value$value, 
[13:35:08.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.676]                   ...future.rng), globalenv = if (FALSE) 
[13:35:08.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:08.676]                     ...future.globalenv.names))
[13:35:08.676]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:08.676]         }, condition = base::local({
[13:35:08.676]             c <- base::c
[13:35:08.676]             inherits <- base::inherits
[13:35:08.676]             invokeRestart <- base::invokeRestart
[13:35:08.676]             length <- base::length
[13:35:08.676]             list <- base::list
[13:35:08.676]             seq.int <- base::seq.int
[13:35:08.676]             signalCondition <- base::signalCondition
[13:35:08.676]             sys.calls <- base::sys.calls
[13:35:08.676]             `[[` <- base::`[[`
[13:35:08.676]             `+` <- base::`+`
[13:35:08.676]             `<<-` <- base::`<<-`
[13:35:08.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:08.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:08.676]                   3L)]
[13:35:08.676]             }
[13:35:08.676]             function(cond) {
[13:35:08.676]                 is_error <- inherits(cond, "error")
[13:35:08.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:08.676]                   NULL)
[13:35:08.676]                 if (is_error) {
[13:35:08.676]                   sessionInformation <- function() {
[13:35:08.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:08.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:08.676]                       search = base::search(), system = base::Sys.info())
[13:35:08.676]                   }
[13:35:08.676]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:08.676]                     cond$call), session = sessionInformation(), 
[13:35:08.676]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:08.676]                   signalCondition(cond)
[13:35:08.676]                 }
[13:35:08.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:08.676]                 "immediateCondition"))) {
[13:35:08.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:08.676]                   ...future.conditions[[length(...future.conditions) + 
[13:35:08.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:08.676]                   if (TRUE && !signal) {
[13:35:08.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.676]                     {
[13:35:08.676]                       inherits <- base::inherits
[13:35:08.676]                       invokeRestart <- base::invokeRestart
[13:35:08.676]                       is.null <- base::is.null
[13:35:08.676]                       muffled <- FALSE
[13:35:08.676]                       if (inherits(cond, "message")) {
[13:35:08.676]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.676]                         if (muffled) 
[13:35:08.676]                           invokeRestart("muffleMessage")
[13:35:08.676]                       }
[13:35:08.676]                       else if (inherits(cond, "warning")) {
[13:35:08.676]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.676]                         if (muffled) 
[13:35:08.676]                           invokeRestart("muffleWarning")
[13:35:08.676]                       }
[13:35:08.676]                       else if (inherits(cond, "condition")) {
[13:35:08.676]                         if (!is.null(pattern)) {
[13:35:08.676]                           computeRestarts <- base::computeRestarts
[13:35:08.676]                           grepl <- base::grepl
[13:35:08.676]                           restarts <- computeRestarts(cond)
[13:35:08.676]                           for (restart in restarts) {
[13:35:08.676]                             name <- restart$name
[13:35:08.676]                             if (is.null(name)) 
[13:35:08.676]                               next
[13:35:08.676]                             if (!grepl(pattern, name)) 
[13:35:08.676]                               next
[13:35:08.676]                             invokeRestart(restart)
[13:35:08.676]                             muffled <- TRUE
[13:35:08.676]                             break
[13:35:08.676]                           }
[13:35:08.676]                         }
[13:35:08.676]                       }
[13:35:08.676]                       invisible(muffled)
[13:35:08.676]                     }
[13:35:08.676]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.676]                   }
[13:35:08.676]                 }
[13:35:08.676]                 else {
[13:35:08.676]                   if (TRUE) {
[13:35:08.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:08.676]                     {
[13:35:08.676]                       inherits <- base::inherits
[13:35:08.676]                       invokeRestart <- base::invokeRestart
[13:35:08.676]                       is.null <- base::is.null
[13:35:08.676]                       muffled <- FALSE
[13:35:08.676]                       if (inherits(cond, "message")) {
[13:35:08.676]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:08.676]                         if (muffled) 
[13:35:08.676]                           invokeRestart("muffleMessage")
[13:35:08.676]                       }
[13:35:08.676]                       else if (inherits(cond, "warning")) {
[13:35:08.676]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:08.676]                         if (muffled) 
[13:35:08.676]                           invokeRestart("muffleWarning")
[13:35:08.676]                       }
[13:35:08.676]                       else if (inherits(cond, "condition")) {
[13:35:08.676]                         if (!is.null(pattern)) {
[13:35:08.676]                           computeRestarts <- base::computeRestarts
[13:35:08.676]                           grepl <- base::grepl
[13:35:08.676]                           restarts <- computeRestarts(cond)
[13:35:08.676]                           for (restart in restarts) {
[13:35:08.676]                             name <- restart$name
[13:35:08.676]                             if (is.null(name)) 
[13:35:08.676]                               next
[13:35:08.676]                             if (!grepl(pattern, name)) 
[13:35:08.676]                               next
[13:35:08.676]                             invokeRestart(restart)
[13:35:08.676]                             muffled <- TRUE
[13:35:08.676]                             break
[13:35:08.676]                           }
[13:35:08.676]                         }
[13:35:08.676]                       }
[13:35:08.676]                       invisible(muffled)
[13:35:08.676]                     }
[13:35:08.676]                     muffleCondition(cond, pattern = "^muffle")
[13:35:08.676]                   }
[13:35:08.676]                 }
[13:35:08.676]             }
[13:35:08.676]         }))
[13:35:08.676]     }, error = function(ex) {
[13:35:08.676]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:08.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:08.676]                 ...future.rng), started = ...future.startTime, 
[13:35:08.676]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:08.676]             version = "1.8"), class = "FutureResult")
[13:35:08.676]     }, finally = {
[13:35:08.676]         if (!identical(...future.workdir, getwd())) 
[13:35:08.676]             setwd(...future.workdir)
[13:35:08.676]         {
[13:35:08.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:08.676]                 ...future.oldOptions$nwarnings <- NULL
[13:35:08.676]             }
[13:35:08.676]             base::options(...future.oldOptions)
[13:35:08.676]             if (.Platform$OS.type == "windows") {
[13:35:08.676]                 old_names <- names(...future.oldEnvVars)
[13:35:08.676]                 envs <- base::Sys.getenv()
[13:35:08.676]                 names <- names(envs)
[13:35:08.676]                 common <- intersect(names, old_names)
[13:35:08.676]                 added <- setdiff(names, old_names)
[13:35:08.676]                 removed <- setdiff(old_names, names)
[13:35:08.676]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:08.676]                   envs[common]]
[13:35:08.676]                 NAMES <- toupper(changed)
[13:35:08.676]                 args <- list()
[13:35:08.676]                 for (kk in seq_along(NAMES)) {
[13:35:08.676]                   name <- changed[[kk]]
[13:35:08.676]                   NAME <- NAMES[[kk]]
[13:35:08.676]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.676]                     next
[13:35:08.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.676]                 }
[13:35:08.676]                 NAMES <- toupper(added)
[13:35:08.676]                 for (kk in seq_along(NAMES)) {
[13:35:08.676]                   name <- added[[kk]]
[13:35:08.676]                   NAME <- NAMES[[kk]]
[13:35:08.676]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.676]                     next
[13:35:08.676]                   args[[name]] <- ""
[13:35:08.676]                 }
[13:35:08.676]                 NAMES <- toupper(removed)
[13:35:08.676]                 for (kk in seq_along(NAMES)) {
[13:35:08.676]                   name <- removed[[kk]]
[13:35:08.676]                   NAME <- NAMES[[kk]]
[13:35:08.676]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:08.676]                     next
[13:35:08.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:08.676]                 }
[13:35:08.676]                 if (length(args) > 0) 
[13:35:08.676]                   base::do.call(base::Sys.setenv, args = args)
[13:35:08.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:08.676]             }
[13:35:08.676]             else {
[13:35:08.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:08.676]             }
[13:35:08.676]             {
[13:35:08.676]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:08.676]                   0L) {
[13:35:08.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:08.676]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:08.676]                   base::options(opts)
[13:35:08.676]                 }
[13:35:08.676]                 {
[13:35:08.676]                   {
[13:35:08.676]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:08.676]                     NULL
[13:35:08.676]                   }
[13:35:08.676]                   options(future.plan = NULL)
[13:35:08.676]                   if (is.na(NA_character_)) 
[13:35:08.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:08.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:08.676]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:08.676]                     .init = FALSE)
[13:35:08.676]                 }
[13:35:08.676]             }
[13:35:08.676]         }
[13:35:08.676]     })
[13:35:08.676]     if (TRUE) {
[13:35:08.676]         base::sink(type = "output", split = FALSE)
[13:35:08.676]         if (TRUE) {
[13:35:08.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:08.676]         }
[13:35:08.676]         else {
[13:35:08.676]             ...future.result["stdout"] <- base::list(NULL)
[13:35:08.676]         }
[13:35:08.676]         base::close(...future.stdout)
[13:35:08.676]         ...future.stdout <- NULL
[13:35:08.676]     }
[13:35:08.676]     ...future.result$conditions <- ...future.conditions
[13:35:08.676]     ...future.result$finished <- base::Sys.time()
[13:35:08.676]     ...future.result
[13:35:08.676] }
[13:35:08.680] assign_globals() ...
[13:35:08.680] List of 11
[13:35:08.680]  $ ...future.FUN            :function (x, ...)  
[13:35:08.680]  $ x_FUN                    :function (x)  
[13:35:08.680]  $ times                    : int 2
[13:35:08.680]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:08.680]  $ stop_if_not              :function (...)  
[13:35:08.680]  $ dim                      : NULL
[13:35:08.680]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[13:35:08.680]  $ future.call.arguments    : list()
[13:35:08.680]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:08.680]  $ ...future.elements_ii    :List of 2
[13:35:08.680]   ..$ : int 2
[13:35:08.680]   ..$ : int 3
[13:35:08.680]  $ ...future.seeds_ii       : NULL
[13:35:08.680]  $ ...future.globals.maxSize: NULL
[13:35:08.680]  - attr(*, "where")=List of 11
[13:35:08.680]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[13:35:08.680]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[13:35:08.680]   ..$ times                    :<environment: R_EmptyEnv> 
[13:35:08.680]   ..$ stopf                    :<environment: R_EmptyEnv> 
[13:35:08.680]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[13:35:08.680]   ..$ dim                      :<environment: R_EmptyEnv> 
[13:35:08.680]   ..$ valid_types              :<environment: R_EmptyEnv> 
[13:35:08.680]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[13:35:08.680]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[13:35:08.680]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[13:35:08.680]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[13:35:08.680]  - attr(*, "resolved")= logi FALSE
[13:35:08.680]  - attr(*, "total_size")= num 95128
[13:35:08.680]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:08.680]  - attr(*, "already-done")= logi TRUE
[13:35:08.693] - copied ‘...future.FUN’ to environment
[13:35:08.693] - copied ‘x_FUN’ to environment
[13:35:08.693] - copied ‘times’ to environment
[13:35:08.693] - copied ‘stopf’ to environment
[13:35:08.693] - copied ‘stop_if_not’ to environment
[13:35:08.694] - copied ‘dim’ to environment
[13:35:08.694] - copied ‘valid_types’ to environment
[13:35:08.694] - copied ‘future.call.arguments’ to environment
[13:35:08.694] - copied ‘...future.elements_ii’ to environment
[13:35:08.694] - copied ‘...future.seeds_ii’ to environment
[13:35:08.694] - copied ‘...future.globals.maxSize’ to environment
[13:35:08.694] assign_globals() ... done
[13:35:08.694] requestCore(): workers = 2
[13:35:08.697] MulticoreFuture started
[13:35:08.697] - Launch lazy future ... done
[13:35:08.697] run() for ‘MulticoreFuture’ ... done
[13:35:08.698] Created future:
[13:35:08.698] plan(): Setting new future strategy stack:
[13:35:08.699] List of future strategies:
[13:35:08.699] 1. sequential:
[13:35:08.699]    - args: function (..., envir = parent.frame())
[13:35:08.699]    - tweaked: FALSE
[13:35:08.699]    - call: NULL
[13:35:08.699] plan(): nbrOfWorkers() = 1
[13:35:08.701] plan(): Setting new future strategy stack:
[13:35:08.702] List of future strategies:
[13:35:08.702] 1. multicore:
[13:35:08.702]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[13:35:08.702]    - tweaked: FALSE
[13:35:08.702]    - call: plan(strategy)
[13:35:08.707] plan(): nbrOfWorkers() = 2
[13:35:08.698] MulticoreFuture:
[13:35:08.698] Label: ‘future_vapply-2’
[13:35:08.698] Expression:
[13:35:08.698] {
[13:35:08.698]     do.call(function(...) {
[13:35:08.698]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:08.698]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:08.698]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:08.698]             on.exit(options(oopts), add = TRUE)
[13:35:08.698]         }
[13:35:08.698]         {
[13:35:08.698]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:08.698]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:08.698]                 ...future.FUN(...future.X_jj, ...)
[13:35:08.698]             })
[13:35:08.698]         }
[13:35:08.698]     }, args = future.call.arguments)
[13:35:08.698] }
[13:35:08.698] Lazy evaluation: FALSE
[13:35:08.698] Asynchronous evaluation: TRUE
[13:35:08.698] Local evaluation: TRUE
[13:35:08.698] Environment: R_GlobalEnv
[13:35:08.698] Capture standard output: TRUE
[13:35:08.698] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:08.698] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:08.698] Packages: 1 packages (‘future.apply’)
[13:35:08.698] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:08.698] Resolved: FALSE
[13:35:08.698] Value: <not collected>
[13:35:08.698] Conditions captured: <none>
[13:35:08.698] Early signaling: FALSE
[13:35:08.698] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:08.698] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:08.711] Chunk #2 of 2 ... DONE
[13:35:08.711] Launching 2 futures (chunks) ... DONE
[13:35:08.711] Resolving 2 futures (chunks) ...
[13:35:08.711] resolve() on list ...
[13:35:08.712]  recursive: 0
[13:35:08.712]  length: 2
[13:35:08.712] 
[13:35:08.712] Future #1
[13:35:08.712] result() for MulticoreFuture ...
[13:35:08.726] result() for MulticoreFuture ...
[13:35:08.726] result() for MulticoreFuture ... done
[13:35:08.726] signalConditions() ...
[13:35:08.727]  - include = ‘immediateCondition’
[13:35:08.727]  - exclude = 
[13:35:08.727]  - resignal = FALSE
[13:35:08.727]  - Number of conditions: 1
[13:35:08.728] signalConditions() ... done
[13:35:08.728] result() for MulticoreFuture ... done
[13:35:08.728] result() for MulticoreFuture ...
[13:35:08.729] result() for MulticoreFuture ... done
[13:35:08.729] signalConditions() ...
[13:35:08.729]  - include = ‘immediateCondition’
[13:35:08.729]  - exclude = 
[13:35:08.729]  - resignal = FALSE
[13:35:08.730]  - Number of conditions: 1
[13:35:08.730] signalConditions() ... done
[13:35:08.730] signalConditionsASAP(MulticoreFuture, pos=1) ...
[13:35:08.731] - nx: 2
[13:35:08.731] - relay: TRUE
[13:35:08.731] - stdout: TRUE
[13:35:08.731] - signal: TRUE
[13:35:08.731] - resignal: FALSE
[13:35:08.732] - force: TRUE
[13:35:08.732] - relayed: [n=2] FALSE, FALSE
[13:35:08.732] - queued futures: [n=2] FALSE, FALSE
[13:35:08.732]  - until=1
[13:35:08.732]  - relaying element #1
[13:35:08.732] result() for MulticoreFuture ...
[13:35:08.733] result() for MulticoreFuture ... done
[13:35:08.733] result() for MulticoreFuture ...
[13:35:08.733] result() for MulticoreFuture ... done
[13:35:08.733] signalConditions() ...
[13:35:08.733]  - include = ‘immediateCondition’
[13:35:08.733]  - exclude = 
[13:35:08.734]  - resignal = FALSE
[13:35:08.734]  - Number of conditions: 1
[13:35:08.734] signalConditions() ... done
[13:35:08.734] result() for MulticoreFuture ...
[13:35:08.735] result() for MulticoreFuture ... done
[13:35:08.735] signalConditions() ...
[13:35:08.735]  - include = ‘immediateCondition’
[13:35:08.735]  - exclude = 
[13:35:08.735]  - resignal = FALSE
[13:35:08.736]  - Number of conditions: 1
[13:35:08.736] signalConditions() ... done
[13:35:08.736] result() for MulticoreFuture ...
[13:35:08.736] result() for MulticoreFuture ... done
[13:35:08.736] signalConditions() ...
[13:35:08.736]  - include = ‘condition’
[13:35:08.736]  - exclude = ‘immediateCondition’
[13:35:08.737]  - resignal = TRUE
[13:35:08.737]  - Number of conditions: 1
[13:35:08.737]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:35:08.737] signalConditions() ... done
[13:35:08.737] - relayed: [n=2] FALSE, FALSE
[13:35:08.737] - queued futures: [n=2] TRUE, FALSE
[13:35:08.738] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[13:35:08.738] plan(): Setting new future strategy stack:
[13:35:08.738] List of future strategies:
[13:35:08.738] 1. sequential:
[13:35:08.738]    - args: function (..., envir = parent.frame())
[13:35:08.738]    - tweaked: FALSE
[13:35:08.738]    - call: plan(sequential)
[13:35:08.739] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[13:35:08.740] plan(): Setting new future strategy stack:
[13:35:08.740] List of future strategies:
[13:35:08.740] 1. multisession:
[13:35:08.740]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:08.740]    - tweaked: FALSE
[13:35:08.740]    - call: plan(strategy)
[13:35:08.740] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[13:35:08.740] multisession:
[13:35:08.740] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[13:35:08.740] - tweaked: FALSE
[13:35:08.740] - call: plan(strategy)
[13:35:08.747] getGlobalsAndPackages() ...
[13:35:08.747] Not searching for globals
[13:35:08.748] - globals: [0] <none>
[13:35:08.748] getGlobalsAndPackages() ... DONE
[13:35:08.748] [local output] makeClusterPSOCK() ...
[13:35:08.827] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[13:35:08.828] [local output] Base port: 11417
[13:35:08.828] [local output] Getting setup options for 2 cluster nodes ...
[13:35:08.828] [local output]  - Node 1 of 2 ...
[13:35:08.829] [local output] localMachine=TRUE => revtunnel=FALSE

[13:35:08.829] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpMAm5my/worker.rank=1.parallelly.parent=77157.12d6567b250a3.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpMAm5my/worker.rank=1.parallelly.parent=77157.12d6567b250a3.pid")'’
[13:35:09.017] - Possible to infer worker's PID: TRUE
[13:35:09.017] [local output] Rscript port: 11417

[13:35:09.018] [local output]  - Node 2 of 2 ...
[13:35:09.018] [local output] localMachine=TRUE => revtunnel=FALSE

[13:35:09.019] [local output] Rscript port: 11417

[13:35:09.019] [local output] Getting setup options for 2 cluster nodes ... done
[13:35:09.019] [local output]  - Parallel setup requested for some PSOCK nodes
[13:35:09.020] [local output] Setting up PSOCK nodes in parallel
[13:35:09.020] List of 36
[13:35:09.020]  $ worker          : chr "localhost"
[13:35:09.020]   ..- attr(*, "localhost")= logi TRUE
[13:35:09.020]  $ master          : chr "localhost"
[13:35:09.020]  $ port            : int 11417
[13:35:09.020]  $ connectTimeout  : num 120
[13:35:09.020]  $ timeout         : num 2592000
[13:35:09.020]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[13:35:09.020]  $ homogeneous     : logi TRUE
[13:35:09.020]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[13:35:09.020]  $ rscript_envs    : NULL
[13:35:09.020]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:35:09.020]  $ rscript_startup : NULL
[13:35:09.020]  $ rscript_sh      : chr "sh"
[13:35:09.020]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:35:09.020]  $ methods         : logi TRUE
[13:35:09.020]  $ socketOptions   : chr "no-delay"
[13:35:09.020]  $ useXDR          : logi FALSE
[13:35:09.020]  $ outfile         : chr "/dev/null"
[13:35:09.020]  $ renice          : int NA
[13:35:09.020]  $ rshcmd          : NULL
[13:35:09.020]  $ user            : chr(0) 
[13:35:09.020]  $ revtunnel       : logi FALSE
[13:35:09.020]  $ rshlogfile      : NULL
[13:35:09.020]  $ rshopts         : chr(0) 
[13:35:09.020]  $ rank            : int 1
[13:35:09.020]  $ manual          : logi FALSE
[13:35:09.020]  $ dryrun          : logi FALSE
[13:35:09.020]  $ quiet           : logi FALSE
[13:35:09.020]  $ setup_strategy  : chr "parallel"
[13:35:09.020]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:35:09.020]  $ pidfile         : chr "/tmp/RtmpMAm5my/worker.rank=1.parallelly.parent=77157.12d6567b250a3.pid"
[13:35:09.020]  $ rshcmd_label    : NULL
[13:35:09.020]  $ rsh_call        : NULL
[13:35:09.020]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[13:35:09.020]  $ localMachine    : logi TRUE
[13:35:09.020]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[13:35:09.020]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[13:35:09.020]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[13:35:09.020]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[13:35:09.020]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[13:35:09.020]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[13:35:09.020]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[13:35:09.020]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[13:35:09.020]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[13:35:09.020]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[13:35:09.020]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[13:35:09.020]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[13:35:09.020]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[13:35:09.020]  $ arguments       :List of 28
[13:35:09.020]   ..$ worker          : chr "localhost"
[13:35:09.020]   ..$ master          : NULL
[13:35:09.020]   ..$ port            : int 11417
[13:35:09.020]   ..$ connectTimeout  : num 120
[13:35:09.020]   ..$ timeout         : num 2592000
[13:35:09.020]   ..$ rscript         : NULL
[13:35:09.020]   ..$ homogeneous     : NULL
[13:35:09.020]   ..$ rscript_args    : NULL
[13:35:09.020]   ..$ rscript_envs    : NULL
[13:35:09.020]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[13:35:09.020]   ..$ rscript_startup : NULL
[13:35:09.020]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[13:35:09.020]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[13:35:09.020]   ..$ methods         : logi TRUE
[13:35:09.020]   ..$ socketOptions   : chr "no-delay"
[13:35:09.020]   ..$ useXDR          : logi FALSE
[13:35:09.020]   ..$ outfile         : chr "/dev/null"
[13:35:09.020]   ..$ renice          : int NA
[13:35:09.020]   ..$ rshcmd          : NULL
[13:35:09.020]   ..$ user            : NULL
[13:35:09.020]   ..$ revtunnel       : logi NA
[13:35:09.020]   ..$ rshlogfile      : NULL
[13:35:09.020]   ..$ rshopts         : NULL
[13:35:09.020]   ..$ rank            : int 1
[13:35:09.020]   ..$ manual          : logi FALSE
[13:35:09.020]   ..$ dryrun          : logi FALSE
[13:35:09.020]   ..$ quiet           : logi FALSE
[13:35:09.020]   ..$ setup_strategy  : chr "parallel"
[13:35:09.020]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[13:35:09.038] [local output] System call to launch all workers:
[13:35:09.038] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpMAm5my/worker.rank=1.parallelly.parent=77157.12d6567b250a3.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11417 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[13:35:09.038] [local output] Starting PSOCK main server
[13:35:09.044] [local output] Workers launched
[13:35:09.044] [local output] Waiting for workers to connect back
[13:35:09.044]  - [local output] 0 workers out of 2 ready
[13:35:09.280]  - [local output] 0 workers out of 2 ready
[13:35:09.281]  - [local output] 1 workers out of 2 ready
[13:35:09.295]  - [local output] 1 workers out of 2 ready
[13:35:09.296]  - [local output] 2 workers out of 2 ready
[13:35:09.296] [local output] Launching of workers completed
[13:35:09.296] [local output] Collecting session information from workers
[13:35:09.297] [local output]  - Worker #1 of 2
[13:35:09.298] [local output]  - Worker #2 of 2
[13:35:09.298] [local output] makeClusterPSOCK() ... done
[13:35:09.309] Packages needed by the future expression (n = 0): <none>
[13:35:09.309] Packages needed by future strategies (n = 0): <none>
[13:35:09.310] {
[13:35:09.310]     {
[13:35:09.310]         {
[13:35:09.310]             ...future.startTime <- base::Sys.time()
[13:35:09.310]             {
[13:35:09.310]                 {
[13:35:09.310]                   {
[13:35:09.310]                     {
[13:35:09.310]                       base::local({
[13:35:09.310]                         has_future <- base::requireNamespace("future", 
[13:35:09.310]                           quietly = TRUE)
[13:35:09.310]                         if (has_future) {
[13:35:09.310]                           ns <- base::getNamespace("future")
[13:35:09.310]                           version <- ns[[".package"]][["version"]]
[13:35:09.310]                           if (is.null(version)) 
[13:35:09.310]                             version <- utils::packageVersion("future")
[13:35:09.310]                         }
[13:35:09.310]                         else {
[13:35:09.310]                           version <- NULL
[13:35:09.310]                         }
[13:35:09.310]                         if (!has_future || version < "1.8.0") {
[13:35:09.310]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:09.310]                             "", base::R.version$version.string), 
[13:35:09.310]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:09.310]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:09.310]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:09.310]                               "release", "version")], collapse = " "), 
[13:35:09.310]                             hostname = base::Sys.info()[["nodename"]])
[13:35:09.310]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:09.310]                             info)
[13:35:09.310]                           info <- base::paste(info, collapse = "; ")
[13:35:09.310]                           if (!has_future) {
[13:35:09.310]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:09.310]                               info)
[13:35:09.310]                           }
[13:35:09.310]                           else {
[13:35:09.310]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:09.310]                               info, version)
[13:35:09.310]                           }
[13:35:09.310]                           base::stop(msg)
[13:35:09.310]                         }
[13:35:09.310]                       })
[13:35:09.310]                     }
[13:35:09.310]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:09.310]                     base::options(mc.cores = 1L)
[13:35:09.310]                   }
[13:35:09.310]                   ...future.strategy.old <- future::plan("list")
[13:35:09.310]                   options(future.plan = NULL)
[13:35:09.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:09.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:09.310]                 }
[13:35:09.310]                 ...future.workdir <- getwd()
[13:35:09.310]             }
[13:35:09.310]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:09.310]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:09.310]         }
[13:35:09.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:09.310]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[13:35:09.310]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:09.310]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:09.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:09.310]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:09.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:09.310]             base::names(...future.oldOptions))
[13:35:09.310]     }
[13:35:09.310]     if (FALSE) {
[13:35:09.310]     }
[13:35:09.310]     else {
[13:35:09.310]         if (TRUE) {
[13:35:09.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:09.310]                 open = "w")
[13:35:09.310]         }
[13:35:09.310]         else {
[13:35:09.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:09.310]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:09.310]         }
[13:35:09.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:09.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:09.310]             base::sink(type = "output", split = FALSE)
[13:35:09.310]             base::close(...future.stdout)
[13:35:09.310]         }, add = TRUE)
[13:35:09.310]     }
[13:35:09.310]     ...future.frame <- base::sys.nframe()
[13:35:09.310]     ...future.conditions <- base::list()
[13:35:09.310]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:09.310]     if (FALSE) {
[13:35:09.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:09.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:09.310]     }
[13:35:09.310]     ...future.result <- base::tryCatch({
[13:35:09.310]         base::withCallingHandlers({
[13:35:09.310]             ...future.value <- base::withVisible(base::local({
[13:35:09.310]                 ...future.makeSendCondition <- base::local({
[13:35:09.310]                   sendCondition <- NULL
[13:35:09.310]                   function(frame = 1L) {
[13:35:09.310]                     if (is.function(sendCondition)) 
[13:35:09.310]                       return(sendCondition)
[13:35:09.310]                     ns <- getNamespace("parallel")
[13:35:09.310]                     if (exists("sendData", mode = "function", 
[13:35:09.310]                       envir = ns)) {
[13:35:09.310]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:09.310]                         envir = ns)
[13:35:09.310]                       envir <- sys.frame(frame)
[13:35:09.310]                       master <- NULL
[13:35:09.310]                       while (!identical(envir, .GlobalEnv) && 
[13:35:09.310]                         !identical(envir, emptyenv())) {
[13:35:09.310]                         if (exists("master", mode = "list", envir = envir, 
[13:35:09.310]                           inherits = FALSE)) {
[13:35:09.310]                           master <- get("master", mode = "list", 
[13:35:09.310]                             envir = envir, inherits = FALSE)
[13:35:09.310]                           if (inherits(master, c("SOCKnode", 
[13:35:09.310]                             "SOCK0node"))) {
[13:35:09.310]                             sendCondition <<- function(cond) {
[13:35:09.310]                               data <- list(type = "VALUE", value = cond, 
[13:35:09.310]                                 success = TRUE)
[13:35:09.310]                               parallel_sendData(master, data)
[13:35:09.310]                             }
[13:35:09.310]                             return(sendCondition)
[13:35:09.310]                           }
[13:35:09.310]                         }
[13:35:09.310]                         frame <- frame + 1L
[13:35:09.310]                         envir <- sys.frame(frame)
[13:35:09.310]                       }
[13:35:09.310]                     }
[13:35:09.310]                     sendCondition <<- function(cond) NULL
[13:35:09.310]                   }
[13:35:09.310]                 })
[13:35:09.310]                 withCallingHandlers({
[13:35:09.310]                   NA
[13:35:09.310]                 }, immediateCondition = function(cond) {
[13:35:09.310]                   sendCondition <- ...future.makeSendCondition()
[13:35:09.310]                   sendCondition(cond)
[13:35:09.310]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:09.310]                   {
[13:35:09.310]                     inherits <- base::inherits
[13:35:09.310]                     invokeRestart <- base::invokeRestart
[13:35:09.310]                     is.null <- base::is.null
[13:35:09.310]                     muffled <- FALSE
[13:35:09.310]                     if (inherits(cond, "message")) {
[13:35:09.310]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:09.310]                       if (muffled) 
[13:35:09.310]                         invokeRestart("muffleMessage")
[13:35:09.310]                     }
[13:35:09.310]                     else if (inherits(cond, "warning")) {
[13:35:09.310]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:09.310]                       if (muffled) 
[13:35:09.310]                         invokeRestart("muffleWarning")
[13:35:09.310]                     }
[13:35:09.310]                     else if (inherits(cond, "condition")) {
[13:35:09.310]                       if (!is.null(pattern)) {
[13:35:09.310]                         computeRestarts <- base::computeRestarts
[13:35:09.310]                         grepl <- base::grepl
[13:35:09.310]                         restarts <- computeRestarts(cond)
[13:35:09.310]                         for (restart in restarts) {
[13:35:09.310]                           name <- restart$name
[13:35:09.310]                           if (is.null(name)) 
[13:35:09.310]                             next
[13:35:09.310]                           if (!grepl(pattern, name)) 
[13:35:09.310]                             next
[13:35:09.310]                           invokeRestart(restart)
[13:35:09.310]                           muffled <- TRUE
[13:35:09.310]                           break
[13:35:09.310]                         }
[13:35:09.310]                       }
[13:35:09.310]                     }
[13:35:09.310]                     invisible(muffled)
[13:35:09.310]                   }
[13:35:09.310]                   muffleCondition(cond)
[13:35:09.310]                 })
[13:35:09.310]             }))
[13:35:09.310]             future::FutureResult(value = ...future.value$value, 
[13:35:09.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:09.310]                   ...future.rng), globalenv = if (FALSE) 
[13:35:09.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:09.310]                     ...future.globalenv.names))
[13:35:09.310]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:09.310]         }, condition = base::local({
[13:35:09.310]             c <- base::c
[13:35:09.310]             inherits <- base::inherits
[13:35:09.310]             invokeRestart <- base::invokeRestart
[13:35:09.310]             length <- base::length
[13:35:09.310]             list <- base::list
[13:35:09.310]             seq.int <- base::seq.int
[13:35:09.310]             signalCondition <- base::signalCondition
[13:35:09.310]             sys.calls <- base::sys.calls
[13:35:09.310]             `[[` <- base::`[[`
[13:35:09.310]             `+` <- base::`+`
[13:35:09.310]             `<<-` <- base::`<<-`
[13:35:09.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:09.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:09.310]                   3L)]
[13:35:09.310]             }
[13:35:09.310]             function(cond) {
[13:35:09.310]                 is_error <- inherits(cond, "error")
[13:35:09.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:09.310]                   NULL)
[13:35:09.310]                 if (is_error) {
[13:35:09.310]                   sessionInformation <- function() {
[13:35:09.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:09.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:09.310]                       search = base::search(), system = base::Sys.info())
[13:35:09.310]                   }
[13:35:09.310]                   ...future.conditions[[length(...future.conditions) + 
[13:35:09.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:09.310]                     cond$call), session = sessionInformation(), 
[13:35:09.310]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:09.310]                   signalCondition(cond)
[13:35:09.310]                 }
[13:35:09.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:09.310]                 "immediateCondition"))) {
[13:35:09.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:09.310]                   ...future.conditions[[length(...future.conditions) + 
[13:35:09.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:09.310]                   if (TRUE && !signal) {
[13:35:09.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:09.310]                     {
[13:35:09.310]                       inherits <- base::inherits
[13:35:09.310]                       invokeRestart <- base::invokeRestart
[13:35:09.310]                       is.null <- base::is.null
[13:35:09.310]                       muffled <- FALSE
[13:35:09.310]                       if (inherits(cond, "message")) {
[13:35:09.310]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:09.310]                         if (muffled) 
[13:35:09.310]                           invokeRestart("muffleMessage")
[13:35:09.310]                       }
[13:35:09.310]                       else if (inherits(cond, "warning")) {
[13:35:09.310]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:09.310]                         if (muffled) 
[13:35:09.310]                           invokeRestart("muffleWarning")
[13:35:09.310]                       }
[13:35:09.310]                       else if (inherits(cond, "condition")) {
[13:35:09.310]                         if (!is.null(pattern)) {
[13:35:09.310]                           computeRestarts <- base::computeRestarts
[13:35:09.310]                           grepl <- base::grepl
[13:35:09.310]                           restarts <- computeRestarts(cond)
[13:35:09.310]                           for (restart in restarts) {
[13:35:09.310]                             name <- restart$name
[13:35:09.310]                             if (is.null(name)) 
[13:35:09.310]                               next
[13:35:09.310]                             if (!grepl(pattern, name)) 
[13:35:09.310]                               next
[13:35:09.310]                             invokeRestart(restart)
[13:35:09.310]                             muffled <- TRUE
[13:35:09.310]                             break
[13:35:09.310]                           }
[13:35:09.310]                         }
[13:35:09.310]                       }
[13:35:09.310]                       invisible(muffled)
[13:35:09.310]                     }
[13:35:09.310]                     muffleCondition(cond, pattern = "^muffle")
[13:35:09.310]                   }
[13:35:09.310]                 }
[13:35:09.310]                 else {
[13:35:09.310]                   if (TRUE) {
[13:35:09.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:09.310]                     {
[13:35:09.310]                       inherits <- base::inherits
[13:35:09.310]                       invokeRestart <- base::invokeRestart
[13:35:09.310]                       is.null <- base::is.null
[13:35:09.310]                       muffled <- FALSE
[13:35:09.310]                       if (inherits(cond, "message")) {
[13:35:09.310]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:09.310]                         if (muffled) 
[13:35:09.310]                           invokeRestart("muffleMessage")
[13:35:09.310]                       }
[13:35:09.310]                       else if (inherits(cond, "warning")) {
[13:35:09.310]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:09.310]                         if (muffled) 
[13:35:09.310]                           invokeRestart("muffleWarning")
[13:35:09.310]                       }
[13:35:09.310]                       else if (inherits(cond, "condition")) {
[13:35:09.310]                         if (!is.null(pattern)) {
[13:35:09.310]                           computeRestarts <- base::computeRestarts
[13:35:09.310]                           grepl <- base::grepl
[13:35:09.310]                           restarts <- computeRestarts(cond)
[13:35:09.310]                           for (restart in restarts) {
[13:35:09.310]                             name <- restart$name
[13:35:09.310]                             if (is.null(name)) 
[13:35:09.310]                               next
[13:35:09.310]                             if (!grepl(pattern, name)) 
[13:35:09.310]                               next
[13:35:09.310]                             invokeRestart(restart)
[13:35:09.310]                             muffled <- TRUE
[13:35:09.310]                             break
[13:35:09.310]                           }
[13:35:09.310]                         }
[13:35:09.310]                       }
[13:35:09.310]                       invisible(muffled)
[13:35:09.310]                     }
[13:35:09.310]                     muffleCondition(cond, pattern = "^muffle")
[13:35:09.310]                   }
[13:35:09.310]                 }
[13:35:09.310]             }
[13:35:09.310]         }))
[13:35:09.310]     }, error = function(ex) {
[13:35:09.310]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:09.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:09.310]                 ...future.rng), started = ...future.startTime, 
[13:35:09.310]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:09.310]             version = "1.8"), class = "FutureResult")
[13:35:09.310]     }, finally = {
[13:35:09.310]         if (!identical(...future.workdir, getwd())) 
[13:35:09.310]             setwd(...future.workdir)
[13:35:09.310]         {
[13:35:09.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:09.310]                 ...future.oldOptions$nwarnings <- NULL
[13:35:09.310]             }
[13:35:09.310]             base::options(...future.oldOptions)
[13:35:09.310]             if (.Platform$OS.type == "windows") {
[13:35:09.310]                 old_names <- names(...future.oldEnvVars)
[13:35:09.310]                 envs <- base::Sys.getenv()
[13:35:09.310]                 names <- names(envs)
[13:35:09.310]                 common <- intersect(names, old_names)
[13:35:09.310]                 added <- setdiff(names, old_names)
[13:35:09.310]                 removed <- setdiff(old_names, names)
[13:35:09.310]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:09.310]                   envs[common]]
[13:35:09.310]                 NAMES <- toupper(changed)
[13:35:09.310]                 args <- list()
[13:35:09.310]                 for (kk in seq_along(NAMES)) {
[13:35:09.310]                   name <- changed[[kk]]
[13:35:09.310]                   NAME <- NAMES[[kk]]
[13:35:09.310]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:09.310]                     next
[13:35:09.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:09.310]                 }
[13:35:09.310]                 NAMES <- toupper(added)
[13:35:09.310]                 for (kk in seq_along(NAMES)) {
[13:35:09.310]                   name <- added[[kk]]
[13:35:09.310]                   NAME <- NAMES[[kk]]
[13:35:09.310]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:09.310]                     next
[13:35:09.310]                   args[[name]] <- ""
[13:35:09.310]                 }
[13:35:09.310]                 NAMES <- toupper(removed)
[13:35:09.310]                 for (kk in seq_along(NAMES)) {
[13:35:09.310]                   name <- removed[[kk]]
[13:35:09.310]                   NAME <- NAMES[[kk]]
[13:35:09.310]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:09.310]                     next
[13:35:09.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:09.310]                 }
[13:35:09.310]                 if (length(args) > 0) 
[13:35:09.310]                   base::do.call(base::Sys.setenv, args = args)
[13:35:09.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:09.310]             }
[13:35:09.310]             else {
[13:35:09.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:09.310]             }
[13:35:09.310]             {
[13:35:09.310]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:09.310]                   0L) {
[13:35:09.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:09.310]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:09.310]                   base::options(opts)
[13:35:09.310]                 }
[13:35:09.310]                 {
[13:35:09.310]                   {
[13:35:09.310]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:09.310]                     NULL
[13:35:09.310]                   }
[13:35:09.310]                   options(future.plan = NULL)
[13:35:09.310]                   if (is.na(NA_character_)) 
[13:35:09.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:09.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:09.310]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:09.310]                     .init = FALSE)
[13:35:09.310]                 }
[13:35:09.310]             }
[13:35:09.310]         }
[13:35:09.310]     })
[13:35:09.310]     if (TRUE) {
[13:35:09.310]         base::sink(type = "output", split = FALSE)
[13:35:09.310]         if (TRUE) {
[13:35:09.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:09.310]         }
[13:35:09.310]         else {
[13:35:09.310]             ...future.result["stdout"] <- base::list(NULL)
[13:35:09.310]         }
[13:35:09.310]         base::close(...future.stdout)
[13:35:09.310]         ...future.stdout <- NULL
[13:35:09.310]     }
[13:35:09.310]     ...future.result$conditions <- ...future.conditions
[13:35:09.310]     ...future.result$finished <- base::Sys.time()
[13:35:09.310]     ...future.result
[13:35:09.310] }
[13:35:09.362] MultisessionFuture started
[13:35:09.363] result() for ClusterFuture ...
[13:35:09.363] receiveMessageFromWorker() for ClusterFuture ...
[13:35:09.363] - Validating connection of MultisessionFuture
[13:35:09.395] - received message: FutureResult
[13:35:09.396] - Received FutureResult
[13:35:09.396] - Erased future from FutureRegistry
[13:35:09.396] result() for ClusterFuture ...
[13:35:09.396] - result already collected: FutureResult
[13:35:09.396] result() for ClusterFuture ... done
[13:35:09.396] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:09.396] result() for ClusterFuture ... done
[13:35:09.397] result() for ClusterFuture ...
[13:35:09.397] - result already collected: FutureResult
[13:35:09.397] result() for ClusterFuture ... done
[13:35:09.397] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[13:35:09.401] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[13:35:09.404] future_lapply() ...
[13:35:09.410] Number of chunks: 2
[13:35:09.410] getGlobalsAndPackagesXApply() ...
[13:35:09.410]  - future.globals: TRUE
[13:35:09.410] getGlobalsAndPackages() ...
[13:35:09.411] Searching for globals...
[13:35:09.414] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:09.415] Searching for globals ... DONE
[13:35:09.415] Resolving globals: FALSE
[13:35:09.416] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[13:35:09.416] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:09.416] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:09.417] - packages: [1] ‘future.apply’
[13:35:09.417] getGlobalsAndPackages() ... DONE
[13:35:09.417]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:09.417]  - needed namespaces: [n=1] ‘future.apply’
[13:35:09.417] Finding globals ... DONE
[13:35:09.417]  - use_args: TRUE
[13:35:09.417]  - Getting '...' globals ...
[13:35:09.418] resolve() on list ...
[13:35:09.418]  recursive: 0
[13:35:09.418]  length: 1
[13:35:09.418]  elements: ‘...’
[13:35:09.418]  length: 0 (resolved future 1)
[13:35:09.418] resolve() on list ... DONE
[13:35:09.418]    - '...' content: [n=0] 
[13:35:09.419] List of 1
[13:35:09.419]  $ ...: list()
[13:35:09.419]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:09.419]  - attr(*, "where")=List of 1
[13:35:09.419]   ..$ ...:<environment: 0x5574d1d6c210> 
[13:35:09.419]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:09.419]  - attr(*, "resolved")= logi TRUE
[13:35:09.419]  - attr(*, "total_size")= num NA
[13:35:09.422]  - Getting '...' globals ... DONE
[13:35:09.422] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:09.422] List of 8
[13:35:09.422]  $ ...future.FUN:function (x, ...)  
[13:35:09.422]  $ x_FUN        :function (x)  
[13:35:09.422]  $ times        : int 1
[13:35:09.422]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:09.422]  $ stop_if_not  :function (...)  
[13:35:09.422]  $ dim          : NULL
[13:35:09.422]  $ valid_types  : chr "character"
[13:35:09.422]  $ ...          : list()
[13:35:09.422]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:09.422]  - attr(*, "where")=List of 8
[13:35:09.422]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:09.422]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:09.422]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:09.422]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:09.422]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:09.422]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:09.422]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:09.422]   ..$ ...          :<environment: 0x5574d1d6c210> 
[13:35:09.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:09.422]  - attr(*, "resolved")= logi FALSE
[13:35:09.422]  - attr(*, "total_size")= num 94208
[13:35:09.429] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:09.429] getGlobalsAndPackagesXApply() ... DONE
[13:35:09.429] Number of futures (= number of chunks): 2
[13:35:09.429] Launching 2 futures (chunks) ...
[13:35:09.429] Chunk #1 of 2 ...
[13:35:09.430]  - Finding globals in 'X' for chunk #1 ...
[13:35:09.430] getGlobalsAndPackages() ...
[13:35:09.430] Searching for globals...
[13:35:09.430] 
[13:35:09.430] Searching for globals ... DONE
[13:35:09.430] - globals: [0] <none>
[13:35:09.430] getGlobalsAndPackages() ... DONE
[13:35:09.431]    + additional globals found: [n=0] 
[13:35:09.431]    + additional namespaces needed: [n=0] 
[13:35:09.431]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:09.431]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:09.431]  - seeds: <none>
[13:35:09.431]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:09.431] getGlobalsAndPackages() ...
[13:35:09.431] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:09.432] Resolving globals: FALSE
[13:35:09.432] Tweak future expression to call with '...' arguments ...
[13:35:09.432] {
[13:35:09.432]     do.call(function(...) {
[13:35:09.432]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:09.432]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:09.432]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:09.432]             on.exit(options(oopts), add = TRUE)
[13:35:09.432]         }
[13:35:09.432]         {
[13:35:09.432]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:09.432]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:09.432]                 ...future.FUN(...future.X_jj, ...)
[13:35:09.432]             })
[13:35:09.432]         }
[13:35:09.432]     }, args = future.call.arguments)
[13:35:09.432] }
[13:35:09.432] Tweak future expression to call with '...' arguments ... DONE
[13:35:09.433] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:09.433] - packages: [1] ‘future.apply’
[13:35:09.433] getGlobalsAndPackages() ... DONE
[13:35:09.433] run() for ‘Future’ ...
[13:35:09.434] - state: ‘created’
[13:35:09.434] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:09.448] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:09.448] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:09.449]   - Field: ‘node’
[13:35:09.449]   - Field: ‘label’
[13:35:09.449]   - Field: ‘local’
[13:35:09.449]   - Field: ‘owner’
[13:35:09.449]   - Field: ‘envir’
[13:35:09.449]   - Field: ‘workers’
[13:35:09.449]   - Field: ‘packages’
[13:35:09.449]   - Field: ‘gc’
[13:35:09.449]   - Field: ‘conditions’
[13:35:09.449]   - Field: ‘persistent’
[13:35:09.450]   - Field: ‘expr’
[13:35:09.450]   - Field: ‘uuid’
[13:35:09.450]   - Field: ‘seed’
[13:35:09.450]   - Field: ‘version’
[13:35:09.450]   - Field: ‘result’
[13:35:09.450]   - Field: ‘asynchronous’
[13:35:09.450]   - Field: ‘calls’
[13:35:09.450]   - Field: ‘globals’
[13:35:09.451]   - Field: ‘stdout’
[13:35:09.452]   - Field: ‘earlySignal’
[13:35:09.452]   - Field: ‘lazy’
[13:35:09.452]   - Field: ‘state’
[13:35:09.453] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:09.453] - Launch lazy future ...
[13:35:09.453] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:09.453] Packages needed by future strategies (n = 0): <none>
[13:35:09.454] {
[13:35:09.454]     {
[13:35:09.454]         {
[13:35:09.454]             ...future.startTime <- base::Sys.time()
[13:35:09.454]             {
[13:35:09.454]                 {
[13:35:09.454]                   {
[13:35:09.454]                     {
[13:35:09.454]                       {
[13:35:09.454]                         base::local({
[13:35:09.454]                           has_future <- base::requireNamespace("future", 
[13:35:09.454]                             quietly = TRUE)
[13:35:09.454]                           if (has_future) {
[13:35:09.454]                             ns <- base::getNamespace("future")
[13:35:09.454]                             version <- ns[[".package"]][["version"]]
[13:35:09.454]                             if (is.null(version)) 
[13:35:09.454]                               version <- utils::packageVersion("future")
[13:35:09.454]                           }
[13:35:09.454]                           else {
[13:35:09.454]                             version <- NULL
[13:35:09.454]                           }
[13:35:09.454]                           if (!has_future || version < "1.8.0") {
[13:35:09.454]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:09.454]                               "", base::R.version$version.string), 
[13:35:09.454]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:09.454]                                 base::R.version$platform, 8 * 
[13:35:09.454]                                   base::.Machine$sizeof.pointer), 
[13:35:09.454]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:09.454]                                 "release", "version")], collapse = " "), 
[13:35:09.454]                               hostname = base::Sys.info()[["nodename"]])
[13:35:09.454]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:09.454]                               info)
[13:35:09.454]                             info <- base::paste(info, collapse = "; ")
[13:35:09.454]                             if (!has_future) {
[13:35:09.454]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:09.454]                                 info)
[13:35:09.454]                             }
[13:35:09.454]                             else {
[13:35:09.454]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:09.454]                                 info, version)
[13:35:09.454]                             }
[13:35:09.454]                             base::stop(msg)
[13:35:09.454]                           }
[13:35:09.454]                         })
[13:35:09.454]                       }
[13:35:09.454]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:09.454]                       base::options(mc.cores = 1L)
[13:35:09.454]                     }
[13:35:09.454]                     base::local({
[13:35:09.454]                       for (pkg in "future.apply") {
[13:35:09.454]                         base::loadNamespace(pkg)
[13:35:09.454]                         base::library(pkg, character.only = TRUE)
[13:35:09.454]                       }
[13:35:09.454]                     })
[13:35:09.454]                   }
[13:35:09.454]                   ...future.strategy.old <- future::plan("list")
[13:35:09.454]                   options(future.plan = NULL)
[13:35:09.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:09.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:09.454]                 }
[13:35:09.454]                 ...future.workdir <- getwd()
[13:35:09.454]             }
[13:35:09.454]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:09.454]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:09.454]         }
[13:35:09.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:09.454]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:09.454]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:09.454]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:09.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:09.454]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:09.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:09.454]             base::names(...future.oldOptions))
[13:35:09.454]     }
[13:35:09.454]     if (FALSE) {
[13:35:09.454]     }
[13:35:09.454]     else {
[13:35:09.454]         if (TRUE) {
[13:35:09.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:09.454]                 open = "w")
[13:35:09.454]         }
[13:35:09.454]         else {
[13:35:09.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:09.454]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:09.454]         }
[13:35:09.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:09.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:09.454]             base::sink(type = "output", split = FALSE)
[13:35:09.454]             base::close(...future.stdout)
[13:35:09.454]         }, add = TRUE)
[13:35:09.454]     }
[13:35:09.454]     ...future.frame <- base::sys.nframe()
[13:35:09.454]     ...future.conditions <- base::list()
[13:35:09.454]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:09.454]     if (FALSE) {
[13:35:09.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:09.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:09.454]     }
[13:35:09.454]     ...future.result <- base::tryCatch({
[13:35:09.454]         base::withCallingHandlers({
[13:35:09.454]             ...future.value <- base::withVisible(base::local({
[13:35:09.454]                 ...future.makeSendCondition <- base::local({
[13:35:09.454]                   sendCondition <- NULL
[13:35:09.454]                   function(frame = 1L) {
[13:35:09.454]                     if (is.function(sendCondition)) 
[13:35:09.454]                       return(sendCondition)
[13:35:09.454]                     ns <- getNamespace("parallel")
[13:35:09.454]                     if (exists("sendData", mode = "function", 
[13:35:09.454]                       envir = ns)) {
[13:35:09.454]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:09.454]                         envir = ns)
[13:35:09.454]                       envir <- sys.frame(frame)
[13:35:09.454]                       master <- NULL
[13:35:09.454]                       while (!identical(envir, .GlobalEnv) && 
[13:35:09.454]                         !identical(envir, emptyenv())) {
[13:35:09.454]                         if (exists("master", mode = "list", envir = envir, 
[13:35:09.454]                           inherits = FALSE)) {
[13:35:09.454]                           master <- get("master", mode = "list", 
[13:35:09.454]                             envir = envir, inherits = FALSE)
[13:35:09.454]                           if (inherits(master, c("SOCKnode", 
[13:35:09.454]                             "SOCK0node"))) {
[13:35:09.454]                             sendCondition <<- function(cond) {
[13:35:09.454]                               data <- list(type = "VALUE", value = cond, 
[13:35:09.454]                                 success = TRUE)
[13:35:09.454]                               parallel_sendData(master, data)
[13:35:09.454]                             }
[13:35:09.454]                             return(sendCondition)
[13:35:09.454]                           }
[13:35:09.454]                         }
[13:35:09.454]                         frame <- frame + 1L
[13:35:09.454]                         envir <- sys.frame(frame)
[13:35:09.454]                       }
[13:35:09.454]                     }
[13:35:09.454]                     sendCondition <<- function(cond) NULL
[13:35:09.454]                   }
[13:35:09.454]                 })
[13:35:09.454]                 withCallingHandlers({
[13:35:09.454]                   {
[13:35:09.454]                     do.call(function(...) {
[13:35:09.454]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:09.454]                       if (!identical(...future.globals.maxSize.org, 
[13:35:09.454]                         ...future.globals.maxSize)) {
[13:35:09.454]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:09.454]                         on.exit(options(oopts), add = TRUE)
[13:35:09.454]                       }
[13:35:09.454]                       {
[13:35:09.454]                         lapply(seq_along(...future.elements_ii), 
[13:35:09.454]                           FUN = function(jj) {
[13:35:09.454]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:09.454]                             ...future.FUN(...future.X_jj, ...)
[13:35:09.454]                           })
[13:35:09.454]                       }
[13:35:09.454]                     }, args = future.call.arguments)
[13:35:09.454]                   }
[13:35:09.454]                 }, immediateCondition = function(cond) {
[13:35:09.454]                   sendCondition <- ...future.makeSendCondition()
[13:35:09.454]                   sendCondition(cond)
[13:35:09.454]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:09.454]                   {
[13:35:09.454]                     inherits <- base::inherits
[13:35:09.454]                     invokeRestart <- base::invokeRestart
[13:35:09.454]                     is.null <- base::is.null
[13:35:09.454]                     muffled <- FALSE
[13:35:09.454]                     if (inherits(cond, "message")) {
[13:35:09.454]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:09.454]                       if (muffled) 
[13:35:09.454]                         invokeRestart("muffleMessage")
[13:35:09.454]                     }
[13:35:09.454]                     else if (inherits(cond, "warning")) {
[13:35:09.454]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:09.454]                       if (muffled) 
[13:35:09.454]                         invokeRestart("muffleWarning")
[13:35:09.454]                     }
[13:35:09.454]                     else if (inherits(cond, "condition")) {
[13:35:09.454]                       if (!is.null(pattern)) {
[13:35:09.454]                         computeRestarts <- base::computeRestarts
[13:35:09.454]                         grepl <- base::grepl
[13:35:09.454]                         restarts <- computeRestarts(cond)
[13:35:09.454]                         for (restart in restarts) {
[13:35:09.454]                           name <- restart$name
[13:35:09.454]                           if (is.null(name)) 
[13:35:09.454]                             next
[13:35:09.454]                           if (!grepl(pattern, name)) 
[13:35:09.454]                             next
[13:35:09.454]                           invokeRestart(restart)
[13:35:09.454]                           muffled <- TRUE
[13:35:09.454]                           break
[13:35:09.454]                         }
[13:35:09.454]                       }
[13:35:09.454]                     }
[13:35:09.454]                     invisible(muffled)
[13:35:09.454]                   }
[13:35:09.454]                   muffleCondition(cond)
[13:35:09.454]                 })
[13:35:09.454]             }))
[13:35:09.454]             future::FutureResult(value = ...future.value$value, 
[13:35:09.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:09.454]                   ...future.rng), globalenv = if (FALSE) 
[13:35:09.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:09.454]                     ...future.globalenv.names))
[13:35:09.454]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:09.454]         }, condition = base::local({
[13:35:09.454]             c <- base::c
[13:35:09.454]             inherits <- base::inherits
[13:35:09.454]             invokeRestart <- base::invokeRestart
[13:35:09.454]             length <- base::length
[13:35:09.454]             list <- base::list
[13:35:09.454]             seq.int <- base::seq.int
[13:35:09.454]             signalCondition <- base::signalCondition
[13:35:09.454]             sys.calls <- base::sys.calls
[13:35:09.454]             `[[` <- base::`[[`
[13:35:09.454]             `+` <- base::`+`
[13:35:09.454]             `<<-` <- base::`<<-`
[13:35:09.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:09.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:09.454]                   3L)]
[13:35:09.454]             }
[13:35:09.454]             function(cond) {
[13:35:09.454]                 is_error <- inherits(cond, "error")
[13:35:09.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:09.454]                   NULL)
[13:35:09.454]                 if (is_error) {
[13:35:09.454]                   sessionInformation <- function() {
[13:35:09.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:09.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:09.454]                       search = base::search(), system = base::Sys.info())
[13:35:09.454]                   }
[13:35:09.454]                   ...future.conditions[[length(...future.conditions) + 
[13:35:09.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:09.454]                     cond$call), session = sessionInformation(), 
[13:35:09.454]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:09.454]                   signalCondition(cond)
[13:35:09.454]                 }
[13:35:09.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:09.454]                 "immediateCondition"))) {
[13:35:09.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:09.454]                   ...future.conditions[[length(...future.conditions) + 
[13:35:09.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:09.454]                   if (TRUE && !signal) {
[13:35:09.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:09.454]                     {
[13:35:09.454]                       inherits <- base::inherits
[13:35:09.454]                       invokeRestart <- base::invokeRestart
[13:35:09.454]                       is.null <- base::is.null
[13:35:09.454]                       muffled <- FALSE
[13:35:09.454]                       if (inherits(cond, "message")) {
[13:35:09.454]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:09.454]                         if (muffled) 
[13:35:09.454]                           invokeRestart("muffleMessage")
[13:35:09.454]                       }
[13:35:09.454]                       else if (inherits(cond, "warning")) {
[13:35:09.454]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:09.454]                         if (muffled) 
[13:35:09.454]                           invokeRestart("muffleWarning")
[13:35:09.454]                       }
[13:35:09.454]                       else if (inherits(cond, "condition")) {
[13:35:09.454]                         if (!is.null(pattern)) {
[13:35:09.454]                           computeRestarts <- base::computeRestarts
[13:35:09.454]                           grepl <- base::grepl
[13:35:09.454]                           restarts <- computeRestarts(cond)
[13:35:09.454]                           for (restart in restarts) {
[13:35:09.454]                             name <- restart$name
[13:35:09.454]                             if (is.null(name)) 
[13:35:09.454]                               next
[13:35:09.454]                             if (!grepl(pattern, name)) 
[13:35:09.454]                               next
[13:35:09.454]                             invokeRestart(restart)
[13:35:09.454]                             muffled <- TRUE
[13:35:09.454]                             break
[13:35:09.454]                           }
[13:35:09.454]                         }
[13:35:09.454]                       }
[13:35:09.454]                       invisible(muffled)
[13:35:09.454]                     }
[13:35:09.454]                     muffleCondition(cond, pattern = "^muffle")
[13:35:09.454]                   }
[13:35:09.454]                 }
[13:35:09.454]                 else {
[13:35:09.454]                   if (TRUE) {
[13:35:09.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:09.454]                     {
[13:35:09.454]                       inherits <- base::inherits
[13:35:09.454]                       invokeRestart <- base::invokeRestart
[13:35:09.454]                       is.null <- base::is.null
[13:35:09.454]                       muffled <- FALSE
[13:35:09.454]                       if (inherits(cond, "message")) {
[13:35:09.454]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:09.454]                         if (muffled) 
[13:35:09.454]                           invokeRestart("muffleMessage")
[13:35:09.454]                       }
[13:35:09.454]                       else if (inherits(cond, "warning")) {
[13:35:09.454]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:09.454]                         if (muffled) 
[13:35:09.454]                           invokeRestart("muffleWarning")
[13:35:09.454]                       }
[13:35:09.454]                       else if (inherits(cond, "condition")) {
[13:35:09.454]                         if (!is.null(pattern)) {
[13:35:09.454]                           computeRestarts <- base::computeRestarts
[13:35:09.454]                           grepl <- base::grepl
[13:35:09.454]                           restarts <- computeRestarts(cond)
[13:35:09.454]                           for (restart in restarts) {
[13:35:09.454]                             name <- restart$name
[13:35:09.454]                             if (is.null(name)) 
[13:35:09.454]                               next
[13:35:09.454]                             if (!grepl(pattern, name)) 
[13:35:09.454]                               next
[13:35:09.454]                             invokeRestart(restart)
[13:35:09.454]                             muffled <- TRUE
[13:35:09.454]                             break
[13:35:09.454]                           }
[13:35:09.454]                         }
[13:35:09.454]                       }
[13:35:09.454]                       invisible(muffled)
[13:35:09.454]                     }
[13:35:09.454]                     muffleCondition(cond, pattern = "^muffle")
[13:35:09.454]                   }
[13:35:09.454]                 }
[13:35:09.454]             }
[13:35:09.454]         }))
[13:35:09.454]     }, error = function(ex) {
[13:35:09.454]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:09.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:09.454]                 ...future.rng), started = ...future.startTime, 
[13:35:09.454]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:09.454]             version = "1.8"), class = "FutureResult")
[13:35:09.454]     }, finally = {
[13:35:09.454]         if (!identical(...future.workdir, getwd())) 
[13:35:09.454]             setwd(...future.workdir)
[13:35:09.454]         {
[13:35:09.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:09.454]                 ...future.oldOptions$nwarnings <- NULL
[13:35:09.454]             }
[13:35:09.454]             base::options(...future.oldOptions)
[13:35:09.454]             if (.Platform$OS.type == "windows") {
[13:35:09.454]                 old_names <- names(...future.oldEnvVars)
[13:35:09.454]                 envs <- base::Sys.getenv()
[13:35:09.454]                 names <- names(envs)
[13:35:09.454]                 common <- intersect(names, old_names)
[13:35:09.454]                 added <- setdiff(names, old_names)
[13:35:09.454]                 removed <- setdiff(old_names, names)
[13:35:09.454]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:09.454]                   envs[common]]
[13:35:09.454]                 NAMES <- toupper(changed)
[13:35:09.454]                 args <- list()
[13:35:09.454]                 for (kk in seq_along(NAMES)) {
[13:35:09.454]                   name <- changed[[kk]]
[13:35:09.454]                   NAME <- NAMES[[kk]]
[13:35:09.454]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:09.454]                     next
[13:35:09.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:09.454]                 }
[13:35:09.454]                 NAMES <- toupper(added)
[13:35:09.454]                 for (kk in seq_along(NAMES)) {
[13:35:09.454]                   name <- added[[kk]]
[13:35:09.454]                   NAME <- NAMES[[kk]]
[13:35:09.454]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:09.454]                     next
[13:35:09.454]                   args[[name]] <- ""
[13:35:09.454]                 }
[13:35:09.454]                 NAMES <- toupper(removed)
[13:35:09.454]                 for (kk in seq_along(NAMES)) {
[13:35:09.454]                   name <- removed[[kk]]
[13:35:09.454]                   NAME <- NAMES[[kk]]
[13:35:09.454]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:09.454]                     next
[13:35:09.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:09.454]                 }
[13:35:09.454]                 if (length(args) > 0) 
[13:35:09.454]                   base::do.call(base::Sys.setenv, args = args)
[13:35:09.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:09.454]             }
[13:35:09.454]             else {
[13:35:09.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:09.454]             }
[13:35:09.454]             {
[13:35:09.454]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:09.454]                   0L) {
[13:35:09.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:09.454]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:09.454]                   base::options(opts)
[13:35:09.454]                 }
[13:35:09.454]                 {
[13:35:09.454]                   {
[13:35:09.454]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:09.454]                     NULL
[13:35:09.454]                   }
[13:35:09.454]                   options(future.plan = NULL)
[13:35:09.454]                   if (is.na(NA_character_)) 
[13:35:09.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:09.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:09.454]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:09.454]                     .init = FALSE)
[13:35:09.454]                 }
[13:35:09.454]             }
[13:35:09.454]         }
[13:35:09.454]     })
[13:35:09.454]     if (TRUE) {
[13:35:09.454]         base::sink(type = "output", split = FALSE)
[13:35:09.454]         if (TRUE) {
[13:35:09.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:09.454]         }
[13:35:09.454]         else {
[13:35:09.454]             ...future.result["stdout"] <- base::list(NULL)
[13:35:09.454]         }
[13:35:09.454]         base::close(...future.stdout)
[13:35:09.454]         ...future.stdout <- NULL
[13:35:09.454]     }
[13:35:09.454]     ...future.result$conditions <- ...future.conditions
[13:35:09.454]     ...future.result$finished <- base::Sys.time()
[13:35:09.454]     ...future.result
[13:35:09.454] }
[13:35:09.457] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[13:35:09.457] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:09.498] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:09.499] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:35:09.499] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:35:09.499] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:09.500] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:09.500] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:09.542] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:09.543] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:09.586] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:09.587] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:09.587] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:09.587] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[13:35:09.588] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[13:35:09.588] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:09.588] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:09.589] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[13:35:09.589] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[13:35:09.589] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:09.589] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:09.590] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:09.590] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:09.590] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[13:35:09.591] MultisessionFuture started
[13:35:09.591] - Launch lazy future ... done
[13:35:09.591] run() for ‘MultisessionFuture’ ... done
[13:35:09.591] Created future:
[13:35:09.591] MultisessionFuture:
[13:35:09.591] Label: ‘future_vapply-1’
[13:35:09.591] Expression:
[13:35:09.591] {
[13:35:09.591]     do.call(function(...) {
[13:35:09.591]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:09.591]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:09.591]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:09.591]             on.exit(options(oopts), add = TRUE)
[13:35:09.591]         }
[13:35:09.591]         {
[13:35:09.591]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:09.591]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:09.591]                 ...future.FUN(...future.X_jj, ...)
[13:35:09.591]             })
[13:35:09.591]         }
[13:35:09.591]     }, args = future.call.arguments)
[13:35:09.591] }
[13:35:09.591] Lazy evaluation: FALSE
[13:35:09.591] Asynchronous evaluation: TRUE
[13:35:09.591] Local evaluation: TRUE
[13:35:09.591] Environment: R_GlobalEnv
[13:35:09.591] Capture standard output: TRUE
[13:35:09.591] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:09.591] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:09.591] Packages: 1 packages (‘future.apply’)
[13:35:09.591] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:09.591] Resolved: FALSE
[13:35:09.591] Value: <not collected>
[13:35:09.591] Conditions captured: <none>
[13:35:09.591] Early signaling: FALSE
[13:35:09.591] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:09.591] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:09.604] Chunk #1 of 2 ... DONE
[13:35:09.604] Chunk #2 of 2 ...
[13:35:09.604]  - Finding globals in 'X' for chunk #2 ...
[13:35:09.604] getGlobalsAndPackages() ...
[13:35:09.604] Searching for globals...
[13:35:09.605] 
[13:35:09.605] Searching for globals ... DONE
[13:35:09.605] - globals: [0] <none>
[13:35:09.605] getGlobalsAndPackages() ... DONE
[13:35:09.605]    + additional globals found: [n=0] 
[13:35:09.605]    + additional namespaces needed: [n=0] 
[13:35:09.605]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:09.605]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:09.606]  - seeds: <none>
[13:35:09.606]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:09.606] getGlobalsAndPackages() ...
[13:35:09.606] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:09.606] Resolving globals: FALSE
[13:35:09.606] Tweak future expression to call with '...' arguments ...
[13:35:09.606] {
[13:35:09.606]     do.call(function(...) {
[13:35:09.606]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:09.606]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:09.606]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:09.606]             on.exit(options(oopts), add = TRUE)
[13:35:09.606]         }
[13:35:09.606]         {
[13:35:09.606]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:09.606]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:09.606]                 ...future.FUN(...future.X_jj, ...)
[13:35:09.606]             })
[13:35:09.606]         }
[13:35:09.606]     }, args = future.call.arguments)
[13:35:09.606] }
[13:35:09.607] Tweak future expression to call with '...' arguments ... DONE
[13:35:09.607] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:09.607] - packages: [1] ‘future.apply’
[13:35:09.608] getGlobalsAndPackages() ... DONE
[13:35:09.608] run() for ‘Future’ ...
[13:35:09.608] - state: ‘created’
[13:35:09.608] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:09.623] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:09.623] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:09.623]   - Field: ‘node’
[13:35:09.623]   - Field: ‘label’
[13:35:09.623]   - Field: ‘local’
[13:35:09.624]   - Field: ‘owner’
[13:35:09.624]   - Field: ‘envir’
[13:35:09.624]   - Field: ‘workers’
[13:35:09.624]   - Field: ‘packages’
[13:35:09.624]   - Field: ‘gc’
[13:35:09.624]   - Field: ‘conditions’
[13:35:09.624]   - Field: ‘persistent’
[13:35:09.624]   - Field: ‘expr’
[13:35:09.624]   - Field: ‘uuid’
[13:35:09.625]   - Field: ‘seed’
[13:35:09.625]   - Field: ‘version’
[13:35:09.625]   - Field: ‘result’
[13:35:09.625]   - Field: ‘asynchronous’
[13:35:09.625]   - Field: ‘calls’
[13:35:09.625]   - Field: ‘globals’
[13:35:09.625]   - Field: ‘stdout’
[13:35:09.625]   - Field: ‘earlySignal’
[13:35:09.626]   - Field: ‘lazy’
[13:35:09.626]   - Field: ‘state’
[13:35:09.626] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:09.626] - Launch lazy future ...
[13:35:09.626] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:09.626] Packages needed by future strategies (n = 0): <none>
[13:35:09.627] {
[13:35:09.627]     {
[13:35:09.627]         {
[13:35:09.627]             ...future.startTime <- base::Sys.time()
[13:35:09.627]             {
[13:35:09.627]                 {
[13:35:09.627]                   {
[13:35:09.627]                     {
[13:35:09.627]                       {
[13:35:09.627]                         base::local({
[13:35:09.627]                           has_future <- base::requireNamespace("future", 
[13:35:09.627]                             quietly = TRUE)
[13:35:09.627]                           if (has_future) {
[13:35:09.627]                             ns <- base::getNamespace("future")
[13:35:09.627]                             version <- ns[[".package"]][["version"]]
[13:35:09.627]                             if (is.null(version)) 
[13:35:09.627]                               version <- utils::packageVersion("future")
[13:35:09.627]                           }
[13:35:09.627]                           else {
[13:35:09.627]                             version <- NULL
[13:35:09.627]                           }
[13:35:09.627]                           if (!has_future || version < "1.8.0") {
[13:35:09.627]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:09.627]                               "", base::R.version$version.string), 
[13:35:09.627]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:09.627]                                 base::R.version$platform, 8 * 
[13:35:09.627]                                   base::.Machine$sizeof.pointer), 
[13:35:09.627]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:09.627]                                 "release", "version")], collapse = " "), 
[13:35:09.627]                               hostname = base::Sys.info()[["nodename"]])
[13:35:09.627]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:09.627]                               info)
[13:35:09.627]                             info <- base::paste(info, collapse = "; ")
[13:35:09.627]                             if (!has_future) {
[13:35:09.627]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:09.627]                                 info)
[13:35:09.627]                             }
[13:35:09.627]                             else {
[13:35:09.627]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:09.627]                                 info, version)
[13:35:09.627]                             }
[13:35:09.627]                             base::stop(msg)
[13:35:09.627]                           }
[13:35:09.627]                         })
[13:35:09.627]                       }
[13:35:09.627]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:09.627]                       base::options(mc.cores = 1L)
[13:35:09.627]                     }
[13:35:09.627]                     base::local({
[13:35:09.627]                       for (pkg in "future.apply") {
[13:35:09.627]                         base::loadNamespace(pkg)
[13:35:09.627]                         base::library(pkg, character.only = TRUE)
[13:35:09.627]                       }
[13:35:09.627]                     })
[13:35:09.627]                   }
[13:35:09.627]                   ...future.strategy.old <- future::plan("list")
[13:35:09.627]                   options(future.plan = NULL)
[13:35:09.627]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:09.627]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:09.627]                 }
[13:35:09.627]                 ...future.workdir <- getwd()
[13:35:09.627]             }
[13:35:09.627]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:09.627]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:09.627]         }
[13:35:09.627]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:09.627]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:09.627]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:09.627]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:09.627]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:09.627]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:09.627]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:09.627]             base::names(...future.oldOptions))
[13:35:09.627]     }
[13:35:09.627]     if (FALSE) {
[13:35:09.627]     }
[13:35:09.627]     else {
[13:35:09.627]         if (TRUE) {
[13:35:09.627]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:09.627]                 open = "w")
[13:35:09.627]         }
[13:35:09.627]         else {
[13:35:09.627]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:09.627]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:09.627]         }
[13:35:09.627]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:09.627]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:09.627]             base::sink(type = "output", split = FALSE)
[13:35:09.627]             base::close(...future.stdout)
[13:35:09.627]         }, add = TRUE)
[13:35:09.627]     }
[13:35:09.627]     ...future.frame <- base::sys.nframe()
[13:35:09.627]     ...future.conditions <- base::list()
[13:35:09.627]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:09.627]     if (FALSE) {
[13:35:09.627]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:09.627]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:09.627]     }
[13:35:09.627]     ...future.result <- base::tryCatch({
[13:35:09.627]         base::withCallingHandlers({
[13:35:09.627]             ...future.value <- base::withVisible(base::local({
[13:35:09.627]                 ...future.makeSendCondition <- base::local({
[13:35:09.627]                   sendCondition <- NULL
[13:35:09.627]                   function(frame = 1L) {
[13:35:09.627]                     if (is.function(sendCondition)) 
[13:35:09.627]                       return(sendCondition)
[13:35:09.627]                     ns <- getNamespace("parallel")
[13:35:09.627]                     if (exists("sendData", mode = "function", 
[13:35:09.627]                       envir = ns)) {
[13:35:09.627]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:09.627]                         envir = ns)
[13:35:09.627]                       envir <- sys.frame(frame)
[13:35:09.627]                       master <- NULL
[13:35:09.627]                       while (!identical(envir, .GlobalEnv) && 
[13:35:09.627]                         !identical(envir, emptyenv())) {
[13:35:09.627]                         if (exists("master", mode = "list", envir = envir, 
[13:35:09.627]                           inherits = FALSE)) {
[13:35:09.627]                           master <- get("master", mode = "list", 
[13:35:09.627]                             envir = envir, inherits = FALSE)
[13:35:09.627]                           if (inherits(master, c("SOCKnode", 
[13:35:09.627]                             "SOCK0node"))) {
[13:35:09.627]                             sendCondition <<- function(cond) {
[13:35:09.627]                               data <- list(type = "VALUE", value = cond, 
[13:35:09.627]                                 success = TRUE)
[13:35:09.627]                               parallel_sendData(master, data)
[13:35:09.627]                             }
[13:35:09.627]                             return(sendCondition)
[13:35:09.627]                           }
[13:35:09.627]                         }
[13:35:09.627]                         frame <- frame + 1L
[13:35:09.627]                         envir <- sys.frame(frame)
[13:35:09.627]                       }
[13:35:09.627]                     }
[13:35:09.627]                     sendCondition <<- function(cond) NULL
[13:35:09.627]                   }
[13:35:09.627]                 })
[13:35:09.627]                 withCallingHandlers({
[13:35:09.627]                   {
[13:35:09.627]                     do.call(function(...) {
[13:35:09.627]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:09.627]                       if (!identical(...future.globals.maxSize.org, 
[13:35:09.627]                         ...future.globals.maxSize)) {
[13:35:09.627]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:09.627]                         on.exit(options(oopts), add = TRUE)
[13:35:09.627]                       }
[13:35:09.627]                       {
[13:35:09.627]                         lapply(seq_along(...future.elements_ii), 
[13:35:09.627]                           FUN = function(jj) {
[13:35:09.627]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:09.627]                             ...future.FUN(...future.X_jj, ...)
[13:35:09.627]                           })
[13:35:09.627]                       }
[13:35:09.627]                     }, args = future.call.arguments)
[13:35:09.627]                   }
[13:35:09.627]                 }, immediateCondition = function(cond) {
[13:35:09.627]                   sendCondition <- ...future.makeSendCondition()
[13:35:09.627]                   sendCondition(cond)
[13:35:09.627]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:09.627]                   {
[13:35:09.627]                     inherits <- base::inherits
[13:35:09.627]                     invokeRestart <- base::invokeRestart
[13:35:09.627]                     is.null <- base::is.null
[13:35:09.627]                     muffled <- FALSE
[13:35:09.627]                     if (inherits(cond, "message")) {
[13:35:09.627]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:09.627]                       if (muffled) 
[13:35:09.627]                         invokeRestart("muffleMessage")
[13:35:09.627]                     }
[13:35:09.627]                     else if (inherits(cond, "warning")) {
[13:35:09.627]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:09.627]                       if (muffled) 
[13:35:09.627]                         invokeRestart("muffleWarning")
[13:35:09.627]                     }
[13:35:09.627]                     else if (inherits(cond, "condition")) {
[13:35:09.627]                       if (!is.null(pattern)) {
[13:35:09.627]                         computeRestarts <- base::computeRestarts
[13:35:09.627]                         grepl <- base::grepl
[13:35:09.627]                         restarts <- computeRestarts(cond)
[13:35:09.627]                         for (restart in restarts) {
[13:35:09.627]                           name <- restart$name
[13:35:09.627]                           if (is.null(name)) 
[13:35:09.627]                             next
[13:35:09.627]                           if (!grepl(pattern, name)) 
[13:35:09.627]                             next
[13:35:09.627]                           invokeRestart(restart)
[13:35:09.627]                           muffled <- TRUE
[13:35:09.627]                           break
[13:35:09.627]                         }
[13:35:09.627]                       }
[13:35:09.627]                     }
[13:35:09.627]                     invisible(muffled)
[13:35:09.627]                   }
[13:35:09.627]                   muffleCondition(cond)
[13:35:09.627]                 })
[13:35:09.627]             }))
[13:35:09.627]             future::FutureResult(value = ...future.value$value, 
[13:35:09.627]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:09.627]                   ...future.rng), globalenv = if (FALSE) 
[13:35:09.627]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:09.627]                     ...future.globalenv.names))
[13:35:09.627]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:09.627]         }, condition = base::local({
[13:35:09.627]             c <- base::c
[13:35:09.627]             inherits <- base::inherits
[13:35:09.627]             invokeRestart <- base::invokeRestart
[13:35:09.627]             length <- base::length
[13:35:09.627]             list <- base::list
[13:35:09.627]             seq.int <- base::seq.int
[13:35:09.627]             signalCondition <- base::signalCondition
[13:35:09.627]             sys.calls <- base::sys.calls
[13:35:09.627]             `[[` <- base::`[[`
[13:35:09.627]             `+` <- base::`+`
[13:35:09.627]             `<<-` <- base::`<<-`
[13:35:09.627]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:09.627]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:09.627]                   3L)]
[13:35:09.627]             }
[13:35:09.627]             function(cond) {
[13:35:09.627]                 is_error <- inherits(cond, "error")
[13:35:09.627]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:09.627]                   NULL)
[13:35:09.627]                 if (is_error) {
[13:35:09.627]                   sessionInformation <- function() {
[13:35:09.627]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:09.627]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:09.627]                       search = base::search(), system = base::Sys.info())
[13:35:09.627]                   }
[13:35:09.627]                   ...future.conditions[[length(...future.conditions) + 
[13:35:09.627]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:09.627]                     cond$call), session = sessionInformation(), 
[13:35:09.627]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:09.627]                   signalCondition(cond)
[13:35:09.627]                 }
[13:35:09.627]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:09.627]                 "immediateCondition"))) {
[13:35:09.627]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:09.627]                   ...future.conditions[[length(...future.conditions) + 
[13:35:09.627]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:09.627]                   if (TRUE && !signal) {
[13:35:09.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:09.627]                     {
[13:35:09.627]                       inherits <- base::inherits
[13:35:09.627]                       invokeRestart <- base::invokeRestart
[13:35:09.627]                       is.null <- base::is.null
[13:35:09.627]                       muffled <- FALSE
[13:35:09.627]                       if (inherits(cond, "message")) {
[13:35:09.627]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:09.627]                         if (muffled) 
[13:35:09.627]                           invokeRestart("muffleMessage")
[13:35:09.627]                       }
[13:35:09.627]                       else if (inherits(cond, "warning")) {
[13:35:09.627]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:09.627]                         if (muffled) 
[13:35:09.627]                           invokeRestart("muffleWarning")
[13:35:09.627]                       }
[13:35:09.627]                       else if (inherits(cond, "condition")) {
[13:35:09.627]                         if (!is.null(pattern)) {
[13:35:09.627]                           computeRestarts <- base::computeRestarts
[13:35:09.627]                           grepl <- base::grepl
[13:35:09.627]                           restarts <- computeRestarts(cond)
[13:35:09.627]                           for (restart in restarts) {
[13:35:09.627]                             name <- restart$name
[13:35:09.627]                             if (is.null(name)) 
[13:35:09.627]                               next
[13:35:09.627]                             if (!grepl(pattern, name)) 
[13:35:09.627]                               next
[13:35:09.627]                             invokeRestart(restart)
[13:35:09.627]                             muffled <- TRUE
[13:35:09.627]                             break
[13:35:09.627]                           }
[13:35:09.627]                         }
[13:35:09.627]                       }
[13:35:09.627]                       invisible(muffled)
[13:35:09.627]                     }
[13:35:09.627]                     muffleCondition(cond, pattern = "^muffle")
[13:35:09.627]                   }
[13:35:09.627]                 }
[13:35:09.627]                 else {
[13:35:09.627]                   if (TRUE) {
[13:35:09.627]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:09.627]                     {
[13:35:09.627]                       inherits <- base::inherits
[13:35:09.627]                       invokeRestart <- base::invokeRestart
[13:35:09.627]                       is.null <- base::is.null
[13:35:09.627]                       muffled <- FALSE
[13:35:09.627]                       if (inherits(cond, "message")) {
[13:35:09.627]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:09.627]                         if (muffled) 
[13:35:09.627]                           invokeRestart("muffleMessage")
[13:35:09.627]                       }
[13:35:09.627]                       else if (inherits(cond, "warning")) {
[13:35:09.627]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:09.627]                         if (muffled) 
[13:35:09.627]                           invokeRestart("muffleWarning")
[13:35:09.627]                       }
[13:35:09.627]                       else if (inherits(cond, "condition")) {
[13:35:09.627]                         if (!is.null(pattern)) {
[13:35:09.627]                           computeRestarts <- base::computeRestarts
[13:35:09.627]                           grepl <- base::grepl
[13:35:09.627]                           restarts <- computeRestarts(cond)
[13:35:09.627]                           for (restart in restarts) {
[13:35:09.627]                             name <- restart$name
[13:35:09.627]                             if (is.null(name)) 
[13:35:09.627]                               next
[13:35:09.627]                             if (!grepl(pattern, name)) 
[13:35:09.627]                               next
[13:35:09.627]                             invokeRestart(restart)
[13:35:09.627]                             muffled <- TRUE
[13:35:09.627]                             break
[13:35:09.627]                           }
[13:35:09.627]                         }
[13:35:09.627]                       }
[13:35:09.627]                       invisible(muffled)
[13:35:09.627]                     }
[13:35:09.627]                     muffleCondition(cond, pattern = "^muffle")
[13:35:09.627]                   }
[13:35:09.627]                 }
[13:35:09.627]             }
[13:35:09.627]         }))
[13:35:09.627]     }, error = function(ex) {
[13:35:09.627]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:09.627]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:09.627]                 ...future.rng), started = ...future.startTime, 
[13:35:09.627]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:09.627]             version = "1.8"), class = "FutureResult")
[13:35:09.627]     }, finally = {
[13:35:09.627]         if (!identical(...future.workdir, getwd())) 
[13:35:09.627]             setwd(...future.workdir)
[13:35:09.627]         {
[13:35:09.627]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:09.627]                 ...future.oldOptions$nwarnings <- NULL
[13:35:09.627]             }
[13:35:09.627]             base::options(...future.oldOptions)
[13:35:09.627]             if (.Platform$OS.type == "windows") {
[13:35:09.627]                 old_names <- names(...future.oldEnvVars)
[13:35:09.627]                 envs <- base::Sys.getenv()
[13:35:09.627]                 names <- names(envs)
[13:35:09.627]                 common <- intersect(names, old_names)
[13:35:09.627]                 added <- setdiff(names, old_names)
[13:35:09.627]                 removed <- setdiff(old_names, names)
[13:35:09.627]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:09.627]                   envs[common]]
[13:35:09.627]                 NAMES <- toupper(changed)
[13:35:09.627]                 args <- list()
[13:35:09.627]                 for (kk in seq_along(NAMES)) {
[13:35:09.627]                   name <- changed[[kk]]
[13:35:09.627]                   NAME <- NAMES[[kk]]
[13:35:09.627]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:09.627]                     next
[13:35:09.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:09.627]                 }
[13:35:09.627]                 NAMES <- toupper(added)
[13:35:09.627]                 for (kk in seq_along(NAMES)) {
[13:35:09.627]                   name <- added[[kk]]
[13:35:09.627]                   NAME <- NAMES[[kk]]
[13:35:09.627]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:09.627]                     next
[13:35:09.627]                   args[[name]] <- ""
[13:35:09.627]                 }
[13:35:09.627]                 NAMES <- toupper(removed)
[13:35:09.627]                 for (kk in seq_along(NAMES)) {
[13:35:09.627]                   name <- removed[[kk]]
[13:35:09.627]                   NAME <- NAMES[[kk]]
[13:35:09.627]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:09.627]                     next
[13:35:09.627]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:09.627]                 }
[13:35:09.627]                 if (length(args) > 0) 
[13:35:09.627]                   base::do.call(base::Sys.setenv, args = args)
[13:35:09.627]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:09.627]             }
[13:35:09.627]             else {
[13:35:09.627]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:09.627]             }
[13:35:09.627]             {
[13:35:09.627]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:09.627]                   0L) {
[13:35:09.627]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:09.627]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:09.627]                   base::options(opts)
[13:35:09.627]                 }
[13:35:09.627]                 {
[13:35:09.627]                   {
[13:35:09.627]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:09.627]                     NULL
[13:35:09.627]                   }
[13:35:09.627]                   options(future.plan = NULL)
[13:35:09.627]                   if (is.na(NA_character_)) 
[13:35:09.627]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:09.627]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:09.627]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:09.627]                     .init = FALSE)
[13:35:09.627]                 }
[13:35:09.627]             }
[13:35:09.627]         }
[13:35:09.627]     })
[13:35:09.627]     if (TRUE) {
[13:35:09.627]         base::sink(type = "output", split = FALSE)
[13:35:09.627]         if (TRUE) {
[13:35:09.627]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:09.627]         }
[13:35:09.627]         else {
[13:35:09.627]             ...future.result["stdout"] <- base::list(NULL)
[13:35:09.627]         }
[13:35:09.627]         base::close(...future.stdout)
[13:35:09.627]         ...future.stdout <- NULL
[13:35:09.627]     }
[13:35:09.627]     ...future.result$conditions <- ...future.conditions
[13:35:09.627]     ...future.result$finished <- base::Sys.time()
[13:35:09.627]     ...future.result
[13:35:09.627] }
[13:35:09.681] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[13:35:09.681] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:35:09.686] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:35:09.686] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[13:35:09.686] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[13:35:09.686] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:35:09.687] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:35:09.687] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:35:09.730] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:35:09.731] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:35:09.774] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:35:09.775] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:35:09.775] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:35:09.775] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[13:35:09.776] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[13:35:09.776] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:35:09.776] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:35:09.777] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[13:35:09.777] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[13:35:09.777] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:09.781] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:09.781] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:09.781] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:09.781] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[13:35:09.782] MultisessionFuture started
[13:35:09.782] - Launch lazy future ... done
[13:35:09.782] run() for ‘MultisessionFuture’ ... done
[13:35:09.782] Created future:
[13:35:09.782] MultisessionFuture:
[13:35:09.782] Label: ‘future_vapply-2’
[13:35:09.782] Expression:
[13:35:09.782] {
[13:35:09.782]     do.call(function(...) {
[13:35:09.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:09.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:09.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:09.782]             on.exit(options(oopts), add = TRUE)
[13:35:09.782]         }
[13:35:09.782]         {
[13:35:09.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:09.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:09.782]                 ...future.FUN(...future.X_jj, ...)
[13:35:09.782]             })
[13:35:09.782]         }
[13:35:09.782]     }, args = future.call.arguments)
[13:35:09.782] }
[13:35:09.782] Lazy evaluation: FALSE
[13:35:09.782] Asynchronous evaluation: TRUE
[13:35:09.782] Local evaluation: TRUE
[13:35:09.782] Environment: R_GlobalEnv
[13:35:09.782] Capture standard output: TRUE
[13:35:09.782] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:09.782] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:09.782] Packages: 1 packages (‘future.apply’)
[13:35:09.782] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:09.782] Resolved: FALSE
[13:35:09.782] Value: <not collected>
[13:35:09.782] Conditions captured: <none>
[13:35:09.782] Early signaling: FALSE
[13:35:09.782] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:09.782] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:09.794] Chunk #2 of 2 ... DONE
[13:35:09.794] Launching 2 futures (chunks) ... DONE
[13:35:09.794] Resolving 2 futures (chunks) ...
[13:35:09.795] resolve() on list ...
[13:35:09.795]  recursive: 0
[13:35:09.795]  length: 2
[13:35:09.795] 
[13:35:09.795] receiveMessageFromWorker() for ClusterFuture ...
[13:35:09.795] - Validating connection of MultisessionFuture
[13:35:09.796] - received message: FutureResult
[13:35:09.796] - Received FutureResult
[13:35:09.796] - Erased future from FutureRegistry
[13:35:09.796] result() for ClusterFuture ...
[13:35:09.796] - result already collected: FutureResult
[13:35:09.796] result() for ClusterFuture ... done
[13:35:09.796] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:09.796] Future #1
[13:35:09.796] result() for ClusterFuture ...
[13:35:09.797] - result already collected: FutureResult
[13:35:09.797] result() for ClusterFuture ... done
[13:35:09.797] result() for ClusterFuture ...
[13:35:09.797] - result already collected: FutureResult
[13:35:09.797] result() for ClusterFuture ... done
[13:35:09.797] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:09.797] - nx: 2
[13:35:09.797] - relay: TRUE
[13:35:09.797] - stdout: TRUE
[13:35:09.797] - signal: TRUE
[13:35:09.797] - resignal: FALSE
[13:35:09.797] - force: TRUE
[13:35:09.798] - relayed: [n=2] FALSE, FALSE
[13:35:09.798] - queued futures: [n=2] FALSE, FALSE
[13:35:09.798]  - until=1
[13:35:09.798]  - relaying element #1
[13:35:09.798] result() for ClusterFuture ...
[13:35:09.798] - result already collected: FutureResult
[13:35:09.798] result() for ClusterFuture ... done
[13:35:09.798] result() for ClusterFuture ...
[13:35:09.798] - result already collected: FutureResult
[13:35:09.798] result() for ClusterFuture ... done
[13:35:09.799] result() for ClusterFuture ...
[13:35:09.799] - result already collected: FutureResult
[13:35:09.799] result() for ClusterFuture ... done
[13:35:09.799] result() for ClusterFuture ...
[13:35:09.799] - result already collected: FutureResult
[13:35:09.799] result() for ClusterFuture ... done
[13:35:09.799] - relayed: [n=2] TRUE, FALSE
[13:35:09.799] - queued futures: [n=2] TRUE, FALSE
[13:35:09.799] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:09.799]  length: 1 (resolved future 1)
[13:35:09.867] receiveMessageFromWorker() for ClusterFuture ...
[13:35:09.867] - Validating connection of MultisessionFuture
[13:35:09.867] - received message: FutureResult
[13:35:09.867] - Received FutureResult
[13:35:09.867] - Erased future from FutureRegistry
[13:35:09.867] result() for ClusterFuture ...
[13:35:09.868] - result already collected: FutureResult
[13:35:09.868] result() for ClusterFuture ... done
[13:35:09.868] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:09.868] Future #2
[13:35:09.868] result() for ClusterFuture ...
[13:35:09.868] - result already collected: FutureResult
[13:35:09.868] result() for ClusterFuture ... done
[13:35:09.868] result() for ClusterFuture ...
[13:35:09.868] - result already collected: FutureResult
[13:35:09.868] result() for ClusterFuture ... done
[13:35:09.869] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:09.869] - nx: 2
[13:35:09.869] - relay: TRUE
[13:35:09.869] - stdout: TRUE
[13:35:09.869] - signal: TRUE
[13:35:09.869] - resignal: FALSE
[13:35:09.869] - force: TRUE
[13:35:09.869] - relayed: [n=2] TRUE, FALSE
[13:35:09.869] - queued futures: [n=2] TRUE, FALSE
[13:35:09.869]  - until=2
[13:35:09.869]  - relaying element #2
[13:35:09.870] result() for ClusterFuture ...
[13:35:09.870] - result already collected: FutureResult
[13:35:09.870] result() for ClusterFuture ... done
[13:35:09.870] result() for ClusterFuture ...
[13:35:09.870] - result already collected: FutureResult
[13:35:09.870] result() for ClusterFuture ... done
[13:35:09.870] result() for ClusterFuture ...
[13:35:09.870] - result already collected: FutureResult
[13:35:09.870] result() for ClusterFuture ... done
[13:35:09.870] result() for ClusterFuture ...
[13:35:09.871] - result already collected: FutureResult
[13:35:09.871] result() for ClusterFuture ... done
[13:35:09.871] - relayed: [n=2] TRUE, TRUE
[13:35:09.871] - queued futures: [n=2] TRUE, TRUE
[13:35:09.871] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:09.871]  length: 0 (resolved future 2)
[13:35:09.871] Relaying remaining futures
[13:35:09.871] signalConditionsASAP(NULL, pos=0) ...
[13:35:09.871] - nx: 2
[13:35:09.871] - relay: TRUE
[13:35:09.871] - stdout: TRUE
[13:35:09.872] - signal: TRUE
[13:35:09.872] - resignal: FALSE
[13:35:09.872] - force: TRUE
[13:35:09.872] - relayed: [n=2] TRUE, TRUE
[13:35:09.872] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:09.872] - relayed: [n=2] TRUE, TRUE
[13:35:09.872] - queued futures: [n=2] TRUE, TRUE
[13:35:09.872] signalConditionsASAP(NULL, pos=0) ... done
[13:35:09.872] resolve() on list ... DONE
[13:35:09.872] result() for ClusterFuture ...
[13:35:09.872] - result already collected: FutureResult
[13:35:09.873] result() for ClusterFuture ... done
[13:35:09.873] result() for ClusterFuture ...
[13:35:09.873] - result already collected: FutureResult
[13:35:09.873] result() for ClusterFuture ... done
[13:35:09.873] result() for ClusterFuture ...
[13:35:09.873] - result already collected: FutureResult
[13:35:09.873] result() for ClusterFuture ... done
[13:35:09.873] result() for ClusterFuture ...
[13:35:09.873] - result already collected: FutureResult
[13:35:09.873] result() for ClusterFuture ... done
[13:35:09.874]  - Number of value chunks collected: 2
[13:35:09.874] Resolving 2 futures (chunks) ... DONE
[13:35:09.874] Reducing values from 2 chunks ...
[13:35:09.874]  - Number of values collected after concatenation: 2
[13:35:09.874]  - Number of values expected: 2
[13:35:09.874] Reducing values from 2 chunks ... DONE
[13:35:09.874] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[13:35:09.875] future_lapply() ...
[13:35:09.881] Number of chunks: 2
[13:35:09.881] getGlobalsAndPackagesXApply() ...
[13:35:09.881]  - future.globals: TRUE
[13:35:09.881] getGlobalsAndPackages() ...
[13:35:09.881] Searching for globals...
[13:35:09.885] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[13:35:09.885] Searching for globals ... DONE
[13:35:09.885] Resolving globals: FALSE
[13:35:09.886] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[13:35:09.886] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:09.886] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:09.887] - packages: [1] ‘future.apply’
[13:35:09.887] getGlobalsAndPackages() ... DONE
[13:35:09.887]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:09.887]  - needed namespaces: [n=1] ‘future.apply’
[13:35:09.887] Finding globals ... DONE
[13:35:09.887]  - use_args: TRUE
[13:35:09.887]  - Getting '...' globals ...
[13:35:09.887] resolve() on list ...
[13:35:09.888]  recursive: 0
[13:35:09.888]  length: 1
[13:35:09.888]  elements: ‘...’
[13:35:09.888]  length: 0 (resolved future 1)
[13:35:09.888] resolve() on list ... DONE
[13:35:09.888]    - '...' content: [n=0] 
[13:35:09.888] List of 1
[13:35:09.888]  $ ...: list()
[13:35:09.888]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:09.888]  - attr(*, "where")=List of 1
[13:35:09.888]   ..$ ...:<environment: 0x5574cf4f1498> 
[13:35:09.888]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:09.888]  - attr(*, "resolved")= logi TRUE
[13:35:09.888]  - attr(*, "total_size")= num NA
[13:35:09.891]  - Getting '...' globals ... DONE
[13:35:09.891] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:09.891] List of 8
[13:35:09.891]  $ ...future.FUN:function (x, ...)  
[13:35:09.891]  $ x_FUN        :function (x)  
[13:35:09.891]  $ times        : int 0
[13:35:09.891]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:09.891]  $ stop_if_not  :function (...)  
[13:35:09.891]  $ dim          : NULL
[13:35:09.891]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:09.891]  $ ...          : list()
[13:35:09.891]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:09.891]  - attr(*, "where")=List of 8
[13:35:09.891]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:09.891]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:09.891]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:09.891]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:09.891]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:09.891]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:09.891]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:09.891]   ..$ ...          :<environment: 0x5574cf4f1498> 
[13:35:09.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:09.891]  - attr(*, "resolved")= logi FALSE
[13:35:09.891]  - attr(*, "total_size")= num 95472
[13:35:09.896] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:09.896] getGlobalsAndPackagesXApply() ... DONE
[13:35:09.896] Number of futures (= number of chunks): 2
[13:35:09.897] Launching 2 futures (chunks) ...
[13:35:09.897] Chunk #1 of 2 ...
[13:35:09.897]  - Finding globals in 'X' for chunk #1 ...
[13:35:09.897] getGlobalsAndPackages() ...
[13:35:09.897] Searching for globals...
[13:35:09.897] 
[13:35:09.897] Searching for globals ... DONE
[13:35:09.897] - globals: [0] <none>
[13:35:09.898] getGlobalsAndPackages() ... DONE
[13:35:09.898]    + additional globals found: [n=0] 
[13:35:09.898]    + additional namespaces needed: [n=0] 
[13:35:09.898]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:09.898]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:09.898]  - seeds: <none>
[13:35:09.898]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:09.898] getGlobalsAndPackages() ...
[13:35:09.898] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:09.898] Resolving globals: FALSE
[13:35:09.899] Tweak future expression to call with '...' arguments ...
[13:35:09.899] {
[13:35:09.899]     do.call(function(...) {
[13:35:09.899]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:09.899]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:09.899]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:09.899]             on.exit(options(oopts), add = TRUE)
[13:35:09.899]         }
[13:35:09.899]         {
[13:35:09.899]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:09.899]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:09.899]                 ...future.FUN(...future.X_jj, ...)
[13:35:09.899]             })
[13:35:09.899]         }
[13:35:09.899]     }, args = future.call.arguments)
[13:35:09.899] }
[13:35:09.899] Tweak future expression to call with '...' arguments ... DONE
[13:35:09.899] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:09.900] - packages: [1] ‘future.apply’
[13:35:09.900] getGlobalsAndPackages() ... DONE
[13:35:09.900] run() for ‘Future’ ...
[13:35:09.900] - state: ‘created’
[13:35:09.900] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:09.914] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:09.914] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:09.914]   - Field: ‘node’
[13:35:09.914]   - Field: ‘label’
[13:35:09.914]   - Field: ‘local’
[13:35:09.915]   - Field: ‘owner’
[13:35:09.915]   - Field: ‘envir’
[13:35:09.915]   - Field: ‘workers’
[13:35:09.915]   - Field: ‘packages’
[13:35:09.915]   - Field: ‘gc’
[13:35:09.915]   - Field: ‘conditions’
[13:35:09.915]   - Field: ‘persistent’
[13:35:09.915]   - Field: ‘expr’
[13:35:09.915]   - Field: ‘uuid’
[13:35:09.915]   - Field: ‘seed’
[13:35:09.916]   - Field: ‘version’
[13:35:09.916]   - Field: ‘result’
[13:35:09.916]   - Field: ‘asynchronous’
[13:35:09.916]   - Field: ‘calls’
[13:35:09.916]   - Field: ‘globals’
[13:35:09.916]   - Field: ‘stdout’
[13:35:09.916]   - Field: ‘earlySignal’
[13:35:09.916]   - Field: ‘lazy’
[13:35:09.916]   - Field: ‘state’
[13:35:09.916] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:09.916] - Launch lazy future ...
[13:35:09.917] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:09.917] Packages needed by future strategies (n = 0): <none>
[13:35:09.917] {
[13:35:09.917]     {
[13:35:09.917]         {
[13:35:09.917]             ...future.startTime <- base::Sys.time()
[13:35:09.917]             {
[13:35:09.917]                 {
[13:35:09.917]                   {
[13:35:09.917]                     {
[13:35:09.917]                       {
[13:35:09.917]                         base::local({
[13:35:09.917]                           has_future <- base::requireNamespace("future", 
[13:35:09.917]                             quietly = TRUE)
[13:35:09.917]                           if (has_future) {
[13:35:09.917]                             ns <- base::getNamespace("future")
[13:35:09.917]                             version <- ns[[".package"]][["version"]]
[13:35:09.917]                             if (is.null(version)) 
[13:35:09.917]                               version <- utils::packageVersion("future")
[13:35:09.917]                           }
[13:35:09.917]                           else {
[13:35:09.917]                             version <- NULL
[13:35:09.917]                           }
[13:35:09.917]                           if (!has_future || version < "1.8.0") {
[13:35:09.917]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:09.917]                               "", base::R.version$version.string), 
[13:35:09.917]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:09.917]                                 base::R.version$platform, 8 * 
[13:35:09.917]                                   base::.Machine$sizeof.pointer), 
[13:35:09.917]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:09.917]                                 "release", "version")], collapse = " "), 
[13:35:09.917]                               hostname = base::Sys.info()[["nodename"]])
[13:35:09.917]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:09.917]                               info)
[13:35:09.917]                             info <- base::paste(info, collapse = "; ")
[13:35:09.917]                             if (!has_future) {
[13:35:09.917]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:09.917]                                 info)
[13:35:09.917]                             }
[13:35:09.917]                             else {
[13:35:09.917]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:09.917]                                 info, version)
[13:35:09.917]                             }
[13:35:09.917]                             base::stop(msg)
[13:35:09.917]                           }
[13:35:09.917]                         })
[13:35:09.917]                       }
[13:35:09.917]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:09.917]                       base::options(mc.cores = 1L)
[13:35:09.917]                     }
[13:35:09.917]                     base::local({
[13:35:09.917]                       for (pkg in "future.apply") {
[13:35:09.917]                         base::loadNamespace(pkg)
[13:35:09.917]                         base::library(pkg, character.only = TRUE)
[13:35:09.917]                       }
[13:35:09.917]                     })
[13:35:09.917]                   }
[13:35:09.917]                   ...future.strategy.old <- future::plan("list")
[13:35:09.917]                   options(future.plan = NULL)
[13:35:09.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:09.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:09.917]                 }
[13:35:09.917]                 ...future.workdir <- getwd()
[13:35:09.917]             }
[13:35:09.917]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:09.917]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:09.917]         }
[13:35:09.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:09.917]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:09.917]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:09.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:09.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:09.917]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:09.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:09.917]             base::names(...future.oldOptions))
[13:35:09.917]     }
[13:35:09.917]     if (FALSE) {
[13:35:09.917]     }
[13:35:09.917]     else {
[13:35:09.917]         if (TRUE) {
[13:35:09.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:09.917]                 open = "w")
[13:35:09.917]         }
[13:35:09.917]         else {
[13:35:09.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:09.917]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:09.917]         }
[13:35:09.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:09.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:09.917]             base::sink(type = "output", split = FALSE)
[13:35:09.917]             base::close(...future.stdout)
[13:35:09.917]         }, add = TRUE)
[13:35:09.917]     }
[13:35:09.917]     ...future.frame <- base::sys.nframe()
[13:35:09.917]     ...future.conditions <- base::list()
[13:35:09.917]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:09.917]     if (FALSE) {
[13:35:09.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:09.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:09.917]     }
[13:35:09.917]     ...future.result <- base::tryCatch({
[13:35:09.917]         base::withCallingHandlers({
[13:35:09.917]             ...future.value <- base::withVisible(base::local({
[13:35:09.917]                 ...future.makeSendCondition <- base::local({
[13:35:09.917]                   sendCondition <- NULL
[13:35:09.917]                   function(frame = 1L) {
[13:35:09.917]                     if (is.function(sendCondition)) 
[13:35:09.917]                       return(sendCondition)
[13:35:09.917]                     ns <- getNamespace("parallel")
[13:35:09.917]                     if (exists("sendData", mode = "function", 
[13:35:09.917]                       envir = ns)) {
[13:35:09.917]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:09.917]                         envir = ns)
[13:35:09.917]                       envir <- sys.frame(frame)
[13:35:09.917]                       master <- NULL
[13:35:09.917]                       while (!identical(envir, .GlobalEnv) && 
[13:35:09.917]                         !identical(envir, emptyenv())) {
[13:35:09.917]                         if (exists("master", mode = "list", envir = envir, 
[13:35:09.917]                           inherits = FALSE)) {
[13:35:09.917]                           master <- get("master", mode = "list", 
[13:35:09.917]                             envir = envir, inherits = FALSE)
[13:35:09.917]                           if (inherits(master, c("SOCKnode", 
[13:35:09.917]                             "SOCK0node"))) {
[13:35:09.917]                             sendCondition <<- function(cond) {
[13:35:09.917]                               data <- list(type = "VALUE", value = cond, 
[13:35:09.917]                                 success = TRUE)
[13:35:09.917]                               parallel_sendData(master, data)
[13:35:09.917]                             }
[13:35:09.917]                             return(sendCondition)
[13:35:09.917]                           }
[13:35:09.917]                         }
[13:35:09.917]                         frame <- frame + 1L
[13:35:09.917]                         envir <- sys.frame(frame)
[13:35:09.917]                       }
[13:35:09.917]                     }
[13:35:09.917]                     sendCondition <<- function(cond) NULL
[13:35:09.917]                   }
[13:35:09.917]                 })
[13:35:09.917]                 withCallingHandlers({
[13:35:09.917]                   {
[13:35:09.917]                     do.call(function(...) {
[13:35:09.917]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:09.917]                       if (!identical(...future.globals.maxSize.org, 
[13:35:09.917]                         ...future.globals.maxSize)) {
[13:35:09.917]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:09.917]                         on.exit(options(oopts), add = TRUE)
[13:35:09.917]                       }
[13:35:09.917]                       {
[13:35:09.917]                         lapply(seq_along(...future.elements_ii), 
[13:35:09.917]                           FUN = function(jj) {
[13:35:09.917]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:09.917]                             ...future.FUN(...future.X_jj, ...)
[13:35:09.917]                           })
[13:35:09.917]                       }
[13:35:09.917]                     }, args = future.call.arguments)
[13:35:09.917]                   }
[13:35:09.917]                 }, immediateCondition = function(cond) {
[13:35:09.917]                   sendCondition <- ...future.makeSendCondition()
[13:35:09.917]                   sendCondition(cond)
[13:35:09.917]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:09.917]                   {
[13:35:09.917]                     inherits <- base::inherits
[13:35:09.917]                     invokeRestart <- base::invokeRestart
[13:35:09.917]                     is.null <- base::is.null
[13:35:09.917]                     muffled <- FALSE
[13:35:09.917]                     if (inherits(cond, "message")) {
[13:35:09.917]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:09.917]                       if (muffled) 
[13:35:09.917]                         invokeRestart("muffleMessage")
[13:35:09.917]                     }
[13:35:09.917]                     else if (inherits(cond, "warning")) {
[13:35:09.917]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:09.917]                       if (muffled) 
[13:35:09.917]                         invokeRestart("muffleWarning")
[13:35:09.917]                     }
[13:35:09.917]                     else if (inherits(cond, "condition")) {
[13:35:09.917]                       if (!is.null(pattern)) {
[13:35:09.917]                         computeRestarts <- base::computeRestarts
[13:35:09.917]                         grepl <- base::grepl
[13:35:09.917]                         restarts <- computeRestarts(cond)
[13:35:09.917]                         for (restart in restarts) {
[13:35:09.917]                           name <- restart$name
[13:35:09.917]                           if (is.null(name)) 
[13:35:09.917]                             next
[13:35:09.917]                           if (!grepl(pattern, name)) 
[13:35:09.917]                             next
[13:35:09.917]                           invokeRestart(restart)
[13:35:09.917]                           muffled <- TRUE
[13:35:09.917]                           break
[13:35:09.917]                         }
[13:35:09.917]                       }
[13:35:09.917]                     }
[13:35:09.917]                     invisible(muffled)
[13:35:09.917]                   }
[13:35:09.917]                   muffleCondition(cond)
[13:35:09.917]                 })
[13:35:09.917]             }))
[13:35:09.917]             future::FutureResult(value = ...future.value$value, 
[13:35:09.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:09.917]                   ...future.rng), globalenv = if (FALSE) 
[13:35:09.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:09.917]                     ...future.globalenv.names))
[13:35:09.917]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:09.917]         }, condition = base::local({
[13:35:09.917]             c <- base::c
[13:35:09.917]             inherits <- base::inherits
[13:35:09.917]             invokeRestart <- base::invokeRestart
[13:35:09.917]             length <- base::length
[13:35:09.917]             list <- base::list
[13:35:09.917]             seq.int <- base::seq.int
[13:35:09.917]             signalCondition <- base::signalCondition
[13:35:09.917]             sys.calls <- base::sys.calls
[13:35:09.917]             `[[` <- base::`[[`
[13:35:09.917]             `+` <- base::`+`
[13:35:09.917]             `<<-` <- base::`<<-`
[13:35:09.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:09.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:09.917]                   3L)]
[13:35:09.917]             }
[13:35:09.917]             function(cond) {
[13:35:09.917]                 is_error <- inherits(cond, "error")
[13:35:09.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:09.917]                   NULL)
[13:35:09.917]                 if (is_error) {
[13:35:09.917]                   sessionInformation <- function() {
[13:35:09.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:09.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:09.917]                       search = base::search(), system = base::Sys.info())
[13:35:09.917]                   }
[13:35:09.917]                   ...future.conditions[[length(...future.conditions) + 
[13:35:09.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:09.917]                     cond$call), session = sessionInformation(), 
[13:35:09.917]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:09.917]                   signalCondition(cond)
[13:35:09.917]                 }
[13:35:09.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:09.917]                 "immediateCondition"))) {
[13:35:09.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:09.917]                   ...future.conditions[[length(...future.conditions) + 
[13:35:09.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:09.917]                   if (TRUE && !signal) {
[13:35:09.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:09.917]                     {
[13:35:09.917]                       inherits <- base::inherits
[13:35:09.917]                       invokeRestart <- base::invokeRestart
[13:35:09.917]                       is.null <- base::is.null
[13:35:09.917]                       muffled <- FALSE
[13:35:09.917]                       if (inherits(cond, "message")) {
[13:35:09.917]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:09.917]                         if (muffled) 
[13:35:09.917]                           invokeRestart("muffleMessage")
[13:35:09.917]                       }
[13:35:09.917]                       else if (inherits(cond, "warning")) {
[13:35:09.917]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:09.917]                         if (muffled) 
[13:35:09.917]                           invokeRestart("muffleWarning")
[13:35:09.917]                       }
[13:35:09.917]                       else if (inherits(cond, "condition")) {
[13:35:09.917]                         if (!is.null(pattern)) {
[13:35:09.917]                           computeRestarts <- base::computeRestarts
[13:35:09.917]                           grepl <- base::grepl
[13:35:09.917]                           restarts <- computeRestarts(cond)
[13:35:09.917]                           for (restart in restarts) {
[13:35:09.917]                             name <- restart$name
[13:35:09.917]                             if (is.null(name)) 
[13:35:09.917]                               next
[13:35:09.917]                             if (!grepl(pattern, name)) 
[13:35:09.917]                               next
[13:35:09.917]                             invokeRestart(restart)
[13:35:09.917]                             muffled <- TRUE
[13:35:09.917]                             break
[13:35:09.917]                           }
[13:35:09.917]                         }
[13:35:09.917]                       }
[13:35:09.917]                       invisible(muffled)
[13:35:09.917]                     }
[13:35:09.917]                     muffleCondition(cond, pattern = "^muffle")
[13:35:09.917]                   }
[13:35:09.917]                 }
[13:35:09.917]                 else {
[13:35:09.917]                   if (TRUE) {
[13:35:09.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:09.917]                     {
[13:35:09.917]                       inherits <- base::inherits
[13:35:09.917]                       invokeRestart <- base::invokeRestart
[13:35:09.917]                       is.null <- base::is.null
[13:35:09.917]                       muffled <- FALSE
[13:35:09.917]                       if (inherits(cond, "message")) {
[13:35:09.917]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:09.917]                         if (muffled) 
[13:35:09.917]                           invokeRestart("muffleMessage")
[13:35:09.917]                       }
[13:35:09.917]                       else if (inherits(cond, "warning")) {
[13:35:09.917]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:09.917]                         if (muffled) 
[13:35:09.917]                           invokeRestart("muffleWarning")
[13:35:09.917]                       }
[13:35:09.917]                       else if (inherits(cond, "condition")) {
[13:35:09.917]                         if (!is.null(pattern)) {
[13:35:09.917]                           computeRestarts <- base::computeRestarts
[13:35:09.917]                           grepl <- base::grepl
[13:35:09.917]                           restarts <- computeRestarts(cond)
[13:35:09.917]                           for (restart in restarts) {
[13:35:09.917]                             name <- restart$name
[13:35:09.917]                             if (is.null(name)) 
[13:35:09.917]                               next
[13:35:09.917]                             if (!grepl(pattern, name)) 
[13:35:09.917]                               next
[13:35:09.917]                             invokeRestart(restart)
[13:35:09.917]                             muffled <- TRUE
[13:35:09.917]                             break
[13:35:09.917]                           }
[13:35:09.917]                         }
[13:35:09.917]                       }
[13:35:09.917]                       invisible(muffled)
[13:35:09.917]                     }
[13:35:09.917]                     muffleCondition(cond, pattern = "^muffle")
[13:35:09.917]                   }
[13:35:09.917]                 }
[13:35:09.917]             }
[13:35:09.917]         }))
[13:35:09.917]     }, error = function(ex) {
[13:35:09.917]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:09.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:09.917]                 ...future.rng), started = ...future.startTime, 
[13:35:09.917]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:09.917]             version = "1.8"), class = "FutureResult")
[13:35:09.917]     }, finally = {
[13:35:09.917]         if (!identical(...future.workdir, getwd())) 
[13:35:09.917]             setwd(...future.workdir)
[13:35:09.917]         {
[13:35:09.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:09.917]                 ...future.oldOptions$nwarnings <- NULL
[13:35:09.917]             }
[13:35:09.917]             base::options(...future.oldOptions)
[13:35:09.917]             if (.Platform$OS.type == "windows") {
[13:35:09.917]                 old_names <- names(...future.oldEnvVars)
[13:35:09.917]                 envs <- base::Sys.getenv()
[13:35:09.917]                 names <- names(envs)
[13:35:09.917]                 common <- intersect(names, old_names)
[13:35:09.917]                 added <- setdiff(names, old_names)
[13:35:09.917]                 removed <- setdiff(old_names, names)
[13:35:09.917]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:09.917]                   envs[common]]
[13:35:09.917]                 NAMES <- toupper(changed)
[13:35:09.917]                 args <- list()
[13:35:09.917]                 for (kk in seq_along(NAMES)) {
[13:35:09.917]                   name <- changed[[kk]]
[13:35:09.917]                   NAME <- NAMES[[kk]]
[13:35:09.917]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:09.917]                     next
[13:35:09.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:09.917]                 }
[13:35:09.917]                 NAMES <- toupper(added)
[13:35:09.917]                 for (kk in seq_along(NAMES)) {
[13:35:09.917]                   name <- added[[kk]]
[13:35:09.917]                   NAME <- NAMES[[kk]]
[13:35:09.917]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:09.917]                     next
[13:35:09.917]                   args[[name]] <- ""
[13:35:09.917]                 }
[13:35:09.917]                 NAMES <- toupper(removed)
[13:35:09.917]                 for (kk in seq_along(NAMES)) {
[13:35:09.917]                   name <- removed[[kk]]
[13:35:09.917]                   NAME <- NAMES[[kk]]
[13:35:09.917]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:09.917]                     next
[13:35:09.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:09.917]                 }
[13:35:09.917]                 if (length(args) > 0) 
[13:35:09.917]                   base::do.call(base::Sys.setenv, args = args)
[13:35:09.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:09.917]             }
[13:35:09.917]             else {
[13:35:09.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:09.917]             }
[13:35:09.917]             {
[13:35:09.917]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:09.917]                   0L) {
[13:35:09.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:09.917]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:09.917]                   base::options(opts)
[13:35:09.917]                 }
[13:35:09.917]                 {
[13:35:09.917]                   {
[13:35:09.917]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:09.917]                     NULL
[13:35:09.917]                   }
[13:35:09.917]                   options(future.plan = NULL)
[13:35:09.917]                   if (is.na(NA_character_)) 
[13:35:09.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:09.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:09.917]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:09.917]                     .init = FALSE)
[13:35:09.917]                 }
[13:35:09.917]             }
[13:35:09.917]         }
[13:35:09.917]     })
[13:35:09.917]     if (TRUE) {
[13:35:09.917]         base::sink(type = "output", split = FALSE)
[13:35:09.917]         if (TRUE) {
[13:35:09.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:09.917]         }
[13:35:09.917]         else {
[13:35:09.917]             ...future.result["stdout"] <- base::list(NULL)
[13:35:09.917]         }
[13:35:09.917]         base::close(...future.stdout)
[13:35:09.917]         ...future.stdout <- NULL
[13:35:09.917]     }
[13:35:09.917]     ...future.result$conditions <- ...future.conditions
[13:35:09.917]     ...future.result$finished <- base::Sys.time()
[13:35:09.917]     ...future.result
[13:35:09.917] }
[13:35:09.920] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[13:35:09.920] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:09.962] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:09.963] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[13:35:09.963] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[13:35:09.963] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:09.964] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:09.964] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:10.006] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:10.007] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:10.050] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:10.051] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:10.051] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.051] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:10.052] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:10.052] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:10.052] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.052] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:35:10.053] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:35:10.053] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:10.053] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.053] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:10.054] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.054] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[13:35:10.054] MultisessionFuture started
[13:35:10.054] - Launch lazy future ... done
[13:35:10.055] run() for ‘MultisessionFuture’ ... done
[13:35:10.055] Created future:
[13:35:10.056] receiveMessageFromWorker() for ClusterFuture ...
[13:35:10.056] - Validating connection of MultisessionFuture
[13:35:10.057] - received message: FutureResult
[13:35:10.057] - Received FutureResult
[13:35:10.057] - Erased future from FutureRegistry
[13:35:10.057] result() for ClusterFuture ...
[13:35:10.057] - result already collected: FutureResult
[13:35:10.057] result() for ClusterFuture ... done
[13:35:10.057] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:10.055] MultisessionFuture:
[13:35:10.055] Label: ‘future_vapply-1’
[13:35:10.055] Expression:
[13:35:10.055] {
[13:35:10.055]     do.call(function(...) {
[13:35:10.055]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.055]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:10.055]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.055]             on.exit(options(oopts), add = TRUE)
[13:35:10.055]         }
[13:35:10.055]         {
[13:35:10.055]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:10.055]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.055]                 ...future.FUN(...future.X_jj, ...)
[13:35:10.055]             })
[13:35:10.055]         }
[13:35:10.055]     }, args = future.call.arguments)
[13:35:10.055] }
[13:35:10.055] Lazy evaluation: FALSE
[13:35:10.055] Asynchronous evaluation: TRUE
[13:35:10.055] Local evaluation: TRUE
[13:35:10.055] Environment: R_GlobalEnv
[13:35:10.055] Capture standard output: TRUE
[13:35:10.055] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:10.055] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:10.055] Packages: 1 packages (‘future.apply’)
[13:35:10.055] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:10.055] Resolved: TRUE
[13:35:10.055] Value: <not collected>
[13:35:10.055] Conditions captured: <none>
[13:35:10.055] Early signaling: FALSE
[13:35:10.055] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:10.055] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:10.057] Chunk #1 of 2 ... DONE
[13:35:10.058] Chunk #2 of 2 ...
[13:35:10.058]  - Finding globals in 'X' for chunk #2 ...
[13:35:10.058] getGlobalsAndPackages() ...
[13:35:10.058] Searching for globals...
[13:35:10.058] 
[13:35:10.058] Searching for globals ... DONE
[13:35:10.058] - globals: [0] <none>
[13:35:10.058] getGlobalsAndPackages() ... DONE
[13:35:10.059]    + additional globals found: [n=0] 
[13:35:10.059]    + additional namespaces needed: [n=0] 
[13:35:10.059]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:10.059]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:10.059]  - seeds: <none>
[13:35:10.059]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.059] getGlobalsAndPackages() ...
[13:35:10.059] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.059] Resolving globals: FALSE
[13:35:10.059] Tweak future expression to call with '...' arguments ...
[13:35:10.060] {
[13:35:10.060]     do.call(function(...) {
[13:35:10.060]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.060]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:10.060]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.060]             on.exit(options(oopts), add = TRUE)
[13:35:10.060]         }
[13:35:10.060]         {
[13:35:10.060]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:10.060]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.060]                 ...future.FUN(...future.X_jj, ...)
[13:35:10.060]             })
[13:35:10.060]         }
[13:35:10.060]     }, args = future.call.arguments)
[13:35:10.060] }
[13:35:10.060] Tweak future expression to call with '...' arguments ... DONE
[13:35:10.060] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.060] - packages: [1] ‘future.apply’
[13:35:10.061] getGlobalsAndPackages() ... DONE
[13:35:10.061] run() for ‘Future’ ...
[13:35:10.061] - state: ‘created’
[13:35:10.061] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:10.075] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:10.075] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:10.075]   - Field: ‘node’
[13:35:10.075]   - Field: ‘label’
[13:35:10.075]   - Field: ‘local’
[13:35:10.075]   - Field: ‘owner’
[13:35:10.075]   - Field: ‘envir’
[13:35:10.075]   - Field: ‘workers’
[13:35:10.076]   - Field: ‘packages’
[13:35:10.076]   - Field: ‘gc’
[13:35:10.076]   - Field: ‘conditions’
[13:35:10.076]   - Field: ‘persistent’
[13:35:10.076]   - Field: ‘expr’
[13:35:10.076]   - Field: ‘uuid’
[13:35:10.076]   - Field: ‘seed’
[13:35:10.076]   - Field: ‘version’
[13:35:10.076]   - Field: ‘result’
[13:35:10.076]   - Field: ‘asynchronous’
[13:35:10.076]   - Field: ‘calls’
[13:35:10.077]   - Field: ‘globals’
[13:35:10.077]   - Field: ‘stdout’
[13:35:10.077]   - Field: ‘earlySignal’
[13:35:10.077]   - Field: ‘lazy’
[13:35:10.077]   - Field: ‘state’
[13:35:10.077] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:10.077] - Launch lazy future ...
[13:35:10.077] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:10.078] Packages needed by future strategies (n = 0): <none>
[13:35:10.078] {
[13:35:10.078]     {
[13:35:10.078]         {
[13:35:10.078]             ...future.startTime <- base::Sys.time()
[13:35:10.078]             {
[13:35:10.078]                 {
[13:35:10.078]                   {
[13:35:10.078]                     {
[13:35:10.078]                       {
[13:35:10.078]                         base::local({
[13:35:10.078]                           has_future <- base::requireNamespace("future", 
[13:35:10.078]                             quietly = TRUE)
[13:35:10.078]                           if (has_future) {
[13:35:10.078]                             ns <- base::getNamespace("future")
[13:35:10.078]                             version <- ns[[".package"]][["version"]]
[13:35:10.078]                             if (is.null(version)) 
[13:35:10.078]                               version <- utils::packageVersion("future")
[13:35:10.078]                           }
[13:35:10.078]                           else {
[13:35:10.078]                             version <- NULL
[13:35:10.078]                           }
[13:35:10.078]                           if (!has_future || version < "1.8.0") {
[13:35:10.078]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:10.078]                               "", base::R.version$version.string), 
[13:35:10.078]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:10.078]                                 base::R.version$platform, 8 * 
[13:35:10.078]                                   base::.Machine$sizeof.pointer), 
[13:35:10.078]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:10.078]                                 "release", "version")], collapse = " "), 
[13:35:10.078]                               hostname = base::Sys.info()[["nodename"]])
[13:35:10.078]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:10.078]                               info)
[13:35:10.078]                             info <- base::paste(info, collapse = "; ")
[13:35:10.078]                             if (!has_future) {
[13:35:10.078]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:10.078]                                 info)
[13:35:10.078]                             }
[13:35:10.078]                             else {
[13:35:10.078]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:10.078]                                 info, version)
[13:35:10.078]                             }
[13:35:10.078]                             base::stop(msg)
[13:35:10.078]                           }
[13:35:10.078]                         })
[13:35:10.078]                       }
[13:35:10.078]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:10.078]                       base::options(mc.cores = 1L)
[13:35:10.078]                     }
[13:35:10.078]                     base::local({
[13:35:10.078]                       for (pkg in "future.apply") {
[13:35:10.078]                         base::loadNamespace(pkg)
[13:35:10.078]                         base::library(pkg, character.only = TRUE)
[13:35:10.078]                       }
[13:35:10.078]                     })
[13:35:10.078]                   }
[13:35:10.078]                   ...future.strategy.old <- future::plan("list")
[13:35:10.078]                   options(future.plan = NULL)
[13:35:10.078]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:10.078]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:10.078]                 }
[13:35:10.078]                 ...future.workdir <- getwd()
[13:35:10.078]             }
[13:35:10.078]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:10.078]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:10.078]         }
[13:35:10.078]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:10.078]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:10.078]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:10.078]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:10.078]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:10.078]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:10.078]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:10.078]             base::names(...future.oldOptions))
[13:35:10.078]     }
[13:35:10.078]     if (FALSE) {
[13:35:10.078]     }
[13:35:10.078]     else {
[13:35:10.078]         if (TRUE) {
[13:35:10.078]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:10.078]                 open = "w")
[13:35:10.078]         }
[13:35:10.078]         else {
[13:35:10.078]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:10.078]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:10.078]         }
[13:35:10.078]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:10.078]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:10.078]             base::sink(type = "output", split = FALSE)
[13:35:10.078]             base::close(...future.stdout)
[13:35:10.078]         }, add = TRUE)
[13:35:10.078]     }
[13:35:10.078]     ...future.frame <- base::sys.nframe()
[13:35:10.078]     ...future.conditions <- base::list()
[13:35:10.078]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:10.078]     if (FALSE) {
[13:35:10.078]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:10.078]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:10.078]     }
[13:35:10.078]     ...future.result <- base::tryCatch({
[13:35:10.078]         base::withCallingHandlers({
[13:35:10.078]             ...future.value <- base::withVisible(base::local({
[13:35:10.078]                 ...future.makeSendCondition <- base::local({
[13:35:10.078]                   sendCondition <- NULL
[13:35:10.078]                   function(frame = 1L) {
[13:35:10.078]                     if (is.function(sendCondition)) 
[13:35:10.078]                       return(sendCondition)
[13:35:10.078]                     ns <- getNamespace("parallel")
[13:35:10.078]                     if (exists("sendData", mode = "function", 
[13:35:10.078]                       envir = ns)) {
[13:35:10.078]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:10.078]                         envir = ns)
[13:35:10.078]                       envir <- sys.frame(frame)
[13:35:10.078]                       master <- NULL
[13:35:10.078]                       while (!identical(envir, .GlobalEnv) && 
[13:35:10.078]                         !identical(envir, emptyenv())) {
[13:35:10.078]                         if (exists("master", mode = "list", envir = envir, 
[13:35:10.078]                           inherits = FALSE)) {
[13:35:10.078]                           master <- get("master", mode = "list", 
[13:35:10.078]                             envir = envir, inherits = FALSE)
[13:35:10.078]                           if (inherits(master, c("SOCKnode", 
[13:35:10.078]                             "SOCK0node"))) {
[13:35:10.078]                             sendCondition <<- function(cond) {
[13:35:10.078]                               data <- list(type = "VALUE", value = cond, 
[13:35:10.078]                                 success = TRUE)
[13:35:10.078]                               parallel_sendData(master, data)
[13:35:10.078]                             }
[13:35:10.078]                             return(sendCondition)
[13:35:10.078]                           }
[13:35:10.078]                         }
[13:35:10.078]                         frame <- frame + 1L
[13:35:10.078]                         envir <- sys.frame(frame)
[13:35:10.078]                       }
[13:35:10.078]                     }
[13:35:10.078]                     sendCondition <<- function(cond) NULL
[13:35:10.078]                   }
[13:35:10.078]                 })
[13:35:10.078]                 withCallingHandlers({
[13:35:10.078]                   {
[13:35:10.078]                     do.call(function(...) {
[13:35:10.078]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.078]                       if (!identical(...future.globals.maxSize.org, 
[13:35:10.078]                         ...future.globals.maxSize)) {
[13:35:10.078]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.078]                         on.exit(options(oopts), add = TRUE)
[13:35:10.078]                       }
[13:35:10.078]                       {
[13:35:10.078]                         lapply(seq_along(...future.elements_ii), 
[13:35:10.078]                           FUN = function(jj) {
[13:35:10.078]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.078]                             ...future.FUN(...future.X_jj, ...)
[13:35:10.078]                           })
[13:35:10.078]                       }
[13:35:10.078]                     }, args = future.call.arguments)
[13:35:10.078]                   }
[13:35:10.078]                 }, immediateCondition = function(cond) {
[13:35:10.078]                   sendCondition <- ...future.makeSendCondition()
[13:35:10.078]                   sendCondition(cond)
[13:35:10.078]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.078]                   {
[13:35:10.078]                     inherits <- base::inherits
[13:35:10.078]                     invokeRestart <- base::invokeRestart
[13:35:10.078]                     is.null <- base::is.null
[13:35:10.078]                     muffled <- FALSE
[13:35:10.078]                     if (inherits(cond, "message")) {
[13:35:10.078]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:10.078]                       if (muffled) 
[13:35:10.078]                         invokeRestart("muffleMessage")
[13:35:10.078]                     }
[13:35:10.078]                     else if (inherits(cond, "warning")) {
[13:35:10.078]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:10.078]                       if (muffled) 
[13:35:10.078]                         invokeRestart("muffleWarning")
[13:35:10.078]                     }
[13:35:10.078]                     else if (inherits(cond, "condition")) {
[13:35:10.078]                       if (!is.null(pattern)) {
[13:35:10.078]                         computeRestarts <- base::computeRestarts
[13:35:10.078]                         grepl <- base::grepl
[13:35:10.078]                         restarts <- computeRestarts(cond)
[13:35:10.078]                         for (restart in restarts) {
[13:35:10.078]                           name <- restart$name
[13:35:10.078]                           if (is.null(name)) 
[13:35:10.078]                             next
[13:35:10.078]                           if (!grepl(pattern, name)) 
[13:35:10.078]                             next
[13:35:10.078]                           invokeRestart(restart)
[13:35:10.078]                           muffled <- TRUE
[13:35:10.078]                           break
[13:35:10.078]                         }
[13:35:10.078]                       }
[13:35:10.078]                     }
[13:35:10.078]                     invisible(muffled)
[13:35:10.078]                   }
[13:35:10.078]                   muffleCondition(cond)
[13:35:10.078]                 })
[13:35:10.078]             }))
[13:35:10.078]             future::FutureResult(value = ...future.value$value, 
[13:35:10.078]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:10.078]                   ...future.rng), globalenv = if (FALSE) 
[13:35:10.078]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:10.078]                     ...future.globalenv.names))
[13:35:10.078]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:10.078]         }, condition = base::local({
[13:35:10.078]             c <- base::c
[13:35:10.078]             inherits <- base::inherits
[13:35:10.078]             invokeRestart <- base::invokeRestart
[13:35:10.078]             length <- base::length
[13:35:10.078]             list <- base::list
[13:35:10.078]             seq.int <- base::seq.int
[13:35:10.078]             signalCondition <- base::signalCondition
[13:35:10.078]             sys.calls <- base::sys.calls
[13:35:10.078]             `[[` <- base::`[[`
[13:35:10.078]             `+` <- base::`+`
[13:35:10.078]             `<<-` <- base::`<<-`
[13:35:10.078]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:10.078]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:10.078]                   3L)]
[13:35:10.078]             }
[13:35:10.078]             function(cond) {
[13:35:10.078]                 is_error <- inherits(cond, "error")
[13:35:10.078]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:10.078]                   NULL)
[13:35:10.078]                 if (is_error) {
[13:35:10.078]                   sessionInformation <- function() {
[13:35:10.078]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:10.078]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:10.078]                       search = base::search(), system = base::Sys.info())
[13:35:10.078]                   }
[13:35:10.078]                   ...future.conditions[[length(...future.conditions) + 
[13:35:10.078]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:10.078]                     cond$call), session = sessionInformation(), 
[13:35:10.078]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:10.078]                   signalCondition(cond)
[13:35:10.078]                 }
[13:35:10.078]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:10.078]                 "immediateCondition"))) {
[13:35:10.078]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:10.078]                   ...future.conditions[[length(...future.conditions) + 
[13:35:10.078]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:10.078]                   if (TRUE && !signal) {
[13:35:10.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.078]                     {
[13:35:10.078]                       inherits <- base::inherits
[13:35:10.078]                       invokeRestart <- base::invokeRestart
[13:35:10.078]                       is.null <- base::is.null
[13:35:10.078]                       muffled <- FALSE
[13:35:10.078]                       if (inherits(cond, "message")) {
[13:35:10.078]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:10.078]                         if (muffled) 
[13:35:10.078]                           invokeRestart("muffleMessage")
[13:35:10.078]                       }
[13:35:10.078]                       else if (inherits(cond, "warning")) {
[13:35:10.078]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:10.078]                         if (muffled) 
[13:35:10.078]                           invokeRestart("muffleWarning")
[13:35:10.078]                       }
[13:35:10.078]                       else if (inherits(cond, "condition")) {
[13:35:10.078]                         if (!is.null(pattern)) {
[13:35:10.078]                           computeRestarts <- base::computeRestarts
[13:35:10.078]                           grepl <- base::grepl
[13:35:10.078]                           restarts <- computeRestarts(cond)
[13:35:10.078]                           for (restart in restarts) {
[13:35:10.078]                             name <- restart$name
[13:35:10.078]                             if (is.null(name)) 
[13:35:10.078]                               next
[13:35:10.078]                             if (!grepl(pattern, name)) 
[13:35:10.078]                               next
[13:35:10.078]                             invokeRestart(restart)
[13:35:10.078]                             muffled <- TRUE
[13:35:10.078]                             break
[13:35:10.078]                           }
[13:35:10.078]                         }
[13:35:10.078]                       }
[13:35:10.078]                       invisible(muffled)
[13:35:10.078]                     }
[13:35:10.078]                     muffleCondition(cond, pattern = "^muffle")
[13:35:10.078]                   }
[13:35:10.078]                 }
[13:35:10.078]                 else {
[13:35:10.078]                   if (TRUE) {
[13:35:10.078]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.078]                     {
[13:35:10.078]                       inherits <- base::inherits
[13:35:10.078]                       invokeRestart <- base::invokeRestart
[13:35:10.078]                       is.null <- base::is.null
[13:35:10.078]                       muffled <- FALSE
[13:35:10.078]                       if (inherits(cond, "message")) {
[13:35:10.078]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:10.078]                         if (muffled) 
[13:35:10.078]                           invokeRestart("muffleMessage")
[13:35:10.078]                       }
[13:35:10.078]                       else if (inherits(cond, "warning")) {
[13:35:10.078]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:10.078]                         if (muffled) 
[13:35:10.078]                           invokeRestart("muffleWarning")
[13:35:10.078]                       }
[13:35:10.078]                       else if (inherits(cond, "condition")) {
[13:35:10.078]                         if (!is.null(pattern)) {
[13:35:10.078]                           computeRestarts <- base::computeRestarts
[13:35:10.078]                           grepl <- base::grepl
[13:35:10.078]                           restarts <- computeRestarts(cond)
[13:35:10.078]                           for (restart in restarts) {
[13:35:10.078]                             name <- restart$name
[13:35:10.078]                             if (is.null(name)) 
[13:35:10.078]                               next
[13:35:10.078]                             if (!grepl(pattern, name)) 
[13:35:10.078]                               next
[13:35:10.078]                             invokeRestart(restart)
[13:35:10.078]                             muffled <- TRUE
[13:35:10.078]                             break
[13:35:10.078]                           }
[13:35:10.078]                         }
[13:35:10.078]                       }
[13:35:10.078]                       invisible(muffled)
[13:35:10.078]                     }
[13:35:10.078]                     muffleCondition(cond, pattern = "^muffle")
[13:35:10.078]                   }
[13:35:10.078]                 }
[13:35:10.078]             }
[13:35:10.078]         }))
[13:35:10.078]     }, error = function(ex) {
[13:35:10.078]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:10.078]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:10.078]                 ...future.rng), started = ...future.startTime, 
[13:35:10.078]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:10.078]             version = "1.8"), class = "FutureResult")
[13:35:10.078]     }, finally = {
[13:35:10.078]         if (!identical(...future.workdir, getwd())) 
[13:35:10.078]             setwd(...future.workdir)
[13:35:10.078]         {
[13:35:10.078]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:10.078]                 ...future.oldOptions$nwarnings <- NULL
[13:35:10.078]             }
[13:35:10.078]             base::options(...future.oldOptions)
[13:35:10.078]             if (.Platform$OS.type == "windows") {
[13:35:10.078]                 old_names <- names(...future.oldEnvVars)
[13:35:10.078]                 envs <- base::Sys.getenv()
[13:35:10.078]                 names <- names(envs)
[13:35:10.078]                 common <- intersect(names, old_names)
[13:35:10.078]                 added <- setdiff(names, old_names)
[13:35:10.078]                 removed <- setdiff(old_names, names)
[13:35:10.078]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:10.078]                   envs[common]]
[13:35:10.078]                 NAMES <- toupper(changed)
[13:35:10.078]                 args <- list()
[13:35:10.078]                 for (kk in seq_along(NAMES)) {
[13:35:10.078]                   name <- changed[[kk]]
[13:35:10.078]                   NAME <- NAMES[[kk]]
[13:35:10.078]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.078]                     next
[13:35:10.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:10.078]                 }
[13:35:10.078]                 NAMES <- toupper(added)
[13:35:10.078]                 for (kk in seq_along(NAMES)) {
[13:35:10.078]                   name <- added[[kk]]
[13:35:10.078]                   NAME <- NAMES[[kk]]
[13:35:10.078]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.078]                     next
[13:35:10.078]                   args[[name]] <- ""
[13:35:10.078]                 }
[13:35:10.078]                 NAMES <- toupper(removed)
[13:35:10.078]                 for (kk in seq_along(NAMES)) {
[13:35:10.078]                   name <- removed[[kk]]
[13:35:10.078]                   NAME <- NAMES[[kk]]
[13:35:10.078]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.078]                     next
[13:35:10.078]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:10.078]                 }
[13:35:10.078]                 if (length(args) > 0) 
[13:35:10.078]                   base::do.call(base::Sys.setenv, args = args)
[13:35:10.078]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:10.078]             }
[13:35:10.078]             else {
[13:35:10.078]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:10.078]             }
[13:35:10.078]             {
[13:35:10.078]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:10.078]                   0L) {
[13:35:10.078]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:10.078]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:10.078]                   base::options(opts)
[13:35:10.078]                 }
[13:35:10.078]                 {
[13:35:10.078]                   {
[13:35:10.078]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:10.078]                     NULL
[13:35:10.078]                   }
[13:35:10.078]                   options(future.plan = NULL)
[13:35:10.078]                   if (is.na(NA_character_)) 
[13:35:10.078]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:10.078]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:10.078]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:10.078]                     .init = FALSE)
[13:35:10.078]                 }
[13:35:10.078]             }
[13:35:10.078]         }
[13:35:10.078]     })
[13:35:10.078]     if (TRUE) {
[13:35:10.078]         base::sink(type = "output", split = FALSE)
[13:35:10.078]         if (TRUE) {
[13:35:10.078]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:10.078]         }
[13:35:10.078]         else {
[13:35:10.078]             ...future.result["stdout"] <- base::list(NULL)
[13:35:10.078]         }
[13:35:10.078]         base::close(...future.stdout)
[13:35:10.078]         ...future.stdout <- NULL
[13:35:10.078]     }
[13:35:10.078]     ...future.result$conditions <- ...future.conditions
[13:35:10.078]     ...future.result$finished <- base::Sys.time()
[13:35:10.078]     ...future.result
[13:35:10.078] }
[13:35:10.081] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[13:35:10.081] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:10.122] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:10.123] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[13:35:10.123] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[13:35:10.123] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:10.124] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:10.124] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:10.166] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:10.167] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:10.210] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:10.211] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:10.211] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.211] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:10.212] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:10.212] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:10.212] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.212] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:35:10.213] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:35:10.213] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:10.213] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.213] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:10.214] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.214] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[13:35:10.214] MultisessionFuture started
[13:35:10.214] - Launch lazy future ... done
[13:35:10.214] run() for ‘MultisessionFuture’ ... done
[13:35:10.215] Created future:
[13:35:10.216] receiveMessageFromWorker() for ClusterFuture ...
[13:35:10.216] - Validating connection of MultisessionFuture
[13:35:10.216] - received message: FutureResult
[13:35:10.216] - Received FutureResult
[13:35:10.217] - Erased future from FutureRegistry
[13:35:10.217] result() for ClusterFuture ...
[13:35:10.217] - result already collected: FutureResult
[13:35:10.217] result() for ClusterFuture ... done
[13:35:10.217] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:10.215] MultisessionFuture:
[13:35:10.215] Label: ‘future_vapply-2’
[13:35:10.215] Expression:
[13:35:10.215] {
[13:35:10.215]     do.call(function(...) {
[13:35:10.215]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.215]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:10.215]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.215]             on.exit(options(oopts), add = TRUE)
[13:35:10.215]         }
[13:35:10.215]         {
[13:35:10.215]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:10.215]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.215]                 ...future.FUN(...future.X_jj, ...)
[13:35:10.215]             })
[13:35:10.215]         }
[13:35:10.215]     }, args = future.call.arguments)
[13:35:10.215] }
[13:35:10.215] Lazy evaluation: FALSE
[13:35:10.215] Asynchronous evaluation: TRUE
[13:35:10.215] Local evaluation: TRUE
[13:35:10.215] Environment: R_GlobalEnv
[13:35:10.215] Capture standard output: TRUE
[13:35:10.215] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:10.215] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:10.215] Packages: 1 packages (‘future.apply’)
[13:35:10.215] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:10.215] Resolved: TRUE
[13:35:10.215] Value: <not collected>
[13:35:10.215] Conditions captured: <none>
[13:35:10.215] Early signaling: FALSE
[13:35:10.215] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:10.215] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:10.217] Chunk #2 of 2 ... DONE
[13:35:10.217] Launching 2 futures (chunks) ... DONE
[13:35:10.217] Resolving 2 futures (chunks) ...
[13:35:10.218] resolve() on list ...
[13:35:10.218]  recursive: 0
[13:35:10.218]  length: 2
[13:35:10.218] 
[13:35:10.218] Future #1
[13:35:10.218] result() for ClusterFuture ...
[13:35:10.218] - result already collected: FutureResult
[13:35:10.218] result() for ClusterFuture ... done
[13:35:10.218] result() for ClusterFuture ...
[13:35:10.218] - result already collected: FutureResult
[13:35:10.218] result() for ClusterFuture ... done
[13:35:10.219] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:10.219] - nx: 2
[13:35:10.219] - relay: TRUE
[13:35:10.219] - stdout: TRUE
[13:35:10.219] - signal: TRUE
[13:35:10.219] - resignal: FALSE
[13:35:10.219] - force: TRUE
[13:35:10.219] - relayed: [n=2] FALSE, FALSE
[13:35:10.219] - queued futures: [n=2] FALSE, FALSE
[13:35:10.219]  - until=1
[13:35:10.219]  - relaying element #1
[13:35:10.220] result() for ClusterFuture ...
[13:35:10.220] - result already collected: FutureResult
[13:35:10.220] result() for ClusterFuture ... done
[13:35:10.220] result() for ClusterFuture ...
[13:35:10.220] - result already collected: FutureResult
[13:35:10.220] result() for ClusterFuture ... done
[13:35:10.220] result() for ClusterFuture ...
[13:35:10.220] - result already collected: FutureResult
[13:35:10.220] result() for ClusterFuture ... done
[13:35:10.220] result() for ClusterFuture ...
[13:35:10.220] - result already collected: FutureResult
[13:35:10.221] result() for ClusterFuture ... done
[13:35:10.221] - relayed: [n=2] TRUE, FALSE
[13:35:10.221] - queued futures: [n=2] TRUE, FALSE
[13:35:10.221] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:10.221]  length: 1 (resolved future 1)
[13:35:10.221] Future #2
[13:35:10.221] result() for ClusterFuture ...
[13:35:10.221] - result already collected: FutureResult
[13:35:10.221] result() for ClusterFuture ... done
[13:35:10.221] result() for ClusterFuture ...
[13:35:10.221] - result already collected: FutureResult
[13:35:10.222] result() for ClusterFuture ... done
[13:35:10.222] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:10.222] - nx: 2
[13:35:10.222] - relay: TRUE
[13:35:10.222] - stdout: TRUE
[13:35:10.222] - signal: TRUE
[13:35:10.222] - resignal: FALSE
[13:35:10.222] - force: TRUE
[13:35:10.222] - relayed: [n=2] TRUE, FALSE
[13:35:10.222] - queued futures: [n=2] TRUE, FALSE
[13:35:10.222]  - until=2
[13:35:10.222]  - relaying element #2
[13:35:10.223] result() for ClusterFuture ...
[13:35:10.223] - result already collected: FutureResult
[13:35:10.223] result() for ClusterFuture ... done
[13:35:10.223] result() for ClusterFuture ...
[13:35:10.223] - result already collected: FutureResult
[13:35:10.223] result() for ClusterFuture ... done
[13:35:10.223] result() for ClusterFuture ...
[13:35:10.223] - result already collected: FutureResult
[13:35:10.223] result() for ClusterFuture ... done
[13:35:10.223] result() for ClusterFuture ...
[13:35:10.223] - result already collected: FutureResult
[13:35:10.224] result() for ClusterFuture ... done
[13:35:10.224] - relayed: [n=2] TRUE, TRUE
[13:35:10.224] - queued futures: [n=2] TRUE, TRUE
[13:35:10.224] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:10.224]  length: 0 (resolved future 2)
[13:35:10.224] Relaying remaining futures
[13:35:10.224] signalConditionsASAP(NULL, pos=0) ...
[13:35:10.224] - nx: 2
[13:35:10.224] - relay: TRUE
[13:35:10.224] - stdout: TRUE
[13:35:10.224] - signal: TRUE
[13:35:10.224] - resignal: FALSE
[13:35:10.225] - force: TRUE
[13:35:10.225] - relayed: [n=2] TRUE, TRUE
[13:35:10.225] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:10.225] - relayed: [n=2] TRUE, TRUE
[13:35:10.225] - queued futures: [n=2] TRUE, TRUE
[13:35:10.225] signalConditionsASAP(NULL, pos=0) ... done
[13:35:10.225] resolve() on list ... DONE
[13:35:10.225] result() for ClusterFuture ...
[13:35:10.225] - result already collected: FutureResult
[13:35:10.225] result() for ClusterFuture ... done
[13:35:10.225] result() for ClusterFuture ...
[13:35:10.226] - result already collected: FutureResult
[13:35:10.226] result() for ClusterFuture ... done
[13:35:10.226] result() for ClusterFuture ...
[13:35:10.226] - result already collected: FutureResult
[13:35:10.226] result() for ClusterFuture ... done
[13:35:10.226] result() for ClusterFuture ...
[13:35:10.226] - result already collected: FutureResult
[13:35:10.226] result() for ClusterFuture ... done
[13:35:10.226]  - Number of value chunks collected: 2
[13:35:10.226] Resolving 2 futures (chunks) ... DONE
[13:35:10.226] Reducing values from 2 chunks ...
[13:35:10.227]  - Number of values collected after concatenation: 10
[13:35:10.227]  - Number of values expected: 10
[13:35:10.227] Reducing values from 2 chunks ... DONE
[13:35:10.227] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[13:35:10.228] future_lapply() ...
[13:35:10.239] Number of chunks: 2
[13:35:10.239] getGlobalsAndPackagesXApply() ...
[13:35:10.240]  - future.globals: TRUE
[13:35:10.240] getGlobalsAndPackages() ...
[13:35:10.240] Searching for globals...
[13:35:10.243] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[13:35:10.244] Searching for globals ... DONE
[13:35:10.244] Resolving globals: FALSE
[13:35:10.245] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[13:35:10.245] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:10.245] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:10.245] - packages: [1] ‘future.apply’
[13:35:10.245] getGlobalsAndPackages() ... DONE
[13:35:10.245]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:10.246]  - needed namespaces: [n=1] ‘future.apply’
[13:35:10.246] Finding globals ... DONE
[13:35:10.246]  - use_args: TRUE
[13:35:10.246]  - Getting '...' globals ...
[13:35:10.246] resolve() on list ...
[13:35:10.246]  recursive: 0
[13:35:10.246]  length: 1
[13:35:10.246]  elements: ‘...’
[13:35:10.247]  length: 0 (resolved future 1)
[13:35:10.247] resolve() on list ... DONE
[13:35:10.247]    - '...' content: [n=0] 
[13:35:10.247] List of 1
[13:35:10.247]  $ ...: list()
[13:35:10.247]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:10.247]  - attr(*, "where")=List of 1
[13:35:10.247]   ..$ ...:<environment: 0x5574d3376fb8> 
[13:35:10.247]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:10.247]  - attr(*, "resolved")= logi TRUE
[13:35:10.247]  - attr(*, "total_size")= num NA
[13:35:10.249]  - Getting '...' globals ... DONE
[13:35:10.250] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:10.250] List of 8
[13:35:10.250]  $ ...future.FUN:function (x, ...)  
[13:35:10.250]  $ x_FUN        :function (x)  
[13:35:10.250]  $ times        : int 0
[13:35:10.250]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:10.250]  $ stop_if_not  :function (...)  
[13:35:10.250]  $ dim          : NULL
[13:35:10.250]  $ valid_types  : chr [1:2] "logical" "integer"
[13:35:10.250]  $ ...          : list()
[13:35:10.250]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:10.250]  - attr(*, "where")=List of 8
[13:35:10.250]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:10.250]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:10.250]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:10.250]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:10.250]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:10.250]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:10.250]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:10.250]   ..$ ...          :<environment: 0x5574d3376fb8> 
[13:35:10.250]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:10.250]  - attr(*, "resolved")= logi FALSE
[13:35:10.250]  - attr(*, "total_size")= num 95400
[13:35:10.255] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:10.255] getGlobalsAndPackagesXApply() ... DONE
[13:35:10.255] Number of futures (= number of chunks): 2
[13:35:10.256] Launching 2 futures (chunks) ...
[13:35:10.256] Chunk #1 of 2 ...
[13:35:10.256]  - Finding globals in 'X' for chunk #1 ...
[13:35:10.256] getGlobalsAndPackages() ...
[13:35:10.256] Searching for globals...
[13:35:10.256] 
[13:35:10.256] Searching for globals ... DONE
[13:35:10.256] - globals: [0] <none>
[13:35:10.257] getGlobalsAndPackages() ... DONE
[13:35:10.257]    + additional globals found: [n=0] 
[13:35:10.257]    + additional namespaces needed: [n=0] 
[13:35:10.257]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:10.257]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:10.257]  - seeds: <none>
[13:35:10.257]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.257] getGlobalsAndPackages() ...
[13:35:10.257] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.257] Resolving globals: FALSE
[13:35:10.258] Tweak future expression to call with '...' arguments ...
[13:35:10.258] {
[13:35:10.258]     do.call(function(...) {
[13:35:10.258]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.258]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:10.258]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.258]             on.exit(options(oopts), add = TRUE)
[13:35:10.258]         }
[13:35:10.258]         {
[13:35:10.258]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:10.258]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.258]                 ...future.FUN(...future.X_jj, ...)
[13:35:10.258]             })
[13:35:10.258]         }
[13:35:10.258]     }, args = future.call.arguments)
[13:35:10.258] }
[13:35:10.258] Tweak future expression to call with '...' arguments ... DONE
[13:35:10.258] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.259] - packages: [1] ‘future.apply’
[13:35:10.259] getGlobalsAndPackages() ... DONE
[13:35:10.259] run() for ‘Future’ ...
[13:35:10.259] - state: ‘created’
[13:35:10.259] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:10.273] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:10.273] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:10.273]   - Field: ‘node’
[13:35:10.273]   - Field: ‘label’
[13:35:10.273]   - Field: ‘local’
[13:35:10.273]   - Field: ‘owner’
[13:35:10.274]   - Field: ‘envir’
[13:35:10.274]   - Field: ‘workers’
[13:35:10.274]   - Field: ‘packages’
[13:35:10.274]   - Field: ‘gc’
[13:35:10.274]   - Field: ‘conditions’
[13:35:10.274]   - Field: ‘persistent’
[13:35:10.274]   - Field: ‘expr’
[13:35:10.274]   - Field: ‘uuid’
[13:35:10.274]   - Field: ‘seed’
[13:35:10.274]   - Field: ‘version’
[13:35:10.274]   - Field: ‘result’
[13:35:10.275]   - Field: ‘asynchronous’
[13:35:10.275]   - Field: ‘calls’
[13:35:10.275]   - Field: ‘globals’
[13:35:10.275]   - Field: ‘stdout’
[13:35:10.275]   - Field: ‘earlySignal’
[13:35:10.275]   - Field: ‘lazy’
[13:35:10.275]   - Field: ‘state’
[13:35:10.275] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:10.275] - Launch lazy future ...
[13:35:10.276] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:10.276] Packages needed by future strategies (n = 0): <none>
[13:35:10.276] {
[13:35:10.276]     {
[13:35:10.276]         {
[13:35:10.276]             ...future.startTime <- base::Sys.time()
[13:35:10.276]             {
[13:35:10.276]                 {
[13:35:10.276]                   {
[13:35:10.276]                     {
[13:35:10.276]                       {
[13:35:10.276]                         base::local({
[13:35:10.276]                           has_future <- base::requireNamespace("future", 
[13:35:10.276]                             quietly = TRUE)
[13:35:10.276]                           if (has_future) {
[13:35:10.276]                             ns <- base::getNamespace("future")
[13:35:10.276]                             version <- ns[[".package"]][["version"]]
[13:35:10.276]                             if (is.null(version)) 
[13:35:10.276]                               version <- utils::packageVersion("future")
[13:35:10.276]                           }
[13:35:10.276]                           else {
[13:35:10.276]                             version <- NULL
[13:35:10.276]                           }
[13:35:10.276]                           if (!has_future || version < "1.8.0") {
[13:35:10.276]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:10.276]                               "", base::R.version$version.string), 
[13:35:10.276]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:10.276]                                 base::R.version$platform, 8 * 
[13:35:10.276]                                   base::.Machine$sizeof.pointer), 
[13:35:10.276]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:10.276]                                 "release", "version")], collapse = " "), 
[13:35:10.276]                               hostname = base::Sys.info()[["nodename"]])
[13:35:10.276]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:10.276]                               info)
[13:35:10.276]                             info <- base::paste(info, collapse = "; ")
[13:35:10.276]                             if (!has_future) {
[13:35:10.276]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:10.276]                                 info)
[13:35:10.276]                             }
[13:35:10.276]                             else {
[13:35:10.276]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:10.276]                                 info, version)
[13:35:10.276]                             }
[13:35:10.276]                             base::stop(msg)
[13:35:10.276]                           }
[13:35:10.276]                         })
[13:35:10.276]                       }
[13:35:10.276]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:10.276]                       base::options(mc.cores = 1L)
[13:35:10.276]                     }
[13:35:10.276]                     base::local({
[13:35:10.276]                       for (pkg in "future.apply") {
[13:35:10.276]                         base::loadNamespace(pkg)
[13:35:10.276]                         base::library(pkg, character.only = TRUE)
[13:35:10.276]                       }
[13:35:10.276]                     })
[13:35:10.276]                   }
[13:35:10.276]                   ...future.strategy.old <- future::plan("list")
[13:35:10.276]                   options(future.plan = NULL)
[13:35:10.276]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:10.276]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:10.276]                 }
[13:35:10.276]                 ...future.workdir <- getwd()
[13:35:10.276]             }
[13:35:10.276]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:10.276]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:10.276]         }
[13:35:10.276]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:10.276]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:10.276]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:10.276]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:10.276]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:10.276]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:10.276]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:10.276]             base::names(...future.oldOptions))
[13:35:10.276]     }
[13:35:10.276]     if (FALSE) {
[13:35:10.276]     }
[13:35:10.276]     else {
[13:35:10.276]         if (TRUE) {
[13:35:10.276]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:10.276]                 open = "w")
[13:35:10.276]         }
[13:35:10.276]         else {
[13:35:10.276]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:10.276]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:10.276]         }
[13:35:10.276]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:10.276]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:10.276]             base::sink(type = "output", split = FALSE)
[13:35:10.276]             base::close(...future.stdout)
[13:35:10.276]         }, add = TRUE)
[13:35:10.276]     }
[13:35:10.276]     ...future.frame <- base::sys.nframe()
[13:35:10.276]     ...future.conditions <- base::list()
[13:35:10.276]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:10.276]     if (FALSE) {
[13:35:10.276]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:10.276]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:10.276]     }
[13:35:10.276]     ...future.result <- base::tryCatch({
[13:35:10.276]         base::withCallingHandlers({
[13:35:10.276]             ...future.value <- base::withVisible(base::local({
[13:35:10.276]                 ...future.makeSendCondition <- base::local({
[13:35:10.276]                   sendCondition <- NULL
[13:35:10.276]                   function(frame = 1L) {
[13:35:10.276]                     if (is.function(sendCondition)) 
[13:35:10.276]                       return(sendCondition)
[13:35:10.276]                     ns <- getNamespace("parallel")
[13:35:10.276]                     if (exists("sendData", mode = "function", 
[13:35:10.276]                       envir = ns)) {
[13:35:10.276]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:10.276]                         envir = ns)
[13:35:10.276]                       envir <- sys.frame(frame)
[13:35:10.276]                       master <- NULL
[13:35:10.276]                       while (!identical(envir, .GlobalEnv) && 
[13:35:10.276]                         !identical(envir, emptyenv())) {
[13:35:10.276]                         if (exists("master", mode = "list", envir = envir, 
[13:35:10.276]                           inherits = FALSE)) {
[13:35:10.276]                           master <- get("master", mode = "list", 
[13:35:10.276]                             envir = envir, inherits = FALSE)
[13:35:10.276]                           if (inherits(master, c("SOCKnode", 
[13:35:10.276]                             "SOCK0node"))) {
[13:35:10.276]                             sendCondition <<- function(cond) {
[13:35:10.276]                               data <- list(type = "VALUE", value = cond, 
[13:35:10.276]                                 success = TRUE)
[13:35:10.276]                               parallel_sendData(master, data)
[13:35:10.276]                             }
[13:35:10.276]                             return(sendCondition)
[13:35:10.276]                           }
[13:35:10.276]                         }
[13:35:10.276]                         frame <- frame + 1L
[13:35:10.276]                         envir <- sys.frame(frame)
[13:35:10.276]                       }
[13:35:10.276]                     }
[13:35:10.276]                     sendCondition <<- function(cond) NULL
[13:35:10.276]                   }
[13:35:10.276]                 })
[13:35:10.276]                 withCallingHandlers({
[13:35:10.276]                   {
[13:35:10.276]                     do.call(function(...) {
[13:35:10.276]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.276]                       if (!identical(...future.globals.maxSize.org, 
[13:35:10.276]                         ...future.globals.maxSize)) {
[13:35:10.276]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.276]                         on.exit(options(oopts), add = TRUE)
[13:35:10.276]                       }
[13:35:10.276]                       {
[13:35:10.276]                         lapply(seq_along(...future.elements_ii), 
[13:35:10.276]                           FUN = function(jj) {
[13:35:10.276]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.276]                             ...future.FUN(...future.X_jj, ...)
[13:35:10.276]                           })
[13:35:10.276]                       }
[13:35:10.276]                     }, args = future.call.arguments)
[13:35:10.276]                   }
[13:35:10.276]                 }, immediateCondition = function(cond) {
[13:35:10.276]                   sendCondition <- ...future.makeSendCondition()
[13:35:10.276]                   sendCondition(cond)
[13:35:10.276]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.276]                   {
[13:35:10.276]                     inherits <- base::inherits
[13:35:10.276]                     invokeRestart <- base::invokeRestart
[13:35:10.276]                     is.null <- base::is.null
[13:35:10.276]                     muffled <- FALSE
[13:35:10.276]                     if (inherits(cond, "message")) {
[13:35:10.276]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:10.276]                       if (muffled) 
[13:35:10.276]                         invokeRestart("muffleMessage")
[13:35:10.276]                     }
[13:35:10.276]                     else if (inherits(cond, "warning")) {
[13:35:10.276]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:10.276]                       if (muffled) 
[13:35:10.276]                         invokeRestart("muffleWarning")
[13:35:10.276]                     }
[13:35:10.276]                     else if (inherits(cond, "condition")) {
[13:35:10.276]                       if (!is.null(pattern)) {
[13:35:10.276]                         computeRestarts <- base::computeRestarts
[13:35:10.276]                         grepl <- base::grepl
[13:35:10.276]                         restarts <- computeRestarts(cond)
[13:35:10.276]                         for (restart in restarts) {
[13:35:10.276]                           name <- restart$name
[13:35:10.276]                           if (is.null(name)) 
[13:35:10.276]                             next
[13:35:10.276]                           if (!grepl(pattern, name)) 
[13:35:10.276]                             next
[13:35:10.276]                           invokeRestart(restart)
[13:35:10.276]                           muffled <- TRUE
[13:35:10.276]                           break
[13:35:10.276]                         }
[13:35:10.276]                       }
[13:35:10.276]                     }
[13:35:10.276]                     invisible(muffled)
[13:35:10.276]                   }
[13:35:10.276]                   muffleCondition(cond)
[13:35:10.276]                 })
[13:35:10.276]             }))
[13:35:10.276]             future::FutureResult(value = ...future.value$value, 
[13:35:10.276]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:10.276]                   ...future.rng), globalenv = if (FALSE) 
[13:35:10.276]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:10.276]                     ...future.globalenv.names))
[13:35:10.276]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:10.276]         }, condition = base::local({
[13:35:10.276]             c <- base::c
[13:35:10.276]             inherits <- base::inherits
[13:35:10.276]             invokeRestart <- base::invokeRestart
[13:35:10.276]             length <- base::length
[13:35:10.276]             list <- base::list
[13:35:10.276]             seq.int <- base::seq.int
[13:35:10.276]             signalCondition <- base::signalCondition
[13:35:10.276]             sys.calls <- base::sys.calls
[13:35:10.276]             `[[` <- base::`[[`
[13:35:10.276]             `+` <- base::`+`
[13:35:10.276]             `<<-` <- base::`<<-`
[13:35:10.276]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:10.276]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:10.276]                   3L)]
[13:35:10.276]             }
[13:35:10.276]             function(cond) {
[13:35:10.276]                 is_error <- inherits(cond, "error")
[13:35:10.276]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:10.276]                   NULL)
[13:35:10.276]                 if (is_error) {
[13:35:10.276]                   sessionInformation <- function() {
[13:35:10.276]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:10.276]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:10.276]                       search = base::search(), system = base::Sys.info())
[13:35:10.276]                   }
[13:35:10.276]                   ...future.conditions[[length(...future.conditions) + 
[13:35:10.276]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:10.276]                     cond$call), session = sessionInformation(), 
[13:35:10.276]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:10.276]                   signalCondition(cond)
[13:35:10.276]                 }
[13:35:10.276]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:10.276]                 "immediateCondition"))) {
[13:35:10.276]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:10.276]                   ...future.conditions[[length(...future.conditions) + 
[13:35:10.276]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:10.276]                   if (TRUE && !signal) {
[13:35:10.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.276]                     {
[13:35:10.276]                       inherits <- base::inherits
[13:35:10.276]                       invokeRestart <- base::invokeRestart
[13:35:10.276]                       is.null <- base::is.null
[13:35:10.276]                       muffled <- FALSE
[13:35:10.276]                       if (inherits(cond, "message")) {
[13:35:10.276]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:10.276]                         if (muffled) 
[13:35:10.276]                           invokeRestart("muffleMessage")
[13:35:10.276]                       }
[13:35:10.276]                       else if (inherits(cond, "warning")) {
[13:35:10.276]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:10.276]                         if (muffled) 
[13:35:10.276]                           invokeRestart("muffleWarning")
[13:35:10.276]                       }
[13:35:10.276]                       else if (inherits(cond, "condition")) {
[13:35:10.276]                         if (!is.null(pattern)) {
[13:35:10.276]                           computeRestarts <- base::computeRestarts
[13:35:10.276]                           grepl <- base::grepl
[13:35:10.276]                           restarts <- computeRestarts(cond)
[13:35:10.276]                           for (restart in restarts) {
[13:35:10.276]                             name <- restart$name
[13:35:10.276]                             if (is.null(name)) 
[13:35:10.276]                               next
[13:35:10.276]                             if (!grepl(pattern, name)) 
[13:35:10.276]                               next
[13:35:10.276]                             invokeRestart(restart)
[13:35:10.276]                             muffled <- TRUE
[13:35:10.276]                             break
[13:35:10.276]                           }
[13:35:10.276]                         }
[13:35:10.276]                       }
[13:35:10.276]                       invisible(muffled)
[13:35:10.276]                     }
[13:35:10.276]                     muffleCondition(cond, pattern = "^muffle")
[13:35:10.276]                   }
[13:35:10.276]                 }
[13:35:10.276]                 else {
[13:35:10.276]                   if (TRUE) {
[13:35:10.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.276]                     {
[13:35:10.276]                       inherits <- base::inherits
[13:35:10.276]                       invokeRestart <- base::invokeRestart
[13:35:10.276]                       is.null <- base::is.null
[13:35:10.276]                       muffled <- FALSE
[13:35:10.276]                       if (inherits(cond, "message")) {
[13:35:10.276]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:10.276]                         if (muffled) 
[13:35:10.276]                           invokeRestart("muffleMessage")
[13:35:10.276]                       }
[13:35:10.276]                       else if (inherits(cond, "warning")) {
[13:35:10.276]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:10.276]                         if (muffled) 
[13:35:10.276]                           invokeRestart("muffleWarning")
[13:35:10.276]                       }
[13:35:10.276]                       else if (inherits(cond, "condition")) {
[13:35:10.276]                         if (!is.null(pattern)) {
[13:35:10.276]                           computeRestarts <- base::computeRestarts
[13:35:10.276]                           grepl <- base::grepl
[13:35:10.276]                           restarts <- computeRestarts(cond)
[13:35:10.276]                           for (restart in restarts) {
[13:35:10.276]                             name <- restart$name
[13:35:10.276]                             if (is.null(name)) 
[13:35:10.276]                               next
[13:35:10.276]                             if (!grepl(pattern, name)) 
[13:35:10.276]                               next
[13:35:10.276]                             invokeRestart(restart)
[13:35:10.276]                             muffled <- TRUE
[13:35:10.276]                             break
[13:35:10.276]                           }
[13:35:10.276]                         }
[13:35:10.276]                       }
[13:35:10.276]                       invisible(muffled)
[13:35:10.276]                     }
[13:35:10.276]                     muffleCondition(cond, pattern = "^muffle")
[13:35:10.276]                   }
[13:35:10.276]                 }
[13:35:10.276]             }
[13:35:10.276]         }))
[13:35:10.276]     }, error = function(ex) {
[13:35:10.276]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:10.276]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:10.276]                 ...future.rng), started = ...future.startTime, 
[13:35:10.276]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:10.276]             version = "1.8"), class = "FutureResult")
[13:35:10.276]     }, finally = {
[13:35:10.276]         if (!identical(...future.workdir, getwd())) 
[13:35:10.276]             setwd(...future.workdir)
[13:35:10.276]         {
[13:35:10.276]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:10.276]                 ...future.oldOptions$nwarnings <- NULL
[13:35:10.276]             }
[13:35:10.276]             base::options(...future.oldOptions)
[13:35:10.276]             if (.Platform$OS.type == "windows") {
[13:35:10.276]                 old_names <- names(...future.oldEnvVars)
[13:35:10.276]                 envs <- base::Sys.getenv()
[13:35:10.276]                 names <- names(envs)
[13:35:10.276]                 common <- intersect(names, old_names)
[13:35:10.276]                 added <- setdiff(names, old_names)
[13:35:10.276]                 removed <- setdiff(old_names, names)
[13:35:10.276]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:10.276]                   envs[common]]
[13:35:10.276]                 NAMES <- toupper(changed)
[13:35:10.276]                 args <- list()
[13:35:10.276]                 for (kk in seq_along(NAMES)) {
[13:35:10.276]                   name <- changed[[kk]]
[13:35:10.276]                   NAME <- NAMES[[kk]]
[13:35:10.276]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.276]                     next
[13:35:10.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:10.276]                 }
[13:35:10.276]                 NAMES <- toupper(added)
[13:35:10.276]                 for (kk in seq_along(NAMES)) {
[13:35:10.276]                   name <- added[[kk]]
[13:35:10.276]                   NAME <- NAMES[[kk]]
[13:35:10.276]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.276]                     next
[13:35:10.276]                   args[[name]] <- ""
[13:35:10.276]                 }
[13:35:10.276]                 NAMES <- toupper(removed)
[13:35:10.276]                 for (kk in seq_along(NAMES)) {
[13:35:10.276]                   name <- removed[[kk]]
[13:35:10.276]                   NAME <- NAMES[[kk]]
[13:35:10.276]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.276]                     next
[13:35:10.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:10.276]                 }
[13:35:10.276]                 if (length(args) > 0) 
[13:35:10.276]                   base::do.call(base::Sys.setenv, args = args)
[13:35:10.276]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:10.276]             }
[13:35:10.276]             else {
[13:35:10.276]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:10.276]             }
[13:35:10.276]             {
[13:35:10.276]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:10.276]                   0L) {
[13:35:10.276]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:10.276]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:10.276]                   base::options(opts)
[13:35:10.276]                 }
[13:35:10.276]                 {
[13:35:10.276]                   {
[13:35:10.276]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:10.276]                     NULL
[13:35:10.276]                   }
[13:35:10.276]                   options(future.plan = NULL)
[13:35:10.276]                   if (is.na(NA_character_)) 
[13:35:10.276]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:10.276]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:10.276]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:10.276]                     .init = FALSE)
[13:35:10.276]                 }
[13:35:10.276]             }
[13:35:10.276]         }
[13:35:10.276]     })
[13:35:10.276]     if (TRUE) {
[13:35:10.276]         base::sink(type = "output", split = FALSE)
[13:35:10.276]         if (TRUE) {
[13:35:10.276]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:10.276]         }
[13:35:10.276]         else {
[13:35:10.276]             ...future.result["stdout"] <- base::list(NULL)
[13:35:10.276]         }
[13:35:10.276]         base::close(...future.stdout)
[13:35:10.276]         ...future.stdout <- NULL
[13:35:10.276]     }
[13:35:10.276]     ...future.result$conditions <- ...future.conditions
[13:35:10.276]     ...future.result$finished <- base::Sys.time()
[13:35:10.276]     ...future.result
[13:35:10.276] }
[13:35:10.279] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[13:35:10.279] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:10.322] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:10.323] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[13:35:10.323] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[13:35:10.323] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:10.324] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:10.324] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:10.366] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:10.367] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:10.410] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:10.411] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:10.411] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.411] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[13:35:10.412] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[13:35:10.412] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:10.412] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.412] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:35:10.413] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:35:10.413] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:10.413] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.413] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:10.414] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.414] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[13:35:10.414] MultisessionFuture started
[13:35:10.414] - Launch lazy future ... done
[13:35:10.414] run() for ‘MultisessionFuture’ ... done
[13:35:10.415] Created future:
[13:35:10.416] receiveMessageFromWorker() for ClusterFuture ...
[13:35:10.416] - Validating connection of MultisessionFuture
[13:35:10.416] - received message: FutureResult
[13:35:10.416] - Received FutureResult
[13:35:10.417] - Erased future from FutureRegistry
[13:35:10.417] result() for ClusterFuture ...
[13:35:10.417] - result already collected: FutureResult
[13:35:10.417] result() for ClusterFuture ... done
[13:35:10.417] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:10.415] MultisessionFuture:
[13:35:10.415] Label: ‘future_vapply-1’
[13:35:10.415] Expression:
[13:35:10.415] {
[13:35:10.415]     do.call(function(...) {
[13:35:10.415]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.415]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:10.415]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.415]             on.exit(options(oopts), add = TRUE)
[13:35:10.415]         }
[13:35:10.415]         {
[13:35:10.415]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:10.415]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.415]                 ...future.FUN(...future.X_jj, ...)
[13:35:10.415]             })
[13:35:10.415]         }
[13:35:10.415]     }, args = future.call.arguments)
[13:35:10.415] }
[13:35:10.415] Lazy evaluation: FALSE
[13:35:10.415] Asynchronous evaluation: TRUE
[13:35:10.415] Local evaluation: TRUE
[13:35:10.415] Environment: R_GlobalEnv
[13:35:10.415] Capture standard output: TRUE
[13:35:10.415] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:10.415] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:10.415] Packages: 1 packages (‘future.apply’)
[13:35:10.415] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:10.415] Resolved: TRUE
[13:35:10.415] Value: <not collected>
[13:35:10.415] Conditions captured: <none>
[13:35:10.415] Early signaling: FALSE
[13:35:10.415] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:10.415] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:10.417] Chunk #1 of 2 ... DONE
[13:35:10.417] Chunk #2 of 2 ...
[13:35:10.418]  - Finding globals in 'X' for chunk #2 ...
[13:35:10.418] getGlobalsAndPackages() ...
[13:35:10.418] Searching for globals...
[13:35:10.418] 
[13:35:10.418] Searching for globals ... DONE
[13:35:10.418] - globals: [0] <none>
[13:35:10.418] getGlobalsAndPackages() ... DONE
[13:35:10.418]    + additional globals found: [n=0] 
[13:35:10.418]    + additional namespaces needed: [n=0] 
[13:35:10.419]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:10.419]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:10.419]  - seeds: <none>
[13:35:10.419]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.419] getGlobalsAndPackages() ...
[13:35:10.419] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.419] Resolving globals: FALSE
[13:35:10.419] Tweak future expression to call with '...' arguments ...
[13:35:10.419] {
[13:35:10.419]     do.call(function(...) {
[13:35:10.419]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.419]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:10.419]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.419]             on.exit(options(oopts), add = TRUE)
[13:35:10.419]         }
[13:35:10.419]         {
[13:35:10.419]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:10.419]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.419]                 ...future.FUN(...future.X_jj, ...)
[13:35:10.419]             })
[13:35:10.419]         }
[13:35:10.419]     }, args = future.call.arguments)
[13:35:10.419] }
[13:35:10.420] Tweak future expression to call with '...' arguments ... DONE
[13:35:10.420] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.420] - packages: [1] ‘future.apply’
[13:35:10.420] getGlobalsAndPackages() ... DONE
[13:35:10.421] run() for ‘Future’ ...
[13:35:10.421] - state: ‘created’
[13:35:10.421] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:10.435] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:10.435] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:10.435]   - Field: ‘node’
[13:35:10.435]   - Field: ‘label’
[13:35:10.435]   - Field: ‘local’
[13:35:10.435]   - Field: ‘owner’
[13:35:10.435]   - Field: ‘envir’
[13:35:10.436]   - Field: ‘workers’
[13:35:10.436]   - Field: ‘packages’
[13:35:10.436]   - Field: ‘gc’
[13:35:10.436]   - Field: ‘conditions’
[13:35:10.436]   - Field: ‘persistent’
[13:35:10.436]   - Field: ‘expr’
[13:35:10.436]   - Field: ‘uuid’
[13:35:10.436]   - Field: ‘seed’
[13:35:10.436]   - Field: ‘version’
[13:35:10.436]   - Field: ‘result’
[13:35:10.436]   - Field: ‘asynchronous’
[13:35:10.437]   - Field: ‘calls’
[13:35:10.437]   - Field: ‘globals’
[13:35:10.437]   - Field: ‘stdout’
[13:35:10.437]   - Field: ‘earlySignal’
[13:35:10.437]   - Field: ‘lazy’
[13:35:10.437]   - Field: ‘state’
[13:35:10.437] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:10.437] - Launch lazy future ...
[13:35:10.437] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:10.438] Packages needed by future strategies (n = 0): <none>
[13:35:10.438] {
[13:35:10.438]     {
[13:35:10.438]         {
[13:35:10.438]             ...future.startTime <- base::Sys.time()
[13:35:10.438]             {
[13:35:10.438]                 {
[13:35:10.438]                   {
[13:35:10.438]                     {
[13:35:10.438]                       {
[13:35:10.438]                         base::local({
[13:35:10.438]                           has_future <- base::requireNamespace("future", 
[13:35:10.438]                             quietly = TRUE)
[13:35:10.438]                           if (has_future) {
[13:35:10.438]                             ns <- base::getNamespace("future")
[13:35:10.438]                             version <- ns[[".package"]][["version"]]
[13:35:10.438]                             if (is.null(version)) 
[13:35:10.438]                               version <- utils::packageVersion("future")
[13:35:10.438]                           }
[13:35:10.438]                           else {
[13:35:10.438]                             version <- NULL
[13:35:10.438]                           }
[13:35:10.438]                           if (!has_future || version < "1.8.0") {
[13:35:10.438]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:10.438]                               "", base::R.version$version.string), 
[13:35:10.438]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:10.438]                                 base::R.version$platform, 8 * 
[13:35:10.438]                                   base::.Machine$sizeof.pointer), 
[13:35:10.438]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:10.438]                                 "release", "version")], collapse = " "), 
[13:35:10.438]                               hostname = base::Sys.info()[["nodename"]])
[13:35:10.438]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:10.438]                               info)
[13:35:10.438]                             info <- base::paste(info, collapse = "; ")
[13:35:10.438]                             if (!has_future) {
[13:35:10.438]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:10.438]                                 info)
[13:35:10.438]                             }
[13:35:10.438]                             else {
[13:35:10.438]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:10.438]                                 info, version)
[13:35:10.438]                             }
[13:35:10.438]                             base::stop(msg)
[13:35:10.438]                           }
[13:35:10.438]                         })
[13:35:10.438]                       }
[13:35:10.438]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:10.438]                       base::options(mc.cores = 1L)
[13:35:10.438]                     }
[13:35:10.438]                     base::local({
[13:35:10.438]                       for (pkg in "future.apply") {
[13:35:10.438]                         base::loadNamespace(pkg)
[13:35:10.438]                         base::library(pkg, character.only = TRUE)
[13:35:10.438]                       }
[13:35:10.438]                     })
[13:35:10.438]                   }
[13:35:10.438]                   ...future.strategy.old <- future::plan("list")
[13:35:10.438]                   options(future.plan = NULL)
[13:35:10.438]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:10.438]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:10.438]                 }
[13:35:10.438]                 ...future.workdir <- getwd()
[13:35:10.438]             }
[13:35:10.438]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:10.438]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:10.438]         }
[13:35:10.438]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:10.438]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:10.438]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:10.438]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:10.438]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:10.438]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:10.438]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:10.438]             base::names(...future.oldOptions))
[13:35:10.438]     }
[13:35:10.438]     if (FALSE) {
[13:35:10.438]     }
[13:35:10.438]     else {
[13:35:10.438]         if (TRUE) {
[13:35:10.438]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:10.438]                 open = "w")
[13:35:10.438]         }
[13:35:10.438]         else {
[13:35:10.438]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:10.438]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:10.438]         }
[13:35:10.438]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:10.438]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:10.438]             base::sink(type = "output", split = FALSE)
[13:35:10.438]             base::close(...future.stdout)
[13:35:10.438]         }, add = TRUE)
[13:35:10.438]     }
[13:35:10.438]     ...future.frame <- base::sys.nframe()
[13:35:10.438]     ...future.conditions <- base::list()
[13:35:10.438]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:10.438]     if (FALSE) {
[13:35:10.438]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:10.438]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:10.438]     }
[13:35:10.438]     ...future.result <- base::tryCatch({
[13:35:10.438]         base::withCallingHandlers({
[13:35:10.438]             ...future.value <- base::withVisible(base::local({
[13:35:10.438]                 ...future.makeSendCondition <- base::local({
[13:35:10.438]                   sendCondition <- NULL
[13:35:10.438]                   function(frame = 1L) {
[13:35:10.438]                     if (is.function(sendCondition)) 
[13:35:10.438]                       return(sendCondition)
[13:35:10.438]                     ns <- getNamespace("parallel")
[13:35:10.438]                     if (exists("sendData", mode = "function", 
[13:35:10.438]                       envir = ns)) {
[13:35:10.438]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:10.438]                         envir = ns)
[13:35:10.438]                       envir <- sys.frame(frame)
[13:35:10.438]                       master <- NULL
[13:35:10.438]                       while (!identical(envir, .GlobalEnv) && 
[13:35:10.438]                         !identical(envir, emptyenv())) {
[13:35:10.438]                         if (exists("master", mode = "list", envir = envir, 
[13:35:10.438]                           inherits = FALSE)) {
[13:35:10.438]                           master <- get("master", mode = "list", 
[13:35:10.438]                             envir = envir, inherits = FALSE)
[13:35:10.438]                           if (inherits(master, c("SOCKnode", 
[13:35:10.438]                             "SOCK0node"))) {
[13:35:10.438]                             sendCondition <<- function(cond) {
[13:35:10.438]                               data <- list(type = "VALUE", value = cond, 
[13:35:10.438]                                 success = TRUE)
[13:35:10.438]                               parallel_sendData(master, data)
[13:35:10.438]                             }
[13:35:10.438]                             return(sendCondition)
[13:35:10.438]                           }
[13:35:10.438]                         }
[13:35:10.438]                         frame <- frame + 1L
[13:35:10.438]                         envir <- sys.frame(frame)
[13:35:10.438]                       }
[13:35:10.438]                     }
[13:35:10.438]                     sendCondition <<- function(cond) NULL
[13:35:10.438]                   }
[13:35:10.438]                 })
[13:35:10.438]                 withCallingHandlers({
[13:35:10.438]                   {
[13:35:10.438]                     do.call(function(...) {
[13:35:10.438]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.438]                       if (!identical(...future.globals.maxSize.org, 
[13:35:10.438]                         ...future.globals.maxSize)) {
[13:35:10.438]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.438]                         on.exit(options(oopts), add = TRUE)
[13:35:10.438]                       }
[13:35:10.438]                       {
[13:35:10.438]                         lapply(seq_along(...future.elements_ii), 
[13:35:10.438]                           FUN = function(jj) {
[13:35:10.438]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.438]                             ...future.FUN(...future.X_jj, ...)
[13:35:10.438]                           })
[13:35:10.438]                       }
[13:35:10.438]                     }, args = future.call.arguments)
[13:35:10.438]                   }
[13:35:10.438]                 }, immediateCondition = function(cond) {
[13:35:10.438]                   sendCondition <- ...future.makeSendCondition()
[13:35:10.438]                   sendCondition(cond)
[13:35:10.438]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.438]                   {
[13:35:10.438]                     inherits <- base::inherits
[13:35:10.438]                     invokeRestart <- base::invokeRestart
[13:35:10.438]                     is.null <- base::is.null
[13:35:10.438]                     muffled <- FALSE
[13:35:10.438]                     if (inherits(cond, "message")) {
[13:35:10.438]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:10.438]                       if (muffled) 
[13:35:10.438]                         invokeRestart("muffleMessage")
[13:35:10.438]                     }
[13:35:10.438]                     else if (inherits(cond, "warning")) {
[13:35:10.438]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:10.438]                       if (muffled) 
[13:35:10.438]                         invokeRestart("muffleWarning")
[13:35:10.438]                     }
[13:35:10.438]                     else if (inherits(cond, "condition")) {
[13:35:10.438]                       if (!is.null(pattern)) {
[13:35:10.438]                         computeRestarts <- base::computeRestarts
[13:35:10.438]                         grepl <- base::grepl
[13:35:10.438]                         restarts <- computeRestarts(cond)
[13:35:10.438]                         for (restart in restarts) {
[13:35:10.438]                           name <- restart$name
[13:35:10.438]                           if (is.null(name)) 
[13:35:10.438]                             next
[13:35:10.438]                           if (!grepl(pattern, name)) 
[13:35:10.438]                             next
[13:35:10.438]                           invokeRestart(restart)
[13:35:10.438]                           muffled <- TRUE
[13:35:10.438]                           break
[13:35:10.438]                         }
[13:35:10.438]                       }
[13:35:10.438]                     }
[13:35:10.438]                     invisible(muffled)
[13:35:10.438]                   }
[13:35:10.438]                   muffleCondition(cond)
[13:35:10.438]                 })
[13:35:10.438]             }))
[13:35:10.438]             future::FutureResult(value = ...future.value$value, 
[13:35:10.438]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:10.438]                   ...future.rng), globalenv = if (FALSE) 
[13:35:10.438]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:10.438]                     ...future.globalenv.names))
[13:35:10.438]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:10.438]         }, condition = base::local({
[13:35:10.438]             c <- base::c
[13:35:10.438]             inherits <- base::inherits
[13:35:10.438]             invokeRestart <- base::invokeRestart
[13:35:10.438]             length <- base::length
[13:35:10.438]             list <- base::list
[13:35:10.438]             seq.int <- base::seq.int
[13:35:10.438]             signalCondition <- base::signalCondition
[13:35:10.438]             sys.calls <- base::sys.calls
[13:35:10.438]             `[[` <- base::`[[`
[13:35:10.438]             `+` <- base::`+`
[13:35:10.438]             `<<-` <- base::`<<-`
[13:35:10.438]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:10.438]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:10.438]                   3L)]
[13:35:10.438]             }
[13:35:10.438]             function(cond) {
[13:35:10.438]                 is_error <- inherits(cond, "error")
[13:35:10.438]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:10.438]                   NULL)
[13:35:10.438]                 if (is_error) {
[13:35:10.438]                   sessionInformation <- function() {
[13:35:10.438]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:10.438]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:10.438]                       search = base::search(), system = base::Sys.info())
[13:35:10.438]                   }
[13:35:10.438]                   ...future.conditions[[length(...future.conditions) + 
[13:35:10.438]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:10.438]                     cond$call), session = sessionInformation(), 
[13:35:10.438]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:10.438]                   signalCondition(cond)
[13:35:10.438]                 }
[13:35:10.438]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:10.438]                 "immediateCondition"))) {
[13:35:10.438]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:10.438]                   ...future.conditions[[length(...future.conditions) + 
[13:35:10.438]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:10.438]                   if (TRUE && !signal) {
[13:35:10.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.438]                     {
[13:35:10.438]                       inherits <- base::inherits
[13:35:10.438]                       invokeRestart <- base::invokeRestart
[13:35:10.438]                       is.null <- base::is.null
[13:35:10.438]                       muffled <- FALSE
[13:35:10.438]                       if (inherits(cond, "message")) {
[13:35:10.438]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:10.438]                         if (muffled) 
[13:35:10.438]                           invokeRestart("muffleMessage")
[13:35:10.438]                       }
[13:35:10.438]                       else if (inherits(cond, "warning")) {
[13:35:10.438]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:10.438]                         if (muffled) 
[13:35:10.438]                           invokeRestart("muffleWarning")
[13:35:10.438]                       }
[13:35:10.438]                       else if (inherits(cond, "condition")) {
[13:35:10.438]                         if (!is.null(pattern)) {
[13:35:10.438]                           computeRestarts <- base::computeRestarts
[13:35:10.438]                           grepl <- base::grepl
[13:35:10.438]                           restarts <- computeRestarts(cond)
[13:35:10.438]                           for (restart in restarts) {
[13:35:10.438]                             name <- restart$name
[13:35:10.438]                             if (is.null(name)) 
[13:35:10.438]                               next
[13:35:10.438]                             if (!grepl(pattern, name)) 
[13:35:10.438]                               next
[13:35:10.438]                             invokeRestart(restart)
[13:35:10.438]                             muffled <- TRUE
[13:35:10.438]                             break
[13:35:10.438]                           }
[13:35:10.438]                         }
[13:35:10.438]                       }
[13:35:10.438]                       invisible(muffled)
[13:35:10.438]                     }
[13:35:10.438]                     muffleCondition(cond, pattern = "^muffle")
[13:35:10.438]                   }
[13:35:10.438]                 }
[13:35:10.438]                 else {
[13:35:10.438]                   if (TRUE) {
[13:35:10.438]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.438]                     {
[13:35:10.438]                       inherits <- base::inherits
[13:35:10.438]                       invokeRestart <- base::invokeRestart
[13:35:10.438]                       is.null <- base::is.null
[13:35:10.438]                       muffled <- FALSE
[13:35:10.438]                       if (inherits(cond, "message")) {
[13:35:10.438]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:10.438]                         if (muffled) 
[13:35:10.438]                           invokeRestart("muffleMessage")
[13:35:10.438]                       }
[13:35:10.438]                       else if (inherits(cond, "warning")) {
[13:35:10.438]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:10.438]                         if (muffled) 
[13:35:10.438]                           invokeRestart("muffleWarning")
[13:35:10.438]                       }
[13:35:10.438]                       else if (inherits(cond, "condition")) {
[13:35:10.438]                         if (!is.null(pattern)) {
[13:35:10.438]                           computeRestarts <- base::computeRestarts
[13:35:10.438]                           grepl <- base::grepl
[13:35:10.438]                           restarts <- computeRestarts(cond)
[13:35:10.438]                           for (restart in restarts) {
[13:35:10.438]                             name <- restart$name
[13:35:10.438]                             if (is.null(name)) 
[13:35:10.438]                               next
[13:35:10.438]                             if (!grepl(pattern, name)) 
[13:35:10.438]                               next
[13:35:10.438]                             invokeRestart(restart)
[13:35:10.438]                             muffled <- TRUE
[13:35:10.438]                             break
[13:35:10.438]                           }
[13:35:10.438]                         }
[13:35:10.438]                       }
[13:35:10.438]                       invisible(muffled)
[13:35:10.438]                     }
[13:35:10.438]                     muffleCondition(cond, pattern = "^muffle")
[13:35:10.438]                   }
[13:35:10.438]                 }
[13:35:10.438]             }
[13:35:10.438]         }))
[13:35:10.438]     }, error = function(ex) {
[13:35:10.438]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:10.438]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:10.438]                 ...future.rng), started = ...future.startTime, 
[13:35:10.438]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:10.438]             version = "1.8"), class = "FutureResult")
[13:35:10.438]     }, finally = {
[13:35:10.438]         if (!identical(...future.workdir, getwd())) 
[13:35:10.438]             setwd(...future.workdir)
[13:35:10.438]         {
[13:35:10.438]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:10.438]                 ...future.oldOptions$nwarnings <- NULL
[13:35:10.438]             }
[13:35:10.438]             base::options(...future.oldOptions)
[13:35:10.438]             if (.Platform$OS.type == "windows") {
[13:35:10.438]                 old_names <- names(...future.oldEnvVars)
[13:35:10.438]                 envs <- base::Sys.getenv()
[13:35:10.438]                 names <- names(envs)
[13:35:10.438]                 common <- intersect(names, old_names)
[13:35:10.438]                 added <- setdiff(names, old_names)
[13:35:10.438]                 removed <- setdiff(old_names, names)
[13:35:10.438]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:10.438]                   envs[common]]
[13:35:10.438]                 NAMES <- toupper(changed)
[13:35:10.438]                 args <- list()
[13:35:10.438]                 for (kk in seq_along(NAMES)) {
[13:35:10.438]                   name <- changed[[kk]]
[13:35:10.438]                   NAME <- NAMES[[kk]]
[13:35:10.438]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.438]                     next
[13:35:10.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:10.438]                 }
[13:35:10.438]                 NAMES <- toupper(added)
[13:35:10.438]                 for (kk in seq_along(NAMES)) {
[13:35:10.438]                   name <- added[[kk]]
[13:35:10.438]                   NAME <- NAMES[[kk]]
[13:35:10.438]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.438]                     next
[13:35:10.438]                   args[[name]] <- ""
[13:35:10.438]                 }
[13:35:10.438]                 NAMES <- toupper(removed)
[13:35:10.438]                 for (kk in seq_along(NAMES)) {
[13:35:10.438]                   name <- removed[[kk]]
[13:35:10.438]                   NAME <- NAMES[[kk]]
[13:35:10.438]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.438]                     next
[13:35:10.438]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:10.438]                 }
[13:35:10.438]                 if (length(args) > 0) 
[13:35:10.438]                   base::do.call(base::Sys.setenv, args = args)
[13:35:10.438]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:10.438]             }
[13:35:10.438]             else {
[13:35:10.438]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:10.438]             }
[13:35:10.438]             {
[13:35:10.438]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:10.438]                   0L) {
[13:35:10.438]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:10.438]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:10.438]                   base::options(opts)
[13:35:10.438]                 }
[13:35:10.438]                 {
[13:35:10.438]                   {
[13:35:10.438]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:10.438]                     NULL
[13:35:10.438]                   }
[13:35:10.438]                   options(future.plan = NULL)
[13:35:10.438]                   if (is.na(NA_character_)) 
[13:35:10.438]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:10.438]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:10.438]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:10.438]                     .init = FALSE)
[13:35:10.438]                 }
[13:35:10.438]             }
[13:35:10.438]         }
[13:35:10.438]     })
[13:35:10.438]     if (TRUE) {
[13:35:10.438]         base::sink(type = "output", split = FALSE)
[13:35:10.438]         if (TRUE) {
[13:35:10.438]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:10.438]         }
[13:35:10.438]         else {
[13:35:10.438]             ...future.result["stdout"] <- base::list(NULL)
[13:35:10.438]         }
[13:35:10.438]         base::close(...future.stdout)
[13:35:10.438]         ...future.stdout <- NULL
[13:35:10.438]     }
[13:35:10.438]     ...future.result$conditions <- ...future.conditions
[13:35:10.438]     ...future.result$finished <- base::Sys.time()
[13:35:10.438]     ...future.result
[13:35:10.438] }
[13:35:10.441] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[13:35:10.441] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:10.482] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:10.483] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[13:35:10.483] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[13:35:10.483] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:10.483] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:10.484] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:10.526] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:10.527] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:10.570] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:10.571] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:10.571] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.571] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[13:35:10.572] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[13:35:10.572] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:10.572] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.572] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:35:10.573] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:35:10.573] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:10.573] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.573] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:10.574] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.574] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[13:35:10.574] MultisessionFuture started
[13:35:10.574] - Launch lazy future ... done
[13:35:10.575] run() for ‘MultisessionFuture’ ... done
[13:35:10.575] Created future:
[13:35:10.576] receiveMessageFromWorker() for ClusterFuture ...
[13:35:10.576] - Validating connection of MultisessionFuture
[13:35:10.576] - received message: FutureResult
[13:35:10.576] - Received FutureResult
[13:35:10.577] - Erased future from FutureRegistry
[13:35:10.577] result() for ClusterFuture ...
[13:35:10.577] - result already collected: FutureResult
[13:35:10.577] result() for ClusterFuture ... done
[13:35:10.577] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:10.575] MultisessionFuture:
[13:35:10.575] Label: ‘future_vapply-2’
[13:35:10.575] Expression:
[13:35:10.575] {
[13:35:10.575]     do.call(function(...) {
[13:35:10.575]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.575]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:10.575]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.575]             on.exit(options(oopts), add = TRUE)
[13:35:10.575]         }
[13:35:10.575]         {
[13:35:10.575]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:10.575]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.575]                 ...future.FUN(...future.X_jj, ...)
[13:35:10.575]             })
[13:35:10.575]         }
[13:35:10.575]     }, args = future.call.arguments)
[13:35:10.575] }
[13:35:10.575] Lazy evaluation: FALSE
[13:35:10.575] Asynchronous evaluation: TRUE
[13:35:10.575] Local evaluation: TRUE
[13:35:10.575] Environment: R_GlobalEnv
[13:35:10.575] Capture standard output: TRUE
[13:35:10.575] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:10.575] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:10.575] Packages: 1 packages (‘future.apply’)
[13:35:10.575] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:10.575] Resolved: TRUE
[13:35:10.575] Value: <not collected>
[13:35:10.575] Conditions captured: <none>
[13:35:10.575] Early signaling: FALSE
[13:35:10.575] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:10.575] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:10.577] Chunk #2 of 2 ... DONE
[13:35:10.577] Launching 2 futures (chunks) ... DONE
[13:35:10.577] Resolving 2 futures (chunks) ...
[13:35:10.578] resolve() on list ...
[13:35:10.578]  recursive: 0
[13:35:10.578]  length: 2
[13:35:10.578] 
[13:35:10.578] Future #1
[13:35:10.578] result() for ClusterFuture ...
[13:35:10.578] - result already collected: FutureResult
[13:35:10.578] result() for ClusterFuture ... done
[13:35:10.578] result() for ClusterFuture ...
[13:35:10.578] - result already collected: FutureResult
[13:35:10.578] result() for ClusterFuture ... done
[13:35:10.579] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:10.579] - nx: 2
[13:35:10.579] - relay: TRUE
[13:35:10.579] - stdout: TRUE
[13:35:10.579] - signal: TRUE
[13:35:10.579] - resignal: FALSE
[13:35:10.579] - force: TRUE
[13:35:10.579] - relayed: [n=2] FALSE, FALSE
[13:35:10.579] - queued futures: [n=2] FALSE, FALSE
[13:35:10.579]  - until=1
[13:35:10.579]  - relaying element #1
[13:35:10.580] result() for ClusterFuture ...
[13:35:10.580] - result already collected: FutureResult
[13:35:10.580] result() for ClusterFuture ... done
[13:35:10.580] result() for ClusterFuture ...
[13:35:10.580] - result already collected: FutureResult
[13:35:10.580] result() for ClusterFuture ... done
[13:35:10.580] result() for ClusterFuture ...
[13:35:10.580] - result already collected: FutureResult
[13:35:10.580] result() for ClusterFuture ... done
[13:35:10.580] result() for ClusterFuture ...
[13:35:10.580] - result already collected: FutureResult
[13:35:10.581] result() for ClusterFuture ... done
[13:35:10.581] - relayed: [n=2] TRUE, FALSE
[13:35:10.581] - queued futures: [n=2] TRUE, FALSE
[13:35:10.581] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:10.581]  length: 1 (resolved future 1)
[13:35:10.581] Future #2
[13:35:10.581] result() for ClusterFuture ...
[13:35:10.581] - result already collected: FutureResult
[13:35:10.581] result() for ClusterFuture ... done
[13:35:10.581] result() for ClusterFuture ...
[13:35:10.581] - result already collected: FutureResult
[13:35:10.582] result() for ClusterFuture ... done
[13:35:10.582] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:10.582] - nx: 2
[13:35:10.582] - relay: TRUE
[13:35:10.582] - stdout: TRUE
[13:35:10.582] - signal: TRUE
[13:35:10.582] - resignal: FALSE
[13:35:10.582] - force: TRUE
[13:35:10.582] - relayed: [n=2] TRUE, FALSE
[13:35:10.582] - queued futures: [n=2] TRUE, FALSE
[13:35:10.582]  - until=2
[13:35:10.583]  - relaying element #2
[13:35:10.583] result() for ClusterFuture ...
[13:35:10.583] - result already collected: FutureResult
[13:35:10.583] result() for ClusterFuture ... done
[13:35:10.583] result() for ClusterFuture ...
[13:35:10.583] - result already collected: FutureResult
[13:35:10.583] result() for ClusterFuture ... done
[13:35:10.583] result() for ClusterFuture ...
[13:35:10.583] - result already collected: FutureResult
[13:35:10.583] result() for ClusterFuture ... done
[13:35:10.583] result() for ClusterFuture ...
[13:35:10.584] - result already collected: FutureResult
[13:35:10.584] result() for ClusterFuture ... done
[13:35:10.584] - relayed: [n=2] TRUE, TRUE
[13:35:10.584] - queued futures: [n=2] TRUE, TRUE
[13:35:10.584] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:10.584]  length: 0 (resolved future 2)
[13:35:10.584] Relaying remaining futures
[13:35:10.584] signalConditionsASAP(NULL, pos=0) ...
[13:35:10.584] - nx: 2
[13:35:10.584] - relay: TRUE
[13:35:10.584] - stdout: TRUE
[13:35:10.584] - signal: TRUE
[13:35:10.585] - resignal: FALSE
[13:35:10.585] - force: TRUE
[13:35:10.585] - relayed: [n=2] TRUE, TRUE
[13:35:10.585] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:10.585] - relayed: [n=2] TRUE, TRUE
[13:35:10.585] - queued futures: [n=2] TRUE, TRUE
[13:35:10.585] signalConditionsASAP(NULL, pos=0) ... done
[13:35:10.585] resolve() on list ... DONE
[13:35:10.585] result() for ClusterFuture ...
[13:35:10.585] - result already collected: FutureResult
[13:35:10.585] result() for ClusterFuture ... done
[13:35:10.586] result() for ClusterFuture ...
[13:35:10.586] - result already collected: FutureResult
[13:35:10.586] result() for ClusterFuture ... done
[13:35:10.586] result() for ClusterFuture ...
[13:35:10.586] - result already collected: FutureResult
[13:35:10.586] result() for ClusterFuture ... done
[13:35:10.586] result() for ClusterFuture ...
[13:35:10.586] - result already collected: FutureResult
[13:35:10.586] result() for ClusterFuture ... done
[13:35:10.586]  - Number of value chunks collected: 2
[13:35:10.587] Resolving 2 futures (chunks) ... DONE
[13:35:10.587] Reducing values from 2 chunks ...
[13:35:10.587]  - Number of values collected after concatenation: 10
[13:35:10.587]  - Number of values expected: 10
[13:35:10.587] Reducing values from 2 chunks ... DONE
[13:35:10.587] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[13:35:10.588] future_lapply() ...
[13:35:10.593] Number of chunks: 2
[13:35:10.593] getGlobalsAndPackagesXApply() ...
[13:35:10.593]  - future.globals: TRUE
[13:35:10.593] getGlobalsAndPackages() ...
[13:35:10.594] Searching for globals...
[13:35:10.597] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:10.597] Searching for globals ... DONE
[13:35:10.597] Resolving globals: FALSE
[13:35:10.598] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[13:35:10.598] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:10.598] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:10.598] - packages: [1] ‘future.apply’
[13:35:10.598] getGlobalsAndPackages() ... DONE
[13:35:10.599]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:10.599]  - needed namespaces: [n=1] ‘future.apply’
[13:35:10.599] Finding globals ... DONE
[13:35:10.599]  - use_args: TRUE
[13:35:10.599]  - Getting '...' globals ...
[13:35:10.599] resolve() on list ...
[13:35:10.599]  recursive: 0
[13:35:10.599]  length: 1
[13:35:10.599]  elements: ‘...’
[13:35:10.600]  length: 0 (resolved future 1)
[13:35:10.600] resolve() on list ... DONE
[13:35:10.600]    - '...' content: [n=0] 
[13:35:10.600] List of 1
[13:35:10.600]  $ ...: list()
[13:35:10.600]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:10.600]  - attr(*, "where")=List of 1
[13:35:10.600]   ..$ ...:<environment: 0x5574d2f7a590> 
[13:35:10.600]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:10.600]  - attr(*, "resolved")= logi TRUE
[13:35:10.600]  - attr(*, "total_size")= num NA
[13:35:10.602]  - Getting '...' globals ... DONE
[13:35:10.603] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:10.603] List of 8
[13:35:10.603]  $ ...future.FUN:function (x, ...)  
[13:35:10.603]  $ x_FUN        :function (x)  
[13:35:10.603]  $ times        : int 1
[13:35:10.603]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:10.603]  $ stop_if_not  :function (...)  
[13:35:10.603]  $ dim          : NULL
[13:35:10.603]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:10.603]  $ ...          : list()
[13:35:10.603]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:10.603]  - attr(*, "where")=List of 8
[13:35:10.603]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:10.603]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:10.603]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:10.603]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:10.603]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:10.603]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:10.603]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:10.603]   ..$ ...          :<environment: 0x5574d2f7a590> 
[13:35:10.603]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:10.603]  - attr(*, "resolved")= logi FALSE
[13:35:10.603]  - attr(*, "total_size")= num 94336
[13:35:10.608] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:10.608] getGlobalsAndPackagesXApply() ... DONE
[13:35:10.608] Number of futures (= number of chunks): 2
[13:35:10.608] Launching 2 futures (chunks) ...
[13:35:10.608] Chunk #1 of 2 ...
[13:35:10.609]  - Finding globals in 'X' for chunk #1 ...
[13:35:10.609] getGlobalsAndPackages() ...
[13:35:10.611] Searching for globals...
[13:35:10.611] 
[13:35:10.611] Searching for globals ... DONE
[13:35:10.612] - globals: [0] <none>
[13:35:10.612] getGlobalsAndPackages() ... DONE
[13:35:10.612]    + additional globals found: [n=0] 
[13:35:10.612]    + additional namespaces needed: [n=0] 
[13:35:10.612]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:10.612]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:10.612]  - seeds: <none>
[13:35:10.612]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.612] getGlobalsAndPackages() ...
[13:35:10.612] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.613] Resolving globals: FALSE
[13:35:10.613] Tweak future expression to call with '...' arguments ...
[13:35:10.613] {
[13:35:10.613]     do.call(function(...) {
[13:35:10.613]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.613]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:10.613]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.613]             on.exit(options(oopts), add = TRUE)
[13:35:10.613]         }
[13:35:10.613]         {
[13:35:10.613]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:10.613]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.613]                 ...future.FUN(...future.X_jj, ...)
[13:35:10.613]             })
[13:35:10.613]         }
[13:35:10.613]     }, args = future.call.arguments)
[13:35:10.613] }
[13:35:10.613] Tweak future expression to call with '...' arguments ... DONE
[13:35:10.613] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.614] - packages: [1] ‘future.apply’
[13:35:10.614] getGlobalsAndPackages() ... DONE
[13:35:10.614] run() for ‘Future’ ...
[13:35:10.614] - state: ‘created’
[13:35:10.614] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:10.628] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:10.628] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:10.628]   - Field: ‘node’
[13:35:10.628]   - Field: ‘label’
[13:35:10.628]   - Field: ‘local’
[13:35:10.628]   - Field: ‘owner’
[13:35:10.628]   - Field: ‘envir’
[13:35:10.628]   - Field: ‘workers’
[13:35:10.629]   - Field: ‘packages’
[13:35:10.629]   - Field: ‘gc’
[13:35:10.629]   - Field: ‘conditions’
[13:35:10.629]   - Field: ‘persistent’
[13:35:10.629]   - Field: ‘expr’
[13:35:10.629]   - Field: ‘uuid’
[13:35:10.629]   - Field: ‘seed’
[13:35:10.629]   - Field: ‘version’
[13:35:10.629]   - Field: ‘result’
[13:35:10.629]   - Field: ‘asynchronous’
[13:35:10.629]   - Field: ‘calls’
[13:35:10.630]   - Field: ‘globals’
[13:35:10.630]   - Field: ‘stdout’
[13:35:10.630]   - Field: ‘earlySignal’
[13:35:10.630]   - Field: ‘lazy’
[13:35:10.630]   - Field: ‘state’
[13:35:10.630] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:10.630] - Launch lazy future ...
[13:35:10.630] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:10.631] Packages needed by future strategies (n = 0): <none>
[13:35:10.631] {
[13:35:10.631]     {
[13:35:10.631]         {
[13:35:10.631]             ...future.startTime <- base::Sys.time()
[13:35:10.631]             {
[13:35:10.631]                 {
[13:35:10.631]                   {
[13:35:10.631]                     {
[13:35:10.631]                       {
[13:35:10.631]                         base::local({
[13:35:10.631]                           has_future <- base::requireNamespace("future", 
[13:35:10.631]                             quietly = TRUE)
[13:35:10.631]                           if (has_future) {
[13:35:10.631]                             ns <- base::getNamespace("future")
[13:35:10.631]                             version <- ns[[".package"]][["version"]]
[13:35:10.631]                             if (is.null(version)) 
[13:35:10.631]                               version <- utils::packageVersion("future")
[13:35:10.631]                           }
[13:35:10.631]                           else {
[13:35:10.631]                             version <- NULL
[13:35:10.631]                           }
[13:35:10.631]                           if (!has_future || version < "1.8.0") {
[13:35:10.631]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:10.631]                               "", base::R.version$version.string), 
[13:35:10.631]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:10.631]                                 base::R.version$platform, 8 * 
[13:35:10.631]                                   base::.Machine$sizeof.pointer), 
[13:35:10.631]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:10.631]                                 "release", "version")], collapse = " "), 
[13:35:10.631]                               hostname = base::Sys.info()[["nodename"]])
[13:35:10.631]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:10.631]                               info)
[13:35:10.631]                             info <- base::paste(info, collapse = "; ")
[13:35:10.631]                             if (!has_future) {
[13:35:10.631]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:10.631]                                 info)
[13:35:10.631]                             }
[13:35:10.631]                             else {
[13:35:10.631]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:10.631]                                 info, version)
[13:35:10.631]                             }
[13:35:10.631]                             base::stop(msg)
[13:35:10.631]                           }
[13:35:10.631]                         })
[13:35:10.631]                       }
[13:35:10.631]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:10.631]                       base::options(mc.cores = 1L)
[13:35:10.631]                     }
[13:35:10.631]                     base::local({
[13:35:10.631]                       for (pkg in "future.apply") {
[13:35:10.631]                         base::loadNamespace(pkg)
[13:35:10.631]                         base::library(pkg, character.only = TRUE)
[13:35:10.631]                       }
[13:35:10.631]                     })
[13:35:10.631]                   }
[13:35:10.631]                   ...future.strategy.old <- future::plan("list")
[13:35:10.631]                   options(future.plan = NULL)
[13:35:10.631]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:10.631]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:10.631]                 }
[13:35:10.631]                 ...future.workdir <- getwd()
[13:35:10.631]             }
[13:35:10.631]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:10.631]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:10.631]         }
[13:35:10.631]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:10.631]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:10.631]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:10.631]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:10.631]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:10.631]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:10.631]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:10.631]             base::names(...future.oldOptions))
[13:35:10.631]     }
[13:35:10.631]     if (FALSE) {
[13:35:10.631]     }
[13:35:10.631]     else {
[13:35:10.631]         if (TRUE) {
[13:35:10.631]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:10.631]                 open = "w")
[13:35:10.631]         }
[13:35:10.631]         else {
[13:35:10.631]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:10.631]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:10.631]         }
[13:35:10.631]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:10.631]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:10.631]             base::sink(type = "output", split = FALSE)
[13:35:10.631]             base::close(...future.stdout)
[13:35:10.631]         }, add = TRUE)
[13:35:10.631]     }
[13:35:10.631]     ...future.frame <- base::sys.nframe()
[13:35:10.631]     ...future.conditions <- base::list()
[13:35:10.631]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:10.631]     if (FALSE) {
[13:35:10.631]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:10.631]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:10.631]     }
[13:35:10.631]     ...future.result <- base::tryCatch({
[13:35:10.631]         base::withCallingHandlers({
[13:35:10.631]             ...future.value <- base::withVisible(base::local({
[13:35:10.631]                 ...future.makeSendCondition <- base::local({
[13:35:10.631]                   sendCondition <- NULL
[13:35:10.631]                   function(frame = 1L) {
[13:35:10.631]                     if (is.function(sendCondition)) 
[13:35:10.631]                       return(sendCondition)
[13:35:10.631]                     ns <- getNamespace("parallel")
[13:35:10.631]                     if (exists("sendData", mode = "function", 
[13:35:10.631]                       envir = ns)) {
[13:35:10.631]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:10.631]                         envir = ns)
[13:35:10.631]                       envir <- sys.frame(frame)
[13:35:10.631]                       master <- NULL
[13:35:10.631]                       while (!identical(envir, .GlobalEnv) && 
[13:35:10.631]                         !identical(envir, emptyenv())) {
[13:35:10.631]                         if (exists("master", mode = "list", envir = envir, 
[13:35:10.631]                           inherits = FALSE)) {
[13:35:10.631]                           master <- get("master", mode = "list", 
[13:35:10.631]                             envir = envir, inherits = FALSE)
[13:35:10.631]                           if (inherits(master, c("SOCKnode", 
[13:35:10.631]                             "SOCK0node"))) {
[13:35:10.631]                             sendCondition <<- function(cond) {
[13:35:10.631]                               data <- list(type = "VALUE", value = cond, 
[13:35:10.631]                                 success = TRUE)
[13:35:10.631]                               parallel_sendData(master, data)
[13:35:10.631]                             }
[13:35:10.631]                             return(sendCondition)
[13:35:10.631]                           }
[13:35:10.631]                         }
[13:35:10.631]                         frame <- frame + 1L
[13:35:10.631]                         envir <- sys.frame(frame)
[13:35:10.631]                       }
[13:35:10.631]                     }
[13:35:10.631]                     sendCondition <<- function(cond) NULL
[13:35:10.631]                   }
[13:35:10.631]                 })
[13:35:10.631]                 withCallingHandlers({
[13:35:10.631]                   {
[13:35:10.631]                     do.call(function(...) {
[13:35:10.631]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.631]                       if (!identical(...future.globals.maxSize.org, 
[13:35:10.631]                         ...future.globals.maxSize)) {
[13:35:10.631]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.631]                         on.exit(options(oopts), add = TRUE)
[13:35:10.631]                       }
[13:35:10.631]                       {
[13:35:10.631]                         lapply(seq_along(...future.elements_ii), 
[13:35:10.631]                           FUN = function(jj) {
[13:35:10.631]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.631]                             ...future.FUN(...future.X_jj, ...)
[13:35:10.631]                           })
[13:35:10.631]                       }
[13:35:10.631]                     }, args = future.call.arguments)
[13:35:10.631]                   }
[13:35:10.631]                 }, immediateCondition = function(cond) {
[13:35:10.631]                   sendCondition <- ...future.makeSendCondition()
[13:35:10.631]                   sendCondition(cond)
[13:35:10.631]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.631]                   {
[13:35:10.631]                     inherits <- base::inherits
[13:35:10.631]                     invokeRestart <- base::invokeRestart
[13:35:10.631]                     is.null <- base::is.null
[13:35:10.631]                     muffled <- FALSE
[13:35:10.631]                     if (inherits(cond, "message")) {
[13:35:10.631]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:10.631]                       if (muffled) 
[13:35:10.631]                         invokeRestart("muffleMessage")
[13:35:10.631]                     }
[13:35:10.631]                     else if (inherits(cond, "warning")) {
[13:35:10.631]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:10.631]                       if (muffled) 
[13:35:10.631]                         invokeRestart("muffleWarning")
[13:35:10.631]                     }
[13:35:10.631]                     else if (inherits(cond, "condition")) {
[13:35:10.631]                       if (!is.null(pattern)) {
[13:35:10.631]                         computeRestarts <- base::computeRestarts
[13:35:10.631]                         grepl <- base::grepl
[13:35:10.631]                         restarts <- computeRestarts(cond)
[13:35:10.631]                         for (restart in restarts) {
[13:35:10.631]                           name <- restart$name
[13:35:10.631]                           if (is.null(name)) 
[13:35:10.631]                             next
[13:35:10.631]                           if (!grepl(pattern, name)) 
[13:35:10.631]                             next
[13:35:10.631]                           invokeRestart(restart)
[13:35:10.631]                           muffled <- TRUE
[13:35:10.631]                           break
[13:35:10.631]                         }
[13:35:10.631]                       }
[13:35:10.631]                     }
[13:35:10.631]                     invisible(muffled)
[13:35:10.631]                   }
[13:35:10.631]                   muffleCondition(cond)
[13:35:10.631]                 })
[13:35:10.631]             }))
[13:35:10.631]             future::FutureResult(value = ...future.value$value, 
[13:35:10.631]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:10.631]                   ...future.rng), globalenv = if (FALSE) 
[13:35:10.631]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:10.631]                     ...future.globalenv.names))
[13:35:10.631]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:10.631]         }, condition = base::local({
[13:35:10.631]             c <- base::c
[13:35:10.631]             inherits <- base::inherits
[13:35:10.631]             invokeRestart <- base::invokeRestart
[13:35:10.631]             length <- base::length
[13:35:10.631]             list <- base::list
[13:35:10.631]             seq.int <- base::seq.int
[13:35:10.631]             signalCondition <- base::signalCondition
[13:35:10.631]             sys.calls <- base::sys.calls
[13:35:10.631]             `[[` <- base::`[[`
[13:35:10.631]             `+` <- base::`+`
[13:35:10.631]             `<<-` <- base::`<<-`
[13:35:10.631]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:10.631]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:10.631]                   3L)]
[13:35:10.631]             }
[13:35:10.631]             function(cond) {
[13:35:10.631]                 is_error <- inherits(cond, "error")
[13:35:10.631]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:10.631]                   NULL)
[13:35:10.631]                 if (is_error) {
[13:35:10.631]                   sessionInformation <- function() {
[13:35:10.631]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:10.631]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:10.631]                       search = base::search(), system = base::Sys.info())
[13:35:10.631]                   }
[13:35:10.631]                   ...future.conditions[[length(...future.conditions) + 
[13:35:10.631]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:10.631]                     cond$call), session = sessionInformation(), 
[13:35:10.631]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:10.631]                   signalCondition(cond)
[13:35:10.631]                 }
[13:35:10.631]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:10.631]                 "immediateCondition"))) {
[13:35:10.631]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:10.631]                   ...future.conditions[[length(...future.conditions) + 
[13:35:10.631]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:10.631]                   if (TRUE && !signal) {
[13:35:10.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.631]                     {
[13:35:10.631]                       inherits <- base::inherits
[13:35:10.631]                       invokeRestart <- base::invokeRestart
[13:35:10.631]                       is.null <- base::is.null
[13:35:10.631]                       muffled <- FALSE
[13:35:10.631]                       if (inherits(cond, "message")) {
[13:35:10.631]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:10.631]                         if (muffled) 
[13:35:10.631]                           invokeRestart("muffleMessage")
[13:35:10.631]                       }
[13:35:10.631]                       else if (inherits(cond, "warning")) {
[13:35:10.631]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:10.631]                         if (muffled) 
[13:35:10.631]                           invokeRestart("muffleWarning")
[13:35:10.631]                       }
[13:35:10.631]                       else if (inherits(cond, "condition")) {
[13:35:10.631]                         if (!is.null(pattern)) {
[13:35:10.631]                           computeRestarts <- base::computeRestarts
[13:35:10.631]                           grepl <- base::grepl
[13:35:10.631]                           restarts <- computeRestarts(cond)
[13:35:10.631]                           for (restart in restarts) {
[13:35:10.631]                             name <- restart$name
[13:35:10.631]                             if (is.null(name)) 
[13:35:10.631]                               next
[13:35:10.631]                             if (!grepl(pattern, name)) 
[13:35:10.631]                               next
[13:35:10.631]                             invokeRestart(restart)
[13:35:10.631]                             muffled <- TRUE
[13:35:10.631]                             break
[13:35:10.631]                           }
[13:35:10.631]                         }
[13:35:10.631]                       }
[13:35:10.631]                       invisible(muffled)
[13:35:10.631]                     }
[13:35:10.631]                     muffleCondition(cond, pattern = "^muffle")
[13:35:10.631]                   }
[13:35:10.631]                 }
[13:35:10.631]                 else {
[13:35:10.631]                   if (TRUE) {
[13:35:10.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.631]                     {
[13:35:10.631]                       inherits <- base::inherits
[13:35:10.631]                       invokeRestart <- base::invokeRestart
[13:35:10.631]                       is.null <- base::is.null
[13:35:10.631]                       muffled <- FALSE
[13:35:10.631]                       if (inherits(cond, "message")) {
[13:35:10.631]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:10.631]                         if (muffled) 
[13:35:10.631]                           invokeRestart("muffleMessage")
[13:35:10.631]                       }
[13:35:10.631]                       else if (inherits(cond, "warning")) {
[13:35:10.631]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:10.631]                         if (muffled) 
[13:35:10.631]                           invokeRestart("muffleWarning")
[13:35:10.631]                       }
[13:35:10.631]                       else if (inherits(cond, "condition")) {
[13:35:10.631]                         if (!is.null(pattern)) {
[13:35:10.631]                           computeRestarts <- base::computeRestarts
[13:35:10.631]                           grepl <- base::grepl
[13:35:10.631]                           restarts <- computeRestarts(cond)
[13:35:10.631]                           for (restart in restarts) {
[13:35:10.631]                             name <- restart$name
[13:35:10.631]                             if (is.null(name)) 
[13:35:10.631]                               next
[13:35:10.631]                             if (!grepl(pattern, name)) 
[13:35:10.631]                               next
[13:35:10.631]                             invokeRestart(restart)
[13:35:10.631]                             muffled <- TRUE
[13:35:10.631]                             break
[13:35:10.631]                           }
[13:35:10.631]                         }
[13:35:10.631]                       }
[13:35:10.631]                       invisible(muffled)
[13:35:10.631]                     }
[13:35:10.631]                     muffleCondition(cond, pattern = "^muffle")
[13:35:10.631]                   }
[13:35:10.631]                 }
[13:35:10.631]             }
[13:35:10.631]         }))
[13:35:10.631]     }, error = function(ex) {
[13:35:10.631]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:10.631]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:10.631]                 ...future.rng), started = ...future.startTime, 
[13:35:10.631]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:10.631]             version = "1.8"), class = "FutureResult")
[13:35:10.631]     }, finally = {
[13:35:10.631]         if (!identical(...future.workdir, getwd())) 
[13:35:10.631]             setwd(...future.workdir)
[13:35:10.631]         {
[13:35:10.631]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:10.631]                 ...future.oldOptions$nwarnings <- NULL
[13:35:10.631]             }
[13:35:10.631]             base::options(...future.oldOptions)
[13:35:10.631]             if (.Platform$OS.type == "windows") {
[13:35:10.631]                 old_names <- names(...future.oldEnvVars)
[13:35:10.631]                 envs <- base::Sys.getenv()
[13:35:10.631]                 names <- names(envs)
[13:35:10.631]                 common <- intersect(names, old_names)
[13:35:10.631]                 added <- setdiff(names, old_names)
[13:35:10.631]                 removed <- setdiff(old_names, names)
[13:35:10.631]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:10.631]                   envs[common]]
[13:35:10.631]                 NAMES <- toupper(changed)
[13:35:10.631]                 args <- list()
[13:35:10.631]                 for (kk in seq_along(NAMES)) {
[13:35:10.631]                   name <- changed[[kk]]
[13:35:10.631]                   NAME <- NAMES[[kk]]
[13:35:10.631]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.631]                     next
[13:35:10.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:10.631]                 }
[13:35:10.631]                 NAMES <- toupper(added)
[13:35:10.631]                 for (kk in seq_along(NAMES)) {
[13:35:10.631]                   name <- added[[kk]]
[13:35:10.631]                   NAME <- NAMES[[kk]]
[13:35:10.631]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.631]                     next
[13:35:10.631]                   args[[name]] <- ""
[13:35:10.631]                 }
[13:35:10.631]                 NAMES <- toupper(removed)
[13:35:10.631]                 for (kk in seq_along(NAMES)) {
[13:35:10.631]                   name <- removed[[kk]]
[13:35:10.631]                   NAME <- NAMES[[kk]]
[13:35:10.631]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.631]                     next
[13:35:10.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:10.631]                 }
[13:35:10.631]                 if (length(args) > 0) 
[13:35:10.631]                   base::do.call(base::Sys.setenv, args = args)
[13:35:10.631]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:10.631]             }
[13:35:10.631]             else {
[13:35:10.631]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:10.631]             }
[13:35:10.631]             {
[13:35:10.631]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:10.631]                   0L) {
[13:35:10.631]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:10.631]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:10.631]                   base::options(opts)
[13:35:10.631]                 }
[13:35:10.631]                 {
[13:35:10.631]                   {
[13:35:10.631]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:10.631]                     NULL
[13:35:10.631]                   }
[13:35:10.631]                   options(future.plan = NULL)
[13:35:10.631]                   if (is.na(NA_character_)) 
[13:35:10.631]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:10.631]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:10.631]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:10.631]                     .init = FALSE)
[13:35:10.631]                 }
[13:35:10.631]             }
[13:35:10.631]         }
[13:35:10.631]     })
[13:35:10.631]     if (TRUE) {
[13:35:10.631]         base::sink(type = "output", split = FALSE)
[13:35:10.631]         if (TRUE) {
[13:35:10.631]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:10.631]         }
[13:35:10.631]         else {
[13:35:10.631]             ...future.result["stdout"] <- base::list(NULL)
[13:35:10.631]         }
[13:35:10.631]         base::close(...future.stdout)
[13:35:10.631]         ...future.stdout <- NULL
[13:35:10.631]     }
[13:35:10.631]     ...future.result$conditions <- ...future.conditions
[13:35:10.631]     ...future.result$finished <- base::Sys.time()
[13:35:10.631]     ...future.result
[13:35:10.631] }
[13:35:10.634] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[13:35:10.634] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:10.674] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:10.675] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:35:10.675] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:35:10.675] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:10.676] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:10.676] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:10.718] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:10.719] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:10.762] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:10.763] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:10.763] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.763] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:10.764] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:10.764] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:10.764] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.764] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:35:10.765] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:35:10.765] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:10.765] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.765] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:10.766] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.766] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[13:35:10.766] MultisessionFuture started
[13:35:10.767] - Launch lazy future ... done
[13:35:10.767] run() for ‘MultisessionFuture’ ... done
[13:35:10.767] Created future:
[13:35:10.768] receiveMessageFromWorker() for ClusterFuture ...
[13:35:10.768] - Validating connection of MultisessionFuture
[13:35:10.769] - received message: FutureResult
[13:35:10.769] - Received FutureResult
[13:35:10.769] - Erased future from FutureRegistry
[13:35:10.769] result() for ClusterFuture ...
[13:35:10.769] - result already collected: FutureResult
[13:35:10.769] result() for ClusterFuture ... done
[13:35:10.769] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:10.767] MultisessionFuture:
[13:35:10.767] Label: ‘future_vapply-1’
[13:35:10.767] Expression:
[13:35:10.767] {
[13:35:10.767]     do.call(function(...) {
[13:35:10.767]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.767]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:10.767]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.767]             on.exit(options(oopts), add = TRUE)
[13:35:10.767]         }
[13:35:10.767]         {
[13:35:10.767]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:10.767]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.767]                 ...future.FUN(...future.X_jj, ...)
[13:35:10.767]             })
[13:35:10.767]         }
[13:35:10.767]     }, args = future.call.arguments)
[13:35:10.767] }
[13:35:10.767] Lazy evaluation: FALSE
[13:35:10.767] Asynchronous evaluation: TRUE
[13:35:10.767] Local evaluation: TRUE
[13:35:10.767] Environment: R_GlobalEnv
[13:35:10.767] Capture standard output: TRUE
[13:35:10.767] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:10.767] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:10.767] Packages: 1 packages (‘future.apply’)
[13:35:10.767] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:10.767] Resolved: TRUE
[13:35:10.767] Value: <not collected>
[13:35:10.767] Conditions captured: <none>
[13:35:10.767] Early signaling: FALSE
[13:35:10.767] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:10.767] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:10.770] Chunk #1 of 2 ... DONE
[13:35:10.770] Chunk #2 of 2 ...
[13:35:10.770]  - Finding globals in 'X' for chunk #2 ...
[13:35:10.770] getGlobalsAndPackages() ...
[13:35:10.770] Searching for globals...
[13:35:10.770] 
[13:35:10.770] Searching for globals ... DONE
[13:35:10.770] - globals: [0] <none>
[13:35:10.771] getGlobalsAndPackages() ... DONE
[13:35:10.771]    + additional globals found: [n=0] 
[13:35:10.771]    + additional namespaces needed: [n=0] 
[13:35:10.771]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:10.771]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:10.771]  - seeds: <none>
[13:35:10.771]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.771] getGlobalsAndPackages() ...
[13:35:10.771] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.771] Resolving globals: FALSE
[13:35:10.772] Tweak future expression to call with '...' arguments ...
[13:35:10.772] {
[13:35:10.772]     do.call(function(...) {
[13:35:10.772]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.772]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:10.772]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.772]             on.exit(options(oopts), add = TRUE)
[13:35:10.772]         }
[13:35:10.772]         {
[13:35:10.772]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:10.772]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.772]                 ...future.FUN(...future.X_jj, ...)
[13:35:10.772]             })
[13:35:10.772]         }
[13:35:10.772]     }, args = future.call.arguments)
[13:35:10.772] }
[13:35:10.772] Tweak future expression to call with '...' arguments ... DONE
[13:35:10.772] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.773] - packages: [1] ‘future.apply’
[13:35:10.773] getGlobalsAndPackages() ... DONE
[13:35:10.773] run() for ‘Future’ ...
[13:35:10.773] - state: ‘created’
[13:35:10.773] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:10.787] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:10.787] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:10.787]   - Field: ‘node’
[13:35:10.787]   - Field: ‘label’
[13:35:10.787]   - Field: ‘local’
[13:35:10.788]   - Field: ‘owner’
[13:35:10.788]   - Field: ‘envir’
[13:35:10.788]   - Field: ‘workers’
[13:35:10.788]   - Field: ‘packages’
[13:35:10.788]   - Field: ‘gc’
[13:35:10.788]   - Field: ‘conditions’
[13:35:10.788]   - Field: ‘persistent’
[13:35:10.788]   - Field: ‘expr’
[13:35:10.788]   - Field: ‘uuid’
[13:35:10.788]   - Field: ‘seed’
[13:35:10.788]   - Field: ‘version’
[13:35:10.789]   - Field: ‘result’
[13:35:10.789]   - Field: ‘asynchronous’
[13:35:10.789]   - Field: ‘calls’
[13:35:10.789]   - Field: ‘globals’
[13:35:10.789]   - Field: ‘stdout’
[13:35:10.789]   - Field: ‘earlySignal’
[13:35:10.789]   - Field: ‘lazy’
[13:35:10.789]   - Field: ‘state’
[13:35:10.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:10.789] - Launch lazy future ...
[13:35:10.790] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:10.790] Packages needed by future strategies (n = 0): <none>
[13:35:10.790] {
[13:35:10.790]     {
[13:35:10.790]         {
[13:35:10.790]             ...future.startTime <- base::Sys.time()
[13:35:10.790]             {
[13:35:10.790]                 {
[13:35:10.790]                   {
[13:35:10.790]                     {
[13:35:10.790]                       {
[13:35:10.790]                         base::local({
[13:35:10.790]                           has_future <- base::requireNamespace("future", 
[13:35:10.790]                             quietly = TRUE)
[13:35:10.790]                           if (has_future) {
[13:35:10.790]                             ns <- base::getNamespace("future")
[13:35:10.790]                             version <- ns[[".package"]][["version"]]
[13:35:10.790]                             if (is.null(version)) 
[13:35:10.790]                               version <- utils::packageVersion("future")
[13:35:10.790]                           }
[13:35:10.790]                           else {
[13:35:10.790]                             version <- NULL
[13:35:10.790]                           }
[13:35:10.790]                           if (!has_future || version < "1.8.0") {
[13:35:10.790]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:10.790]                               "", base::R.version$version.string), 
[13:35:10.790]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:10.790]                                 base::R.version$platform, 8 * 
[13:35:10.790]                                   base::.Machine$sizeof.pointer), 
[13:35:10.790]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:10.790]                                 "release", "version")], collapse = " "), 
[13:35:10.790]                               hostname = base::Sys.info()[["nodename"]])
[13:35:10.790]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:10.790]                               info)
[13:35:10.790]                             info <- base::paste(info, collapse = "; ")
[13:35:10.790]                             if (!has_future) {
[13:35:10.790]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:10.790]                                 info)
[13:35:10.790]                             }
[13:35:10.790]                             else {
[13:35:10.790]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:10.790]                                 info, version)
[13:35:10.790]                             }
[13:35:10.790]                             base::stop(msg)
[13:35:10.790]                           }
[13:35:10.790]                         })
[13:35:10.790]                       }
[13:35:10.790]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:10.790]                       base::options(mc.cores = 1L)
[13:35:10.790]                     }
[13:35:10.790]                     base::local({
[13:35:10.790]                       for (pkg in "future.apply") {
[13:35:10.790]                         base::loadNamespace(pkg)
[13:35:10.790]                         base::library(pkg, character.only = TRUE)
[13:35:10.790]                       }
[13:35:10.790]                     })
[13:35:10.790]                   }
[13:35:10.790]                   ...future.strategy.old <- future::plan("list")
[13:35:10.790]                   options(future.plan = NULL)
[13:35:10.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:10.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:10.790]                 }
[13:35:10.790]                 ...future.workdir <- getwd()
[13:35:10.790]             }
[13:35:10.790]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:10.790]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:10.790]         }
[13:35:10.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:10.790]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:10.790]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:10.790]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:10.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:10.790]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:10.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:10.790]             base::names(...future.oldOptions))
[13:35:10.790]     }
[13:35:10.790]     if (FALSE) {
[13:35:10.790]     }
[13:35:10.790]     else {
[13:35:10.790]         if (TRUE) {
[13:35:10.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:10.790]                 open = "w")
[13:35:10.790]         }
[13:35:10.790]         else {
[13:35:10.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:10.790]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:10.790]         }
[13:35:10.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:10.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:10.790]             base::sink(type = "output", split = FALSE)
[13:35:10.790]             base::close(...future.stdout)
[13:35:10.790]         }, add = TRUE)
[13:35:10.790]     }
[13:35:10.790]     ...future.frame <- base::sys.nframe()
[13:35:10.790]     ...future.conditions <- base::list()
[13:35:10.790]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:10.790]     if (FALSE) {
[13:35:10.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:10.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:10.790]     }
[13:35:10.790]     ...future.result <- base::tryCatch({
[13:35:10.790]         base::withCallingHandlers({
[13:35:10.790]             ...future.value <- base::withVisible(base::local({
[13:35:10.790]                 ...future.makeSendCondition <- base::local({
[13:35:10.790]                   sendCondition <- NULL
[13:35:10.790]                   function(frame = 1L) {
[13:35:10.790]                     if (is.function(sendCondition)) 
[13:35:10.790]                       return(sendCondition)
[13:35:10.790]                     ns <- getNamespace("parallel")
[13:35:10.790]                     if (exists("sendData", mode = "function", 
[13:35:10.790]                       envir = ns)) {
[13:35:10.790]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:10.790]                         envir = ns)
[13:35:10.790]                       envir <- sys.frame(frame)
[13:35:10.790]                       master <- NULL
[13:35:10.790]                       while (!identical(envir, .GlobalEnv) && 
[13:35:10.790]                         !identical(envir, emptyenv())) {
[13:35:10.790]                         if (exists("master", mode = "list", envir = envir, 
[13:35:10.790]                           inherits = FALSE)) {
[13:35:10.790]                           master <- get("master", mode = "list", 
[13:35:10.790]                             envir = envir, inherits = FALSE)
[13:35:10.790]                           if (inherits(master, c("SOCKnode", 
[13:35:10.790]                             "SOCK0node"))) {
[13:35:10.790]                             sendCondition <<- function(cond) {
[13:35:10.790]                               data <- list(type = "VALUE", value = cond, 
[13:35:10.790]                                 success = TRUE)
[13:35:10.790]                               parallel_sendData(master, data)
[13:35:10.790]                             }
[13:35:10.790]                             return(sendCondition)
[13:35:10.790]                           }
[13:35:10.790]                         }
[13:35:10.790]                         frame <- frame + 1L
[13:35:10.790]                         envir <- sys.frame(frame)
[13:35:10.790]                       }
[13:35:10.790]                     }
[13:35:10.790]                     sendCondition <<- function(cond) NULL
[13:35:10.790]                   }
[13:35:10.790]                 })
[13:35:10.790]                 withCallingHandlers({
[13:35:10.790]                   {
[13:35:10.790]                     do.call(function(...) {
[13:35:10.790]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.790]                       if (!identical(...future.globals.maxSize.org, 
[13:35:10.790]                         ...future.globals.maxSize)) {
[13:35:10.790]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.790]                         on.exit(options(oopts), add = TRUE)
[13:35:10.790]                       }
[13:35:10.790]                       {
[13:35:10.790]                         lapply(seq_along(...future.elements_ii), 
[13:35:10.790]                           FUN = function(jj) {
[13:35:10.790]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.790]                             ...future.FUN(...future.X_jj, ...)
[13:35:10.790]                           })
[13:35:10.790]                       }
[13:35:10.790]                     }, args = future.call.arguments)
[13:35:10.790]                   }
[13:35:10.790]                 }, immediateCondition = function(cond) {
[13:35:10.790]                   sendCondition <- ...future.makeSendCondition()
[13:35:10.790]                   sendCondition(cond)
[13:35:10.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.790]                   {
[13:35:10.790]                     inherits <- base::inherits
[13:35:10.790]                     invokeRestart <- base::invokeRestart
[13:35:10.790]                     is.null <- base::is.null
[13:35:10.790]                     muffled <- FALSE
[13:35:10.790]                     if (inherits(cond, "message")) {
[13:35:10.790]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:10.790]                       if (muffled) 
[13:35:10.790]                         invokeRestart("muffleMessage")
[13:35:10.790]                     }
[13:35:10.790]                     else if (inherits(cond, "warning")) {
[13:35:10.790]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:10.790]                       if (muffled) 
[13:35:10.790]                         invokeRestart("muffleWarning")
[13:35:10.790]                     }
[13:35:10.790]                     else if (inherits(cond, "condition")) {
[13:35:10.790]                       if (!is.null(pattern)) {
[13:35:10.790]                         computeRestarts <- base::computeRestarts
[13:35:10.790]                         grepl <- base::grepl
[13:35:10.790]                         restarts <- computeRestarts(cond)
[13:35:10.790]                         for (restart in restarts) {
[13:35:10.790]                           name <- restart$name
[13:35:10.790]                           if (is.null(name)) 
[13:35:10.790]                             next
[13:35:10.790]                           if (!grepl(pattern, name)) 
[13:35:10.790]                             next
[13:35:10.790]                           invokeRestart(restart)
[13:35:10.790]                           muffled <- TRUE
[13:35:10.790]                           break
[13:35:10.790]                         }
[13:35:10.790]                       }
[13:35:10.790]                     }
[13:35:10.790]                     invisible(muffled)
[13:35:10.790]                   }
[13:35:10.790]                   muffleCondition(cond)
[13:35:10.790]                 })
[13:35:10.790]             }))
[13:35:10.790]             future::FutureResult(value = ...future.value$value, 
[13:35:10.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:10.790]                   ...future.rng), globalenv = if (FALSE) 
[13:35:10.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:10.790]                     ...future.globalenv.names))
[13:35:10.790]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:10.790]         }, condition = base::local({
[13:35:10.790]             c <- base::c
[13:35:10.790]             inherits <- base::inherits
[13:35:10.790]             invokeRestart <- base::invokeRestart
[13:35:10.790]             length <- base::length
[13:35:10.790]             list <- base::list
[13:35:10.790]             seq.int <- base::seq.int
[13:35:10.790]             signalCondition <- base::signalCondition
[13:35:10.790]             sys.calls <- base::sys.calls
[13:35:10.790]             `[[` <- base::`[[`
[13:35:10.790]             `+` <- base::`+`
[13:35:10.790]             `<<-` <- base::`<<-`
[13:35:10.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:10.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:10.790]                   3L)]
[13:35:10.790]             }
[13:35:10.790]             function(cond) {
[13:35:10.790]                 is_error <- inherits(cond, "error")
[13:35:10.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:10.790]                   NULL)
[13:35:10.790]                 if (is_error) {
[13:35:10.790]                   sessionInformation <- function() {
[13:35:10.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:10.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:10.790]                       search = base::search(), system = base::Sys.info())
[13:35:10.790]                   }
[13:35:10.790]                   ...future.conditions[[length(...future.conditions) + 
[13:35:10.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:10.790]                     cond$call), session = sessionInformation(), 
[13:35:10.790]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:10.790]                   signalCondition(cond)
[13:35:10.790]                 }
[13:35:10.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:10.790]                 "immediateCondition"))) {
[13:35:10.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:10.790]                   ...future.conditions[[length(...future.conditions) + 
[13:35:10.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:10.790]                   if (TRUE && !signal) {
[13:35:10.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.790]                     {
[13:35:10.790]                       inherits <- base::inherits
[13:35:10.790]                       invokeRestart <- base::invokeRestart
[13:35:10.790]                       is.null <- base::is.null
[13:35:10.790]                       muffled <- FALSE
[13:35:10.790]                       if (inherits(cond, "message")) {
[13:35:10.790]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:10.790]                         if (muffled) 
[13:35:10.790]                           invokeRestart("muffleMessage")
[13:35:10.790]                       }
[13:35:10.790]                       else if (inherits(cond, "warning")) {
[13:35:10.790]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:10.790]                         if (muffled) 
[13:35:10.790]                           invokeRestart("muffleWarning")
[13:35:10.790]                       }
[13:35:10.790]                       else if (inherits(cond, "condition")) {
[13:35:10.790]                         if (!is.null(pattern)) {
[13:35:10.790]                           computeRestarts <- base::computeRestarts
[13:35:10.790]                           grepl <- base::grepl
[13:35:10.790]                           restarts <- computeRestarts(cond)
[13:35:10.790]                           for (restart in restarts) {
[13:35:10.790]                             name <- restart$name
[13:35:10.790]                             if (is.null(name)) 
[13:35:10.790]                               next
[13:35:10.790]                             if (!grepl(pattern, name)) 
[13:35:10.790]                               next
[13:35:10.790]                             invokeRestart(restart)
[13:35:10.790]                             muffled <- TRUE
[13:35:10.790]                             break
[13:35:10.790]                           }
[13:35:10.790]                         }
[13:35:10.790]                       }
[13:35:10.790]                       invisible(muffled)
[13:35:10.790]                     }
[13:35:10.790]                     muffleCondition(cond, pattern = "^muffle")
[13:35:10.790]                   }
[13:35:10.790]                 }
[13:35:10.790]                 else {
[13:35:10.790]                   if (TRUE) {
[13:35:10.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.790]                     {
[13:35:10.790]                       inherits <- base::inherits
[13:35:10.790]                       invokeRestart <- base::invokeRestart
[13:35:10.790]                       is.null <- base::is.null
[13:35:10.790]                       muffled <- FALSE
[13:35:10.790]                       if (inherits(cond, "message")) {
[13:35:10.790]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:10.790]                         if (muffled) 
[13:35:10.790]                           invokeRestart("muffleMessage")
[13:35:10.790]                       }
[13:35:10.790]                       else if (inherits(cond, "warning")) {
[13:35:10.790]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:10.790]                         if (muffled) 
[13:35:10.790]                           invokeRestart("muffleWarning")
[13:35:10.790]                       }
[13:35:10.790]                       else if (inherits(cond, "condition")) {
[13:35:10.790]                         if (!is.null(pattern)) {
[13:35:10.790]                           computeRestarts <- base::computeRestarts
[13:35:10.790]                           grepl <- base::grepl
[13:35:10.790]                           restarts <- computeRestarts(cond)
[13:35:10.790]                           for (restart in restarts) {
[13:35:10.790]                             name <- restart$name
[13:35:10.790]                             if (is.null(name)) 
[13:35:10.790]                               next
[13:35:10.790]                             if (!grepl(pattern, name)) 
[13:35:10.790]                               next
[13:35:10.790]                             invokeRestart(restart)
[13:35:10.790]                             muffled <- TRUE
[13:35:10.790]                             break
[13:35:10.790]                           }
[13:35:10.790]                         }
[13:35:10.790]                       }
[13:35:10.790]                       invisible(muffled)
[13:35:10.790]                     }
[13:35:10.790]                     muffleCondition(cond, pattern = "^muffle")
[13:35:10.790]                   }
[13:35:10.790]                 }
[13:35:10.790]             }
[13:35:10.790]         }))
[13:35:10.790]     }, error = function(ex) {
[13:35:10.790]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:10.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:10.790]                 ...future.rng), started = ...future.startTime, 
[13:35:10.790]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:10.790]             version = "1.8"), class = "FutureResult")
[13:35:10.790]     }, finally = {
[13:35:10.790]         if (!identical(...future.workdir, getwd())) 
[13:35:10.790]             setwd(...future.workdir)
[13:35:10.790]         {
[13:35:10.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:10.790]                 ...future.oldOptions$nwarnings <- NULL
[13:35:10.790]             }
[13:35:10.790]             base::options(...future.oldOptions)
[13:35:10.790]             if (.Platform$OS.type == "windows") {
[13:35:10.790]                 old_names <- names(...future.oldEnvVars)
[13:35:10.790]                 envs <- base::Sys.getenv()
[13:35:10.790]                 names <- names(envs)
[13:35:10.790]                 common <- intersect(names, old_names)
[13:35:10.790]                 added <- setdiff(names, old_names)
[13:35:10.790]                 removed <- setdiff(old_names, names)
[13:35:10.790]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:10.790]                   envs[common]]
[13:35:10.790]                 NAMES <- toupper(changed)
[13:35:10.790]                 args <- list()
[13:35:10.790]                 for (kk in seq_along(NAMES)) {
[13:35:10.790]                   name <- changed[[kk]]
[13:35:10.790]                   NAME <- NAMES[[kk]]
[13:35:10.790]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.790]                     next
[13:35:10.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:10.790]                 }
[13:35:10.790]                 NAMES <- toupper(added)
[13:35:10.790]                 for (kk in seq_along(NAMES)) {
[13:35:10.790]                   name <- added[[kk]]
[13:35:10.790]                   NAME <- NAMES[[kk]]
[13:35:10.790]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.790]                     next
[13:35:10.790]                   args[[name]] <- ""
[13:35:10.790]                 }
[13:35:10.790]                 NAMES <- toupper(removed)
[13:35:10.790]                 for (kk in seq_along(NAMES)) {
[13:35:10.790]                   name <- removed[[kk]]
[13:35:10.790]                   NAME <- NAMES[[kk]]
[13:35:10.790]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.790]                     next
[13:35:10.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:10.790]                 }
[13:35:10.790]                 if (length(args) > 0) 
[13:35:10.790]                   base::do.call(base::Sys.setenv, args = args)
[13:35:10.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:10.790]             }
[13:35:10.790]             else {
[13:35:10.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:10.790]             }
[13:35:10.790]             {
[13:35:10.790]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:10.790]                   0L) {
[13:35:10.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:10.790]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:10.790]                   base::options(opts)
[13:35:10.790]                 }
[13:35:10.790]                 {
[13:35:10.790]                   {
[13:35:10.790]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:10.790]                     NULL
[13:35:10.790]                   }
[13:35:10.790]                   options(future.plan = NULL)
[13:35:10.790]                   if (is.na(NA_character_)) 
[13:35:10.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:10.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:10.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:10.790]                     .init = FALSE)
[13:35:10.790]                 }
[13:35:10.790]             }
[13:35:10.790]         }
[13:35:10.790]     })
[13:35:10.790]     if (TRUE) {
[13:35:10.790]         base::sink(type = "output", split = FALSE)
[13:35:10.790]         if (TRUE) {
[13:35:10.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:10.790]         }
[13:35:10.790]         else {
[13:35:10.790]             ...future.result["stdout"] <- base::list(NULL)
[13:35:10.790]         }
[13:35:10.790]         base::close(...future.stdout)
[13:35:10.790]         ...future.stdout <- NULL
[13:35:10.790]     }
[13:35:10.790]     ...future.result$conditions <- ...future.conditions
[13:35:10.790]     ...future.result$finished <- base::Sys.time()
[13:35:10.790]     ...future.result
[13:35:10.790] }
[13:35:10.793] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[13:35:10.793] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:10.834] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:10.835] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:35:10.835] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:35:10.835] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:10.835] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:10.836] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:10.878] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:10.879] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:10.922] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:10.923] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:10.923] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.923] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:10.924] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:10.924] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:10.924] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.924] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:35:10.925] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:35:10.925] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:10.925] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.925] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:10.926] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:10.926] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[13:35:10.926] MultisessionFuture started
[13:35:10.926] - Launch lazy future ... done
[13:35:10.926] run() for ‘MultisessionFuture’ ... done
[13:35:10.927] Created future:
[13:35:10.928] receiveMessageFromWorker() for ClusterFuture ...
[13:35:10.928] - Validating connection of MultisessionFuture
[13:35:10.928] - received message: FutureResult
[13:35:10.928] - Received FutureResult
[13:35:10.928] - Erased future from FutureRegistry
[13:35:10.929] result() for ClusterFuture ...
[13:35:10.929] - result already collected: FutureResult
[13:35:10.929] result() for ClusterFuture ... done
[13:35:10.929] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:10.927] MultisessionFuture:
[13:35:10.927] Label: ‘future_vapply-2’
[13:35:10.927] Expression:
[13:35:10.927] {
[13:35:10.927]     do.call(function(...) {
[13:35:10.927]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.927]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:10.927]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.927]             on.exit(options(oopts), add = TRUE)
[13:35:10.927]         }
[13:35:10.927]         {
[13:35:10.927]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:10.927]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.927]                 ...future.FUN(...future.X_jj, ...)
[13:35:10.927]             })
[13:35:10.927]         }
[13:35:10.927]     }, args = future.call.arguments)
[13:35:10.927] }
[13:35:10.927] Lazy evaluation: FALSE
[13:35:10.927] Asynchronous evaluation: TRUE
[13:35:10.927] Local evaluation: TRUE
[13:35:10.927] Environment: R_GlobalEnv
[13:35:10.927] Capture standard output: TRUE
[13:35:10.927] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:10.927] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:10.927] Packages: 1 packages (‘future.apply’)
[13:35:10.927] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:10.927] Resolved: TRUE
[13:35:10.927] Value: <not collected>
[13:35:10.927] Conditions captured: <none>
[13:35:10.927] Early signaling: FALSE
[13:35:10.927] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:10.927] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:10.929] Chunk #2 of 2 ... DONE
[13:35:10.929] Launching 2 futures (chunks) ... DONE
[13:35:10.929] Resolving 2 futures (chunks) ...
[13:35:10.929] resolve() on list ...
[13:35:10.929]  recursive: 0
[13:35:10.930]  length: 2
[13:35:10.930] 
[13:35:10.930] Future #1
[13:35:10.930] result() for ClusterFuture ...
[13:35:10.930] - result already collected: FutureResult
[13:35:10.930] result() for ClusterFuture ... done
[13:35:10.930] result() for ClusterFuture ...
[13:35:10.930] - result already collected: FutureResult
[13:35:10.930] result() for ClusterFuture ... done
[13:35:10.930] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:10.931] - nx: 2
[13:35:10.931] - relay: TRUE
[13:35:10.931] - stdout: TRUE
[13:35:10.931] - signal: TRUE
[13:35:10.931] - resignal: FALSE
[13:35:10.931] - force: TRUE
[13:35:10.931] - relayed: [n=2] FALSE, FALSE
[13:35:10.931] - queued futures: [n=2] FALSE, FALSE
[13:35:10.931]  - until=1
[13:35:10.931]  - relaying element #1
[13:35:10.931] result() for ClusterFuture ...
[13:35:10.931] - result already collected: FutureResult
[13:35:10.932] result() for ClusterFuture ... done
[13:35:10.932] result() for ClusterFuture ...
[13:35:10.932] - result already collected: FutureResult
[13:35:10.932] result() for ClusterFuture ... done
[13:35:10.932] result() for ClusterFuture ...
[13:35:10.932] - result already collected: FutureResult
[13:35:10.932] result() for ClusterFuture ... done
[13:35:10.932] result() for ClusterFuture ...
[13:35:10.932] - result already collected: FutureResult
[13:35:10.932] result() for ClusterFuture ... done
[13:35:10.932] - relayed: [n=2] TRUE, FALSE
[13:35:10.932] - queued futures: [n=2] TRUE, FALSE
[13:35:10.933] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:10.933]  length: 1 (resolved future 1)
[13:35:10.933] Future #2
[13:35:10.933] result() for ClusterFuture ...
[13:35:10.933] - result already collected: FutureResult
[13:35:10.933] result() for ClusterFuture ... done
[13:35:10.933] result() for ClusterFuture ...
[13:35:10.933] - result already collected: FutureResult
[13:35:10.933] result() for ClusterFuture ... done
[13:35:10.933] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:10.933] - nx: 2
[13:35:10.934] - relay: TRUE
[13:35:10.934] - stdout: TRUE
[13:35:10.934] - signal: TRUE
[13:35:10.934] - resignal: FALSE
[13:35:10.934] - force: TRUE
[13:35:10.934] - relayed: [n=2] TRUE, FALSE
[13:35:10.934] - queued futures: [n=2] TRUE, FALSE
[13:35:10.934]  - until=2
[13:35:10.934]  - relaying element #2
[13:35:10.934] result() for ClusterFuture ...
[13:35:10.934] - result already collected: FutureResult
[13:35:10.935] result() for ClusterFuture ... done
[13:35:10.935] result() for ClusterFuture ...
[13:35:10.935] - result already collected: FutureResult
[13:35:10.935] result() for ClusterFuture ... done
[13:35:10.935] result() for ClusterFuture ...
[13:35:10.935] - result already collected: FutureResult
[13:35:10.935] result() for ClusterFuture ... done
[13:35:10.935] result() for ClusterFuture ...
[13:35:10.935] - result already collected: FutureResult
[13:35:10.935] result() for ClusterFuture ... done
[13:35:10.935] - relayed: [n=2] TRUE, TRUE
[13:35:10.936] - queued futures: [n=2] TRUE, TRUE
[13:35:10.936] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:10.936]  length: 0 (resolved future 2)
[13:35:10.936] Relaying remaining futures
[13:35:10.936] signalConditionsASAP(NULL, pos=0) ...
[13:35:10.936] - nx: 2
[13:35:10.936] - relay: TRUE
[13:35:10.936] - stdout: TRUE
[13:35:10.936] - signal: TRUE
[13:35:10.936] - resignal: FALSE
[13:35:10.936] - force: TRUE
[13:35:10.936] - relayed: [n=2] TRUE, TRUE
[13:35:10.936] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:10.937] - relayed: [n=2] TRUE, TRUE
[13:35:10.937] - queued futures: [n=2] TRUE, TRUE
[13:35:10.937] signalConditionsASAP(NULL, pos=0) ... done
[13:35:10.937] resolve() on list ... DONE
[13:35:10.937] result() for ClusterFuture ...
[13:35:10.937] - result already collected: FutureResult
[13:35:10.937] result() for ClusterFuture ... done
[13:35:10.937] result() for ClusterFuture ...
[13:35:10.937] - result already collected: FutureResult
[13:35:10.937] result() for ClusterFuture ... done
[13:35:10.938] result() for ClusterFuture ...
[13:35:10.938] - result already collected: FutureResult
[13:35:10.938] result() for ClusterFuture ... done
[13:35:10.938] result() for ClusterFuture ...
[13:35:10.938] - result already collected: FutureResult
[13:35:10.938] result() for ClusterFuture ... done
[13:35:10.938]  - Number of value chunks collected: 2
[13:35:10.938] Resolving 2 futures (chunks) ... DONE
[13:35:10.938] Reducing values from 2 chunks ...
[13:35:10.938]  - Number of values collected after concatenation: 10
[13:35:10.938]  - Number of values expected: 10
[13:35:10.938] Reducing values from 2 chunks ... DONE
[13:35:10.939] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[13:35:10.939] future_lapply() ...
[13:35:10.945] Number of chunks: 2
[13:35:10.945] getGlobalsAndPackagesXApply() ...
[13:35:10.945]  - future.globals: TRUE
[13:35:10.945] getGlobalsAndPackages() ...
[13:35:10.945] Searching for globals...
[13:35:10.948] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[13:35:10.949] Searching for globals ... DONE
[13:35:10.949] Resolving globals: FALSE
[13:35:10.949] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[13:35:10.950] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:10.950] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:10.950] - packages: [1] ‘future.apply’
[13:35:10.950] getGlobalsAndPackages() ... DONE
[13:35:10.950]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:10.950]  - needed namespaces: [n=1] ‘future.apply’
[13:35:10.951] Finding globals ... DONE
[13:35:10.951]  - use_args: TRUE
[13:35:10.951]  - Getting '...' globals ...
[13:35:10.951] resolve() on list ...
[13:35:10.951]  recursive: 0
[13:35:10.951]  length: 1
[13:35:10.951]  elements: ‘...’
[13:35:10.951]  length: 0 (resolved future 1)
[13:35:10.952] resolve() on list ... DONE
[13:35:10.952]    - '...' content: [n=0] 
[13:35:10.952] List of 1
[13:35:10.952]  $ ...: list()
[13:35:10.952]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:10.952]  - attr(*, "where")=List of 1
[13:35:10.952]   ..$ ...:<environment: 0x5574d1ec7a88> 
[13:35:10.952]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:10.952]  - attr(*, "resolved")= logi TRUE
[13:35:10.952]  - attr(*, "total_size")= num NA
[13:35:10.954]  - Getting '...' globals ... DONE
[13:35:10.954] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:10.954] List of 8
[13:35:10.954]  $ ...future.FUN:function (x, ...)  
[13:35:10.954]  $ x_FUN        :function (x)  
[13:35:10.954]  $ times        : int 2
[13:35:10.954]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:10.954]  $ stop_if_not  :function (...)  
[13:35:10.954]  $ dim          : NULL
[13:35:10.954]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:10.954]  $ ...          : list()
[13:35:10.954]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:10.954]  - attr(*, "where")=List of 8
[13:35:10.954]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:10.954]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:10.954]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:10.954]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:10.954]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:10.954]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:10.954]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:10.954]   ..$ ...          :<environment: 0x5574d1ec7a88> 
[13:35:10.954]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:10.954]  - attr(*, "resolved")= logi FALSE
[13:35:10.954]  - attr(*, "total_size")= num 96456
[13:35:10.960] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:10.960] getGlobalsAndPackagesXApply() ... DONE
[13:35:10.960] Number of futures (= number of chunks): 2
[13:35:10.960] Launching 2 futures (chunks) ...
[13:35:10.960] Chunk #1 of 2 ...
[13:35:10.960]  - Finding globals in 'X' for chunk #1 ...
[13:35:10.960] getGlobalsAndPackages() ...
[13:35:10.960] Searching for globals...
[13:35:10.961] 
[13:35:10.961] Searching for globals ... DONE
[13:35:10.961] - globals: [0] <none>
[13:35:10.961] getGlobalsAndPackages() ... DONE
[13:35:10.961]    + additional globals found: [n=0] 
[13:35:10.961]    + additional namespaces needed: [n=0] 
[13:35:10.961]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:10.961]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:10.961]  - seeds: <none>
[13:35:10.961]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.962] getGlobalsAndPackages() ...
[13:35:10.962] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.962] Resolving globals: FALSE
[13:35:10.962] Tweak future expression to call with '...' arguments ...
[13:35:10.962] {
[13:35:10.962]     do.call(function(...) {
[13:35:10.962]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.962]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:10.962]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.962]             on.exit(options(oopts), add = TRUE)
[13:35:10.962]         }
[13:35:10.962]         {
[13:35:10.962]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:10.962]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.962]                 ...future.FUN(...future.X_jj, ...)
[13:35:10.962]             })
[13:35:10.962]         }
[13:35:10.962]     }, args = future.call.arguments)
[13:35:10.962] }
[13:35:10.962] Tweak future expression to call with '...' arguments ... DONE
[13:35:10.963] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:10.963] - packages: [1] ‘future.apply’
[13:35:10.963] getGlobalsAndPackages() ... DONE
[13:35:10.963] run() for ‘Future’ ...
[13:35:10.963] - state: ‘created’
[13:35:10.963] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:10.977] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:10.977] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:10.977]   - Field: ‘node’
[13:35:10.977]   - Field: ‘label’
[13:35:10.978]   - Field: ‘local’
[13:35:10.978]   - Field: ‘owner’
[13:35:10.978]   - Field: ‘envir’
[13:35:10.978]   - Field: ‘workers’
[13:35:10.978]   - Field: ‘packages’
[13:35:10.978]   - Field: ‘gc’
[13:35:10.978]   - Field: ‘conditions’
[13:35:10.978]   - Field: ‘persistent’
[13:35:10.978]   - Field: ‘expr’
[13:35:10.978]   - Field: ‘uuid’
[13:35:10.979]   - Field: ‘seed’
[13:35:10.979]   - Field: ‘version’
[13:35:10.979]   - Field: ‘result’
[13:35:10.979]   - Field: ‘asynchronous’
[13:35:10.979]   - Field: ‘calls’
[13:35:10.979]   - Field: ‘globals’
[13:35:10.979]   - Field: ‘stdout’
[13:35:10.979]   - Field: ‘earlySignal’
[13:35:10.979]   - Field: ‘lazy’
[13:35:10.979]   - Field: ‘state’
[13:35:10.979] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:10.980] - Launch lazy future ...
[13:35:10.980] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:10.980] Packages needed by future strategies (n = 0): <none>
[13:35:10.980] {
[13:35:10.980]     {
[13:35:10.980]         {
[13:35:10.980]             ...future.startTime <- base::Sys.time()
[13:35:10.980]             {
[13:35:10.980]                 {
[13:35:10.980]                   {
[13:35:10.980]                     {
[13:35:10.980]                       {
[13:35:10.980]                         base::local({
[13:35:10.980]                           has_future <- base::requireNamespace("future", 
[13:35:10.980]                             quietly = TRUE)
[13:35:10.980]                           if (has_future) {
[13:35:10.980]                             ns <- base::getNamespace("future")
[13:35:10.980]                             version <- ns[[".package"]][["version"]]
[13:35:10.980]                             if (is.null(version)) 
[13:35:10.980]                               version <- utils::packageVersion("future")
[13:35:10.980]                           }
[13:35:10.980]                           else {
[13:35:10.980]                             version <- NULL
[13:35:10.980]                           }
[13:35:10.980]                           if (!has_future || version < "1.8.0") {
[13:35:10.980]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:10.980]                               "", base::R.version$version.string), 
[13:35:10.980]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:10.980]                                 base::R.version$platform, 8 * 
[13:35:10.980]                                   base::.Machine$sizeof.pointer), 
[13:35:10.980]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:10.980]                                 "release", "version")], collapse = " "), 
[13:35:10.980]                               hostname = base::Sys.info()[["nodename"]])
[13:35:10.980]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:10.980]                               info)
[13:35:10.980]                             info <- base::paste(info, collapse = "; ")
[13:35:10.980]                             if (!has_future) {
[13:35:10.980]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:10.980]                                 info)
[13:35:10.980]                             }
[13:35:10.980]                             else {
[13:35:10.980]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:10.980]                                 info, version)
[13:35:10.980]                             }
[13:35:10.980]                             base::stop(msg)
[13:35:10.980]                           }
[13:35:10.980]                         })
[13:35:10.980]                       }
[13:35:10.980]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:10.980]                       base::options(mc.cores = 1L)
[13:35:10.980]                     }
[13:35:10.980]                     base::local({
[13:35:10.980]                       for (pkg in "future.apply") {
[13:35:10.980]                         base::loadNamespace(pkg)
[13:35:10.980]                         base::library(pkg, character.only = TRUE)
[13:35:10.980]                       }
[13:35:10.980]                     })
[13:35:10.980]                   }
[13:35:10.980]                   ...future.strategy.old <- future::plan("list")
[13:35:10.980]                   options(future.plan = NULL)
[13:35:10.980]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:10.980]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:10.980]                 }
[13:35:10.980]                 ...future.workdir <- getwd()
[13:35:10.980]             }
[13:35:10.980]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:10.980]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:10.980]         }
[13:35:10.980]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:10.980]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:10.980]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:10.980]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:10.980]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:10.980]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:10.980]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:10.980]             base::names(...future.oldOptions))
[13:35:10.980]     }
[13:35:10.980]     if (FALSE) {
[13:35:10.980]     }
[13:35:10.980]     else {
[13:35:10.980]         if (TRUE) {
[13:35:10.980]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:10.980]                 open = "w")
[13:35:10.980]         }
[13:35:10.980]         else {
[13:35:10.980]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:10.980]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:10.980]         }
[13:35:10.980]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:10.980]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:10.980]             base::sink(type = "output", split = FALSE)
[13:35:10.980]             base::close(...future.stdout)
[13:35:10.980]         }, add = TRUE)
[13:35:10.980]     }
[13:35:10.980]     ...future.frame <- base::sys.nframe()
[13:35:10.980]     ...future.conditions <- base::list()
[13:35:10.980]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:10.980]     if (FALSE) {
[13:35:10.980]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:10.980]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:10.980]     }
[13:35:10.980]     ...future.result <- base::tryCatch({
[13:35:10.980]         base::withCallingHandlers({
[13:35:10.980]             ...future.value <- base::withVisible(base::local({
[13:35:10.980]                 ...future.makeSendCondition <- base::local({
[13:35:10.980]                   sendCondition <- NULL
[13:35:10.980]                   function(frame = 1L) {
[13:35:10.980]                     if (is.function(sendCondition)) 
[13:35:10.980]                       return(sendCondition)
[13:35:10.980]                     ns <- getNamespace("parallel")
[13:35:10.980]                     if (exists("sendData", mode = "function", 
[13:35:10.980]                       envir = ns)) {
[13:35:10.980]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:10.980]                         envir = ns)
[13:35:10.980]                       envir <- sys.frame(frame)
[13:35:10.980]                       master <- NULL
[13:35:10.980]                       while (!identical(envir, .GlobalEnv) && 
[13:35:10.980]                         !identical(envir, emptyenv())) {
[13:35:10.980]                         if (exists("master", mode = "list", envir = envir, 
[13:35:10.980]                           inherits = FALSE)) {
[13:35:10.980]                           master <- get("master", mode = "list", 
[13:35:10.980]                             envir = envir, inherits = FALSE)
[13:35:10.980]                           if (inherits(master, c("SOCKnode", 
[13:35:10.980]                             "SOCK0node"))) {
[13:35:10.980]                             sendCondition <<- function(cond) {
[13:35:10.980]                               data <- list(type = "VALUE", value = cond, 
[13:35:10.980]                                 success = TRUE)
[13:35:10.980]                               parallel_sendData(master, data)
[13:35:10.980]                             }
[13:35:10.980]                             return(sendCondition)
[13:35:10.980]                           }
[13:35:10.980]                         }
[13:35:10.980]                         frame <- frame + 1L
[13:35:10.980]                         envir <- sys.frame(frame)
[13:35:10.980]                       }
[13:35:10.980]                     }
[13:35:10.980]                     sendCondition <<- function(cond) NULL
[13:35:10.980]                   }
[13:35:10.980]                 })
[13:35:10.980]                 withCallingHandlers({
[13:35:10.980]                   {
[13:35:10.980]                     do.call(function(...) {
[13:35:10.980]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:10.980]                       if (!identical(...future.globals.maxSize.org, 
[13:35:10.980]                         ...future.globals.maxSize)) {
[13:35:10.980]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:10.980]                         on.exit(options(oopts), add = TRUE)
[13:35:10.980]                       }
[13:35:10.980]                       {
[13:35:10.980]                         lapply(seq_along(...future.elements_ii), 
[13:35:10.980]                           FUN = function(jj) {
[13:35:10.980]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:10.980]                             ...future.FUN(...future.X_jj, ...)
[13:35:10.980]                           })
[13:35:10.980]                       }
[13:35:10.980]                     }, args = future.call.arguments)
[13:35:10.980]                   }
[13:35:10.980]                 }, immediateCondition = function(cond) {
[13:35:10.980]                   sendCondition <- ...future.makeSendCondition()
[13:35:10.980]                   sendCondition(cond)
[13:35:10.980]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.980]                   {
[13:35:10.980]                     inherits <- base::inherits
[13:35:10.980]                     invokeRestart <- base::invokeRestart
[13:35:10.980]                     is.null <- base::is.null
[13:35:10.980]                     muffled <- FALSE
[13:35:10.980]                     if (inherits(cond, "message")) {
[13:35:10.980]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:10.980]                       if (muffled) 
[13:35:10.980]                         invokeRestart("muffleMessage")
[13:35:10.980]                     }
[13:35:10.980]                     else if (inherits(cond, "warning")) {
[13:35:10.980]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:10.980]                       if (muffled) 
[13:35:10.980]                         invokeRestart("muffleWarning")
[13:35:10.980]                     }
[13:35:10.980]                     else if (inherits(cond, "condition")) {
[13:35:10.980]                       if (!is.null(pattern)) {
[13:35:10.980]                         computeRestarts <- base::computeRestarts
[13:35:10.980]                         grepl <- base::grepl
[13:35:10.980]                         restarts <- computeRestarts(cond)
[13:35:10.980]                         for (restart in restarts) {
[13:35:10.980]                           name <- restart$name
[13:35:10.980]                           if (is.null(name)) 
[13:35:10.980]                             next
[13:35:10.980]                           if (!grepl(pattern, name)) 
[13:35:10.980]                             next
[13:35:10.980]                           invokeRestart(restart)
[13:35:10.980]                           muffled <- TRUE
[13:35:10.980]                           break
[13:35:10.980]                         }
[13:35:10.980]                       }
[13:35:10.980]                     }
[13:35:10.980]                     invisible(muffled)
[13:35:10.980]                   }
[13:35:10.980]                   muffleCondition(cond)
[13:35:10.980]                 })
[13:35:10.980]             }))
[13:35:10.980]             future::FutureResult(value = ...future.value$value, 
[13:35:10.980]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:10.980]                   ...future.rng), globalenv = if (FALSE) 
[13:35:10.980]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:10.980]                     ...future.globalenv.names))
[13:35:10.980]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:10.980]         }, condition = base::local({
[13:35:10.980]             c <- base::c
[13:35:10.980]             inherits <- base::inherits
[13:35:10.980]             invokeRestart <- base::invokeRestart
[13:35:10.980]             length <- base::length
[13:35:10.980]             list <- base::list
[13:35:10.980]             seq.int <- base::seq.int
[13:35:10.980]             signalCondition <- base::signalCondition
[13:35:10.980]             sys.calls <- base::sys.calls
[13:35:10.980]             `[[` <- base::`[[`
[13:35:10.980]             `+` <- base::`+`
[13:35:10.980]             `<<-` <- base::`<<-`
[13:35:10.980]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:10.980]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:10.980]                   3L)]
[13:35:10.980]             }
[13:35:10.980]             function(cond) {
[13:35:10.980]                 is_error <- inherits(cond, "error")
[13:35:10.980]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:10.980]                   NULL)
[13:35:10.980]                 if (is_error) {
[13:35:10.980]                   sessionInformation <- function() {
[13:35:10.980]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:10.980]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:10.980]                       search = base::search(), system = base::Sys.info())
[13:35:10.980]                   }
[13:35:10.980]                   ...future.conditions[[length(...future.conditions) + 
[13:35:10.980]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:10.980]                     cond$call), session = sessionInformation(), 
[13:35:10.980]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:10.980]                   signalCondition(cond)
[13:35:10.980]                 }
[13:35:10.980]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:10.980]                 "immediateCondition"))) {
[13:35:10.980]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:10.980]                   ...future.conditions[[length(...future.conditions) + 
[13:35:10.980]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:10.980]                   if (TRUE && !signal) {
[13:35:10.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.980]                     {
[13:35:10.980]                       inherits <- base::inherits
[13:35:10.980]                       invokeRestart <- base::invokeRestart
[13:35:10.980]                       is.null <- base::is.null
[13:35:10.980]                       muffled <- FALSE
[13:35:10.980]                       if (inherits(cond, "message")) {
[13:35:10.980]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:10.980]                         if (muffled) 
[13:35:10.980]                           invokeRestart("muffleMessage")
[13:35:10.980]                       }
[13:35:10.980]                       else if (inherits(cond, "warning")) {
[13:35:10.980]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:10.980]                         if (muffled) 
[13:35:10.980]                           invokeRestart("muffleWarning")
[13:35:10.980]                       }
[13:35:10.980]                       else if (inherits(cond, "condition")) {
[13:35:10.980]                         if (!is.null(pattern)) {
[13:35:10.980]                           computeRestarts <- base::computeRestarts
[13:35:10.980]                           grepl <- base::grepl
[13:35:10.980]                           restarts <- computeRestarts(cond)
[13:35:10.980]                           for (restart in restarts) {
[13:35:10.980]                             name <- restart$name
[13:35:10.980]                             if (is.null(name)) 
[13:35:10.980]                               next
[13:35:10.980]                             if (!grepl(pattern, name)) 
[13:35:10.980]                               next
[13:35:10.980]                             invokeRestart(restart)
[13:35:10.980]                             muffled <- TRUE
[13:35:10.980]                             break
[13:35:10.980]                           }
[13:35:10.980]                         }
[13:35:10.980]                       }
[13:35:10.980]                       invisible(muffled)
[13:35:10.980]                     }
[13:35:10.980]                     muffleCondition(cond, pattern = "^muffle")
[13:35:10.980]                   }
[13:35:10.980]                 }
[13:35:10.980]                 else {
[13:35:10.980]                   if (TRUE) {
[13:35:10.980]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:10.980]                     {
[13:35:10.980]                       inherits <- base::inherits
[13:35:10.980]                       invokeRestart <- base::invokeRestart
[13:35:10.980]                       is.null <- base::is.null
[13:35:10.980]                       muffled <- FALSE
[13:35:10.980]                       if (inherits(cond, "message")) {
[13:35:10.980]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:10.980]                         if (muffled) 
[13:35:10.980]                           invokeRestart("muffleMessage")
[13:35:10.980]                       }
[13:35:10.980]                       else if (inherits(cond, "warning")) {
[13:35:10.980]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:10.980]                         if (muffled) 
[13:35:10.980]                           invokeRestart("muffleWarning")
[13:35:10.980]                       }
[13:35:10.980]                       else if (inherits(cond, "condition")) {
[13:35:10.980]                         if (!is.null(pattern)) {
[13:35:10.980]                           computeRestarts <- base::computeRestarts
[13:35:10.980]                           grepl <- base::grepl
[13:35:10.980]                           restarts <- computeRestarts(cond)
[13:35:10.980]                           for (restart in restarts) {
[13:35:10.980]                             name <- restart$name
[13:35:10.980]                             if (is.null(name)) 
[13:35:10.980]                               next
[13:35:10.980]                             if (!grepl(pattern, name)) 
[13:35:10.980]                               next
[13:35:10.980]                             invokeRestart(restart)
[13:35:10.980]                             muffled <- TRUE
[13:35:10.980]                             break
[13:35:10.980]                           }
[13:35:10.980]                         }
[13:35:10.980]                       }
[13:35:10.980]                       invisible(muffled)
[13:35:10.980]                     }
[13:35:10.980]                     muffleCondition(cond, pattern = "^muffle")
[13:35:10.980]                   }
[13:35:10.980]                 }
[13:35:10.980]             }
[13:35:10.980]         }))
[13:35:10.980]     }, error = function(ex) {
[13:35:10.980]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:10.980]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:10.980]                 ...future.rng), started = ...future.startTime, 
[13:35:10.980]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:10.980]             version = "1.8"), class = "FutureResult")
[13:35:10.980]     }, finally = {
[13:35:10.980]         if (!identical(...future.workdir, getwd())) 
[13:35:10.980]             setwd(...future.workdir)
[13:35:10.980]         {
[13:35:10.980]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:10.980]                 ...future.oldOptions$nwarnings <- NULL
[13:35:10.980]             }
[13:35:10.980]             base::options(...future.oldOptions)
[13:35:10.980]             if (.Platform$OS.type == "windows") {
[13:35:10.980]                 old_names <- names(...future.oldEnvVars)
[13:35:10.980]                 envs <- base::Sys.getenv()
[13:35:10.980]                 names <- names(envs)
[13:35:10.980]                 common <- intersect(names, old_names)
[13:35:10.980]                 added <- setdiff(names, old_names)
[13:35:10.980]                 removed <- setdiff(old_names, names)
[13:35:10.980]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:10.980]                   envs[common]]
[13:35:10.980]                 NAMES <- toupper(changed)
[13:35:10.980]                 args <- list()
[13:35:10.980]                 for (kk in seq_along(NAMES)) {
[13:35:10.980]                   name <- changed[[kk]]
[13:35:10.980]                   NAME <- NAMES[[kk]]
[13:35:10.980]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.980]                     next
[13:35:10.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:10.980]                 }
[13:35:10.980]                 NAMES <- toupper(added)
[13:35:10.980]                 for (kk in seq_along(NAMES)) {
[13:35:10.980]                   name <- added[[kk]]
[13:35:10.980]                   NAME <- NAMES[[kk]]
[13:35:10.980]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.980]                     next
[13:35:10.980]                   args[[name]] <- ""
[13:35:10.980]                 }
[13:35:10.980]                 NAMES <- toupper(removed)
[13:35:10.980]                 for (kk in seq_along(NAMES)) {
[13:35:10.980]                   name <- removed[[kk]]
[13:35:10.980]                   NAME <- NAMES[[kk]]
[13:35:10.980]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:10.980]                     next
[13:35:10.980]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:10.980]                 }
[13:35:10.980]                 if (length(args) > 0) 
[13:35:10.980]                   base::do.call(base::Sys.setenv, args = args)
[13:35:10.980]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:10.980]             }
[13:35:10.980]             else {
[13:35:10.980]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:10.980]             }
[13:35:10.980]             {
[13:35:10.980]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:10.980]                   0L) {
[13:35:10.980]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:10.980]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:10.980]                   base::options(opts)
[13:35:10.980]                 }
[13:35:10.980]                 {
[13:35:10.980]                   {
[13:35:10.980]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:10.980]                     NULL
[13:35:10.980]                   }
[13:35:10.980]                   options(future.plan = NULL)
[13:35:10.980]                   if (is.na(NA_character_)) 
[13:35:10.980]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:10.980]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:10.980]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:10.980]                     .init = FALSE)
[13:35:10.980]                 }
[13:35:10.980]             }
[13:35:10.980]         }
[13:35:10.980]     })
[13:35:10.980]     if (TRUE) {
[13:35:10.980]         base::sink(type = "output", split = FALSE)
[13:35:10.980]         if (TRUE) {
[13:35:10.980]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:10.980]         }
[13:35:10.980]         else {
[13:35:10.980]             ...future.result["stdout"] <- base::list(NULL)
[13:35:10.980]         }
[13:35:10.980]         base::close(...future.stdout)
[13:35:10.980]         ...future.stdout <- NULL
[13:35:10.980]     }
[13:35:10.980]     ...future.result$conditions <- ...future.conditions
[13:35:10.980]     ...future.result$finished <- base::Sys.time()
[13:35:10.980]     ...future.result
[13:35:10.980] }
[13:35:10.983] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[13:35:10.983] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:11.026] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:11.027] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[13:35:11.027] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[13:35:11.027] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:11.028] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:11.028] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:11.070] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:11.071] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:11.114] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:11.115] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:11.115] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.115] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:11.116] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:11.116] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:11.116] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.116] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:35:11.117] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:35:11.117] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:11.117] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.117] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:11.118] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.118] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[13:35:11.118] MultisessionFuture started
[13:35:11.118] - Launch lazy future ... done
[13:35:11.119] run() for ‘MultisessionFuture’ ... done
[13:35:11.119] Created future:
[13:35:11.120] receiveMessageFromWorker() for ClusterFuture ...
[13:35:11.120] - Validating connection of MultisessionFuture
[13:35:11.120] - received message: FutureResult
[13:35:11.121] - Received FutureResult
[13:35:11.121] - Erased future from FutureRegistry
[13:35:11.121] result() for ClusterFuture ...
[13:35:11.121] - result already collected: FutureResult
[13:35:11.121] result() for ClusterFuture ... done
[13:35:11.121] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:11.119] MultisessionFuture:
[13:35:11.119] Label: ‘future_vapply-1’
[13:35:11.119] Expression:
[13:35:11.119] {
[13:35:11.119]     do.call(function(...) {
[13:35:11.119]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.119]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:11.119]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.119]             on.exit(options(oopts), add = TRUE)
[13:35:11.119]         }
[13:35:11.119]         {
[13:35:11.119]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:11.119]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.119]                 ...future.FUN(...future.X_jj, ...)
[13:35:11.119]             })
[13:35:11.119]         }
[13:35:11.119]     }, args = future.call.arguments)
[13:35:11.119] }
[13:35:11.119] Lazy evaluation: FALSE
[13:35:11.119] Asynchronous evaluation: TRUE
[13:35:11.119] Local evaluation: TRUE
[13:35:11.119] Environment: R_GlobalEnv
[13:35:11.119] Capture standard output: TRUE
[13:35:11.119] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:11.119] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:11.119] Packages: 1 packages (‘future.apply’)
[13:35:11.119] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:11.119] Resolved: TRUE
[13:35:11.119] Value: <not collected>
[13:35:11.119] Conditions captured: <none>
[13:35:11.119] Early signaling: FALSE
[13:35:11.119] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:11.119] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:11.121] Chunk #1 of 2 ... DONE
[13:35:11.121] Chunk #2 of 2 ...
[13:35:11.122]  - Finding globals in 'X' for chunk #2 ...
[13:35:11.122] getGlobalsAndPackages() ...
[13:35:11.122] Searching for globals...
[13:35:11.122] 
[13:35:11.122] Searching for globals ... DONE
[13:35:11.122] - globals: [0] <none>
[13:35:11.122] getGlobalsAndPackages() ... DONE
[13:35:11.123]    + additional globals found: [n=0] 
[13:35:11.123]    + additional namespaces needed: [n=0] 
[13:35:11.123]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:11.123]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:11.123]  - seeds: <none>
[13:35:11.123]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.123] getGlobalsAndPackages() ...
[13:35:11.123] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.123] Resolving globals: FALSE
[13:35:11.123] Tweak future expression to call with '...' arguments ...
[13:35:11.126] {
[13:35:11.126]     do.call(function(...) {
[13:35:11.126]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.126]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:11.126]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.126]             on.exit(options(oopts), add = TRUE)
[13:35:11.126]         }
[13:35:11.126]         {
[13:35:11.126]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:11.126]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.126]                 ...future.FUN(...future.X_jj, ...)
[13:35:11.126]             })
[13:35:11.126]         }
[13:35:11.126]     }, args = future.call.arguments)
[13:35:11.126] }
[13:35:11.126] Tweak future expression to call with '...' arguments ... DONE
[13:35:11.127] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.127] - packages: [1] ‘future.apply’
[13:35:11.127] getGlobalsAndPackages() ... DONE
[13:35:11.127] run() for ‘Future’ ...
[13:35:11.128] - state: ‘created’
[13:35:11.128] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:11.142] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:11.142] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:11.142]   - Field: ‘node’
[13:35:11.142]   - Field: ‘label’
[13:35:11.142]   - Field: ‘local’
[13:35:11.143]   - Field: ‘owner’
[13:35:11.143]   - Field: ‘envir’
[13:35:11.143]   - Field: ‘workers’
[13:35:11.143]   - Field: ‘packages’
[13:35:11.143]   - Field: ‘gc’
[13:35:11.143]   - Field: ‘conditions’
[13:35:11.143]   - Field: ‘persistent’
[13:35:11.143]   - Field: ‘expr’
[13:35:11.143]   - Field: ‘uuid’
[13:35:11.143]   - Field: ‘seed’
[13:35:11.143]   - Field: ‘version’
[13:35:11.143]   - Field: ‘result’
[13:35:11.144]   - Field: ‘asynchronous’
[13:35:11.144]   - Field: ‘calls’
[13:35:11.144]   - Field: ‘globals’
[13:35:11.144]   - Field: ‘stdout’
[13:35:11.144]   - Field: ‘earlySignal’
[13:35:11.144]   - Field: ‘lazy’
[13:35:11.144]   - Field: ‘state’
[13:35:11.144] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:11.144] - Launch lazy future ...
[13:35:11.145] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:11.145] Packages needed by future strategies (n = 0): <none>
[13:35:11.145] {
[13:35:11.145]     {
[13:35:11.145]         {
[13:35:11.145]             ...future.startTime <- base::Sys.time()
[13:35:11.145]             {
[13:35:11.145]                 {
[13:35:11.145]                   {
[13:35:11.145]                     {
[13:35:11.145]                       {
[13:35:11.145]                         base::local({
[13:35:11.145]                           has_future <- base::requireNamespace("future", 
[13:35:11.145]                             quietly = TRUE)
[13:35:11.145]                           if (has_future) {
[13:35:11.145]                             ns <- base::getNamespace("future")
[13:35:11.145]                             version <- ns[[".package"]][["version"]]
[13:35:11.145]                             if (is.null(version)) 
[13:35:11.145]                               version <- utils::packageVersion("future")
[13:35:11.145]                           }
[13:35:11.145]                           else {
[13:35:11.145]                             version <- NULL
[13:35:11.145]                           }
[13:35:11.145]                           if (!has_future || version < "1.8.0") {
[13:35:11.145]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:11.145]                               "", base::R.version$version.string), 
[13:35:11.145]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:11.145]                                 base::R.version$platform, 8 * 
[13:35:11.145]                                   base::.Machine$sizeof.pointer), 
[13:35:11.145]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:11.145]                                 "release", "version")], collapse = " "), 
[13:35:11.145]                               hostname = base::Sys.info()[["nodename"]])
[13:35:11.145]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:11.145]                               info)
[13:35:11.145]                             info <- base::paste(info, collapse = "; ")
[13:35:11.145]                             if (!has_future) {
[13:35:11.145]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:11.145]                                 info)
[13:35:11.145]                             }
[13:35:11.145]                             else {
[13:35:11.145]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:11.145]                                 info, version)
[13:35:11.145]                             }
[13:35:11.145]                             base::stop(msg)
[13:35:11.145]                           }
[13:35:11.145]                         })
[13:35:11.145]                       }
[13:35:11.145]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:11.145]                       base::options(mc.cores = 1L)
[13:35:11.145]                     }
[13:35:11.145]                     base::local({
[13:35:11.145]                       for (pkg in "future.apply") {
[13:35:11.145]                         base::loadNamespace(pkg)
[13:35:11.145]                         base::library(pkg, character.only = TRUE)
[13:35:11.145]                       }
[13:35:11.145]                     })
[13:35:11.145]                   }
[13:35:11.145]                   ...future.strategy.old <- future::plan("list")
[13:35:11.145]                   options(future.plan = NULL)
[13:35:11.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:11.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:11.145]                 }
[13:35:11.145]                 ...future.workdir <- getwd()
[13:35:11.145]             }
[13:35:11.145]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:11.145]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:11.145]         }
[13:35:11.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:11.145]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:11.145]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:11.145]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:11.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:11.145]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:11.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:11.145]             base::names(...future.oldOptions))
[13:35:11.145]     }
[13:35:11.145]     if (FALSE) {
[13:35:11.145]     }
[13:35:11.145]     else {
[13:35:11.145]         if (TRUE) {
[13:35:11.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:11.145]                 open = "w")
[13:35:11.145]         }
[13:35:11.145]         else {
[13:35:11.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:11.145]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:11.145]         }
[13:35:11.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:11.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:11.145]             base::sink(type = "output", split = FALSE)
[13:35:11.145]             base::close(...future.stdout)
[13:35:11.145]         }, add = TRUE)
[13:35:11.145]     }
[13:35:11.145]     ...future.frame <- base::sys.nframe()
[13:35:11.145]     ...future.conditions <- base::list()
[13:35:11.145]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:11.145]     if (FALSE) {
[13:35:11.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:11.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:11.145]     }
[13:35:11.145]     ...future.result <- base::tryCatch({
[13:35:11.145]         base::withCallingHandlers({
[13:35:11.145]             ...future.value <- base::withVisible(base::local({
[13:35:11.145]                 ...future.makeSendCondition <- base::local({
[13:35:11.145]                   sendCondition <- NULL
[13:35:11.145]                   function(frame = 1L) {
[13:35:11.145]                     if (is.function(sendCondition)) 
[13:35:11.145]                       return(sendCondition)
[13:35:11.145]                     ns <- getNamespace("parallel")
[13:35:11.145]                     if (exists("sendData", mode = "function", 
[13:35:11.145]                       envir = ns)) {
[13:35:11.145]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:11.145]                         envir = ns)
[13:35:11.145]                       envir <- sys.frame(frame)
[13:35:11.145]                       master <- NULL
[13:35:11.145]                       while (!identical(envir, .GlobalEnv) && 
[13:35:11.145]                         !identical(envir, emptyenv())) {
[13:35:11.145]                         if (exists("master", mode = "list", envir = envir, 
[13:35:11.145]                           inherits = FALSE)) {
[13:35:11.145]                           master <- get("master", mode = "list", 
[13:35:11.145]                             envir = envir, inherits = FALSE)
[13:35:11.145]                           if (inherits(master, c("SOCKnode", 
[13:35:11.145]                             "SOCK0node"))) {
[13:35:11.145]                             sendCondition <<- function(cond) {
[13:35:11.145]                               data <- list(type = "VALUE", value = cond, 
[13:35:11.145]                                 success = TRUE)
[13:35:11.145]                               parallel_sendData(master, data)
[13:35:11.145]                             }
[13:35:11.145]                             return(sendCondition)
[13:35:11.145]                           }
[13:35:11.145]                         }
[13:35:11.145]                         frame <- frame + 1L
[13:35:11.145]                         envir <- sys.frame(frame)
[13:35:11.145]                       }
[13:35:11.145]                     }
[13:35:11.145]                     sendCondition <<- function(cond) NULL
[13:35:11.145]                   }
[13:35:11.145]                 })
[13:35:11.145]                 withCallingHandlers({
[13:35:11.145]                   {
[13:35:11.145]                     do.call(function(...) {
[13:35:11.145]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.145]                       if (!identical(...future.globals.maxSize.org, 
[13:35:11.145]                         ...future.globals.maxSize)) {
[13:35:11.145]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.145]                         on.exit(options(oopts), add = TRUE)
[13:35:11.145]                       }
[13:35:11.145]                       {
[13:35:11.145]                         lapply(seq_along(...future.elements_ii), 
[13:35:11.145]                           FUN = function(jj) {
[13:35:11.145]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.145]                             ...future.FUN(...future.X_jj, ...)
[13:35:11.145]                           })
[13:35:11.145]                       }
[13:35:11.145]                     }, args = future.call.arguments)
[13:35:11.145]                   }
[13:35:11.145]                 }, immediateCondition = function(cond) {
[13:35:11.145]                   sendCondition <- ...future.makeSendCondition()
[13:35:11.145]                   sendCondition(cond)
[13:35:11.145]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.145]                   {
[13:35:11.145]                     inherits <- base::inherits
[13:35:11.145]                     invokeRestart <- base::invokeRestart
[13:35:11.145]                     is.null <- base::is.null
[13:35:11.145]                     muffled <- FALSE
[13:35:11.145]                     if (inherits(cond, "message")) {
[13:35:11.145]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:11.145]                       if (muffled) 
[13:35:11.145]                         invokeRestart("muffleMessage")
[13:35:11.145]                     }
[13:35:11.145]                     else if (inherits(cond, "warning")) {
[13:35:11.145]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:11.145]                       if (muffled) 
[13:35:11.145]                         invokeRestart("muffleWarning")
[13:35:11.145]                     }
[13:35:11.145]                     else if (inherits(cond, "condition")) {
[13:35:11.145]                       if (!is.null(pattern)) {
[13:35:11.145]                         computeRestarts <- base::computeRestarts
[13:35:11.145]                         grepl <- base::grepl
[13:35:11.145]                         restarts <- computeRestarts(cond)
[13:35:11.145]                         for (restart in restarts) {
[13:35:11.145]                           name <- restart$name
[13:35:11.145]                           if (is.null(name)) 
[13:35:11.145]                             next
[13:35:11.145]                           if (!grepl(pattern, name)) 
[13:35:11.145]                             next
[13:35:11.145]                           invokeRestart(restart)
[13:35:11.145]                           muffled <- TRUE
[13:35:11.145]                           break
[13:35:11.145]                         }
[13:35:11.145]                       }
[13:35:11.145]                     }
[13:35:11.145]                     invisible(muffled)
[13:35:11.145]                   }
[13:35:11.145]                   muffleCondition(cond)
[13:35:11.145]                 })
[13:35:11.145]             }))
[13:35:11.145]             future::FutureResult(value = ...future.value$value, 
[13:35:11.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:11.145]                   ...future.rng), globalenv = if (FALSE) 
[13:35:11.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:11.145]                     ...future.globalenv.names))
[13:35:11.145]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:11.145]         }, condition = base::local({
[13:35:11.145]             c <- base::c
[13:35:11.145]             inherits <- base::inherits
[13:35:11.145]             invokeRestart <- base::invokeRestart
[13:35:11.145]             length <- base::length
[13:35:11.145]             list <- base::list
[13:35:11.145]             seq.int <- base::seq.int
[13:35:11.145]             signalCondition <- base::signalCondition
[13:35:11.145]             sys.calls <- base::sys.calls
[13:35:11.145]             `[[` <- base::`[[`
[13:35:11.145]             `+` <- base::`+`
[13:35:11.145]             `<<-` <- base::`<<-`
[13:35:11.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:11.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:11.145]                   3L)]
[13:35:11.145]             }
[13:35:11.145]             function(cond) {
[13:35:11.145]                 is_error <- inherits(cond, "error")
[13:35:11.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:11.145]                   NULL)
[13:35:11.145]                 if (is_error) {
[13:35:11.145]                   sessionInformation <- function() {
[13:35:11.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:11.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:11.145]                       search = base::search(), system = base::Sys.info())
[13:35:11.145]                   }
[13:35:11.145]                   ...future.conditions[[length(...future.conditions) + 
[13:35:11.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:11.145]                     cond$call), session = sessionInformation(), 
[13:35:11.145]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:11.145]                   signalCondition(cond)
[13:35:11.145]                 }
[13:35:11.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:11.145]                 "immediateCondition"))) {
[13:35:11.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:11.145]                   ...future.conditions[[length(...future.conditions) + 
[13:35:11.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:11.145]                   if (TRUE && !signal) {
[13:35:11.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.145]                     {
[13:35:11.145]                       inherits <- base::inherits
[13:35:11.145]                       invokeRestart <- base::invokeRestart
[13:35:11.145]                       is.null <- base::is.null
[13:35:11.145]                       muffled <- FALSE
[13:35:11.145]                       if (inherits(cond, "message")) {
[13:35:11.145]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:11.145]                         if (muffled) 
[13:35:11.145]                           invokeRestart("muffleMessage")
[13:35:11.145]                       }
[13:35:11.145]                       else if (inherits(cond, "warning")) {
[13:35:11.145]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:11.145]                         if (muffled) 
[13:35:11.145]                           invokeRestart("muffleWarning")
[13:35:11.145]                       }
[13:35:11.145]                       else if (inherits(cond, "condition")) {
[13:35:11.145]                         if (!is.null(pattern)) {
[13:35:11.145]                           computeRestarts <- base::computeRestarts
[13:35:11.145]                           grepl <- base::grepl
[13:35:11.145]                           restarts <- computeRestarts(cond)
[13:35:11.145]                           for (restart in restarts) {
[13:35:11.145]                             name <- restart$name
[13:35:11.145]                             if (is.null(name)) 
[13:35:11.145]                               next
[13:35:11.145]                             if (!grepl(pattern, name)) 
[13:35:11.145]                               next
[13:35:11.145]                             invokeRestart(restart)
[13:35:11.145]                             muffled <- TRUE
[13:35:11.145]                             break
[13:35:11.145]                           }
[13:35:11.145]                         }
[13:35:11.145]                       }
[13:35:11.145]                       invisible(muffled)
[13:35:11.145]                     }
[13:35:11.145]                     muffleCondition(cond, pattern = "^muffle")
[13:35:11.145]                   }
[13:35:11.145]                 }
[13:35:11.145]                 else {
[13:35:11.145]                   if (TRUE) {
[13:35:11.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.145]                     {
[13:35:11.145]                       inherits <- base::inherits
[13:35:11.145]                       invokeRestart <- base::invokeRestart
[13:35:11.145]                       is.null <- base::is.null
[13:35:11.145]                       muffled <- FALSE
[13:35:11.145]                       if (inherits(cond, "message")) {
[13:35:11.145]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:11.145]                         if (muffled) 
[13:35:11.145]                           invokeRestart("muffleMessage")
[13:35:11.145]                       }
[13:35:11.145]                       else if (inherits(cond, "warning")) {
[13:35:11.145]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:11.145]                         if (muffled) 
[13:35:11.145]                           invokeRestart("muffleWarning")
[13:35:11.145]                       }
[13:35:11.145]                       else if (inherits(cond, "condition")) {
[13:35:11.145]                         if (!is.null(pattern)) {
[13:35:11.145]                           computeRestarts <- base::computeRestarts
[13:35:11.145]                           grepl <- base::grepl
[13:35:11.145]                           restarts <- computeRestarts(cond)
[13:35:11.145]                           for (restart in restarts) {
[13:35:11.145]                             name <- restart$name
[13:35:11.145]                             if (is.null(name)) 
[13:35:11.145]                               next
[13:35:11.145]                             if (!grepl(pattern, name)) 
[13:35:11.145]                               next
[13:35:11.145]                             invokeRestart(restart)
[13:35:11.145]                             muffled <- TRUE
[13:35:11.145]                             break
[13:35:11.145]                           }
[13:35:11.145]                         }
[13:35:11.145]                       }
[13:35:11.145]                       invisible(muffled)
[13:35:11.145]                     }
[13:35:11.145]                     muffleCondition(cond, pattern = "^muffle")
[13:35:11.145]                   }
[13:35:11.145]                 }
[13:35:11.145]             }
[13:35:11.145]         }))
[13:35:11.145]     }, error = function(ex) {
[13:35:11.145]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:11.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:11.145]                 ...future.rng), started = ...future.startTime, 
[13:35:11.145]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:11.145]             version = "1.8"), class = "FutureResult")
[13:35:11.145]     }, finally = {
[13:35:11.145]         if (!identical(...future.workdir, getwd())) 
[13:35:11.145]             setwd(...future.workdir)
[13:35:11.145]         {
[13:35:11.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:11.145]                 ...future.oldOptions$nwarnings <- NULL
[13:35:11.145]             }
[13:35:11.145]             base::options(...future.oldOptions)
[13:35:11.145]             if (.Platform$OS.type == "windows") {
[13:35:11.145]                 old_names <- names(...future.oldEnvVars)
[13:35:11.145]                 envs <- base::Sys.getenv()
[13:35:11.145]                 names <- names(envs)
[13:35:11.145]                 common <- intersect(names, old_names)
[13:35:11.145]                 added <- setdiff(names, old_names)
[13:35:11.145]                 removed <- setdiff(old_names, names)
[13:35:11.145]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:11.145]                   envs[common]]
[13:35:11.145]                 NAMES <- toupper(changed)
[13:35:11.145]                 args <- list()
[13:35:11.145]                 for (kk in seq_along(NAMES)) {
[13:35:11.145]                   name <- changed[[kk]]
[13:35:11.145]                   NAME <- NAMES[[kk]]
[13:35:11.145]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.145]                     next
[13:35:11.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:11.145]                 }
[13:35:11.145]                 NAMES <- toupper(added)
[13:35:11.145]                 for (kk in seq_along(NAMES)) {
[13:35:11.145]                   name <- added[[kk]]
[13:35:11.145]                   NAME <- NAMES[[kk]]
[13:35:11.145]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.145]                     next
[13:35:11.145]                   args[[name]] <- ""
[13:35:11.145]                 }
[13:35:11.145]                 NAMES <- toupper(removed)
[13:35:11.145]                 for (kk in seq_along(NAMES)) {
[13:35:11.145]                   name <- removed[[kk]]
[13:35:11.145]                   NAME <- NAMES[[kk]]
[13:35:11.145]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.145]                     next
[13:35:11.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:11.145]                 }
[13:35:11.145]                 if (length(args) > 0) 
[13:35:11.145]                   base::do.call(base::Sys.setenv, args = args)
[13:35:11.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:11.145]             }
[13:35:11.145]             else {
[13:35:11.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:11.145]             }
[13:35:11.145]             {
[13:35:11.145]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:11.145]                   0L) {
[13:35:11.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:11.145]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:11.145]                   base::options(opts)
[13:35:11.145]                 }
[13:35:11.145]                 {
[13:35:11.145]                   {
[13:35:11.145]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:11.145]                     NULL
[13:35:11.145]                   }
[13:35:11.145]                   options(future.plan = NULL)
[13:35:11.145]                   if (is.na(NA_character_)) 
[13:35:11.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:11.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:11.145]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:11.145]                     .init = FALSE)
[13:35:11.145]                 }
[13:35:11.145]             }
[13:35:11.145]         }
[13:35:11.145]     })
[13:35:11.145]     if (TRUE) {
[13:35:11.145]         base::sink(type = "output", split = FALSE)
[13:35:11.145]         if (TRUE) {
[13:35:11.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:11.145]         }
[13:35:11.145]         else {
[13:35:11.145]             ...future.result["stdout"] <- base::list(NULL)
[13:35:11.145]         }
[13:35:11.145]         base::close(...future.stdout)
[13:35:11.145]         ...future.stdout <- NULL
[13:35:11.145]     }
[13:35:11.145]     ...future.result$conditions <- ...future.conditions
[13:35:11.145]     ...future.result$finished <- base::Sys.time()
[13:35:11.145]     ...future.result
[13:35:11.145] }
[13:35:11.148] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[13:35:11.148] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:11.191] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:11.191] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[13:35:11.191] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[13:35:11.192] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:11.192] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:11.192] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:11.234] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:11.235] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:11.278] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:11.279] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:11.279] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.279] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:11.279] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:11.280] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:11.280] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.280] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:35:11.281] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:35:11.281] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:11.281] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.281] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:11.282] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.282] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[13:35:11.283] MultisessionFuture started
[13:35:11.283] - Launch lazy future ... done
[13:35:11.283] run() for ‘MultisessionFuture’ ... done
[13:35:11.283] Created future:
[13:35:11.283] MultisessionFuture:
[13:35:11.283] Label: ‘future_vapply-2’
[13:35:11.283] Expression:
[13:35:11.283] {
[13:35:11.283]     do.call(function(...) {
[13:35:11.283]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.283]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:11.283]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.283]             on.exit(options(oopts), add = TRUE)
[13:35:11.283]         }
[13:35:11.283]         {
[13:35:11.283]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:11.283]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.283]                 ...future.FUN(...future.X_jj, ...)
[13:35:11.283]             })
[13:35:11.283]         }
[13:35:11.283]     }, args = future.call.arguments)
[13:35:11.283] }
[13:35:11.283] Lazy evaluation: FALSE
[13:35:11.283] Asynchronous evaluation: TRUE
[13:35:11.283] Local evaluation: TRUE
[13:35:11.283] Environment: R_GlobalEnv
[13:35:11.283] Capture standard output: TRUE
[13:35:11.283] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:11.283] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:11.283] Packages: 1 packages (‘future.apply’)
[13:35:11.283] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:11.283] Resolved: FALSE
[13:35:11.283] Value: <not collected>
[13:35:11.283] Conditions captured: <none>
[13:35:11.283] Early signaling: FALSE
[13:35:11.283] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:11.283] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:11.295] Chunk #2 of 2 ... DONE
[13:35:11.295] Launching 2 futures (chunks) ... DONE
[13:35:11.295] Resolving 2 futures (chunks) ...
[13:35:11.295] resolve() on list ...
[13:35:11.295]  recursive: 0
[13:35:11.296]  length: 2
[13:35:11.296] 
[13:35:11.296] Future #1
[13:35:11.296] result() for ClusterFuture ...
[13:35:11.296] - result already collected: FutureResult
[13:35:11.296] result() for ClusterFuture ... done
[13:35:11.296] result() for ClusterFuture ...
[13:35:11.296] - result already collected: FutureResult
[13:35:11.296] result() for ClusterFuture ... done
[13:35:11.296] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:11.297] - nx: 2
[13:35:11.297] - relay: TRUE
[13:35:11.297] - stdout: TRUE
[13:35:11.297] - signal: TRUE
[13:35:11.297] - resignal: FALSE
[13:35:11.297] - force: TRUE
[13:35:11.297] - relayed: [n=2] FALSE, FALSE
[13:35:11.297] - queued futures: [n=2] FALSE, FALSE
[13:35:11.297]  - until=1
[13:35:11.297]  - relaying element #1
[13:35:11.297] result() for ClusterFuture ...
[13:35:11.297] - result already collected: FutureResult
[13:35:11.298] result() for ClusterFuture ... done
[13:35:11.298] result() for ClusterFuture ...
[13:35:11.298] - result already collected: FutureResult
[13:35:11.298] result() for ClusterFuture ... done
[13:35:11.298] result() for ClusterFuture ...
[13:35:11.298] - result already collected: FutureResult
[13:35:11.298] result() for ClusterFuture ... done
[13:35:11.298] result() for ClusterFuture ...
[13:35:11.298] - result already collected: FutureResult
[13:35:11.298] result() for ClusterFuture ... done
[13:35:11.299] - relayed: [n=2] TRUE, FALSE
[13:35:11.299] - queued futures: [n=2] TRUE, FALSE
[13:35:11.299] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:11.299]  length: 1 (resolved future 1)
[13:35:11.328] receiveMessageFromWorker() for ClusterFuture ...
[13:35:11.328] - Validating connection of MultisessionFuture
[13:35:11.328] - received message: FutureResult
[13:35:11.328] - Received FutureResult
[13:35:11.329] - Erased future from FutureRegistry
[13:35:11.329] result() for ClusterFuture ...
[13:35:11.329] - result already collected: FutureResult
[13:35:11.329] result() for ClusterFuture ... done
[13:35:11.329] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:11.329] Future #2
[13:35:11.329] result() for ClusterFuture ...
[13:35:11.329] - result already collected: FutureResult
[13:35:11.329] result() for ClusterFuture ... done
[13:35:11.329] result() for ClusterFuture ...
[13:35:11.329] - result already collected: FutureResult
[13:35:11.330] result() for ClusterFuture ... done
[13:35:11.330] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:11.330] - nx: 2
[13:35:11.330] - relay: TRUE
[13:35:11.330] - stdout: TRUE
[13:35:11.330] - signal: TRUE
[13:35:11.330] - resignal: FALSE
[13:35:11.330] - force: TRUE
[13:35:11.330] - relayed: [n=2] TRUE, FALSE
[13:35:11.330] - queued futures: [n=2] TRUE, FALSE
[13:35:11.331]  - until=2
[13:35:11.331]  - relaying element #2
[13:35:11.331] result() for ClusterFuture ...
[13:35:11.331] - result already collected: FutureResult
[13:35:11.331] result() for ClusterFuture ... done
[13:35:11.331] result() for ClusterFuture ...
[13:35:11.331] - result already collected: FutureResult
[13:35:11.331] result() for ClusterFuture ... done
[13:35:11.331] result() for ClusterFuture ...
[13:35:11.331] - result already collected: FutureResult
[13:35:11.331] result() for ClusterFuture ... done
[13:35:11.332] result() for ClusterFuture ...
[13:35:11.332] - result already collected: FutureResult
[13:35:11.332] result() for ClusterFuture ... done
[13:35:11.332] - relayed: [n=2] TRUE, TRUE
[13:35:11.332] - queued futures: [n=2] TRUE, TRUE
[13:35:11.332] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:11.332]  length: 0 (resolved future 2)
[13:35:11.332] Relaying remaining futures
[13:35:11.332] signalConditionsASAP(NULL, pos=0) ...
[13:35:11.332] - nx: 2
[13:35:11.332] - relay: TRUE
[13:35:11.332] - stdout: TRUE
[13:35:11.333] - signal: TRUE
[13:35:11.333] - resignal: FALSE
[13:35:11.333] - force: TRUE
[13:35:11.333] - relayed: [n=2] TRUE, TRUE
[13:35:11.333] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:11.333] - relayed: [n=2] TRUE, TRUE
[13:35:11.333] - queued futures: [n=2] TRUE, TRUE
[13:35:11.333] signalConditionsASAP(NULL, pos=0) ... done
[13:35:11.333] resolve() on list ... DONE
[13:35:11.333] result() for ClusterFuture ...
[13:35:11.333] - result already collected: FutureResult
[13:35:11.334] result() for ClusterFuture ... done
[13:35:11.334] result() for ClusterFuture ...
[13:35:11.334] - result already collected: FutureResult
[13:35:11.334] result() for ClusterFuture ... done
[13:35:11.334] result() for ClusterFuture ...
[13:35:11.334] - result already collected: FutureResult
[13:35:11.334] result() for ClusterFuture ... done
[13:35:11.334] result() for ClusterFuture ...
[13:35:11.334] - result already collected: FutureResult
[13:35:11.334] result() for ClusterFuture ... done
[13:35:11.334]  - Number of value chunks collected: 2
[13:35:11.335] Resolving 2 futures (chunks) ... DONE
[13:35:11.335] Reducing values from 2 chunks ...
[13:35:11.335]  - Number of values collected after concatenation: 10
[13:35:11.335]  - Number of values expected: 10
[13:35:11.335] Reducing values from 2 chunks ... DONE
[13:35:11.335] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:35:11.336] future_lapply() ...
[13:35:11.342] Number of chunks: 2
[13:35:11.342] getGlobalsAndPackagesXApply() ...
[13:35:11.342]  - future.globals: TRUE
[13:35:11.342] getGlobalsAndPackages() ...
[13:35:11.342] Searching for globals...
[13:35:11.346] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:35:11.346] Searching for globals ... DONE
[13:35:11.346] Resolving globals: FALSE
[13:35:11.347] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[13:35:11.347] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:11.348] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:11.348] - packages: [1] ‘future.apply’
[13:35:11.348] getGlobalsAndPackages() ... DONE
[13:35:11.348]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:11.348]  - needed namespaces: [n=1] ‘future.apply’
[13:35:11.348] Finding globals ... DONE
[13:35:11.348]  - use_args: TRUE
[13:35:11.348]  - Getting '...' globals ...
[13:35:11.349] resolve() on list ...
[13:35:11.349]  recursive: 0
[13:35:11.349]  length: 1
[13:35:11.349]  elements: ‘...’
[13:35:11.349]  length: 0 (resolved future 1)
[13:35:11.349] resolve() on list ... DONE
[13:35:11.349]    - '...' content: [n=0] 
[13:35:11.349] List of 1
[13:35:11.349]  $ ...: list()
[13:35:11.349]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:11.349]  - attr(*, "where")=List of 1
[13:35:11.349]   ..$ ...:<environment: 0x5574d16d1490> 
[13:35:11.349]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:11.349]  - attr(*, "resolved")= logi TRUE
[13:35:11.349]  - attr(*, "total_size")= num NA
[13:35:11.352]  - Getting '...' globals ... DONE
[13:35:11.352] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:11.352] List of 8
[13:35:11.352]  $ ...future.FUN:function (x, ...)  
[13:35:11.352]  $ x_FUN        :function (x)  
[13:35:11.352]  $ times        : int 4
[13:35:11.352]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:11.352]  $ stop_if_not  :function (...)  
[13:35:11.352]  $ dim          : int [1:2] 2 2
[13:35:11.352]  $ valid_types  : chr [1:2] "logical" "integer"
[13:35:11.352]  $ ...          : list()
[13:35:11.352]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:11.352]  - attr(*, "where")=List of 8
[13:35:11.352]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:11.352]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:11.352]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:11.352]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:11.352]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:11.352]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:11.352]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:11.352]   ..$ ...          :<environment: 0x5574d16d1490> 
[13:35:11.352]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:11.352]  - attr(*, "resolved")= logi FALSE
[13:35:11.352]  - attr(*, "total_size")= num 97232
[13:35:11.358] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:11.358] getGlobalsAndPackagesXApply() ... DONE
[13:35:11.358] Number of futures (= number of chunks): 2
[13:35:11.358] Launching 2 futures (chunks) ...
[13:35:11.358] Chunk #1 of 2 ...
[13:35:11.358]  - Finding globals in 'X' for chunk #1 ...
[13:35:11.358] getGlobalsAndPackages() ...
[13:35:11.358] Searching for globals...
[13:35:11.359] 
[13:35:11.359] Searching for globals ... DONE
[13:35:11.359] - globals: [0] <none>
[13:35:11.359] getGlobalsAndPackages() ... DONE
[13:35:11.359]    + additional globals found: [n=0] 
[13:35:11.359]    + additional namespaces needed: [n=0] 
[13:35:11.359]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:11.359]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:11.359]  - seeds: <none>
[13:35:11.359]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.360] getGlobalsAndPackages() ...
[13:35:11.360] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.360] Resolving globals: FALSE
[13:35:11.360] Tweak future expression to call with '...' arguments ...
[13:35:11.360] {
[13:35:11.360]     do.call(function(...) {
[13:35:11.360]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.360]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:11.360]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.360]             on.exit(options(oopts), add = TRUE)
[13:35:11.360]         }
[13:35:11.360]         {
[13:35:11.360]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:11.360]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.360]                 ...future.FUN(...future.X_jj, ...)
[13:35:11.360]             })
[13:35:11.360]         }
[13:35:11.360]     }, args = future.call.arguments)
[13:35:11.360] }
[13:35:11.360] Tweak future expression to call with '...' arguments ... DONE
[13:35:11.361] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.361] - packages: [1] ‘future.apply’
[13:35:11.361] getGlobalsAndPackages() ... DONE
[13:35:11.361] run() for ‘Future’ ...
[13:35:11.361] - state: ‘created’
[13:35:11.362] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:11.376] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:11.376] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:11.376]   - Field: ‘node’
[13:35:11.376]   - Field: ‘label’
[13:35:11.376]   - Field: ‘local’
[13:35:11.376]   - Field: ‘owner’
[13:35:11.376]   - Field: ‘envir’
[13:35:11.376]   - Field: ‘workers’
[13:35:11.376]   - Field: ‘packages’
[13:35:11.376]   - Field: ‘gc’
[13:35:11.377]   - Field: ‘conditions’
[13:35:11.377]   - Field: ‘persistent’
[13:35:11.377]   - Field: ‘expr’
[13:35:11.377]   - Field: ‘uuid’
[13:35:11.377]   - Field: ‘seed’
[13:35:11.377]   - Field: ‘version’
[13:35:11.377]   - Field: ‘result’
[13:35:11.377]   - Field: ‘asynchronous’
[13:35:11.377]   - Field: ‘calls’
[13:35:11.377]   - Field: ‘globals’
[13:35:11.377]   - Field: ‘stdout’
[13:35:11.378]   - Field: ‘earlySignal’
[13:35:11.378]   - Field: ‘lazy’
[13:35:11.378]   - Field: ‘state’
[13:35:11.378] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:11.378] - Launch lazy future ...
[13:35:11.378] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:11.378] Packages needed by future strategies (n = 0): <none>
[13:35:11.379] {
[13:35:11.379]     {
[13:35:11.379]         {
[13:35:11.379]             ...future.startTime <- base::Sys.time()
[13:35:11.379]             {
[13:35:11.379]                 {
[13:35:11.379]                   {
[13:35:11.379]                     {
[13:35:11.379]                       {
[13:35:11.379]                         base::local({
[13:35:11.379]                           has_future <- base::requireNamespace("future", 
[13:35:11.379]                             quietly = TRUE)
[13:35:11.379]                           if (has_future) {
[13:35:11.379]                             ns <- base::getNamespace("future")
[13:35:11.379]                             version <- ns[[".package"]][["version"]]
[13:35:11.379]                             if (is.null(version)) 
[13:35:11.379]                               version <- utils::packageVersion("future")
[13:35:11.379]                           }
[13:35:11.379]                           else {
[13:35:11.379]                             version <- NULL
[13:35:11.379]                           }
[13:35:11.379]                           if (!has_future || version < "1.8.0") {
[13:35:11.379]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:11.379]                               "", base::R.version$version.string), 
[13:35:11.379]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:11.379]                                 base::R.version$platform, 8 * 
[13:35:11.379]                                   base::.Machine$sizeof.pointer), 
[13:35:11.379]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:11.379]                                 "release", "version")], collapse = " "), 
[13:35:11.379]                               hostname = base::Sys.info()[["nodename"]])
[13:35:11.379]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:11.379]                               info)
[13:35:11.379]                             info <- base::paste(info, collapse = "; ")
[13:35:11.379]                             if (!has_future) {
[13:35:11.379]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:11.379]                                 info)
[13:35:11.379]                             }
[13:35:11.379]                             else {
[13:35:11.379]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:11.379]                                 info, version)
[13:35:11.379]                             }
[13:35:11.379]                             base::stop(msg)
[13:35:11.379]                           }
[13:35:11.379]                         })
[13:35:11.379]                       }
[13:35:11.379]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:11.379]                       base::options(mc.cores = 1L)
[13:35:11.379]                     }
[13:35:11.379]                     base::local({
[13:35:11.379]                       for (pkg in "future.apply") {
[13:35:11.379]                         base::loadNamespace(pkg)
[13:35:11.379]                         base::library(pkg, character.only = TRUE)
[13:35:11.379]                       }
[13:35:11.379]                     })
[13:35:11.379]                   }
[13:35:11.379]                   ...future.strategy.old <- future::plan("list")
[13:35:11.379]                   options(future.plan = NULL)
[13:35:11.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:11.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:11.379]                 }
[13:35:11.379]                 ...future.workdir <- getwd()
[13:35:11.379]             }
[13:35:11.379]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:11.379]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:11.379]         }
[13:35:11.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:11.379]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:11.379]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:11.379]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:11.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:11.379]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:11.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:11.379]             base::names(...future.oldOptions))
[13:35:11.379]     }
[13:35:11.379]     if (FALSE) {
[13:35:11.379]     }
[13:35:11.379]     else {
[13:35:11.379]         if (TRUE) {
[13:35:11.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:11.379]                 open = "w")
[13:35:11.379]         }
[13:35:11.379]         else {
[13:35:11.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:11.379]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:11.379]         }
[13:35:11.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:11.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:11.379]             base::sink(type = "output", split = FALSE)
[13:35:11.379]             base::close(...future.stdout)
[13:35:11.379]         }, add = TRUE)
[13:35:11.379]     }
[13:35:11.379]     ...future.frame <- base::sys.nframe()
[13:35:11.379]     ...future.conditions <- base::list()
[13:35:11.379]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:11.379]     if (FALSE) {
[13:35:11.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:11.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:11.379]     }
[13:35:11.379]     ...future.result <- base::tryCatch({
[13:35:11.379]         base::withCallingHandlers({
[13:35:11.379]             ...future.value <- base::withVisible(base::local({
[13:35:11.379]                 ...future.makeSendCondition <- base::local({
[13:35:11.379]                   sendCondition <- NULL
[13:35:11.379]                   function(frame = 1L) {
[13:35:11.379]                     if (is.function(sendCondition)) 
[13:35:11.379]                       return(sendCondition)
[13:35:11.379]                     ns <- getNamespace("parallel")
[13:35:11.379]                     if (exists("sendData", mode = "function", 
[13:35:11.379]                       envir = ns)) {
[13:35:11.379]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:11.379]                         envir = ns)
[13:35:11.379]                       envir <- sys.frame(frame)
[13:35:11.379]                       master <- NULL
[13:35:11.379]                       while (!identical(envir, .GlobalEnv) && 
[13:35:11.379]                         !identical(envir, emptyenv())) {
[13:35:11.379]                         if (exists("master", mode = "list", envir = envir, 
[13:35:11.379]                           inherits = FALSE)) {
[13:35:11.379]                           master <- get("master", mode = "list", 
[13:35:11.379]                             envir = envir, inherits = FALSE)
[13:35:11.379]                           if (inherits(master, c("SOCKnode", 
[13:35:11.379]                             "SOCK0node"))) {
[13:35:11.379]                             sendCondition <<- function(cond) {
[13:35:11.379]                               data <- list(type = "VALUE", value = cond, 
[13:35:11.379]                                 success = TRUE)
[13:35:11.379]                               parallel_sendData(master, data)
[13:35:11.379]                             }
[13:35:11.379]                             return(sendCondition)
[13:35:11.379]                           }
[13:35:11.379]                         }
[13:35:11.379]                         frame <- frame + 1L
[13:35:11.379]                         envir <- sys.frame(frame)
[13:35:11.379]                       }
[13:35:11.379]                     }
[13:35:11.379]                     sendCondition <<- function(cond) NULL
[13:35:11.379]                   }
[13:35:11.379]                 })
[13:35:11.379]                 withCallingHandlers({
[13:35:11.379]                   {
[13:35:11.379]                     do.call(function(...) {
[13:35:11.379]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.379]                       if (!identical(...future.globals.maxSize.org, 
[13:35:11.379]                         ...future.globals.maxSize)) {
[13:35:11.379]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.379]                         on.exit(options(oopts), add = TRUE)
[13:35:11.379]                       }
[13:35:11.379]                       {
[13:35:11.379]                         lapply(seq_along(...future.elements_ii), 
[13:35:11.379]                           FUN = function(jj) {
[13:35:11.379]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.379]                             ...future.FUN(...future.X_jj, ...)
[13:35:11.379]                           })
[13:35:11.379]                       }
[13:35:11.379]                     }, args = future.call.arguments)
[13:35:11.379]                   }
[13:35:11.379]                 }, immediateCondition = function(cond) {
[13:35:11.379]                   sendCondition <- ...future.makeSendCondition()
[13:35:11.379]                   sendCondition(cond)
[13:35:11.379]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.379]                   {
[13:35:11.379]                     inherits <- base::inherits
[13:35:11.379]                     invokeRestart <- base::invokeRestart
[13:35:11.379]                     is.null <- base::is.null
[13:35:11.379]                     muffled <- FALSE
[13:35:11.379]                     if (inherits(cond, "message")) {
[13:35:11.379]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:11.379]                       if (muffled) 
[13:35:11.379]                         invokeRestart("muffleMessage")
[13:35:11.379]                     }
[13:35:11.379]                     else if (inherits(cond, "warning")) {
[13:35:11.379]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:11.379]                       if (muffled) 
[13:35:11.379]                         invokeRestart("muffleWarning")
[13:35:11.379]                     }
[13:35:11.379]                     else if (inherits(cond, "condition")) {
[13:35:11.379]                       if (!is.null(pattern)) {
[13:35:11.379]                         computeRestarts <- base::computeRestarts
[13:35:11.379]                         grepl <- base::grepl
[13:35:11.379]                         restarts <- computeRestarts(cond)
[13:35:11.379]                         for (restart in restarts) {
[13:35:11.379]                           name <- restart$name
[13:35:11.379]                           if (is.null(name)) 
[13:35:11.379]                             next
[13:35:11.379]                           if (!grepl(pattern, name)) 
[13:35:11.379]                             next
[13:35:11.379]                           invokeRestart(restart)
[13:35:11.379]                           muffled <- TRUE
[13:35:11.379]                           break
[13:35:11.379]                         }
[13:35:11.379]                       }
[13:35:11.379]                     }
[13:35:11.379]                     invisible(muffled)
[13:35:11.379]                   }
[13:35:11.379]                   muffleCondition(cond)
[13:35:11.379]                 })
[13:35:11.379]             }))
[13:35:11.379]             future::FutureResult(value = ...future.value$value, 
[13:35:11.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:11.379]                   ...future.rng), globalenv = if (FALSE) 
[13:35:11.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:11.379]                     ...future.globalenv.names))
[13:35:11.379]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:11.379]         }, condition = base::local({
[13:35:11.379]             c <- base::c
[13:35:11.379]             inherits <- base::inherits
[13:35:11.379]             invokeRestart <- base::invokeRestart
[13:35:11.379]             length <- base::length
[13:35:11.379]             list <- base::list
[13:35:11.379]             seq.int <- base::seq.int
[13:35:11.379]             signalCondition <- base::signalCondition
[13:35:11.379]             sys.calls <- base::sys.calls
[13:35:11.379]             `[[` <- base::`[[`
[13:35:11.379]             `+` <- base::`+`
[13:35:11.379]             `<<-` <- base::`<<-`
[13:35:11.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:11.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:11.379]                   3L)]
[13:35:11.379]             }
[13:35:11.379]             function(cond) {
[13:35:11.379]                 is_error <- inherits(cond, "error")
[13:35:11.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:11.379]                   NULL)
[13:35:11.379]                 if (is_error) {
[13:35:11.379]                   sessionInformation <- function() {
[13:35:11.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:11.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:11.379]                       search = base::search(), system = base::Sys.info())
[13:35:11.379]                   }
[13:35:11.379]                   ...future.conditions[[length(...future.conditions) + 
[13:35:11.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:11.379]                     cond$call), session = sessionInformation(), 
[13:35:11.379]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:11.379]                   signalCondition(cond)
[13:35:11.379]                 }
[13:35:11.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:11.379]                 "immediateCondition"))) {
[13:35:11.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:11.379]                   ...future.conditions[[length(...future.conditions) + 
[13:35:11.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:11.379]                   if (TRUE && !signal) {
[13:35:11.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.379]                     {
[13:35:11.379]                       inherits <- base::inherits
[13:35:11.379]                       invokeRestart <- base::invokeRestart
[13:35:11.379]                       is.null <- base::is.null
[13:35:11.379]                       muffled <- FALSE
[13:35:11.379]                       if (inherits(cond, "message")) {
[13:35:11.379]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:11.379]                         if (muffled) 
[13:35:11.379]                           invokeRestart("muffleMessage")
[13:35:11.379]                       }
[13:35:11.379]                       else if (inherits(cond, "warning")) {
[13:35:11.379]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:11.379]                         if (muffled) 
[13:35:11.379]                           invokeRestart("muffleWarning")
[13:35:11.379]                       }
[13:35:11.379]                       else if (inherits(cond, "condition")) {
[13:35:11.379]                         if (!is.null(pattern)) {
[13:35:11.379]                           computeRestarts <- base::computeRestarts
[13:35:11.379]                           grepl <- base::grepl
[13:35:11.379]                           restarts <- computeRestarts(cond)
[13:35:11.379]                           for (restart in restarts) {
[13:35:11.379]                             name <- restart$name
[13:35:11.379]                             if (is.null(name)) 
[13:35:11.379]                               next
[13:35:11.379]                             if (!grepl(pattern, name)) 
[13:35:11.379]                               next
[13:35:11.379]                             invokeRestart(restart)
[13:35:11.379]                             muffled <- TRUE
[13:35:11.379]                             break
[13:35:11.379]                           }
[13:35:11.379]                         }
[13:35:11.379]                       }
[13:35:11.379]                       invisible(muffled)
[13:35:11.379]                     }
[13:35:11.379]                     muffleCondition(cond, pattern = "^muffle")
[13:35:11.379]                   }
[13:35:11.379]                 }
[13:35:11.379]                 else {
[13:35:11.379]                   if (TRUE) {
[13:35:11.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.379]                     {
[13:35:11.379]                       inherits <- base::inherits
[13:35:11.379]                       invokeRestart <- base::invokeRestart
[13:35:11.379]                       is.null <- base::is.null
[13:35:11.379]                       muffled <- FALSE
[13:35:11.379]                       if (inherits(cond, "message")) {
[13:35:11.379]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:11.379]                         if (muffled) 
[13:35:11.379]                           invokeRestart("muffleMessage")
[13:35:11.379]                       }
[13:35:11.379]                       else if (inherits(cond, "warning")) {
[13:35:11.379]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:11.379]                         if (muffled) 
[13:35:11.379]                           invokeRestart("muffleWarning")
[13:35:11.379]                       }
[13:35:11.379]                       else if (inherits(cond, "condition")) {
[13:35:11.379]                         if (!is.null(pattern)) {
[13:35:11.379]                           computeRestarts <- base::computeRestarts
[13:35:11.379]                           grepl <- base::grepl
[13:35:11.379]                           restarts <- computeRestarts(cond)
[13:35:11.379]                           for (restart in restarts) {
[13:35:11.379]                             name <- restart$name
[13:35:11.379]                             if (is.null(name)) 
[13:35:11.379]                               next
[13:35:11.379]                             if (!grepl(pattern, name)) 
[13:35:11.379]                               next
[13:35:11.379]                             invokeRestart(restart)
[13:35:11.379]                             muffled <- TRUE
[13:35:11.379]                             break
[13:35:11.379]                           }
[13:35:11.379]                         }
[13:35:11.379]                       }
[13:35:11.379]                       invisible(muffled)
[13:35:11.379]                     }
[13:35:11.379]                     muffleCondition(cond, pattern = "^muffle")
[13:35:11.379]                   }
[13:35:11.379]                 }
[13:35:11.379]             }
[13:35:11.379]         }))
[13:35:11.379]     }, error = function(ex) {
[13:35:11.379]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:11.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:11.379]                 ...future.rng), started = ...future.startTime, 
[13:35:11.379]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:11.379]             version = "1.8"), class = "FutureResult")
[13:35:11.379]     }, finally = {
[13:35:11.379]         if (!identical(...future.workdir, getwd())) 
[13:35:11.379]             setwd(...future.workdir)
[13:35:11.379]         {
[13:35:11.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:11.379]                 ...future.oldOptions$nwarnings <- NULL
[13:35:11.379]             }
[13:35:11.379]             base::options(...future.oldOptions)
[13:35:11.379]             if (.Platform$OS.type == "windows") {
[13:35:11.379]                 old_names <- names(...future.oldEnvVars)
[13:35:11.379]                 envs <- base::Sys.getenv()
[13:35:11.379]                 names <- names(envs)
[13:35:11.379]                 common <- intersect(names, old_names)
[13:35:11.379]                 added <- setdiff(names, old_names)
[13:35:11.379]                 removed <- setdiff(old_names, names)
[13:35:11.379]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:11.379]                   envs[common]]
[13:35:11.379]                 NAMES <- toupper(changed)
[13:35:11.379]                 args <- list()
[13:35:11.379]                 for (kk in seq_along(NAMES)) {
[13:35:11.379]                   name <- changed[[kk]]
[13:35:11.379]                   NAME <- NAMES[[kk]]
[13:35:11.379]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.379]                     next
[13:35:11.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:11.379]                 }
[13:35:11.379]                 NAMES <- toupper(added)
[13:35:11.379]                 for (kk in seq_along(NAMES)) {
[13:35:11.379]                   name <- added[[kk]]
[13:35:11.379]                   NAME <- NAMES[[kk]]
[13:35:11.379]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.379]                     next
[13:35:11.379]                   args[[name]] <- ""
[13:35:11.379]                 }
[13:35:11.379]                 NAMES <- toupper(removed)
[13:35:11.379]                 for (kk in seq_along(NAMES)) {
[13:35:11.379]                   name <- removed[[kk]]
[13:35:11.379]                   NAME <- NAMES[[kk]]
[13:35:11.379]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.379]                     next
[13:35:11.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:11.379]                 }
[13:35:11.379]                 if (length(args) > 0) 
[13:35:11.379]                   base::do.call(base::Sys.setenv, args = args)
[13:35:11.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:11.379]             }
[13:35:11.379]             else {
[13:35:11.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:11.379]             }
[13:35:11.379]             {
[13:35:11.379]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:11.379]                   0L) {
[13:35:11.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:11.379]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:11.379]                   base::options(opts)
[13:35:11.379]                 }
[13:35:11.379]                 {
[13:35:11.379]                   {
[13:35:11.379]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:11.379]                     NULL
[13:35:11.379]                   }
[13:35:11.379]                   options(future.plan = NULL)
[13:35:11.379]                   if (is.na(NA_character_)) 
[13:35:11.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:11.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:11.379]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:11.379]                     .init = FALSE)
[13:35:11.379]                 }
[13:35:11.379]             }
[13:35:11.379]         }
[13:35:11.379]     })
[13:35:11.379]     if (TRUE) {
[13:35:11.379]         base::sink(type = "output", split = FALSE)
[13:35:11.379]         if (TRUE) {
[13:35:11.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:11.379]         }
[13:35:11.379]         else {
[13:35:11.379]             ...future.result["stdout"] <- base::list(NULL)
[13:35:11.379]         }
[13:35:11.379]         base::close(...future.stdout)
[13:35:11.379]         ...future.stdout <- NULL
[13:35:11.379]     }
[13:35:11.379]     ...future.result$conditions <- ...future.conditions
[13:35:11.379]     ...future.result$finished <- base::Sys.time()
[13:35:11.379]     ...future.result
[13:35:11.379] }
[13:35:11.382] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[13:35:11.382] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:11.422] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:11.423] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[13:35:11.423] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[13:35:11.423] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:11.424] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:11.424] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:11.470] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:11.471] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:11.514] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:11.515] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:35:11.515] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:35:11.515] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[13:35:11.516] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[13:35:11.516] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:11.516] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.516] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:35:11.517] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:35:11.517] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:11.517] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.517] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:11.518] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.518] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[13:35:11.518] MultisessionFuture started
[13:35:11.519] - Launch lazy future ... done
[13:35:11.519] run() for ‘MultisessionFuture’ ... done
[13:35:11.519] Created future:
[13:35:11.519] MultisessionFuture:
[13:35:11.519] Label: ‘future_vapply-1’
[13:35:11.519] Expression:
[13:35:11.519] {
[13:35:11.519]     do.call(function(...) {
[13:35:11.519]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.519]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:11.519]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.519]             on.exit(options(oopts), add = TRUE)
[13:35:11.519]         }
[13:35:11.519]         {
[13:35:11.519]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:11.519]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.519]                 ...future.FUN(...future.X_jj, ...)
[13:35:11.519]             })
[13:35:11.519]         }
[13:35:11.519]     }, args = future.call.arguments)
[13:35:11.519] }
[13:35:11.519] Lazy evaluation: FALSE
[13:35:11.519] Asynchronous evaluation: TRUE
[13:35:11.519] Local evaluation: TRUE
[13:35:11.519] Environment: R_GlobalEnv
[13:35:11.519] Capture standard output: TRUE
[13:35:11.519] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:11.519] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:11.519] Packages: 1 packages (‘future.apply’)
[13:35:11.519] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:11.519] Resolved: FALSE
[13:35:11.519] Value: <not collected>
[13:35:11.519] Conditions captured: <none>
[13:35:11.519] Early signaling: FALSE
[13:35:11.519] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:11.519] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:11.531] Chunk #1 of 2 ... DONE
[13:35:11.531] Chunk #2 of 2 ...
[13:35:11.531]  - Finding globals in 'X' for chunk #2 ...
[13:35:11.531] getGlobalsAndPackages() ...
[13:35:11.531] Searching for globals...
[13:35:11.531] 
[13:35:11.532] Searching for globals ... DONE
[13:35:11.532] - globals: [0] <none>
[13:35:11.532] getGlobalsAndPackages() ... DONE
[13:35:11.532]    + additional globals found: [n=0] 
[13:35:11.532]    + additional namespaces needed: [n=0] 
[13:35:11.532]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:11.532]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:11.532]  - seeds: <none>
[13:35:11.532]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.532] getGlobalsAndPackages() ...
[13:35:11.532] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.533] Resolving globals: FALSE
[13:35:11.533] Tweak future expression to call with '...' arguments ...
[13:35:11.533] {
[13:35:11.533]     do.call(function(...) {
[13:35:11.533]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.533]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:11.533]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.533]             on.exit(options(oopts), add = TRUE)
[13:35:11.533]         }
[13:35:11.533]         {
[13:35:11.533]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:11.533]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.533]                 ...future.FUN(...future.X_jj, ...)
[13:35:11.533]             })
[13:35:11.533]         }
[13:35:11.533]     }, args = future.call.arguments)
[13:35:11.533] }
[13:35:11.533] Tweak future expression to call with '...' arguments ... DONE
[13:35:11.534] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.534] - packages: [1] ‘future.apply’
[13:35:11.534] getGlobalsAndPackages() ... DONE
[13:35:11.534] run() for ‘Future’ ...
[13:35:11.534] - state: ‘created’
[13:35:11.534] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:11.548] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:11.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:11.548]   - Field: ‘node’
[13:35:11.548]   - Field: ‘label’
[13:35:11.548]   - Field: ‘local’
[13:35:11.548]   - Field: ‘owner’
[13:35:11.548]   - Field: ‘envir’
[13:35:11.548]   - Field: ‘workers’
[13:35:11.549]   - Field: ‘packages’
[13:35:11.549]   - Field: ‘gc’
[13:35:11.549]   - Field: ‘conditions’
[13:35:11.549]   - Field: ‘persistent’
[13:35:11.549]   - Field: ‘expr’
[13:35:11.549]   - Field: ‘uuid’
[13:35:11.549]   - Field: ‘seed’
[13:35:11.549]   - Field: ‘version’
[13:35:11.549]   - Field: ‘result’
[13:35:11.549]   - Field: ‘asynchronous’
[13:35:11.549]   - Field: ‘calls’
[13:35:11.550]   - Field: ‘globals’
[13:35:11.550]   - Field: ‘stdout’
[13:35:11.550]   - Field: ‘earlySignal’
[13:35:11.550]   - Field: ‘lazy’
[13:35:11.550]   - Field: ‘state’
[13:35:11.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:11.550] - Launch lazy future ...
[13:35:11.550] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:11.551] Packages needed by future strategies (n = 0): <none>
[13:35:11.551] {
[13:35:11.551]     {
[13:35:11.551]         {
[13:35:11.551]             ...future.startTime <- base::Sys.time()
[13:35:11.551]             {
[13:35:11.551]                 {
[13:35:11.551]                   {
[13:35:11.551]                     {
[13:35:11.551]                       {
[13:35:11.551]                         base::local({
[13:35:11.551]                           has_future <- base::requireNamespace("future", 
[13:35:11.551]                             quietly = TRUE)
[13:35:11.551]                           if (has_future) {
[13:35:11.551]                             ns <- base::getNamespace("future")
[13:35:11.551]                             version <- ns[[".package"]][["version"]]
[13:35:11.551]                             if (is.null(version)) 
[13:35:11.551]                               version <- utils::packageVersion("future")
[13:35:11.551]                           }
[13:35:11.551]                           else {
[13:35:11.551]                             version <- NULL
[13:35:11.551]                           }
[13:35:11.551]                           if (!has_future || version < "1.8.0") {
[13:35:11.551]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:11.551]                               "", base::R.version$version.string), 
[13:35:11.551]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:11.551]                                 base::R.version$platform, 8 * 
[13:35:11.551]                                   base::.Machine$sizeof.pointer), 
[13:35:11.551]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:11.551]                                 "release", "version")], collapse = " "), 
[13:35:11.551]                               hostname = base::Sys.info()[["nodename"]])
[13:35:11.551]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:11.551]                               info)
[13:35:11.551]                             info <- base::paste(info, collapse = "; ")
[13:35:11.551]                             if (!has_future) {
[13:35:11.551]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:11.551]                                 info)
[13:35:11.551]                             }
[13:35:11.551]                             else {
[13:35:11.551]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:11.551]                                 info, version)
[13:35:11.551]                             }
[13:35:11.551]                             base::stop(msg)
[13:35:11.551]                           }
[13:35:11.551]                         })
[13:35:11.551]                       }
[13:35:11.551]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:11.551]                       base::options(mc.cores = 1L)
[13:35:11.551]                     }
[13:35:11.551]                     base::local({
[13:35:11.551]                       for (pkg in "future.apply") {
[13:35:11.551]                         base::loadNamespace(pkg)
[13:35:11.551]                         base::library(pkg, character.only = TRUE)
[13:35:11.551]                       }
[13:35:11.551]                     })
[13:35:11.551]                   }
[13:35:11.551]                   ...future.strategy.old <- future::plan("list")
[13:35:11.551]                   options(future.plan = NULL)
[13:35:11.551]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:11.551]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:11.551]                 }
[13:35:11.551]                 ...future.workdir <- getwd()
[13:35:11.551]             }
[13:35:11.551]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:11.551]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:11.551]         }
[13:35:11.551]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:11.551]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:11.551]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:11.551]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:11.551]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:11.551]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:11.551]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:11.551]             base::names(...future.oldOptions))
[13:35:11.551]     }
[13:35:11.551]     if (FALSE) {
[13:35:11.551]     }
[13:35:11.551]     else {
[13:35:11.551]         if (TRUE) {
[13:35:11.551]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:11.551]                 open = "w")
[13:35:11.551]         }
[13:35:11.551]         else {
[13:35:11.551]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:11.551]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:11.551]         }
[13:35:11.551]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:11.551]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:11.551]             base::sink(type = "output", split = FALSE)
[13:35:11.551]             base::close(...future.stdout)
[13:35:11.551]         }, add = TRUE)
[13:35:11.551]     }
[13:35:11.551]     ...future.frame <- base::sys.nframe()
[13:35:11.551]     ...future.conditions <- base::list()
[13:35:11.551]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:11.551]     if (FALSE) {
[13:35:11.551]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:11.551]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:11.551]     }
[13:35:11.551]     ...future.result <- base::tryCatch({
[13:35:11.551]         base::withCallingHandlers({
[13:35:11.551]             ...future.value <- base::withVisible(base::local({
[13:35:11.551]                 ...future.makeSendCondition <- base::local({
[13:35:11.551]                   sendCondition <- NULL
[13:35:11.551]                   function(frame = 1L) {
[13:35:11.551]                     if (is.function(sendCondition)) 
[13:35:11.551]                       return(sendCondition)
[13:35:11.551]                     ns <- getNamespace("parallel")
[13:35:11.551]                     if (exists("sendData", mode = "function", 
[13:35:11.551]                       envir = ns)) {
[13:35:11.551]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:11.551]                         envir = ns)
[13:35:11.551]                       envir <- sys.frame(frame)
[13:35:11.551]                       master <- NULL
[13:35:11.551]                       while (!identical(envir, .GlobalEnv) && 
[13:35:11.551]                         !identical(envir, emptyenv())) {
[13:35:11.551]                         if (exists("master", mode = "list", envir = envir, 
[13:35:11.551]                           inherits = FALSE)) {
[13:35:11.551]                           master <- get("master", mode = "list", 
[13:35:11.551]                             envir = envir, inherits = FALSE)
[13:35:11.551]                           if (inherits(master, c("SOCKnode", 
[13:35:11.551]                             "SOCK0node"))) {
[13:35:11.551]                             sendCondition <<- function(cond) {
[13:35:11.551]                               data <- list(type = "VALUE", value = cond, 
[13:35:11.551]                                 success = TRUE)
[13:35:11.551]                               parallel_sendData(master, data)
[13:35:11.551]                             }
[13:35:11.551]                             return(sendCondition)
[13:35:11.551]                           }
[13:35:11.551]                         }
[13:35:11.551]                         frame <- frame + 1L
[13:35:11.551]                         envir <- sys.frame(frame)
[13:35:11.551]                       }
[13:35:11.551]                     }
[13:35:11.551]                     sendCondition <<- function(cond) NULL
[13:35:11.551]                   }
[13:35:11.551]                 })
[13:35:11.551]                 withCallingHandlers({
[13:35:11.551]                   {
[13:35:11.551]                     do.call(function(...) {
[13:35:11.551]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.551]                       if (!identical(...future.globals.maxSize.org, 
[13:35:11.551]                         ...future.globals.maxSize)) {
[13:35:11.551]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.551]                         on.exit(options(oopts), add = TRUE)
[13:35:11.551]                       }
[13:35:11.551]                       {
[13:35:11.551]                         lapply(seq_along(...future.elements_ii), 
[13:35:11.551]                           FUN = function(jj) {
[13:35:11.551]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.551]                             ...future.FUN(...future.X_jj, ...)
[13:35:11.551]                           })
[13:35:11.551]                       }
[13:35:11.551]                     }, args = future.call.arguments)
[13:35:11.551]                   }
[13:35:11.551]                 }, immediateCondition = function(cond) {
[13:35:11.551]                   sendCondition <- ...future.makeSendCondition()
[13:35:11.551]                   sendCondition(cond)
[13:35:11.551]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.551]                   {
[13:35:11.551]                     inherits <- base::inherits
[13:35:11.551]                     invokeRestart <- base::invokeRestart
[13:35:11.551]                     is.null <- base::is.null
[13:35:11.551]                     muffled <- FALSE
[13:35:11.551]                     if (inherits(cond, "message")) {
[13:35:11.551]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:11.551]                       if (muffled) 
[13:35:11.551]                         invokeRestart("muffleMessage")
[13:35:11.551]                     }
[13:35:11.551]                     else if (inherits(cond, "warning")) {
[13:35:11.551]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:11.551]                       if (muffled) 
[13:35:11.551]                         invokeRestart("muffleWarning")
[13:35:11.551]                     }
[13:35:11.551]                     else if (inherits(cond, "condition")) {
[13:35:11.551]                       if (!is.null(pattern)) {
[13:35:11.551]                         computeRestarts <- base::computeRestarts
[13:35:11.551]                         grepl <- base::grepl
[13:35:11.551]                         restarts <- computeRestarts(cond)
[13:35:11.551]                         for (restart in restarts) {
[13:35:11.551]                           name <- restart$name
[13:35:11.551]                           if (is.null(name)) 
[13:35:11.551]                             next
[13:35:11.551]                           if (!grepl(pattern, name)) 
[13:35:11.551]                             next
[13:35:11.551]                           invokeRestart(restart)
[13:35:11.551]                           muffled <- TRUE
[13:35:11.551]                           break
[13:35:11.551]                         }
[13:35:11.551]                       }
[13:35:11.551]                     }
[13:35:11.551]                     invisible(muffled)
[13:35:11.551]                   }
[13:35:11.551]                   muffleCondition(cond)
[13:35:11.551]                 })
[13:35:11.551]             }))
[13:35:11.551]             future::FutureResult(value = ...future.value$value, 
[13:35:11.551]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:11.551]                   ...future.rng), globalenv = if (FALSE) 
[13:35:11.551]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:11.551]                     ...future.globalenv.names))
[13:35:11.551]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:11.551]         }, condition = base::local({
[13:35:11.551]             c <- base::c
[13:35:11.551]             inherits <- base::inherits
[13:35:11.551]             invokeRestart <- base::invokeRestart
[13:35:11.551]             length <- base::length
[13:35:11.551]             list <- base::list
[13:35:11.551]             seq.int <- base::seq.int
[13:35:11.551]             signalCondition <- base::signalCondition
[13:35:11.551]             sys.calls <- base::sys.calls
[13:35:11.551]             `[[` <- base::`[[`
[13:35:11.551]             `+` <- base::`+`
[13:35:11.551]             `<<-` <- base::`<<-`
[13:35:11.551]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:11.551]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:11.551]                   3L)]
[13:35:11.551]             }
[13:35:11.551]             function(cond) {
[13:35:11.551]                 is_error <- inherits(cond, "error")
[13:35:11.551]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:11.551]                   NULL)
[13:35:11.551]                 if (is_error) {
[13:35:11.551]                   sessionInformation <- function() {
[13:35:11.551]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:11.551]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:11.551]                       search = base::search(), system = base::Sys.info())
[13:35:11.551]                   }
[13:35:11.551]                   ...future.conditions[[length(...future.conditions) + 
[13:35:11.551]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:11.551]                     cond$call), session = sessionInformation(), 
[13:35:11.551]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:11.551]                   signalCondition(cond)
[13:35:11.551]                 }
[13:35:11.551]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:11.551]                 "immediateCondition"))) {
[13:35:11.551]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:11.551]                   ...future.conditions[[length(...future.conditions) + 
[13:35:11.551]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:11.551]                   if (TRUE && !signal) {
[13:35:11.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.551]                     {
[13:35:11.551]                       inherits <- base::inherits
[13:35:11.551]                       invokeRestart <- base::invokeRestart
[13:35:11.551]                       is.null <- base::is.null
[13:35:11.551]                       muffled <- FALSE
[13:35:11.551]                       if (inherits(cond, "message")) {
[13:35:11.551]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:11.551]                         if (muffled) 
[13:35:11.551]                           invokeRestart("muffleMessage")
[13:35:11.551]                       }
[13:35:11.551]                       else if (inherits(cond, "warning")) {
[13:35:11.551]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:11.551]                         if (muffled) 
[13:35:11.551]                           invokeRestart("muffleWarning")
[13:35:11.551]                       }
[13:35:11.551]                       else if (inherits(cond, "condition")) {
[13:35:11.551]                         if (!is.null(pattern)) {
[13:35:11.551]                           computeRestarts <- base::computeRestarts
[13:35:11.551]                           grepl <- base::grepl
[13:35:11.551]                           restarts <- computeRestarts(cond)
[13:35:11.551]                           for (restart in restarts) {
[13:35:11.551]                             name <- restart$name
[13:35:11.551]                             if (is.null(name)) 
[13:35:11.551]                               next
[13:35:11.551]                             if (!grepl(pattern, name)) 
[13:35:11.551]                               next
[13:35:11.551]                             invokeRestart(restart)
[13:35:11.551]                             muffled <- TRUE
[13:35:11.551]                             break
[13:35:11.551]                           }
[13:35:11.551]                         }
[13:35:11.551]                       }
[13:35:11.551]                       invisible(muffled)
[13:35:11.551]                     }
[13:35:11.551]                     muffleCondition(cond, pattern = "^muffle")
[13:35:11.551]                   }
[13:35:11.551]                 }
[13:35:11.551]                 else {
[13:35:11.551]                   if (TRUE) {
[13:35:11.551]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.551]                     {
[13:35:11.551]                       inherits <- base::inherits
[13:35:11.551]                       invokeRestart <- base::invokeRestart
[13:35:11.551]                       is.null <- base::is.null
[13:35:11.551]                       muffled <- FALSE
[13:35:11.551]                       if (inherits(cond, "message")) {
[13:35:11.551]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:11.551]                         if (muffled) 
[13:35:11.551]                           invokeRestart("muffleMessage")
[13:35:11.551]                       }
[13:35:11.551]                       else if (inherits(cond, "warning")) {
[13:35:11.551]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:11.551]                         if (muffled) 
[13:35:11.551]                           invokeRestart("muffleWarning")
[13:35:11.551]                       }
[13:35:11.551]                       else if (inherits(cond, "condition")) {
[13:35:11.551]                         if (!is.null(pattern)) {
[13:35:11.551]                           computeRestarts <- base::computeRestarts
[13:35:11.551]                           grepl <- base::grepl
[13:35:11.551]                           restarts <- computeRestarts(cond)
[13:35:11.551]                           for (restart in restarts) {
[13:35:11.551]                             name <- restart$name
[13:35:11.551]                             if (is.null(name)) 
[13:35:11.551]                               next
[13:35:11.551]                             if (!grepl(pattern, name)) 
[13:35:11.551]                               next
[13:35:11.551]                             invokeRestart(restart)
[13:35:11.551]                             muffled <- TRUE
[13:35:11.551]                             break
[13:35:11.551]                           }
[13:35:11.551]                         }
[13:35:11.551]                       }
[13:35:11.551]                       invisible(muffled)
[13:35:11.551]                     }
[13:35:11.551]                     muffleCondition(cond, pattern = "^muffle")
[13:35:11.551]                   }
[13:35:11.551]                 }
[13:35:11.551]             }
[13:35:11.551]         }))
[13:35:11.551]     }, error = function(ex) {
[13:35:11.551]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:11.551]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:11.551]                 ...future.rng), started = ...future.startTime, 
[13:35:11.551]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:11.551]             version = "1.8"), class = "FutureResult")
[13:35:11.551]     }, finally = {
[13:35:11.551]         if (!identical(...future.workdir, getwd())) 
[13:35:11.551]             setwd(...future.workdir)
[13:35:11.551]         {
[13:35:11.551]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:11.551]                 ...future.oldOptions$nwarnings <- NULL
[13:35:11.551]             }
[13:35:11.551]             base::options(...future.oldOptions)
[13:35:11.551]             if (.Platform$OS.type == "windows") {
[13:35:11.551]                 old_names <- names(...future.oldEnvVars)
[13:35:11.551]                 envs <- base::Sys.getenv()
[13:35:11.551]                 names <- names(envs)
[13:35:11.551]                 common <- intersect(names, old_names)
[13:35:11.551]                 added <- setdiff(names, old_names)
[13:35:11.551]                 removed <- setdiff(old_names, names)
[13:35:11.551]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:11.551]                   envs[common]]
[13:35:11.551]                 NAMES <- toupper(changed)
[13:35:11.551]                 args <- list()
[13:35:11.551]                 for (kk in seq_along(NAMES)) {
[13:35:11.551]                   name <- changed[[kk]]
[13:35:11.551]                   NAME <- NAMES[[kk]]
[13:35:11.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.551]                     next
[13:35:11.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:11.551]                 }
[13:35:11.551]                 NAMES <- toupper(added)
[13:35:11.551]                 for (kk in seq_along(NAMES)) {
[13:35:11.551]                   name <- added[[kk]]
[13:35:11.551]                   NAME <- NAMES[[kk]]
[13:35:11.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.551]                     next
[13:35:11.551]                   args[[name]] <- ""
[13:35:11.551]                 }
[13:35:11.551]                 NAMES <- toupper(removed)
[13:35:11.551]                 for (kk in seq_along(NAMES)) {
[13:35:11.551]                   name <- removed[[kk]]
[13:35:11.551]                   NAME <- NAMES[[kk]]
[13:35:11.551]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.551]                     next
[13:35:11.551]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:11.551]                 }
[13:35:11.551]                 if (length(args) > 0) 
[13:35:11.551]                   base::do.call(base::Sys.setenv, args = args)
[13:35:11.551]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:11.551]             }
[13:35:11.551]             else {
[13:35:11.551]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:11.551]             }
[13:35:11.551]             {
[13:35:11.551]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:11.551]                   0L) {
[13:35:11.551]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:11.551]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:11.551]                   base::options(opts)
[13:35:11.551]                 }
[13:35:11.551]                 {
[13:35:11.551]                   {
[13:35:11.551]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:11.551]                     NULL
[13:35:11.551]                   }
[13:35:11.551]                   options(future.plan = NULL)
[13:35:11.551]                   if (is.na(NA_character_)) 
[13:35:11.551]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:11.551]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:11.551]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:11.551]                     .init = FALSE)
[13:35:11.551]                 }
[13:35:11.551]             }
[13:35:11.551]         }
[13:35:11.551]     })
[13:35:11.551]     if (TRUE) {
[13:35:11.551]         base::sink(type = "output", split = FALSE)
[13:35:11.551]         if (TRUE) {
[13:35:11.551]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:11.551]         }
[13:35:11.551]         else {
[13:35:11.551]             ...future.result["stdout"] <- base::list(NULL)
[13:35:11.551]         }
[13:35:11.551]         base::close(...future.stdout)
[13:35:11.551]         ...future.stdout <- NULL
[13:35:11.551]     }
[13:35:11.551]     ...future.result$conditions <- ...future.conditions
[13:35:11.551]     ...future.result$finished <- base::Sys.time()
[13:35:11.551]     ...future.result
[13:35:11.551] }
[13:35:11.554] Exporting 11 global objects (94.95 KiB) to cluster node #2 ...
[13:35:11.554] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:35:11.594] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:35:11.595] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[13:35:11.595] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[13:35:11.595] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:35:11.596] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:35:11.596] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:35:11.638] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:35:11.639] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:35:11.682] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:35:11.683] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[13:35:11.683] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[13:35:11.683] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[13:35:11.684] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[13:35:11.684] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:35:11.684] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:35:11.684] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:35:11.685] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:35:11.685] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:11.685] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:11.685] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:11.686] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:11.686] Exporting 11 global objects (94.95 KiB) to cluster node #2 ... DONE
[13:35:11.686] MultisessionFuture started
[13:35:11.686] - Launch lazy future ... done
[13:35:11.687] run() for ‘MultisessionFuture’ ... done
[13:35:11.687] Created future:
[13:35:11.688] receiveMessageFromWorker() for ClusterFuture ...
[13:35:11.688] - Validating connection of MultisessionFuture
[13:35:11.688] - received message: FutureResult
[13:35:11.689] - Received FutureResult
[13:35:11.689] - Erased future from FutureRegistry
[13:35:11.689] result() for ClusterFuture ...
[13:35:11.689] - result already collected: FutureResult
[13:35:11.689] result() for ClusterFuture ... done
[13:35:11.689] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:11.687] MultisessionFuture:
[13:35:11.687] Label: ‘future_vapply-2’
[13:35:11.687] Expression:
[13:35:11.687] {
[13:35:11.687]     do.call(function(...) {
[13:35:11.687]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.687]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:11.687]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.687]             on.exit(options(oopts), add = TRUE)
[13:35:11.687]         }
[13:35:11.687]         {
[13:35:11.687]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:11.687]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.687]                 ...future.FUN(...future.X_jj, ...)
[13:35:11.687]             })
[13:35:11.687]         }
[13:35:11.687]     }, args = future.call.arguments)
[13:35:11.687] }
[13:35:11.687] Lazy evaluation: FALSE
[13:35:11.687] Asynchronous evaluation: TRUE
[13:35:11.687] Local evaluation: TRUE
[13:35:11.687] Environment: R_GlobalEnv
[13:35:11.687] Capture standard output: TRUE
[13:35:11.687] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:11.687] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:11.687] Packages: 1 packages (‘future.apply’)
[13:35:11.687] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:11.687] Resolved: TRUE
[13:35:11.687] Value: <not collected>
[13:35:11.687] Conditions captured: <none>
[13:35:11.687] Early signaling: FALSE
[13:35:11.687] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:11.687] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:11.689] Chunk #2 of 2 ... DONE
[13:35:11.689] Launching 2 futures (chunks) ... DONE
[13:35:11.690] Resolving 2 futures (chunks) ...
[13:35:11.690] resolve() on list ...
[13:35:11.690]  recursive: 0
[13:35:11.690]  length: 2
[13:35:11.690] 
[13:35:11.690] receiveMessageFromWorker() for ClusterFuture ...
[13:35:11.691] - Validating connection of MultisessionFuture
[13:35:11.691] - received message: FutureResult
[13:35:11.691] - Received FutureResult
[13:35:11.691] - Erased future from FutureRegistry
[13:35:11.691] result() for ClusterFuture ...
[13:35:11.691] - result already collected: FutureResult
[13:35:11.691] result() for ClusterFuture ... done
[13:35:11.691] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:11.691] Future #1
[13:35:11.691] result() for ClusterFuture ...
[13:35:11.692] - result already collected: FutureResult
[13:35:11.692] result() for ClusterFuture ... done
[13:35:11.692] result() for ClusterFuture ...
[13:35:11.692] - result already collected: FutureResult
[13:35:11.692] result() for ClusterFuture ... done
[13:35:11.692] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:11.692] - nx: 2
[13:35:11.692] - relay: TRUE
[13:35:11.692] - stdout: TRUE
[13:35:11.692] - signal: TRUE
[13:35:11.692] - resignal: FALSE
[13:35:11.692] - force: TRUE
[13:35:11.693] - relayed: [n=2] FALSE, FALSE
[13:35:11.693] - queued futures: [n=2] FALSE, FALSE
[13:35:11.693]  - until=1
[13:35:11.693]  - relaying element #1
[13:35:11.693] result() for ClusterFuture ...
[13:35:11.695] - result already collected: FutureResult
[13:35:11.695] result() for ClusterFuture ... done
[13:35:11.695] result() for ClusterFuture ...
[13:35:11.695] - result already collected: FutureResult
[13:35:11.696] result() for ClusterFuture ... done
[13:35:11.696] result() for ClusterFuture ...
[13:35:11.696] - result already collected: FutureResult
[13:35:11.696] result() for ClusterFuture ... done
[13:35:11.696] result() for ClusterFuture ...
[13:35:11.696] - result already collected: FutureResult
[13:35:11.696] result() for ClusterFuture ... done
[13:35:11.696] - relayed: [n=2] TRUE, FALSE
[13:35:11.696] - queued futures: [n=2] TRUE, FALSE
[13:35:11.696] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:11.696]  length: 1 (resolved future 1)
[13:35:11.697] Future #2
[13:35:11.697] result() for ClusterFuture ...
[13:35:11.697] - result already collected: FutureResult
[13:35:11.697] result() for ClusterFuture ... done
[13:35:11.697] result() for ClusterFuture ...
[13:35:11.697] - result already collected: FutureResult
[13:35:11.697] result() for ClusterFuture ... done
[13:35:11.697] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:11.697] - nx: 2
[13:35:11.697] - relay: TRUE
[13:35:11.697] - stdout: TRUE
[13:35:11.698] - signal: TRUE
[13:35:11.698] - resignal: FALSE
[13:35:11.698] - force: TRUE
[13:35:11.698] - relayed: [n=2] TRUE, FALSE
[13:35:11.698] - queued futures: [n=2] TRUE, FALSE
[13:35:11.698]  - until=2
[13:35:11.698]  - relaying element #2
[13:35:11.698] result() for ClusterFuture ...
[13:35:11.698] - result already collected: FutureResult
[13:35:11.698] result() for ClusterFuture ... done
[13:35:11.698] result() for ClusterFuture ...
[13:35:11.698] - result already collected: FutureResult
[13:35:11.699] result() for ClusterFuture ... done
[13:35:11.699] result() for ClusterFuture ...
[13:35:11.699] - result already collected: FutureResult
[13:35:11.699] result() for ClusterFuture ... done
[13:35:11.699] result() for ClusterFuture ...
[13:35:11.699] - result already collected: FutureResult
[13:35:11.699] result() for ClusterFuture ... done
[13:35:11.699] - relayed: [n=2] TRUE, TRUE
[13:35:11.699] - queued futures: [n=2] TRUE, TRUE
[13:35:11.699] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:11.699]  length: 0 (resolved future 2)
[13:35:11.700] Relaying remaining futures
[13:35:11.700] signalConditionsASAP(NULL, pos=0) ...
[13:35:11.700] - nx: 2
[13:35:11.700] - relay: TRUE
[13:35:11.700] - stdout: TRUE
[13:35:11.700] - signal: TRUE
[13:35:11.700] - resignal: FALSE
[13:35:11.700] - force: TRUE
[13:35:11.700] - relayed: [n=2] TRUE, TRUE
[13:35:11.700] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:11.700] - relayed: [n=2] TRUE, TRUE
[13:35:11.700] - queued futures: [n=2] TRUE, TRUE
[13:35:11.701] signalConditionsASAP(NULL, pos=0) ... done
[13:35:11.701] resolve() on list ... DONE
[13:35:11.701] result() for ClusterFuture ...
[13:35:11.701] - result already collected: FutureResult
[13:35:11.701] result() for ClusterFuture ... done
[13:35:11.701] result() for ClusterFuture ...
[13:35:11.701] - result already collected: FutureResult
[13:35:11.701] result() for ClusterFuture ... done
[13:35:11.701] result() for ClusterFuture ...
[13:35:11.701] - result already collected: FutureResult
[13:35:11.701] result() for ClusterFuture ... done
[13:35:11.702] result() for ClusterFuture ...
[13:35:11.702] - result already collected: FutureResult
[13:35:11.702] result() for ClusterFuture ... done
[13:35:11.702]  - Number of value chunks collected: 2
[13:35:11.702] Resolving 2 futures (chunks) ... DONE
[13:35:11.702] Reducing values from 2 chunks ...
[13:35:11.702]  - Number of values collected after concatenation: 10
[13:35:11.702]  - Number of values expected: 10
[13:35:11.702] Reducing values from 2 chunks ... DONE
[13:35:11.702] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[13:35:11.703] future_lapply() ...
[13:35:11.709] Number of chunks: 2
[13:35:11.709] getGlobalsAndPackagesXApply() ...
[13:35:11.709]  - future.globals: TRUE
[13:35:11.709] getGlobalsAndPackages() ...
[13:35:11.709] Searching for globals...
[13:35:11.713] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[13:35:11.713] Searching for globals ... DONE
[13:35:11.713] Resolving globals: FALSE
[13:35:11.714] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[13:35:11.714] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:11.714] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:11.715] - packages: [1] ‘future.apply’
[13:35:11.715] getGlobalsAndPackages() ... DONE
[13:35:11.715]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:11.715]  - needed namespaces: [n=1] ‘future.apply’
[13:35:11.715] Finding globals ... DONE
[13:35:11.715]  - use_args: TRUE
[13:35:11.715]  - Getting '...' globals ...
[13:35:11.715] resolve() on list ...
[13:35:11.716]  recursive: 0
[13:35:11.716]  length: 1
[13:35:11.716]  elements: ‘...’
[13:35:11.716]  length: 0 (resolved future 1)
[13:35:11.716] resolve() on list ... DONE
[13:35:11.716]    - '...' content: [n=0] 
[13:35:11.716] List of 1
[13:35:11.716]  $ ...: list()
[13:35:11.716]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:11.716]  - attr(*, "where")=List of 1
[13:35:11.716]   ..$ ...:<environment: 0x5574d098fa80> 
[13:35:11.716]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:11.716]  - attr(*, "resolved")= logi TRUE
[13:35:11.716]  - attr(*, "total_size")= num NA
[13:35:11.719]  - Getting '...' globals ... DONE
[13:35:11.719] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:11.719] List of 8
[13:35:11.719]  $ ...future.FUN:function (x, ...)  
[13:35:11.719]  $ x_FUN        :function (x)  
[13:35:11.719]  $ times        : int 4
[13:35:11.719]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:11.719]  $ stop_if_not  :function (...)  
[13:35:11.719]  $ dim          : int [1:2] 2 2
[13:35:11.719]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:11.719]  $ ...          : list()
[13:35:11.719]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:11.719]  - attr(*, "where")=List of 8
[13:35:11.719]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:11.719]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:11.719]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:11.719]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:11.719]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:11.719]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:11.719]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:11.719]   ..$ ...          :<environment: 0x5574d098fa80> 
[13:35:11.719]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:11.719]  - attr(*, "resolved")= logi FALSE
[13:35:11.719]  - attr(*, "total_size")= num 97304
[13:35:11.724] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:11.724] getGlobalsAndPackagesXApply() ... DONE
[13:35:11.724] Number of futures (= number of chunks): 2
[13:35:11.725] Launching 2 futures (chunks) ...
[13:35:11.725] Chunk #1 of 2 ...
[13:35:11.725]  - Finding globals in 'X' for chunk #1 ...
[13:35:11.725] getGlobalsAndPackages() ...
[13:35:11.725] Searching for globals...
[13:35:11.725] 
[13:35:11.725] Searching for globals ... DONE
[13:35:11.725] - globals: [0] <none>
[13:35:11.725] getGlobalsAndPackages() ... DONE
[13:35:11.725]    + additional globals found: [n=0] 
[13:35:11.726]    + additional namespaces needed: [n=0] 
[13:35:11.726]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:11.726]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:11.726]  - seeds: <none>
[13:35:11.726]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.726] getGlobalsAndPackages() ...
[13:35:11.726] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.726] Resolving globals: FALSE
[13:35:11.726] Tweak future expression to call with '...' arguments ...
[13:35:11.727] {
[13:35:11.727]     do.call(function(...) {
[13:35:11.727]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.727]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:11.727]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.727]             on.exit(options(oopts), add = TRUE)
[13:35:11.727]         }
[13:35:11.727]         {
[13:35:11.727]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:11.727]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.727]                 ...future.FUN(...future.X_jj, ...)
[13:35:11.727]             })
[13:35:11.727]         }
[13:35:11.727]     }, args = future.call.arguments)
[13:35:11.727] }
[13:35:11.727] Tweak future expression to call with '...' arguments ... DONE
[13:35:11.727] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.727] - packages: [1] ‘future.apply’
[13:35:11.727] getGlobalsAndPackages() ... DONE
[13:35:11.728] run() for ‘Future’ ...
[13:35:11.728] - state: ‘created’
[13:35:11.728] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:11.742] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:11.742] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:11.742]   - Field: ‘node’
[13:35:11.742]   - Field: ‘label’
[13:35:11.742]   - Field: ‘local’
[13:35:11.742]   - Field: ‘owner’
[13:35:11.742]   - Field: ‘envir’
[13:35:11.743]   - Field: ‘workers’
[13:35:11.743]   - Field: ‘packages’
[13:35:11.743]   - Field: ‘gc’
[13:35:11.743]   - Field: ‘conditions’
[13:35:11.743]   - Field: ‘persistent’
[13:35:11.743]   - Field: ‘expr’
[13:35:11.743]   - Field: ‘uuid’
[13:35:11.743]   - Field: ‘seed’
[13:35:11.743]   - Field: ‘version’
[13:35:11.743]   - Field: ‘result’
[13:35:11.743]   - Field: ‘asynchronous’
[13:35:11.744]   - Field: ‘calls’
[13:35:11.744]   - Field: ‘globals’
[13:35:11.744]   - Field: ‘stdout’
[13:35:11.744]   - Field: ‘earlySignal’
[13:35:11.744]   - Field: ‘lazy’
[13:35:11.744]   - Field: ‘state’
[13:35:11.744] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:11.744] - Launch lazy future ...
[13:35:11.744] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:11.745] Packages needed by future strategies (n = 0): <none>
[13:35:11.745] {
[13:35:11.745]     {
[13:35:11.745]         {
[13:35:11.745]             ...future.startTime <- base::Sys.time()
[13:35:11.745]             {
[13:35:11.745]                 {
[13:35:11.745]                   {
[13:35:11.745]                     {
[13:35:11.745]                       {
[13:35:11.745]                         base::local({
[13:35:11.745]                           has_future <- base::requireNamespace("future", 
[13:35:11.745]                             quietly = TRUE)
[13:35:11.745]                           if (has_future) {
[13:35:11.745]                             ns <- base::getNamespace("future")
[13:35:11.745]                             version <- ns[[".package"]][["version"]]
[13:35:11.745]                             if (is.null(version)) 
[13:35:11.745]                               version <- utils::packageVersion("future")
[13:35:11.745]                           }
[13:35:11.745]                           else {
[13:35:11.745]                             version <- NULL
[13:35:11.745]                           }
[13:35:11.745]                           if (!has_future || version < "1.8.0") {
[13:35:11.745]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:11.745]                               "", base::R.version$version.string), 
[13:35:11.745]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:11.745]                                 base::R.version$platform, 8 * 
[13:35:11.745]                                   base::.Machine$sizeof.pointer), 
[13:35:11.745]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:11.745]                                 "release", "version")], collapse = " "), 
[13:35:11.745]                               hostname = base::Sys.info()[["nodename"]])
[13:35:11.745]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:11.745]                               info)
[13:35:11.745]                             info <- base::paste(info, collapse = "; ")
[13:35:11.745]                             if (!has_future) {
[13:35:11.745]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:11.745]                                 info)
[13:35:11.745]                             }
[13:35:11.745]                             else {
[13:35:11.745]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:11.745]                                 info, version)
[13:35:11.745]                             }
[13:35:11.745]                             base::stop(msg)
[13:35:11.745]                           }
[13:35:11.745]                         })
[13:35:11.745]                       }
[13:35:11.745]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:11.745]                       base::options(mc.cores = 1L)
[13:35:11.745]                     }
[13:35:11.745]                     base::local({
[13:35:11.745]                       for (pkg in "future.apply") {
[13:35:11.745]                         base::loadNamespace(pkg)
[13:35:11.745]                         base::library(pkg, character.only = TRUE)
[13:35:11.745]                       }
[13:35:11.745]                     })
[13:35:11.745]                   }
[13:35:11.745]                   ...future.strategy.old <- future::plan("list")
[13:35:11.745]                   options(future.plan = NULL)
[13:35:11.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:11.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:11.745]                 }
[13:35:11.745]                 ...future.workdir <- getwd()
[13:35:11.745]             }
[13:35:11.745]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:11.745]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:11.745]         }
[13:35:11.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:11.745]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:11.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:11.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:11.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:11.745]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:11.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:11.745]             base::names(...future.oldOptions))
[13:35:11.745]     }
[13:35:11.745]     if (FALSE) {
[13:35:11.745]     }
[13:35:11.745]     else {
[13:35:11.745]         if (TRUE) {
[13:35:11.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:11.745]                 open = "w")
[13:35:11.745]         }
[13:35:11.745]         else {
[13:35:11.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:11.745]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:11.745]         }
[13:35:11.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:11.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:11.745]             base::sink(type = "output", split = FALSE)
[13:35:11.745]             base::close(...future.stdout)
[13:35:11.745]         }, add = TRUE)
[13:35:11.745]     }
[13:35:11.745]     ...future.frame <- base::sys.nframe()
[13:35:11.745]     ...future.conditions <- base::list()
[13:35:11.745]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:11.745]     if (FALSE) {
[13:35:11.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:11.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:11.745]     }
[13:35:11.745]     ...future.result <- base::tryCatch({
[13:35:11.745]         base::withCallingHandlers({
[13:35:11.745]             ...future.value <- base::withVisible(base::local({
[13:35:11.745]                 ...future.makeSendCondition <- base::local({
[13:35:11.745]                   sendCondition <- NULL
[13:35:11.745]                   function(frame = 1L) {
[13:35:11.745]                     if (is.function(sendCondition)) 
[13:35:11.745]                       return(sendCondition)
[13:35:11.745]                     ns <- getNamespace("parallel")
[13:35:11.745]                     if (exists("sendData", mode = "function", 
[13:35:11.745]                       envir = ns)) {
[13:35:11.745]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:11.745]                         envir = ns)
[13:35:11.745]                       envir <- sys.frame(frame)
[13:35:11.745]                       master <- NULL
[13:35:11.745]                       while (!identical(envir, .GlobalEnv) && 
[13:35:11.745]                         !identical(envir, emptyenv())) {
[13:35:11.745]                         if (exists("master", mode = "list", envir = envir, 
[13:35:11.745]                           inherits = FALSE)) {
[13:35:11.745]                           master <- get("master", mode = "list", 
[13:35:11.745]                             envir = envir, inherits = FALSE)
[13:35:11.745]                           if (inherits(master, c("SOCKnode", 
[13:35:11.745]                             "SOCK0node"))) {
[13:35:11.745]                             sendCondition <<- function(cond) {
[13:35:11.745]                               data <- list(type = "VALUE", value = cond, 
[13:35:11.745]                                 success = TRUE)
[13:35:11.745]                               parallel_sendData(master, data)
[13:35:11.745]                             }
[13:35:11.745]                             return(sendCondition)
[13:35:11.745]                           }
[13:35:11.745]                         }
[13:35:11.745]                         frame <- frame + 1L
[13:35:11.745]                         envir <- sys.frame(frame)
[13:35:11.745]                       }
[13:35:11.745]                     }
[13:35:11.745]                     sendCondition <<- function(cond) NULL
[13:35:11.745]                   }
[13:35:11.745]                 })
[13:35:11.745]                 withCallingHandlers({
[13:35:11.745]                   {
[13:35:11.745]                     do.call(function(...) {
[13:35:11.745]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.745]                       if (!identical(...future.globals.maxSize.org, 
[13:35:11.745]                         ...future.globals.maxSize)) {
[13:35:11.745]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.745]                         on.exit(options(oopts), add = TRUE)
[13:35:11.745]                       }
[13:35:11.745]                       {
[13:35:11.745]                         lapply(seq_along(...future.elements_ii), 
[13:35:11.745]                           FUN = function(jj) {
[13:35:11.745]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.745]                             ...future.FUN(...future.X_jj, ...)
[13:35:11.745]                           })
[13:35:11.745]                       }
[13:35:11.745]                     }, args = future.call.arguments)
[13:35:11.745]                   }
[13:35:11.745]                 }, immediateCondition = function(cond) {
[13:35:11.745]                   sendCondition <- ...future.makeSendCondition()
[13:35:11.745]                   sendCondition(cond)
[13:35:11.745]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.745]                   {
[13:35:11.745]                     inherits <- base::inherits
[13:35:11.745]                     invokeRestart <- base::invokeRestart
[13:35:11.745]                     is.null <- base::is.null
[13:35:11.745]                     muffled <- FALSE
[13:35:11.745]                     if (inherits(cond, "message")) {
[13:35:11.745]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:11.745]                       if (muffled) 
[13:35:11.745]                         invokeRestart("muffleMessage")
[13:35:11.745]                     }
[13:35:11.745]                     else if (inherits(cond, "warning")) {
[13:35:11.745]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:11.745]                       if (muffled) 
[13:35:11.745]                         invokeRestart("muffleWarning")
[13:35:11.745]                     }
[13:35:11.745]                     else if (inherits(cond, "condition")) {
[13:35:11.745]                       if (!is.null(pattern)) {
[13:35:11.745]                         computeRestarts <- base::computeRestarts
[13:35:11.745]                         grepl <- base::grepl
[13:35:11.745]                         restarts <- computeRestarts(cond)
[13:35:11.745]                         for (restart in restarts) {
[13:35:11.745]                           name <- restart$name
[13:35:11.745]                           if (is.null(name)) 
[13:35:11.745]                             next
[13:35:11.745]                           if (!grepl(pattern, name)) 
[13:35:11.745]                             next
[13:35:11.745]                           invokeRestart(restart)
[13:35:11.745]                           muffled <- TRUE
[13:35:11.745]                           break
[13:35:11.745]                         }
[13:35:11.745]                       }
[13:35:11.745]                     }
[13:35:11.745]                     invisible(muffled)
[13:35:11.745]                   }
[13:35:11.745]                   muffleCondition(cond)
[13:35:11.745]                 })
[13:35:11.745]             }))
[13:35:11.745]             future::FutureResult(value = ...future.value$value, 
[13:35:11.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:11.745]                   ...future.rng), globalenv = if (FALSE) 
[13:35:11.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:11.745]                     ...future.globalenv.names))
[13:35:11.745]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:11.745]         }, condition = base::local({
[13:35:11.745]             c <- base::c
[13:35:11.745]             inherits <- base::inherits
[13:35:11.745]             invokeRestart <- base::invokeRestart
[13:35:11.745]             length <- base::length
[13:35:11.745]             list <- base::list
[13:35:11.745]             seq.int <- base::seq.int
[13:35:11.745]             signalCondition <- base::signalCondition
[13:35:11.745]             sys.calls <- base::sys.calls
[13:35:11.745]             `[[` <- base::`[[`
[13:35:11.745]             `+` <- base::`+`
[13:35:11.745]             `<<-` <- base::`<<-`
[13:35:11.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:11.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:11.745]                   3L)]
[13:35:11.745]             }
[13:35:11.745]             function(cond) {
[13:35:11.745]                 is_error <- inherits(cond, "error")
[13:35:11.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:11.745]                   NULL)
[13:35:11.745]                 if (is_error) {
[13:35:11.745]                   sessionInformation <- function() {
[13:35:11.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:11.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:11.745]                       search = base::search(), system = base::Sys.info())
[13:35:11.745]                   }
[13:35:11.745]                   ...future.conditions[[length(...future.conditions) + 
[13:35:11.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:11.745]                     cond$call), session = sessionInformation(), 
[13:35:11.745]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:11.745]                   signalCondition(cond)
[13:35:11.745]                 }
[13:35:11.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:11.745]                 "immediateCondition"))) {
[13:35:11.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:11.745]                   ...future.conditions[[length(...future.conditions) + 
[13:35:11.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:11.745]                   if (TRUE && !signal) {
[13:35:11.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.745]                     {
[13:35:11.745]                       inherits <- base::inherits
[13:35:11.745]                       invokeRestart <- base::invokeRestart
[13:35:11.745]                       is.null <- base::is.null
[13:35:11.745]                       muffled <- FALSE
[13:35:11.745]                       if (inherits(cond, "message")) {
[13:35:11.745]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:11.745]                         if (muffled) 
[13:35:11.745]                           invokeRestart("muffleMessage")
[13:35:11.745]                       }
[13:35:11.745]                       else if (inherits(cond, "warning")) {
[13:35:11.745]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:11.745]                         if (muffled) 
[13:35:11.745]                           invokeRestart("muffleWarning")
[13:35:11.745]                       }
[13:35:11.745]                       else if (inherits(cond, "condition")) {
[13:35:11.745]                         if (!is.null(pattern)) {
[13:35:11.745]                           computeRestarts <- base::computeRestarts
[13:35:11.745]                           grepl <- base::grepl
[13:35:11.745]                           restarts <- computeRestarts(cond)
[13:35:11.745]                           for (restart in restarts) {
[13:35:11.745]                             name <- restart$name
[13:35:11.745]                             if (is.null(name)) 
[13:35:11.745]                               next
[13:35:11.745]                             if (!grepl(pattern, name)) 
[13:35:11.745]                               next
[13:35:11.745]                             invokeRestart(restart)
[13:35:11.745]                             muffled <- TRUE
[13:35:11.745]                             break
[13:35:11.745]                           }
[13:35:11.745]                         }
[13:35:11.745]                       }
[13:35:11.745]                       invisible(muffled)
[13:35:11.745]                     }
[13:35:11.745]                     muffleCondition(cond, pattern = "^muffle")
[13:35:11.745]                   }
[13:35:11.745]                 }
[13:35:11.745]                 else {
[13:35:11.745]                   if (TRUE) {
[13:35:11.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.745]                     {
[13:35:11.745]                       inherits <- base::inherits
[13:35:11.745]                       invokeRestart <- base::invokeRestart
[13:35:11.745]                       is.null <- base::is.null
[13:35:11.745]                       muffled <- FALSE
[13:35:11.745]                       if (inherits(cond, "message")) {
[13:35:11.745]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:11.745]                         if (muffled) 
[13:35:11.745]                           invokeRestart("muffleMessage")
[13:35:11.745]                       }
[13:35:11.745]                       else if (inherits(cond, "warning")) {
[13:35:11.745]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:11.745]                         if (muffled) 
[13:35:11.745]                           invokeRestart("muffleWarning")
[13:35:11.745]                       }
[13:35:11.745]                       else if (inherits(cond, "condition")) {
[13:35:11.745]                         if (!is.null(pattern)) {
[13:35:11.745]                           computeRestarts <- base::computeRestarts
[13:35:11.745]                           grepl <- base::grepl
[13:35:11.745]                           restarts <- computeRestarts(cond)
[13:35:11.745]                           for (restart in restarts) {
[13:35:11.745]                             name <- restart$name
[13:35:11.745]                             if (is.null(name)) 
[13:35:11.745]                               next
[13:35:11.745]                             if (!grepl(pattern, name)) 
[13:35:11.745]                               next
[13:35:11.745]                             invokeRestart(restart)
[13:35:11.745]                             muffled <- TRUE
[13:35:11.745]                             break
[13:35:11.745]                           }
[13:35:11.745]                         }
[13:35:11.745]                       }
[13:35:11.745]                       invisible(muffled)
[13:35:11.745]                     }
[13:35:11.745]                     muffleCondition(cond, pattern = "^muffle")
[13:35:11.745]                   }
[13:35:11.745]                 }
[13:35:11.745]             }
[13:35:11.745]         }))
[13:35:11.745]     }, error = function(ex) {
[13:35:11.745]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:11.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:11.745]                 ...future.rng), started = ...future.startTime, 
[13:35:11.745]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:11.745]             version = "1.8"), class = "FutureResult")
[13:35:11.745]     }, finally = {
[13:35:11.745]         if (!identical(...future.workdir, getwd())) 
[13:35:11.745]             setwd(...future.workdir)
[13:35:11.745]         {
[13:35:11.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:11.745]                 ...future.oldOptions$nwarnings <- NULL
[13:35:11.745]             }
[13:35:11.745]             base::options(...future.oldOptions)
[13:35:11.745]             if (.Platform$OS.type == "windows") {
[13:35:11.745]                 old_names <- names(...future.oldEnvVars)
[13:35:11.745]                 envs <- base::Sys.getenv()
[13:35:11.745]                 names <- names(envs)
[13:35:11.745]                 common <- intersect(names, old_names)
[13:35:11.745]                 added <- setdiff(names, old_names)
[13:35:11.745]                 removed <- setdiff(old_names, names)
[13:35:11.745]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:11.745]                   envs[common]]
[13:35:11.745]                 NAMES <- toupper(changed)
[13:35:11.745]                 args <- list()
[13:35:11.745]                 for (kk in seq_along(NAMES)) {
[13:35:11.745]                   name <- changed[[kk]]
[13:35:11.745]                   NAME <- NAMES[[kk]]
[13:35:11.745]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.745]                     next
[13:35:11.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:11.745]                 }
[13:35:11.745]                 NAMES <- toupper(added)
[13:35:11.745]                 for (kk in seq_along(NAMES)) {
[13:35:11.745]                   name <- added[[kk]]
[13:35:11.745]                   NAME <- NAMES[[kk]]
[13:35:11.745]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.745]                     next
[13:35:11.745]                   args[[name]] <- ""
[13:35:11.745]                 }
[13:35:11.745]                 NAMES <- toupper(removed)
[13:35:11.745]                 for (kk in seq_along(NAMES)) {
[13:35:11.745]                   name <- removed[[kk]]
[13:35:11.745]                   NAME <- NAMES[[kk]]
[13:35:11.745]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.745]                     next
[13:35:11.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:11.745]                 }
[13:35:11.745]                 if (length(args) > 0) 
[13:35:11.745]                   base::do.call(base::Sys.setenv, args = args)
[13:35:11.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:11.745]             }
[13:35:11.745]             else {
[13:35:11.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:11.745]             }
[13:35:11.745]             {
[13:35:11.745]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:11.745]                   0L) {
[13:35:11.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:11.745]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:11.745]                   base::options(opts)
[13:35:11.745]                 }
[13:35:11.745]                 {
[13:35:11.745]                   {
[13:35:11.745]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:11.745]                     NULL
[13:35:11.745]                   }
[13:35:11.745]                   options(future.plan = NULL)
[13:35:11.745]                   if (is.na(NA_character_)) 
[13:35:11.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:11.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:11.745]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:11.745]                     .init = FALSE)
[13:35:11.745]                 }
[13:35:11.745]             }
[13:35:11.745]         }
[13:35:11.745]     })
[13:35:11.745]     if (TRUE) {
[13:35:11.745]         base::sink(type = "output", split = FALSE)
[13:35:11.745]         if (TRUE) {
[13:35:11.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:11.745]         }
[13:35:11.745]         else {
[13:35:11.745]             ...future.result["stdout"] <- base::list(NULL)
[13:35:11.745]         }
[13:35:11.745]         base::close(...future.stdout)
[13:35:11.745]         ...future.stdout <- NULL
[13:35:11.745]     }
[13:35:11.745]     ...future.result$conditions <- ...future.conditions
[13:35:11.745]     ...future.result$finished <- base::Sys.time()
[13:35:11.745]     ...future.result
[13:35:11.745] }
[13:35:11.748] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[13:35:11.748] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:11.790] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:11.791] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[13:35:11.791] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[13:35:11.791] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:11.792] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:11.792] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:11.834] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:11.835] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:11.878] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:11.879] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:35:11.879] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:35:11.879] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:11.880] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:11.880] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:11.880] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.880] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:35:11.881] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:35:11.881] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:11.881] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.882] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:11.882] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:11.882] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[13:35:11.883] MultisessionFuture started
[13:35:11.883] - Launch lazy future ... done
[13:35:11.883] run() for ‘MultisessionFuture’ ... done
[13:35:11.883] Created future:
[13:35:11.883] MultisessionFuture:
[13:35:11.883] Label: ‘future_vapply-1’
[13:35:11.883] Expression:
[13:35:11.883] {
[13:35:11.883]     do.call(function(...) {
[13:35:11.883]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.883]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:11.883]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.883]             on.exit(options(oopts), add = TRUE)
[13:35:11.883]         }
[13:35:11.883]         {
[13:35:11.883]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:11.883]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.883]                 ...future.FUN(...future.X_jj, ...)
[13:35:11.883]             })
[13:35:11.883]         }
[13:35:11.883]     }, args = future.call.arguments)
[13:35:11.883] }
[13:35:11.883] Lazy evaluation: FALSE
[13:35:11.883] Asynchronous evaluation: TRUE
[13:35:11.883] Local evaluation: TRUE
[13:35:11.883] Environment: R_GlobalEnv
[13:35:11.883] Capture standard output: TRUE
[13:35:11.883] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:11.883] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:11.883] Packages: 1 packages (‘future.apply’)
[13:35:11.883] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:11.883] Resolved: FALSE
[13:35:11.883] Value: <not collected>
[13:35:11.883] Conditions captured: <none>
[13:35:11.883] Early signaling: FALSE
[13:35:11.883] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:11.883] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:11.895] Chunk #1 of 2 ... DONE
[13:35:11.895] Chunk #2 of 2 ...
[13:35:11.895]  - Finding globals in 'X' for chunk #2 ...
[13:35:11.895] getGlobalsAndPackages() ...
[13:35:11.895] Searching for globals...
[13:35:11.895] 
[13:35:11.895] Searching for globals ... DONE
[13:35:11.896] - globals: [0] <none>
[13:35:11.896] getGlobalsAndPackages() ... DONE
[13:35:11.896]    + additional globals found: [n=0] 
[13:35:11.896]    + additional namespaces needed: [n=0] 
[13:35:11.896]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:11.896]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:11.896]  - seeds: <none>
[13:35:11.896]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.896] getGlobalsAndPackages() ...
[13:35:11.896] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.896] Resolving globals: FALSE
[13:35:11.897] Tweak future expression to call with '...' arguments ...
[13:35:11.897] {
[13:35:11.897]     do.call(function(...) {
[13:35:11.897]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.897]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:11.897]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.897]             on.exit(options(oopts), add = TRUE)
[13:35:11.897]         }
[13:35:11.897]         {
[13:35:11.897]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:11.897]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.897]                 ...future.FUN(...future.X_jj, ...)
[13:35:11.897]             })
[13:35:11.897]         }
[13:35:11.897]     }, args = future.call.arguments)
[13:35:11.897] }
[13:35:11.897] Tweak future expression to call with '...' arguments ... DONE
[13:35:11.897] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:11.897] - packages: [1] ‘future.apply’
[13:35:11.898] getGlobalsAndPackages() ... DONE
[13:35:11.898] run() for ‘Future’ ...
[13:35:11.898] - state: ‘created’
[13:35:11.898] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:11.912] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:11.912] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:11.912]   - Field: ‘node’
[13:35:11.912]   - Field: ‘label’
[13:35:11.912]   - Field: ‘local’
[13:35:11.912]   - Field: ‘owner’
[13:35:11.912]   - Field: ‘envir’
[13:35:11.912]   - Field: ‘workers’
[13:35:11.912]   - Field: ‘packages’
[13:35:11.912]   - Field: ‘gc’
[13:35:11.913]   - Field: ‘conditions’
[13:35:11.913]   - Field: ‘persistent’
[13:35:11.913]   - Field: ‘expr’
[13:35:11.913]   - Field: ‘uuid’
[13:35:11.913]   - Field: ‘seed’
[13:35:11.913]   - Field: ‘version’
[13:35:11.913]   - Field: ‘result’
[13:35:11.913]   - Field: ‘asynchronous’
[13:35:11.913]   - Field: ‘calls’
[13:35:11.913]   - Field: ‘globals’
[13:35:11.913]   - Field: ‘stdout’
[13:35:11.914]   - Field: ‘earlySignal’
[13:35:11.914]   - Field: ‘lazy’
[13:35:11.914]   - Field: ‘state’
[13:35:11.914] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:11.914] - Launch lazy future ...
[13:35:11.914] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:11.914] Packages needed by future strategies (n = 0): <none>
[13:35:11.915] {
[13:35:11.915]     {
[13:35:11.915]         {
[13:35:11.915]             ...future.startTime <- base::Sys.time()
[13:35:11.915]             {
[13:35:11.915]                 {
[13:35:11.915]                   {
[13:35:11.915]                     {
[13:35:11.915]                       {
[13:35:11.915]                         base::local({
[13:35:11.915]                           has_future <- base::requireNamespace("future", 
[13:35:11.915]                             quietly = TRUE)
[13:35:11.915]                           if (has_future) {
[13:35:11.915]                             ns <- base::getNamespace("future")
[13:35:11.915]                             version <- ns[[".package"]][["version"]]
[13:35:11.915]                             if (is.null(version)) 
[13:35:11.915]                               version <- utils::packageVersion("future")
[13:35:11.915]                           }
[13:35:11.915]                           else {
[13:35:11.915]                             version <- NULL
[13:35:11.915]                           }
[13:35:11.915]                           if (!has_future || version < "1.8.0") {
[13:35:11.915]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:11.915]                               "", base::R.version$version.string), 
[13:35:11.915]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:11.915]                                 base::R.version$platform, 8 * 
[13:35:11.915]                                   base::.Machine$sizeof.pointer), 
[13:35:11.915]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:11.915]                                 "release", "version")], collapse = " "), 
[13:35:11.915]                               hostname = base::Sys.info()[["nodename"]])
[13:35:11.915]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:11.915]                               info)
[13:35:11.915]                             info <- base::paste(info, collapse = "; ")
[13:35:11.915]                             if (!has_future) {
[13:35:11.915]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:11.915]                                 info)
[13:35:11.915]                             }
[13:35:11.915]                             else {
[13:35:11.915]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:11.915]                                 info, version)
[13:35:11.915]                             }
[13:35:11.915]                             base::stop(msg)
[13:35:11.915]                           }
[13:35:11.915]                         })
[13:35:11.915]                       }
[13:35:11.915]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:11.915]                       base::options(mc.cores = 1L)
[13:35:11.915]                     }
[13:35:11.915]                     base::local({
[13:35:11.915]                       for (pkg in "future.apply") {
[13:35:11.915]                         base::loadNamespace(pkg)
[13:35:11.915]                         base::library(pkg, character.only = TRUE)
[13:35:11.915]                       }
[13:35:11.915]                     })
[13:35:11.915]                   }
[13:35:11.915]                   ...future.strategy.old <- future::plan("list")
[13:35:11.915]                   options(future.plan = NULL)
[13:35:11.915]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:11.915]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:11.915]                 }
[13:35:11.915]                 ...future.workdir <- getwd()
[13:35:11.915]             }
[13:35:11.915]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:11.915]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:11.915]         }
[13:35:11.915]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:11.915]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:11.915]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:11.915]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:11.915]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:11.915]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:11.915]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:11.915]             base::names(...future.oldOptions))
[13:35:11.915]     }
[13:35:11.915]     if (FALSE) {
[13:35:11.915]     }
[13:35:11.915]     else {
[13:35:11.915]         if (TRUE) {
[13:35:11.915]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:11.915]                 open = "w")
[13:35:11.915]         }
[13:35:11.915]         else {
[13:35:11.915]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:11.915]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:11.915]         }
[13:35:11.915]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:11.915]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:11.915]             base::sink(type = "output", split = FALSE)
[13:35:11.915]             base::close(...future.stdout)
[13:35:11.915]         }, add = TRUE)
[13:35:11.915]     }
[13:35:11.915]     ...future.frame <- base::sys.nframe()
[13:35:11.915]     ...future.conditions <- base::list()
[13:35:11.915]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:11.915]     if (FALSE) {
[13:35:11.915]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:11.915]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:11.915]     }
[13:35:11.915]     ...future.result <- base::tryCatch({
[13:35:11.915]         base::withCallingHandlers({
[13:35:11.915]             ...future.value <- base::withVisible(base::local({
[13:35:11.915]                 ...future.makeSendCondition <- base::local({
[13:35:11.915]                   sendCondition <- NULL
[13:35:11.915]                   function(frame = 1L) {
[13:35:11.915]                     if (is.function(sendCondition)) 
[13:35:11.915]                       return(sendCondition)
[13:35:11.915]                     ns <- getNamespace("parallel")
[13:35:11.915]                     if (exists("sendData", mode = "function", 
[13:35:11.915]                       envir = ns)) {
[13:35:11.915]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:11.915]                         envir = ns)
[13:35:11.915]                       envir <- sys.frame(frame)
[13:35:11.915]                       master <- NULL
[13:35:11.915]                       while (!identical(envir, .GlobalEnv) && 
[13:35:11.915]                         !identical(envir, emptyenv())) {
[13:35:11.915]                         if (exists("master", mode = "list", envir = envir, 
[13:35:11.915]                           inherits = FALSE)) {
[13:35:11.915]                           master <- get("master", mode = "list", 
[13:35:11.915]                             envir = envir, inherits = FALSE)
[13:35:11.915]                           if (inherits(master, c("SOCKnode", 
[13:35:11.915]                             "SOCK0node"))) {
[13:35:11.915]                             sendCondition <<- function(cond) {
[13:35:11.915]                               data <- list(type = "VALUE", value = cond, 
[13:35:11.915]                                 success = TRUE)
[13:35:11.915]                               parallel_sendData(master, data)
[13:35:11.915]                             }
[13:35:11.915]                             return(sendCondition)
[13:35:11.915]                           }
[13:35:11.915]                         }
[13:35:11.915]                         frame <- frame + 1L
[13:35:11.915]                         envir <- sys.frame(frame)
[13:35:11.915]                       }
[13:35:11.915]                     }
[13:35:11.915]                     sendCondition <<- function(cond) NULL
[13:35:11.915]                   }
[13:35:11.915]                 })
[13:35:11.915]                 withCallingHandlers({
[13:35:11.915]                   {
[13:35:11.915]                     do.call(function(...) {
[13:35:11.915]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:11.915]                       if (!identical(...future.globals.maxSize.org, 
[13:35:11.915]                         ...future.globals.maxSize)) {
[13:35:11.915]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:11.915]                         on.exit(options(oopts), add = TRUE)
[13:35:11.915]                       }
[13:35:11.915]                       {
[13:35:11.915]                         lapply(seq_along(...future.elements_ii), 
[13:35:11.915]                           FUN = function(jj) {
[13:35:11.915]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:11.915]                             ...future.FUN(...future.X_jj, ...)
[13:35:11.915]                           })
[13:35:11.915]                       }
[13:35:11.915]                     }, args = future.call.arguments)
[13:35:11.915]                   }
[13:35:11.915]                 }, immediateCondition = function(cond) {
[13:35:11.915]                   sendCondition <- ...future.makeSendCondition()
[13:35:11.915]                   sendCondition(cond)
[13:35:11.915]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.915]                   {
[13:35:11.915]                     inherits <- base::inherits
[13:35:11.915]                     invokeRestart <- base::invokeRestart
[13:35:11.915]                     is.null <- base::is.null
[13:35:11.915]                     muffled <- FALSE
[13:35:11.915]                     if (inherits(cond, "message")) {
[13:35:11.915]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:11.915]                       if (muffled) 
[13:35:11.915]                         invokeRestart("muffleMessage")
[13:35:11.915]                     }
[13:35:11.915]                     else if (inherits(cond, "warning")) {
[13:35:11.915]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:11.915]                       if (muffled) 
[13:35:11.915]                         invokeRestart("muffleWarning")
[13:35:11.915]                     }
[13:35:11.915]                     else if (inherits(cond, "condition")) {
[13:35:11.915]                       if (!is.null(pattern)) {
[13:35:11.915]                         computeRestarts <- base::computeRestarts
[13:35:11.915]                         grepl <- base::grepl
[13:35:11.915]                         restarts <- computeRestarts(cond)
[13:35:11.915]                         for (restart in restarts) {
[13:35:11.915]                           name <- restart$name
[13:35:11.915]                           if (is.null(name)) 
[13:35:11.915]                             next
[13:35:11.915]                           if (!grepl(pattern, name)) 
[13:35:11.915]                             next
[13:35:11.915]                           invokeRestart(restart)
[13:35:11.915]                           muffled <- TRUE
[13:35:11.915]                           break
[13:35:11.915]                         }
[13:35:11.915]                       }
[13:35:11.915]                     }
[13:35:11.915]                     invisible(muffled)
[13:35:11.915]                   }
[13:35:11.915]                   muffleCondition(cond)
[13:35:11.915]                 })
[13:35:11.915]             }))
[13:35:11.915]             future::FutureResult(value = ...future.value$value, 
[13:35:11.915]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:11.915]                   ...future.rng), globalenv = if (FALSE) 
[13:35:11.915]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:11.915]                     ...future.globalenv.names))
[13:35:11.915]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:11.915]         }, condition = base::local({
[13:35:11.915]             c <- base::c
[13:35:11.915]             inherits <- base::inherits
[13:35:11.915]             invokeRestart <- base::invokeRestart
[13:35:11.915]             length <- base::length
[13:35:11.915]             list <- base::list
[13:35:11.915]             seq.int <- base::seq.int
[13:35:11.915]             signalCondition <- base::signalCondition
[13:35:11.915]             sys.calls <- base::sys.calls
[13:35:11.915]             `[[` <- base::`[[`
[13:35:11.915]             `+` <- base::`+`
[13:35:11.915]             `<<-` <- base::`<<-`
[13:35:11.915]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:11.915]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:11.915]                   3L)]
[13:35:11.915]             }
[13:35:11.915]             function(cond) {
[13:35:11.915]                 is_error <- inherits(cond, "error")
[13:35:11.915]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:11.915]                   NULL)
[13:35:11.915]                 if (is_error) {
[13:35:11.915]                   sessionInformation <- function() {
[13:35:11.915]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:11.915]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:11.915]                       search = base::search(), system = base::Sys.info())
[13:35:11.915]                   }
[13:35:11.915]                   ...future.conditions[[length(...future.conditions) + 
[13:35:11.915]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:11.915]                     cond$call), session = sessionInformation(), 
[13:35:11.915]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:11.915]                   signalCondition(cond)
[13:35:11.915]                 }
[13:35:11.915]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:11.915]                 "immediateCondition"))) {
[13:35:11.915]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:11.915]                   ...future.conditions[[length(...future.conditions) + 
[13:35:11.915]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:11.915]                   if (TRUE && !signal) {
[13:35:11.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.915]                     {
[13:35:11.915]                       inherits <- base::inherits
[13:35:11.915]                       invokeRestart <- base::invokeRestart
[13:35:11.915]                       is.null <- base::is.null
[13:35:11.915]                       muffled <- FALSE
[13:35:11.915]                       if (inherits(cond, "message")) {
[13:35:11.915]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:11.915]                         if (muffled) 
[13:35:11.915]                           invokeRestart("muffleMessage")
[13:35:11.915]                       }
[13:35:11.915]                       else if (inherits(cond, "warning")) {
[13:35:11.915]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:11.915]                         if (muffled) 
[13:35:11.915]                           invokeRestart("muffleWarning")
[13:35:11.915]                       }
[13:35:11.915]                       else if (inherits(cond, "condition")) {
[13:35:11.915]                         if (!is.null(pattern)) {
[13:35:11.915]                           computeRestarts <- base::computeRestarts
[13:35:11.915]                           grepl <- base::grepl
[13:35:11.915]                           restarts <- computeRestarts(cond)
[13:35:11.915]                           for (restart in restarts) {
[13:35:11.915]                             name <- restart$name
[13:35:11.915]                             if (is.null(name)) 
[13:35:11.915]                               next
[13:35:11.915]                             if (!grepl(pattern, name)) 
[13:35:11.915]                               next
[13:35:11.915]                             invokeRestart(restart)
[13:35:11.915]                             muffled <- TRUE
[13:35:11.915]                             break
[13:35:11.915]                           }
[13:35:11.915]                         }
[13:35:11.915]                       }
[13:35:11.915]                       invisible(muffled)
[13:35:11.915]                     }
[13:35:11.915]                     muffleCondition(cond, pattern = "^muffle")
[13:35:11.915]                   }
[13:35:11.915]                 }
[13:35:11.915]                 else {
[13:35:11.915]                   if (TRUE) {
[13:35:11.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:11.915]                     {
[13:35:11.915]                       inherits <- base::inherits
[13:35:11.915]                       invokeRestart <- base::invokeRestart
[13:35:11.915]                       is.null <- base::is.null
[13:35:11.915]                       muffled <- FALSE
[13:35:11.915]                       if (inherits(cond, "message")) {
[13:35:11.915]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:11.915]                         if (muffled) 
[13:35:11.915]                           invokeRestart("muffleMessage")
[13:35:11.915]                       }
[13:35:11.915]                       else if (inherits(cond, "warning")) {
[13:35:11.915]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:11.915]                         if (muffled) 
[13:35:11.915]                           invokeRestart("muffleWarning")
[13:35:11.915]                       }
[13:35:11.915]                       else if (inherits(cond, "condition")) {
[13:35:11.915]                         if (!is.null(pattern)) {
[13:35:11.915]                           computeRestarts <- base::computeRestarts
[13:35:11.915]                           grepl <- base::grepl
[13:35:11.915]                           restarts <- computeRestarts(cond)
[13:35:11.915]                           for (restart in restarts) {
[13:35:11.915]                             name <- restart$name
[13:35:11.915]                             if (is.null(name)) 
[13:35:11.915]                               next
[13:35:11.915]                             if (!grepl(pattern, name)) 
[13:35:11.915]                               next
[13:35:11.915]                             invokeRestart(restart)
[13:35:11.915]                             muffled <- TRUE
[13:35:11.915]                             break
[13:35:11.915]                           }
[13:35:11.915]                         }
[13:35:11.915]                       }
[13:35:11.915]                       invisible(muffled)
[13:35:11.915]                     }
[13:35:11.915]                     muffleCondition(cond, pattern = "^muffle")
[13:35:11.915]                   }
[13:35:11.915]                 }
[13:35:11.915]             }
[13:35:11.915]         }))
[13:35:11.915]     }, error = function(ex) {
[13:35:11.915]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:11.915]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:11.915]                 ...future.rng), started = ...future.startTime, 
[13:35:11.915]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:11.915]             version = "1.8"), class = "FutureResult")
[13:35:11.915]     }, finally = {
[13:35:11.915]         if (!identical(...future.workdir, getwd())) 
[13:35:11.915]             setwd(...future.workdir)
[13:35:11.915]         {
[13:35:11.915]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:11.915]                 ...future.oldOptions$nwarnings <- NULL
[13:35:11.915]             }
[13:35:11.915]             base::options(...future.oldOptions)
[13:35:11.915]             if (.Platform$OS.type == "windows") {
[13:35:11.915]                 old_names <- names(...future.oldEnvVars)
[13:35:11.915]                 envs <- base::Sys.getenv()
[13:35:11.915]                 names <- names(envs)
[13:35:11.915]                 common <- intersect(names, old_names)
[13:35:11.915]                 added <- setdiff(names, old_names)
[13:35:11.915]                 removed <- setdiff(old_names, names)
[13:35:11.915]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:11.915]                   envs[common]]
[13:35:11.915]                 NAMES <- toupper(changed)
[13:35:11.915]                 args <- list()
[13:35:11.915]                 for (kk in seq_along(NAMES)) {
[13:35:11.915]                   name <- changed[[kk]]
[13:35:11.915]                   NAME <- NAMES[[kk]]
[13:35:11.915]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.915]                     next
[13:35:11.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:11.915]                 }
[13:35:11.915]                 NAMES <- toupper(added)
[13:35:11.915]                 for (kk in seq_along(NAMES)) {
[13:35:11.915]                   name <- added[[kk]]
[13:35:11.915]                   NAME <- NAMES[[kk]]
[13:35:11.915]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.915]                     next
[13:35:11.915]                   args[[name]] <- ""
[13:35:11.915]                 }
[13:35:11.915]                 NAMES <- toupper(removed)
[13:35:11.915]                 for (kk in seq_along(NAMES)) {
[13:35:11.915]                   name <- removed[[kk]]
[13:35:11.915]                   NAME <- NAMES[[kk]]
[13:35:11.915]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:11.915]                     next
[13:35:11.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:11.915]                 }
[13:35:11.915]                 if (length(args) > 0) 
[13:35:11.915]                   base::do.call(base::Sys.setenv, args = args)
[13:35:11.915]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:11.915]             }
[13:35:11.915]             else {
[13:35:11.915]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:11.915]             }
[13:35:11.915]             {
[13:35:11.915]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:11.915]                   0L) {
[13:35:11.915]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:11.915]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:11.915]                   base::options(opts)
[13:35:11.915]                 }
[13:35:11.915]                 {
[13:35:11.915]                   {
[13:35:11.915]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:11.915]                     NULL
[13:35:11.915]                   }
[13:35:11.915]                   options(future.plan = NULL)
[13:35:11.915]                   if (is.na(NA_character_)) 
[13:35:11.915]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:11.915]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:11.915]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:11.915]                     .init = FALSE)
[13:35:11.915]                 }
[13:35:11.915]             }
[13:35:11.915]         }
[13:35:11.915]     })
[13:35:11.915]     if (TRUE) {
[13:35:11.915]         base::sink(type = "output", split = FALSE)
[13:35:11.915]         if (TRUE) {
[13:35:11.915]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:11.915]         }
[13:35:11.915]         else {
[13:35:11.915]             ...future.result["stdout"] <- base::list(NULL)
[13:35:11.915]         }
[13:35:11.915]         base::close(...future.stdout)
[13:35:11.915]         ...future.stdout <- NULL
[13:35:11.915]     }
[13:35:11.915]     ...future.result$conditions <- ...future.conditions
[13:35:11.915]     ...future.result$finished <- base::Sys.time()
[13:35:11.915]     ...future.result
[13:35:11.915] }
[13:35:11.918] Exporting 11 global objects (95.02 KiB) to cluster node #2 ...
[13:35:11.918] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:35:11.958] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:35:11.959] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[13:35:11.959] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[13:35:11.959] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:35:11.960] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:35:11.960] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:35:12.002] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:35:12.003] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:35:12.046] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:35:12.047] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[13:35:12.047] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[13:35:12.047] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:35:12.048] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:35:12.048] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:35:12.048] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:35:12.048] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[13:35:12.049] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[13:35:12.049] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:12.049] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:12.049] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:12.050] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:12.050] Exporting 11 global objects (95.02 KiB) to cluster node #2 ... DONE
[13:35:12.050] MultisessionFuture started
[13:35:12.050] - Launch lazy future ... done
[13:35:12.051] run() for ‘MultisessionFuture’ ... done
[13:35:12.051] Created future:
[13:35:12.052] receiveMessageFromWorker() for ClusterFuture ...
[13:35:12.052] - Validating connection of MultisessionFuture
[13:35:12.052] - received message: FutureResult
[13:35:12.053] - Received FutureResult
[13:35:12.053] - Erased future from FutureRegistry
[13:35:12.053] result() for ClusterFuture ...
[13:35:12.053] - result already collected: FutureResult
[13:35:12.053] result() for ClusterFuture ... done
[13:35:12.053] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:12.051] MultisessionFuture:
[13:35:12.051] Label: ‘future_vapply-2’
[13:35:12.051] Expression:
[13:35:12.051] {
[13:35:12.051]     do.call(function(...) {
[13:35:12.051]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.051]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.051]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.051]             on.exit(options(oopts), add = TRUE)
[13:35:12.051]         }
[13:35:12.051]         {
[13:35:12.051]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.051]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.051]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.051]             })
[13:35:12.051]         }
[13:35:12.051]     }, args = future.call.arguments)
[13:35:12.051] }
[13:35:12.051] Lazy evaluation: FALSE
[13:35:12.051] Asynchronous evaluation: TRUE
[13:35:12.051] Local evaluation: TRUE
[13:35:12.051] Environment: R_GlobalEnv
[13:35:12.051] Capture standard output: TRUE
[13:35:12.051] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:12.051] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:12.051] Packages: 1 packages (‘future.apply’)
[13:35:12.051] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:12.051] Resolved: TRUE
[13:35:12.051] Value: <not collected>
[13:35:12.051] Conditions captured: <none>
[13:35:12.051] Early signaling: FALSE
[13:35:12.051] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:12.051] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:12.053] Chunk #2 of 2 ... DONE
[13:35:12.053] Launching 2 futures (chunks) ... DONE
[13:35:12.054] Resolving 2 futures (chunks) ...
[13:35:12.054] resolve() on list ...
[13:35:12.054]  recursive: 0
[13:35:12.054]  length: 2
[13:35:12.054] 
[13:35:12.054] receiveMessageFromWorker() for ClusterFuture ...
[13:35:12.054] - Validating connection of MultisessionFuture
[13:35:12.055] - received message: FutureResult
[13:35:12.055] - Received FutureResult
[13:35:12.055] - Erased future from FutureRegistry
[13:35:12.055] result() for ClusterFuture ...
[13:35:12.055] - result already collected: FutureResult
[13:35:12.055] result() for ClusterFuture ... done
[13:35:12.055] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:12.055] Future #1
[13:35:12.055] result() for ClusterFuture ...
[13:35:12.055] - result already collected: FutureResult
[13:35:12.056] result() for ClusterFuture ... done
[13:35:12.056] result() for ClusterFuture ...
[13:35:12.056] - result already collected: FutureResult
[13:35:12.056] result() for ClusterFuture ... done
[13:35:12.056] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:12.056] - nx: 2
[13:35:12.056] - relay: TRUE
[13:35:12.056] - stdout: TRUE
[13:35:12.056] - signal: TRUE
[13:35:12.056] - resignal: FALSE
[13:35:12.056] - force: TRUE
[13:35:12.056] - relayed: [n=2] FALSE, FALSE
[13:35:12.057] - queued futures: [n=2] FALSE, FALSE
[13:35:12.057]  - until=1
[13:35:12.057]  - relaying element #1
[13:35:12.057] result() for ClusterFuture ...
[13:35:12.057] - result already collected: FutureResult
[13:35:12.057] result() for ClusterFuture ... done
[13:35:12.057] result() for ClusterFuture ...
[13:35:12.057] - result already collected: FutureResult
[13:35:12.057] result() for ClusterFuture ... done
[13:35:12.057] result() for ClusterFuture ...
[13:35:12.057] - result already collected: FutureResult
[13:35:12.058] result() for ClusterFuture ... done
[13:35:12.058] result() for ClusterFuture ...
[13:35:12.058] - result already collected: FutureResult
[13:35:12.058] result() for ClusterFuture ... done
[13:35:12.058] - relayed: [n=2] TRUE, FALSE
[13:35:12.058] - queued futures: [n=2] TRUE, FALSE
[13:35:12.058] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:12.058]  length: 1 (resolved future 1)
[13:35:12.058] Future #2
[13:35:12.058] result() for ClusterFuture ...
[13:35:12.059] - result already collected: FutureResult
[13:35:12.059] result() for ClusterFuture ... done
[13:35:12.059] result() for ClusterFuture ...
[13:35:12.059] - result already collected: FutureResult
[13:35:12.059] result() for ClusterFuture ... done
[13:35:12.059] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:12.059] - nx: 2
[13:35:12.059] - relay: TRUE
[13:35:12.059] - stdout: TRUE
[13:35:12.059] - signal: TRUE
[13:35:12.059] - resignal: FALSE
[13:35:12.059] - force: TRUE
[13:35:12.060] - relayed: [n=2] TRUE, FALSE
[13:35:12.060] - queued futures: [n=2] TRUE, FALSE
[13:35:12.060]  - until=2
[13:35:12.060]  - relaying element #2
[13:35:12.060] result() for ClusterFuture ...
[13:35:12.060] - result already collected: FutureResult
[13:35:12.060] result() for ClusterFuture ... done
[13:35:12.060] result() for ClusterFuture ...
[13:35:12.060] - result already collected: FutureResult
[13:35:12.060] result() for ClusterFuture ... done
[13:35:12.060] result() for ClusterFuture ...
[13:35:12.061] - result already collected: FutureResult
[13:35:12.061] result() for ClusterFuture ... done
[13:35:12.061] result() for ClusterFuture ...
[13:35:12.061] - result already collected: FutureResult
[13:35:12.061] result() for ClusterFuture ... done
[13:35:12.061] - relayed: [n=2] TRUE, TRUE
[13:35:12.061] - queued futures: [n=2] TRUE, TRUE
[13:35:12.061] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:12.061]  length: 0 (resolved future 2)
[13:35:12.061] Relaying remaining futures
[13:35:12.061] signalConditionsASAP(NULL, pos=0) ...
[13:35:12.061] - nx: 2
[13:35:12.062] - relay: TRUE
[13:35:12.062] - stdout: TRUE
[13:35:12.062] - signal: TRUE
[13:35:12.062] - resignal: FALSE
[13:35:12.062] - force: TRUE
[13:35:12.062] - relayed: [n=2] TRUE, TRUE
[13:35:12.062] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:12.062] - relayed: [n=2] TRUE, TRUE
[13:35:12.062] - queued futures: [n=2] TRUE, TRUE
[13:35:12.062] signalConditionsASAP(NULL, pos=0) ... done
[13:35:12.062] resolve() on list ... DONE
[13:35:12.063] result() for ClusterFuture ...
[13:35:12.063] - result already collected: FutureResult
[13:35:12.063] result() for ClusterFuture ... done
[13:35:12.063] result() for ClusterFuture ...
[13:35:12.063] - result already collected: FutureResult
[13:35:12.063] result() for ClusterFuture ... done
[13:35:12.063] result() for ClusterFuture ...
[13:35:12.063] - result already collected: FutureResult
[13:35:12.063] result() for ClusterFuture ... done
[13:35:12.063] result() for ClusterFuture ...
[13:35:12.063] - result already collected: FutureResult
[13:35:12.063] result() for ClusterFuture ... done
[13:35:12.064]  - Number of value chunks collected: 2
[13:35:12.064] Resolving 2 futures (chunks) ... DONE
[13:35:12.064] Reducing values from 2 chunks ...
[13:35:12.064]  - Number of values collected after concatenation: 10
[13:35:12.064]  - Number of values expected: 10
[13:35:12.064] Reducing values from 2 chunks ... DONE
[13:35:12.064] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[13:35:12.066] future_lapply() ...
[13:35:12.072] Number of chunks: 2
[13:35:12.072] getGlobalsAndPackagesXApply() ...
[13:35:12.072]  - future.globals: TRUE
[13:35:12.072] getGlobalsAndPackages() ...
[13:35:12.072] Searching for globals...
[13:35:12.078] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[13:35:12.078] Searching for globals ... DONE
[13:35:12.078] Resolving globals: FALSE
[13:35:12.079] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[13:35:12.079] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:12.079] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:12.080] - packages: [1] ‘future.apply’
[13:35:12.080] getGlobalsAndPackages() ... DONE
[13:35:12.080]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:12.080]  - needed namespaces: [n=1] ‘future.apply’
[13:35:12.080] Finding globals ... DONE
[13:35:12.080]  - use_args: TRUE
[13:35:12.080]  - Getting '...' globals ...
[13:35:12.080] resolve() on list ...
[13:35:12.080]  recursive: 0
[13:35:12.081]  length: 1
[13:35:12.081]  elements: ‘...’
[13:35:12.081]  length: 0 (resolved future 1)
[13:35:12.081] resolve() on list ... DONE
[13:35:12.081]    - '...' content: [n=0] 
[13:35:12.081] List of 1
[13:35:12.081]  $ ...: list()
[13:35:12.081]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:12.081]  - attr(*, "where")=List of 1
[13:35:12.081]   ..$ ...:<environment: 0x5574d349ba70> 
[13:35:12.081]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:12.081]  - attr(*, "resolved")= logi TRUE
[13:35:12.081]  - attr(*, "total_size")= num NA
[13:35:12.083]  - Getting '...' globals ... DONE
[13:35:12.084] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:12.084] List of 8
[13:35:12.084]  $ ...future.FUN:function (x, ...)  
[13:35:12.084]  $ x_FUN        :function (x)  
[13:35:12.084]  $ times        : int 4
[13:35:12.084]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:12.084]  $ stop_if_not  :function (...)  
[13:35:12.084]  $ dim          : int [1:2] 2 2
[13:35:12.084]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:12.084]  $ ...          : list()
[13:35:12.084]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:12.084]  - attr(*, "where")=List of 8
[13:35:12.084]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:12.084]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:12.084]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:12.084]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:12.084]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:12.084]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:12.084]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:12.084]   ..$ ...          :<environment: 0x5574d349ba70> 
[13:35:12.084]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:12.084]  - attr(*, "resolved")= logi FALSE
[13:35:12.084]  - attr(*, "total_size")= num 105552
[13:35:12.089] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:12.089] getGlobalsAndPackagesXApply() ... DONE
[13:35:12.089] Number of futures (= number of chunks): 2
[13:35:12.090] Launching 2 futures (chunks) ...
[13:35:12.090] Chunk #1 of 2 ...
[13:35:12.090]  - Finding globals in 'X' for chunk #1 ...
[13:35:12.090] getGlobalsAndPackages() ...
[13:35:12.090] Searching for globals...
[13:35:12.090] 
[13:35:12.090] Searching for globals ... DONE
[13:35:12.090] - globals: [0] <none>
[13:35:12.091] getGlobalsAndPackages() ... DONE
[13:35:12.091]    + additional globals found: [n=0] 
[13:35:12.091]    + additional namespaces needed: [n=0] 
[13:35:12.091]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:12.091]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:12.091]  - seeds: <none>
[13:35:12.091]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.091] getGlobalsAndPackages() ...
[13:35:12.091] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.091] Resolving globals: FALSE
[13:35:12.091] Tweak future expression to call with '...' arguments ...
[13:35:12.092] {
[13:35:12.092]     do.call(function(...) {
[13:35:12.092]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.092]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.092]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.092]             on.exit(options(oopts), add = TRUE)
[13:35:12.092]         }
[13:35:12.092]         {
[13:35:12.092]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.092]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.092]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.092]             })
[13:35:12.092]         }
[13:35:12.092]     }, args = future.call.arguments)
[13:35:12.092] }
[13:35:12.092] Tweak future expression to call with '...' arguments ... DONE
[13:35:12.092] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.093] - packages: [1] ‘future.apply’
[13:35:12.093] getGlobalsAndPackages() ... DONE
[13:35:12.093] run() for ‘Future’ ...
[13:35:12.093] - state: ‘created’
[13:35:12.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:12.107] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:12.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:12.107]   - Field: ‘node’
[13:35:12.107]   - Field: ‘label’
[13:35:12.107]   - Field: ‘local’
[13:35:12.107]   - Field: ‘owner’
[13:35:12.108]   - Field: ‘envir’
[13:35:12.108]   - Field: ‘workers’
[13:35:12.108]   - Field: ‘packages’
[13:35:12.108]   - Field: ‘gc’
[13:35:12.108]   - Field: ‘conditions’
[13:35:12.108]   - Field: ‘persistent’
[13:35:12.108]   - Field: ‘expr’
[13:35:12.108]   - Field: ‘uuid’
[13:35:12.108]   - Field: ‘seed’
[13:35:12.108]   - Field: ‘version’
[13:35:12.108]   - Field: ‘result’
[13:35:12.109]   - Field: ‘asynchronous’
[13:35:12.109]   - Field: ‘calls’
[13:35:12.109]   - Field: ‘globals’
[13:35:12.109]   - Field: ‘stdout’
[13:35:12.109]   - Field: ‘earlySignal’
[13:35:12.109]   - Field: ‘lazy’
[13:35:12.109]   - Field: ‘state’
[13:35:12.109] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:12.109] - Launch lazy future ...
[13:35:12.110] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:12.110] Packages needed by future strategies (n = 0): <none>
[13:35:12.110] {
[13:35:12.110]     {
[13:35:12.110]         {
[13:35:12.110]             ...future.startTime <- base::Sys.time()
[13:35:12.110]             {
[13:35:12.110]                 {
[13:35:12.110]                   {
[13:35:12.110]                     {
[13:35:12.110]                       {
[13:35:12.110]                         base::local({
[13:35:12.110]                           has_future <- base::requireNamespace("future", 
[13:35:12.110]                             quietly = TRUE)
[13:35:12.110]                           if (has_future) {
[13:35:12.110]                             ns <- base::getNamespace("future")
[13:35:12.110]                             version <- ns[[".package"]][["version"]]
[13:35:12.110]                             if (is.null(version)) 
[13:35:12.110]                               version <- utils::packageVersion("future")
[13:35:12.110]                           }
[13:35:12.110]                           else {
[13:35:12.110]                             version <- NULL
[13:35:12.110]                           }
[13:35:12.110]                           if (!has_future || version < "1.8.0") {
[13:35:12.110]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:12.110]                               "", base::R.version$version.string), 
[13:35:12.110]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:12.110]                                 base::R.version$platform, 8 * 
[13:35:12.110]                                   base::.Machine$sizeof.pointer), 
[13:35:12.110]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:12.110]                                 "release", "version")], collapse = " "), 
[13:35:12.110]                               hostname = base::Sys.info()[["nodename"]])
[13:35:12.110]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:12.110]                               info)
[13:35:12.110]                             info <- base::paste(info, collapse = "; ")
[13:35:12.110]                             if (!has_future) {
[13:35:12.110]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:12.110]                                 info)
[13:35:12.110]                             }
[13:35:12.110]                             else {
[13:35:12.110]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:12.110]                                 info, version)
[13:35:12.110]                             }
[13:35:12.110]                             base::stop(msg)
[13:35:12.110]                           }
[13:35:12.110]                         })
[13:35:12.110]                       }
[13:35:12.110]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:12.110]                       base::options(mc.cores = 1L)
[13:35:12.110]                     }
[13:35:12.110]                     base::local({
[13:35:12.110]                       for (pkg in "future.apply") {
[13:35:12.110]                         base::loadNamespace(pkg)
[13:35:12.110]                         base::library(pkg, character.only = TRUE)
[13:35:12.110]                       }
[13:35:12.110]                     })
[13:35:12.110]                   }
[13:35:12.110]                   ...future.strategy.old <- future::plan("list")
[13:35:12.110]                   options(future.plan = NULL)
[13:35:12.110]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:12.110]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:12.110]                 }
[13:35:12.110]                 ...future.workdir <- getwd()
[13:35:12.110]             }
[13:35:12.110]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:12.110]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:12.110]         }
[13:35:12.110]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:12.110]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:12.110]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:12.110]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:12.110]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:12.110]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:12.110]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:12.110]             base::names(...future.oldOptions))
[13:35:12.110]     }
[13:35:12.110]     if (FALSE) {
[13:35:12.110]     }
[13:35:12.110]     else {
[13:35:12.110]         if (TRUE) {
[13:35:12.110]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:12.110]                 open = "w")
[13:35:12.110]         }
[13:35:12.110]         else {
[13:35:12.110]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:12.110]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:12.110]         }
[13:35:12.110]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:12.110]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:12.110]             base::sink(type = "output", split = FALSE)
[13:35:12.110]             base::close(...future.stdout)
[13:35:12.110]         }, add = TRUE)
[13:35:12.110]     }
[13:35:12.110]     ...future.frame <- base::sys.nframe()
[13:35:12.110]     ...future.conditions <- base::list()
[13:35:12.110]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:12.110]     if (FALSE) {
[13:35:12.110]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:12.110]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:12.110]     }
[13:35:12.110]     ...future.result <- base::tryCatch({
[13:35:12.110]         base::withCallingHandlers({
[13:35:12.110]             ...future.value <- base::withVisible(base::local({
[13:35:12.110]                 ...future.makeSendCondition <- base::local({
[13:35:12.110]                   sendCondition <- NULL
[13:35:12.110]                   function(frame = 1L) {
[13:35:12.110]                     if (is.function(sendCondition)) 
[13:35:12.110]                       return(sendCondition)
[13:35:12.110]                     ns <- getNamespace("parallel")
[13:35:12.110]                     if (exists("sendData", mode = "function", 
[13:35:12.110]                       envir = ns)) {
[13:35:12.110]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:12.110]                         envir = ns)
[13:35:12.110]                       envir <- sys.frame(frame)
[13:35:12.110]                       master <- NULL
[13:35:12.110]                       while (!identical(envir, .GlobalEnv) && 
[13:35:12.110]                         !identical(envir, emptyenv())) {
[13:35:12.110]                         if (exists("master", mode = "list", envir = envir, 
[13:35:12.110]                           inherits = FALSE)) {
[13:35:12.110]                           master <- get("master", mode = "list", 
[13:35:12.110]                             envir = envir, inherits = FALSE)
[13:35:12.110]                           if (inherits(master, c("SOCKnode", 
[13:35:12.110]                             "SOCK0node"))) {
[13:35:12.110]                             sendCondition <<- function(cond) {
[13:35:12.110]                               data <- list(type = "VALUE", value = cond, 
[13:35:12.110]                                 success = TRUE)
[13:35:12.110]                               parallel_sendData(master, data)
[13:35:12.110]                             }
[13:35:12.110]                             return(sendCondition)
[13:35:12.110]                           }
[13:35:12.110]                         }
[13:35:12.110]                         frame <- frame + 1L
[13:35:12.110]                         envir <- sys.frame(frame)
[13:35:12.110]                       }
[13:35:12.110]                     }
[13:35:12.110]                     sendCondition <<- function(cond) NULL
[13:35:12.110]                   }
[13:35:12.110]                 })
[13:35:12.110]                 withCallingHandlers({
[13:35:12.110]                   {
[13:35:12.110]                     do.call(function(...) {
[13:35:12.110]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.110]                       if (!identical(...future.globals.maxSize.org, 
[13:35:12.110]                         ...future.globals.maxSize)) {
[13:35:12.110]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.110]                         on.exit(options(oopts), add = TRUE)
[13:35:12.110]                       }
[13:35:12.110]                       {
[13:35:12.110]                         lapply(seq_along(...future.elements_ii), 
[13:35:12.110]                           FUN = function(jj) {
[13:35:12.110]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.110]                             ...future.FUN(...future.X_jj, ...)
[13:35:12.110]                           })
[13:35:12.110]                       }
[13:35:12.110]                     }, args = future.call.arguments)
[13:35:12.110]                   }
[13:35:12.110]                 }, immediateCondition = function(cond) {
[13:35:12.110]                   sendCondition <- ...future.makeSendCondition()
[13:35:12.110]                   sendCondition(cond)
[13:35:12.110]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.110]                   {
[13:35:12.110]                     inherits <- base::inherits
[13:35:12.110]                     invokeRestart <- base::invokeRestart
[13:35:12.110]                     is.null <- base::is.null
[13:35:12.110]                     muffled <- FALSE
[13:35:12.110]                     if (inherits(cond, "message")) {
[13:35:12.110]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:12.110]                       if (muffled) 
[13:35:12.110]                         invokeRestart("muffleMessage")
[13:35:12.110]                     }
[13:35:12.110]                     else if (inherits(cond, "warning")) {
[13:35:12.110]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:12.110]                       if (muffled) 
[13:35:12.110]                         invokeRestart("muffleWarning")
[13:35:12.110]                     }
[13:35:12.110]                     else if (inherits(cond, "condition")) {
[13:35:12.110]                       if (!is.null(pattern)) {
[13:35:12.110]                         computeRestarts <- base::computeRestarts
[13:35:12.110]                         grepl <- base::grepl
[13:35:12.110]                         restarts <- computeRestarts(cond)
[13:35:12.110]                         for (restart in restarts) {
[13:35:12.110]                           name <- restart$name
[13:35:12.110]                           if (is.null(name)) 
[13:35:12.110]                             next
[13:35:12.110]                           if (!grepl(pattern, name)) 
[13:35:12.110]                             next
[13:35:12.110]                           invokeRestart(restart)
[13:35:12.110]                           muffled <- TRUE
[13:35:12.110]                           break
[13:35:12.110]                         }
[13:35:12.110]                       }
[13:35:12.110]                     }
[13:35:12.110]                     invisible(muffled)
[13:35:12.110]                   }
[13:35:12.110]                   muffleCondition(cond)
[13:35:12.110]                 })
[13:35:12.110]             }))
[13:35:12.110]             future::FutureResult(value = ...future.value$value, 
[13:35:12.110]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:12.110]                   ...future.rng), globalenv = if (FALSE) 
[13:35:12.110]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:12.110]                     ...future.globalenv.names))
[13:35:12.110]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:12.110]         }, condition = base::local({
[13:35:12.110]             c <- base::c
[13:35:12.110]             inherits <- base::inherits
[13:35:12.110]             invokeRestart <- base::invokeRestart
[13:35:12.110]             length <- base::length
[13:35:12.110]             list <- base::list
[13:35:12.110]             seq.int <- base::seq.int
[13:35:12.110]             signalCondition <- base::signalCondition
[13:35:12.110]             sys.calls <- base::sys.calls
[13:35:12.110]             `[[` <- base::`[[`
[13:35:12.110]             `+` <- base::`+`
[13:35:12.110]             `<<-` <- base::`<<-`
[13:35:12.110]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:12.110]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:12.110]                   3L)]
[13:35:12.110]             }
[13:35:12.110]             function(cond) {
[13:35:12.110]                 is_error <- inherits(cond, "error")
[13:35:12.110]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:12.110]                   NULL)
[13:35:12.110]                 if (is_error) {
[13:35:12.110]                   sessionInformation <- function() {
[13:35:12.110]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:12.110]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:12.110]                       search = base::search(), system = base::Sys.info())
[13:35:12.110]                   }
[13:35:12.110]                   ...future.conditions[[length(...future.conditions) + 
[13:35:12.110]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:12.110]                     cond$call), session = sessionInformation(), 
[13:35:12.110]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:12.110]                   signalCondition(cond)
[13:35:12.110]                 }
[13:35:12.110]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:12.110]                 "immediateCondition"))) {
[13:35:12.110]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:12.110]                   ...future.conditions[[length(...future.conditions) + 
[13:35:12.110]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:12.110]                   if (TRUE && !signal) {
[13:35:12.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.110]                     {
[13:35:12.110]                       inherits <- base::inherits
[13:35:12.110]                       invokeRestart <- base::invokeRestart
[13:35:12.110]                       is.null <- base::is.null
[13:35:12.110]                       muffled <- FALSE
[13:35:12.110]                       if (inherits(cond, "message")) {
[13:35:12.110]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:12.110]                         if (muffled) 
[13:35:12.110]                           invokeRestart("muffleMessage")
[13:35:12.110]                       }
[13:35:12.110]                       else if (inherits(cond, "warning")) {
[13:35:12.110]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:12.110]                         if (muffled) 
[13:35:12.110]                           invokeRestart("muffleWarning")
[13:35:12.110]                       }
[13:35:12.110]                       else if (inherits(cond, "condition")) {
[13:35:12.110]                         if (!is.null(pattern)) {
[13:35:12.110]                           computeRestarts <- base::computeRestarts
[13:35:12.110]                           grepl <- base::grepl
[13:35:12.110]                           restarts <- computeRestarts(cond)
[13:35:12.110]                           for (restart in restarts) {
[13:35:12.110]                             name <- restart$name
[13:35:12.110]                             if (is.null(name)) 
[13:35:12.110]                               next
[13:35:12.110]                             if (!grepl(pattern, name)) 
[13:35:12.110]                               next
[13:35:12.110]                             invokeRestart(restart)
[13:35:12.110]                             muffled <- TRUE
[13:35:12.110]                             break
[13:35:12.110]                           }
[13:35:12.110]                         }
[13:35:12.110]                       }
[13:35:12.110]                       invisible(muffled)
[13:35:12.110]                     }
[13:35:12.110]                     muffleCondition(cond, pattern = "^muffle")
[13:35:12.110]                   }
[13:35:12.110]                 }
[13:35:12.110]                 else {
[13:35:12.110]                   if (TRUE) {
[13:35:12.110]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.110]                     {
[13:35:12.110]                       inherits <- base::inherits
[13:35:12.110]                       invokeRestart <- base::invokeRestart
[13:35:12.110]                       is.null <- base::is.null
[13:35:12.110]                       muffled <- FALSE
[13:35:12.110]                       if (inherits(cond, "message")) {
[13:35:12.110]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:12.110]                         if (muffled) 
[13:35:12.110]                           invokeRestart("muffleMessage")
[13:35:12.110]                       }
[13:35:12.110]                       else if (inherits(cond, "warning")) {
[13:35:12.110]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:12.110]                         if (muffled) 
[13:35:12.110]                           invokeRestart("muffleWarning")
[13:35:12.110]                       }
[13:35:12.110]                       else if (inherits(cond, "condition")) {
[13:35:12.110]                         if (!is.null(pattern)) {
[13:35:12.110]                           computeRestarts <- base::computeRestarts
[13:35:12.110]                           grepl <- base::grepl
[13:35:12.110]                           restarts <- computeRestarts(cond)
[13:35:12.110]                           for (restart in restarts) {
[13:35:12.110]                             name <- restart$name
[13:35:12.110]                             if (is.null(name)) 
[13:35:12.110]                               next
[13:35:12.110]                             if (!grepl(pattern, name)) 
[13:35:12.110]                               next
[13:35:12.110]                             invokeRestart(restart)
[13:35:12.110]                             muffled <- TRUE
[13:35:12.110]                             break
[13:35:12.110]                           }
[13:35:12.110]                         }
[13:35:12.110]                       }
[13:35:12.110]                       invisible(muffled)
[13:35:12.110]                     }
[13:35:12.110]                     muffleCondition(cond, pattern = "^muffle")
[13:35:12.110]                   }
[13:35:12.110]                 }
[13:35:12.110]             }
[13:35:12.110]         }))
[13:35:12.110]     }, error = function(ex) {
[13:35:12.110]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:12.110]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:12.110]                 ...future.rng), started = ...future.startTime, 
[13:35:12.110]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:12.110]             version = "1.8"), class = "FutureResult")
[13:35:12.110]     }, finally = {
[13:35:12.110]         if (!identical(...future.workdir, getwd())) 
[13:35:12.110]             setwd(...future.workdir)
[13:35:12.110]         {
[13:35:12.110]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:12.110]                 ...future.oldOptions$nwarnings <- NULL
[13:35:12.110]             }
[13:35:12.110]             base::options(...future.oldOptions)
[13:35:12.110]             if (.Platform$OS.type == "windows") {
[13:35:12.110]                 old_names <- names(...future.oldEnvVars)
[13:35:12.110]                 envs <- base::Sys.getenv()
[13:35:12.110]                 names <- names(envs)
[13:35:12.110]                 common <- intersect(names, old_names)
[13:35:12.110]                 added <- setdiff(names, old_names)
[13:35:12.110]                 removed <- setdiff(old_names, names)
[13:35:12.110]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:12.110]                   envs[common]]
[13:35:12.110]                 NAMES <- toupper(changed)
[13:35:12.110]                 args <- list()
[13:35:12.110]                 for (kk in seq_along(NAMES)) {
[13:35:12.110]                   name <- changed[[kk]]
[13:35:12.110]                   NAME <- NAMES[[kk]]
[13:35:12.110]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.110]                     next
[13:35:12.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:12.110]                 }
[13:35:12.110]                 NAMES <- toupper(added)
[13:35:12.110]                 for (kk in seq_along(NAMES)) {
[13:35:12.110]                   name <- added[[kk]]
[13:35:12.110]                   NAME <- NAMES[[kk]]
[13:35:12.110]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.110]                     next
[13:35:12.110]                   args[[name]] <- ""
[13:35:12.110]                 }
[13:35:12.110]                 NAMES <- toupper(removed)
[13:35:12.110]                 for (kk in seq_along(NAMES)) {
[13:35:12.110]                   name <- removed[[kk]]
[13:35:12.110]                   NAME <- NAMES[[kk]]
[13:35:12.110]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.110]                     next
[13:35:12.110]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:12.110]                 }
[13:35:12.110]                 if (length(args) > 0) 
[13:35:12.110]                   base::do.call(base::Sys.setenv, args = args)
[13:35:12.110]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:12.110]             }
[13:35:12.110]             else {
[13:35:12.110]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:12.110]             }
[13:35:12.110]             {
[13:35:12.110]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:12.110]                   0L) {
[13:35:12.110]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:12.110]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:12.110]                   base::options(opts)
[13:35:12.110]                 }
[13:35:12.110]                 {
[13:35:12.110]                   {
[13:35:12.110]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:12.110]                     NULL
[13:35:12.110]                   }
[13:35:12.110]                   options(future.plan = NULL)
[13:35:12.110]                   if (is.na(NA_character_)) 
[13:35:12.110]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:12.110]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:12.110]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:12.110]                     .init = FALSE)
[13:35:12.110]                 }
[13:35:12.110]             }
[13:35:12.110]         }
[13:35:12.110]     })
[13:35:12.110]     if (TRUE) {
[13:35:12.110]         base::sink(type = "output", split = FALSE)
[13:35:12.110]         if (TRUE) {
[13:35:12.110]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:12.110]         }
[13:35:12.110]         else {
[13:35:12.110]             ...future.result["stdout"] <- base::list(NULL)
[13:35:12.110]         }
[13:35:12.110]         base::close(...future.stdout)
[13:35:12.110]         ...future.stdout <- NULL
[13:35:12.110]     }
[13:35:12.110]     ...future.result$conditions <- ...future.conditions
[13:35:12.110]     ...future.result$finished <- base::Sys.time()
[13:35:12.110]     ...future.result
[13:35:12.110] }
[13:35:12.113] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[13:35:12.113] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:12.154] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:12.155] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[13:35:12.155] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[13:35:12.155] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:12.156] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:12.156] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:12.198] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:12.199] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:12.242] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:12.243] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:35:12.243] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:35:12.243] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:12.244] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:12.244] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:12.244] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.244] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:35:12.245] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:35:12.245] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:12.245] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.245] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:12.246] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.246] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[13:35:12.246] MultisessionFuture started
[13:35:12.247] - Launch lazy future ... done
[13:35:12.247] run() for ‘MultisessionFuture’ ... done
[13:35:12.247] Created future:
[13:35:12.248] receiveMessageFromWorker() for ClusterFuture ...
[13:35:12.248] - Validating connection of MultisessionFuture
[13:35:12.249] - received message: FutureResult
[13:35:12.249] - Received FutureResult
[13:35:12.249] - Erased future from FutureRegistry
[13:35:12.249] result() for ClusterFuture ...
[13:35:12.249] - result already collected: FutureResult
[13:35:12.249] result() for ClusterFuture ... done
[13:35:12.249] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:12.247] MultisessionFuture:
[13:35:12.247] Label: ‘future_vapply-1’
[13:35:12.247] Expression:
[13:35:12.247] {
[13:35:12.247]     do.call(function(...) {
[13:35:12.247]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.247]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.247]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.247]             on.exit(options(oopts), add = TRUE)
[13:35:12.247]         }
[13:35:12.247]         {
[13:35:12.247]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.247]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.247]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.247]             })
[13:35:12.247]         }
[13:35:12.247]     }, args = future.call.arguments)
[13:35:12.247] }
[13:35:12.247] Lazy evaluation: FALSE
[13:35:12.247] Asynchronous evaluation: TRUE
[13:35:12.247] Local evaluation: TRUE
[13:35:12.247] Environment: R_GlobalEnv
[13:35:12.247] Capture standard output: TRUE
[13:35:12.247] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:12.247] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:12.247] Packages: 1 packages (‘future.apply’)
[13:35:12.247] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:12.247] Resolved: TRUE
[13:35:12.247] Value: <not collected>
[13:35:12.247] Conditions captured: <none>
[13:35:12.247] Early signaling: FALSE
[13:35:12.247] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:12.247] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:12.250] Chunk #1 of 2 ... DONE
[13:35:12.250] Chunk #2 of 2 ...
[13:35:12.250]  - Finding globals in 'X' for chunk #2 ...
[13:35:12.250] getGlobalsAndPackages() ...
[13:35:12.250] Searching for globals...
[13:35:12.250] 
[13:35:12.250] Searching for globals ... DONE
[13:35:12.250] - globals: [0] <none>
[13:35:12.251] getGlobalsAndPackages() ... DONE
[13:35:12.251]    + additional globals found: [n=0] 
[13:35:12.251]    + additional namespaces needed: [n=0] 
[13:35:12.251]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:12.251]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:12.251]  - seeds: <none>
[13:35:12.251]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.251] getGlobalsAndPackages() ...
[13:35:12.251] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.251] Resolving globals: FALSE
[13:35:12.251] Tweak future expression to call with '...' arguments ...
[13:35:12.252] {
[13:35:12.252]     do.call(function(...) {
[13:35:12.252]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.252]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.252]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.252]             on.exit(options(oopts), add = TRUE)
[13:35:12.252]         }
[13:35:12.252]         {
[13:35:12.252]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.252]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.252]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.252]             })
[13:35:12.252]         }
[13:35:12.252]     }, args = future.call.arguments)
[13:35:12.252] }
[13:35:12.252] Tweak future expression to call with '...' arguments ... DONE
[13:35:12.252] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.252] - packages: [1] ‘future.apply’
[13:35:12.253] getGlobalsAndPackages() ... DONE
[13:35:12.253] run() for ‘Future’ ...
[13:35:12.253] - state: ‘created’
[13:35:12.253] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:12.267] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:12.267] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:12.267]   - Field: ‘node’
[13:35:12.267]   - Field: ‘label’
[13:35:12.267]   - Field: ‘local’
[13:35:12.267]   - Field: ‘owner’
[13:35:12.268]   - Field: ‘envir’
[13:35:12.268]   - Field: ‘workers’
[13:35:12.268]   - Field: ‘packages’
[13:35:12.268]   - Field: ‘gc’
[13:35:12.268]   - Field: ‘conditions’
[13:35:12.268]   - Field: ‘persistent’
[13:35:12.268]   - Field: ‘expr’
[13:35:12.268]   - Field: ‘uuid’
[13:35:12.268]   - Field: ‘seed’
[13:35:12.268]   - Field: ‘version’
[13:35:12.268]   - Field: ‘result’
[13:35:12.269]   - Field: ‘asynchronous’
[13:35:12.269]   - Field: ‘calls’
[13:35:12.269]   - Field: ‘globals’
[13:35:12.269]   - Field: ‘stdout’
[13:35:12.269]   - Field: ‘earlySignal’
[13:35:12.269]   - Field: ‘lazy’
[13:35:12.269]   - Field: ‘state’
[13:35:12.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:12.269] - Launch lazy future ...
[13:35:12.270] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:12.270] Packages needed by future strategies (n = 0): <none>
[13:35:12.270] {
[13:35:12.270]     {
[13:35:12.270]         {
[13:35:12.270]             ...future.startTime <- base::Sys.time()
[13:35:12.270]             {
[13:35:12.270]                 {
[13:35:12.270]                   {
[13:35:12.270]                     {
[13:35:12.270]                       {
[13:35:12.270]                         base::local({
[13:35:12.270]                           has_future <- base::requireNamespace("future", 
[13:35:12.270]                             quietly = TRUE)
[13:35:12.270]                           if (has_future) {
[13:35:12.270]                             ns <- base::getNamespace("future")
[13:35:12.270]                             version <- ns[[".package"]][["version"]]
[13:35:12.270]                             if (is.null(version)) 
[13:35:12.270]                               version <- utils::packageVersion("future")
[13:35:12.270]                           }
[13:35:12.270]                           else {
[13:35:12.270]                             version <- NULL
[13:35:12.270]                           }
[13:35:12.270]                           if (!has_future || version < "1.8.0") {
[13:35:12.270]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:12.270]                               "", base::R.version$version.string), 
[13:35:12.270]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:12.270]                                 base::R.version$platform, 8 * 
[13:35:12.270]                                   base::.Machine$sizeof.pointer), 
[13:35:12.270]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:12.270]                                 "release", "version")], collapse = " "), 
[13:35:12.270]                               hostname = base::Sys.info()[["nodename"]])
[13:35:12.270]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:12.270]                               info)
[13:35:12.270]                             info <- base::paste(info, collapse = "; ")
[13:35:12.270]                             if (!has_future) {
[13:35:12.270]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:12.270]                                 info)
[13:35:12.270]                             }
[13:35:12.270]                             else {
[13:35:12.270]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:12.270]                                 info, version)
[13:35:12.270]                             }
[13:35:12.270]                             base::stop(msg)
[13:35:12.270]                           }
[13:35:12.270]                         })
[13:35:12.270]                       }
[13:35:12.270]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:12.270]                       base::options(mc.cores = 1L)
[13:35:12.270]                     }
[13:35:12.270]                     base::local({
[13:35:12.270]                       for (pkg in "future.apply") {
[13:35:12.270]                         base::loadNamespace(pkg)
[13:35:12.270]                         base::library(pkg, character.only = TRUE)
[13:35:12.270]                       }
[13:35:12.270]                     })
[13:35:12.270]                   }
[13:35:12.270]                   ...future.strategy.old <- future::plan("list")
[13:35:12.270]                   options(future.plan = NULL)
[13:35:12.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:12.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:12.270]                 }
[13:35:12.270]                 ...future.workdir <- getwd()
[13:35:12.270]             }
[13:35:12.270]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:12.270]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:12.270]         }
[13:35:12.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:12.270]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:12.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:12.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:12.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:12.270]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:12.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:12.270]             base::names(...future.oldOptions))
[13:35:12.270]     }
[13:35:12.270]     if (FALSE) {
[13:35:12.270]     }
[13:35:12.270]     else {
[13:35:12.270]         if (TRUE) {
[13:35:12.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:12.270]                 open = "w")
[13:35:12.270]         }
[13:35:12.270]         else {
[13:35:12.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:12.270]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:12.270]         }
[13:35:12.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:12.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:12.270]             base::sink(type = "output", split = FALSE)
[13:35:12.270]             base::close(...future.stdout)
[13:35:12.270]         }, add = TRUE)
[13:35:12.270]     }
[13:35:12.270]     ...future.frame <- base::sys.nframe()
[13:35:12.270]     ...future.conditions <- base::list()
[13:35:12.270]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:12.270]     if (FALSE) {
[13:35:12.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:12.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:12.270]     }
[13:35:12.270]     ...future.result <- base::tryCatch({
[13:35:12.270]         base::withCallingHandlers({
[13:35:12.270]             ...future.value <- base::withVisible(base::local({
[13:35:12.270]                 ...future.makeSendCondition <- base::local({
[13:35:12.270]                   sendCondition <- NULL
[13:35:12.270]                   function(frame = 1L) {
[13:35:12.270]                     if (is.function(sendCondition)) 
[13:35:12.270]                       return(sendCondition)
[13:35:12.270]                     ns <- getNamespace("parallel")
[13:35:12.270]                     if (exists("sendData", mode = "function", 
[13:35:12.270]                       envir = ns)) {
[13:35:12.270]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:12.270]                         envir = ns)
[13:35:12.270]                       envir <- sys.frame(frame)
[13:35:12.270]                       master <- NULL
[13:35:12.270]                       while (!identical(envir, .GlobalEnv) && 
[13:35:12.270]                         !identical(envir, emptyenv())) {
[13:35:12.270]                         if (exists("master", mode = "list", envir = envir, 
[13:35:12.270]                           inherits = FALSE)) {
[13:35:12.270]                           master <- get("master", mode = "list", 
[13:35:12.270]                             envir = envir, inherits = FALSE)
[13:35:12.270]                           if (inherits(master, c("SOCKnode", 
[13:35:12.270]                             "SOCK0node"))) {
[13:35:12.270]                             sendCondition <<- function(cond) {
[13:35:12.270]                               data <- list(type = "VALUE", value = cond, 
[13:35:12.270]                                 success = TRUE)
[13:35:12.270]                               parallel_sendData(master, data)
[13:35:12.270]                             }
[13:35:12.270]                             return(sendCondition)
[13:35:12.270]                           }
[13:35:12.270]                         }
[13:35:12.270]                         frame <- frame + 1L
[13:35:12.270]                         envir <- sys.frame(frame)
[13:35:12.270]                       }
[13:35:12.270]                     }
[13:35:12.270]                     sendCondition <<- function(cond) NULL
[13:35:12.270]                   }
[13:35:12.270]                 })
[13:35:12.270]                 withCallingHandlers({
[13:35:12.270]                   {
[13:35:12.270]                     do.call(function(...) {
[13:35:12.270]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.270]                       if (!identical(...future.globals.maxSize.org, 
[13:35:12.270]                         ...future.globals.maxSize)) {
[13:35:12.270]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.270]                         on.exit(options(oopts), add = TRUE)
[13:35:12.270]                       }
[13:35:12.270]                       {
[13:35:12.270]                         lapply(seq_along(...future.elements_ii), 
[13:35:12.270]                           FUN = function(jj) {
[13:35:12.270]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.270]                             ...future.FUN(...future.X_jj, ...)
[13:35:12.270]                           })
[13:35:12.270]                       }
[13:35:12.270]                     }, args = future.call.arguments)
[13:35:12.270]                   }
[13:35:12.270]                 }, immediateCondition = function(cond) {
[13:35:12.270]                   sendCondition <- ...future.makeSendCondition()
[13:35:12.270]                   sendCondition(cond)
[13:35:12.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.270]                   {
[13:35:12.270]                     inherits <- base::inherits
[13:35:12.270]                     invokeRestart <- base::invokeRestart
[13:35:12.270]                     is.null <- base::is.null
[13:35:12.270]                     muffled <- FALSE
[13:35:12.270]                     if (inherits(cond, "message")) {
[13:35:12.270]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:12.270]                       if (muffled) 
[13:35:12.270]                         invokeRestart("muffleMessage")
[13:35:12.270]                     }
[13:35:12.270]                     else if (inherits(cond, "warning")) {
[13:35:12.270]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:12.270]                       if (muffled) 
[13:35:12.270]                         invokeRestart("muffleWarning")
[13:35:12.270]                     }
[13:35:12.270]                     else if (inherits(cond, "condition")) {
[13:35:12.270]                       if (!is.null(pattern)) {
[13:35:12.270]                         computeRestarts <- base::computeRestarts
[13:35:12.270]                         grepl <- base::grepl
[13:35:12.270]                         restarts <- computeRestarts(cond)
[13:35:12.270]                         for (restart in restarts) {
[13:35:12.270]                           name <- restart$name
[13:35:12.270]                           if (is.null(name)) 
[13:35:12.270]                             next
[13:35:12.270]                           if (!grepl(pattern, name)) 
[13:35:12.270]                             next
[13:35:12.270]                           invokeRestart(restart)
[13:35:12.270]                           muffled <- TRUE
[13:35:12.270]                           break
[13:35:12.270]                         }
[13:35:12.270]                       }
[13:35:12.270]                     }
[13:35:12.270]                     invisible(muffled)
[13:35:12.270]                   }
[13:35:12.270]                   muffleCondition(cond)
[13:35:12.270]                 })
[13:35:12.270]             }))
[13:35:12.270]             future::FutureResult(value = ...future.value$value, 
[13:35:12.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:12.270]                   ...future.rng), globalenv = if (FALSE) 
[13:35:12.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:12.270]                     ...future.globalenv.names))
[13:35:12.270]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:12.270]         }, condition = base::local({
[13:35:12.270]             c <- base::c
[13:35:12.270]             inherits <- base::inherits
[13:35:12.270]             invokeRestart <- base::invokeRestart
[13:35:12.270]             length <- base::length
[13:35:12.270]             list <- base::list
[13:35:12.270]             seq.int <- base::seq.int
[13:35:12.270]             signalCondition <- base::signalCondition
[13:35:12.270]             sys.calls <- base::sys.calls
[13:35:12.270]             `[[` <- base::`[[`
[13:35:12.270]             `+` <- base::`+`
[13:35:12.270]             `<<-` <- base::`<<-`
[13:35:12.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:12.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:12.270]                   3L)]
[13:35:12.270]             }
[13:35:12.270]             function(cond) {
[13:35:12.270]                 is_error <- inherits(cond, "error")
[13:35:12.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:12.270]                   NULL)
[13:35:12.270]                 if (is_error) {
[13:35:12.270]                   sessionInformation <- function() {
[13:35:12.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:12.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:12.270]                       search = base::search(), system = base::Sys.info())
[13:35:12.270]                   }
[13:35:12.270]                   ...future.conditions[[length(...future.conditions) + 
[13:35:12.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:12.270]                     cond$call), session = sessionInformation(), 
[13:35:12.270]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:12.270]                   signalCondition(cond)
[13:35:12.270]                 }
[13:35:12.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:12.270]                 "immediateCondition"))) {
[13:35:12.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:12.270]                   ...future.conditions[[length(...future.conditions) + 
[13:35:12.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:12.270]                   if (TRUE && !signal) {
[13:35:12.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.270]                     {
[13:35:12.270]                       inherits <- base::inherits
[13:35:12.270]                       invokeRestart <- base::invokeRestart
[13:35:12.270]                       is.null <- base::is.null
[13:35:12.270]                       muffled <- FALSE
[13:35:12.270]                       if (inherits(cond, "message")) {
[13:35:12.270]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:12.270]                         if (muffled) 
[13:35:12.270]                           invokeRestart("muffleMessage")
[13:35:12.270]                       }
[13:35:12.270]                       else if (inherits(cond, "warning")) {
[13:35:12.270]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:12.270]                         if (muffled) 
[13:35:12.270]                           invokeRestart("muffleWarning")
[13:35:12.270]                       }
[13:35:12.270]                       else if (inherits(cond, "condition")) {
[13:35:12.270]                         if (!is.null(pattern)) {
[13:35:12.270]                           computeRestarts <- base::computeRestarts
[13:35:12.270]                           grepl <- base::grepl
[13:35:12.270]                           restarts <- computeRestarts(cond)
[13:35:12.270]                           for (restart in restarts) {
[13:35:12.270]                             name <- restart$name
[13:35:12.270]                             if (is.null(name)) 
[13:35:12.270]                               next
[13:35:12.270]                             if (!grepl(pattern, name)) 
[13:35:12.270]                               next
[13:35:12.270]                             invokeRestart(restart)
[13:35:12.270]                             muffled <- TRUE
[13:35:12.270]                             break
[13:35:12.270]                           }
[13:35:12.270]                         }
[13:35:12.270]                       }
[13:35:12.270]                       invisible(muffled)
[13:35:12.270]                     }
[13:35:12.270]                     muffleCondition(cond, pattern = "^muffle")
[13:35:12.270]                   }
[13:35:12.270]                 }
[13:35:12.270]                 else {
[13:35:12.270]                   if (TRUE) {
[13:35:12.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.270]                     {
[13:35:12.270]                       inherits <- base::inherits
[13:35:12.270]                       invokeRestart <- base::invokeRestart
[13:35:12.270]                       is.null <- base::is.null
[13:35:12.270]                       muffled <- FALSE
[13:35:12.270]                       if (inherits(cond, "message")) {
[13:35:12.270]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:12.270]                         if (muffled) 
[13:35:12.270]                           invokeRestart("muffleMessage")
[13:35:12.270]                       }
[13:35:12.270]                       else if (inherits(cond, "warning")) {
[13:35:12.270]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:12.270]                         if (muffled) 
[13:35:12.270]                           invokeRestart("muffleWarning")
[13:35:12.270]                       }
[13:35:12.270]                       else if (inherits(cond, "condition")) {
[13:35:12.270]                         if (!is.null(pattern)) {
[13:35:12.270]                           computeRestarts <- base::computeRestarts
[13:35:12.270]                           grepl <- base::grepl
[13:35:12.270]                           restarts <- computeRestarts(cond)
[13:35:12.270]                           for (restart in restarts) {
[13:35:12.270]                             name <- restart$name
[13:35:12.270]                             if (is.null(name)) 
[13:35:12.270]                               next
[13:35:12.270]                             if (!grepl(pattern, name)) 
[13:35:12.270]                               next
[13:35:12.270]                             invokeRestart(restart)
[13:35:12.270]                             muffled <- TRUE
[13:35:12.270]                             break
[13:35:12.270]                           }
[13:35:12.270]                         }
[13:35:12.270]                       }
[13:35:12.270]                       invisible(muffled)
[13:35:12.270]                     }
[13:35:12.270]                     muffleCondition(cond, pattern = "^muffle")
[13:35:12.270]                   }
[13:35:12.270]                 }
[13:35:12.270]             }
[13:35:12.270]         }))
[13:35:12.270]     }, error = function(ex) {
[13:35:12.270]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:12.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:12.270]                 ...future.rng), started = ...future.startTime, 
[13:35:12.270]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:12.270]             version = "1.8"), class = "FutureResult")
[13:35:12.270]     }, finally = {
[13:35:12.270]         if (!identical(...future.workdir, getwd())) 
[13:35:12.270]             setwd(...future.workdir)
[13:35:12.270]         {
[13:35:12.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:12.270]                 ...future.oldOptions$nwarnings <- NULL
[13:35:12.270]             }
[13:35:12.270]             base::options(...future.oldOptions)
[13:35:12.270]             if (.Platform$OS.type == "windows") {
[13:35:12.270]                 old_names <- names(...future.oldEnvVars)
[13:35:12.270]                 envs <- base::Sys.getenv()
[13:35:12.270]                 names <- names(envs)
[13:35:12.270]                 common <- intersect(names, old_names)
[13:35:12.270]                 added <- setdiff(names, old_names)
[13:35:12.270]                 removed <- setdiff(old_names, names)
[13:35:12.270]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:12.270]                   envs[common]]
[13:35:12.270]                 NAMES <- toupper(changed)
[13:35:12.270]                 args <- list()
[13:35:12.270]                 for (kk in seq_along(NAMES)) {
[13:35:12.270]                   name <- changed[[kk]]
[13:35:12.270]                   NAME <- NAMES[[kk]]
[13:35:12.270]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.270]                     next
[13:35:12.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:12.270]                 }
[13:35:12.270]                 NAMES <- toupper(added)
[13:35:12.270]                 for (kk in seq_along(NAMES)) {
[13:35:12.270]                   name <- added[[kk]]
[13:35:12.270]                   NAME <- NAMES[[kk]]
[13:35:12.270]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.270]                     next
[13:35:12.270]                   args[[name]] <- ""
[13:35:12.270]                 }
[13:35:12.270]                 NAMES <- toupper(removed)
[13:35:12.270]                 for (kk in seq_along(NAMES)) {
[13:35:12.270]                   name <- removed[[kk]]
[13:35:12.270]                   NAME <- NAMES[[kk]]
[13:35:12.270]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.270]                     next
[13:35:12.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:12.270]                 }
[13:35:12.270]                 if (length(args) > 0) 
[13:35:12.270]                   base::do.call(base::Sys.setenv, args = args)
[13:35:12.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:12.270]             }
[13:35:12.270]             else {
[13:35:12.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:12.270]             }
[13:35:12.270]             {
[13:35:12.270]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:12.270]                   0L) {
[13:35:12.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:12.270]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:12.270]                   base::options(opts)
[13:35:12.270]                 }
[13:35:12.270]                 {
[13:35:12.270]                   {
[13:35:12.270]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:12.270]                     NULL
[13:35:12.270]                   }
[13:35:12.270]                   options(future.plan = NULL)
[13:35:12.270]                   if (is.na(NA_character_)) 
[13:35:12.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:12.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:12.270]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:12.270]                     .init = FALSE)
[13:35:12.270]                 }
[13:35:12.270]             }
[13:35:12.270]         }
[13:35:12.270]     })
[13:35:12.270]     if (TRUE) {
[13:35:12.270]         base::sink(type = "output", split = FALSE)
[13:35:12.270]         if (TRUE) {
[13:35:12.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:12.270]         }
[13:35:12.270]         else {
[13:35:12.270]             ...future.result["stdout"] <- base::list(NULL)
[13:35:12.270]         }
[13:35:12.270]         base::close(...future.stdout)
[13:35:12.270]         ...future.stdout <- NULL
[13:35:12.270]     }
[13:35:12.270]     ...future.result$conditions <- ...future.conditions
[13:35:12.270]     ...future.result$finished <- base::Sys.time()
[13:35:12.270]     ...future.result
[13:35:12.270] }
[13:35:12.273] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[13:35:12.273] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:12.314] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:12.315] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[13:35:12.315] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[13:35:12.315] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:12.316] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:12.316] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:12.358] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:12.359] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:12.402] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:12.403] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:35:12.403] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:35:12.403] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:12.404] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:12.404] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:12.404] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.404] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[13:35:12.405] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[13:35:12.405] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:12.405] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.405] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:12.406] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.406] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[13:35:12.406] MultisessionFuture started
[13:35:12.406] - Launch lazy future ... done
[13:35:12.406] run() for ‘MultisessionFuture’ ... done
[13:35:12.407] Created future:
[13:35:12.408] receiveMessageFromWorker() for ClusterFuture ...
[13:35:12.408] - Validating connection of MultisessionFuture
[13:35:12.408] - received message: FutureResult
[13:35:12.408] - Received FutureResult
[13:35:12.409] - Erased future from FutureRegistry
[13:35:12.409] result() for ClusterFuture ...
[13:35:12.409] - result already collected: FutureResult
[13:35:12.409] result() for ClusterFuture ... done
[13:35:12.409] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:12.407] MultisessionFuture:
[13:35:12.407] Label: ‘future_vapply-2’
[13:35:12.407] Expression:
[13:35:12.407] {
[13:35:12.407]     do.call(function(...) {
[13:35:12.407]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.407]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.407]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.407]             on.exit(options(oopts), add = TRUE)
[13:35:12.407]         }
[13:35:12.407]         {
[13:35:12.407]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.407]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.407]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.407]             })
[13:35:12.407]         }
[13:35:12.407]     }, args = future.call.arguments)
[13:35:12.407] }
[13:35:12.407] Lazy evaluation: FALSE
[13:35:12.407] Asynchronous evaluation: TRUE
[13:35:12.407] Local evaluation: TRUE
[13:35:12.407] Environment: R_GlobalEnv
[13:35:12.407] Capture standard output: TRUE
[13:35:12.407] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:12.407] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:12.407] Packages: 1 packages (‘future.apply’)
[13:35:12.407] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:12.407] Resolved: TRUE
[13:35:12.407] Value: <not collected>
[13:35:12.407] Conditions captured: <none>
[13:35:12.407] Early signaling: FALSE
[13:35:12.407] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:12.407] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:12.409] Chunk #2 of 2 ... DONE
[13:35:12.409] Launching 2 futures (chunks) ... DONE
[13:35:12.409] Resolving 2 futures (chunks) ...
[13:35:12.410] resolve() on list ...
[13:35:12.410]  recursive: 0
[13:35:12.410]  length: 2
[13:35:12.410] 
[13:35:12.410] Future #1
[13:35:12.410] result() for ClusterFuture ...
[13:35:12.410] - result already collected: FutureResult
[13:35:12.410] result() for ClusterFuture ... done
[13:35:12.410] result() for ClusterFuture ...
[13:35:12.410] - result already collected: FutureResult
[13:35:12.410] result() for ClusterFuture ... done
[13:35:12.411] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:12.411] - nx: 2
[13:35:12.411] - relay: TRUE
[13:35:12.411] - stdout: TRUE
[13:35:12.411] - signal: TRUE
[13:35:12.411] - resignal: FALSE
[13:35:12.411] - force: TRUE
[13:35:12.411] - relayed: [n=2] FALSE, FALSE
[13:35:12.411] - queued futures: [n=2] FALSE, FALSE
[13:35:12.411]  - until=1
[13:35:12.411]  - relaying element #1
[13:35:12.412] result() for ClusterFuture ...
[13:35:12.412] - result already collected: FutureResult
[13:35:12.412] result() for ClusterFuture ... done
[13:35:12.412] result() for ClusterFuture ...
[13:35:12.412] - result already collected: FutureResult
[13:35:12.412] result() for ClusterFuture ... done
[13:35:12.412] result() for ClusterFuture ...
[13:35:12.412] - result already collected: FutureResult
[13:35:12.412] result() for ClusterFuture ... done
[13:35:12.412] result() for ClusterFuture ...
[13:35:12.412] - result already collected: FutureResult
[13:35:12.412] result() for ClusterFuture ... done
[13:35:12.413] - relayed: [n=2] TRUE, FALSE
[13:35:12.413] - queued futures: [n=2] TRUE, FALSE
[13:35:12.413] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:12.413]  length: 1 (resolved future 1)
[13:35:12.413] Future #2
[13:35:12.413] result() for ClusterFuture ...
[13:35:12.413] - result already collected: FutureResult
[13:35:12.413] result() for ClusterFuture ... done
[13:35:12.413] result() for ClusterFuture ...
[13:35:12.413] - result already collected: FutureResult
[13:35:12.413] result() for ClusterFuture ... done
[13:35:12.414] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:12.414] - nx: 2
[13:35:12.414] - relay: TRUE
[13:35:12.414] - stdout: TRUE
[13:35:12.414] - signal: TRUE
[13:35:12.414] - resignal: FALSE
[13:35:12.414] - force: TRUE
[13:35:12.414] - relayed: [n=2] TRUE, FALSE
[13:35:12.414] - queued futures: [n=2] TRUE, FALSE
[13:35:12.414]  - until=2
[13:35:12.414]  - relaying element #2
[13:35:12.415] result() for ClusterFuture ...
[13:35:12.415] - result already collected: FutureResult
[13:35:12.415] result() for ClusterFuture ... done
[13:35:12.415] result() for ClusterFuture ...
[13:35:12.415] - result already collected: FutureResult
[13:35:12.415] result() for ClusterFuture ... done
[13:35:12.415] result() for ClusterFuture ...
[13:35:12.415] - result already collected: FutureResult
[13:35:12.415] result() for ClusterFuture ... done
[13:35:12.415] result() for ClusterFuture ...
[13:35:12.415] - result already collected: FutureResult
[13:35:12.416] result() for ClusterFuture ... done
[13:35:12.416] - relayed: [n=2] TRUE, TRUE
[13:35:12.416] - queued futures: [n=2] TRUE, TRUE
[13:35:12.416] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:12.416]  length: 0 (resolved future 2)
[13:35:12.416] Relaying remaining futures
[13:35:12.416] signalConditionsASAP(NULL, pos=0) ...
[13:35:12.416] - nx: 2
[13:35:12.416] - relay: TRUE
[13:35:12.416] - stdout: TRUE
[13:35:12.416] - signal: TRUE
[13:35:12.417] - resignal: FALSE
[13:35:12.417] - force: TRUE
[13:35:12.417] - relayed: [n=2] TRUE, TRUE
[13:35:12.417] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:12.417] - relayed: [n=2] TRUE, TRUE
[13:35:12.417] - queued futures: [n=2] TRUE, TRUE
[13:35:12.417] signalConditionsASAP(NULL, pos=0) ... done
[13:35:12.417] resolve() on list ... DONE
[13:35:12.417] result() for ClusterFuture ...
[13:35:12.417] - result already collected: FutureResult
[13:35:12.417] result() for ClusterFuture ... done
[13:35:12.418] result() for ClusterFuture ...
[13:35:12.418] - result already collected: FutureResult
[13:35:12.418] result() for ClusterFuture ... done
[13:35:12.418] result() for ClusterFuture ...
[13:35:12.418] - result already collected: FutureResult
[13:35:12.418] result() for ClusterFuture ... done
[13:35:12.418] result() for ClusterFuture ...
[13:35:12.418] - result already collected: FutureResult
[13:35:12.418] result() for ClusterFuture ... done
[13:35:12.418]  - Number of value chunks collected: 2
[13:35:12.419] Resolving 2 futures (chunks) ... DONE
[13:35:12.419] Reducing values from 2 chunks ...
[13:35:12.419]  - Number of values collected after concatenation: 10
[13:35:12.419]  - Number of values expected: 10
[13:35:12.419] Reducing values from 2 chunks ... DONE
[13:35:12.419] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[13:35:12.421] future_lapply() ...
[13:35:12.427] Number of chunks: 2
[13:35:12.427] getGlobalsAndPackagesXApply() ...
[13:35:12.427]  - future.globals: TRUE
[13:35:12.427] getGlobalsAndPackages() ...
[13:35:12.427] Searching for globals...
[13:35:12.430] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[13:35:12.430] Searching for globals ... DONE
[13:35:12.430] Resolving globals: FALSE
[13:35:12.431] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[13:35:12.432] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:12.432] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:12.432] - packages: [2] ‘stats’, ‘future.apply’
[13:35:12.432] getGlobalsAndPackages() ... DONE
[13:35:12.432]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:12.432]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:35:12.432] Finding globals ... DONE
[13:35:12.432]  - use_args: TRUE
[13:35:12.432]  - Getting '...' globals ...
[13:35:12.433] resolve() on list ...
[13:35:12.433]  recursive: 0
[13:35:12.433]  length: 1
[13:35:12.433]  elements: ‘...’
[13:35:12.433]  length: 0 (resolved future 1)
[13:35:12.433] resolve() on list ... DONE
[13:35:12.433]    - '...' content: [n=0] 
[13:35:12.433] List of 1
[13:35:12.433]  $ ...: list()
[13:35:12.433]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:12.433]  - attr(*, "where")=List of 1
[13:35:12.433]   ..$ ...:<environment: 0x5574d271cec8> 
[13:35:12.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:12.433]  - attr(*, "resolved")= logi TRUE
[13:35:12.433]  - attr(*, "total_size")= num NA
[13:35:12.436]  - Getting '...' globals ... DONE
[13:35:12.436] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:12.436] List of 8
[13:35:12.436]  $ ...future.FUN:function (x, ...)  
[13:35:12.436]  $ x_FUN        :function (x, ...)  
[13:35:12.436]  $ times        : int 5
[13:35:12.436]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:12.436]  $ stop_if_not  :function (...)  
[13:35:12.436]  $ dim          : NULL
[13:35:12.436]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:12.436]  $ ...          : list()
[13:35:12.436]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:12.436]  - attr(*, "where")=List of 8
[13:35:12.436]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:12.436]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:12.436]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:12.436]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:12.436]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:12.436]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:12.436]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:12.436]   ..$ ...          :<environment: 0x5574d271cec8> 
[13:35:12.436]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:12.436]  - attr(*, "resolved")= logi FALSE
[13:35:12.436]  - attr(*, "total_size")= num 95528
[13:35:12.441] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:35:12.441] getGlobalsAndPackagesXApply() ... DONE
[13:35:12.441] Number of futures (= number of chunks): 2
[13:35:12.442] Launching 2 futures (chunks) ...
[13:35:12.442] Chunk #1 of 2 ...
[13:35:12.442]  - Finding globals in 'X' for chunk #1 ...
[13:35:12.442] getGlobalsAndPackages() ...
[13:35:12.442] Searching for globals...
[13:35:12.442] 
[13:35:12.442] Searching for globals ... DONE
[13:35:12.442] - globals: [0] <none>
[13:35:12.442] getGlobalsAndPackages() ... DONE
[13:35:12.443]    + additional globals found: [n=0] 
[13:35:12.443]    + additional namespaces needed: [n=0] 
[13:35:12.443]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:12.443]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:12.443]  - seeds: <none>
[13:35:12.445]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.445] getGlobalsAndPackages() ...
[13:35:12.445] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.446] Resolving globals: FALSE
[13:35:12.446] Tweak future expression to call with '...' arguments ...
[13:35:12.446] {
[13:35:12.446]     do.call(function(...) {
[13:35:12.446]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.446]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.446]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.446]             on.exit(options(oopts), add = TRUE)
[13:35:12.446]         }
[13:35:12.446]         {
[13:35:12.446]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.446]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.446]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.446]             })
[13:35:12.446]         }
[13:35:12.446]     }, args = future.call.arguments)
[13:35:12.446] }
[13:35:12.446] Tweak future expression to call with '...' arguments ... DONE
[13:35:12.447] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.447] - packages: [2] ‘stats’, ‘future.apply’
[13:35:12.447] getGlobalsAndPackages() ... DONE
[13:35:12.447] run() for ‘Future’ ...
[13:35:12.447] - state: ‘created’
[13:35:12.447] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:12.461] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:12.461] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:12.462]   - Field: ‘node’
[13:35:12.462]   - Field: ‘label’
[13:35:12.462]   - Field: ‘local’
[13:35:12.462]   - Field: ‘owner’
[13:35:12.462]   - Field: ‘envir’
[13:35:12.462]   - Field: ‘workers’
[13:35:12.462]   - Field: ‘packages’
[13:35:12.462]   - Field: ‘gc’
[13:35:12.462]   - Field: ‘conditions’
[13:35:12.462]   - Field: ‘persistent’
[13:35:12.463]   - Field: ‘expr’
[13:35:12.463]   - Field: ‘uuid’
[13:35:12.463]   - Field: ‘seed’
[13:35:12.463]   - Field: ‘version’
[13:35:12.463]   - Field: ‘result’
[13:35:12.463]   - Field: ‘asynchronous’
[13:35:12.463]   - Field: ‘calls’
[13:35:12.463]   - Field: ‘globals’
[13:35:12.464]   - Field: ‘stdout’
[13:35:12.464]   - Field: ‘earlySignal’
[13:35:12.464]   - Field: ‘lazy’
[13:35:12.464]   - Field: ‘state’
[13:35:12.464] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:12.464] - Launch lazy future ...
[13:35:12.465] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:35:12.465] Packages needed by future strategies (n = 0): <none>
[13:35:12.465] {
[13:35:12.465]     {
[13:35:12.465]         {
[13:35:12.465]             ...future.startTime <- base::Sys.time()
[13:35:12.465]             {
[13:35:12.465]                 {
[13:35:12.465]                   {
[13:35:12.465]                     {
[13:35:12.465]                       {
[13:35:12.465]                         base::local({
[13:35:12.465]                           has_future <- base::requireNamespace("future", 
[13:35:12.465]                             quietly = TRUE)
[13:35:12.465]                           if (has_future) {
[13:35:12.465]                             ns <- base::getNamespace("future")
[13:35:12.465]                             version <- ns[[".package"]][["version"]]
[13:35:12.465]                             if (is.null(version)) 
[13:35:12.465]                               version <- utils::packageVersion("future")
[13:35:12.465]                           }
[13:35:12.465]                           else {
[13:35:12.465]                             version <- NULL
[13:35:12.465]                           }
[13:35:12.465]                           if (!has_future || version < "1.8.0") {
[13:35:12.465]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:12.465]                               "", base::R.version$version.string), 
[13:35:12.465]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:12.465]                                 base::R.version$platform, 8 * 
[13:35:12.465]                                   base::.Machine$sizeof.pointer), 
[13:35:12.465]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:12.465]                                 "release", "version")], collapse = " "), 
[13:35:12.465]                               hostname = base::Sys.info()[["nodename"]])
[13:35:12.465]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:12.465]                               info)
[13:35:12.465]                             info <- base::paste(info, collapse = "; ")
[13:35:12.465]                             if (!has_future) {
[13:35:12.465]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:12.465]                                 info)
[13:35:12.465]                             }
[13:35:12.465]                             else {
[13:35:12.465]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:12.465]                                 info, version)
[13:35:12.465]                             }
[13:35:12.465]                             base::stop(msg)
[13:35:12.465]                           }
[13:35:12.465]                         })
[13:35:12.465]                       }
[13:35:12.465]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:12.465]                       base::options(mc.cores = 1L)
[13:35:12.465]                     }
[13:35:12.465]                     base::local({
[13:35:12.465]                       for (pkg in c("stats", "future.apply")) {
[13:35:12.465]                         base::loadNamespace(pkg)
[13:35:12.465]                         base::library(pkg, character.only = TRUE)
[13:35:12.465]                       }
[13:35:12.465]                     })
[13:35:12.465]                   }
[13:35:12.465]                   ...future.strategy.old <- future::plan("list")
[13:35:12.465]                   options(future.plan = NULL)
[13:35:12.465]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:12.465]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:12.465]                 }
[13:35:12.465]                 ...future.workdir <- getwd()
[13:35:12.465]             }
[13:35:12.465]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:12.465]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:12.465]         }
[13:35:12.465]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:12.465]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:12.465]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:12.465]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:12.465]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:12.465]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:12.465]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:12.465]             base::names(...future.oldOptions))
[13:35:12.465]     }
[13:35:12.465]     if (FALSE) {
[13:35:12.465]     }
[13:35:12.465]     else {
[13:35:12.465]         if (TRUE) {
[13:35:12.465]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:12.465]                 open = "w")
[13:35:12.465]         }
[13:35:12.465]         else {
[13:35:12.465]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:12.465]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:12.465]         }
[13:35:12.465]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:12.465]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:12.465]             base::sink(type = "output", split = FALSE)
[13:35:12.465]             base::close(...future.stdout)
[13:35:12.465]         }, add = TRUE)
[13:35:12.465]     }
[13:35:12.465]     ...future.frame <- base::sys.nframe()
[13:35:12.465]     ...future.conditions <- base::list()
[13:35:12.465]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:12.465]     if (FALSE) {
[13:35:12.465]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:12.465]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:12.465]     }
[13:35:12.465]     ...future.result <- base::tryCatch({
[13:35:12.465]         base::withCallingHandlers({
[13:35:12.465]             ...future.value <- base::withVisible(base::local({
[13:35:12.465]                 ...future.makeSendCondition <- base::local({
[13:35:12.465]                   sendCondition <- NULL
[13:35:12.465]                   function(frame = 1L) {
[13:35:12.465]                     if (is.function(sendCondition)) 
[13:35:12.465]                       return(sendCondition)
[13:35:12.465]                     ns <- getNamespace("parallel")
[13:35:12.465]                     if (exists("sendData", mode = "function", 
[13:35:12.465]                       envir = ns)) {
[13:35:12.465]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:12.465]                         envir = ns)
[13:35:12.465]                       envir <- sys.frame(frame)
[13:35:12.465]                       master <- NULL
[13:35:12.465]                       while (!identical(envir, .GlobalEnv) && 
[13:35:12.465]                         !identical(envir, emptyenv())) {
[13:35:12.465]                         if (exists("master", mode = "list", envir = envir, 
[13:35:12.465]                           inherits = FALSE)) {
[13:35:12.465]                           master <- get("master", mode = "list", 
[13:35:12.465]                             envir = envir, inherits = FALSE)
[13:35:12.465]                           if (inherits(master, c("SOCKnode", 
[13:35:12.465]                             "SOCK0node"))) {
[13:35:12.465]                             sendCondition <<- function(cond) {
[13:35:12.465]                               data <- list(type = "VALUE", value = cond, 
[13:35:12.465]                                 success = TRUE)
[13:35:12.465]                               parallel_sendData(master, data)
[13:35:12.465]                             }
[13:35:12.465]                             return(sendCondition)
[13:35:12.465]                           }
[13:35:12.465]                         }
[13:35:12.465]                         frame <- frame + 1L
[13:35:12.465]                         envir <- sys.frame(frame)
[13:35:12.465]                       }
[13:35:12.465]                     }
[13:35:12.465]                     sendCondition <<- function(cond) NULL
[13:35:12.465]                   }
[13:35:12.465]                 })
[13:35:12.465]                 withCallingHandlers({
[13:35:12.465]                   {
[13:35:12.465]                     do.call(function(...) {
[13:35:12.465]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.465]                       if (!identical(...future.globals.maxSize.org, 
[13:35:12.465]                         ...future.globals.maxSize)) {
[13:35:12.465]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.465]                         on.exit(options(oopts), add = TRUE)
[13:35:12.465]                       }
[13:35:12.465]                       {
[13:35:12.465]                         lapply(seq_along(...future.elements_ii), 
[13:35:12.465]                           FUN = function(jj) {
[13:35:12.465]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.465]                             ...future.FUN(...future.X_jj, ...)
[13:35:12.465]                           })
[13:35:12.465]                       }
[13:35:12.465]                     }, args = future.call.arguments)
[13:35:12.465]                   }
[13:35:12.465]                 }, immediateCondition = function(cond) {
[13:35:12.465]                   sendCondition <- ...future.makeSendCondition()
[13:35:12.465]                   sendCondition(cond)
[13:35:12.465]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.465]                   {
[13:35:12.465]                     inherits <- base::inherits
[13:35:12.465]                     invokeRestart <- base::invokeRestart
[13:35:12.465]                     is.null <- base::is.null
[13:35:12.465]                     muffled <- FALSE
[13:35:12.465]                     if (inherits(cond, "message")) {
[13:35:12.465]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:12.465]                       if (muffled) 
[13:35:12.465]                         invokeRestart("muffleMessage")
[13:35:12.465]                     }
[13:35:12.465]                     else if (inherits(cond, "warning")) {
[13:35:12.465]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:12.465]                       if (muffled) 
[13:35:12.465]                         invokeRestart("muffleWarning")
[13:35:12.465]                     }
[13:35:12.465]                     else if (inherits(cond, "condition")) {
[13:35:12.465]                       if (!is.null(pattern)) {
[13:35:12.465]                         computeRestarts <- base::computeRestarts
[13:35:12.465]                         grepl <- base::grepl
[13:35:12.465]                         restarts <- computeRestarts(cond)
[13:35:12.465]                         for (restart in restarts) {
[13:35:12.465]                           name <- restart$name
[13:35:12.465]                           if (is.null(name)) 
[13:35:12.465]                             next
[13:35:12.465]                           if (!grepl(pattern, name)) 
[13:35:12.465]                             next
[13:35:12.465]                           invokeRestart(restart)
[13:35:12.465]                           muffled <- TRUE
[13:35:12.465]                           break
[13:35:12.465]                         }
[13:35:12.465]                       }
[13:35:12.465]                     }
[13:35:12.465]                     invisible(muffled)
[13:35:12.465]                   }
[13:35:12.465]                   muffleCondition(cond)
[13:35:12.465]                 })
[13:35:12.465]             }))
[13:35:12.465]             future::FutureResult(value = ...future.value$value, 
[13:35:12.465]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:12.465]                   ...future.rng), globalenv = if (FALSE) 
[13:35:12.465]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:12.465]                     ...future.globalenv.names))
[13:35:12.465]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:12.465]         }, condition = base::local({
[13:35:12.465]             c <- base::c
[13:35:12.465]             inherits <- base::inherits
[13:35:12.465]             invokeRestart <- base::invokeRestart
[13:35:12.465]             length <- base::length
[13:35:12.465]             list <- base::list
[13:35:12.465]             seq.int <- base::seq.int
[13:35:12.465]             signalCondition <- base::signalCondition
[13:35:12.465]             sys.calls <- base::sys.calls
[13:35:12.465]             `[[` <- base::`[[`
[13:35:12.465]             `+` <- base::`+`
[13:35:12.465]             `<<-` <- base::`<<-`
[13:35:12.465]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:12.465]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:12.465]                   3L)]
[13:35:12.465]             }
[13:35:12.465]             function(cond) {
[13:35:12.465]                 is_error <- inherits(cond, "error")
[13:35:12.465]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:12.465]                   NULL)
[13:35:12.465]                 if (is_error) {
[13:35:12.465]                   sessionInformation <- function() {
[13:35:12.465]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:12.465]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:12.465]                       search = base::search(), system = base::Sys.info())
[13:35:12.465]                   }
[13:35:12.465]                   ...future.conditions[[length(...future.conditions) + 
[13:35:12.465]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:12.465]                     cond$call), session = sessionInformation(), 
[13:35:12.465]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:12.465]                   signalCondition(cond)
[13:35:12.465]                 }
[13:35:12.465]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:12.465]                 "immediateCondition"))) {
[13:35:12.465]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:12.465]                   ...future.conditions[[length(...future.conditions) + 
[13:35:12.465]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:12.465]                   if (TRUE && !signal) {
[13:35:12.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.465]                     {
[13:35:12.465]                       inherits <- base::inherits
[13:35:12.465]                       invokeRestart <- base::invokeRestart
[13:35:12.465]                       is.null <- base::is.null
[13:35:12.465]                       muffled <- FALSE
[13:35:12.465]                       if (inherits(cond, "message")) {
[13:35:12.465]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:12.465]                         if (muffled) 
[13:35:12.465]                           invokeRestart("muffleMessage")
[13:35:12.465]                       }
[13:35:12.465]                       else if (inherits(cond, "warning")) {
[13:35:12.465]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:12.465]                         if (muffled) 
[13:35:12.465]                           invokeRestart("muffleWarning")
[13:35:12.465]                       }
[13:35:12.465]                       else if (inherits(cond, "condition")) {
[13:35:12.465]                         if (!is.null(pattern)) {
[13:35:12.465]                           computeRestarts <- base::computeRestarts
[13:35:12.465]                           grepl <- base::grepl
[13:35:12.465]                           restarts <- computeRestarts(cond)
[13:35:12.465]                           for (restart in restarts) {
[13:35:12.465]                             name <- restart$name
[13:35:12.465]                             if (is.null(name)) 
[13:35:12.465]                               next
[13:35:12.465]                             if (!grepl(pattern, name)) 
[13:35:12.465]                               next
[13:35:12.465]                             invokeRestart(restart)
[13:35:12.465]                             muffled <- TRUE
[13:35:12.465]                             break
[13:35:12.465]                           }
[13:35:12.465]                         }
[13:35:12.465]                       }
[13:35:12.465]                       invisible(muffled)
[13:35:12.465]                     }
[13:35:12.465]                     muffleCondition(cond, pattern = "^muffle")
[13:35:12.465]                   }
[13:35:12.465]                 }
[13:35:12.465]                 else {
[13:35:12.465]                   if (TRUE) {
[13:35:12.465]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.465]                     {
[13:35:12.465]                       inherits <- base::inherits
[13:35:12.465]                       invokeRestart <- base::invokeRestart
[13:35:12.465]                       is.null <- base::is.null
[13:35:12.465]                       muffled <- FALSE
[13:35:12.465]                       if (inherits(cond, "message")) {
[13:35:12.465]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:12.465]                         if (muffled) 
[13:35:12.465]                           invokeRestart("muffleMessage")
[13:35:12.465]                       }
[13:35:12.465]                       else if (inherits(cond, "warning")) {
[13:35:12.465]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:12.465]                         if (muffled) 
[13:35:12.465]                           invokeRestart("muffleWarning")
[13:35:12.465]                       }
[13:35:12.465]                       else if (inherits(cond, "condition")) {
[13:35:12.465]                         if (!is.null(pattern)) {
[13:35:12.465]                           computeRestarts <- base::computeRestarts
[13:35:12.465]                           grepl <- base::grepl
[13:35:12.465]                           restarts <- computeRestarts(cond)
[13:35:12.465]                           for (restart in restarts) {
[13:35:12.465]                             name <- restart$name
[13:35:12.465]                             if (is.null(name)) 
[13:35:12.465]                               next
[13:35:12.465]                             if (!grepl(pattern, name)) 
[13:35:12.465]                               next
[13:35:12.465]                             invokeRestart(restart)
[13:35:12.465]                             muffled <- TRUE
[13:35:12.465]                             break
[13:35:12.465]                           }
[13:35:12.465]                         }
[13:35:12.465]                       }
[13:35:12.465]                       invisible(muffled)
[13:35:12.465]                     }
[13:35:12.465]                     muffleCondition(cond, pattern = "^muffle")
[13:35:12.465]                   }
[13:35:12.465]                 }
[13:35:12.465]             }
[13:35:12.465]         }))
[13:35:12.465]     }, error = function(ex) {
[13:35:12.465]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:12.465]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:12.465]                 ...future.rng), started = ...future.startTime, 
[13:35:12.465]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:12.465]             version = "1.8"), class = "FutureResult")
[13:35:12.465]     }, finally = {
[13:35:12.465]         if (!identical(...future.workdir, getwd())) 
[13:35:12.465]             setwd(...future.workdir)
[13:35:12.465]         {
[13:35:12.465]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:12.465]                 ...future.oldOptions$nwarnings <- NULL
[13:35:12.465]             }
[13:35:12.465]             base::options(...future.oldOptions)
[13:35:12.465]             if (.Platform$OS.type == "windows") {
[13:35:12.465]                 old_names <- names(...future.oldEnvVars)
[13:35:12.465]                 envs <- base::Sys.getenv()
[13:35:12.465]                 names <- names(envs)
[13:35:12.465]                 common <- intersect(names, old_names)
[13:35:12.465]                 added <- setdiff(names, old_names)
[13:35:12.465]                 removed <- setdiff(old_names, names)
[13:35:12.465]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:12.465]                   envs[common]]
[13:35:12.465]                 NAMES <- toupper(changed)
[13:35:12.465]                 args <- list()
[13:35:12.465]                 for (kk in seq_along(NAMES)) {
[13:35:12.465]                   name <- changed[[kk]]
[13:35:12.465]                   NAME <- NAMES[[kk]]
[13:35:12.465]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.465]                     next
[13:35:12.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:12.465]                 }
[13:35:12.465]                 NAMES <- toupper(added)
[13:35:12.465]                 for (kk in seq_along(NAMES)) {
[13:35:12.465]                   name <- added[[kk]]
[13:35:12.465]                   NAME <- NAMES[[kk]]
[13:35:12.465]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.465]                     next
[13:35:12.465]                   args[[name]] <- ""
[13:35:12.465]                 }
[13:35:12.465]                 NAMES <- toupper(removed)
[13:35:12.465]                 for (kk in seq_along(NAMES)) {
[13:35:12.465]                   name <- removed[[kk]]
[13:35:12.465]                   NAME <- NAMES[[kk]]
[13:35:12.465]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.465]                     next
[13:35:12.465]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:12.465]                 }
[13:35:12.465]                 if (length(args) > 0) 
[13:35:12.465]                   base::do.call(base::Sys.setenv, args = args)
[13:35:12.465]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:12.465]             }
[13:35:12.465]             else {
[13:35:12.465]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:12.465]             }
[13:35:12.465]             {
[13:35:12.465]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:12.465]                   0L) {
[13:35:12.465]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:12.465]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:12.465]                   base::options(opts)
[13:35:12.465]                 }
[13:35:12.465]                 {
[13:35:12.465]                   {
[13:35:12.465]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:12.465]                     NULL
[13:35:12.465]                   }
[13:35:12.465]                   options(future.plan = NULL)
[13:35:12.465]                   if (is.na(NA_character_)) 
[13:35:12.465]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:12.465]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:12.465]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:12.465]                     .init = FALSE)
[13:35:12.465]                 }
[13:35:12.465]             }
[13:35:12.465]         }
[13:35:12.465]     })
[13:35:12.465]     if (TRUE) {
[13:35:12.465]         base::sink(type = "output", split = FALSE)
[13:35:12.465]         if (TRUE) {
[13:35:12.465]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:12.465]         }
[13:35:12.465]         else {
[13:35:12.465]             ...future.result["stdout"] <- base::list(NULL)
[13:35:12.465]         }
[13:35:12.465]         base::close(...future.stdout)
[13:35:12.465]         ...future.stdout <- NULL
[13:35:12.465]     }
[13:35:12.465]     ...future.result$conditions <- ...future.conditions
[13:35:12.465]     ...future.result$finished <- base::Sys.time()
[13:35:12.465]     ...future.result
[13:35:12.465] }
[13:35:12.469] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[13:35:12.469] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:12.510] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:12.511] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[13:35:12.511] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:35:12.511] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:12.511] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:12.512] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:12.556] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:12.557] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:12.598] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:12.599] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:12.599] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.599] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:12.600] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:12.600] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:12.600] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.600] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[13:35:12.601] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[13:35:12.601] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:12.601] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.602] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:12.602] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.602] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[13:35:12.603] MultisessionFuture started
[13:35:12.603] - Launch lazy future ... done
[13:35:12.603] run() for ‘MultisessionFuture’ ... done
[13:35:12.603] Created future:
[13:35:12.606] receiveMessageFromWorker() for ClusterFuture ...
[13:35:12.606] - Validating connection of MultisessionFuture
[13:35:12.607] - received message: FutureResult
[13:35:12.607] - Received FutureResult
[13:35:12.607] - Erased future from FutureRegistry
[13:35:12.607] result() for ClusterFuture ...
[13:35:12.607] - result already collected: FutureResult
[13:35:12.607] result() for ClusterFuture ... done
[13:35:12.607] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:12.603] MultisessionFuture:
[13:35:12.603] Label: ‘future_vapply-1’
[13:35:12.603] Expression:
[13:35:12.603] {
[13:35:12.603]     do.call(function(...) {
[13:35:12.603]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.603]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.603]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.603]             on.exit(options(oopts), add = TRUE)
[13:35:12.603]         }
[13:35:12.603]         {
[13:35:12.603]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.603]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.603]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.603]             })
[13:35:12.603]         }
[13:35:12.603]     }, args = future.call.arguments)
[13:35:12.603] }
[13:35:12.603] Lazy evaluation: FALSE
[13:35:12.603] Asynchronous evaluation: TRUE
[13:35:12.603] Local evaluation: TRUE
[13:35:12.603] Environment: R_GlobalEnv
[13:35:12.603] Capture standard output: TRUE
[13:35:12.603] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:12.603] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:12.603] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:35:12.603] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:12.603] Resolved: TRUE
[13:35:12.603] Value: <not collected>
[13:35:12.603] Conditions captured: <none>
[13:35:12.603] Early signaling: FALSE
[13:35:12.603] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:12.603] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:12.608] Chunk #1 of 2 ... DONE
[13:35:12.608] Chunk #2 of 2 ...
[13:35:12.608]  - Finding globals in 'X' for chunk #2 ...
[13:35:12.608] getGlobalsAndPackages() ...
[13:35:12.608] Searching for globals...
[13:35:12.608] 
[13:35:12.608] Searching for globals ... DONE
[13:35:12.608] - globals: [0] <none>
[13:35:12.608] getGlobalsAndPackages() ... DONE
[13:35:12.609]    + additional globals found: [n=0] 
[13:35:12.609]    + additional namespaces needed: [n=0] 
[13:35:12.609]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:12.609]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:12.609]  - seeds: <none>
[13:35:12.609]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.609] getGlobalsAndPackages() ...
[13:35:12.609] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.609] Resolving globals: FALSE
[13:35:12.609] Tweak future expression to call with '...' arguments ...
[13:35:12.610] {
[13:35:12.610]     do.call(function(...) {
[13:35:12.610]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.610]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.610]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.610]             on.exit(options(oopts), add = TRUE)
[13:35:12.610]         }
[13:35:12.610]         {
[13:35:12.610]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.610]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.610]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.610]             })
[13:35:12.610]         }
[13:35:12.610]     }, args = future.call.arguments)
[13:35:12.610] }
[13:35:12.610] Tweak future expression to call with '...' arguments ... DONE
[13:35:12.610] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.611] - packages: [2] ‘stats’, ‘future.apply’
[13:35:12.611] getGlobalsAndPackages() ... DONE
[13:35:12.611] run() for ‘Future’ ...
[13:35:12.611] - state: ‘created’
[13:35:12.611] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:12.625] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:12.625] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:12.625]   - Field: ‘node’
[13:35:12.626]   - Field: ‘label’
[13:35:12.626]   - Field: ‘local’
[13:35:12.626]   - Field: ‘owner’
[13:35:12.626]   - Field: ‘envir’
[13:35:12.626]   - Field: ‘workers’
[13:35:12.626]   - Field: ‘packages’
[13:35:12.626]   - Field: ‘gc’
[13:35:12.626]   - Field: ‘conditions’
[13:35:12.626]   - Field: ‘persistent’
[13:35:12.626]   - Field: ‘expr’
[13:35:12.626]   - Field: ‘uuid’
[13:35:12.627]   - Field: ‘seed’
[13:35:12.627]   - Field: ‘version’
[13:35:12.627]   - Field: ‘result’
[13:35:12.627]   - Field: ‘asynchronous’
[13:35:12.627]   - Field: ‘calls’
[13:35:12.627]   - Field: ‘globals’
[13:35:12.627]   - Field: ‘stdout’
[13:35:12.627]   - Field: ‘earlySignal’
[13:35:12.627]   - Field: ‘lazy’
[13:35:12.627]   - Field: ‘state’
[13:35:12.627] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:12.628] - Launch lazy future ...
[13:35:12.628] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:35:12.628] Packages needed by future strategies (n = 0): <none>
[13:35:12.629] {
[13:35:12.629]     {
[13:35:12.629]         {
[13:35:12.629]             ...future.startTime <- base::Sys.time()
[13:35:12.629]             {
[13:35:12.629]                 {
[13:35:12.629]                   {
[13:35:12.629]                     {
[13:35:12.629]                       {
[13:35:12.629]                         base::local({
[13:35:12.629]                           has_future <- base::requireNamespace("future", 
[13:35:12.629]                             quietly = TRUE)
[13:35:12.629]                           if (has_future) {
[13:35:12.629]                             ns <- base::getNamespace("future")
[13:35:12.629]                             version <- ns[[".package"]][["version"]]
[13:35:12.629]                             if (is.null(version)) 
[13:35:12.629]                               version <- utils::packageVersion("future")
[13:35:12.629]                           }
[13:35:12.629]                           else {
[13:35:12.629]                             version <- NULL
[13:35:12.629]                           }
[13:35:12.629]                           if (!has_future || version < "1.8.0") {
[13:35:12.629]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:12.629]                               "", base::R.version$version.string), 
[13:35:12.629]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:12.629]                                 base::R.version$platform, 8 * 
[13:35:12.629]                                   base::.Machine$sizeof.pointer), 
[13:35:12.629]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:12.629]                                 "release", "version")], collapse = " "), 
[13:35:12.629]                               hostname = base::Sys.info()[["nodename"]])
[13:35:12.629]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:12.629]                               info)
[13:35:12.629]                             info <- base::paste(info, collapse = "; ")
[13:35:12.629]                             if (!has_future) {
[13:35:12.629]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:12.629]                                 info)
[13:35:12.629]                             }
[13:35:12.629]                             else {
[13:35:12.629]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:12.629]                                 info, version)
[13:35:12.629]                             }
[13:35:12.629]                             base::stop(msg)
[13:35:12.629]                           }
[13:35:12.629]                         })
[13:35:12.629]                       }
[13:35:12.629]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:12.629]                       base::options(mc.cores = 1L)
[13:35:12.629]                     }
[13:35:12.629]                     base::local({
[13:35:12.629]                       for (pkg in c("stats", "future.apply")) {
[13:35:12.629]                         base::loadNamespace(pkg)
[13:35:12.629]                         base::library(pkg, character.only = TRUE)
[13:35:12.629]                       }
[13:35:12.629]                     })
[13:35:12.629]                   }
[13:35:12.629]                   ...future.strategy.old <- future::plan("list")
[13:35:12.629]                   options(future.plan = NULL)
[13:35:12.629]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:12.629]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:12.629]                 }
[13:35:12.629]                 ...future.workdir <- getwd()
[13:35:12.629]             }
[13:35:12.629]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:12.629]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:12.629]         }
[13:35:12.629]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:12.629]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:12.629]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:12.629]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:12.629]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:12.629]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:12.629]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:12.629]             base::names(...future.oldOptions))
[13:35:12.629]     }
[13:35:12.629]     if (FALSE) {
[13:35:12.629]     }
[13:35:12.629]     else {
[13:35:12.629]         if (TRUE) {
[13:35:12.629]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:12.629]                 open = "w")
[13:35:12.629]         }
[13:35:12.629]         else {
[13:35:12.629]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:12.629]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:12.629]         }
[13:35:12.629]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:12.629]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:12.629]             base::sink(type = "output", split = FALSE)
[13:35:12.629]             base::close(...future.stdout)
[13:35:12.629]         }, add = TRUE)
[13:35:12.629]     }
[13:35:12.629]     ...future.frame <- base::sys.nframe()
[13:35:12.629]     ...future.conditions <- base::list()
[13:35:12.629]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:12.629]     if (FALSE) {
[13:35:12.629]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:12.629]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:12.629]     }
[13:35:12.629]     ...future.result <- base::tryCatch({
[13:35:12.629]         base::withCallingHandlers({
[13:35:12.629]             ...future.value <- base::withVisible(base::local({
[13:35:12.629]                 ...future.makeSendCondition <- base::local({
[13:35:12.629]                   sendCondition <- NULL
[13:35:12.629]                   function(frame = 1L) {
[13:35:12.629]                     if (is.function(sendCondition)) 
[13:35:12.629]                       return(sendCondition)
[13:35:12.629]                     ns <- getNamespace("parallel")
[13:35:12.629]                     if (exists("sendData", mode = "function", 
[13:35:12.629]                       envir = ns)) {
[13:35:12.629]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:12.629]                         envir = ns)
[13:35:12.629]                       envir <- sys.frame(frame)
[13:35:12.629]                       master <- NULL
[13:35:12.629]                       while (!identical(envir, .GlobalEnv) && 
[13:35:12.629]                         !identical(envir, emptyenv())) {
[13:35:12.629]                         if (exists("master", mode = "list", envir = envir, 
[13:35:12.629]                           inherits = FALSE)) {
[13:35:12.629]                           master <- get("master", mode = "list", 
[13:35:12.629]                             envir = envir, inherits = FALSE)
[13:35:12.629]                           if (inherits(master, c("SOCKnode", 
[13:35:12.629]                             "SOCK0node"))) {
[13:35:12.629]                             sendCondition <<- function(cond) {
[13:35:12.629]                               data <- list(type = "VALUE", value = cond, 
[13:35:12.629]                                 success = TRUE)
[13:35:12.629]                               parallel_sendData(master, data)
[13:35:12.629]                             }
[13:35:12.629]                             return(sendCondition)
[13:35:12.629]                           }
[13:35:12.629]                         }
[13:35:12.629]                         frame <- frame + 1L
[13:35:12.629]                         envir <- sys.frame(frame)
[13:35:12.629]                       }
[13:35:12.629]                     }
[13:35:12.629]                     sendCondition <<- function(cond) NULL
[13:35:12.629]                   }
[13:35:12.629]                 })
[13:35:12.629]                 withCallingHandlers({
[13:35:12.629]                   {
[13:35:12.629]                     do.call(function(...) {
[13:35:12.629]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.629]                       if (!identical(...future.globals.maxSize.org, 
[13:35:12.629]                         ...future.globals.maxSize)) {
[13:35:12.629]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.629]                         on.exit(options(oopts), add = TRUE)
[13:35:12.629]                       }
[13:35:12.629]                       {
[13:35:12.629]                         lapply(seq_along(...future.elements_ii), 
[13:35:12.629]                           FUN = function(jj) {
[13:35:12.629]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.629]                             ...future.FUN(...future.X_jj, ...)
[13:35:12.629]                           })
[13:35:12.629]                       }
[13:35:12.629]                     }, args = future.call.arguments)
[13:35:12.629]                   }
[13:35:12.629]                 }, immediateCondition = function(cond) {
[13:35:12.629]                   sendCondition <- ...future.makeSendCondition()
[13:35:12.629]                   sendCondition(cond)
[13:35:12.629]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.629]                   {
[13:35:12.629]                     inherits <- base::inherits
[13:35:12.629]                     invokeRestart <- base::invokeRestart
[13:35:12.629]                     is.null <- base::is.null
[13:35:12.629]                     muffled <- FALSE
[13:35:12.629]                     if (inherits(cond, "message")) {
[13:35:12.629]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:12.629]                       if (muffled) 
[13:35:12.629]                         invokeRestart("muffleMessage")
[13:35:12.629]                     }
[13:35:12.629]                     else if (inherits(cond, "warning")) {
[13:35:12.629]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:12.629]                       if (muffled) 
[13:35:12.629]                         invokeRestart("muffleWarning")
[13:35:12.629]                     }
[13:35:12.629]                     else if (inherits(cond, "condition")) {
[13:35:12.629]                       if (!is.null(pattern)) {
[13:35:12.629]                         computeRestarts <- base::computeRestarts
[13:35:12.629]                         grepl <- base::grepl
[13:35:12.629]                         restarts <- computeRestarts(cond)
[13:35:12.629]                         for (restart in restarts) {
[13:35:12.629]                           name <- restart$name
[13:35:12.629]                           if (is.null(name)) 
[13:35:12.629]                             next
[13:35:12.629]                           if (!grepl(pattern, name)) 
[13:35:12.629]                             next
[13:35:12.629]                           invokeRestart(restart)
[13:35:12.629]                           muffled <- TRUE
[13:35:12.629]                           break
[13:35:12.629]                         }
[13:35:12.629]                       }
[13:35:12.629]                     }
[13:35:12.629]                     invisible(muffled)
[13:35:12.629]                   }
[13:35:12.629]                   muffleCondition(cond)
[13:35:12.629]                 })
[13:35:12.629]             }))
[13:35:12.629]             future::FutureResult(value = ...future.value$value, 
[13:35:12.629]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:12.629]                   ...future.rng), globalenv = if (FALSE) 
[13:35:12.629]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:12.629]                     ...future.globalenv.names))
[13:35:12.629]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:12.629]         }, condition = base::local({
[13:35:12.629]             c <- base::c
[13:35:12.629]             inherits <- base::inherits
[13:35:12.629]             invokeRestart <- base::invokeRestart
[13:35:12.629]             length <- base::length
[13:35:12.629]             list <- base::list
[13:35:12.629]             seq.int <- base::seq.int
[13:35:12.629]             signalCondition <- base::signalCondition
[13:35:12.629]             sys.calls <- base::sys.calls
[13:35:12.629]             `[[` <- base::`[[`
[13:35:12.629]             `+` <- base::`+`
[13:35:12.629]             `<<-` <- base::`<<-`
[13:35:12.629]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:12.629]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:12.629]                   3L)]
[13:35:12.629]             }
[13:35:12.629]             function(cond) {
[13:35:12.629]                 is_error <- inherits(cond, "error")
[13:35:12.629]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:12.629]                   NULL)
[13:35:12.629]                 if (is_error) {
[13:35:12.629]                   sessionInformation <- function() {
[13:35:12.629]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:12.629]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:12.629]                       search = base::search(), system = base::Sys.info())
[13:35:12.629]                   }
[13:35:12.629]                   ...future.conditions[[length(...future.conditions) + 
[13:35:12.629]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:12.629]                     cond$call), session = sessionInformation(), 
[13:35:12.629]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:12.629]                   signalCondition(cond)
[13:35:12.629]                 }
[13:35:12.629]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:12.629]                 "immediateCondition"))) {
[13:35:12.629]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:12.629]                   ...future.conditions[[length(...future.conditions) + 
[13:35:12.629]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:12.629]                   if (TRUE && !signal) {
[13:35:12.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.629]                     {
[13:35:12.629]                       inherits <- base::inherits
[13:35:12.629]                       invokeRestart <- base::invokeRestart
[13:35:12.629]                       is.null <- base::is.null
[13:35:12.629]                       muffled <- FALSE
[13:35:12.629]                       if (inherits(cond, "message")) {
[13:35:12.629]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:12.629]                         if (muffled) 
[13:35:12.629]                           invokeRestart("muffleMessage")
[13:35:12.629]                       }
[13:35:12.629]                       else if (inherits(cond, "warning")) {
[13:35:12.629]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:12.629]                         if (muffled) 
[13:35:12.629]                           invokeRestart("muffleWarning")
[13:35:12.629]                       }
[13:35:12.629]                       else if (inherits(cond, "condition")) {
[13:35:12.629]                         if (!is.null(pattern)) {
[13:35:12.629]                           computeRestarts <- base::computeRestarts
[13:35:12.629]                           grepl <- base::grepl
[13:35:12.629]                           restarts <- computeRestarts(cond)
[13:35:12.629]                           for (restart in restarts) {
[13:35:12.629]                             name <- restart$name
[13:35:12.629]                             if (is.null(name)) 
[13:35:12.629]                               next
[13:35:12.629]                             if (!grepl(pattern, name)) 
[13:35:12.629]                               next
[13:35:12.629]                             invokeRestart(restart)
[13:35:12.629]                             muffled <- TRUE
[13:35:12.629]                             break
[13:35:12.629]                           }
[13:35:12.629]                         }
[13:35:12.629]                       }
[13:35:12.629]                       invisible(muffled)
[13:35:12.629]                     }
[13:35:12.629]                     muffleCondition(cond, pattern = "^muffle")
[13:35:12.629]                   }
[13:35:12.629]                 }
[13:35:12.629]                 else {
[13:35:12.629]                   if (TRUE) {
[13:35:12.629]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.629]                     {
[13:35:12.629]                       inherits <- base::inherits
[13:35:12.629]                       invokeRestart <- base::invokeRestart
[13:35:12.629]                       is.null <- base::is.null
[13:35:12.629]                       muffled <- FALSE
[13:35:12.629]                       if (inherits(cond, "message")) {
[13:35:12.629]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:12.629]                         if (muffled) 
[13:35:12.629]                           invokeRestart("muffleMessage")
[13:35:12.629]                       }
[13:35:12.629]                       else if (inherits(cond, "warning")) {
[13:35:12.629]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:12.629]                         if (muffled) 
[13:35:12.629]                           invokeRestart("muffleWarning")
[13:35:12.629]                       }
[13:35:12.629]                       else if (inherits(cond, "condition")) {
[13:35:12.629]                         if (!is.null(pattern)) {
[13:35:12.629]                           computeRestarts <- base::computeRestarts
[13:35:12.629]                           grepl <- base::grepl
[13:35:12.629]                           restarts <- computeRestarts(cond)
[13:35:12.629]                           for (restart in restarts) {
[13:35:12.629]                             name <- restart$name
[13:35:12.629]                             if (is.null(name)) 
[13:35:12.629]                               next
[13:35:12.629]                             if (!grepl(pattern, name)) 
[13:35:12.629]                               next
[13:35:12.629]                             invokeRestart(restart)
[13:35:12.629]                             muffled <- TRUE
[13:35:12.629]                             break
[13:35:12.629]                           }
[13:35:12.629]                         }
[13:35:12.629]                       }
[13:35:12.629]                       invisible(muffled)
[13:35:12.629]                     }
[13:35:12.629]                     muffleCondition(cond, pattern = "^muffle")
[13:35:12.629]                   }
[13:35:12.629]                 }
[13:35:12.629]             }
[13:35:12.629]         }))
[13:35:12.629]     }, error = function(ex) {
[13:35:12.629]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:12.629]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:12.629]                 ...future.rng), started = ...future.startTime, 
[13:35:12.629]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:12.629]             version = "1.8"), class = "FutureResult")
[13:35:12.629]     }, finally = {
[13:35:12.629]         if (!identical(...future.workdir, getwd())) 
[13:35:12.629]             setwd(...future.workdir)
[13:35:12.629]         {
[13:35:12.629]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:12.629]                 ...future.oldOptions$nwarnings <- NULL
[13:35:12.629]             }
[13:35:12.629]             base::options(...future.oldOptions)
[13:35:12.629]             if (.Platform$OS.type == "windows") {
[13:35:12.629]                 old_names <- names(...future.oldEnvVars)
[13:35:12.629]                 envs <- base::Sys.getenv()
[13:35:12.629]                 names <- names(envs)
[13:35:12.629]                 common <- intersect(names, old_names)
[13:35:12.629]                 added <- setdiff(names, old_names)
[13:35:12.629]                 removed <- setdiff(old_names, names)
[13:35:12.629]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:12.629]                   envs[common]]
[13:35:12.629]                 NAMES <- toupper(changed)
[13:35:12.629]                 args <- list()
[13:35:12.629]                 for (kk in seq_along(NAMES)) {
[13:35:12.629]                   name <- changed[[kk]]
[13:35:12.629]                   NAME <- NAMES[[kk]]
[13:35:12.629]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.629]                     next
[13:35:12.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:12.629]                 }
[13:35:12.629]                 NAMES <- toupper(added)
[13:35:12.629]                 for (kk in seq_along(NAMES)) {
[13:35:12.629]                   name <- added[[kk]]
[13:35:12.629]                   NAME <- NAMES[[kk]]
[13:35:12.629]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.629]                     next
[13:35:12.629]                   args[[name]] <- ""
[13:35:12.629]                 }
[13:35:12.629]                 NAMES <- toupper(removed)
[13:35:12.629]                 for (kk in seq_along(NAMES)) {
[13:35:12.629]                   name <- removed[[kk]]
[13:35:12.629]                   NAME <- NAMES[[kk]]
[13:35:12.629]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.629]                     next
[13:35:12.629]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:12.629]                 }
[13:35:12.629]                 if (length(args) > 0) 
[13:35:12.629]                   base::do.call(base::Sys.setenv, args = args)
[13:35:12.629]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:12.629]             }
[13:35:12.629]             else {
[13:35:12.629]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:12.629]             }
[13:35:12.629]             {
[13:35:12.629]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:12.629]                   0L) {
[13:35:12.629]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:12.629]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:12.629]                   base::options(opts)
[13:35:12.629]                 }
[13:35:12.629]                 {
[13:35:12.629]                   {
[13:35:12.629]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:12.629]                     NULL
[13:35:12.629]                   }
[13:35:12.629]                   options(future.plan = NULL)
[13:35:12.629]                   if (is.na(NA_character_)) 
[13:35:12.629]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:12.629]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:12.629]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:12.629]                     .init = FALSE)
[13:35:12.629]                 }
[13:35:12.629]             }
[13:35:12.629]         }
[13:35:12.629]     })
[13:35:12.629]     if (TRUE) {
[13:35:12.629]         base::sink(type = "output", split = FALSE)
[13:35:12.629]         if (TRUE) {
[13:35:12.629]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:12.629]         }
[13:35:12.629]         else {
[13:35:12.629]             ...future.result["stdout"] <- base::list(NULL)
[13:35:12.629]         }
[13:35:12.629]         base::close(...future.stdout)
[13:35:12.629]         ...future.stdout <- NULL
[13:35:12.629]     }
[13:35:12.629]     ...future.result$conditions <- ...future.conditions
[13:35:12.629]     ...future.result$finished <- base::Sys.time()
[13:35:12.629]     ...future.result
[13:35:12.629] }
[13:35:12.631] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[13:35:12.631] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:12.674] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:12.675] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[13:35:12.675] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[13:35:12.675] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:12.676] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:12.676] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:12.718] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:12.719] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:12.762] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:12.763] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:12.763] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.763] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:12.764] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:12.764] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:12.764] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.764] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #1 ...
[13:35:12.765] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #1 ... DONE
[13:35:12.765] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:12.765] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.765] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:12.766] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.766] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[13:35:12.766] MultisessionFuture started
[13:35:12.766] - Launch lazy future ... done
[13:35:12.766] run() for ‘MultisessionFuture’ ... done
[13:35:12.767] Created future:
[13:35:12.767] MultisessionFuture:
[13:35:12.767] Label: ‘future_vapply-2’
[13:35:12.767] Expression:
[13:35:12.767] {
[13:35:12.767]     do.call(function(...) {
[13:35:12.767]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.767]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.767]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.767]             on.exit(options(oopts), add = TRUE)
[13:35:12.767]         }
[13:35:12.767]         {
[13:35:12.767]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.767]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.767]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.767]             })
[13:35:12.767]         }
[13:35:12.767]     }, args = future.call.arguments)
[13:35:12.767] }
[13:35:12.767] Lazy evaluation: FALSE
[13:35:12.767] Asynchronous evaluation: TRUE
[13:35:12.767] Local evaluation: TRUE
[13:35:12.767] Environment: R_GlobalEnv
[13:35:12.767] Capture standard output: TRUE
[13:35:12.767] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:12.767] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:12.767] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:35:12.767] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:12.767] Resolved: FALSE
[13:35:12.767] Value: <not collected>
[13:35:12.767] Conditions captured: <none>
[13:35:12.767] Early signaling: FALSE
[13:35:12.767] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:12.767] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:12.778] Chunk #2 of 2 ... DONE
[13:35:12.778] Launching 2 futures (chunks) ... DONE
[13:35:12.779] Resolving 2 futures (chunks) ...
[13:35:12.779] resolve() on list ...
[13:35:12.779]  recursive: 0
[13:35:12.779]  length: 2
[13:35:12.779] 
[13:35:12.779] Future #1
[13:35:12.779] result() for ClusterFuture ...
[13:35:12.779] - result already collected: FutureResult
[13:35:12.779] result() for ClusterFuture ... done
[13:35:12.779] result() for ClusterFuture ...
[13:35:12.780] - result already collected: FutureResult
[13:35:12.780] result() for ClusterFuture ... done
[13:35:12.780] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:12.780] - nx: 2
[13:35:12.780] - relay: TRUE
[13:35:12.780] - stdout: TRUE
[13:35:12.780] - signal: TRUE
[13:35:12.780] - resignal: FALSE
[13:35:12.780] - force: TRUE
[13:35:12.780] - relayed: [n=2] FALSE, FALSE
[13:35:12.780] - queued futures: [n=2] FALSE, FALSE
[13:35:12.781]  - until=1
[13:35:12.781]  - relaying element #1
[13:35:12.781] result() for ClusterFuture ...
[13:35:12.781] - result already collected: FutureResult
[13:35:12.781] result() for ClusterFuture ... done
[13:35:12.781] result() for ClusterFuture ...
[13:35:12.781] - result already collected: FutureResult
[13:35:12.781] result() for ClusterFuture ... done
[13:35:12.781] result() for ClusterFuture ...
[13:35:12.781] - result already collected: FutureResult
[13:35:12.781] result() for ClusterFuture ... done
[13:35:12.782] result() for ClusterFuture ...
[13:35:12.782] - result already collected: FutureResult
[13:35:12.782] result() for ClusterFuture ... done
[13:35:12.782] - relayed: [n=2] TRUE, FALSE
[13:35:12.782] - queued futures: [n=2] TRUE, FALSE
[13:35:12.782] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:12.782]  length: 1 (resolved future 1)
[13:35:12.812] receiveMessageFromWorker() for ClusterFuture ...
[13:35:12.812] - Validating connection of MultisessionFuture
[13:35:12.813] - received message: FutureResult
[13:35:12.813] - Received FutureResult
[13:35:12.813] - Erased future from FutureRegistry
[13:35:12.813] result() for ClusterFuture ...
[13:35:12.813] - result already collected: FutureResult
[13:35:12.813] result() for ClusterFuture ... done
[13:35:12.813] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:12.813] Future #2
[13:35:12.814] result() for ClusterFuture ...
[13:35:12.814] - result already collected: FutureResult
[13:35:12.814] result() for ClusterFuture ... done
[13:35:12.814] result() for ClusterFuture ...
[13:35:12.814] - result already collected: FutureResult
[13:35:12.814] result() for ClusterFuture ... done
[13:35:12.814] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:12.814] - nx: 2
[13:35:12.814] - relay: TRUE
[13:35:12.814] - stdout: TRUE
[13:35:12.815] - signal: TRUE
[13:35:12.815] - resignal: FALSE
[13:35:12.815] - force: TRUE
[13:35:12.815] - relayed: [n=2] TRUE, FALSE
[13:35:12.815] - queued futures: [n=2] TRUE, FALSE
[13:35:12.815]  - until=2
[13:35:12.815]  - relaying element #2
[13:35:12.815] result() for ClusterFuture ...
[13:35:12.815] - result already collected: FutureResult
[13:35:12.815] result() for ClusterFuture ... done
[13:35:12.815] result() for ClusterFuture ...
[13:35:12.815] - result already collected: FutureResult
[13:35:12.816] result() for ClusterFuture ... done
[13:35:12.816] result() for ClusterFuture ...
[13:35:12.816] - result already collected: FutureResult
[13:35:12.816] result() for ClusterFuture ... done
[13:35:12.816] result() for ClusterFuture ...
[13:35:12.816] - result already collected: FutureResult
[13:35:12.816] result() for ClusterFuture ... done
[13:35:12.816] - relayed: [n=2] TRUE, TRUE
[13:35:12.816] - queued futures: [n=2] TRUE, TRUE
[13:35:12.816] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:12.816]  length: 0 (resolved future 2)
[13:35:12.817] Relaying remaining futures
[13:35:12.817] signalConditionsASAP(NULL, pos=0) ...
[13:35:12.817] - nx: 2
[13:35:12.817] - relay: TRUE
[13:35:12.817] - stdout: TRUE
[13:35:12.817] - signal: TRUE
[13:35:12.817] - resignal: FALSE
[13:35:12.817] - force: TRUE
[13:35:12.817] - relayed: [n=2] TRUE, TRUE
[13:35:12.817] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:12.817] - relayed: [n=2] TRUE, TRUE
[13:35:12.817] - queued futures: [n=2] TRUE, TRUE
[13:35:12.818] signalConditionsASAP(NULL, pos=0) ... done
[13:35:12.818] resolve() on list ... DONE
[13:35:12.818] result() for ClusterFuture ...
[13:35:12.818] - result already collected: FutureResult
[13:35:12.818] result() for ClusterFuture ... done
[13:35:12.818] result() for ClusterFuture ...
[13:35:12.818] - result already collected: FutureResult
[13:35:12.818] result() for ClusterFuture ... done
[13:35:12.818] result() for ClusterFuture ...
[13:35:12.818] - result already collected: FutureResult
[13:35:12.818] result() for ClusterFuture ... done
[13:35:12.819] result() for ClusterFuture ...
[13:35:12.819] - result already collected: FutureResult
[13:35:12.819] result() for ClusterFuture ... done
[13:35:12.819]  - Number of value chunks collected: 2
[13:35:12.819] Resolving 2 futures (chunks) ... DONE
[13:35:12.819] Reducing values from 2 chunks ...
[13:35:12.819]  - Number of values collected after concatenation: 3
[13:35:12.819]  - Number of values expected: 3
[13:35:12.819] Reducing values from 2 chunks ... DONE
[13:35:12.819] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[13:35:12.821] future_lapply() ...
[13:35:12.829] Number of chunks: 2
[13:35:12.829] getGlobalsAndPackagesXApply() ...
[13:35:12.829]  - future.globals: TRUE
[13:35:12.829] getGlobalsAndPackages() ...
[13:35:12.829] Searching for globals...
[13:35:12.834] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:35:12.834] Searching for globals ... DONE
[13:35:12.834] Resolving globals: FALSE
[13:35:12.835] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[13:35:12.835] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[13:35:12.835] - globals: [1] ‘FUN’
[13:35:12.835] - packages: [1] ‘stats’
[13:35:12.835] getGlobalsAndPackages() ... DONE
[13:35:12.835]  - globals found/used: [n=1] ‘FUN’
[13:35:12.836]  - needed namespaces: [n=1] ‘stats’
[13:35:12.836] Finding globals ... DONE
[13:35:12.836]  - use_args: TRUE
[13:35:12.836]  - Getting '...' globals ...
[13:35:12.836] resolve() on list ...
[13:35:12.836]  recursive: 0
[13:35:12.836]  length: 1
[13:35:12.836]  elements: ‘...’
[13:35:12.836]  length: 0 (resolved future 1)
[13:35:12.837] resolve() on list ... DONE
[13:35:12.837]    - '...' content: [n=0] 
[13:35:12.837] List of 1
[13:35:12.837]  $ ...: list()
[13:35:12.837]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:12.837]  - attr(*, "where")=List of 1
[13:35:12.837]   ..$ ...:<environment: 0x5574d1d7cd00> 
[13:35:12.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:12.837]  - attr(*, "resolved")= logi TRUE
[13:35:12.837]  - attr(*, "total_size")= num NA
[13:35:12.839]  - Getting '...' globals ... DONE
[13:35:12.839] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:12.840] List of 2
[13:35:12.840]  $ ...future.FUN:function (x, na.rm = TRUE)  
[13:35:12.840]  $ ...          : list()
[13:35:12.840]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:12.840]  - attr(*, "where")=List of 2
[13:35:12.840]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:12.840]   ..$ ...          :<environment: 0x5574d1d7cd00> 
[13:35:12.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:12.840]  - attr(*, "resolved")= logi FALSE
[13:35:12.840]  - attr(*, "total_size")= num 46960
[13:35:12.842] Packages to be attached in all futures: [n=1] ‘stats’
[13:35:12.842] getGlobalsAndPackagesXApply() ... DONE
[13:35:12.842] Number of futures (= number of chunks): 2
[13:35:12.843] Launching 2 futures (chunks) ...
[13:35:12.843] Chunk #1 of 2 ...
[13:35:12.843]  - Finding globals in 'X' for chunk #1 ...
[13:35:12.843] getGlobalsAndPackages() ...
[13:35:12.843] Searching for globals...
[13:35:12.843] 
[13:35:12.843] Searching for globals ... DONE
[13:35:12.843] - globals: [0] <none>
[13:35:12.843] getGlobalsAndPackages() ... DONE
[13:35:12.844]    + additional globals found: [n=0] 
[13:35:12.844]    + additional namespaces needed: [n=0] 
[13:35:12.844]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:12.844]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:12.844]  - seeds: <none>
[13:35:12.844]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.844] getGlobalsAndPackages() ...
[13:35:12.844] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.844] Resolving globals: FALSE
[13:35:12.844] Tweak future expression to call with '...' arguments ...
[13:35:12.844] {
[13:35:12.844]     do.call(function(...) {
[13:35:12.844]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.844]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.844]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.844]             on.exit(options(oopts), add = TRUE)
[13:35:12.844]         }
[13:35:12.844]         {
[13:35:12.844]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.844]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.844]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.844]             })
[13:35:12.844]         }
[13:35:12.844]     }, args = future.call.arguments)
[13:35:12.844] }
[13:35:12.845] Tweak future expression to call with '...' arguments ... DONE
[13:35:12.845] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.845] - packages: [1] ‘stats’
[13:35:12.845] getGlobalsAndPackages() ... DONE
[13:35:12.846] run() for ‘Future’ ...
[13:35:12.846] - state: ‘created’
[13:35:12.846] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:12.860] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:12.860] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:12.860]   - Field: ‘node’
[13:35:12.860]   - Field: ‘label’
[13:35:12.860]   - Field: ‘local’
[13:35:12.860]   - Field: ‘owner’
[13:35:12.860]   - Field: ‘envir’
[13:35:12.861]   - Field: ‘workers’
[13:35:12.861]   - Field: ‘packages’
[13:35:12.861]   - Field: ‘gc’
[13:35:12.861]   - Field: ‘conditions’
[13:35:12.861]   - Field: ‘persistent’
[13:35:12.861]   - Field: ‘expr’
[13:35:12.861]   - Field: ‘uuid’
[13:35:12.861]   - Field: ‘seed’
[13:35:12.861]   - Field: ‘version’
[13:35:12.861]   - Field: ‘result’
[13:35:12.861]   - Field: ‘asynchronous’
[13:35:12.862]   - Field: ‘calls’
[13:35:12.862]   - Field: ‘globals’
[13:35:12.862]   - Field: ‘stdout’
[13:35:12.862]   - Field: ‘earlySignal’
[13:35:12.862]   - Field: ‘lazy’
[13:35:12.862]   - Field: ‘state’
[13:35:12.862] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:12.862] - Launch lazy future ...
[13:35:12.863] Packages needed by the future expression (n = 1): ‘stats’
[13:35:12.863] Packages needed by future strategies (n = 0): <none>
[13:35:12.863] {
[13:35:12.863]     {
[13:35:12.863]         {
[13:35:12.863]             ...future.startTime <- base::Sys.time()
[13:35:12.863]             {
[13:35:12.863]                 {
[13:35:12.863]                   {
[13:35:12.863]                     {
[13:35:12.863]                       {
[13:35:12.863]                         base::local({
[13:35:12.863]                           has_future <- base::requireNamespace("future", 
[13:35:12.863]                             quietly = TRUE)
[13:35:12.863]                           if (has_future) {
[13:35:12.863]                             ns <- base::getNamespace("future")
[13:35:12.863]                             version <- ns[[".package"]][["version"]]
[13:35:12.863]                             if (is.null(version)) 
[13:35:12.863]                               version <- utils::packageVersion("future")
[13:35:12.863]                           }
[13:35:12.863]                           else {
[13:35:12.863]                             version <- NULL
[13:35:12.863]                           }
[13:35:12.863]                           if (!has_future || version < "1.8.0") {
[13:35:12.863]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:12.863]                               "", base::R.version$version.string), 
[13:35:12.863]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:12.863]                                 base::R.version$platform, 8 * 
[13:35:12.863]                                   base::.Machine$sizeof.pointer), 
[13:35:12.863]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:12.863]                                 "release", "version")], collapse = " "), 
[13:35:12.863]                               hostname = base::Sys.info()[["nodename"]])
[13:35:12.863]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:12.863]                               info)
[13:35:12.863]                             info <- base::paste(info, collapse = "; ")
[13:35:12.863]                             if (!has_future) {
[13:35:12.863]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:12.863]                                 info)
[13:35:12.863]                             }
[13:35:12.863]                             else {
[13:35:12.863]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:12.863]                                 info, version)
[13:35:12.863]                             }
[13:35:12.863]                             base::stop(msg)
[13:35:12.863]                           }
[13:35:12.863]                         })
[13:35:12.863]                       }
[13:35:12.863]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:12.863]                       base::options(mc.cores = 1L)
[13:35:12.863]                     }
[13:35:12.863]                     base::local({
[13:35:12.863]                       for (pkg in "stats") {
[13:35:12.863]                         base::loadNamespace(pkg)
[13:35:12.863]                         base::library(pkg, character.only = TRUE)
[13:35:12.863]                       }
[13:35:12.863]                     })
[13:35:12.863]                   }
[13:35:12.863]                   ...future.strategy.old <- future::plan("list")
[13:35:12.863]                   options(future.plan = NULL)
[13:35:12.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:12.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:12.863]                 }
[13:35:12.863]                 ...future.workdir <- getwd()
[13:35:12.863]             }
[13:35:12.863]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:12.863]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:12.863]         }
[13:35:12.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:12.863]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:12.863]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:12.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:12.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:12.863]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:12.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:12.863]             base::names(...future.oldOptions))
[13:35:12.863]     }
[13:35:12.863]     if (FALSE) {
[13:35:12.863]     }
[13:35:12.863]     else {
[13:35:12.863]         if (TRUE) {
[13:35:12.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:12.863]                 open = "w")
[13:35:12.863]         }
[13:35:12.863]         else {
[13:35:12.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:12.863]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:12.863]         }
[13:35:12.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:12.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:12.863]             base::sink(type = "output", split = FALSE)
[13:35:12.863]             base::close(...future.stdout)
[13:35:12.863]         }, add = TRUE)
[13:35:12.863]     }
[13:35:12.863]     ...future.frame <- base::sys.nframe()
[13:35:12.863]     ...future.conditions <- base::list()
[13:35:12.863]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:12.863]     if (FALSE) {
[13:35:12.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:12.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:12.863]     }
[13:35:12.863]     ...future.result <- base::tryCatch({
[13:35:12.863]         base::withCallingHandlers({
[13:35:12.863]             ...future.value <- base::withVisible(base::local({
[13:35:12.863]                 ...future.makeSendCondition <- base::local({
[13:35:12.863]                   sendCondition <- NULL
[13:35:12.863]                   function(frame = 1L) {
[13:35:12.863]                     if (is.function(sendCondition)) 
[13:35:12.863]                       return(sendCondition)
[13:35:12.863]                     ns <- getNamespace("parallel")
[13:35:12.863]                     if (exists("sendData", mode = "function", 
[13:35:12.863]                       envir = ns)) {
[13:35:12.863]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:12.863]                         envir = ns)
[13:35:12.863]                       envir <- sys.frame(frame)
[13:35:12.863]                       master <- NULL
[13:35:12.863]                       while (!identical(envir, .GlobalEnv) && 
[13:35:12.863]                         !identical(envir, emptyenv())) {
[13:35:12.863]                         if (exists("master", mode = "list", envir = envir, 
[13:35:12.863]                           inherits = FALSE)) {
[13:35:12.863]                           master <- get("master", mode = "list", 
[13:35:12.863]                             envir = envir, inherits = FALSE)
[13:35:12.863]                           if (inherits(master, c("SOCKnode", 
[13:35:12.863]                             "SOCK0node"))) {
[13:35:12.863]                             sendCondition <<- function(cond) {
[13:35:12.863]                               data <- list(type = "VALUE", value = cond, 
[13:35:12.863]                                 success = TRUE)
[13:35:12.863]                               parallel_sendData(master, data)
[13:35:12.863]                             }
[13:35:12.863]                             return(sendCondition)
[13:35:12.863]                           }
[13:35:12.863]                         }
[13:35:12.863]                         frame <- frame + 1L
[13:35:12.863]                         envir <- sys.frame(frame)
[13:35:12.863]                       }
[13:35:12.863]                     }
[13:35:12.863]                     sendCondition <<- function(cond) NULL
[13:35:12.863]                   }
[13:35:12.863]                 })
[13:35:12.863]                 withCallingHandlers({
[13:35:12.863]                   {
[13:35:12.863]                     do.call(function(...) {
[13:35:12.863]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.863]                       if (!identical(...future.globals.maxSize.org, 
[13:35:12.863]                         ...future.globals.maxSize)) {
[13:35:12.863]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.863]                         on.exit(options(oopts), add = TRUE)
[13:35:12.863]                       }
[13:35:12.863]                       {
[13:35:12.863]                         lapply(seq_along(...future.elements_ii), 
[13:35:12.863]                           FUN = function(jj) {
[13:35:12.863]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.863]                             ...future.FUN(...future.X_jj, ...)
[13:35:12.863]                           })
[13:35:12.863]                       }
[13:35:12.863]                     }, args = future.call.arguments)
[13:35:12.863]                   }
[13:35:12.863]                 }, immediateCondition = function(cond) {
[13:35:12.863]                   sendCondition <- ...future.makeSendCondition()
[13:35:12.863]                   sendCondition(cond)
[13:35:12.863]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.863]                   {
[13:35:12.863]                     inherits <- base::inherits
[13:35:12.863]                     invokeRestart <- base::invokeRestart
[13:35:12.863]                     is.null <- base::is.null
[13:35:12.863]                     muffled <- FALSE
[13:35:12.863]                     if (inherits(cond, "message")) {
[13:35:12.863]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:12.863]                       if (muffled) 
[13:35:12.863]                         invokeRestart("muffleMessage")
[13:35:12.863]                     }
[13:35:12.863]                     else if (inherits(cond, "warning")) {
[13:35:12.863]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:12.863]                       if (muffled) 
[13:35:12.863]                         invokeRestart("muffleWarning")
[13:35:12.863]                     }
[13:35:12.863]                     else if (inherits(cond, "condition")) {
[13:35:12.863]                       if (!is.null(pattern)) {
[13:35:12.863]                         computeRestarts <- base::computeRestarts
[13:35:12.863]                         grepl <- base::grepl
[13:35:12.863]                         restarts <- computeRestarts(cond)
[13:35:12.863]                         for (restart in restarts) {
[13:35:12.863]                           name <- restart$name
[13:35:12.863]                           if (is.null(name)) 
[13:35:12.863]                             next
[13:35:12.863]                           if (!grepl(pattern, name)) 
[13:35:12.863]                             next
[13:35:12.863]                           invokeRestart(restart)
[13:35:12.863]                           muffled <- TRUE
[13:35:12.863]                           break
[13:35:12.863]                         }
[13:35:12.863]                       }
[13:35:12.863]                     }
[13:35:12.863]                     invisible(muffled)
[13:35:12.863]                   }
[13:35:12.863]                   muffleCondition(cond)
[13:35:12.863]                 })
[13:35:12.863]             }))
[13:35:12.863]             future::FutureResult(value = ...future.value$value, 
[13:35:12.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:12.863]                   ...future.rng), globalenv = if (FALSE) 
[13:35:12.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:12.863]                     ...future.globalenv.names))
[13:35:12.863]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:12.863]         }, condition = base::local({
[13:35:12.863]             c <- base::c
[13:35:12.863]             inherits <- base::inherits
[13:35:12.863]             invokeRestart <- base::invokeRestart
[13:35:12.863]             length <- base::length
[13:35:12.863]             list <- base::list
[13:35:12.863]             seq.int <- base::seq.int
[13:35:12.863]             signalCondition <- base::signalCondition
[13:35:12.863]             sys.calls <- base::sys.calls
[13:35:12.863]             `[[` <- base::`[[`
[13:35:12.863]             `+` <- base::`+`
[13:35:12.863]             `<<-` <- base::`<<-`
[13:35:12.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:12.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:12.863]                   3L)]
[13:35:12.863]             }
[13:35:12.863]             function(cond) {
[13:35:12.863]                 is_error <- inherits(cond, "error")
[13:35:12.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:12.863]                   NULL)
[13:35:12.863]                 if (is_error) {
[13:35:12.863]                   sessionInformation <- function() {
[13:35:12.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:12.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:12.863]                       search = base::search(), system = base::Sys.info())
[13:35:12.863]                   }
[13:35:12.863]                   ...future.conditions[[length(...future.conditions) + 
[13:35:12.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:12.863]                     cond$call), session = sessionInformation(), 
[13:35:12.863]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:12.863]                   signalCondition(cond)
[13:35:12.863]                 }
[13:35:12.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:12.863]                 "immediateCondition"))) {
[13:35:12.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:12.863]                   ...future.conditions[[length(...future.conditions) + 
[13:35:12.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:12.863]                   if (TRUE && !signal) {
[13:35:12.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.863]                     {
[13:35:12.863]                       inherits <- base::inherits
[13:35:12.863]                       invokeRestart <- base::invokeRestart
[13:35:12.863]                       is.null <- base::is.null
[13:35:12.863]                       muffled <- FALSE
[13:35:12.863]                       if (inherits(cond, "message")) {
[13:35:12.863]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:12.863]                         if (muffled) 
[13:35:12.863]                           invokeRestart("muffleMessage")
[13:35:12.863]                       }
[13:35:12.863]                       else if (inherits(cond, "warning")) {
[13:35:12.863]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:12.863]                         if (muffled) 
[13:35:12.863]                           invokeRestart("muffleWarning")
[13:35:12.863]                       }
[13:35:12.863]                       else if (inherits(cond, "condition")) {
[13:35:12.863]                         if (!is.null(pattern)) {
[13:35:12.863]                           computeRestarts <- base::computeRestarts
[13:35:12.863]                           grepl <- base::grepl
[13:35:12.863]                           restarts <- computeRestarts(cond)
[13:35:12.863]                           for (restart in restarts) {
[13:35:12.863]                             name <- restart$name
[13:35:12.863]                             if (is.null(name)) 
[13:35:12.863]                               next
[13:35:12.863]                             if (!grepl(pattern, name)) 
[13:35:12.863]                               next
[13:35:12.863]                             invokeRestart(restart)
[13:35:12.863]                             muffled <- TRUE
[13:35:12.863]                             break
[13:35:12.863]                           }
[13:35:12.863]                         }
[13:35:12.863]                       }
[13:35:12.863]                       invisible(muffled)
[13:35:12.863]                     }
[13:35:12.863]                     muffleCondition(cond, pattern = "^muffle")
[13:35:12.863]                   }
[13:35:12.863]                 }
[13:35:12.863]                 else {
[13:35:12.863]                   if (TRUE) {
[13:35:12.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.863]                     {
[13:35:12.863]                       inherits <- base::inherits
[13:35:12.863]                       invokeRestart <- base::invokeRestart
[13:35:12.863]                       is.null <- base::is.null
[13:35:12.863]                       muffled <- FALSE
[13:35:12.863]                       if (inherits(cond, "message")) {
[13:35:12.863]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:12.863]                         if (muffled) 
[13:35:12.863]                           invokeRestart("muffleMessage")
[13:35:12.863]                       }
[13:35:12.863]                       else if (inherits(cond, "warning")) {
[13:35:12.863]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:12.863]                         if (muffled) 
[13:35:12.863]                           invokeRestart("muffleWarning")
[13:35:12.863]                       }
[13:35:12.863]                       else if (inherits(cond, "condition")) {
[13:35:12.863]                         if (!is.null(pattern)) {
[13:35:12.863]                           computeRestarts <- base::computeRestarts
[13:35:12.863]                           grepl <- base::grepl
[13:35:12.863]                           restarts <- computeRestarts(cond)
[13:35:12.863]                           for (restart in restarts) {
[13:35:12.863]                             name <- restart$name
[13:35:12.863]                             if (is.null(name)) 
[13:35:12.863]                               next
[13:35:12.863]                             if (!grepl(pattern, name)) 
[13:35:12.863]                               next
[13:35:12.863]                             invokeRestart(restart)
[13:35:12.863]                             muffled <- TRUE
[13:35:12.863]                             break
[13:35:12.863]                           }
[13:35:12.863]                         }
[13:35:12.863]                       }
[13:35:12.863]                       invisible(muffled)
[13:35:12.863]                     }
[13:35:12.863]                     muffleCondition(cond, pattern = "^muffle")
[13:35:12.863]                   }
[13:35:12.863]                 }
[13:35:12.863]             }
[13:35:12.863]         }))
[13:35:12.863]     }, error = function(ex) {
[13:35:12.863]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:12.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:12.863]                 ...future.rng), started = ...future.startTime, 
[13:35:12.863]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:12.863]             version = "1.8"), class = "FutureResult")
[13:35:12.863]     }, finally = {
[13:35:12.863]         if (!identical(...future.workdir, getwd())) 
[13:35:12.863]             setwd(...future.workdir)
[13:35:12.863]         {
[13:35:12.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:12.863]                 ...future.oldOptions$nwarnings <- NULL
[13:35:12.863]             }
[13:35:12.863]             base::options(...future.oldOptions)
[13:35:12.863]             if (.Platform$OS.type == "windows") {
[13:35:12.863]                 old_names <- names(...future.oldEnvVars)
[13:35:12.863]                 envs <- base::Sys.getenv()
[13:35:12.863]                 names <- names(envs)
[13:35:12.863]                 common <- intersect(names, old_names)
[13:35:12.863]                 added <- setdiff(names, old_names)
[13:35:12.863]                 removed <- setdiff(old_names, names)
[13:35:12.863]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:12.863]                   envs[common]]
[13:35:12.863]                 NAMES <- toupper(changed)
[13:35:12.863]                 args <- list()
[13:35:12.863]                 for (kk in seq_along(NAMES)) {
[13:35:12.863]                   name <- changed[[kk]]
[13:35:12.863]                   NAME <- NAMES[[kk]]
[13:35:12.863]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.863]                     next
[13:35:12.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:12.863]                 }
[13:35:12.863]                 NAMES <- toupper(added)
[13:35:12.863]                 for (kk in seq_along(NAMES)) {
[13:35:12.863]                   name <- added[[kk]]
[13:35:12.863]                   NAME <- NAMES[[kk]]
[13:35:12.863]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.863]                     next
[13:35:12.863]                   args[[name]] <- ""
[13:35:12.863]                 }
[13:35:12.863]                 NAMES <- toupper(removed)
[13:35:12.863]                 for (kk in seq_along(NAMES)) {
[13:35:12.863]                   name <- removed[[kk]]
[13:35:12.863]                   NAME <- NAMES[[kk]]
[13:35:12.863]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.863]                     next
[13:35:12.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:12.863]                 }
[13:35:12.863]                 if (length(args) > 0) 
[13:35:12.863]                   base::do.call(base::Sys.setenv, args = args)
[13:35:12.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:12.863]             }
[13:35:12.863]             else {
[13:35:12.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:12.863]             }
[13:35:12.863]             {
[13:35:12.863]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:12.863]                   0L) {
[13:35:12.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:12.863]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:12.863]                   base::options(opts)
[13:35:12.863]                 }
[13:35:12.863]                 {
[13:35:12.863]                   {
[13:35:12.863]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:12.863]                     NULL
[13:35:12.863]                   }
[13:35:12.863]                   options(future.plan = NULL)
[13:35:12.863]                   if (is.na(NA_character_)) 
[13:35:12.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:12.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:12.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:12.863]                     .init = FALSE)
[13:35:12.863]                 }
[13:35:12.863]             }
[13:35:12.863]         }
[13:35:12.863]     })
[13:35:12.863]     if (TRUE) {
[13:35:12.863]         base::sink(type = "output", split = FALSE)
[13:35:12.863]         if (TRUE) {
[13:35:12.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:12.863]         }
[13:35:12.863]         else {
[13:35:12.863]             ...future.result["stdout"] <- base::list(NULL)
[13:35:12.863]         }
[13:35:12.863]         base::close(...future.stdout)
[13:35:12.863]         ...future.stdout <- NULL
[13:35:12.863]     }
[13:35:12.863]     ...future.result$conditions <- ...future.conditions
[13:35:12.863]     ...future.result$finished <- base::Sys.time()
[13:35:12.863]     ...future.result
[13:35:12.863] }
[13:35:12.866] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[13:35:12.866] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[13:35:12.910] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[13:35:12.911] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:12.911] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.911] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[13:35:12.912] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[13:35:12.912] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:12.912] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.912] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:12.912] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:12.913] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[13:35:12.913] MultisessionFuture started
[13:35:12.913] - Launch lazy future ... done
[13:35:12.913] run() for ‘MultisessionFuture’ ... done
[13:35:12.913] Created future:
[13:35:12.913] MultisessionFuture:
[13:35:12.913] Label: ‘future_sapply-1’
[13:35:12.913] Expression:
[13:35:12.913] {
[13:35:12.913]     do.call(function(...) {
[13:35:12.913]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.913]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.913]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.913]             on.exit(options(oopts), add = TRUE)
[13:35:12.913]         }
[13:35:12.913]         {
[13:35:12.913]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.913]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.913]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.913]             })
[13:35:12.913]         }
[13:35:12.913]     }, args = future.call.arguments)
[13:35:12.913] }
[13:35:12.913] Lazy evaluation: FALSE
[13:35:12.913] Asynchronous evaluation: TRUE
[13:35:12.913] Local evaluation: TRUE
[13:35:12.913] Environment: R_GlobalEnv
[13:35:12.913] Capture standard output: TRUE
[13:35:12.913] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:12.913] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:12.913] Packages: 1 packages (‘stats’)
[13:35:12.913] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:12.913] Resolved: FALSE
[13:35:12.913] Value: <not collected>
[13:35:12.913] Conditions captured: <none>
[13:35:12.913] Early signaling: FALSE
[13:35:12.913] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:12.913] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:12.925] Chunk #1 of 2 ... DONE
[13:35:12.925] Chunk #2 of 2 ...
[13:35:12.925]  - Finding globals in 'X' for chunk #2 ...
[13:35:12.925] getGlobalsAndPackages() ...
[13:35:12.926] Searching for globals...
[13:35:12.926] 
[13:35:12.926] Searching for globals ... DONE
[13:35:12.926] - globals: [0] <none>
[13:35:12.926] getGlobalsAndPackages() ... DONE
[13:35:12.926]    + additional globals found: [n=0] 
[13:35:12.926]    + additional namespaces needed: [n=0] 
[13:35:12.926]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:12.927]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:12.927]  - seeds: <none>
[13:35:12.927]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.927] getGlobalsAndPackages() ...
[13:35:12.927] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.927] Resolving globals: FALSE
[13:35:12.927] Tweak future expression to call with '...' arguments ...
[13:35:12.927] {
[13:35:12.927]     do.call(function(...) {
[13:35:12.927]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.927]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.927]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.927]             on.exit(options(oopts), add = TRUE)
[13:35:12.927]         }
[13:35:12.927]         {
[13:35:12.927]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.927]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.927]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.927]             })
[13:35:12.927]         }
[13:35:12.927]     }, args = future.call.arguments)
[13:35:12.927] }
[13:35:12.930] Tweak future expression to call with '...' arguments ... DONE
[13:35:12.931] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:12.931] - packages: [1] ‘stats’
[13:35:12.931] getGlobalsAndPackages() ... DONE
[13:35:12.931] run() for ‘Future’ ...
[13:35:12.931] - state: ‘created’
[13:35:12.931] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:12.946] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:12.946] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:12.946]   - Field: ‘node’
[13:35:12.946]   - Field: ‘label’
[13:35:12.946]   - Field: ‘local’
[13:35:12.946]   - Field: ‘owner’
[13:35:12.946]   - Field: ‘envir’
[13:35:12.946]   - Field: ‘workers’
[13:35:12.946]   - Field: ‘packages’
[13:35:12.947]   - Field: ‘gc’
[13:35:12.947]   - Field: ‘conditions’
[13:35:12.947]   - Field: ‘persistent’
[13:35:12.947]   - Field: ‘expr’
[13:35:12.947]   - Field: ‘uuid’
[13:35:12.947]   - Field: ‘seed’
[13:35:12.947]   - Field: ‘version’
[13:35:12.947]   - Field: ‘result’
[13:35:12.947]   - Field: ‘asynchronous’
[13:35:12.947]   - Field: ‘calls’
[13:35:12.947]   - Field: ‘globals’
[13:35:12.948]   - Field: ‘stdout’
[13:35:12.948]   - Field: ‘earlySignal’
[13:35:12.948]   - Field: ‘lazy’
[13:35:12.948]   - Field: ‘state’
[13:35:12.948] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:12.948] - Launch lazy future ...
[13:35:12.948] Packages needed by the future expression (n = 1): ‘stats’
[13:35:12.948] Packages needed by future strategies (n = 0): <none>
[13:35:12.949] {
[13:35:12.949]     {
[13:35:12.949]         {
[13:35:12.949]             ...future.startTime <- base::Sys.time()
[13:35:12.949]             {
[13:35:12.949]                 {
[13:35:12.949]                   {
[13:35:12.949]                     {
[13:35:12.949]                       {
[13:35:12.949]                         base::local({
[13:35:12.949]                           has_future <- base::requireNamespace("future", 
[13:35:12.949]                             quietly = TRUE)
[13:35:12.949]                           if (has_future) {
[13:35:12.949]                             ns <- base::getNamespace("future")
[13:35:12.949]                             version <- ns[[".package"]][["version"]]
[13:35:12.949]                             if (is.null(version)) 
[13:35:12.949]                               version <- utils::packageVersion("future")
[13:35:12.949]                           }
[13:35:12.949]                           else {
[13:35:12.949]                             version <- NULL
[13:35:12.949]                           }
[13:35:12.949]                           if (!has_future || version < "1.8.0") {
[13:35:12.949]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:12.949]                               "", base::R.version$version.string), 
[13:35:12.949]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:12.949]                                 base::R.version$platform, 8 * 
[13:35:12.949]                                   base::.Machine$sizeof.pointer), 
[13:35:12.949]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:12.949]                                 "release", "version")], collapse = " "), 
[13:35:12.949]                               hostname = base::Sys.info()[["nodename"]])
[13:35:12.949]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:12.949]                               info)
[13:35:12.949]                             info <- base::paste(info, collapse = "; ")
[13:35:12.949]                             if (!has_future) {
[13:35:12.949]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:12.949]                                 info)
[13:35:12.949]                             }
[13:35:12.949]                             else {
[13:35:12.949]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:12.949]                                 info, version)
[13:35:12.949]                             }
[13:35:12.949]                             base::stop(msg)
[13:35:12.949]                           }
[13:35:12.949]                         })
[13:35:12.949]                       }
[13:35:12.949]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:12.949]                       base::options(mc.cores = 1L)
[13:35:12.949]                     }
[13:35:12.949]                     base::local({
[13:35:12.949]                       for (pkg in "stats") {
[13:35:12.949]                         base::loadNamespace(pkg)
[13:35:12.949]                         base::library(pkg, character.only = TRUE)
[13:35:12.949]                       }
[13:35:12.949]                     })
[13:35:12.949]                   }
[13:35:12.949]                   ...future.strategy.old <- future::plan("list")
[13:35:12.949]                   options(future.plan = NULL)
[13:35:12.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:12.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:12.949]                 }
[13:35:12.949]                 ...future.workdir <- getwd()
[13:35:12.949]             }
[13:35:12.949]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:12.949]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:12.949]         }
[13:35:12.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:12.949]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:12.949]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:12.949]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:12.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:12.949]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:12.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:12.949]             base::names(...future.oldOptions))
[13:35:12.949]     }
[13:35:12.949]     if (FALSE) {
[13:35:12.949]     }
[13:35:12.949]     else {
[13:35:12.949]         if (TRUE) {
[13:35:12.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:12.949]                 open = "w")
[13:35:12.949]         }
[13:35:12.949]         else {
[13:35:12.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:12.949]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:12.949]         }
[13:35:12.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:12.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:12.949]             base::sink(type = "output", split = FALSE)
[13:35:12.949]             base::close(...future.stdout)
[13:35:12.949]         }, add = TRUE)
[13:35:12.949]     }
[13:35:12.949]     ...future.frame <- base::sys.nframe()
[13:35:12.949]     ...future.conditions <- base::list()
[13:35:12.949]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:12.949]     if (FALSE) {
[13:35:12.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:12.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:12.949]     }
[13:35:12.949]     ...future.result <- base::tryCatch({
[13:35:12.949]         base::withCallingHandlers({
[13:35:12.949]             ...future.value <- base::withVisible(base::local({
[13:35:12.949]                 ...future.makeSendCondition <- base::local({
[13:35:12.949]                   sendCondition <- NULL
[13:35:12.949]                   function(frame = 1L) {
[13:35:12.949]                     if (is.function(sendCondition)) 
[13:35:12.949]                       return(sendCondition)
[13:35:12.949]                     ns <- getNamespace("parallel")
[13:35:12.949]                     if (exists("sendData", mode = "function", 
[13:35:12.949]                       envir = ns)) {
[13:35:12.949]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:12.949]                         envir = ns)
[13:35:12.949]                       envir <- sys.frame(frame)
[13:35:12.949]                       master <- NULL
[13:35:12.949]                       while (!identical(envir, .GlobalEnv) && 
[13:35:12.949]                         !identical(envir, emptyenv())) {
[13:35:12.949]                         if (exists("master", mode = "list", envir = envir, 
[13:35:12.949]                           inherits = FALSE)) {
[13:35:12.949]                           master <- get("master", mode = "list", 
[13:35:12.949]                             envir = envir, inherits = FALSE)
[13:35:12.949]                           if (inherits(master, c("SOCKnode", 
[13:35:12.949]                             "SOCK0node"))) {
[13:35:12.949]                             sendCondition <<- function(cond) {
[13:35:12.949]                               data <- list(type = "VALUE", value = cond, 
[13:35:12.949]                                 success = TRUE)
[13:35:12.949]                               parallel_sendData(master, data)
[13:35:12.949]                             }
[13:35:12.949]                             return(sendCondition)
[13:35:12.949]                           }
[13:35:12.949]                         }
[13:35:12.949]                         frame <- frame + 1L
[13:35:12.949]                         envir <- sys.frame(frame)
[13:35:12.949]                       }
[13:35:12.949]                     }
[13:35:12.949]                     sendCondition <<- function(cond) NULL
[13:35:12.949]                   }
[13:35:12.949]                 })
[13:35:12.949]                 withCallingHandlers({
[13:35:12.949]                   {
[13:35:12.949]                     do.call(function(...) {
[13:35:12.949]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.949]                       if (!identical(...future.globals.maxSize.org, 
[13:35:12.949]                         ...future.globals.maxSize)) {
[13:35:12.949]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.949]                         on.exit(options(oopts), add = TRUE)
[13:35:12.949]                       }
[13:35:12.949]                       {
[13:35:12.949]                         lapply(seq_along(...future.elements_ii), 
[13:35:12.949]                           FUN = function(jj) {
[13:35:12.949]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.949]                             ...future.FUN(...future.X_jj, ...)
[13:35:12.949]                           })
[13:35:12.949]                       }
[13:35:12.949]                     }, args = future.call.arguments)
[13:35:12.949]                   }
[13:35:12.949]                 }, immediateCondition = function(cond) {
[13:35:12.949]                   sendCondition <- ...future.makeSendCondition()
[13:35:12.949]                   sendCondition(cond)
[13:35:12.949]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.949]                   {
[13:35:12.949]                     inherits <- base::inherits
[13:35:12.949]                     invokeRestart <- base::invokeRestart
[13:35:12.949]                     is.null <- base::is.null
[13:35:12.949]                     muffled <- FALSE
[13:35:12.949]                     if (inherits(cond, "message")) {
[13:35:12.949]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:12.949]                       if (muffled) 
[13:35:12.949]                         invokeRestart("muffleMessage")
[13:35:12.949]                     }
[13:35:12.949]                     else if (inherits(cond, "warning")) {
[13:35:12.949]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:12.949]                       if (muffled) 
[13:35:12.949]                         invokeRestart("muffleWarning")
[13:35:12.949]                     }
[13:35:12.949]                     else if (inherits(cond, "condition")) {
[13:35:12.949]                       if (!is.null(pattern)) {
[13:35:12.949]                         computeRestarts <- base::computeRestarts
[13:35:12.949]                         grepl <- base::grepl
[13:35:12.949]                         restarts <- computeRestarts(cond)
[13:35:12.949]                         for (restart in restarts) {
[13:35:12.949]                           name <- restart$name
[13:35:12.949]                           if (is.null(name)) 
[13:35:12.949]                             next
[13:35:12.949]                           if (!grepl(pattern, name)) 
[13:35:12.949]                             next
[13:35:12.949]                           invokeRestart(restart)
[13:35:12.949]                           muffled <- TRUE
[13:35:12.949]                           break
[13:35:12.949]                         }
[13:35:12.949]                       }
[13:35:12.949]                     }
[13:35:12.949]                     invisible(muffled)
[13:35:12.949]                   }
[13:35:12.949]                   muffleCondition(cond)
[13:35:12.949]                 })
[13:35:12.949]             }))
[13:35:12.949]             future::FutureResult(value = ...future.value$value, 
[13:35:12.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:12.949]                   ...future.rng), globalenv = if (FALSE) 
[13:35:12.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:12.949]                     ...future.globalenv.names))
[13:35:12.949]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:12.949]         }, condition = base::local({
[13:35:12.949]             c <- base::c
[13:35:12.949]             inherits <- base::inherits
[13:35:12.949]             invokeRestart <- base::invokeRestart
[13:35:12.949]             length <- base::length
[13:35:12.949]             list <- base::list
[13:35:12.949]             seq.int <- base::seq.int
[13:35:12.949]             signalCondition <- base::signalCondition
[13:35:12.949]             sys.calls <- base::sys.calls
[13:35:12.949]             `[[` <- base::`[[`
[13:35:12.949]             `+` <- base::`+`
[13:35:12.949]             `<<-` <- base::`<<-`
[13:35:12.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:12.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:12.949]                   3L)]
[13:35:12.949]             }
[13:35:12.949]             function(cond) {
[13:35:12.949]                 is_error <- inherits(cond, "error")
[13:35:12.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:12.949]                   NULL)
[13:35:12.949]                 if (is_error) {
[13:35:12.949]                   sessionInformation <- function() {
[13:35:12.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:12.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:12.949]                       search = base::search(), system = base::Sys.info())
[13:35:12.949]                   }
[13:35:12.949]                   ...future.conditions[[length(...future.conditions) + 
[13:35:12.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:12.949]                     cond$call), session = sessionInformation(), 
[13:35:12.949]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:12.949]                   signalCondition(cond)
[13:35:12.949]                 }
[13:35:12.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:12.949]                 "immediateCondition"))) {
[13:35:12.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:12.949]                   ...future.conditions[[length(...future.conditions) + 
[13:35:12.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:12.949]                   if (TRUE && !signal) {
[13:35:12.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.949]                     {
[13:35:12.949]                       inherits <- base::inherits
[13:35:12.949]                       invokeRestart <- base::invokeRestart
[13:35:12.949]                       is.null <- base::is.null
[13:35:12.949]                       muffled <- FALSE
[13:35:12.949]                       if (inherits(cond, "message")) {
[13:35:12.949]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:12.949]                         if (muffled) 
[13:35:12.949]                           invokeRestart("muffleMessage")
[13:35:12.949]                       }
[13:35:12.949]                       else if (inherits(cond, "warning")) {
[13:35:12.949]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:12.949]                         if (muffled) 
[13:35:12.949]                           invokeRestart("muffleWarning")
[13:35:12.949]                       }
[13:35:12.949]                       else if (inherits(cond, "condition")) {
[13:35:12.949]                         if (!is.null(pattern)) {
[13:35:12.949]                           computeRestarts <- base::computeRestarts
[13:35:12.949]                           grepl <- base::grepl
[13:35:12.949]                           restarts <- computeRestarts(cond)
[13:35:12.949]                           for (restart in restarts) {
[13:35:12.949]                             name <- restart$name
[13:35:12.949]                             if (is.null(name)) 
[13:35:12.949]                               next
[13:35:12.949]                             if (!grepl(pattern, name)) 
[13:35:12.949]                               next
[13:35:12.949]                             invokeRestart(restart)
[13:35:12.949]                             muffled <- TRUE
[13:35:12.949]                             break
[13:35:12.949]                           }
[13:35:12.949]                         }
[13:35:12.949]                       }
[13:35:12.949]                       invisible(muffled)
[13:35:12.949]                     }
[13:35:12.949]                     muffleCondition(cond, pattern = "^muffle")
[13:35:12.949]                   }
[13:35:12.949]                 }
[13:35:12.949]                 else {
[13:35:12.949]                   if (TRUE) {
[13:35:12.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:12.949]                     {
[13:35:12.949]                       inherits <- base::inherits
[13:35:12.949]                       invokeRestart <- base::invokeRestart
[13:35:12.949]                       is.null <- base::is.null
[13:35:12.949]                       muffled <- FALSE
[13:35:12.949]                       if (inherits(cond, "message")) {
[13:35:12.949]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:12.949]                         if (muffled) 
[13:35:12.949]                           invokeRestart("muffleMessage")
[13:35:12.949]                       }
[13:35:12.949]                       else if (inherits(cond, "warning")) {
[13:35:12.949]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:12.949]                         if (muffled) 
[13:35:12.949]                           invokeRestart("muffleWarning")
[13:35:12.949]                       }
[13:35:12.949]                       else if (inherits(cond, "condition")) {
[13:35:12.949]                         if (!is.null(pattern)) {
[13:35:12.949]                           computeRestarts <- base::computeRestarts
[13:35:12.949]                           grepl <- base::grepl
[13:35:12.949]                           restarts <- computeRestarts(cond)
[13:35:12.949]                           for (restart in restarts) {
[13:35:12.949]                             name <- restart$name
[13:35:12.949]                             if (is.null(name)) 
[13:35:12.949]                               next
[13:35:12.949]                             if (!grepl(pattern, name)) 
[13:35:12.949]                               next
[13:35:12.949]                             invokeRestart(restart)
[13:35:12.949]                             muffled <- TRUE
[13:35:12.949]                             break
[13:35:12.949]                           }
[13:35:12.949]                         }
[13:35:12.949]                       }
[13:35:12.949]                       invisible(muffled)
[13:35:12.949]                     }
[13:35:12.949]                     muffleCondition(cond, pattern = "^muffle")
[13:35:12.949]                   }
[13:35:12.949]                 }
[13:35:12.949]             }
[13:35:12.949]         }))
[13:35:12.949]     }, error = function(ex) {
[13:35:12.949]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:12.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:12.949]                 ...future.rng), started = ...future.startTime, 
[13:35:12.949]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:12.949]             version = "1.8"), class = "FutureResult")
[13:35:12.949]     }, finally = {
[13:35:12.949]         if (!identical(...future.workdir, getwd())) 
[13:35:12.949]             setwd(...future.workdir)
[13:35:12.949]         {
[13:35:12.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:12.949]                 ...future.oldOptions$nwarnings <- NULL
[13:35:12.949]             }
[13:35:12.949]             base::options(...future.oldOptions)
[13:35:12.949]             if (.Platform$OS.type == "windows") {
[13:35:12.949]                 old_names <- names(...future.oldEnvVars)
[13:35:12.949]                 envs <- base::Sys.getenv()
[13:35:12.949]                 names <- names(envs)
[13:35:12.949]                 common <- intersect(names, old_names)
[13:35:12.949]                 added <- setdiff(names, old_names)
[13:35:12.949]                 removed <- setdiff(old_names, names)
[13:35:12.949]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:12.949]                   envs[common]]
[13:35:12.949]                 NAMES <- toupper(changed)
[13:35:12.949]                 args <- list()
[13:35:12.949]                 for (kk in seq_along(NAMES)) {
[13:35:12.949]                   name <- changed[[kk]]
[13:35:12.949]                   NAME <- NAMES[[kk]]
[13:35:12.949]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.949]                     next
[13:35:12.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:12.949]                 }
[13:35:12.949]                 NAMES <- toupper(added)
[13:35:12.949]                 for (kk in seq_along(NAMES)) {
[13:35:12.949]                   name <- added[[kk]]
[13:35:12.949]                   NAME <- NAMES[[kk]]
[13:35:12.949]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.949]                     next
[13:35:12.949]                   args[[name]] <- ""
[13:35:12.949]                 }
[13:35:12.949]                 NAMES <- toupper(removed)
[13:35:12.949]                 for (kk in seq_along(NAMES)) {
[13:35:12.949]                   name <- removed[[kk]]
[13:35:12.949]                   NAME <- NAMES[[kk]]
[13:35:12.949]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:12.949]                     next
[13:35:12.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:12.949]                 }
[13:35:12.949]                 if (length(args) > 0) 
[13:35:12.949]                   base::do.call(base::Sys.setenv, args = args)
[13:35:12.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:12.949]             }
[13:35:12.949]             else {
[13:35:12.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:12.949]             }
[13:35:12.949]             {
[13:35:12.949]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:12.949]                   0L) {
[13:35:12.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:12.949]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:12.949]                   base::options(opts)
[13:35:12.949]                 }
[13:35:12.949]                 {
[13:35:12.949]                   {
[13:35:12.949]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:12.949]                     NULL
[13:35:12.949]                   }
[13:35:12.949]                   options(future.plan = NULL)
[13:35:12.949]                   if (is.na(NA_character_)) 
[13:35:12.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:12.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:12.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:12.949]                     .init = FALSE)
[13:35:12.949]                 }
[13:35:12.949]             }
[13:35:12.949]         }
[13:35:12.949]     })
[13:35:12.949]     if (TRUE) {
[13:35:12.949]         base::sink(type = "output", split = FALSE)
[13:35:12.949]         if (TRUE) {
[13:35:12.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:12.949]         }
[13:35:12.949]         else {
[13:35:12.949]             ...future.result["stdout"] <- base::list(NULL)
[13:35:12.949]         }
[13:35:12.949]         base::close(...future.stdout)
[13:35:12.949]         ...future.stdout <- NULL
[13:35:12.949]     }
[13:35:12.949]     ...future.result$conditions <- ...future.conditions
[13:35:12.949]     ...future.result$finished <- base::Sys.time()
[13:35:12.949]     ...future.result
[13:35:12.949] }
[13:35:12.952] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[13:35:12.952] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[13:35:12.994] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[13:35:12.995] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:35:12.995] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:35:12.995] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[13:35:12.996] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[13:35:12.996] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:12.996] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:12.996] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:12.997] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:12.997] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[13:35:12.997] MultisessionFuture started
[13:35:12.997] - Launch lazy future ... done
[13:35:12.997] run() for ‘MultisessionFuture’ ... done
[13:35:12.997] Created future:
[13:35:12.998] MultisessionFuture:
[13:35:12.998] Label: ‘future_sapply-2’
[13:35:12.998] Expression:
[13:35:12.998] {
[13:35:12.998]     do.call(function(...) {
[13:35:12.998]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:12.998]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:12.998]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:12.998]             on.exit(options(oopts), add = TRUE)
[13:35:12.998]         }
[13:35:12.998]         {
[13:35:12.998]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:12.998]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:12.998]                 ...future.FUN(...future.X_jj, ...)
[13:35:12.998]             })
[13:35:12.998]         }
[13:35:12.998]     }, args = future.call.arguments)
[13:35:12.998] }
[13:35:12.998] Lazy evaluation: FALSE
[13:35:12.998] Asynchronous evaluation: TRUE
[13:35:12.998] Local evaluation: TRUE
[13:35:12.998] Environment: R_GlobalEnv
[13:35:12.998] Capture standard output: TRUE
[13:35:12.998] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:12.998] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:12.998] Packages: 1 packages (‘stats’)
[13:35:12.998] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:12.998] Resolved: FALSE
[13:35:12.998] Value: <not collected>
[13:35:12.998] Conditions captured: <none>
[13:35:12.998] Early signaling: FALSE
[13:35:12.998] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:12.998] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:13.009] Chunk #2 of 2 ... DONE
[13:35:13.009] Launching 2 futures (chunks) ... DONE
[13:35:13.009] Resolving 2 futures (chunks) ...
[13:35:13.010] resolve() on list ...
[13:35:13.010]  recursive: 0
[13:35:13.010]  length: 2
[13:35:13.010] 
[13:35:13.010] receiveMessageFromWorker() for ClusterFuture ...
[13:35:13.011] - Validating connection of MultisessionFuture
[13:35:13.011] - received message: FutureResult
[13:35:13.011] - Received FutureResult
[13:35:13.011] - Erased future from FutureRegistry
[13:35:13.011] result() for ClusterFuture ...
[13:35:13.011] - result already collected: FutureResult
[13:35:13.011] result() for ClusterFuture ... done
[13:35:13.011] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:13.011] Future #1
[13:35:13.012] result() for ClusterFuture ...
[13:35:13.012] - result already collected: FutureResult
[13:35:13.012] result() for ClusterFuture ... done
[13:35:13.012] result() for ClusterFuture ...
[13:35:13.012] - result already collected: FutureResult
[13:35:13.012] result() for ClusterFuture ... done
[13:35:13.012] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:13.012] - nx: 2
[13:35:13.012] - relay: TRUE
[13:35:13.012] - stdout: TRUE
[13:35:13.012] - signal: TRUE
[13:35:13.012] - resignal: FALSE
[13:35:13.013] - force: TRUE
[13:35:13.013] - relayed: [n=2] FALSE, FALSE
[13:35:13.013] - queued futures: [n=2] FALSE, FALSE
[13:35:13.013]  - until=1
[13:35:13.013]  - relaying element #1
[13:35:13.013] result() for ClusterFuture ...
[13:35:13.013] - result already collected: FutureResult
[13:35:13.013] result() for ClusterFuture ... done
[13:35:13.013] result() for ClusterFuture ...
[13:35:13.013] - result already collected: FutureResult
[13:35:13.013] result() for ClusterFuture ... done
[13:35:13.014] result() for ClusterFuture ...
[13:35:13.014] - result already collected: FutureResult
[13:35:13.014] result() for ClusterFuture ... done
[13:35:13.014] result() for ClusterFuture ...
[13:35:13.014] - result already collected: FutureResult
[13:35:13.014] result() for ClusterFuture ... done
[13:35:13.014] - relayed: [n=2] TRUE, FALSE
[13:35:13.014] - queued futures: [n=2] TRUE, FALSE
[13:35:13.014] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:13.014]  length: 1 (resolved future 1)
[13:35:13.044] receiveMessageFromWorker() for ClusterFuture ...
[13:35:13.044] - Validating connection of MultisessionFuture
[13:35:13.045] - received message: FutureResult
[13:35:13.045] - Received FutureResult
[13:35:13.045] - Erased future from FutureRegistry
[13:35:13.045] result() for ClusterFuture ...
[13:35:13.045] - result already collected: FutureResult
[13:35:13.045] result() for ClusterFuture ... done
[13:35:13.045] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:13.045] Future #2
[13:35:13.045] result() for ClusterFuture ...
[13:35:13.046] - result already collected: FutureResult
[13:35:13.046] result() for ClusterFuture ... done
[13:35:13.046] result() for ClusterFuture ...
[13:35:13.046] - result already collected: FutureResult
[13:35:13.046] result() for ClusterFuture ... done
[13:35:13.046] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:13.046] - nx: 2
[13:35:13.046] - relay: TRUE
[13:35:13.046] - stdout: TRUE
[13:35:13.046] - signal: TRUE
[13:35:13.046] - resignal: FALSE
[13:35:13.047] - force: TRUE
[13:35:13.047] - relayed: [n=2] TRUE, FALSE
[13:35:13.047] - queued futures: [n=2] TRUE, FALSE
[13:35:13.047]  - until=2
[13:35:13.047]  - relaying element #2
[13:35:13.047] result() for ClusterFuture ...
[13:35:13.047] - result already collected: FutureResult
[13:35:13.047] result() for ClusterFuture ... done
[13:35:13.047] result() for ClusterFuture ...
[13:35:13.047] - result already collected: FutureResult
[13:35:13.047] result() for ClusterFuture ... done
[13:35:13.048] result() for ClusterFuture ...
[13:35:13.048] - result already collected: FutureResult
[13:35:13.048] result() for ClusterFuture ... done
[13:35:13.048] result() for ClusterFuture ...
[13:35:13.048] - result already collected: FutureResult
[13:35:13.048] result() for ClusterFuture ... done
[13:35:13.048] - relayed: [n=2] TRUE, TRUE
[13:35:13.048] - queued futures: [n=2] TRUE, TRUE
[13:35:13.048] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:13.048]  length: 0 (resolved future 2)
[13:35:13.048] Relaying remaining futures
[13:35:13.049] signalConditionsASAP(NULL, pos=0) ...
[13:35:13.049] - nx: 2
[13:35:13.049] - relay: TRUE
[13:35:13.049] - stdout: TRUE
[13:35:13.049] - signal: TRUE
[13:35:13.049] - resignal: FALSE
[13:35:13.049] - force: TRUE
[13:35:13.049] - relayed: [n=2] TRUE, TRUE
[13:35:13.049] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:13.049] - relayed: [n=2] TRUE, TRUE
[13:35:13.049] - queued futures: [n=2] TRUE, TRUE
[13:35:13.050] signalConditionsASAP(NULL, pos=0) ... done
[13:35:13.050] resolve() on list ... DONE
[13:35:13.050] result() for ClusterFuture ...
[13:35:13.050] - result already collected: FutureResult
[13:35:13.050] result() for ClusterFuture ... done
[13:35:13.050] result() for ClusterFuture ...
[13:35:13.050] - result already collected: FutureResult
[13:35:13.050] result() for ClusterFuture ... done
[13:35:13.050] result() for ClusterFuture ...
[13:35:13.050] - result already collected: FutureResult
[13:35:13.050] result() for ClusterFuture ... done
[13:35:13.051] result() for ClusterFuture ...
[13:35:13.051] - result already collected: FutureResult
[13:35:13.051] result() for ClusterFuture ... done
[13:35:13.051]  - Number of value chunks collected: 2
[13:35:13.051] Resolving 2 futures (chunks) ... DONE
[13:35:13.051] Reducing values from 2 chunks ...
[13:35:13.051]  - Number of values collected after concatenation: 7
[13:35:13.051]  - Number of values expected: 7
[13:35:13.051] Reducing values from 2 chunks ... DONE
[13:35:13.051] future_lapply() ... DONE
[13:35:13.052] future_lapply() ...
[13:35:13.057] Number of chunks: 2
[13:35:13.057] getGlobalsAndPackagesXApply() ...
[13:35:13.057]  - future.globals: TRUE
[13:35:13.058] getGlobalsAndPackages() ...
[13:35:13.058] Searching for globals...
[13:35:13.065] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[13:35:13.065] Searching for globals ... DONE
[13:35:13.065] Resolving globals: FALSE
[13:35:13.066] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[13:35:13.067] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[13:35:13.067] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:13.067] - packages: [2] ‘stats’, ‘future.apply’
[13:35:13.067] getGlobalsAndPackages() ... DONE
[13:35:13.067]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:13.067]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[13:35:13.067] Finding globals ... DONE
[13:35:13.067]  - use_args: TRUE
[13:35:13.067]  - Getting '...' globals ...
[13:35:13.068] resolve() on list ...
[13:35:13.068]  recursive: 0
[13:35:13.068]  length: 1
[13:35:13.068]  elements: ‘...’
[13:35:13.068]  length: 0 (resolved future 1)
[13:35:13.068] resolve() on list ... DONE
[13:35:13.068]    - '...' content: [n=0] 
[13:35:13.068] List of 1
[13:35:13.068]  $ ...: list()
[13:35:13.068]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:13.068]  - attr(*, "where")=List of 1
[13:35:13.068]   ..$ ...:<environment: 0x5574d16ac1d8> 
[13:35:13.068]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:13.068]  - attr(*, "resolved")= logi TRUE
[13:35:13.068]  - attr(*, "total_size")= num NA
[13:35:13.071]  - Getting '...' globals ... DONE
[13:35:13.071] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:13.071] List of 8
[13:35:13.071]  $ ...future.FUN:function (x, ...)  
[13:35:13.071]  $ x_FUN        :function (x, na.rm = TRUE)  
[13:35:13.071]  $ times        : int 5
[13:35:13.071]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:13.071]  $ stop_if_not  :function (...)  
[13:35:13.071]  $ dim          : NULL
[13:35:13.071]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:13.071]  $ ...          : list()
[13:35:13.071]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:13.071]  - attr(*, "where")=List of 8
[13:35:13.071]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:13.071]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:13.071]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:13.071]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:13.071]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:13.071]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:13.071]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:13.071]   ..$ ...          :<environment: 0x5574d16ac1d8> 
[13:35:13.071]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:13.071]  - attr(*, "resolved")= logi FALSE
[13:35:13.071]  - attr(*, "total_size")= num 141240
[13:35:13.076] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[13:35:13.077] getGlobalsAndPackagesXApply() ... DONE
[13:35:13.077] Number of futures (= number of chunks): 2
[13:35:13.077] Launching 2 futures (chunks) ...
[13:35:13.077] Chunk #1 of 2 ...
[13:35:13.077]  - Finding globals in 'X' for chunk #1 ...
[13:35:13.077] getGlobalsAndPackages() ...
[13:35:13.077] Searching for globals...
[13:35:13.078] 
[13:35:13.078] Searching for globals ... DONE
[13:35:13.078] - globals: [0] <none>
[13:35:13.078] getGlobalsAndPackages() ... DONE
[13:35:13.078]    + additional globals found: [n=0] 
[13:35:13.078]    + additional namespaces needed: [n=0] 
[13:35:13.078]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:13.078]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:13.078]  - seeds: <none>
[13:35:13.078]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.079] getGlobalsAndPackages() ...
[13:35:13.079] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.079] Resolving globals: FALSE
[13:35:13.079] Tweak future expression to call with '...' arguments ...
[13:35:13.079] {
[13:35:13.079]     do.call(function(...) {
[13:35:13.079]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.079]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:13.079]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.079]             on.exit(options(oopts), add = TRUE)
[13:35:13.079]         }
[13:35:13.079]         {
[13:35:13.079]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:13.079]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.079]                 ...future.FUN(...future.X_jj, ...)
[13:35:13.079]             })
[13:35:13.079]         }
[13:35:13.079]     }, args = future.call.arguments)
[13:35:13.079] }
[13:35:13.079] Tweak future expression to call with '...' arguments ... DONE
[13:35:13.080] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.080] - packages: [2] ‘stats’, ‘future.apply’
[13:35:13.080] getGlobalsAndPackages() ... DONE
[13:35:13.080] run() for ‘Future’ ...
[13:35:13.080] - state: ‘created’
[13:35:13.080] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:13.094] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:13.094] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:13.094]   - Field: ‘node’
[13:35:13.095]   - Field: ‘label’
[13:35:13.095]   - Field: ‘local’
[13:35:13.095]   - Field: ‘owner’
[13:35:13.095]   - Field: ‘envir’
[13:35:13.095]   - Field: ‘workers’
[13:35:13.095]   - Field: ‘packages’
[13:35:13.095]   - Field: ‘gc’
[13:35:13.095]   - Field: ‘conditions’
[13:35:13.095]   - Field: ‘persistent’
[13:35:13.095]   - Field: ‘expr’
[13:35:13.095]   - Field: ‘uuid’
[13:35:13.096]   - Field: ‘seed’
[13:35:13.096]   - Field: ‘version’
[13:35:13.096]   - Field: ‘result’
[13:35:13.096]   - Field: ‘asynchronous’
[13:35:13.096]   - Field: ‘calls’
[13:35:13.096]   - Field: ‘globals’
[13:35:13.096]   - Field: ‘stdout’
[13:35:13.096]   - Field: ‘earlySignal’
[13:35:13.096]   - Field: ‘lazy’
[13:35:13.096]   - Field: ‘state’
[13:35:13.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:13.097] - Launch lazy future ...
[13:35:13.097] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:35:13.097] Packages needed by future strategies (n = 0): <none>
[13:35:13.097] {
[13:35:13.097]     {
[13:35:13.097]         {
[13:35:13.097]             ...future.startTime <- base::Sys.time()
[13:35:13.097]             {
[13:35:13.097]                 {
[13:35:13.097]                   {
[13:35:13.097]                     {
[13:35:13.097]                       {
[13:35:13.097]                         base::local({
[13:35:13.097]                           has_future <- base::requireNamespace("future", 
[13:35:13.097]                             quietly = TRUE)
[13:35:13.097]                           if (has_future) {
[13:35:13.097]                             ns <- base::getNamespace("future")
[13:35:13.097]                             version <- ns[[".package"]][["version"]]
[13:35:13.097]                             if (is.null(version)) 
[13:35:13.097]                               version <- utils::packageVersion("future")
[13:35:13.097]                           }
[13:35:13.097]                           else {
[13:35:13.097]                             version <- NULL
[13:35:13.097]                           }
[13:35:13.097]                           if (!has_future || version < "1.8.0") {
[13:35:13.097]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:13.097]                               "", base::R.version$version.string), 
[13:35:13.097]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:13.097]                                 base::R.version$platform, 8 * 
[13:35:13.097]                                   base::.Machine$sizeof.pointer), 
[13:35:13.097]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:13.097]                                 "release", "version")], collapse = " "), 
[13:35:13.097]                               hostname = base::Sys.info()[["nodename"]])
[13:35:13.097]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:13.097]                               info)
[13:35:13.097]                             info <- base::paste(info, collapse = "; ")
[13:35:13.097]                             if (!has_future) {
[13:35:13.097]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:13.097]                                 info)
[13:35:13.097]                             }
[13:35:13.097]                             else {
[13:35:13.097]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:13.097]                                 info, version)
[13:35:13.097]                             }
[13:35:13.097]                             base::stop(msg)
[13:35:13.097]                           }
[13:35:13.097]                         })
[13:35:13.097]                       }
[13:35:13.097]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:13.097]                       base::options(mc.cores = 1L)
[13:35:13.097]                     }
[13:35:13.097]                     base::local({
[13:35:13.097]                       for (pkg in c("stats", "future.apply")) {
[13:35:13.097]                         base::loadNamespace(pkg)
[13:35:13.097]                         base::library(pkg, character.only = TRUE)
[13:35:13.097]                       }
[13:35:13.097]                     })
[13:35:13.097]                   }
[13:35:13.097]                   ...future.strategy.old <- future::plan("list")
[13:35:13.097]                   options(future.plan = NULL)
[13:35:13.097]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:13.097]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:13.097]                 }
[13:35:13.097]                 ...future.workdir <- getwd()
[13:35:13.097]             }
[13:35:13.097]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:13.097]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:13.097]         }
[13:35:13.097]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:13.097]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:13.097]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:13.097]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:13.097]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:13.097]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:13.097]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:13.097]             base::names(...future.oldOptions))
[13:35:13.097]     }
[13:35:13.097]     if (FALSE) {
[13:35:13.097]     }
[13:35:13.097]     else {
[13:35:13.097]         if (TRUE) {
[13:35:13.097]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:13.097]                 open = "w")
[13:35:13.097]         }
[13:35:13.097]         else {
[13:35:13.097]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:13.097]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:13.097]         }
[13:35:13.097]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:13.097]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:13.097]             base::sink(type = "output", split = FALSE)
[13:35:13.097]             base::close(...future.stdout)
[13:35:13.097]         }, add = TRUE)
[13:35:13.097]     }
[13:35:13.097]     ...future.frame <- base::sys.nframe()
[13:35:13.097]     ...future.conditions <- base::list()
[13:35:13.097]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:13.097]     if (FALSE) {
[13:35:13.097]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:13.097]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:13.097]     }
[13:35:13.097]     ...future.result <- base::tryCatch({
[13:35:13.097]         base::withCallingHandlers({
[13:35:13.097]             ...future.value <- base::withVisible(base::local({
[13:35:13.097]                 ...future.makeSendCondition <- base::local({
[13:35:13.097]                   sendCondition <- NULL
[13:35:13.097]                   function(frame = 1L) {
[13:35:13.097]                     if (is.function(sendCondition)) 
[13:35:13.097]                       return(sendCondition)
[13:35:13.097]                     ns <- getNamespace("parallel")
[13:35:13.097]                     if (exists("sendData", mode = "function", 
[13:35:13.097]                       envir = ns)) {
[13:35:13.097]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:13.097]                         envir = ns)
[13:35:13.097]                       envir <- sys.frame(frame)
[13:35:13.097]                       master <- NULL
[13:35:13.097]                       while (!identical(envir, .GlobalEnv) && 
[13:35:13.097]                         !identical(envir, emptyenv())) {
[13:35:13.097]                         if (exists("master", mode = "list", envir = envir, 
[13:35:13.097]                           inherits = FALSE)) {
[13:35:13.097]                           master <- get("master", mode = "list", 
[13:35:13.097]                             envir = envir, inherits = FALSE)
[13:35:13.097]                           if (inherits(master, c("SOCKnode", 
[13:35:13.097]                             "SOCK0node"))) {
[13:35:13.097]                             sendCondition <<- function(cond) {
[13:35:13.097]                               data <- list(type = "VALUE", value = cond, 
[13:35:13.097]                                 success = TRUE)
[13:35:13.097]                               parallel_sendData(master, data)
[13:35:13.097]                             }
[13:35:13.097]                             return(sendCondition)
[13:35:13.097]                           }
[13:35:13.097]                         }
[13:35:13.097]                         frame <- frame + 1L
[13:35:13.097]                         envir <- sys.frame(frame)
[13:35:13.097]                       }
[13:35:13.097]                     }
[13:35:13.097]                     sendCondition <<- function(cond) NULL
[13:35:13.097]                   }
[13:35:13.097]                 })
[13:35:13.097]                 withCallingHandlers({
[13:35:13.097]                   {
[13:35:13.097]                     do.call(function(...) {
[13:35:13.097]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.097]                       if (!identical(...future.globals.maxSize.org, 
[13:35:13.097]                         ...future.globals.maxSize)) {
[13:35:13.097]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.097]                         on.exit(options(oopts), add = TRUE)
[13:35:13.097]                       }
[13:35:13.097]                       {
[13:35:13.097]                         lapply(seq_along(...future.elements_ii), 
[13:35:13.097]                           FUN = function(jj) {
[13:35:13.097]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.097]                             ...future.FUN(...future.X_jj, ...)
[13:35:13.097]                           })
[13:35:13.097]                       }
[13:35:13.097]                     }, args = future.call.arguments)
[13:35:13.097]                   }
[13:35:13.097]                 }, immediateCondition = function(cond) {
[13:35:13.097]                   sendCondition <- ...future.makeSendCondition()
[13:35:13.097]                   sendCondition(cond)
[13:35:13.097]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.097]                   {
[13:35:13.097]                     inherits <- base::inherits
[13:35:13.097]                     invokeRestart <- base::invokeRestart
[13:35:13.097]                     is.null <- base::is.null
[13:35:13.097]                     muffled <- FALSE
[13:35:13.097]                     if (inherits(cond, "message")) {
[13:35:13.097]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:13.097]                       if (muffled) 
[13:35:13.097]                         invokeRestart("muffleMessage")
[13:35:13.097]                     }
[13:35:13.097]                     else if (inherits(cond, "warning")) {
[13:35:13.097]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:13.097]                       if (muffled) 
[13:35:13.097]                         invokeRestart("muffleWarning")
[13:35:13.097]                     }
[13:35:13.097]                     else if (inherits(cond, "condition")) {
[13:35:13.097]                       if (!is.null(pattern)) {
[13:35:13.097]                         computeRestarts <- base::computeRestarts
[13:35:13.097]                         grepl <- base::grepl
[13:35:13.097]                         restarts <- computeRestarts(cond)
[13:35:13.097]                         for (restart in restarts) {
[13:35:13.097]                           name <- restart$name
[13:35:13.097]                           if (is.null(name)) 
[13:35:13.097]                             next
[13:35:13.097]                           if (!grepl(pattern, name)) 
[13:35:13.097]                             next
[13:35:13.097]                           invokeRestart(restart)
[13:35:13.097]                           muffled <- TRUE
[13:35:13.097]                           break
[13:35:13.097]                         }
[13:35:13.097]                       }
[13:35:13.097]                     }
[13:35:13.097]                     invisible(muffled)
[13:35:13.097]                   }
[13:35:13.097]                   muffleCondition(cond)
[13:35:13.097]                 })
[13:35:13.097]             }))
[13:35:13.097]             future::FutureResult(value = ...future.value$value, 
[13:35:13.097]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:13.097]                   ...future.rng), globalenv = if (FALSE) 
[13:35:13.097]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:13.097]                     ...future.globalenv.names))
[13:35:13.097]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:13.097]         }, condition = base::local({
[13:35:13.097]             c <- base::c
[13:35:13.097]             inherits <- base::inherits
[13:35:13.097]             invokeRestart <- base::invokeRestart
[13:35:13.097]             length <- base::length
[13:35:13.097]             list <- base::list
[13:35:13.097]             seq.int <- base::seq.int
[13:35:13.097]             signalCondition <- base::signalCondition
[13:35:13.097]             sys.calls <- base::sys.calls
[13:35:13.097]             `[[` <- base::`[[`
[13:35:13.097]             `+` <- base::`+`
[13:35:13.097]             `<<-` <- base::`<<-`
[13:35:13.097]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:13.097]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:13.097]                   3L)]
[13:35:13.097]             }
[13:35:13.097]             function(cond) {
[13:35:13.097]                 is_error <- inherits(cond, "error")
[13:35:13.097]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:13.097]                   NULL)
[13:35:13.097]                 if (is_error) {
[13:35:13.097]                   sessionInformation <- function() {
[13:35:13.097]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:13.097]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:13.097]                       search = base::search(), system = base::Sys.info())
[13:35:13.097]                   }
[13:35:13.097]                   ...future.conditions[[length(...future.conditions) + 
[13:35:13.097]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:13.097]                     cond$call), session = sessionInformation(), 
[13:35:13.097]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:13.097]                   signalCondition(cond)
[13:35:13.097]                 }
[13:35:13.097]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:13.097]                 "immediateCondition"))) {
[13:35:13.097]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:13.097]                   ...future.conditions[[length(...future.conditions) + 
[13:35:13.097]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:13.097]                   if (TRUE && !signal) {
[13:35:13.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.097]                     {
[13:35:13.097]                       inherits <- base::inherits
[13:35:13.097]                       invokeRestart <- base::invokeRestart
[13:35:13.097]                       is.null <- base::is.null
[13:35:13.097]                       muffled <- FALSE
[13:35:13.097]                       if (inherits(cond, "message")) {
[13:35:13.097]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:13.097]                         if (muffled) 
[13:35:13.097]                           invokeRestart("muffleMessage")
[13:35:13.097]                       }
[13:35:13.097]                       else if (inherits(cond, "warning")) {
[13:35:13.097]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:13.097]                         if (muffled) 
[13:35:13.097]                           invokeRestart("muffleWarning")
[13:35:13.097]                       }
[13:35:13.097]                       else if (inherits(cond, "condition")) {
[13:35:13.097]                         if (!is.null(pattern)) {
[13:35:13.097]                           computeRestarts <- base::computeRestarts
[13:35:13.097]                           grepl <- base::grepl
[13:35:13.097]                           restarts <- computeRestarts(cond)
[13:35:13.097]                           for (restart in restarts) {
[13:35:13.097]                             name <- restart$name
[13:35:13.097]                             if (is.null(name)) 
[13:35:13.097]                               next
[13:35:13.097]                             if (!grepl(pattern, name)) 
[13:35:13.097]                               next
[13:35:13.097]                             invokeRestart(restart)
[13:35:13.097]                             muffled <- TRUE
[13:35:13.097]                             break
[13:35:13.097]                           }
[13:35:13.097]                         }
[13:35:13.097]                       }
[13:35:13.097]                       invisible(muffled)
[13:35:13.097]                     }
[13:35:13.097]                     muffleCondition(cond, pattern = "^muffle")
[13:35:13.097]                   }
[13:35:13.097]                 }
[13:35:13.097]                 else {
[13:35:13.097]                   if (TRUE) {
[13:35:13.097]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.097]                     {
[13:35:13.097]                       inherits <- base::inherits
[13:35:13.097]                       invokeRestart <- base::invokeRestart
[13:35:13.097]                       is.null <- base::is.null
[13:35:13.097]                       muffled <- FALSE
[13:35:13.097]                       if (inherits(cond, "message")) {
[13:35:13.097]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:13.097]                         if (muffled) 
[13:35:13.097]                           invokeRestart("muffleMessage")
[13:35:13.097]                       }
[13:35:13.097]                       else if (inherits(cond, "warning")) {
[13:35:13.097]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:13.097]                         if (muffled) 
[13:35:13.097]                           invokeRestart("muffleWarning")
[13:35:13.097]                       }
[13:35:13.097]                       else if (inherits(cond, "condition")) {
[13:35:13.097]                         if (!is.null(pattern)) {
[13:35:13.097]                           computeRestarts <- base::computeRestarts
[13:35:13.097]                           grepl <- base::grepl
[13:35:13.097]                           restarts <- computeRestarts(cond)
[13:35:13.097]                           for (restart in restarts) {
[13:35:13.097]                             name <- restart$name
[13:35:13.097]                             if (is.null(name)) 
[13:35:13.097]                               next
[13:35:13.097]                             if (!grepl(pattern, name)) 
[13:35:13.097]                               next
[13:35:13.097]                             invokeRestart(restart)
[13:35:13.097]                             muffled <- TRUE
[13:35:13.097]                             break
[13:35:13.097]                           }
[13:35:13.097]                         }
[13:35:13.097]                       }
[13:35:13.097]                       invisible(muffled)
[13:35:13.097]                     }
[13:35:13.097]                     muffleCondition(cond, pattern = "^muffle")
[13:35:13.097]                   }
[13:35:13.097]                 }
[13:35:13.097]             }
[13:35:13.097]         }))
[13:35:13.097]     }, error = function(ex) {
[13:35:13.097]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:13.097]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:13.097]                 ...future.rng), started = ...future.startTime, 
[13:35:13.097]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:13.097]             version = "1.8"), class = "FutureResult")
[13:35:13.097]     }, finally = {
[13:35:13.097]         if (!identical(...future.workdir, getwd())) 
[13:35:13.097]             setwd(...future.workdir)
[13:35:13.097]         {
[13:35:13.097]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:13.097]                 ...future.oldOptions$nwarnings <- NULL
[13:35:13.097]             }
[13:35:13.097]             base::options(...future.oldOptions)
[13:35:13.097]             if (.Platform$OS.type == "windows") {
[13:35:13.097]                 old_names <- names(...future.oldEnvVars)
[13:35:13.097]                 envs <- base::Sys.getenv()
[13:35:13.097]                 names <- names(envs)
[13:35:13.097]                 common <- intersect(names, old_names)
[13:35:13.097]                 added <- setdiff(names, old_names)
[13:35:13.097]                 removed <- setdiff(old_names, names)
[13:35:13.097]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:13.097]                   envs[common]]
[13:35:13.097]                 NAMES <- toupper(changed)
[13:35:13.097]                 args <- list()
[13:35:13.097]                 for (kk in seq_along(NAMES)) {
[13:35:13.097]                   name <- changed[[kk]]
[13:35:13.097]                   NAME <- NAMES[[kk]]
[13:35:13.097]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.097]                     next
[13:35:13.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:13.097]                 }
[13:35:13.097]                 NAMES <- toupper(added)
[13:35:13.097]                 for (kk in seq_along(NAMES)) {
[13:35:13.097]                   name <- added[[kk]]
[13:35:13.097]                   NAME <- NAMES[[kk]]
[13:35:13.097]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.097]                     next
[13:35:13.097]                   args[[name]] <- ""
[13:35:13.097]                 }
[13:35:13.097]                 NAMES <- toupper(removed)
[13:35:13.097]                 for (kk in seq_along(NAMES)) {
[13:35:13.097]                   name <- removed[[kk]]
[13:35:13.097]                   NAME <- NAMES[[kk]]
[13:35:13.097]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.097]                     next
[13:35:13.097]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:13.097]                 }
[13:35:13.097]                 if (length(args) > 0) 
[13:35:13.097]                   base::do.call(base::Sys.setenv, args = args)
[13:35:13.097]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:13.097]             }
[13:35:13.097]             else {
[13:35:13.097]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:13.097]             }
[13:35:13.097]             {
[13:35:13.097]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:13.097]                   0L) {
[13:35:13.097]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:13.097]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:13.097]                   base::options(opts)
[13:35:13.097]                 }
[13:35:13.097]                 {
[13:35:13.097]                   {
[13:35:13.097]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:13.097]                     NULL
[13:35:13.097]                   }
[13:35:13.097]                   options(future.plan = NULL)
[13:35:13.097]                   if (is.na(NA_character_)) 
[13:35:13.097]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:13.097]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:13.097]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:13.097]                     .init = FALSE)
[13:35:13.097]                 }
[13:35:13.097]             }
[13:35:13.097]         }
[13:35:13.097]     })
[13:35:13.097]     if (TRUE) {
[13:35:13.097]         base::sink(type = "output", split = FALSE)
[13:35:13.097]         if (TRUE) {
[13:35:13.097]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:13.097]         }
[13:35:13.097]         else {
[13:35:13.097]             ...future.result["stdout"] <- base::list(NULL)
[13:35:13.097]         }
[13:35:13.097]         base::close(...future.stdout)
[13:35:13.097]         ...future.stdout <- NULL
[13:35:13.097]     }
[13:35:13.097]     ...future.result$conditions <- ...future.conditions
[13:35:13.097]     ...future.result$finished <- base::Sys.time()
[13:35:13.097]     ...future.result
[13:35:13.097] }
[13:35:13.100] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[13:35:13.100] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:13.143] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:13.143] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[13:35:13.186] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[13:35:13.187] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:13.187] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:13.187] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:13.230] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:13.231] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:13.274] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:13.275] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:13.275] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:13.275] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:13.276] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:13.276] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:13.277] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:13.277] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[13:35:13.277] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[13:35:13.277] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:13.278] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:13.278] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:13.278] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:13.278] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[13:35:13.279] MultisessionFuture started
[13:35:13.279] - Launch lazy future ... done
[13:35:13.279] run() for ‘MultisessionFuture’ ... done
[13:35:13.279] Created future:
[13:35:13.279] MultisessionFuture:
[13:35:13.279] Label: ‘future_vapply-1’
[13:35:13.279] Expression:
[13:35:13.279] {
[13:35:13.279]     do.call(function(...) {
[13:35:13.279]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.279]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:13.279]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.279]             on.exit(options(oopts), add = TRUE)
[13:35:13.279]         }
[13:35:13.279]         {
[13:35:13.279]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:13.279]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.279]                 ...future.FUN(...future.X_jj, ...)
[13:35:13.279]             })
[13:35:13.279]         }
[13:35:13.279]     }, args = future.call.arguments)
[13:35:13.279] }
[13:35:13.279] Lazy evaluation: FALSE
[13:35:13.279] Asynchronous evaluation: TRUE
[13:35:13.279] Local evaluation: TRUE
[13:35:13.279] Environment: R_GlobalEnv
[13:35:13.279] Capture standard output: TRUE
[13:35:13.279] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:13.279] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:13.279] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:35:13.279] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:13.279] Resolved: FALSE
[13:35:13.279] Value: <not collected>
[13:35:13.279] Conditions captured: <none>
[13:35:13.279] Early signaling: FALSE
[13:35:13.279] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:13.279] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:13.291] Chunk #1 of 2 ... DONE
[13:35:13.291] Chunk #2 of 2 ...
[13:35:13.291]  - Finding globals in 'X' for chunk #2 ...
[13:35:13.291] getGlobalsAndPackages() ...
[13:35:13.291] Searching for globals...
[13:35:13.292] 
[13:35:13.292] Searching for globals ... DONE
[13:35:13.292] - globals: [0] <none>
[13:35:13.292] getGlobalsAndPackages() ... DONE
[13:35:13.292]    + additional globals found: [n=0] 
[13:35:13.292]    + additional namespaces needed: [n=0] 
[13:35:13.292]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:13.292]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:13.292]  - seeds: <none>
[13:35:13.292]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.292] getGlobalsAndPackages() ...
[13:35:13.293] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.293] Resolving globals: FALSE
[13:35:13.293] Tweak future expression to call with '...' arguments ...
[13:35:13.293] {
[13:35:13.293]     do.call(function(...) {
[13:35:13.293]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.293]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:13.293]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.293]             on.exit(options(oopts), add = TRUE)
[13:35:13.293]         }
[13:35:13.293]         {
[13:35:13.293]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:13.293]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.293]                 ...future.FUN(...future.X_jj, ...)
[13:35:13.293]             })
[13:35:13.293]         }
[13:35:13.293]     }, args = future.call.arguments)
[13:35:13.293] }
[13:35:13.293] Tweak future expression to call with '...' arguments ... DONE
[13:35:13.294] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.294] - packages: [2] ‘stats’, ‘future.apply’
[13:35:13.294] getGlobalsAndPackages() ... DONE
[13:35:13.294] run() for ‘Future’ ...
[13:35:13.294] - state: ‘created’
[13:35:13.294] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:13.308] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:13.308] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:13.308]   - Field: ‘node’
[13:35:13.309]   - Field: ‘label’
[13:35:13.309]   - Field: ‘local’
[13:35:13.309]   - Field: ‘owner’
[13:35:13.309]   - Field: ‘envir’
[13:35:13.309]   - Field: ‘workers’
[13:35:13.309]   - Field: ‘packages’
[13:35:13.309]   - Field: ‘gc’
[13:35:13.309]   - Field: ‘conditions’
[13:35:13.309]   - Field: ‘persistent’
[13:35:13.309]   - Field: ‘expr’
[13:35:13.310]   - Field: ‘uuid’
[13:35:13.310]   - Field: ‘seed’
[13:35:13.310]   - Field: ‘version’
[13:35:13.310]   - Field: ‘result’
[13:35:13.310]   - Field: ‘asynchronous’
[13:35:13.310]   - Field: ‘calls’
[13:35:13.310]   - Field: ‘globals’
[13:35:13.310]   - Field: ‘stdout’
[13:35:13.310]   - Field: ‘earlySignal’
[13:35:13.310]   - Field: ‘lazy’
[13:35:13.310]   - Field: ‘state’
[13:35:13.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:13.311] - Launch lazy future ...
[13:35:13.311] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[13:35:13.311] Packages needed by future strategies (n = 0): <none>
[13:35:13.312] {
[13:35:13.312]     {
[13:35:13.312]         {
[13:35:13.312]             ...future.startTime <- base::Sys.time()
[13:35:13.312]             {
[13:35:13.312]                 {
[13:35:13.312]                   {
[13:35:13.312]                     {
[13:35:13.312]                       {
[13:35:13.312]                         base::local({
[13:35:13.312]                           has_future <- base::requireNamespace("future", 
[13:35:13.312]                             quietly = TRUE)
[13:35:13.312]                           if (has_future) {
[13:35:13.312]                             ns <- base::getNamespace("future")
[13:35:13.312]                             version <- ns[[".package"]][["version"]]
[13:35:13.312]                             if (is.null(version)) 
[13:35:13.312]                               version <- utils::packageVersion("future")
[13:35:13.312]                           }
[13:35:13.312]                           else {
[13:35:13.312]                             version <- NULL
[13:35:13.312]                           }
[13:35:13.312]                           if (!has_future || version < "1.8.0") {
[13:35:13.312]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:13.312]                               "", base::R.version$version.string), 
[13:35:13.312]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:13.312]                                 base::R.version$platform, 8 * 
[13:35:13.312]                                   base::.Machine$sizeof.pointer), 
[13:35:13.312]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:13.312]                                 "release", "version")], collapse = " "), 
[13:35:13.312]                               hostname = base::Sys.info()[["nodename"]])
[13:35:13.312]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:13.312]                               info)
[13:35:13.312]                             info <- base::paste(info, collapse = "; ")
[13:35:13.312]                             if (!has_future) {
[13:35:13.312]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:13.312]                                 info)
[13:35:13.312]                             }
[13:35:13.312]                             else {
[13:35:13.312]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:13.312]                                 info, version)
[13:35:13.312]                             }
[13:35:13.312]                             base::stop(msg)
[13:35:13.312]                           }
[13:35:13.312]                         })
[13:35:13.312]                       }
[13:35:13.312]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:13.312]                       base::options(mc.cores = 1L)
[13:35:13.312]                     }
[13:35:13.312]                     base::local({
[13:35:13.312]                       for (pkg in c("stats", "future.apply")) {
[13:35:13.312]                         base::loadNamespace(pkg)
[13:35:13.312]                         base::library(pkg, character.only = TRUE)
[13:35:13.312]                       }
[13:35:13.312]                     })
[13:35:13.312]                   }
[13:35:13.312]                   ...future.strategy.old <- future::plan("list")
[13:35:13.312]                   options(future.plan = NULL)
[13:35:13.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:13.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:13.312]                 }
[13:35:13.312]                 ...future.workdir <- getwd()
[13:35:13.312]             }
[13:35:13.312]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:13.312]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:13.312]         }
[13:35:13.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:13.312]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:13.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:13.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:13.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:13.312]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:13.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:13.312]             base::names(...future.oldOptions))
[13:35:13.312]     }
[13:35:13.312]     if (FALSE) {
[13:35:13.312]     }
[13:35:13.312]     else {
[13:35:13.312]         if (TRUE) {
[13:35:13.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:13.312]                 open = "w")
[13:35:13.312]         }
[13:35:13.312]         else {
[13:35:13.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:13.312]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:13.312]         }
[13:35:13.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:13.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:13.312]             base::sink(type = "output", split = FALSE)
[13:35:13.312]             base::close(...future.stdout)
[13:35:13.312]         }, add = TRUE)
[13:35:13.312]     }
[13:35:13.312]     ...future.frame <- base::sys.nframe()
[13:35:13.312]     ...future.conditions <- base::list()
[13:35:13.312]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:13.312]     if (FALSE) {
[13:35:13.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:13.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:13.312]     }
[13:35:13.312]     ...future.result <- base::tryCatch({
[13:35:13.312]         base::withCallingHandlers({
[13:35:13.312]             ...future.value <- base::withVisible(base::local({
[13:35:13.312]                 ...future.makeSendCondition <- base::local({
[13:35:13.312]                   sendCondition <- NULL
[13:35:13.312]                   function(frame = 1L) {
[13:35:13.312]                     if (is.function(sendCondition)) 
[13:35:13.312]                       return(sendCondition)
[13:35:13.312]                     ns <- getNamespace("parallel")
[13:35:13.312]                     if (exists("sendData", mode = "function", 
[13:35:13.312]                       envir = ns)) {
[13:35:13.312]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:13.312]                         envir = ns)
[13:35:13.312]                       envir <- sys.frame(frame)
[13:35:13.312]                       master <- NULL
[13:35:13.312]                       while (!identical(envir, .GlobalEnv) && 
[13:35:13.312]                         !identical(envir, emptyenv())) {
[13:35:13.312]                         if (exists("master", mode = "list", envir = envir, 
[13:35:13.312]                           inherits = FALSE)) {
[13:35:13.312]                           master <- get("master", mode = "list", 
[13:35:13.312]                             envir = envir, inherits = FALSE)
[13:35:13.312]                           if (inherits(master, c("SOCKnode", 
[13:35:13.312]                             "SOCK0node"))) {
[13:35:13.312]                             sendCondition <<- function(cond) {
[13:35:13.312]                               data <- list(type = "VALUE", value = cond, 
[13:35:13.312]                                 success = TRUE)
[13:35:13.312]                               parallel_sendData(master, data)
[13:35:13.312]                             }
[13:35:13.312]                             return(sendCondition)
[13:35:13.312]                           }
[13:35:13.312]                         }
[13:35:13.312]                         frame <- frame + 1L
[13:35:13.312]                         envir <- sys.frame(frame)
[13:35:13.312]                       }
[13:35:13.312]                     }
[13:35:13.312]                     sendCondition <<- function(cond) NULL
[13:35:13.312]                   }
[13:35:13.312]                 })
[13:35:13.312]                 withCallingHandlers({
[13:35:13.312]                   {
[13:35:13.312]                     do.call(function(...) {
[13:35:13.312]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.312]                       if (!identical(...future.globals.maxSize.org, 
[13:35:13.312]                         ...future.globals.maxSize)) {
[13:35:13.312]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.312]                         on.exit(options(oopts), add = TRUE)
[13:35:13.312]                       }
[13:35:13.312]                       {
[13:35:13.312]                         lapply(seq_along(...future.elements_ii), 
[13:35:13.312]                           FUN = function(jj) {
[13:35:13.312]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.312]                             ...future.FUN(...future.X_jj, ...)
[13:35:13.312]                           })
[13:35:13.312]                       }
[13:35:13.312]                     }, args = future.call.arguments)
[13:35:13.312]                   }
[13:35:13.312]                 }, immediateCondition = function(cond) {
[13:35:13.312]                   sendCondition <- ...future.makeSendCondition()
[13:35:13.312]                   sendCondition(cond)
[13:35:13.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.312]                   {
[13:35:13.312]                     inherits <- base::inherits
[13:35:13.312]                     invokeRestart <- base::invokeRestart
[13:35:13.312]                     is.null <- base::is.null
[13:35:13.312]                     muffled <- FALSE
[13:35:13.312]                     if (inherits(cond, "message")) {
[13:35:13.312]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:13.312]                       if (muffled) 
[13:35:13.312]                         invokeRestart("muffleMessage")
[13:35:13.312]                     }
[13:35:13.312]                     else if (inherits(cond, "warning")) {
[13:35:13.312]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:13.312]                       if (muffled) 
[13:35:13.312]                         invokeRestart("muffleWarning")
[13:35:13.312]                     }
[13:35:13.312]                     else if (inherits(cond, "condition")) {
[13:35:13.312]                       if (!is.null(pattern)) {
[13:35:13.312]                         computeRestarts <- base::computeRestarts
[13:35:13.312]                         grepl <- base::grepl
[13:35:13.312]                         restarts <- computeRestarts(cond)
[13:35:13.312]                         for (restart in restarts) {
[13:35:13.312]                           name <- restart$name
[13:35:13.312]                           if (is.null(name)) 
[13:35:13.312]                             next
[13:35:13.312]                           if (!grepl(pattern, name)) 
[13:35:13.312]                             next
[13:35:13.312]                           invokeRestart(restart)
[13:35:13.312]                           muffled <- TRUE
[13:35:13.312]                           break
[13:35:13.312]                         }
[13:35:13.312]                       }
[13:35:13.312]                     }
[13:35:13.312]                     invisible(muffled)
[13:35:13.312]                   }
[13:35:13.312]                   muffleCondition(cond)
[13:35:13.312]                 })
[13:35:13.312]             }))
[13:35:13.312]             future::FutureResult(value = ...future.value$value, 
[13:35:13.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:13.312]                   ...future.rng), globalenv = if (FALSE) 
[13:35:13.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:13.312]                     ...future.globalenv.names))
[13:35:13.312]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:13.312]         }, condition = base::local({
[13:35:13.312]             c <- base::c
[13:35:13.312]             inherits <- base::inherits
[13:35:13.312]             invokeRestart <- base::invokeRestart
[13:35:13.312]             length <- base::length
[13:35:13.312]             list <- base::list
[13:35:13.312]             seq.int <- base::seq.int
[13:35:13.312]             signalCondition <- base::signalCondition
[13:35:13.312]             sys.calls <- base::sys.calls
[13:35:13.312]             `[[` <- base::`[[`
[13:35:13.312]             `+` <- base::`+`
[13:35:13.312]             `<<-` <- base::`<<-`
[13:35:13.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:13.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:13.312]                   3L)]
[13:35:13.312]             }
[13:35:13.312]             function(cond) {
[13:35:13.312]                 is_error <- inherits(cond, "error")
[13:35:13.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:13.312]                   NULL)
[13:35:13.312]                 if (is_error) {
[13:35:13.312]                   sessionInformation <- function() {
[13:35:13.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:13.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:13.312]                       search = base::search(), system = base::Sys.info())
[13:35:13.312]                   }
[13:35:13.312]                   ...future.conditions[[length(...future.conditions) + 
[13:35:13.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:13.312]                     cond$call), session = sessionInformation(), 
[13:35:13.312]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:13.312]                   signalCondition(cond)
[13:35:13.312]                 }
[13:35:13.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:13.312]                 "immediateCondition"))) {
[13:35:13.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:13.312]                   ...future.conditions[[length(...future.conditions) + 
[13:35:13.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:13.312]                   if (TRUE && !signal) {
[13:35:13.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.312]                     {
[13:35:13.312]                       inherits <- base::inherits
[13:35:13.312]                       invokeRestart <- base::invokeRestart
[13:35:13.312]                       is.null <- base::is.null
[13:35:13.312]                       muffled <- FALSE
[13:35:13.312]                       if (inherits(cond, "message")) {
[13:35:13.312]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:13.312]                         if (muffled) 
[13:35:13.312]                           invokeRestart("muffleMessage")
[13:35:13.312]                       }
[13:35:13.312]                       else if (inherits(cond, "warning")) {
[13:35:13.312]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:13.312]                         if (muffled) 
[13:35:13.312]                           invokeRestart("muffleWarning")
[13:35:13.312]                       }
[13:35:13.312]                       else if (inherits(cond, "condition")) {
[13:35:13.312]                         if (!is.null(pattern)) {
[13:35:13.312]                           computeRestarts <- base::computeRestarts
[13:35:13.312]                           grepl <- base::grepl
[13:35:13.312]                           restarts <- computeRestarts(cond)
[13:35:13.312]                           for (restart in restarts) {
[13:35:13.312]                             name <- restart$name
[13:35:13.312]                             if (is.null(name)) 
[13:35:13.312]                               next
[13:35:13.312]                             if (!grepl(pattern, name)) 
[13:35:13.312]                               next
[13:35:13.312]                             invokeRestart(restart)
[13:35:13.312]                             muffled <- TRUE
[13:35:13.312]                             break
[13:35:13.312]                           }
[13:35:13.312]                         }
[13:35:13.312]                       }
[13:35:13.312]                       invisible(muffled)
[13:35:13.312]                     }
[13:35:13.312]                     muffleCondition(cond, pattern = "^muffle")
[13:35:13.312]                   }
[13:35:13.312]                 }
[13:35:13.312]                 else {
[13:35:13.312]                   if (TRUE) {
[13:35:13.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.312]                     {
[13:35:13.312]                       inherits <- base::inherits
[13:35:13.312]                       invokeRestart <- base::invokeRestart
[13:35:13.312]                       is.null <- base::is.null
[13:35:13.312]                       muffled <- FALSE
[13:35:13.312]                       if (inherits(cond, "message")) {
[13:35:13.312]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:13.312]                         if (muffled) 
[13:35:13.312]                           invokeRestart("muffleMessage")
[13:35:13.312]                       }
[13:35:13.312]                       else if (inherits(cond, "warning")) {
[13:35:13.312]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:13.312]                         if (muffled) 
[13:35:13.312]                           invokeRestart("muffleWarning")
[13:35:13.312]                       }
[13:35:13.312]                       else if (inherits(cond, "condition")) {
[13:35:13.312]                         if (!is.null(pattern)) {
[13:35:13.312]                           computeRestarts <- base::computeRestarts
[13:35:13.312]                           grepl <- base::grepl
[13:35:13.312]                           restarts <- computeRestarts(cond)
[13:35:13.312]                           for (restart in restarts) {
[13:35:13.312]                             name <- restart$name
[13:35:13.312]                             if (is.null(name)) 
[13:35:13.312]                               next
[13:35:13.312]                             if (!grepl(pattern, name)) 
[13:35:13.312]                               next
[13:35:13.312]                             invokeRestart(restart)
[13:35:13.312]                             muffled <- TRUE
[13:35:13.312]                             break
[13:35:13.312]                           }
[13:35:13.312]                         }
[13:35:13.312]                       }
[13:35:13.312]                       invisible(muffled)
[13:35:13.312]                     }
[13:35:13.312]                     muffleCondition(cond, pattern = "^muffle")
[13:35:13.312]                   }
[13:35:13.312]                 }
[13:35:13.312]             }
[13:35:13.312]         }))
[13:35:13.312]     }, error = function(ex) {
[13:35:13.312]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:13.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:13.312]                 ...future.rng), started = ...future.startTime, 
[13:35:13.312]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:13.312]             version = "1.8"), class = "FutureResult")
[13:35:13.312]     }, finally = {
[13:35:13.312]         if (!identical(...future.workdir, getwd())) 
[13:35:13.312]             setwd(...future.workdir)
[13:35:13.312]         {
[13:35:13.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:13.312]                 ...future.oldOptions$nwarnings <- NULL
[13:35:13.312]             }
[13:35:13.312]             base::options(...future.oldOptions)
[13:35:13.312]             if (.Platform$OS.type == "windows") {
[13:35:13.312]                 old_names <- names(...future.oldEnvVars)
[13:35:13.312]                 envs <- base::Sys.getenv()
[13:35:13.312]                 names <- names(envs)
[13:35:13.312]                 common <- intersect(names, old_names)
[13:35:13.312]                 added <- setdiff(names, old_names)
[13:35:13.312]                 removed <- setdiff(old_names, names)
[13:35:13.312]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:13.312]                   envs[common]]
[13:35:13.312]                 NAMES <- toupper(changed)
[13:35:13.312]                 args <- list()
[13:35:13.312]                 for (kk in seq_along(NAMES)) {
[13:35:13.312]                   name <- changed[[kk]]
[13:35:13.312]                   NAME <- NAMES[[kk]]
[13:35:13.312]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.312]                     next
[13:35:13.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:13.312]                 }
[13:35:13.312]                 NAMES <- toupper(added)
[13:35:13.312]                 for (kk in seq_along(NAMES)) {
[13:35:13.312]                   name <- added[[kk]]
[13:35:13.312]                   NAME <- NAMES[[kk]]
[13:35:13.312]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.312]                     next
[13:35:13.312]                   args[[name]] <- ""
[13:35:13.312]                 }
[13:35:13.312]                 NAMES <- toupper(removed)
[13:35:13.312]                 for (kk in seq_along(NAMES)) {
[13:35:13.312]                   name <- removed[[kk]]
[13:35:13.312]                   NAME <- NAMES[[kk]]
[13:35:13.312]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.312]                     next
[13:35:13.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:13.312]                 }
[13:35:13.312]                 if (length(args) > 0) 
[13:35:13.312]                   base::do.call(base::Sys.setenv, args = args)
[13:35:13.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:13.312]             }
[13:35:13.312]             else {
[13:35:13.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:13.312]             }
[13:35:13.312]             {
[13:35:13.312]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:13.312]                   0L) {
[13:35:13.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:13.312]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:13.312]                   base::options(opts)
[13:35:13.312]                 }
[13:35:13.312]                 {
[13:35:13.312]                   {
[13:35:13.312]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:13.312]                     NULL
[13:35:13.312]                   }
[13:35:13.312]                   options(future.plan = NULL)
[13:35:13.312]                   if (is.na(NA_character_)) 
[13:35:13.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:13.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:13.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:13.312]                     .init = FALSE)
[13:35:13.312]                 }
[13:35:13.312]             }
[13:35:13.312]         }
[13:35:13.312]     })
[13:35:13.312]     if (TRUE) {
[13:35:13.312]         base::sink(type = "output", split = FALSE)
[13:35:13.312]         if (TRUE) {
[13:35:13.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:13.312]         }
[13:35:13.312]         else {
[13:35:13.312]             ...future.result["stdout"] <- base::list(NULL)
[13:35:13.312]         }
[13:35:13.312]         base::close(...future.stdout)
[13:35:13.312]         ...future.stdout <- NULL
[13:35:13.312]     }
[13:35:13.312]     ...future.result$conditions <- ...future.conditions
[13:35:13.312]     ...future.result$finished <- base::Sys.time()
[13:35:13.312]     ...future.result
[13:35:13.312] }
[13:35:13.314] Exporting 11 global objects (137.93 KiB) to cluster node #2 ...
[13:35:13.314] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:35:13.359] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:35:13.359] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ...
[13:35:13.402] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #2 ... DONE
[13:35:13.403] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:35:13.403] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:35:13.403] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:35:13.447] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:35:13.447] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:35:13.490] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:35:13.491] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:35:13.491] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:35:13.491] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:35:13.492] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:35:13.492] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:35:13.492] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:35:13.492] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[13:35:13.493] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[13:35:13.493] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:13.493] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:13.493] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:13.494] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:13.494] Exporting 11 global objects (137.93 KiB) to cluster node #2 ... DONE
[13:35:13.494] MultisessionFuture started
[13:35:13.495] - Launch lazy future ... done
[13:35:13.495] run() for ‘MultisessionFuture’ ... done
[13:35:13.495] Created future:
[13:35:13.495] MultisessionFuture:
[13:35:13.495] Label: ‘future_vapply-2’
[13:35:13.495] Expression:
[13:35:13.495] {
[13:35:13.495]     do.call(function(...) {
[13:35:13.495]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.495]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:13.495]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.495]             on.exit(options(oopts), add = TRUE)
[13:35:13.495]         }
[13:35:13.495]         {
[13:35:13.495]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:13.495]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.495]                 ...future.FUN(...future.X_jj, ...)
[13:35:13.495]             })
[13:35:13.495]         }
[13:35:13.495]     }, args = future.call.arguments)
[13:35:13.495] }
[13:35:13.495] Lazy evaluation: FALSE
[13:35:13.495] Asynchronous evaluation: TRUE
[13:35:13.495] Local evaluation: TRUE
[13:35:13.495] Environment: R_GlobalEnv
[13:35:13.495] Capture standard output: TRUE
[13:35:13.495] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:13.495] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:13.495] Packages: 2 packages (‘stats’, ‘future.apply’)
[13:35:13.495] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:13.495] Resolved: FALSE
[13:35:13.495] Value: <not collected>
[13:35:13.495] Conditions captured: <none>
[13:35:13.495] Early signaling: FALSE
[13:35:13.495] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:13.495] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:13.509] Chunk #2 of 2 ... DONE
[13:35:13.509] Launching 2 futures (chunks) ... DONE
[13:35:13.509] Resolving 2 futures (chunks) ...
[13:35:13.509] resolve() on list ...
[13:35:13.510]  recursive: 0
[13:35:13.510]  length: 2
[13:35:13.510] 
[13:35:13.510] receiveMessageFromWorker() for ClusterFuture ...
[13:35:13.510] - Validating connection of MultisessionFuture
[13:35:13.510] - received message: FutureResult
[13:35:13.511] - Received FutureResult
[13:35:13.511] - Erased future from FutureRegistry
[13:35:13.511] result() for ClusterFuture ...
[13:35:13.511] - result already collected: FutureResult
[13:35:13.511] result() for ClusterFuture ... done
[13:35:13.511] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:13.511] Future #1
[13:35:13.511] result() for ClusterFuture ...
[13:35:13.511] - result already collected: FutureResult
[13:35:13.511] result() for ClusterFuture ... done
[13:35:13.511] result() for ClusterFuture ...
[13:35:13.512] - result already collected: FutureResult
[13:35:13.512] result() for ClusterFuture ... done
[13:35:13.512] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:13.512] - nx: 2
[13:35:13.512] - relay: TRUE
[13:35:13.512] - stdout: TRUE
[13:35:13.512] - signal: TRUE
[13:35:13.512] - resignal: FALSE
[13:35:13.512] - force: TRUE
[13:35:13.512] - relayed: [n=2] FALSE, FALSE
[13:35:13.512] - queued futures: [n=2] FALSE, FALSE
[13:35:13.513]  - until=1
[13:35:13.513]  - relaying element #1
[13:35:13.513] result() for ClusterFuture ...
[13:35:13.513] - result already collected: FutureResult
[13:35:13.513] result() for ClusterFuture ... done
[13:35:13.513] result() for ClusterFuture ...
[13:35:13.513] - result already collected: FutureResult
[13:35:13.513] result() for ClusterFuture ... done
[13:35:13.513] result() for ClusterFuture ...
[13:35:13.513] - result already collected: FutureResult
[13:35:13.513] result() for ClusterFuture ... done
[13:35:13.513] result() for ClusterFuture ...
[13:35:13.514] - result already collected: FutureResult
[13:35:13.514] result() for ClusterFuture ... done
[13:35:13.514] - relayed: [n=2] TRUE, FALSE
[13:35:13.514] - queued futures: [n=2] TRUE, FALSE
[13:35:13.514] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:13.514]  length: 1 (resolved future 1)
[13:35:13.540] receiveMessageFromWorker() for ClusterFuture ...
[13:35:13.540] - Validating connection of MultisessionFuture
[13:35:13.540] - received message: FutureResult
[13:35:13.541] - Received FutureResult
[13:35:13.541] - Erased future from FutureRegistry
[13:35:13.541] result() for ClusterFuture ...
[13:35:13.541] - result already collected: FutureResult
[13:35:13.541] result() for ClusterFuture ... done
[13:35:13.541] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:13.541] Future #2
[13:35:13.541] result() for ClusterFuture ...
[13:35:13.541] - result already collected: FutureResult
[13:35:13.541] result() for ClusterFuture ... done
[13:35:13.541] result() for ClusterFuture ...
[13:35:13.542] - result already collected: FutureResult
[13:35:13.542] result() for ClusterFuture ... done
[13:35:13.542] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:13.542] - nx: 2
[13:35:13.542] - relay: TRUE
[13:35:13.542] - stdout: TRUE
[13:35:13.542] - signal: TRUE
[13:35:13.542] - resignal: FALSE
[13:35:13.542] - force: TRUE
[13:35:13.542] - relayed: [n=2] TRUE, FALSE
[13:35:13.542] - queued futures: [n=2] TRUE, FALSE
[13:35:13.543]  - until=2
[13:35:13.543]  - relaying element #2
[13:35:13.543] result() for ClusterFuture ...
[13:35:13.543] - result already collected: FutureResult
[13:35:13.543] result() for ClusterFuture ... done
[13:35:13.543] result() for ClusterFuture ...
[13:35:13.543] - result already collected: FutureResult
[13:35:13.543] result() for ClusterFuture ... done
[13:35:13.543] result() for ClusterFuture ...
[13:35:13.543] - result already collected: FutureResult
[13:35:13.543] result() for ClusterFuture ... done
[13:35:13.544] result() for ClusterFuture ...
[13:35:13.544] - result already collected: FutureResult
[13:35:13.544] result() for ClusterFuture ... done
[13:35:13.544] - relayed: [n=2] TRUE, TRUE
[13:35:13.544] - queued futures: [n=2] TRUE, TRUE
[13:35:13.544] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:13.544]  length: 0 (resolved future 2)
[13:35:13.544] Relaying remaining futures
[13:35:13.544] signalConditionsASAP(NULL, pos=0) ...
[13:35:13.544] - nx: 2
[13:35:13.544] - relay: TRUE
[13:35:13.545] - stdout: TRUE
[13:35:13.545] - signal: TRUE
[13:35:13.545] - resignal: FALSE
[13:35:13.545] - force: TRUE
[13:35:13.545] - relayed: [n=2] TRUE, TRUE
[13:35:13.545] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:13.545] - relayed: [n=2] TRUE, TRUE
[13:35:13.545] - queued futures: [n=2] TRUE, TRUE
[13:35:13.545] signalConditionsASAP(NULL, pos=0) ... done
[13:35:13.545] resolve() on list ... DONE
[13:35:13.545] result() for ClusterFuture ...
[13:35:13.546] - result already collected: FutureResult
[13:35:13.546] result() for ClusterFuture ... done
[13:35:13.546] result() for ClusterFuture ...
[13:35:13.546] - result already collected: FutureResult
[13:35:13.546] result() for ClusterFuture ... done
[13:35:13.546] result() for ClusterFuture ...
[13:35:13.546] - result already collected: FutureResult
[13:35:13.546] result() for ClusterFuture ... done
[13:35:13.546] result() for ClusterFuture ...
[13:35:13.546] - result already collected: FutureResult
[13:35:13.546] result() for ClusterFuture ... done
[13:35:13.547]  - Number of value chunks collected: 2
[13:35:13.547] Resolving 2 futures (chunks) ... DONE
[13:35:13.547] Reducing values from 2 chunks ...
[13:35:13.547]  - Number of values collected after concatenation: 7
[13:35:13.547]  - Number of values expected: 7
[13:35:13.547] Reducing values from 2 chunks ... DONE
[13:35:13.547] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[13:35:13.549] future_lapply() ...
[13:35:13.553] Number of chunks: 2
[13:35:13.553] getGlobalsAndPackagesXApply() ...
[13:35:13.553]  - future.globals: TRUE
[13:35:13.553] getGlobalsAndPackages() ...
[13:35:13.553] Searching for globals...
[13:35:13.555] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[13:35:13.555] Searching for globals ... DONE
[13:35:13.555] Resolving globals: FALSE
[13:35:13.555] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[13:35:13.556] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[13:35:13.556] - globals: [1] ‘FUN’
[13:35:13.556] 
[13:35:13.556] getGlobalsAndPackages() ... DONE
[13:35:13.556]  - globals found/used: [n=1] ‘FUN’
[13:35:13.556]  - needed namespaces: [n=0] 
[13:35:13.556] Finding globals ... DONE
[13:35:13.556]  - use_args: TRUE
[13:35:13.556]  - Getting '...' globals ...
[13:35:13.557] resolve() on list ...
[13:35:13.557]  recursive: 0
[13:35:13.557]  length: 1
[13:35:13.557]  elements: ‘...’
[13:35:13.557]  length: 0 (resolved future 1)
[13:35:13.557] resolve() on list ... DONE
[13:35:13.557]    - '...' content: [n=1] ‘y’
[13:35:13.557] List of 1
[13:35:13.557]  $ ...:List of 1
[13:35:13.557]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:13.557]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:13.557]  - attr(*, "where")=List of 1
[13:35:13.557]   ..$ ...:<environment: 0x5574cfc5d198> 
[13:35:13.557]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:13.557]  - attr(*, "resolved")= logi TRUE
[13:35:13.557]  - attr(*, "total_size")= num NA
[13:35:13.560]  - Getting '...' globals ... DONE
[13:35:13.560] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[13:35:13.560] List of 2
[13:35:13.560]  $ ...future.FUN:function (x, y)  
[13:35:13.560]  $ ...          :List of 1
[13:35:13.560]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:13.560]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:13.560]  - attr(*, "where")=List of 2
[13:35:13.560]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:13.560]   ..$ ...          :<environment: 0x5574cfc5d198> 
[13:35:13.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:13.560]  - attr(*, "resolved")= logi FALSE
[13:35:13.560]  - attr(*, "total_size")= num 4264
[13:35:13.563] Packages to be attached in all futures: [n=0] 
[13:35:13.563] getGlobalsAndPackagesXApply() ... DONE
[13:35:13.564] Number of futures (= number of chunks): 2
[13:35:13.564] Launching 2 futures (chunks) ...
[13:35:13.564] Chunk #1 of 2 ...
[13:35:13.564]  - Finding globals in 'X' for chunk #1 ...
[13:35:13.564] getGlobalsAndPackages() ...
[13:35:13.564] Searching for globals...
[13:35:13.564] 
[13:35:13.564] Searching for globals ... DONE
[13:35:13.565] - globals: [0] <none>
[13:35:13.565] getGlobalsAndPackages() ... DONE
[13:35:13.565]    + additional globals found: [n=0] 
[13:35:13.565]    + additional namespaces needed: [n=0] 
[13:35:13.565]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:13.565]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:13.565]  - seeds: <none>
[13:35:13.565]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.565] getGlobalsAndPackages() ...
[13:35:13.565] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.566] Resolving globals: FALSE
[13:35:13.566] Tweak future expression to call with '...' arguments ...
[13:35:13.566] {
[13:35:13.566]     do.call(function(...) {
[13:35:13.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:13.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.566]             on.exit(options(oopts), add = TRUE)
[13:35:13.566]         }
[13:35:13.566]         {
[13:35:13.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:13.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.566]                 ...future.FUN(...future.X_jj, ...)
[13:35:13.566]             })
[13:35:13.566]         }
[13:35:13.566]     }, args = future.call.arguments)
[13:35:13.566] }
[13:35:13.566] Tweak future expression to call with '...' arguments ... DONE
[13:35:13.566] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.566] 
[13:35:13.567] getGlobalsAndPackages() ... DONE
[13:35:13.567] run() for ‘Future’ ...
[13:35:13.567] - state: ‘created’
[13:35:13.567] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:13.582] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:13.582] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:13.582]   - Field: ‘node’
[13:35:13.582]   - Field: ‘label’
[13:35:13.582]   - Field: ‘local’
[13:35:13.582]   - Field: ‘owner’
[13:35:13.583]   - Field: ‘envir’
[13:35:13.583]   - Field: ‘workers’
[13:35:13.583]   - Field: ‘packages’
[13:35:13.583]   - Field: ‘gc’
[13:35:13.583]   - Field: ‘conditions’
[13:35:13.583]   - Field: ‘persistent’
[13:35:13.583]   - Field: ‘expr’
[13:35:13.583]   - Field: ‘uuid’
[13:35:13.583]   - Field: ‘seed’
[13:35:13.583]   - Field: ‘version’
[13:35:13.583]   - Field: ‘result’
[13:35:13.584]   - Field: ‘asynchronous’
[13:35:13.584]   - Field: ‘calls’
[13:35:13.584]   - Field: ‘globals’
[13:35:13.584]   - Field: ‘stdout’
[13:35:13.584]   - Field: ‘earlySignal’
[13:35:13.584]   - Field: ‘lazy’
[13:35:13.584]   - Field: ‘state’
[13:35:13.584] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:13.584] - Launch lazy future ...
[13:35:13.585] Packages needed by the future expression (n = 0): <none>
[13:35:13.585] Packages needed by future strategies (n = 0): <none>
[13:35:13.585] {
[13:35:13.585]     {
[13:35:13.585]         {
[13:35:13.585]             ...future.startTime <- base::Sys.time()
[13:35:13.585]             {
[13:35:13.585]                 {
[13:35:13.585]                   {
[13:35:13.585]                     {
[13:35:13.585]                       base::local({
[13:35:13.585]                         has_future <- base::requireNamespace("future", 
[13:35:13.585]                           quietly = TRUE)
[13:35:13.585]                         if (has_future) {
[13:35:13.585]                           ns <- base::getNamespace("future")
[13:35:13.585]                           version <- ns[[".package"]][["version"]]
[13:35:13.585]                           if (is.null(version)) 
[13:35:13.585]                             version <- utils::packageVersion("future")
[13:35:13.585]                         }
[13:35:13.585]                         else {
[13:35:13.585]                           version <- NULL
[13:35:13.585]                         }
[13:35:13.585]                         if (!has_future || version < "1.8.0") {
[13:35:13.585]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:13.585]                             "", base::R.version$version.string), 
[13:35:13.585]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:13.585]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:13.585]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:13.585]                               "release", "version")], collapse = " "), 
[13:35:13.585]                             hostname = base::Sys.info()[["nodename"]])
[13:35:13.585]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:13.585]                             info)
[13:35:13.585]                           info <- base::paste(info, collapse = "; ")
[13:35:13.585]                           if (!has_future) {
[13:35:13.585]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:13.585]                               info)
[13:35:13.585]                           }
[13:35:13.585]                           else {
[13:35:13.585]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:13.585]                               info, version)
[13:35:13.585]                           }
[13:35:13.585]                           base::stop(msg)
[13:35:13.585]                         }
[13:35:13.585]                       })
[13:35:13.585]                     }
[13:35:13.585]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:13.585]                     base::options(mc.cores = 1L)
[13:35:13.585]                   }
[13:35:13.585]                   ...future.strategy.old <- future::plan("list")
[13:35:13.585]                   options(future.plan = NULL)
[13:35:13.585]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:13.585]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:13.585]                 }
[13:35:13.585]                 ...future.workdir <- getwd()
[13:35:13.585]             }
[13:35:13.585]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:13.585]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:13.585]         }
[13:35:13.585]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:13.585]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:13.585]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:13.585]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:13.585]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:13.585]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:13.585]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:13.585]             base::names(...future.oldOptions))
[13:35:13.585]     }
[13:35:13.585]     if (FALSE) {
[13:35:13.585]     }
[13:35:13.585]     else {
[13:35:13.585]         if (TRUE) {
[13:35:13.585]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:13.585]                 open = "w")
[13:35:13.585]         }
[13:35:13.585]         else {
[13:35:13.585]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:13.585]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:13.585]         }
[13:35:13.585]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:13.585]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:13.585]             base::sink(type = "output", split = FALSE)
[13:35:13.585]             base::close(...future.stdout)
[13:35:13.585]         }, add = TRUE)
[13:35:13.585]     }
[13:35:13.585]     ...future.frame <- base::sys.nframe()
[13:35:13.585]     ...future.conditions <- base::list()
[13:35:13.585]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:13.585]     if (FALSE) {
[13:35:13.585]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:13.585]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:13.585]     }
[13:35:13.585]     ...future.result <- base::tryCatch({
[13:35:13.585]         base::withCallingHandlers({
[13:35:13.585]             ...future.value <- base::withVisible(base::local({
[13:35:13.585]                 ...future.makeSendCondition <- base::local({
[13:35:13.585]                   sendCondition <- NULL
[13:35:13.585]                   function(frame = 1L) {
[13:35:13.585]                     if (is.function(sendCondition)) 
[13:35:13.585]                       return(sendCondition)
[13:35:13.585]                     ns <- getNamespace("parallel")
[13:35:13.585]                     if (exists("sendData", mode = "function", 
[13:35:13.585]                       envir = ns)) {
[13:35:13.585]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:13.585]                         envir = ns)
[13:35:13.585]                       envir <- sys.frame(frame)
[13:35:13.585]                       master <- NULL
[13:35:13.585]                       while (!identical(envir, .GlobalEnv) && 
[13:35:13.585]                         !identical(envir, emptyenv())) {
[13:35:13.585]                         if (exists("master", mode = "list", envir = envir, 
[13:35:13.585]                           inherits = FALSE)) {
[13:35:13.585]                           master <- get("master", mode = "list", 
[13:35:13.585]                             envir = envir, inherits = FALSE)
[13:35:13.585]                           if (inherits(master, c("SOCKnode", 
[13:35:13.585]                             "SOCK0node"))) {
[13:35:13.585]                             sendCondition <<- function(cond) {
[13:35:13.585]                               data <- list(type = "VALUE", value = cond, 
[13:35:13.585]                                 success = TRUE)
[13:35:13.585]                               parallel_sendData(master, data)
[13:35:13.585]                             }
[13:35:13.585]                             return(sendCondition)
[13:35:13.585]                           }
[13:35:13.585]                         }
[13:35:13.585]                         frame <- frame + 1L
[13:35:13.585]                         envir <- sys.frame(frame)
[13:35:13.585]                       }
[13:35:13.585]                     }
[13:35:13.585]                     sendCondition <<- function(cond) NULL
[13:35:13.585]                   }
[13:35:13.585]                 })
[13:35:13.585]                 withCallingHandlers({
[13:35:13.585]                   {
[13:35:13.585]                     do.call(function(...) {
[13:35:13.585]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.585]                       if (!identical(...future.globals.maxSize.org, 
[13:35:13.585]                         ...future.globals.maxSize)) {
[13:35:13.585]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.585]                         on.exit(options(oopts), add = TRUE)
[13:35:13.585]                       }
[13:35:13.585]                       {
[13:35:13.585]                         lapply(seq_along(...future.elements_ii), 
[13:35:13.585]                           FUN = function(jj) {
[13:35:13.585]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.585]                             ...future.FUN(...future.X_jj, ...)
[13:35:13.585]                           })
[13:35:13.585]                       }
[13:35:13.585]                     }, args = future.call.arguments)
[13:35:13.585]                   }
[13:35:13.585]                 }, immediateCondition = function(cond) {
[13:35:13.585]                   sendCondition <- ...future.makeSendCondition()
[13:35:13.585]                   sendCondition(cond)
[13:35:13.585]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.585]                   {
[13:35:13.585]                     inherits <- base::inherits
[13:35:13.585]                     invokeRestart <- base::invokeRestart
[13:35:13.585]                     is.null <- base::is.null
[13:35:13.585]                     muffled <- FALSE
[13:35:13.585]                     if (inherits(cond, "message")) {
[13:35:13.585]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:13.585]                       if (muffled) 
[13:35:13.585]                         invokeRestart("muffleMessage")
[13:35:13.585]                     }
[13:35:13.585]                     else if (inherits(cond, "warning")) {
[13:35:13.585]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:13.585]                       if (muffled) 
[13:35:13.585]                         invokeRestart("muffleWarning")
[13:35:13.585]                     }
[13:35:13.585]                     else if (inherits(cond, "condition")) {
[13:35:13.585]                       if (!is.null(pattern)) {
[13:35:13.585]                         computeRestarts <- base::computeRestarts
[13:35:13.585]                         grepl <- base::grepl
[13:35:13.585]                         restarts <- computeRestarts(cond)
[13:35:13.585]                         for (restart in restarts) {
[13:35:13.585]                           name <- restart$name
[13:35:13.585]                           if (is.null(name)) 
[13:35:13.585]                             next
[13:35:13.585]                           if (!grepl(pattern, name)) 
[13:35:13.585]                             next
[13:35:13.585]                           invokeRestart(restart)
[13:35:13.585]                           muffled <- TRUE
[13:35:13.585]                           break
[13:35:13.585]                         }
[13:35:13.585]                       }
[13:35:13.585]                     }
[13:35:13.585]                     invisible(muffled)
[13:35:13.585]                   }
[13:35:13.585]                   muffleCondition(cond)
[13:35:13.585]                 })
[13:35:13.585]             }))
[13:35:13.585]             future::FutureResult(value = ...future.value$value, 
[13:35:13.585]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:13.585]                   ...future.rng), globalenv = if (FALSE) 
[13:35:13.585]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:13.585]                     ...future.globalenv.names))
[13:35:13.585]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:13.585]         }, condition = base::local({
[13:35:13.585]             c <- base::c
[13:35:13.585]             inherits <- base::inherits
[13:35:13.585]             invokeRestart <- base::invokeRestart
[13:35:13.585]             length <- base::length
[13:35:13.585]             list <- base::list
[13:35:13.585]             seq.int <- base::seq.int
[13:35:13.585]             signalCondition <- base::signalCondition
[13:35:13.585]             sys.calls <- base::sys.calls
[13:35:13.585]             `[[` <- base::`[[`
[13:35:13.585]             `+` <- base::`+`
[13:35:13.585]             `<<-` <- base::`<<-`
[13:35:13.585]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:13.585]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:13.585]                   3L)]
[13:35:13.585]             }
[13:35:13.585]             function(cond) {
[13:35:13.585]                 is_error <- inherits(cond, "error")
[13:35:13.585]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:13.585]                   NULL)
[13:35:13.585]                 if (is_error) {
[13:35:13.585]                   sessionInformation <- function() {
[13:35:13.585]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:13.585]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:13.585]                       search = base::search(), system = base::Sys.info())
[13:35:13.585]                   }
[13:35:13.585]                   ...future.conditions[[length(...future.conditions) + 
[13:35:13.585]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:13.585]                     cond$call), session = sessionInformation(), 
[13:35:13.585]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:13.585]                   signalCondition(cond)
[13:35:13.585]                 }
[13:35:13.585]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:13.585]                 "immediateCondition"))) {
[13:35:13.585]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:13.585]                   ...future.conditions[[length(...future.conditions) + 
[13:35:13.585]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:13.585]                   if (TRUE && !signal) {
[13:35:13.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.585]                     {
[13:35:13.585]                       inherits <- base::inherits
[13:35:13.585]                       invokeRestart <- base::invokeRestart
[13:35:13.585]                       is.null <- base::is.null
[13:35:13.585]                       muffled <- FALSE
[13:35:13.585]                       if (inherits(cond, "message")) {
[13:35:13.585]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:13.585]                         if (muffled) 
[13:35:13.585]                           invokeRestart("muffleMessage")
[13:35:13.585]                       }
[13:35:13.585]                       else if (inherits(cond, "warning")) {
[13:35:13.585]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:13.585]                         if (muffled) 
[13:35:13.585]                           invokeRestart("muffleWarning")
[13:35:13.585]                       }
[13:35:13.585]                       else if (inherits(cond, "condition")) {
[13:35:13.585]                         if (!is.null(pattern)) {
[13:35:13.585]                           computeRestarts <- base::computeRestarts
[13:35:13.585]                           grepl <- base::grepl
[13:35:13.585]                           restarts <- computeRestarts(cond)
[13:35:13.585]                           for (restart in restarts) {
[13:35:13.585]                             name <- restart$name
[13:35:13.585]                             if (is.null(name)) 
[13:35:13.585]                               next
[13:35:13.585]                             if (!grepl(pattern, name)) 
[13:35:13.585]                               next
[13:35:13.585]                             invokeRestart(restart)
[13:35:13.585]                             muffled <- TRUE
[13:35:13.585]                             break
[13:35:13.585]                           }
[13:35:13.585]                         }
[13:35:13.585]                       }
[13:35:13.585]                       invisible(muffled)
[13:35:13.585]                     }
[13:35:13.585]                     muffleCondition(cond, pattern = "^muffle")
[13:35:13.585]                   }
[13:35:13.585]                 }
[13:35:13.585]                 else {
[13:35:13.585]                   if (TRUE) {
[13:35:13.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.585]                     {
[13:35:13.585]                       inherits <- base::inherits
[13:35:13.585]                       invokeRestart <- base::invokeRestart
[13:35:13.585]                       is.null <- base::is.null
[13:35:13.585]                       muffled <- FALSE
[13:35:13.585]                       if (inherits(cond, "message")) {
[13:35:13.585]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:13.585]                         if (muffled) 
[13:35:13.585]                           invokeRestart("muffleMessage")
[13:35:13.585]                       }
[13:35:13.585]                       else if (inherits(cond, "warning")) {
[13:35:13.585]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:13.585]                         if (muffled) 
[13:35:13.585]                           invokeRestart("muffleWarning")
[13:35:13.585]                       }
[13:35:13.585]                       else if (inherits(cond, "condition")) {
[13:35:13.585]                         if (!is.null(pattern)) {
[13:35:13.585]                           computeRestarts <- base::computeRestarts
[13:35:13.585]                           grepl <- base::grepl
[13:35:13.585]                           restarts <- computeRestarts(cond)
[13:35:13.585]                           for (restart in restarts) {
[13:35:13.585]                             name <- restart$name
[13:35:13.585]                             if (is.null(name)) 
[13:35:13.585]                               next
[13:35:13.585]                             if (!grepl(pattern, name)) 
[13:35:13.585]                               next
[13:35:13.585]                             invokeRestart(restart)
[13:35:13.585]                             muffled <- TRUE
[13:35:13.585]                             break
[13:35:13.585]                           }
[13:35:13.585]                         }
[13:35:13.585]                       }
[13:35:13.585]                       invisible(muffled)
[13:35:13.585]                     }
[13:35:13.585]                     muffleCondition(cond, pattern = "^muffle")
[13:35:13.585]                   }
[13:35:13.585]                 }
[13:35:13.585]             }
[13:35:13.585]         }))
[13:35:13.585]     }, error = function(ex) {
[13:35:13.585]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:13.585]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:13.585]                 ...future.rng), started = ...future.startTime, 
[13:35:13.585]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:13.585]             version = "1.8"), class = "FutureResult")
[13:35:13.585]     }, finally = {
[13:35:13.585]         if (!identical(...future.workdir, getwd())) 
[13:35:13.585]             setwd(...future.workdir)
[13:35:13.585]         {
[13:35:13.585]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:13.585]                 ...future.oldOptions$nwarnings <- NULL
[13:35:13.585]             }
[13:35:13.585]             base::options(...future.oldOptions)
[13:35:13.585]             if (.Platform$OS.type == "windows") {
[13:35:13.585]                 old_names <- names(...future.oldEnvVars)
[13:35:13.585]                 envs <- base::Sys.getenv()
[13:35:13.585]                 names <- names(envs)
[13:35:13.585]                 common <- intersect(names, old_names)
[13:35:13.585]                 added <- setdiff(names, old_names)
[13:35:13.585]                 removed <- setdiff(old_names, names)
[13:35:13.585]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:13.585]                   envs[common]]
[13:35:13.585]                 NAMES <- toupper(changed)
[13:35:13.585]                 args <- list()
[13:35:13.585]                 for (kk in seq_along(NAMES)) {
[13:35:13.585]                   name <- changed[[kk]]
[13:35:13.585]                   NAME <- NAMES[[kk]]
[13:35:13.585]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.585]                     next
[13:35:13.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:13.585]                 }
[13:35:13.585]                 NAMES <- toupper(added)
[13:35:13.585]                 for (kk in seq_along(NAMES)) {
[13:35:13.585]                   name <- added[[kk]]
[13:35:13.585]                   NAME <- NAMES[[kk]]
[13:35:13.585]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.585]                     next
[13:35:13.585]                   args[[name]] <- ""
[13:35:13.585]                 }
[13:35:13.585]                 NAMES <- toupper(removed)
[13:35:13.585]                 for (kk in seq_along(NAMES)) {
[13:35:13.585]                   name <- removed[[kk]]
[13:35:13.585]                   NAME <- NAMES[[kk]]
[13:35:13.585]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.585]                     next
[13:35:13.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:13.585]                 }
[13:35:13.585]                 if (length(args) > 0) 
[13:35:13.585]                   base::do.call(base::Sys.setenv, args = args)
[13:35:13.585]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:13.585]             }
[13:35:13.585]             else {
[13:35:13.585]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:13.585]             }
[13:35:13.585]             {
[13:35:13.585]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:13.585]                   0L) {
[13:35:13.585]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:13.585]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:13.585]                   base::options(opts)
[13:35:13.585]                 }
[13:35:13.585]                 {
[13:35:13.585]                   {
[13:35:13.585]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:13.585]                     NULL
[13:35:13.585]                   }
[13:35:13.585]                   options(future.plan = NULL)
[13:35:13.585]                   if (is.na(NA_character_)) 
[13:35:13.585]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:13.585]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:13.585]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:13.585]                     .init = FALSE)
[13:35:13.585]                 }
[13:35:13.585]             }
[13:35:13.585]         }
[13:35:13.585]     })
[13:35:13.585]     if (TRUE) {
[13:35:13.585]         base::sink(type = "output", split = FALSE)
[13:35:13.585]         if (TRUE) {
[13:35:13.585]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:13.585]         }
[13:35:13.585]         else {
[13:35:13.585]             ...future.result["stdout"] <- base::list(NULL)
[13:35:13.585]         }
[13:35:13.585]         base::close(...future.stdout)
[13:35:13.585]         ...future.stdout <- NULL
[13:35:13.585]     }
[13:35:13.585]     ...future.result$conditions <- ...future.conditions
[13:35:13.585]     ...future.result$finished <- base::Sys.time()
[13:35:13.585]     ...future.result
[13:35:13.585] }
[13:35:13.588] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[13:35:13.588] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[13:35:13.588] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[13:35:13.589] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[13:35:13.589] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[13:35:13.589] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:35:13.590] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:35:13.590] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:13.590] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:13.590] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:13.591] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:13.591] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[13:35:13.591] MultisessionFuture started
[13:35:13.591] - Launch lazy future ... done
[13:35:13.592] run() for ‘MultisessionFuture’ ... done
[13:35:13.592] Created future:
[13:35:13.592] MultisessionFuture:
[13:35:13.592] Label: ‘future_sapply-1’
[13:35:13.592] Expression:
[13:35:13.592] {
[13:35:13.592]     do.call(function(...) {
[13:35:13.592]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.592]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:13.592]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.592]             on.exit(options(oopts), add = TRUE)
[13:35:13.592]         }
[13:35:13.592]         {
[13:35:13.592]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:13.592]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.592]                 ...future.FUN(...future.X_jj, ...)
[13:35:13.592]             })
[13:35:13.592]         }
[13:35:13.592]     }, args = future.call.arguments)
[13:35:13.592] }
[13:35:13.592] Lazy evaluation: FALSE
[13:35:13.592] Asynchronous evaluation: TRUE
[13:35:13.592] Local evaluation: TRUE
[13:35:13.592] Environment: R_GlobalEnv
[13:35:13.592] Capture standard output: TRUE
[13:35:13.592] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:13.592] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:13.592] Packages: <none>
[13:35:13.592] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:13.592] Resolved: FALSE
[13:35:13.592] Value: <not collected>
[13:35:13.592] Conditions captured: <none>
[13:35:13.592] Early signaling: FALSE
[13:35:13.592] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:13.592] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:13.603] Chunk #1 of 2 ... DONE
[13:35:13.603] Chunk #2 of 2 ...
[13:35:13.603]  - Finding globals in 'X' for chunk #2 ...
[13:35:13.604] getGlobalsAndPackages() ...
[13:35:13.604] Searching for globals...
[13:35:13.604] 
[13:35:13.604] Searching for globals ... DONE
[13:35:13.604] - globals: [0] <none>
[13:35:13.604] getGlobalsAndPackages() ... DONE
[13:35:13.604]    + additional globals found: [n=0] 
[13:35:13.604]    + additional namespaces needed: [n=0] 
[13:35:13.604]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:13.605]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:13.605]  - seeds: <none>
[13:35:13.605]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.605] getGlobalsAndPackages() ...
[13:35:13.605] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.605] Resolving globals: FALSE
[13:35:13.605] Tweak future expression to call with '...' arguments ...
[13:35:13.605] {
[13:35:13.605]     do.call(function(...) {
[13:35:13.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:13.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.605]             on.exit(options(oopts), add = TRUE)
[13:35:13.605]         }
[13:35:13.605]         {
[13:35:13.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:13.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.605]                 ...future.FUN(...future.X_jj, ...)
[13:35:13.605]             })
[13:35:13.605]         }
[13:35:13.605]     }, args = future.call.arguments)
[13:35:13.605] }
[13:35:13.605] Tweak future expression to call with '...' arguments ... DONE
[13:35:13.606] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.606] 
[13:35:13.606] getGlobalsAndPackages() ... DONE
[13:35:13.606] run() for ‘Future’ ...
[13:35:13.606] - state: ‘created’
[13:35:13.607] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:13.620] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:13.620] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:13.620]   - Field: ‘node’
[13:35:13.620]   - Field: ‘label’
[13:35:13.620]   - Field: ‘local’
[13:35:13.620]   - Field: ‘owner’
[13:35:13.621]   - Field: ‘envir’
[13:35:13.621]   - Field: ‘workers’
[13:35:13.621]   - Field: ‘packages’
[13:35:13.621]   - Field: ‘gc’
[13:35:13.621]   - Field: ‘conditions’
[13:35:13.621]   - Field: ‘persistent’
[13:35:13.621]   - Field: ‘expr’
[13:35:13.621]   - Field: ‘uuid’
[13:35:13.621]   - Field: ‘seed’
[13:35:13.621]   - Field: ‘version’
[13:35:13.621]   - Field: ‘result’
[13:35:13.622]   - Field: ‘asynchronous’
[13:35:13.622]   - Field: ‘calls’
[13:35:13.622]   - Field: ‘globals’
[13:35:13.622]   - Field: ‘stdout’
[13:35:13.622]   - Field: ‘earlySignal’
[13:35:13.622]   - Field: ‘lazy’
[13:35:13.622]   - Field: ‘state’
[13:35:13.622] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:13.622] - Launch lazy future ...
[13:35:13.623] Packages needed by the future expression (n = 0): <none>
[13:35:13.623] Packages needed by future strategies (n = 0): <none>
[13:35:13.623] {
[13:35:13.623]     {
[13:35:13.623]         {
[13:35:13.623]             ...future.startTime <- base::Sys.time()
[13:35:13.623]             {
[13:35:13.623]                 {
[13:35:13.623]                   {
[13:35:13.623]                     {
[13:35:13.623]                       base::local({
[13:35:13.623]                         has_future <- base::requireNamespace("future", 
[13:35:13.623]                           quietly = TRUE)
[13:35:13.623]                         if (has_future) {
[13:35:13.623]                           ns <- base::getNamespace("future")
[13:35:13.623]                           version <- ns[[".package"]][["version"]]
[13:35:13.623]                           if (is.null(version)) 
[13:35:13.623]                             version <- utils::packageVersion("future")
[13:35:13.623]                         }
[13:35:13.623]                         else {
[13:35:13.623]                           version <- NULL
[13:35:13.623]                         }
[13:35:13.623]                         if (!has_future || version < "1.8.0") {
[13:35:13.623]                           info <- base::c(r_version = base::gsub("R version ", 
[13:35:13.623]                             "", base::R.version$version.string), 
[13:35:13.623]                             platform = base::sprintf("%s (%s-bit)", 
[13:35:13.623]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[13:35:13.623]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:13.623]                               "release", "version")], collapse = " "), 
[13:35:13.623]                             hostname = base::Sys.info()[["nodename"]])
[13:35:13.623]                           info <- base::sprintf("%s: %s", base::names(info), 
[13:35:13.623]                             info)
[13:35:13.623]                           info <- base::paste(info, collapse = "; ")
[13:35:13.623]                           if (!has_future) {
[13:35:13.623]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:13.623]                               info)
[13:35:13.623]                           }
[13:35:13.623]                           else {
[13:35:13.623]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:13.623]                               info, version)
[13:35:13.623]                           }
[13:35:13.623]                           base::stop(msg)
[13:35:13.623]                         }
[13:35:13.623]                       })
[13:35:13.623]                     }
[13:35:13.623]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:13.623]                     base::options(mc.cores = 1L)
[13:35:13.623]                   }
[13:35:13.623]                   ...future.strategy.old <- future::plan("list")
[13:35:13.623]                   options(future.plan = NULL)
[13:35:13.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:13.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:13.623]                 }
[13:35:13.623]                 ...future.workdir <- getwd()
[13:35:13.623]             }
[13:35:13.623]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:13.623]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:13.623]         }
[13:35:13.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:13.623]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:13.623]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:13.623]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:13.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:13.623]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:13.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:13.623]             base::names(...future.oldOptions))
[13:35:13.623]     }
[13:35:13.623]     if (FALSE) {
[13:35:13.623]     }
[13:35:13.623]     else {
[13:35:13.623]         if (TRUE) {
[13:35:13.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:13.623]                 open = "w")
[13:35:13.623]         }
[13:35:13.623]         else {
[13:35:13.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:13.623]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:13.623]         }
[13:35:13.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:13.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:13.623]             base::sink(type = "output", split = FALSE)
[13:35:13.623]             base::close(...future.stdout)
[13:35:13.623]         }, add = TRUE)
[13:35:13.623]     }
[13:35:13.623]     ...future.frame <- base::sys.nframe()
[13:35:13.623]     ...future.conditions <- base::list()
[13:35:13.623]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:13.623]     if (FALSE) {
[13:35:13.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:13.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:13.623]     }
[13:35:13.623]     ...future.result <- base::tryCatch({
[13:35:13.623]         base::withCallingHandlers({
[13:35:13.623]             ...future.value <- base::withVisible(base::local({
[13:35:13.623]                 ...future.makeSendCondition <- base::local({
[13:35:13.623]                   sendCondition <- NULL
[13:35:13.623]                   function(frame = 1L) {
[13:35:13.623]                     if (is.function(sendCondition)) 
[13:35:13.623]                       return(sendCondition)
[13:35:13.623]                     ns <- getNamespace("parallel")
[13:35:13.623]                     if (exists("sendData", mode = "function", 
[13:35:13.623]                       envir = ns)) {
[13:35:13.623]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:13.623]                         envir = ns)
[13:35:13.623]                       envir <- sys.frame(frame)
[13:35:13.623]                       master <- NULL
[13:35:13.623]                       while (!identical(envir, .GlobalEnv) && 
[13:35:13.623]                         !identical(envir, emptyenv())) {
[13:35:13.623]                         if (exists("master", mode = "list", envir = envir, 
[13:35:13.623]                           inherits = FALSE)) {
[13:35:13.623]                           master <- get("master", mode = "list", 
[13:35:13.623]                             envir = envir, inherits = FALSE)
[13:35:13.623]                           if (inherits(master, c("SOCKnode", 
[13:35:13.623]                             "SOCK0node"))) {
[13:35:13.623]                             sendCondition <<- function(cond) {
[13:35:13.623]                               data <- list(type = "VALUE", value = cond, 
[13:35:13.623]                                 success = TRUE)
[13:35:13.623]                               parallel_sendData(master, data)
[13:35:13.623]                             }
[13:35:13.623]                             return(sendCondition)
[13:35:13.623]                           }
[13:35:13.623]                         }
[13:35:13.623]                         frame <- frame + 1L
[13:35:13.623]                         envir <- sys.frame(frame)
[13:35:13.623]                       }
[13:35:13.623]                     }
[13:35:13.623]                     sendCondition <<- function(cond) NULL
[13:35:13.623]                   }
[13:35:13.623]                 })
[13:35:13.623]                 withCallingHandlers({
[13:35:13.623]                   {
[13:35:13.623]                     do.call(function(...) {
[13:35:13.623]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.623]                       if (!identical(...future.globals.maxSize.org, 
[13:35:13.623]                         ...future.globals.maxSize)) {
[13:35:13.623]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.623]                         on.exit(options(oopts), add = TRUE)
[13:35:13.623]                       }
[13:35:13.623]                       {
[13:35:13.623]                         lapply(seq_along(...future.elements_ii), 
[13:35:13.623]                           FUN = function(jj) {
[13:35:13.623]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.623]                             ...future.FUN(...future.X_jj, ...)
[13:35:13.623]                           })
[13:35:13.623]                       }
[13:35:13.623]                     }, args = future.call.arguments)
[13:35:13.623]                   }
[13:35:13.623]                 }, immediateCondition = function(cond) {
[13:35:13.623]                   sendCondition <- ...future.makeSendCondition()
[13:35:13.623]                   sendCondition(cond)
[13:35:13.623]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.623]                   {
[13:35:13.623]                     inherits <- base::inherits
[13:35:13.623]                     invokeRestart <- base::invokeRestart
[13:35:13.623]                     is.null <- base::is.null
[13:35:13.623]                     muffled <- FALSE
[13:35:13.623]                     if (inherits(cond, "message")) {
[13:35:13.623]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:13.623]                       if (muffled) 
[13:35:13.623]                         invokeRestart("muffleMessage")
[13:35:13.623]                     }
[13:35:13.623]                     else if (inherits(cond, "warning")) {
[13:35:13.623]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:13.623]                       if (muffled) 
[13:35:13.623]                         invokeRestart("muffleWarning")
[13:35:13.623]                     }
[13:35:13.623]                     else if (inherits(cond, "condition")) {
[13:35:13.623]                       if (!is.null(pattern)) {
[13:35:13.623]                         computeRestarts <- base::computeRestarts
[13:35:13.623]                         grepl <- base::grepl
[13:35:13.623]                         restarts <- computeRestarts(cond)
[13:35:13.623]                         for (restart in restarts) {
[13:35:13.623]                           name <- restart$name
[13:35:13.623]                           if (is.null(name)) 
[13:35:13.623]                             next
[13:35:13.623]                           if (!grepl(pattern, name)) 
[13:35:13.623]                             next
[13:35:13.623]                           invokeRestart(restart)
[13:35:13.623]                           muffled <- TRUE
[13:35:13.623]                           break
[13:35:13.623]                         }
[13:35:13.623]                       }
[13:35:13.623]                     }
[13:35:13.623]                     invisible(muffled)
[13:35:13.623]                   }
[13:35:13.623]                   muffleCondition(cond)
[13:35:13.623]                 })
[13:35:13.623]             }))
[13:35:13.623]             future::FutureResult(value = ...future.value$value, 
[13:35:13.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:13.623]                   ...future.rng), globalenv = if (FALSE) 
[13:35:13.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:13.623]                     ...future.globalenv.names))
[13:35:13.623]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:13.623]         }, condition = base::local({
[13:35:13.623]             c <- base::c
[13:35:13.623]             inherits <- base::inherits
[13:35:13.623]             invokeRestart <- base::invokeRestart
[13:35:13.623]             length <- base::length
[13:35:13.623]             list <- base::list
[13:35:13.623]             seq.int <- base::seq.int
[13:35:13.623]             signalCondition <- base::signalCondition
[13:35:13.623]             sys.calls <- base::sys.calls
[13:35:13.623]             `[[` <- base::`[[`
[13:35:13.623]             `+` <- base::`+`
[13:35:13.623]             `<<-` <- base::`<<-`
[13:35:13.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:13.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:13.623]                   3L)]
[13:35:13.623]             }
[13:35:13.623]             function(cond) {
[13:35:13.623]                 is_error <- inherits(cond, "error")
[13:35:13.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:13.623]                   NULL)
[13:35:13.623]                 if (is_error) {
[13:35:13.623]                   sessionInformation <- function() {
[13:35:13.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:13.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:13.623]                       search = base::search(), system = base::Sys.info())
[13:35:13.623]                   }
[13:35:13.623]                   ...future.conditions[[length(...future.conditions) + 
[13:35:13.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:13.623]                     cond$call), session = sessionInformation(), 
[13:35:13.623]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:13.623]                   signalCondition(cond)
[13:35:13.623]                 }
[13:35:13.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:13.623]                 "immediateCondition"))) {
[13:35:13.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:13.623]                   ...future.conditions[[length(...future.conditions) + 
[13:35:13.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:13.623]                   if (TRUE && !signal) {
[13:35:13.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.623]                     {
[13:35:13.623]                       inherits <- base::inherits
[13:35:13.623]                       invokeRestart <- base::invokeRestart
[13:35:13.623]                       is.null <- base::is.null
[13:35:13.623]                       muffled <- FALSE
[13:35:13.623]                       if (inherits(cond, "message")) {
[13:35:13.623]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:13.623]                         if (muffled) 
[13:35:13.623]                           invokeRestart("muffleMessage")
[13:35:13.623]                       }
[13:35:13.623]                       else if (inherits(cond, "warning")) {
[13:35:13.623]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:13.623]                         if (muffled) 
[13:35:13.623]                           invokeRestart("muffleWarning")
[13:35:13.623]                       }
[13:35:13.623]                       else if (inherits(cond, "condition")) {
[13:35:13.623]                         if (!is.null(pattern)) {
[13:35:13.623]                           computeRestarts <- base::computeRestarts
[13:35:13.623]                           grepl <- base::grepl
[13:35:13.623]                           restarts <- computeRestarts(cond)
[13:35:13.623]                           for (restart in restarts) {
[13:35:13.623]                             name <- restart$name
[13:35:13.623]                             if (is.null(name)) 
[13:35:13.623]                               next
[13:35:13.623]                             if (!grepl(pattern, name)) 
[13:35:13.623]                               next
[13:35:13.623]                             invokeRestart(restart)
[13:35:13.623]                             muffled <- TRUE
[13:35:13.623]                             break
[13:35:13.623]                           }
[13:35:13.623]                         }
[13:35:13.623]                       }
[13:35:13.623]                       invisible(muffled)
[13:35:13.623]                     }
[13:35:13.623]                     muffleCondition(cond, pattern = "^muffle")
[13:35:13.623]                   }
[13:35:13.623]                 }
[13:35:13.623]                 else {
[13:35:13.623]                   if (TRUE) {
[13:35:13.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.623]                     {
[13:35:13.623]                       inherits <- base::inherits
[13:35:13.623]                       invokeRestart <- base::invokeRestart
[13:35:13.623]                       is.null <- base::is.null
[13:35:13.623]                       muffled <- FALSE
[13:35:13.623]                       if (inherits(cond, "message")) {
[13:35:13.623]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:13.623]                         if (muffled) 
[13:35:13.623]                           invokeRestart("muffleMessage")
[13:35:13.623]                       }
[13:35:13.623]                       else if (inherits(cond, "warning")) {
[13:35:13.623]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:13.623]                         if (muffled) 
[13:35:13.623]                           invokeRestart("muffleWarning")
[13:35:13.623]                       }
[13:35:13.623]                       else if (inherits(cond, "condition")) {
[13:35:13.623]                         if (!is.null(pattern)) {
[13:35:13.623]                           computeRestarts <- base::computeRestarts
[13:35:13.623]                           grepl <- base::grepl
[13:35:13.623]                           restarts <- computeRestarts(cond)
[13:35:13.623]                           for (restart in restarts) {
[13:35:13.623]                             name <- restart$name
[13:35:13.623]                             if (is.null(name)) 
[13:35:13.623]                               next
[13:35:13.623]                             if (!grepl(pattern, name)) 
[13:35:13.623]                               next
[13:35:13.623]                             invokeRestart(restart)
[13:35:13.623]                             muffled <- TRUE
[13:35:13.623]                             break
[13:35:13.623]                           }
[13:35:13.623]                         }
[13:35:13.623]                       }
[13:35:13.623]                       invisible(muffled)
[13:35:13.623]                     }
[13:35:13.623]                     muffleCondition(cond, pattern = "^muffle")
[13:35:13.623]                   }
[13:35:13.623]                 }
[13:35:13.623]             }
[13:35:13.623]         }))
[13:35:13.623]     }, error = function(ex) {
[13:35:13.623]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:13.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:13.623]                 ...future.rng), started = ...future.startTime, 
[13:35:13.623]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:13.623]             version = "1.8"), class = "FutureResult")
[13:35:13.623]     }, finally = {
[13:35:13.623]         if (!identical(...future.workdir, getwd())) 
[13:35:13.623]             setwd(...future.workdir)
[13:35:13.623]         {
[13:35:13.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:13.623]                 ...future.oldOptions$nwarnings <- NULL
[13:35:13.623]             }
[13:35:13.623]             base::options(...future.oldOptions)
[13:35:13.623]             if (.Platform$OS.type == "windows") {
[13:35:13.623]                 old_names <- names(...future.oldEnvVars)
[13:35:13.623]                 envs <- base::Sys.getenv()
[13:35:13.623]                 names <- names(envs)
[13:35:13.623]                 common <- intersect(names, old_names)
[13:35:13.623]                 added <- setdiff(names, old_names)
[13:35:13.623]                 removed <- setdiff(old_names, names)
[13:35:13.623]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:13.623]                   envs[common]]
[13:35:13.623]                 NAMES <- toupper(changed)
[13:35:13.623]                 args <- list()
[13:35:13.623]                 for (kk in seq_along(NAMES)) {
[13:35:13.623]                   name <- changed[[kk]]
[13:35:13.623]                   NAME <- NAMES[[kk]]
[13:35:13.623]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.623]                     next
[13:35:13.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:13.623]                 }
[13:35:13.623]                 NAMES <- toupper(added)
[13:35:13.623]                 for (kk in seq_along(NAMES)) {
[13:35:13.623]                   name <- added[[kk]]
[13:35:13.623]                   NAME <- NAMES[[kk]]
[13:35:13.623]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.623]                     next
[13:35:13.623]                   args[[name]] <- ""
[13:35:13.623]                 }
[13:35:13.623]                 NAMES <- toupper(removed)
[13:35:13.623]                 for (kk in seq_along(NAMES)) {
[13:35:13.623]                   name <- removed[[kk]]
[13:35:13.623]                   NAME <- NAMES[[kk]]
[13:35:13.623]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.623]                     next
[13:35:13.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:13.623]                 }
[13:35:13.623]                 if (length(args) > 0) 
[13:35:13.623]                   base::do.call(base::Sys.setenv, args = args)
[13:35:13.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:13.623]             }
[13:35:13.623]             else {
[13:35:13.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:13.623]             }
[13:35:13.623]             {
[13:35:13.623]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:13.623]                   0L) {
[13:35:13.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:13.623]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:13.623]                   base::options(opts)
[13:35:13.623]                 }
[13:35:13.623]                 {
[13:35:13.623]                   {
[13:35:13.623]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:13.623]                     NULL
[13:35:13.623]                   }
[13:35:13.623]                   options(future.plan = NULL)
[13:35:13.623]                   if (is.na(NA_character_)) 
[13:35:13.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:13.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:13.623]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:13.623]                     .init = FALSE)
[13:35:13.623]                 }
[13:35:13.623]             }
[13:35:13.623]         }
[13:35:13.623]     })
[13:35:13.623]     if (TRUE) {
[13:35:13.623]         base::sink(type = "output", split = FALSE)
[13:35:13.623]         if (TRUE) {
[13:35:13.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:13.623]         }
[13:35:13.623]         else {
[13:35:13.623]             ...future.result["stdout"] <- base::list(NULL)
[13:35:13.623]         }
[13:35:13.623]         base::close(...future.stdout)
[13:35:13.623]         ...future.stdout <- NULL
[13:35:13.623]     }
[13:35:13.623]     ...future.result$conditions <- ...future.conditions
[13:35:13.623]     ...future.result$finished <- base::Sys.time()
[13:35:13.623]     ...future.result
[13:35:13.623] }
[13:35:13.626] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[13:35:13.626] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[13:35:13.626] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[13:35:13.626] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[13:35:13.627] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[13:35:13.627] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:35:13.627] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:35:13.627] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:13.628] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:13.628] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:13.628] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:13.628] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[13:35:13.629] MultisessionFuture started
[13:35:13.629] - Launch lazy future ... done
[13:35:13.629] run() for ‘MultisessionFuture’ ... done
[13:35:13.629] Created future:
[13:35:13.629] MultisessionFuture:
[13:35:13.629] Label: ‘future_sapply-2’
[13:35:13.629] Expression:
[13:35:13.629] {
[13:35:13.629]     do.call(function(...) {
[13:35:13.629]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.629]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:13.629]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.629]             on.exit(options(oopts), add = TRUE)
[13:35:13.629]         }
[13:35:13.629]         {
[13:35:13.629]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:13.629]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.629]                 ...future.FUN(...future.X_jj, ...)
[13:35:13.629]             })
[13:35:13.629]         }
[13:35:13.629]     }, args = future.call.arguments)
[13:35:13.629] }
[13:35:13.629] Lazy evaluation: FALSE
[13:35:13.629] Asynchronous evaluation: TRUE
[13:35:13.629] Local evaluation: TRUE
[13:35:13.629] Environment: R_GlobalEnv
[13:35:13.629] Capture standard output: TRUE
[13:35:13.629] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:13.629] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[13:35:13.629] Packages: <none>
[13:35:13.629] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:13.629] Resolved: FALSE
[13:35:13.629] Value: <not collected>
[13:35:13.629] Conditions captured: <none>
[13:35:13.629] Early signaling: FALSE
[13:35:13.629] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:13.629] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:13.640] Chunk #2 of 2 ... DONE
[13:35:13.641] Launching 2 futures (chunks) ... DONE
[13:35:13.641] Resolving 2 futures (chunks) ...
[13:35:13.641] resolve() on list ...
[13:35:13.641]  recursive: 0
[13:35:13.641]  length: 2
[13:35:13.641] 
[13:35:13.642] receiveMessageFromWorker() for ClusterFuture ...
[13:35:13.642] - Validating connection of MultisessionFuture
[13:35:13.642] - received message: FutureResult
[13:35:13.642] - Received FutureResult
[13:35:13.642] - Erased future from FutureRegistry
[13:35:13.642] result() for ClusterFuture ...
[13:35:13.642] - result already collected: FutureResult
[13:35:13.642] result() for ClusterFuture ... done
[13:35:13.643] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:13.643] Future #1
[13:35:13.643] result() for ClusterFuture ...
[13:35:13.643] - result already collected: FutureResult
[13:35:13.643] result() for ClusterFuture ... done
[13:35:13.643] result() for ClusterFuture ...
[13:35:13.643] - result already collected: FutureResult
[13:35:13.643] result() for ClusterFuture ... done
[13:35:13.643] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:13.643] - nx: 2
[13:35:13.643] - relay: TRUE
[13:35:13.644] - stdout: TRUE
[13:35:13.644] - signal: TRUE
[13:35:13.644] - resignal: FALSE
[13:35:13.644] - force: TRUE
[13:35:13.644] - relayed: [n=2] FALSE, FALSE
[13:35:13.644] - queued futures: [n=2] FALSE, FALSE
[13:35:13.644]  - until=1
[13:35:13.644]  - relaying element #1
[13:35:13.644] result() for ClusterFuture ...
[13:35:13.644] - result already collected: FutureResult
[13:35:13.644] result() for ClusterFuture ... done
[13:35:13.644] result() for ClusterFuture ...
[13:35:13.645] - result already collected: FutureResult
[13:35:13.645] result() for ClusterFuture ... done
[13:35:13.645] result() for ClusterFuture ...
[13:35:13.645] - result already collected: FutureResult
[13:35:13.645] result() for ClusterFuture ... done
[13:35:13.645] result() for ClusterFuture ...
[13:35:13.645] - result already collected: FutureResult
[13:35:13.645] result() for ClusterFuture ... done
[13:35:13.645] - relayed: [n=2] TRUE, FALSE
[13:35:13.645] - queued futures: [n=2] TRUE, FALSE
[13:35:13.645] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:13.646]  length: 1 (resolved future 1)
[13:35:13.672] receiveMessageFromWorker() for ClusterFuture ...
[13:35:13.672] - Validating connection of MultisessionFuture
[13:35:13.672] - received message: FutureResult
[13:35:13.672] - Received FutureResult
[13:35:13.673] - Erased future from FutureRegistry
[13:35:13.673] result() for ClusterFuture ...
[13:35:13.673] - result already collected: FutureResult
[13:35:13.673] result() for ClusterFuture ... done
[13:35:13.673] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:13.673] Future #2
[13:35:13.673] result() for ClusterFuture ...
[13:35:13.673] - result already collected: FutureResult
[13:35:13.673] result() for ClusterFuture ... done
[13:35:13.673] result() for ClusterFuture ...
[13:35:13.673] - result already collected: FutureResult
[13:35:13.674] result() for ClusterFuture ... done
[13:35:13.674] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:13.674] - nx: 2
[13:35:13.674] - relay: TRUE
[13:35:13.674] - stdout: TRUE
[13:35:13.674] - signal: TRUE
[13:35:13.674] - resignal: FALSE
[13:35:13.674] - force: TRUE
[13:35:13.674] - relayed: [n=2] TRUE, FALSE
[13:35:13.674] - queued futures: [n=2] TRUE, FALSE
[13:35:13.674]  - until=2
[13:35:13.675]  - relaying element #2
[13:35:13.675] result() for ClusterFuture ...
[13:35:13.675] - result already collected: FutureResult
[13:35:13.675] result() for ClusterFuture ... done
[13:35:13.675] result() for ClusterFuture ...
[13:35:13.675] - result already collected: FutureResult
[13:35:13.675] result() for ClusterFuture ... done
[13:35:13.675] result() for ClusterFuture ...
[13:35:13.675] - result already collected: FutureResult
[13:35:13.675] result() for ClusterFuture ... done
[13:35:13.675] result() for ClusterFuture ...
[13:35:13.675] - result already collected: FutureResult
[13:35:13.676] result() for ClusterFuture ... done
[13:35:13.676] - relayed: [n=2] TRUE, TRUE
[13:35:13.676] - queued futures: [n=2] TRUE, TRUE
[13:35:13.676] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:13.676]  length: 0 (resolved future 2)
[13:35:13.676] Relaying remaining futures
[13:35:13.676] signalConditionsASAP(NULL, pos=0) ...
[13:35:13.676] - nx: 2
[13:35:13.676] - relay: TRUE
[13:35:13.676] - stdout: TRUE
[13:35:13.676] - signal: TRUE
[13:35:13.676] - resignal: FALSE
[13:35:13.677] - force: TRUE
[13:35:13.677] - relayed: [n=2] TRUE, TRUE
[13:35:13.677] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:13.677] - relayed: [n=2] TRUE, TRUE
[13:35:13.677] - queued futures: [n=2] TRUE, TRUE
[13:35:13.677] signalConditionsASAP(NULL, pos=0) ... done
[13:35:13.677] resolve() on list ... DONE
[13:35:13.677] result() for ClusterFuture ...
[13:35:13.677] - result already collected: FutureResult
[13:35:13.677] result() for ClusterFuture ... done
[13:35:13.677] result() for ClusterFuture ...
[13:35:13.678] - result already collected: FutureResult
[13:35:13.678] result() for ClusterFuture ... done
[13:35:13.678] result() for ClusterFuture ...
[13:35:13.678] - result already collected: FutureResult
[13:35:13.678] result() for ClusterFuture ... done
[13:35:13.678] result() for ClusterFuture ...
[13:35:13.678] - result already collected: FutureResult
[13:35:13.678] result() for ClusterFuture ... done
[13:35:13.678]  - Number of value chunks collected: 2
[13:35:13.678] Resolving 2 futures (chunks) ... DONE
[13:35:13.679] Reducing values from 2 chunks ...
[13:35:13.679]  - Number of values collected after concatenation: 4
[13:35:13.679]  - Number of values expected: 4
[13:35:13.679] Reducing values from 2 chunks ... DONE
[13:35:13.679] future_lapply() ... DONE
[13:35:13.679] future_lapply() ...
[13:35:13.685] Number of chunks: 2
[13:35:13.685] getGlobalsAndPackagesXApply() ...
[13:35:13.685]  - future.globals: TRUE
[13:35:13.685] getGlobalsAndPackages() ...
[13:35:13.685] Searching for globals...
[13:35:13.689] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[13:35:13.689] Searching for globals ... DONE
[13:35:13.689] Resolving globals: FALSE
[13:35:13.690] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[13:35:13.690] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:13.691] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:13.691] - packages: [1] ‘future.apply’
[13:35:13.691] getGlobalsAndPackages() ... DONE
[13:35:13.691]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:13.691]  - needed namespaces: [n=1] ‘future.apply’
[13:35:13.691] Finding globals ... DONE
[13:35:13.691]  - use_args: TRUE
[13:35:13.691]  - Getting '...' globals ...
[13:35:13.692] resolve() on list ...
[13:35:13.692]  recursive: 0
[13:35:13.692]  length: 1
[13:35:13.692]  elements: ‘...’
[13:35:13.692]  length: 0 (resolved future 1)
[13:35:13.692] resolve() on list ... DONE
[13:35:13.692]    - '...' content: [n=1] ‘y’
[13:35:13.692] List of 1
[13:35:13.692]  $ ...:List of 1
[13:35:13.692]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:13.692]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:13.692]  - attr(*, "where")=List of 1
[13:35:13.692]   ..$ ...:<environment: 0x5574d2c19168> 
[13:35:13.692]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:13.692]  - attr(*, "resolved")= logi TRUE
[13:35:13.692]  - attr(*, "total_size")= num NA
[13:35:13.698]  - Getting '...' globals ... DONE
[13:35:13.698] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:13.698] List of 8
[13:35:13.698]  $ ...future.FUN:function (x, ...)  
[13:35:13.698]  $ x_FUN        :function (x, y)  
[13:35:13.698]  $ times        : int 15
[13:35:13.698]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:13.698]  $ stop_if_not  :function (...)  
[13:35:13.698]  $ dim          : int [1:2] 3 5
[13:35:13.698]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:13.698]  $ ...          :List of 1
[13:35:13.698]   ..$ y: num [1:5] 2 4 6 8 10
[13:35:13.698]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:13.698]  - attr(*, "where")=List of 8
[13:35:13.698]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:13.698]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:13.698]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:13.698]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:13.698]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:13.698]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:13.698]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:13.698]   ..$ ...          :<environment: 0x5574d2c19168> 
[13:35:13.698]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:13.698]  - attr(*, "resolved")= logi FALSE
[13:35:13.698]  - attr(*, "total_size")= num 98600
[13:35:13.704] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:13.704] getGlobalsAndPackagesXApply() ... DONE
[13:35:13.704] Number of futures (= number of chunks): 2
[13:35:13.704] Launching 2 futures (chunks) ...
[13:35:13.705] Chunk #1 of 2 ...
[13:35:13.705]  - Finding globals in 'X' for chunk #1 ...
[13:35:13.705] getGlobalsAndPackages() ...
[13:35:13.705] Searching for globals...
[13:35:13.705] 
[13:35:13.705] Searching for globals ... DONE
[13:35:13.705] - globals: [0] <none>
[13:35:13.705] getGlobalsAndPackages() ... DONE
[13:35:13.706]    + additional globals found: [n=0] 
[13:35:13.706]    + additional namespaces needed: [n=0] 
[13:35:13.706]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:13.706]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:13.706]  - seeds: <none>
[13:35:13.706]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.706] getGlobalsAndPackages() ...
[13:35:13.706] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.706] Resolving globals: FALSE
[13:35:13.707] Tweak future expression to call with '...' arguments ...
[13:35:13.707] {
[13:35:13.707]     do.call(function(...) {
[13:35:13.707]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.707]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:13.707]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.707]             on.exit(options(oopts), add = TRUE)
[13:35:13.707]         }
[13:35:13.707]         {
[13:35:13.707]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:13.707]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.707]                 ...future.FUN(...future.X_jj, ...)
[13:35:13.707]             })
[13:35:13.707]         }
[13:35:13.707]     }, args = future.call.arguments)
[13:35:13.707] }
[13:35:13.707] Tweak future expression to call with '...' arguments ... DONE
[13:35:13.707] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.708] - packages: [1] ‘future.apply’
[13:35:13.708] getGlobalsAndPackages() ... DONE
[13:35:13.708] run() for ‘Future’ ...
[13:35:13.708] - state: ‘created’
[13:35:13.708] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:13.723] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:13.724] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:13.724]   - Field: ‘node’
[13:35:13.724]   - Field: ‘label’
[13:35:13.724]   - Field: ‘local’
[13:35:13.724]   - Field: ‘owner’
[13:35:13.724]   - Field: ‘envir’
[13:35:13.724]   - Field: ‘workers’
[13:35:13.724]   - Field: ‘packages’
[13:35:13.724]   - Field: ‘gc’
[13:35:13.725]   - Field: ‘conditions’
[13:35:13.725]   - Field: ‘persistent’
[13:35:13.725]   - Field: ‘expr’
[13:35:13.725]   - Field: ‘uuid’
[13:35:13.725]   - Field: ‘seed’
[13:35:13.725]   - Field: ‘version’
[13:35:13.725]   - Field: ‘result’
[13:35:13.725]   - Field: ‘asynchronous’
[13:35:13.725]   - Field: ‘calls’
[13:35:13.725]   - Field: ‘globals’
[13:35:13.725]   - Field: ‘stdout’
[13:35:13.726]   - Field: ‘earlySignal’
[13:35:13.726]   - Field: ‘lazy’
[13:35:13.726]   - Field: ‘state’
[13:35:13.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:13.726] - Launch lazy future ...
[13:35:13.726] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:13.726] Packages needed by future strategies (n = 0): <none>
[13:35:13.727] {
[13:35:13.727]     {
[13:35:13.727]         {
[13:35:13.727]             ...future.startTime <- base::Sys.time()
[13:35:13.727]             {
[13:35:13.727]                 {
[13:35:13.727]                   {
[13:35:13.727]                     {
[13:35:13.727]                       {
[13:35:13.727]                         base::local({
[13:35:13.727]                           has_future <- base::requireNamespace("future", 
[13:35:13.727]                             quietly = TRUE)
[13:35:13.727]                           if (has_future) {
[13:35:13.727]                             ns <- base::getNamespace("future")
[13:35:13.727]                             version <- ns[[".package"]][["version"]]
[13:35:13.727]                             if (is.null(version)) 
[13:35:13.727]                               version <- utils::packageVersion("future")
[13:35:13.727]                           }
[13:35:13.727]                           else {
[13:35:13.727]                             version <- NULL
[13:35:13.727]                           }
[13:35:13.727]                           if (!has_future || version < "1.8.0") {
[13:35:13.727]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:13.727]                               "", base::R.version$version.string), 
[13:35:13.727]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:13.727]                                 base::R.version$platform, 8 * 
[13:35:13.727]                                   base::.Machine$sizeof.pointer), 
[13:35:13.727]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:13.727]                                 "release", "version")], collapse = " "), 
[13:35:13.727]                               hostname = base::Sys.info()[["nodename"]])
[13:35:13.727]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:13.727]                               info)
[13:35:13.727]                             info <- base::paste(info, collapse = "; ")
[13:35:13.727]                             if (!has_future) {
[13:35:13.727]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:13.727]                                 info)
[13:35:13.727]                             }
[13:35:13.727]                             else {
[13:35:13.727]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:13.727]                                 info, version)
[13:35:13.727]                             }
[13:35:13.727]                             base::stop(msg)
[13:35:13.727]                           }
[13:35:13.727]                         })
[13:35:13.727]                       }
[13:35:13.727]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:13.727]                       base::options(mc.cores = 1L)
[13:35:13.727]                     }
[13:35:13.727]                     base::local({
[13:35:13.727]                       for (pkg in "future.apply") {
[13:35:13.727]                         base::loadNamespace(pkg)
[13:35:13.727]                         base::library(pkg, character.only = TRUE)
[13:35:13.727]                       }
[13:35:13.727]                     })
[13:35:13.727]                   }
[13:35:13.727]                   ...future.strategy.old <- future::plan("list")
[13:35:13.727]                   options(future.plan = NULL)
[13:35:13.727]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:13.727]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:13.727]                 }
[13:35:13.727]                 ...future.workdir <- getwd()
[13:35:13.727]             }
[13:35:13.727]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:13.727]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:13.727]         }
[13:35:13.727]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:13.727]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:13.727]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:13.727]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:13.727]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:13.727]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:13.727]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:13.727]             base::names(...future.oldOptions))
[13:35:13.727]     }
[13:35:13.727]     if (FALSE) {
[13:35:13.727]     }
[13:35:13.727]     else {
[13:35:13.727]         if (TRUE) {
[13:35:13.727]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:13.727]                 open = "w")
[13:35:13.727]         }
[13:35:13.727]         else {
[13:35:13.727]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:13.727]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:13.727]         }
[13:35:13.727]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:13.727]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:13.727]             base::sink(type = "output", split = FALSE)
[13:35:13.727]             base::close(...future.stdout)
[13:35:13.727]         }, add = TRUE)
[13:35:13.727]     }
[13:35:13.727]     ...future.frame <- base::sys.nframe()
[13:35:13.727]     ...future.conditions <- base::list()
[13:35:13.727]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:13.727]     if (FALSE) {
[13:35:13.727]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:13.727]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:13.727]     }
[13:35:13.727]     ...future.result <- base::tryCatch({
[13:35:13.727]         base::withCallingHandlers({
[13:35:13.727]             ...future.value <- base::withVisible(base::local({
[13:35:13.727]                 ...future.makeSendCondition <- base::local({
[13:35:13.727]                   sendCondition <- NULL
[13:35:13.727]                   function(frame = 1L) {
[13:35:13.727]                     if (is.function(sendCondition)) 
[13:35:13.727]                       return(sendCondition)
[13:35:13.727]                     ns <- getNamespace("parallel")
[13:35:13.727]                     if (exists("sendData", mode = "function", 
[13:35:13.727]                       envir = ns)) {
[13:35:13.727]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:13.727]                         envir = ns)
[13:35:13.727]                       envir <- sys.frame(frame)
[13:35:13.727]                       master <- NULL
[13:35:13.727]                       while (!identical(envir, .GlobalEnv) && 
[13:35:13.727]                         !identical(envir, emptyenv())) {
[13:35:13.727]                         if (exists("master", mode = "list", envir = envir, 
[13:35:13.727]                           inherits = FALSE)) {
[13:35:13.727]                           master <- get("master", mode = "list", 
[13:35:13.727]                             envir = envir, inherits = FALSE)
[13:35:13.727]                           if (inherits(master, c("SOCKnode", 
[13:35:13.727]                             "SOCK0node"))) {
[13:35:13.727]                             sendCondition <<- function(cond) {
[13:35:13.727]                               data <- list(type = "VALUE", value = cond, 
[13:35:13.727]                                 success = TRUE)
[13:35:13.727]                               parallel_sendData(master, data)
[13:35:13.727]                             }
[13:35:13.727]                             return(sendCondition)
[13:35:13.727]                           }
[13:35:13.727]                         }
[13:35:13.727]                         frame <- frame + 1L
[13:35:13.727]                         envir <- sys.frame(frame)
[13:35:13.727]                       }
[13:35:13.727]                     }
[13:35:13.727]                     sendCondition <<- function(cond) NULL
[13:35:13.727]                   }
[13:35:13.727]                 })
[13:35:13.727]                 withCallingHandlers({
[13:35:13.727]                   {
[13:35:13.727]                     do.call(function(...) {
[13:35:13.727]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.727]                       if (!identical(...future.globals.maxSize.org, 
[13:35:13.727]                         ...future.globals.maxSize)) {
[13:35:13.727]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.727]                         on.exit(options(oopts), add = TRUE)
[13:35:13.727]                       }
[13:35:13.727]                       {
[13:35:13.727]                         lapply(seq_along(...future.elements_ii), 
[13:35:13.727]                           FUN = function(jj) {
[13:35:13.727]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.727]                             ...future.FUN(...future.X_jj, ...)
[13:35:13.727]                           })
[13:35:13.727]                       }
[13:35:13.727]                     }, args = future.call.arguments)
[13:35:13.727]                   }
[13:35:13.727]                 }, immediateCondition = function(cond) {
[13:35:13.727]                   sendCondition <- ...future.makeSendCondition()
[13:35:13.727]                   sendCondition(cond)
[13:35:13.727]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.727]                   {
[13:35:13.727]                     inherits <- base::inherits
[13:35:13.727]                     invokeRestart <- base::invokeRestart
[13:35:13.727]                     is.null <- base::is.null
[13:35:13.727]                     muffled <- FALSE
[13:35:13.727]                     if (inherits(cond, "message")) {
[13:35:13.727]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:13.727]                       if (muffled) 
[13:35:13.727]                         invokeRestart("muffleMessage")
[13:35:13.727]                     }
[13:35:13.727]                     else if (inherits(cond, "warning")) {
[13:35:13.727]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:13.727]                       if (muffled) 
[13:35:13.727]                         invokeRestart("muffleWarning")
[13:35:13.727]                     }
[13:35:13.727]                     else if (inherits(cond, "condition")) {
[13:35:13.727]                       if (!is.null(pattern)) {
[13:35:13.727]                         computeRestarts <- base::computeRestarts
[13:35:13.727]                         grepl <- base::grepl
[13:35:13.727]                         restarts <- computeRestarts(cond)
[13:35:13.727]                         for (restart in restarts) {
[13:35:13.727]                           name <- restart$name
[13:35:13.727]                           if (is.null(name)) 
[13:35:13.727]                             next
[13:35:13.727]                           if (!grepl(pattern, name)) 
[13:35:13.727]                             next
[13:35:13.727]                           invokeRestart(restart)
[13:35:13.727]                           muffled <- TRUE
[13:35:13.727]                           break
[13:35:13.727]                         }
[13:35:13.727]                       }
[13:35:13.727]                     }
[13:35:13.727]                     invisible(muffled)
[13:35:13.727]                   }
[13:35:13.727]                   muffleCondition(cond)
[13:35:13.727]                 })
[13:35:13.727]             }))
[13:35:13.727]             future::FutureResult(value = ...future.value$value, 
[13:35:13.727]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:13.727]                   ...future.rng), globalenv = if (FALSE) 
[13:35:13.727]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:13.727]                     ...future.globalenv.names))
[13:35:13.727]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:13.727]         }, condition = base::local({
[13:35:13.727]             c <- base::c
[13:35:13.727]             inherits <- base::inherits
[13:35:13.727]             invokeRestart <- base::invokeRestart
[13:35:13.727]             length <- base::length
[13:35:13.727]             list <- base::list
[13:35:13.727]             seq.int <- base::seq.int
[13:35:13.727]             signalCondition <- base::signalCondition
[13:35:13.727]             sys.calls <- base::sys.calls
[13:35:13.727]             `[[` <- base::`[[`
[13:35:13.727]             `+` <- base::`+`
[13:35:13.727]             `<<-` <- base::`<<-`
[13:35:13.727]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:13.727]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:13.727]                   3L)]
[13:35:13.727]             }
[13:35:13.727]             function(cond) {
[13:35:13.727]                 is_error <- inherits(cond, "error")
[13:35:13.727]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:13.727]                   NULL)
[13:35:13.727]                 if (is_error) {
[13:35:13.727]                   sessionInformation <- function() {
[13:35:13.727]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:13.727]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:13.727]                       search = base::search(), system = base::Sys.info())
[13:35:13.727]                   }
[13:35:13.727]                   ...future.conditions[[length(...future.conditions) + 
[13:35:13.727]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:13.727]                     cond$call), session = sessionInformation(), 
[13:35:13.727]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:13.727]                   signalCondition(cond)
[13:35:13.727]                 }
[13:35:13.727]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:13.727]                 "immediateCondition"))) {
[13:35:13.727]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:13.727]                   ...future.conditions[[length(...future.conditions) + 
[13:35:13.727]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:13.727]                   if (TRUE && !signal) {
[13:35:13.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.727]                     {
[13:35:13.727]                       inherits <- base::inherits
[13:35:13.727]                       invokeRestart <- base::invokeRestart
[13:35:13.727]                       is.null <- base::is.null
[13:35:13.727]                       muffled <- FALSE
[13:35:13.727]                       if (inherits(cond, "message")) {
[13:35:13.727]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:13.727]                         if (muffled) 
[13:35:13.727]                           invokeRestart("muffleMessage")
[13:35:13.727]                       }
[13:35:13.727]                       else if (inherits(cond, "warning")) {
[13:35:13.727]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:13.727]                         if (muffled) 
[13:35:13.727]                           invokeRestart("muffleWarning")
[13:35:13.727]                       }
[13:35:13.727]                       else if (inherits(cond, "condition")) {
[13:35:13.727]                         if (!is.null(pattern)) {
[13:35:13.727]                           computeRestarts <- base::computeRestarts
[13:35:13.727]                           grepl <- base::grepl
[13:35:13.727]                           restarts <- computeRestarts(cond)
[13:35:13.727]                           for (restart in restarts) {
[13:35:13.727]                             name <- restart$name
[13:35:13.727]                             if (is.null(name)) 
[13:35:13.727]                               next
[13:35:13.727]                             if (!grepl(pattern, name)) 
[13:35:13.727]                               next
[13:35:13.727]                             invokeRestart(restart)
[13:35:13.727]                             muffled <- TRUE
[13:35:13.727]                             break
[13:35:13.727]                           }
[13:35:13.727]                         }
[13:35:13.727]                       }
[13:35:13.727]                       invisible(muffled)
[13:35:13.727]                     }
[13:35:13.727]                     muffleCondition(cond, pattern = "^muffle")
[13:35:13.727]                   }
[13:35:13.727]                 }
[13:35:13.727]                 else {
[13:35:13.727]                   if (TRUE) {
[13:35:13.727]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.727]                     {
[13:35:13.727]                       inherits <- base::inherits
[13:35:13.727]                       invokeRestart <- base::invokeRestart
[13:35:13.727]                       is.null <- base::is.null
[13:35:13.727]                       muffled <- FALSE
[13:35:13.727]                       if (inherits(cond, "message")) {
[13:35:13.727]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:13.727]                         if (muffled) 
[13:35:13.727]                           invokeRestart("muffleMessage")
[13:35:13.727]                       }
[13:35:13.727]                       else if (inherits(cond, "warning")) {
[13:35:13.727]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:13.727]                         if (muffled) 
[13:35:13.727]                           invokeRestart("muffleWarning")
[13:35:13.727]                       }
[13:35:13.727]                       else if (inherits(cond, "condition")) {
[13:35:13.727]                         if (!is.null(pattern)) {
[13:35:13.727]                           computeRestarts <- base::computeRestarts
[13:35:13.727]                           grepl <- base::grepl
[13:35:13.727]                           restarts <- computeRestarts(cond)
[13:35:13.727]                           for (restart in restarts) {
[13:35:13.727]                             name <- restart$name
[13:35:13.727]                             if (is.null(name)) 
[13:35:13.727]                               next
[13:35:13.727]                             if (!grepl(pattern, name)) 
[13:35:13.727]                               next
[13:35:13.727]                             invokeRestart(restart)
[13:35:13.727]                             muffled <- TRUE
[13:35:13.727]                             break
[13:35:13.727]                           }
[13:35:13.727]                         }
[13:35:13.727]                       }
[13:35:13.727]                       invisible(muffled)
[13:35:13.727]                     }
[13:35:13.727]                     muffleCondition(cond, pattern = "^muffle")
[13:35:13.727]                   }
[13:35:13.727]                 }
[13:35:13.727]             }
[13:35:13.727]         }))
[13:35:13.727]     }, error = function(ex) {
[13:35:13.727]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:13.727]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:13.727]                 ...future.rng), started = ...future.startTime, 
[13:35:13.727]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:13.727]             version = "1.8"), class = "FutureResult")
[13:35:13.727]     }, finally = {
[13:35:13.727]         if (!identical(...future.workdir, getwd())) 
[13:35:13.727]             setwd(...future.workdir)
[13:35:13.727]         {
[13:35:13.727]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:13.727]                 ...future.oldOptions$nwarnings <- NULL
[13:35:13.727]             }
[13:35:13.727]             base::options(...future.oldOptions)
[13:35:13.727]             if (.Platform$OS.type == "windows") {
[13:35:13.727]                 old_names <- names(...future.oldEnvVars)
[13:35:13.727]                 envs <- base::Sys.getenv()
[13:35:13.727]                 names <- names(envs)
[13:35:13.727]                 common <- intersect(names, old_names)
[13:35:13.727]                 added <- setdiff(names, old_names)
[13:35:13.727]                 removed <- setdiff(old_names, names)
[13:35:13.727]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:13.727]                   envs[common]]
[13:35:13.727]                 NAMES <- toupper(changed)
[13:35:13.727]                 args <- list()
[13:35:13.727]                 for (kk in seq_along(NAMES)) {
[13:35:13.727]                   name <- changed[[kk]]
[13:35:13.727]                   NAME <- NAMES[[kk]]
[13:35:13.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.727]                     next
[13:35:13.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:13.727]                 }
[13:35:13.727]                 NAMES <- toupper(added)
[13:35:13.727]                 for (kk in seq_along(NAMES)) {
[13:35:13.727]                   name <- added[[kk]]
[13:35:13.727]                   NAME <- NAMES[[kk]]
[13:35:13.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.727]                     next
[13:35:13.727]                   args[[name]] <- ""
[13:35:13.727]                 }
[13:35:13.727]                 NAMES <- toupper(removed)
[13:35:13.727]                 for (kk in seq_along(NAMES)) {
[13:35:13.727]                   name <- removed[[kk]]
[13:35:13.727]                   NAME <- NAMES[[kk]]
[13:35:13.727]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.727]                     next
[13:35:13.727]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:13.727]                 }
[13:35:13.727]                 if (length(args) > 0) 
[13:35:13.727]                   base::do.call(base::Sys.setenv, args = args)
[13:35:13.727]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:13.727]             }
[13:35:13.727]             else {
[13:35:13.727]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:13.727]             }
[13:35:13.727]             {
[13:35:13.727]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:13.727]                   0L) {
[13:35:13.727]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:13.727]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:13.727]                   base::options(opts)
[13:35:13.727]                 }
[13:35:13.727]                 {
[13:35:13.727]                   {
[13:35:13.727]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:13.727]                     NULL
[13:35:13.727]                   }
[13:35:13.727]                   options(future.plan = NULL)
[13:35:13.727]                   if (is.na(NA_character_)) 
[13:35:13.727]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:13.727]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:13.727]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:13.727]                     .init = FALSE)
[13:35:13.727]                 }
[13:35:13.727]             }
[13:35:13.727]         }
[13:35:13.727]     })
[13:35:13.727]     if (TRUE) {
[13:35:13.727]         base::sink(type = "output", split = FALSE)
[13:35:13.727]         if (TRUE) {
[13:35:13.727]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:13.727]         }
[13:35:13.727]         else {
[13:35:13.727]             ...future.result["stdout"] <- base::list(NULL)
[13:35:13.727]         }
[13:35:13.727]         base::close(...future.stdout)
[13:35:13.727]         ...future.stdout <- NULL
[13:35:13.727]     }
[13:35:13.727]     ...future.result$conditions <- ...future.conditions
[13:35:13.727]     ...future.result$finished <- base::Sys.time()
[13:35:13.727]     ...future.result
[13:35:13.727] }
[13:35:13.729] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[13:35:13.730] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:13.770] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:13.771] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[13:35:13.771] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[13:35:13.771] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:13.772] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:13.772] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:13.814] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:13.815] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:13.858] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:13.859] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[13:35:13.859] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[13:35:13.859] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:13.860] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:13.860] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[13:35:13.860] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[13:35:13.860] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:35:13.861] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:35:13.861] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:13.861] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:13.861] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:13.861] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:13.861] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[13:35:13.862] MultisessionFuture started
[13:35:13.862] - Launch lazy future ... done
[13:35:13.862] run() for ‘MultisessionFuture’ ... done
[13:35:13.862] Created future:
[13:35:13.862] MultisessionFuture:
[13:35:13.862] Label: ‘future_vapply-1’
[13:35:13.862] Expression:
[13:35:13.862] {
[13:35:13.862]     do.call(function(...) {
[13:35:13.862]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.862]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:13.862]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.862]             on.exit(options(oopts), add = TRUE)
[13:35:13.862]         }
[13:35:13.862]         {
[13:35:13.862]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:13.862]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.862]                 ...future.FUN(...future.X_jj, ...)
[13:35:13.862]             })
[13:35:13.862]         }
[13:35:13.862]     }, args = future.call.arguments)
[13:35:13.862] }
[13:35:13.862] Lazy evaluation: FALSE
[13:35:13.862] Asynchronous evaluation: TRUE
[13:35:13.862] Local evaluation: TRUE
[13:35:13.862] Environment: R_GlobalEnv
[13:35:13.862] Capture standard output: TRUE
[13:35:13.862] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:13.862] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:13.862] Packages: 1 packages (‘future.apply’)
[13:35:13.862] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:13.862] Resolved: FALSE
[13:35:13.862] Value: <not collected>
[13:35:13.862] Conditions captured: <none>
[13:35:13.862] Early signaling: FALSE
[13:35:13.862] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:13.862] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:13.874] Chunk #1 of 2 ... DONE
[13:35:13.874] Chunk #2 of 2 ...
[13:35:13.874]  - Finding globals in 'X' for chunk #2 ...
[13:35:13.874] getGlobalsAndPackages() ...
[13:35:13.875] Searching for globals...
[13:35:13.875] 
[13:35:13.875] Searching for globals ... DONE
[13:35:13.875] - globals: [0] <none>
[13:35:13.875] getGlobalsAndPackages() ... DONE
[13:35:13.875]    + additional globals found: [n=0] 
[13:35:13.875]    + additional namespaces needed: [n=0] 
[13:35:13.875]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:13.876]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:13.876]  - seeds: <none>
[13:35:13.876]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.876] getGlobalsAndPackages() ...
[13:35:13.876] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.876] Resolving globals: FALSE
[13:35:13.876] Tweak future expression to call with '...' arguments ...
[13:35:13.876] {
[13:35:13.876]     do.call(function(...) {
[13:35:13.876]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.876]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:13.876]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.876]             on.exit(options(oopts), add = TRUE)
[13:35:13.876]         }
[13:35:13.876]         {
[13:35:13.876]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:13.876]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.876]                 ...future.FUN(...future.X_jj, ...)
[13:35:13.876]             })
[13:35:13.876]         }
[13:35:13.876]     }, args = future.call.arguments)
[13:35:13.876] }
[13:35:13.876] Tweak future expression to call with '...' arguments ... DONE
[13:35:13.877] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:13.877] - packages: [1] ‘future.apply’
[13:35:13.877] getGlobalsAndPackages() ... DONE
[13:35:13.877] run() for ‘Future’ ...
[13:35:13.878] - state: ‘created’
[13:35:13.878] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:13.892] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:13.893] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:13.893]   - Field: ‘node’
[13:35:13.893]   - Field: ‘label’
[13:35:13.893]   - Field: ‘local’
[13:35:13.893]   - Field: ‘owner’
[13:35:13.893]   - Field: ‘envir’
[13:35:13.893]   - Field: ‘workers’
[13:35:13.893]   - Field: ‘packages’
[13:35:13.893]   - Field: ‘gc’
[13:35:13.893]   - Field: ‘conditions’
[13:35:13.894]   - Field: ‘persistent’
[13:35:13.894]   - Field: ‘expr’
[13:35:13.894]   - Field: ‘uuid’
[13:35:13.894]   - Field: ‘seed’
[13:35:13.894]   - Field: ‘version’
[13:35:13.894]   - Field: ‘result’
[13:35:13.894]   - Field: ‘asynchronous’
[13:35:13.894]   - Field: ‘calls’
[13:35:13.894]   - Field: ‘globals’
[13:35:13.894]   - Field: ‘stdout’
[13:35:13.894]   - Field: ‘earlySignal’
[13:35:13.895]   - Field: ‘lazy’
[13:35:13.895]   - Field: ‘state’
[13:35:13.895] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:13.895] - Launch lazy future ...
[13:35:13.895] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:13.895] Packages needed by future strategies (n = 0): <none>
[13:35:13.896] {
[13:35:13.896]     {
[13:35:13.896]         {
[13:35:13.896]             ...future.startTime <- base::Sys.time()
[13:35:13.896]             {
[13:35:13.896]                 {
[13:35:13.896]                   {
[13:35:13.896]                     {
[13:35:13.896]                       {
[13:35:13.896]                         base::local({
[13:35:13.896]                           has_future <- base::requireNamespace("future", 
[13:35:13.896]                             quietly = TRUE)
[13:35:13.896]                           if (has_future) {
[13:35:13.896]                             ns <- base::getNamespace("future")
[13:35:13.896]                             version <- ns[[".package"]][["version"]]
[13:35:13.896]                             if (is.null(version)) 
[13:35:13.896]                               version <- utils::packageVersion("future")
[13:35:13.896]                           }
[13:35:13.896]                           else {
[13:35:13.896]                             version <- NULL
[13:35:13.896]                           }
[13:35:13.896]                           if (!has_future || version < "1.8.0") {
[13:35:13.896]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:13.896]                               "", base::R.version$version.string), 
[13:35:13.896]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:13.896]                                 base::R.version$platform, 8 * 
[13:35:13.896]                                   base::.Machine$sizeof.pointer), 
[13:35:13.896]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:13.896]                                 "release", "version")], collapse = " "), 
[13:35:13.896]                               hostname = base::Sys.info()[["nodename"]])
[13:35:13.896]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:13.896]                               info)
[13:35:13.896]                             info <- base::paste(info, collapse = "; ")
[13:35:13.896]                             if (!has_future) {
[13:35:13.896]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:13.896]                                 info)
[13:35:13.896]                             }
[13:35:13.896]                             else {
[13:35:13.896]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:13.896]                                 info, version)
[13:35:13.896]                             }
[13:35:13.896]                             base::stop(msg)
[13:35:13.896]                           }
[13:35:13.896]                         })
[13:35:13.896]                       }
[13:35:13.896]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:13.896]                       base::options(mc.cores = 1L)
[13:35:13.896]                     }
[13:35:13.896]                     base::local({
[13:35:13.896]                       for (pkg in "future.apply") {
[13:35:13.896]                         base::loadNamespace(pkg)
[13:35:13.896]                         base::library(pkg, character.only = TRUE)
[13:35:13.896]                       }
[13:35:13.896]                     })
[13:35:13.896]                   }
[13:35:13.896]                   ...future.strategy.old <- future::plan("list")
[13:35:13.896]                   options(future.plan = NULL)
[13:35:13.896]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:13.896]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:13.896]                 }
[13:35:13.896]                 ...future.workdir <- getwd()
[13:35:13.896]             }
[13:35:13.896]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:13.896]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:13.896]         }
[13:35:13.896]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:13.896]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:13.896]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:13.896]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:13.896]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:13.896]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:13.896]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:13.896]             base::names(...future.oldOptions))
[13:35:13.896]     }
[13:35:13.896]     if (FALSE) {
[13:35:13.896]     }
[13:35:13.896]     else {
[13:35:13.896]         if (TRUE) {
[13:35:13.896]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:13.896]                 open = "w")
[13:35:13.896]         }
[13:35:13.896]         else {
[13:35:13.896]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:13.896]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:13.896]         }
[13:35:13.896]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:13.896]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:13.896]             base::sink(type = "output", split = FALSE)
[13:35:13.896]             base::close(...future.stdout)
[13:35:13.896]         }, add = TRUE)
[13:35:13.896]     }
[13:35:13.896]     ...future.frame <- base::sys.nframe()
[13:35:13.896]     ...future.conditions <- base::list()
[13:35:13.896]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:13.896]     if (FALSE) {
[13:35:13.896]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:13.896]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:13.896]     }
[13:35:13.896]     ...future.result <- base::tryCatch({
[13:35:13.896]         base::withCallingHandlers({
[13:35:13.896]             ...future.value <- base::withVisible(base::local({
[13:35:13.896]                 ...future.makeSendCondition <- base::local({
[13:35:13.896]                   sendCondition <- NULL
[13:35:13.896]                   function(frame = 1L) {
[13:35:13.896]                     if (is.function(sendCondition)) 
[13:35:13.896]                       return(sendCondition)
[13:35:13.896]                     ns <- getNamespace("parallel")
[13:35:13.896]                     if (exists("sendData", mode = "function", 
[13:35:13.896]                       envir = ns)) {
[13:35:13.896]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:13.896]                         envir = ns)
[13:35:13.896]                       envir <- sys.frame(frame)
[13:35:13.896]                       master <- NULL
[13:35:13.896]                       while (!identical(envir, .GlobalEnv) && 
[13:35:13.896]                         !identical(envir, emptyenv())) {
[13:35:13.896]                         if (exists("master", mode = "list", envir = envir, 
[13:35:13.896]                           inherits = FALSE)) {
[13:35:13.896]                           master <- get("master", mode = "list", 
[13:35:13.896]                             envir = envir, inherits = FALSE)
[13:35:13.896]                           if (inherits(master, c("SOCKnode", 
[13:35:13.896]                             "SOCK0node"))) {
[13:35:13.896]                             sendCondition <<- function(cond) {
[13:35:13.896]                               data <- list(type = "VALUE", value = cond, 
[13:35:13.896]                                 success = TRUE)
[13:35:13.896]                               parallel_sendData(master, data)
[13:35:13.896]                             }
[13:35:13.896]                             return(sendCondition)
[13:35:13.896]                           }
[13:35:13.896]                         }
[13:35:13.896]                         frame <- frame + 1L
[13:35:13.896]                         envir <- sys.frame(frame)
[13:35:13.896]                       }
[13:35:13.896]                     }
[13:35:13.896]                     sendCondition <<- function(cond) NULL
[13:35:13.896]                   }
[13:35:13.896]                 })
[13:35:13.896]                 withCallingHandlers({
[13:35:13.896]                   {
[13:35:13.896]                     do.call(function(...) {
[13:35:13.896]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:13.896]                       if (!identical(...future.globals.maxSize.org, 
[13:35:13.896]                         ...future.globals.maxSize)) {
[13:35:13.896]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:13.896]                         on.exit(options(oopts), add = TRUE)
[13:35:13.896]                       }
[13:35:13.896]                       {
[13:35:13.896]                         lapply(seq_along(...future.elements_ii), 
[13:35:13.896]                           FUN = function(jj) {
[13:35:13.896]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:13.896]                             ...future.FUN(...future.X_jj, ...)
[13:35:13.896]                           })
[13:35:13.896]                       }
[13:35:13.896]                     }, args = future.call.arguments)
[13:35:13.896]                   }
[13:35:13.896]                 }, immediateCondition = function(cond) {
[13:35:13.896]                   sendCondition <- ...future.makeSendCondition()
[13:35:13.896]                   sendCondition(cond)
[13:35:13.896]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.896]                   {
[13:35:13.896]                     inherits <- base::inherits
[13:35:13.896]                     invokeRestart <- base::invokeRestart
[13:35:13.896]                     is.null <- base::is.null
[13:35:13.896]                     muffled <- FALSE
[13:35:13.896]                     if (inherits(cond, "message")) {
[13:35:13.896]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:13.896]                       if (muffled) 
[13:35:13.896]                         invokeRestart("muffleMessage")
[13:35:13.896]                     }
[13:35:13.896]                     else if (inherits(cond, "warning")) {
[13:35:13.896]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:13.896]                       if (muffled) 
[13:35:13.896]                         invokeRestart("muffleWarning")
[13:35:13.896]                     }
[13:35:13.896]                     else if (inherits(cond, "condition")) {
[13:35:13.896]                       if (!is.null(pattern)) {
[13:35:13.896]                         computeRestarts <- base::computeRestarts
[13:35:13.896]                         grepl <- base::grepl
[13:35:13.896]                         restarts <- computeRestarts(cond)
[13:35:13.896]                         for (restart in restarts) {
[13:35:13.896]                           name <- restart$name
[13:35:13.896]                           if (is.null(name)) 
[13:35:13.896]                             next
[13:35:13.896]                           if (!grepl(pattern, name)) 
[13:35:13.896]                             next
[13:35:13.896]                           invokeRestart(restart)
[13:35:13.896]                           muffled <- TRUE
[13:35:13.896]                           break
[13:35:13.896]                         }
[13:35:13.896]                       }
[13:35:13.896]                     }
[13:35:13.896]                     invisible(muffled)
[13:35:13.896]                   }
[13:35:13.896]                   muffleCondition(cond)
[13:35:13.896]                 })
[13:35:13.896]             }))
[13:35:13.896]             future::FutureResult(value = ...future.value$value, 
[13:35:13.896]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:13.896]                   ...future.rng), globalenv = if (FALSE) 
[13:35:13.896]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:13.896]                     ...future.globalenv.names))
[13:35:13.896]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:13.896]         }, condition = base::local({
[13:35:13.896]             c <- base::c
[13:35:13.896]             inherits <- base::inherits
[13:35:13.896]             invokeRestart <- base::invokeRestart
[13:35:13.896]             length <- base::length
[13:35:13.896]             list <- base::list
[13:35:13.896]             seq.int <- base::seq.int
[13:35:13.896]             signalCondition <- base::signalCondition
[13:35:13.896]             sys.calls <- base::sys.calls
[13:35:13.896]             `[[` <- base::`[[`
[13:35:13.896]             `+` <- base::`+`
[13:35:13.896]             `<<-` <- base::`<<-`
[13:35:13.896]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:13.896]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:13.896]                   3L)]
[13:35:13.896]             }
[13:35:13.896]             function(cond) {
[13:35:13.896]                 is_error <- inherits(cond, "error")
[13:35:13.896]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:13.896]                   NULL)
[13:35:13.896]                 if (is_error) {
[13:35:13.896]                   sessionInformation <- function() {
[13:35:13.896]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:13.896]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:13.896]                       search = base::search(), system = base::Sys.info())
[13:35:13.896]                   }
[13:35:13.896]                   ...future.conditions[[length(...future.conditions) + 
[13:35:13.896]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:13.896]                     cond$call), session = sessionInformation(), 
[13:35:13.896]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:13.896]                   signalCondition(cond)
[13:35:13.896]                 }
[13:35:13.896]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:13.896]                 "immediateCondition"))) {
[13:35:13.896]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:13.896]                   ...future.conditions[[length(...future.conditions) + 
[13:35:13.896]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:13.896]                   if (TRUE && !signal) {
[13:35:13.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.896]                     {
[13:35:13.896]                       inherits <- base::inherits
[13:35:13.896]                       invokeRestart <- base::invokeRestart
[13:35:13.896]                       is.null <- base::is.null
[13:35:13.896]                       muffled <- FALSE
[13:35:13.896]                       if (inherits(cond, "message")) {
[13:35:13.896]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:13.896]                         if (muffled) 
[13:35:13.896]                           invokeRestart("muffleMessage")
[13:35:13.896]                       }
[13:35:13.896]                       else if (inherits(cond, "warning")) {
[13:35:13.896]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:13.896]                         if (muffled) 
[13:35:13.896]                           invokeRestart("muffleWarning")
[13:35:13.896]                       }
[13:35:13.896]                       else if (inherits(cond, "condition")) {
[13:35:13.896]                         if (!is.null(pattern)) {
[13:35:13.896]                           computeRestarts <- base::computeRestarts
[13:35:13.896]                           grepl <- base::grepl
[13:35:13.896]                           restarts <- computeRestarts(cond)
[13:35:13.896]                           for (restart in restarts) {
[13:35:13.896]                             name <- restart$name
[13:35:13.896]                             if (is.null(name)) 
[13:35:13.896]                               next
[13:35:13.896]                             if (!grepl(pattern, name)) 
[13:35:13.896]                               next
[13:35:13.896]                             invokeRestart(restart)
[13:35:13.896]                             muffled <- TRUE
[13:35:13.896]                             break
[13:35:13.896]                           }
[13:35:13.896]                         }
[13:35:13.896]                       }
[13:35:13.896]                       invisible(muffled)
[13:35:13.896]                     }
[13:35:13.896]                     muffleCondition(cond, pattern = "^muffle")
[13:35:13.896]                   }
[13:35:13.896]                 }
[13:35:13.896]                 else {
[13:35:13.896]                   if (TRUE) {
[13:35:13.896]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:13.896]                     {
[13:35:13.896]                       inherits <- base::inherits
[13:35:13.896]                       invokeRestart <- base::invokeRestart
[13:35:13.896]                       is.null <- base::is.null
[13:35:13.896]                       muffled <- FALSE
[13:35:13.896]                       if (inherits(cond, "message")) {
[13:35:13.896]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:13.896]                         if (muffled) 
[13:35:13.896]                           invokeRestart("muffleMessage")
[13:35:13.896]                       }
[13:35:13.896]                       else if (inherits(cond, "warning")) {
[13:35:13.896]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:13.896]                         if (muffled) 
[13:35:13.896]                           invokeRestart("muffleWarning")
[13:35:13.896]                       }
[13:35:13.896]                       else if (inherits(cond, "condition")) {
[13:35:13.896]                         if (!is.null(pattern)) {
[13:35:13.896]                           computeRestarts <- base::computeRestarts
[13:35:13.896]                           grepl <- base::grepl
[13:35:13.896]                           restarts <- computeRestarts(cond)
[13:35:13.896]                           for (restart in restarts) {
[13:35:13.896]                             name <- restart$name
[13:35:13.896]                             if (is.null(name)) 
[13:35:13.896]                               next
[13:35:13.896]                             if (!grepl(pattern, name)) 
[13:35:13.896]                               next
[13:35:13.896]                             invokeRestart(restart)
[13:35:13.896]                             muffled <- TRUE
[13:35:13.896]                             break
[13:35:13.896]                           }
[13:35:13.896]                         }
[13:35:13.896]                       }
[13:35:13.896]                       invisible(muffled)
[13:35:13.896]                     }
[13:35:13.896]                     muffleCondition(cond, pattern = "^muffle")
[13:35:13.896]                   }
[13:35:13.896]                 }
[13:35:13.896]             }
[13:35:13.896]         }))
[13:35:13.896]     }, error = function(ex) {
[13:35:13.896]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:13.896]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:13.896]                 ...future.rng), started = ...future.startTime, 
[13:35:13.896]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:13.896]             version = "1.8"), class = "FutureResult")
[13:35:13.896]     }, finally = {
[13:35:13.896]         if (!identical(...future.workdir, getwd())) 
[13:35:13.896]             setwd(...future.workdir)
[13:35:13.896]         {
[13:35:13.896]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:13.896]                 ...future.oldOptions$nwarnings <- NULL
[13:35:13.896]             }
[13:35:13.896]             base::options(...future.oldOptions)
[13:35:13.896]             if (.Platform$OS.type == "windows") {
[13:35:13.896]                 old_names <- names(...future.oldEnvVars)
[13:35:13.896]                 envs <- base::Sys.getenv()
[13:35:13.896]                 names <- names(envs)
[13:35:13.896]                 common <- intersect(names, old_names)
[13:35:13.896]                 added <- setdiff(names, old_names)
[13:35:13.896]                 removed <- setdiff(old_names, names)
[13:35:13.896]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:13.896]                   envs[common]]
[13:35:13.896]                 NAMES <- toupper(changed)
[13:35:13.896]                 args <- list()
[13:35:13.896]                 for (kk in seq_along(NAMES)) {
[13:35:13.896]                   name <- changed[[kk]]
[13:35:13.896]                   NAME <- NAMES[[kk]]
[13:35:13.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.896]                     next
[13:35:13.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:13.896]                 }
[13:35:13.896]                 NAMES <- toupper(added)
[13:35:13.896]                 for (kk in seq_along(NAMES)) {
[13:35:13.896]                   name <- added[[kk]]
[13:35:13.896]                   NAME <- NAMES[[kk]]
[13:35:13.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.896]                     next
[13:35:13.896]                   args[[name]] <- ""
[13:35:13.896]                 }
[13:35:13.896]                 NAMES <- toupper(removed)
[13:35:13.896]                 for (kk in seq_along(NAMES)) {
[13:35:13.896]                   name <- removed[[kk]]
[13:35:13.896]                   NAME <- NAMES[[kk]]
[13:35:13.896]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:13.896]                     next
[13:35:13.896]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:13.896]                 }
[13:35:13.896]                 if (length(args) > 0) 
[13:35:13.896]                   base::do.call(base::Sys.setenv, args = args)
[13:35:13.896]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:13.896]             }
[13:35:13.896]             else {
[13:35:13.896]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:13.896]             }
[13:35:13.896]             {
[13:35:13.896]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:13.896]                   0L) {
[13:35:13.896]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:13.896]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:13.896]                   base::options(opts)
[13:35:13.896]                 }
[13:35:13.896]                 {
[13:35:13.896]                   {
[13:35:13.896]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:13.896]                     NULL
[13:35:13.896]                   }
[13:35:13.896]                   options(future.plan = NULL)
[13:35:13.896]                   if (is.na(NA_character_)) 
[13:35:13.896]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:13.896]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:13.896]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:13.896]                     .init = FALSE)
[13:35:13.896]                 }
[13:35:13.896]             }
[13:35:13.896]         }
[13:35:13.896]     })
[13:35:13.896]     if (TRUE) {
[13:35:13.896]         base::sink(type = "output", split = FALSE)
[13:35:13.896]         if (TRUE) {
[13:35:13.896]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:13.896]         }
[13:35:13.896]         else {
[13:35:13.896]             ...future.result["stdout"] <- base::list(NULL)
[13:35:13.896]         }
[13:35:13.896]         base::close(...future.stdout)
[13:35:13.896]         ...future.stdout <- NULL
[13:35:13.896]     }
[13:35:13.896]     ...future.result$conditions <- ...future.conditions
[13:35:13.896]     ...future.result$finished <- base::Sys.time()
[13:35:13.896]     ...future.result
[13:35:13.896] }
[13:35:13.898] Exporting 11 global objects (96.29 KiB) to cluster node #2 ...
[13:35:13.899] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:35:13.942] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:35:13.943] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ...
[13:35:13.943] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #2 ... DONE
[13:35:13.943] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:35:13.944] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:35:13.944] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:35:13.986] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:35:13.987] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:35:14.030] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:35:14.031] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[13:35:14.031] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[13:35:14.031] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[13:35:14.032] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[13:35:14.032] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[13:35:14.032] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[13:35:14.032] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:35:14.033] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:35:14.033] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:14.033] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:14.033] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:14.034] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:14.034] Exporting 11 global objects (96.29 KiB) to cluster node #2 ... DONE
[13:35:14.034] MultisessionFuture started
[13:35:14.034] - Launch lazy future ... done
[13:35:14.034] run() for ‘MultisessionFuture’ ... done
[13:35:14.035] Created future:
[13:35:14.036] receiveMessageFromWorker() for ClusterFuture ...
[13:35:14.036] - Validating connection of MultisessionFuture
[13:35:14.036] - received message: FutureResult
[13:35:14.036] - Received FutureResult
[13:35:14.037] - Erased future from FutureRegistry
[13:35:14.037] result() for ClusterFuture ...
[13:35:14.037] - result already collected: FutureResult
[13:35:14.037] result() for ClusterFuture ... done
[13:35:14.037] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:14.035] MultisessionFuture:
[13:35:14.035] Label: ‘future_vapply-2’
[13:35:14.035] Expression:
[13:35:14.035] {
[13:35:14.035]     do.call(function(...) {
[13:35:14.035]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.035]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:14.035]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.035]             on.exit(options(oopts), add = TRUE)
[13:35:14.035]         }
[13:35:14.035]         {
[13:35:14.035]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:14.035]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.035]                 ...future.FUN(...future.X_jj, ...)
[13:35:14.035]             })
[13:35:14.035]         }
[13:35:14.035]     }, args = future.call.arguments)
[13:35:14.035] }
[13:35:14.035] Lazy evaluation: FALSE
[13:35:14.035] Asynchronous evaluation: TRUE
[13:35:14.035] Local evaluation: TRUE
[13:35:14.035] Environment: R_GlobalEnv
[13:35:14.035] Capture standard output: TRUE
[13:35:14.035] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:14.035] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:14.035] Packages: 1 packages (‘future.apply’)
[13:35:14.035] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:14.035] Resolved: TRUE
[13:35:14.035] Value: <not collected>
[13:35:14.035] Conditions captured: <none>
[13:35:14.035] Early signaling: FALSE
[13:35:14.035] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:14.035] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:14.037] Chunk #2 of 2 ... DONE
[13:35:14.037] Launching 2 futures (chunks) ... DONE
[13:35:14.037] Resolving 2 futures (chunks) ...
[13:35:14.038] resolve() on list ...
[13:35:14.038]  recursive: 0
[13:35:14.038]  length: 2
[13:35:14.038] 
[13:35:14.038] receiveMessageFromWorker() for ClusterFuture ...
[13:35:14.038] - Validating connection of MultisessionFuture
[13:35:14.039] - received message: FutureResult
[13:35:14.039] - Received FutureResult
[13:35:14.039] - Erased future from FutureRegistry
[13:35:14.039] result() for ClusterFuture ...
[13:35:14.039] - result already collected: FutureResult
[13:35:14.039] result() for ClusterFuture ... done
[13:35:14.039] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:14.039] Future #1
[13:35:14.039] result() for ClusterFuture ...
[13:35:14.039] - result already collected: FutureResult
[13:35:14.039] result() for ClusterFuture ... done
[13:35:14.040] result() for ClusterFuture ...
[13:35:14.040] - result already collected: FutureResult
[13:35:14.040] result() for ClusterFuture ... done
[13:35:14.040] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:14.040] - nx: 2
[13:35:14.040] - relay: TRUE
[13:35:14.040] - stdout: TRUE
[13:35:14.040] - signal: TRUE
[13:35:14.040] - resignal: FALSE
[13:35:14.040] - force: TRUE
[13:35:14.040] - relayed: [n=2] FALSE, FALSE
[13:35:14.040] - queued futures: [n=2] FALSE, FALSE
[13:35:14.041]  - until=1
[13:35:14.041]  - relaying element #1
[13:35:14.041] result() for ClusterFuture ...
[13:35:14.041] - result already collected: FutureResult
[13:35:14.041] result() for ClusterFuture ... done
[13:35:14.041] result() for ClusterFuture ...
[13:35:14.041] - result already collected: FutureResult
[13:35:14.041] result() for ClusterFuture ... done
[13:35:14.041] result() for ClusterFuture ...
[13:35:14.041] - result already collected: FutureResult
[13:35:14.041] result() for ClusterFuture ... done
[13:35:14.042] result() for ClusterFuture ...
[13:35:14.042] - result already collected: FutureResult
[13:35:14.042] result() for ClusterFuture ... done
[13:35:14.042] - relayed: [n=2] TRUE, FALSE
[13:35:14.042] - queued futures: [n=2] TRUE, FALSE
[13:35:14.042] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:14.042]  length: 1 (resolved future 1)
[13:35:14.042] Future #2
[13:35:14.042] result() for ClusterFuture ...
[13:35:14.042] - result already collected: FutureResult
[13:35:14.042] result() for ClusterFuture ... done
[13:35:14.043] result() for ClusterFuture ...
[13:35:14.043] - result already collected: FutureResult
[13:35:14.043] result() for ClusterFuture ... done
[13:35:14.043] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:14.043] - nx: 2
[13:35:14.043] - relay: TRUE
[13:35:14.043] - stdout: TRUE
[13:35:14.043] - signal: TRUE
[13:35:14.043] - resignal: FALSE
[13:35:14.043] - force: TRUE
[13:35:14.043] - relayed: [n=2] TRUE, FALSE
[13:35:14.043] - queued futures: [n=2] TRUE, FALSE
[13:35:14.044]  - until=2
[13:35:14.044]  - relaying element #2
[13:35:14.044] result() for ClusterFuture ...
[13:35:14.044] - result already collected: FutureResult
[13:35:14.044] result() for ClusterFuture ... done
[13:35:14.044] result() for ClusterFuture ...
[13:35:14.044] - result already collected: FutureResult
[13:35:14.044] result() for ClusterFuture ... done
[13:35:14.044] result() for ClusterFuture ...
[13:35:14.044] - result already collected: FutureResult
[13:35:14.044] result() for ClusterFuture ... done
[13:35:14.044] result() for ClusterFuture ...
[13:35:14.045] - result already collected: FutureResult
[13:35:14.045] result() for ClusterFuture ... done
[13:35:14.045] - relayed: [n=2] TRUE, TRUE
[13:35:14.045] - queued futures: [n=2] TRUE, TRUE
[13:35:14.045] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:14.045]  length: 0 (resolved future 2)
[13:35:14.045] Relaying remaining futures
[13:35:14.045] signalConditionsASAP(NULL, pos=0) ...
[13:35:14.045] - nx: 2
[13:35:14.045] - relay: TRUE
[13:35:14.045] - stdout: TRUE
[13:35:14.045] - signal: TRUE
[13:35:14.046] - resignal: FALSE
[13:35:14.046] - force: TRUE
[13:35:14.046] - relayed: [n=2] TRUE, TRUE
[13:35:14.046] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:14.046] - relayed: [n=2] TRUE, TRUE
[13:35:14.046] - queued futures: [n=2] TRUE, TRUE
[13:35:14.046] signalConditionsASAP(NULL, pos=0) ... done
[13:35:14.046] resolve() on list ... DONE
[13:35:14.046] result() for ClusterFuture ...
[13:35:14.046] - result already collected: FutureResult
[13:35:14.046] result() for ClusterFuture ... done
[13:35:14.047] result() for ClusterFuture ...
[13:35:14.047] - result already collected: FutureResult
[13:35:14.047] result() for ClusterFuture ... done
[13:35:14.047] result() for ClusterFuture ...
[13:35:14.047] - result already collected: FutureResult
[13:35:14.047] result() for ClusterFuture ... done
[13:35:14.047] result() for ClusterFuture ...
[13:35:14.047] - result already collected: FutureResult
[13:35:14.047] result() for ClusterFuture ... done
[13:35:14.047]  - Number of value chunks collected: 2
[13:35:14.047] Resolving 2 futures (chunks) ... DONE
[13:35:14.048] Reducing values from 2 chunks ...
[13:35:14.048]  - Number of values collected after concatenation: 4
[13:35:14.048]  - Number of values expected: 4
[13:35:14.048] Reducing values from 2 chunks ... DONE
[13:35:14.048] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[13:35:14.050] future_lapply() ...
[13:35:14.055] Number of chunks: 2
[13:35:14.055] getGlobalsAndPackagesXApply() ...
[13:35:14.055]  - future.globals: TRUE
[13:35:14.055] getGlobalsAndPackages() ...
[13:35:14.055] Searching for globals...
[13:35:14.059] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:14.059] Searching for globals ... DONE
[13:35:14.059] Resolving globals: FALSE
[13:35:14.060] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[13:35:14.060] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:14.060] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:14.060] - packages: [1] ‘future.apply’
[13:35:14.060] getGlobalsAndPackages() ... DONE
[13:35:14.061]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:14.061]  - needed namespaces: [n=1] ‘future.apply’
[13:35:14.061] Finding globals ... DONE
[13:35:14.061]  - use_args: TRUE
[13:35:14.061]  - Getting '...' globals ...
[13:35:14.061] resolve() on list ...
[13:35:14.061]  recursive: 0
[13:35:14.061]  length: 1
[13:35:14.062]  elements: ‘...’
[13:35:14.062]  length: 0 (resolved future 1)
[13:35:14.062] resolve() on list ... DONE
[13:35:14.062]    - '...' content: [n=0] 
[13:35:14.062] List of 1
[13:35:14.062]  $ ...: list()
[13:35:14.062]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:14.062]  - attr(*, "where")=List of 1
[13:35:14.062]   ..$ ...:<environment: 0x5574d2760e68> 
[13:35:14.062]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:14.062]  - attr(*, "resolved")= logi TRUE
[13:35:14.062]  - attr(*, "total_size")= num NA
[13:35:14.064]  - Getting '...' globals ... DONE
[13:35:14.065] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:14.065] List of 8
[13:35:14.065]  $ ...future.FUN:function (x, ...)  
[13:35:14.065]  $ x_FUN        :function (x)  
[13:35:14.065]  $ times        : int 1
[13:35:14.065]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:14.065]  $ stop_if_not  :function (...)  
[13:35:14.065]  $ dim          : NULL
[13:35:14.065]  $ valid_types  : chr "logical"
[13:35:14.065]  $ ...          : list()
[13:35:14.065]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:14.065]  - attr(*, "where")=List of 8
[13:35:14.065]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:14.065]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:14.065]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:14.065]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:14.065]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:14.065]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:14.065]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:14.065]   ..$ ...          :<environment: 0x5574d2760e68> 
[13:35:14.065]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:14.065]  - attr(*, "resolved")= logi FALSE
[13:35:14.065]  - attr(*, "total_size")= num 94200
[13:35:14.070] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:14.070] getGlobalsAndPackagesXApply() ... DONE
[13:35:14.070] Number of futures (= number of chunks): 2
[13:35:14.070] Launching 2 futures (chunks) ...
[13:35:14.070] Chunk #1 of 2 ...
[13:35:14.071]  - Finding globals in 'X' for chunk #1 ...
[13:35:14.071] getGlobalsAndPackages() ...
[13:35:14.071] Searching for globals...
[13:35:14.071] 
[13:35:14.071] Searching for globals ... DONE
[13:35:14.071] - globals: [0] <none>
[13:35:14.071] getGlobalsAndPackages() ... DONE
[13:35:14.071]    + additional globals found: [n=0] 
[13:35:14.071]    + additional namespaces needed: [n=0] 
[13:35:14.072]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:14.072]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:14.072]  - seeds: <none>
[13:35:14.072]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.072] getGlobalsAndPackages() ...
[13:35:14.072] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.072] Resolving globals: FALSE
[13:35:14.072] Tweak future expression to call with '...' arguments ...
[13:35:14.072] {
[13:35:14.072]     do.call(function(...) {
[13:35:14.072]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.072]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:14.072]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.072]             on.exit(options(oopts), add = TRUE)
[13:35:14.072]         }
[13:35:14.072]         {
[13:35:14.072]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:14.072]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.072]                 ...future.FUN(...future.X_jj, ...)
[13:35:14.072]             })
[13:35:14.072]         }
[13:35:14.072]     }, args = future.call.arguments)
[13:35:14.072] }
[13:35:14.073] Tweak future expression to call with '...' arguments ... DONE
[13:35:14.073] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.073] - packages: [1] ‘future.apply’
[13:35:14.073] getGlobalsAndPackages() ... DONE
[13:35:14.074] run() for ‘Future’ ...
[13:35:14.074] - state: ‘created’
[13:35:14.074] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:14.087] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:14.088] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:14.090]   - Field: ‘node’
[13:35:14.090]   - Field: ‘label’
[13:35:14.090]   - Field: ‘local’
[13:35:14.091]   - Field: ‘owner’
[13:35:14.091]   - Field: ‘envir’
[13:35:14.091]   - Field: ‘workers’
[13:35:14.091]   - Field: ‘packages’
[13:35:14.091]   - Field: ‘gc’
[13:35:14.091]   - Field: ‘conditions’
[13:35:14.091]   - Field: ‘persistent’
[13:35:14.091]   - Field: ‘expr’
[13:35:14.091]   - Field: ‘uuid’
[13:35:14.091]   - Field: ‘seed’
[13:35:14.091]   - Field: ‘version’
[13:35:14.092]   - Field: ‘result’
[13:35:14.092]   - Field: ‘asynchronous’
[13:35:14.092]   - Field: ‘calls’
[13:35:14.092]   - Field: ‘globals’
[13:35:14.092]   - Field: ‘stdout’
[13:35:14.092]   - Field: ‘earlySignal’
[13:35:14.092]   - Field: ‘lazy’
[13:35:14.092]   - Field: ‘state’
[13:35:14.092] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:14.092] - Launch lazy future ...
[13:35:14.093] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:14.093] Packages needed by future strategies (n = 0): <none>
[13:35:14.093] {
[13:35:14.093]     {
[13:35:14.093]         {
[13:35:14.093]             ...future.startTime <- base::Sys.time()
[13:35:14.093]             {
[13:35:14.093]                 {
[13:35:14.093]                   {
[13:35:14.093]                     {
[13:35:14.093]                       {
[13:35:14.093]                         base::local({
[13:35:14.093]                           has_future <- base::requireNamespace("future", 
[13:35:14.093]                             quietly = TRUE)
[13:35:14.093]                           if (has_future) {
[13:35:14.093]                             ns <- base::getNamespace("future")
[13:35:14.093]                             version <- ns[[".package"]][["version"]]
[13:35:14.093]                             if (is.null(version)) 
[13:35:14.093]                               version <- utils::packageVersion("future")
[13:35:14.093]                           }
[13:35:14.093]                           else {
[13:35:14.093]                             version <- NULL
[13:35:14.093]                           }
[13:35:14.093]                           if (!has_future || version < "1.8.0") {
[13:35:14.093]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:14.093]                               "", base::R.version$version.string), 
[13:35:14.093]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:14.093]                                 base::R.version$platform, 8 * 
[13:35:14.093]                                   base::.Machine$sizeof.pointer), 
[13:35:14.093]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:14.093]                                 "release", "version")], collapse = " "), 
[13:35:14.093]                               hostname = base::Sys.info()[["nodename"]])
[13:35:14.093]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:14.093]                               info)
[13:35:14.093]                             info <- base::paste(info, collapse = "; ")
[13:35:14.093]                             if (!has_future) {
[13:35:14.093]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:14.093]                                 info)
[13:35:14.093]                             }
[13:35:14.093]                             else {
[13:35:14.093]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:14.093]                                 info, version)
[13:35:14.093]                             }
[13:35:14.093]                             base::stop(msg)
[13:35:14.093]                           }
[13:35:14.093]                         })
[13:35:14.093]                       }
[13:35:14.093]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:14.093]                       base::options(mc.cores = 1L)
[13:35:14.093]                     }
[13:35:14.093]                     base::local({
[13:35:14.093]                       for (pkg in "future.apply") {
[13:35:14.093]                         base::loadNamespace(pkg)
[13:35:14.093]                         base::library(pkg, character.only = TRUE)
[13:35:14.093]                       }
[13:35:14.093]                     })
[13:35:14.093]                   }
[13:35:14.093]                   ...future.strategy.old <- future::plan("list")
[13:35:14.093]                   options(future.plan = NULL)
[13:35:14.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:14.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:14.093]                 }
[13:35:14.093]                 ...future.workdir <- getwd()
[13:35:14.093]             }
[13:35:14.093]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:14.093]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:14.093]         }
[13:35:14.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:14.093]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:14.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:14.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:14.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:14.093]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:14.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:14.093]             base::names(...future.oldOptions))
[13:35:14.093]     }
[13:35:14.093]     if (FALSE) {
[13:35:14.093]     }
[13:35:14.093]     else {
[13:35:14.093]         if (TRUE) {
[13:35:14.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:14.093]                 open = "w")
[13:35:14.093]         }
[13:35:14.093]         else {
[13:35:14.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:14.093]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:14.093]         }
[13:35:14.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:14.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:14.093]             base::sink(type = "output", split = FALSE)
[13:35:14.093]             base::close(...future.stdout)
[13:35:14.093]         }, add = TRUE)
[13:35:14.093]     }
[13:35:14.093]     ...future.frame <- base::sys.nframe()
[13:35:14.093]     ...future.conditions <- base::list()
[13:35:14.093]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:14.093]     if (FALSE) {
[13:35:14.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:14.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:14.093]     }
[13:35:14.093]     ...future.result <- base::tryCatch({
[13:35:14.093]         base::withCallingHandlers({
[13:35:14.093]             ...future.value <- base::withVisible(base::local({
[13:35:14.093]                 ...future.makeSendCondition <- base::local({
[13:35:14.093]                   sendCondition <- NULL
[13:35:14.093]                   function(frame = 1L) {
[13:35:14.093]                     if (is.function(sendCondition)) 
[13:35:14.093]                       return(sendCondition)
[13:35:14.093]                     ns <- getNamespace("parallel")
[13:35:14.093]                     if (exists("sendData", mode = "function", 
[13:35:14.093]                       envir = ns)) {
[13:35:14.093]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:14.093]                         envir = ns)
[13:35:14.093]                       envir <- sys.frame(frame)
[13:35:14.093]                       master <- NULL
[13:35:14.093]                       while (!identical(envir, .GlobalEnv) && 
[13:35:14.093]                         !identical(envir, emptyenv())) {
[13:35:14.093]                         if (exists("master", mode = "list", envir = envir, 
[13:35:14.093]                           inherits = FALSE)) {
[13:35:14.093]                           master <- get("master", mode = "list", 
[13:35:14.093]                             envir = envir, inherits = FALSE)
[13:35:14.093]                           if (inherits(master, c("SOCKnode", 
[13:35:14.093]                             "SOCK0node"))) {
[13:35:14.093]                             sendCondition <<- function(cond) {
[13:35:14.093]                               data <- list(type = "VALUE", value = cond, 
[13:35:14.093]                                 success = TRUE)
[13:35:14.093]                               parallel_sendData(master, data)
[13:35:14.093]                             }
[13:35:14.093]                             return(sendCondition)
[13:35:14.093]                           }
[13:35:14.093]                         }
[13:35:14.093]                         frame <- frame + 1L
[13:35:14.093]                         envir <- sys.frame(frame)
[13:35:14.093]                       }
[13:35:14.093]                     }
[13:35:14.093]                     sendCondition <<- function(cond) NULL
[13:35:14.093]                   }
[13:35:14.093]                 })
[13:35:14.093]                 withCallingHandlers({
[13:35:14.093]                   {
[13:35:14.093]                     do.call(function(...) {
[13:35:14.093]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.093]                       if (!identical(...future.globals.maxSize.org, 
[13:35:14.093]                         ...future.globals.maxSize)) {
[13:35:14.093]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.093]                         on.exit(options(oopts), add = TRUE)
[13:35:14.093]                       }
[13:35:14.093]                       {
[13:35:14.093]                         lapply(seq_along(...future.elements_ii), 
[13:35:14.093]                           FUN = function(jj) {
[13:35:14.093]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.093]                             ...future.FUN(...future.X_jj, ...)
[13:35:14.093]                           })
[13:35:14.093]                       }
[13:35:14.093]                     }, args = future.call.arguments)
[13:35:14.093]                   }
[13:35:14.093]                 }, immediateCondition = function(cond) {
[13:35:14.093]                   sendCondition <- ...future.makeSendCondition()
[13:35:14.093]                   sendCondition(cond)
[13:35:14.093]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.093]                   {
[13:35:14.093]                     inherits <- base::inherits
[13:35:14.093]                     invokeRestart <- base::invokeRestart
[13:35:14.093]                     is.null <- base::is.null
[13:35:14.093]                     muffled <- FALSE
[13:35:14.093]                     if (inherits(cond, "message")) {
[13:35:14.093]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:14.093]                       if (muffled) 
[13:35:14.093]                         invokeRestart("muffleMessage")
[13:35:14.093]                     }
[13:35:14.093]                     else if (inherits(cond, "warning")) {
[13:35:14.093]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:14.093]                       if (muffled) 
[13:35:14.093]                         invokeRestart("muffleWarning")
[13:35:14.093]                     }
[13:35:14.093]                     else if (inherits(cond, "condition")) {
[13:35:14.093]                       if (!is.null(pattern)) {
[13:35:14.093]                         computeRestarts <- base::computeRestarts
[13:35:14.093]                         grepl <- base::grepl
[13:35:14.093]                         restarts <- computeRestarts(cond)
[13:35:14.093]                         for (restart in restarts) {
[13:35:14.093]                           name <- restart$name
[13:35:14.093]                           if (is.null(name)) 
[13:35:14.093]                             next
[13:35:14.093]                           if (!grepl(pattern, name)) 
[13:35:14.093]                             next
[13:35:14.093]                           invokeRestart(restart)
[13:35:14.093]                           muffled <- TRUE
[13:35:14.093]                           break
[13:35:14.093]                         }
[13:35:14.093]                       }
[13:35:14.093]                     }
[13:35:14.093]                     invisible(muffled)
[13:35:14.093]                   }
[13:35:14.093]                   muffleCondition(cond)
[13:35:14.093]                 })
[13:35:14.093]             }))
[13:35:14.093]             future::FutureResult(value = ...future.value$value, 
[13:35:14.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:14.093]                   ...future.rng), globalenv = if (FALSE) 
[13:35:14.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:14.093]                     ...future.globalenv.names))
[13:35:14.093]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:14.093]         }, condition = base::local({
[13:35:14.093]             c <- base::c
[13:35:14.093]             inherits <- base::inherits
[13:35:14.093]             invokeRestart <- base::invokeRestart
[13:35:14.093]             length <- base::length
[13:35:14.093]             list <- base::list
[13:35:14.093]             seq.int <- base::seq.int
[13:35:14.093]             signalCondition <- base::signalCondition
[13:35:14.093]             sys.calls <- base::sys.calls
[13:35:14.093]             `[[` <- base::`[[`
[13:35:14.093]             `+` <- base::`+`
[13:35:14.093]             `<<-` <- base::`<<-`
[13:35:14.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:14.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:14.093]                   3L)]
[13:35:14.093]             }
[13:35:14.093]             function(cond) {
[13:35:14.093]                 is_error <- inherits(cond, "error")
[13:35:14.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:14.093]                   NULL)
[13:35:14.093]                 if (is_error) {
[13:35:14.093]                   sessionInformation <- function() {
[13:35:14.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:14.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:14.093]                       search = base::search(), system = base::Sys.info())
[13:35:14.093]                   }
[13:35:14.093]                   ...future.conditions[[length(...future.conditions) + 
[13:35:14.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:14.093]                     cond$call), session = sessionInformation(), 
[13:35:14.093]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:14.093]                   signalCondition(cond)
[13:35:14.093]                 }
[13:35:14.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:14.093]                 "immediateCondition"))) {
[13:35:14.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:14.093]                   ...future.conditions[[length(...future.conditions) + 
[13:35:14.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:14.093]                   if (TRUE && !signal) {
[13:35:14.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.093]                     {
[13:35:14.093]                       inherits <- base::inherits
[13:35:14.093]                       invokeRestart <- base::invokeRestart
[13:35:14.093]                       is.null <- base::is.null
[13:35:14.093]                       muffled <- FALSE
[13:35:14.093]                       if (inherits(cond, "message")) {
[13:35:14.093]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:14.093]                         if (muffled) 
[13:35:14.093]                           invokeRestart("muffleMessage")
[13:35:14.093]                       }
[13:35:14.093]                       else if (inherits(cond, "warning")) {
[13:35:14.093]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:14.093]                         if (muffled) 
[13:35:14.093]                           invokeRestart("muffleWarning")
[13:35:14.093]                       }
[13:35:14.093]                       else if (inherits(cond, "condition")) {
[13:35:14.093]                         if (!is.null(pattern)) {
[13:35:14.093]                           computeRestarts <- base::computeRestarts
[13:35:14.093]                           grepl <- base::grepl
[13:35:14.093]                           restarts <- computeRestarts(cond)
[13:35:14.093]                           for (restart in restarts) {
[13:35:14.093]                             name <- restart$name
[13:35:14.093]                             if (is.null(name)) 
[13:35:14.093]                               next
[13:35:14.093]                             if (!grepl(pattern, name)) 
[13:35:14.093]                               next
[13:35:14.093]                             invokeRestart(restart)
[13:35:14.093]                             muffled <- TRUE
[13:35:14.093]                             break
[13:35:14.093]                           }
[13:35:14.093]                         }
[13:35:14.093]                       }
[13:35:14.093]                       invisible(muffled)
[13:35:14.093]                     }
[13:35:14.093]                     muffleCondition(cond, pattern = "^muffle")
[13:35:14.093]                   }
[13:35:14.093]                 }
[13:35:14.093]                 else {
[13:35:14.093]                   if (TRUE) {
[13:35:14.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.093]                     {
[13:35:14.093]                       inherits <- base::inherits
[13:35:14.093]                       invokeRestart <- base::invokeRestart
[13:35:14.093]                       is.null <- base::is.null
[13:35:14.093]                       muffled <- FALSE
[13:35:14.093]                       if (inherits(cond, "message")) {
[13:35:14.093]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:14.093]                         if (muffled) 
[13:35:14.093]                           invokeRestart("muffleMessage")
[13:35:14.093]                       }
[13:35:14.093]                       else if (inherits(cond, "warning")) {
[13:35:14.093]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:14.093]                         if (muffled) 
[13:35:14.093]                           invokeRestart("muffleWarning")
[13:35:14.093]                       }
[13:35:14.093]                       else if (inherits(cond, "condition")) {
[13:35:14.093]                         if (!is.null(pattern)) {
[13:35:14.093]                           computeRestarts <- base::computeRestarts
[13:35:14.093]                           grepl <- base::grepl
[13:35:14.093]                           restarts <- computeRestarts(cond)
[13:35:14.093]                           for (restart in restarts) {
[13:35:14.093]                             name <- restart$name
[13:35:14.093]                             if (is.null(name)) 
[13:35:14.093]                               next
[13:35:14.093]                             if (!grepl(pattern, name)) 
[13:35:14.093]                               next
[13:35:14.093]                             invokeRestart(restart)
[13:35:14.093]                             muffled <- TRUE
[13:35:14.093]                             break
[13:35:14.093]                           }
[13:35:14.093]                         }
[13:35:14.093]                       }
[13:35:14.093]                       invisible(muffled)
[13:35:14.093]                     }
[13:35:14.093]                     muffleCondition(cond, pattern = "^muffle")
[13:35:14.093]                   }
[13:35:14.093]                 }
[13:35:14.093]             }
[13:35:14.093]         }))
[13:35:14.093]     }, error = function(ex) {
[13:35:14.093]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:14.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:14.093]                 ...future.rng), started = ...future.startTime, 
[13:35:14.093]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:14.093]             version = "1.8"), class = "FutureResult")
[13:35:14.093]     }, finally = {
[13:35:14.093]         if (!identical(...future.workdir, getwd())) 
[13:35:14.093]             setwd(...future.workdir)
[13:35:14.093]         {
[13:35:14.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:14.093]                 ...future.oldOptions$nwarnings <- NULL
[13:35:14.093]             }
[13:35:14.093]             base::options(...future.oldOptions)
[13:35:14.093]             if (.Platform$OS.type == "windows") {
[13:35:14.093]                 old_names <- names(...future.oldEnvVars)
[13:35:14.093]                 envs <- base::Sys.getenv()
[13:35:14.093]                 names <- names(envs)
[13:35:14.093]                 common <- intersect(names, old_names)
[13:35:14.093]                 added <- setdiff(names, old_names)
[13:35:14.093]                 removed <- setdiff(old_names, names)
[13:35:14.093]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:14.093]                   envs[common]]
[13:35:14.093]                 NAMES <- toupper(changed)
[13:35:14.093]                 args <- list()
[13:35:14.093]                 for (kk in seq_along(NAMES)) {
[13:35:14.093]                   name <- changed[[kk]]
[13:35:14.093]                   NAME <- NAMES[[kk]]
[13:35:14.093]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.093]                     next
[13:35:14.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:14.093]                 }
[13:35:14.093]                 NAMES <- toupper(added)
[13:35:14.093]                 for (kk in seq_along(NAMES)) {
[13:35:14.093]                   name <- added[[kk]]
[13:35:14.093]                   NAME <- NAMES[[kk]]
[13:35:14.093]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.093]                     next
[13:35:14.093]                   args[[name]] <- ""
[13:35:14.093]                 }
[13:35:14.093]                 NAMES <- toupper(removed)
[13:35:14.093]                 for (kk in seq_along(NAMES)) {
[13:35:14.093]                   name <- removed[[kk]]
[13:35:14.093]                   NAME <- NAMES[[kk]]
[13:35:14.093]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.093]                     next
[13:35:14.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:14.093]                 }
[13:35:14.093]                 if (length(args) > 0) 
[13:35:14.093]                   base::do.call(base::Sys.setenv, args = args)
[13:35:14.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:14.093]             }
[13:35:14.093]             else {
[13:35:14.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:14.093]             }
[13:35:14.093]             {
[13:35:14.093]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:14.093]                   0L) {
[13:35:14.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:14.093]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:14.093]                   base::options(opts)
[13:35:14.093]                 }
[13:35:14.093]                 {
[13:35:14.093]                   {
[13:35:14.093]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:14.093]                     NULL
[13:35:14.093]                   }
[13:35:14.093]                   options(future.plan = NULL)
[13:35:14.093]                   if (is.na(NA_character_)) 
[13:35:14.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:14.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:14.093]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:14.093]                     .init = FALSE)
[13:35:14.093]                 }
[13:35:14.093]             }
[13:35:14.093]         }
[13:35:14.093]     })
[13:35:14.093]     if (TRUE) {
[13:35:14.093]         base::sink(type = "output", split = FALSE)
[13:35:14.093]         if (TRUE) {
[13:35:14.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:14.093]         }
[13:35:14.093]         else {
[13:35:14.093]             ...future.result["stdout"] <- base::list(NULL)
[13:35:14.093]         }
[13:35:14.093]         base::close(...future.stdout)
[13:35:14.093]         ...future.stdout <- NULL
[13:35:14.093]     }
[13:35:14.093]     ...future.result$conditions <- ...future.conditions
[13:35:14.093]     ...future.result$finished <- base::Sys.time()
[13:35:14.093]     ...future.result
[13:35:14.093] }
[13:35:14.096] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[13:35:14.096] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:14.138] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:14.139] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:35:14.139] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:35:14.139] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:14.139] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:14.140] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:14.182] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:14.183] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:14.226] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:14.227] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:14.227] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:14.227] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[13:35:14.227] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[13:35:14.228] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:14.228] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:14.228] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[13:35:14.228] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[13:35:14.229] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:14.229] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:14.229] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:14.229] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:14.229] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[13:35:14.230] MultisessionFuture started
[13:35:14.230] - Launch lazy future ... done
[13:35:14.230] run() for ‘MultisessionFuture’ ... done
[13:35:14.230] Created future:
[13:35:14.230] MultisessionFuture:
[13:35:14.230] Label: ‘future_vapply-1’
[13:35:14.230] Expression:
[13:35:14.230] {
[13:35:14.230]     do.call(function(...) {
[13:35:14.230]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.230]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:14.230]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.230]             on.exit(options(oopts), add = TRUE)
[13:35:14.230]         }
[13:35:14.230]         {
[13:35:14.230]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:14.230]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.230]                 ...future.FUN(...future.X_jj, ...)
[13:35:14.230]             })
[13:35:14.230]         }
[13:35:14.230]     }, args = future.call.arguments)
[13:35:14.230] }
[13:35:14.230] Lazy evaluation: FALSE
[13:35:14.230] Asynchronous evaluation: TRUE
[13:35:14.230] Local evaluation: TRUE
[13:35:14.230] Environment: R_GlobalEnv
[13:35:14.230] Capture standard output: TRUE
[13:35:14.230] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:14.230] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:14.230] Packages: 1 packages (‘future.apply’)
[13:35:14.230] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:14.230] Resolved: FALSE
[13:35:14.230] Value: <not collected>
[13:35:14.230] Conditions captured: <none>
[13:35:14.230] Early signaling: FALSE
[13:35:14.230] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:14.230] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:14.242] Chunk #1 of 2 ... DONE
[13:35:14.242] Chunk #2 of 2 ...
[13:35:14.242]  - Finding globals in 'X' for chunk #2 ...
[13:35:14.242] getGlobalsAndPackages() ...
[13:35:14.242] Searching for globals...
[13:35:14.243] 
[13:35:14.243] Searching for globals ... DONE
[13:35:14.243] - globals: [0] <none>
[13:35:14.243] getGlobalsAndPackages() ... DONE
[13:35:14.243]    + additional globals found: [n=0] 
[13:35:14.243]    + additional namespaces needed: [n=0] 
[13:35:14.243]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:14.243]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:14.244]  - seeds: <none>
[13:35:14.244]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.244] getGlobalsAndPackages() ...
[13:35:14.244] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.244] Resolving globals: FALSE
[13:35:14.244] Tweak future expression to call with '...' arguments ...
[13:35:14.244] {
[13:35:14.244]     do.call(function(...) {
[13:35:14.244]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.244]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:14.244]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.244]             on.exit(options(oopts), add = TRUE)
[13:35:14.244]         }
[13:35:14.244]         {
[13:35:14.244]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:14.244]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.244]                 ...future.FUN(...future.X_jj, ...)
[13:35:14.244]             })
[13:35:14.244]         }
[13:35:14.244]     }, args = future.call.arguments)
[13:35:14.244] }
[13:35:14.244] Tweak future expression to call with '...' arguments ... DONE
[13:35:14.245] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.245] - packages: [1] ‘future.apply’
[13:35:14.245] getGlobalsAndPackages() ... DONE
[13:35:14.245] run() for ‘Future’ ...
[13:35:14.246] - state: ‘created’
[13:35:14.246] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:14.260] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:14.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:14.261]   - Field: ‘node’
[13:35:14.261]   - Field: ‘label’
[13:35:14.261]   - Field: ‘local’
[13:35:14.261]   - Field: ‘owner’
[13:35:14.261]   - Field: ‘envir’
[13:35:14.261]   - Field: ‘workers’
[13:35:14.261]   - Field: ‘packages’
[13:35:14.261]   - Field: ‘gc’
[13:35:14.262]   - Field: ‘conditions’
[13:35:14.262]   - Field: ‘persistent’
[13:35:14.262]   - Field: ‘expr’
[13:35:14.262]   - Field: ‘uuid’
[13:35:14.262]   - Field: ‘seed’
[13:35:14.262]   - Field: ‘version’
[13:35:14.262]   - Field: ‘result’
[13:35:14.262]   - Field: ‘asynchronous’
[13:35:14.262]   - Field: ‘calls’
[13:35:14.262]   - Field: ‘globals’
[13:35:14.262]   - Field: ‘stdout’
[13:35:14.263]   - Field: ‘earlySignal’
[13:35:14.263]   - Field: ‘lazy’
[13:35:14.263]   - Field: ‘state’
[13:35:14.263] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:14.263] - Launch lazy future ...
[13:35:14.263] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:14.263] Packages needed by future strategies (n = 0): <none>
[13:35:14.264] {
[13:35:14.264]     {
[13:35:14.264]         {
[13:35:14.264]             ...future.startTime <- base::Sys.time()
[13:35:14.264]             {
[13:35:14.264]                 {
[13:35:14.264]                   {
[13:35:14.264]                     {
[13:35:14.264]                       {
[13:35:14.264]                         base::local({
[13:35:14.264]                           has_future <- base::requireNamespace("future", 
[13:35:14.264]                             quietly = TRUE)
[13:35:14.264]                           if (has_future) {
[13:35:14.264]                             ns <- base::getNamespace("future")
[13:35:14.264]                             version <- ns[[".package"]][["version"]]
[13:35:14.264]                             if (is.null(version)) 
[13:35:14.264]                               version <- utils::packageVersion("future")
[13:35:14.264]                           }
[13:35:14.264]                           else {
[13:35:14.264]                             version <- NULL
[13:35:14.264]                           }
[13:35:14.264]                           if (!has_future || version < "1.8.0") {
[13:35:14.264]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:14.264]                               "", base::R.version$version.string), 
[13:35:14.264]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:14.264]                                 base::R.version$platform, 8 * 
[13:35:14.264]                                   base::.Machine$sizeof.pointer), 
[13:35:14.264]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:14.264]                                 "release", "version")], collapse = " "), 
[13:35:14.264]                               hostname = base::Sys.info()[["nodename"]])
[13:35:14.264]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:14.264]                               info)
[13:35:14.264]                             info <- base::paste(info, collapse = "; ")
[13:35:14.264]                             if (!has_future) {
[13:35:14.264]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:14.264]                                 info)
[13:35:14.264]                             }
[13:35:14.264]                             else {
[13:35:14.264]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:14.264]                                 info, version)
[13:35:14.264]                             }
[13:35:14.264]                             base::stop(msg)
[13:35:14.264]                           }
[13:35:14.264]                         })
[13:35:14.264]                       }
[13:35:14.264]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:14.264]                       base::options(mc.cores = 1L)
[13:35:14.264]                     }
[13:35:14.264]                     base::local({
[13:35:14.264]                       for (pkg in "future.apply") {
[13:35:14.264]                         base::loadNamespace(pkg)
[13:35:14.264]                         base::library(pkg, character.only = TRUE)
[13:35:14.264]                       }
[13:35:14.264]                     })
[13:35:14.264]                   }
[13:35:14.264]                   ...future.strategy.old <- future::plan("list")
[13:35:14.264]                   options(future.plan = NULL)
[13:35:14.264]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:14.264]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:14.264]                 }
[13:35:14.264]                 ...future.workdir <- getwd()
[13:35:14.264]             }
[13:35:14.264]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:14.264]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:14.264]         }
[13:35:14.264]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:14.264]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:14.264]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:14.264]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:14.264]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:14.264]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:14.264]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:14.264]             base::names(...future.oldOptions))
[13:35:14.264]     }
[13:35:14.264]     if (FALSE) {
[13:35:14.264]     }
[13:35:14.264]     else {
[13:35:14.264]         if (TRUE) {
[13:35:14.264]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:14.264]                 open = "w")
[13:35:14.264]         }
[13:35:14.264]         else {
[13:35:14.264]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:14.264]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:14.264]         }
[13:35:14.264]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:14.264]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:14.264]             base::sink(type = "output", split = FALSE)
[13:35:14.264]             base::close(...future.stdout)
[13:35:14.264]         }, add = TRUE)
[13:35:14.264]     }
[13:35:14.264]     ...future.frame <- base::sys.nframe()
[13:35:14.264]     ...future.conditions <- base::list()
[13:35:14.264]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:14.264]     if (FALSE) {
[13:35:14.264]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:14.264]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:14.264]     }
[13:35:14.264]     ...future.result <- base::tryCatch({
[13:35:14.264]         base::withCallingHandlers({
[13:35:14.264]             ...future.value <- base::withVisible(base::local({
[13:35:14.264]                 ...future.makeSendCondition <- base::local({
[13:35:14.264]                   sendCondition <- NULL
[13:35:14.264]                   function(frame = 1L) {
[13:35:14.264]                     if (is.function(sendCondition)) 
[13:35:14.264]                       return(sendCondition)
[13:35:14.264]                     ns <- getNamespace("parallel")
[13:35:14.264]                     if (exists("sendData", mode = "function", 
[13:35:14.264]                       envir = ns)) {
[13:35:14.264]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:14.264]                         envir = ns)
[13:35:14.264]                       envir <- sys.frame(frame)
[13:35:14.264]                       master <- NULL
[13:35:14.264]                       while (!identical(envir, .GlobalEnv) && 
[13:35:14.264]                         !identical(envir, emptyenv())) {
[13:35:14.264]                         if (exists("master", mode = "list", envir = envir, 
[13:35:14.264]                           inherits = FALSE)) {
[13:35:14.264]                           master <- get("master", mode = "list", 
[13:35:14.264]                             envir = envir, inherits = FALSE)
[13:35:14.264]                           if (inherits(master, c("SOCKnode", 
[13:35:14.264]                             "SOCK0node"))) {
[13:35:14.264]                             sendCondition <<- function(cond) {
[13:35:14.264]                               data <- list(type = "VALUE", value = cond, 
[13:35:14.264]                                 success = TRUE)
[13:35:14.264]                               parallel_sendData(master, data)
[13:35:14.264]                             }
[13:35:14.264]                             return(sendCondition)
[13:35:14.264]                           }
[13:35:14.264]                         }
[13:35:14.264]                         frame <- frame + 1L
[13:35:14.264]                         envir <- sys.frame(frame)
[13:35:14.264]                       }
[13:35:14.264]                     }
[13:35:14.264]                     sendCondition <<- function(cond) NULL
[13:35:14.264]                   }
[13:35:14.264]                 })
[13:35:14.264]                 withCallingHandlers({
[13:35:14.264]                   {
[13:35:14.264]                     do.call(function(...) {
[13:35:14.264]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.264]                       if (!identical(...future.globals.maxSize.org, 
[13:35:14.264]                         ...future.globals.maxSize)) {
[13:35:14.264]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.264]                         on.exit(options(oopts), add = TRUE)
[13:35:14.264]                       }
[13:35:14.264]                       {
[13:35:14.264]                         lapply(seq_along(...future.elements_ii), 
[13:35:14.264]                           FUN = function(jj) {
[13:35:14.264]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.264]                             ...future.FUN(...future.X_jj, ...)
[13:35:14.264]                           })
[13:35:14.264]                       }
[13:35:14.264]                     }, args = future.call.arguments)
[13:35:14.264]                   }
[13:35:14.264]                 }, immediateCondition = function(cond) {
[13:35:14.264]                   sendCondition <- ...future.makeSendCondition()
[13:35:14.264]                   sendCondition(cond)
[13:35:14.264]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.264]                   {
[13:35:14.264]                     inherits <- base::inherits
[13:35:14.264]                     invokeRestart <- base::invokeRestart
[13:35:14.264]                     is.null <- base::is.null
[13:35:14.264]                     muffled <- FALSE
[13:35:14.264]                     if (inherits(cond, "message")) {
[13:35:14.264]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:14.264]                       if (muffled) 
[13:35:14.264]                         invokeRestart("muffleMessage")
[13:35:14.264]                     }
[13:35:14.264]                     else if (inherits(cond, "warning")) {
[13:35:14.264]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:14.264]                       if (muffled) 
[13:35:14.264]                         invokeRestart("muffleWarning")
[13:35:14.264]                     }
[13:35:14.264]                     else if (inherits(cond, "condition")) {
[13:35:14.264]                       if (!is.null(pattern)) {
[13:35:14.264]                         computeRestarts <- base::computeRestarts
[13:35:14.264]                         grepl <- base::grepl
[13:35:14.264]                         restarts <- computeRestarts(cond)
[13:35:14.264]                         for (restart in restarts) {
[13:35:14.264]                           name <- restart$name
[13:35:14.264]                           if (is.null(name)) 
[13:35:14.264]                             next
[13:35:14.264]                           if (!grepl(pattern, name)) 
[13:35:14.264]                             next
[13:35:14.264]                           invokeRestart(restart)
[13:35:14.264]                           muffled <- TRUE
[13:35:14.264]                           break
[13:35:14.264]                         }
[13:35:14.264]                       }
[13:35:14.264]                     }
[13:35:14.264]                     invisible(muffled)
[13:35:14.264]                   }
[13:35:14.264]                   muffleCondition(cond)
[13:35:14.264]                 })
[13:35:14.264]             }))
[13:35:14.264]             future::FutureResult(value = ...future.value$value, 
[13:35:14.264]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:14.264]                   ...future.rng), globalenv = if (FALSE) 
[13:35:14.264]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:14.264]                     ...future.globalenv.names))
[13:35:14.264]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:14.264]         }, condition = base::local({
[13:35:14.264]             c <- base::c
[13:35:14.264]             inherits <- base::inherits
[13:35:14.264]             invokeRestart <- base::invokeRestart
[13:35:14.264]             length <- base::length
[13:35:14.264]             list <- base::list
[13:35:14.264]             seq.int <- base::seq.int
[13:35:14.264]             signalCondition <- base::signalCondition
[13:35:14.264]             sys.calls <- base::sys.calls
[13:35:14.264]             `[[` <- base::`[[`
[13:35:14.264]             `+` <- base::`+`
[13:35:14.264]             `<<-` <- base::`<<-`
[13:35:14.264]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:14.264]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:14.264]                   3L)]
[13:35:14.264]             }
[13:35:14.264]             function(cond) {
[13:35:14.264]                 is_error <- inherits(cond, "error")
[13:35:14.264]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:14.264]                   NULL)
[13:35:14.264]                 if (is_error) {
[13:35:14.264]                   sessionInformation <- function() {
[13:35:14.264]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:14.264]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:14.264]                       search = base::search(), system = base::Sys.info())
[13:35:14.264]                   }
[13:35:14.264]                   ...future.conditions[[length(...future.conditions) + 
[13:35:14.264]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:14.264]                     cond$call), session = sessionInformation(), 
[13:35:14.264]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:14.264]                   signalCondition(cond)
[13:35:14.264]                 }
[13:35:14.264]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:14.264]                 "immediateCondition"))) {
[13:35:14.264]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:14.264]                   ...future.conditions[[length(...future.conditions) + 
[13:35:14.264]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:14.264]                   if (TRUE && !signal) {
[13:35:14.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.264]                     {
[13:35:14.264]                       inherits <- base::inherits
[13:35:14.264]                       invokeRestart <- base::invokeRestart
[13:35:14.264]                       is.null <- base::is.null
[13:35:14.264]                       muffled <- FALSE
[13:35:14.264]                       if (inherits(cond, "message")) {
[13:35:14.264]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:14.264]                         if (muffled) 
[13:35:14.264]                           invokeRestart("muffleMessage")
[13:35:14.264]                       }
[13:35:14.264]                       else if (inherits(cond, "warning")) {
[13:35:14.264]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:14.264]                         if (muffled) 
[13:35:14.264]                           invokeRestart("muffleWarning")
[13:35:14.264]                       }
[13:35:14.264]                       else if (inherits(cond, "condition")) {
[13:35:14.264]                         if (!is.null(pattern)) {
[13:35:14.264]                           computeRestarts <- base::computeRestarts
[13:35:14.264]                           grepl <- base::grepl
[13:35:14.264]                           restarts <- computeRestarts(cond)
[13:35:14.264]                           for (restart in restarts) {
[13:35:14.264]                             name <- restart$name
[13:35:14.264]                             if (is.null(name)) 
[13:35:14.264]                               next
[13:35:14.264]                             if (!grepl(pattern, name)) 
[13:35:14.264]                               next
[13:35:14.264]                             invokeRestart(restart)
[13:35:14.264]                             muffled <- TRUE
[13:35:14.264]                             break
[13:35:14.264]                           }
[13:35:14.264]                         }
[13:35:14.264]                       }
[13:35:14.264]                       invisible(muffled)
[13:35:14.264]                     }
[13:35:14.264]                     muffleCondition(cond, pattern = "^muffle")
[13:35:14.264]                   }
[13:35:14.264]                 }
[13:35:14.264]                 else {
[13:35:14.264]                   if (TRUE) {
[13:35:14.264]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.264]                     {
[13:35:14.264]                       inherits <- base::inherits
[13:35:14.264]                       invokeRestart <- base::invokeRestart
[13:35:14.264]                       is.null <- base::is.null
[13:35:14.264]                       muffled <- FALSE
[13:35:14.264]                       if (inherits(cond, "message")) {
[13:35:14.264]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:14.264]                         if (muffled) 
[13:35:14.264]                           invokeRestart("muffleMessage")
[13:35:14.264]                       }
[13:35:14.264]                       else if (inherits(cond, "warning")) {
[13:35:14.264]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:14.264]                         if (muffled) 
[13:35:14.264]                           invokeRestart("muffleWarning")
[13:35:14.264]                       }
[13:35:14.264]                       else if (inherits(cond, "condition")) {
[13:35:14.264]                         if (!is.null(pattern)) {
[13:35:14.264]                           computeRestarts <- base::computeRestarts
[13:35:14.264]                           grepl <- base::grepl
[13:35:14.264]                           restarts <- computeRestarts(cond)
[13:35:14.264]                           for (restart in restarts) {
[13:35:14.264]                             name <- restart$name
[13:35:14.264]                             if (is.null(name)) 
[13:35:14.264]                               next
[13:35:14.264]                             if (!grepl(pattern, name)) 
[13:35:14.264]                               next
[13:35:14.264]                             invokeRestart(restart)
[13:35:14.264]                             muffled <- TRUE
[13:35:14.264]                             break
[13:35:14.264]                           }
[13:35:14.264]                         }
[13:35:14.264]                       }
[13:35:14.264]                       invisible(muffled)
[13:35:14.264]                     }
[13:35:14.264]                     muffleCondition(cond, pattern = "^muffle")
[13:35:14.264]                   }
[13:35:14.264]                 }
[13:35:14.264]             }
[13:35:14.264]         }))
[13:35:14.264]     }, error = function(ex) {
[13:35:14.264]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:14.264]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:14.264]                 ...future.rng), started = ...future.startTime, 
[13:35:14.264]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:14.264]             version = "1.8"), class = "FutureResult")
[13:35:14.264]     }, finally = {
[13:35:14.264]         if (!identical(...future.workdir, getwd())) 
[13:35:14.264]             setwd(...future.workdir)
[13:35:14.264]         {
[13:35:14.264]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:14.264]                 ...future.oldOptions$nwarnings <- NULL
[13:35:14.264]             }
[13:35:14.264]             base::options(...future.oldOptions)
[13:35:14.264]             if (.Platform$OS.type == "windows") {
[13:35:14.264]                 old_names <- names(...future.oldEnvVars)
[13:35:14.264]                 envs <- base::Sys.getenv()
[13:35:14.264]                 names <- names(envs)
[13:35:14.264]                 common <- intersect(names, old_names)
[13:35:14.264]                 added <- setdiff(names, old_names)
[13:35:14.264]                 removed <- setdiff(old_names, names)
[13:35:14.264]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:14.264]                   envs[common]]
[13:35:14.264]                 NAMES <- toupper(changed)
[13:35:14.264]                 args <- list()
[13:35:14.264]                 for (kk in seq_along(NAMES)) {
[13:35:14.264]                   name <- changed[[kk]]
[13:35:14.264]                   NAME <- NAMES[[kk]]
[13:35:14.264]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.264]                     next
[13:35:14.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:14.264]                 }
[13:35:14.264]                 NAMES <- toupper(added)
[13:35:14.264]                 for (kk in seq_along(NAMES)) {
[13:35:14.264]                   name <- added[[kk]]
[13:35:14.264]                   NAME <- NAMES[[kk]]
[13:35:14.264]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.264]                     next
[13:35:14.264]                   args[[name]] <- ""
[13:35:14.264]                 }
[13:35:14.264]                 NAMES <- toupper(removed)
[13:35:14.264]                 for (kk in seq_along(NAMES)) {
[13:35:14.264]                   name <- removed[[kk]]
[13:35:14.264]                   NAME <- NAMES[[kk]]
[13:35:14.264]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.264]                     next
[13:35:14.264]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:14.264]                 }
[13:35:14.264]                 if (length(args) > 0) 
[13:35:14.264]                   base::do.call(base::Sys.setenv, args = args)
[13:35:14.264]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:14.264]             }
[13:35:14.264]             else {
[13:35:14.264]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:14.264]             }
[13:35:14.264]             {
[13:35:14.264]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:14.264]                   0L) {
[13:35:14.264]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:14.264]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:14.264]                   base::options(opts)
[13:35:14.264]                 }
[13:35:14.264]                 {
[13:35:14.264]                   {
[13:35:14.264]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:14.264]                     NULL
[13:35:14.264]                   }
[13:35:14.264]                   options(future.plan = NULL)
[13:35:14.264]                   if (is.na(NA_character_)) 
[13:35:14.264]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:14.264]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:14.264]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:14.264]                     .init = FALSE)
[13:35:14.264]                 }
[13:35:14.264]             }
[13:35:14.264]         }
[13:35:14.264]     })
[13:35:14.264]     if (TRUE) {
[13:35:14.264]         base::sink(type = "output", split = FALSE)
[13:35:14.264]         if (TRUE) {
[13:35:14.264]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:14.264]         }
[13:35:14.264]         else {
[13:35:14.264]             ...future.result["stdout"] <- base::list(NULL)
[13:35:14.264]         }
[13:35:14.264]         base::close(...future.stdout)
[13:35:14.264]         ...future.stdout <- NULL
[13:35:14.264]     }
[13:35:14.264]     ...future.result$conditions <- ...future.conditions
[13:35:14.264]     ...future.result$finished <- base::Sys.time()
[13:35:14.264]     ...future.result
[13:35:14.264] }
[13:35:14.267] Exporting 11 global objects (91.99 KiB) to cluster node #2 ...
[13:35:14.267] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:35:14.311] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:35:14.311] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[13:35:14.311] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[13:35:14.311] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:35:14.312] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:35:14.312] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:35:14.354] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:35:14.355] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:35:14.398] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:35:14.399] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:35:14.399] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:35:14.399] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ...
[13:35:14.400] Exporting ‘valid_types’ (112 bytes) to cluster node #2 ... DONE
[13:35:14.400] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:35:14.400] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:35:14.401] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ...
[13:35:14.401] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #2 ... DONE
[13:35:14.401] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:14.401] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:14.401] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:14.402] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:14.402] Exporting 11 global objects (91.99 KiB) to cluster node #2 ... DONE
[13:35:14.403] MultisessionFuture started
[13:35:14.403] - Launch lazy future ... done
[13:35:14.403] run() for ‘MultisessionFuture’ ... done
[13:35:14.403] Created future:
[13:35:14.403] MultisessionFuture:
[13:35:14.403] Label: ‘future_vapply-2’
[13:35:14.403] Expression:
[13:35:14.403] {
[13:35:14.403]     do.call(function(...) {
[13:35:14.403]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.403]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:14.403]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.403]             on.exit(options(oopts), add = TRUE)
[13:35:14.403]         }
[13:35:14.403]         {
[13:35:14.403]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:14.403]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.403]                 ...future.FUN(...future.X_jj, ...)
[13:35:14.403]             })
[13:35:14.403]         }
[13:35:14.403]     }, args = future.call.arguments)
[13:35:14.403] }
[13:35:14.403] Lazy evaluation: FALSE
[13:35:14.403] Asynchronous evaluation: TRUE
[13:35:14.403] Local evaluation: TRUE
[13:35:14.403] Environment: R_GlobalEnv
[13:35:14.403] Capture standard output: TRUE
[13:35:14.403] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:14.403] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:14.403] Packages: 1 packages (‘future.apply’)
[13:35:14.403] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:14.403] Resolved: FALSE
[13:35:14.403] Value: <not collected>
[13:35:14.403] Conditions captured: <none>
[13:35:14.403] Early signaling: FALSE
[13:35:14.403] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:14.403] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:14.415] Chunk #2 of 2 ... DONE
[13:35:14.415] Launching 2 futures (chunks) ... DONE
[13:35:14.415] Resolving 2 futures (chunks) ...
[13:35:14.415] resolve() on list ...
[13:35:14.415]  recursive: 0
[13:35:14.416]  length: 2
[13:35:14.416] 
[13:35:14.416] receiveMessageFromWorker() for ClusterFuture ...
[13:35:14.416] - Validating connection of MultisessionFuture
[13:35:14.416] - received message: FutureResult
[13:35:14.416] - Received FutureResult
[13:35:14.417] - Erased future from FutureRegistry
[13:35:14.417] result() for ClusterFuture ...
[13:35:14.417] - result already collected: FutureResult
[13:35:14.417] result() for ClusterFuture ... done
[13:35:14.417] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:14.417] Future #1
[13:35:14.417] result() for ClusterFuture ...
[13:35:14.417] - result already collected: FutureResult
[13:35:14.417] result() for ClusterFuture ... done
[13:35:14.417] result() for ClusterFuture ...
[13:35:14.417] - result already collected: FutureResult
[13:35:14.418] result() for ClusterFuture ... done
[13:35:14.418] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:14.418] - nx: 2
[13:35:14.418] - relay: TRUE
[13:35:14.418] - stdout: TRUE
[13:35:14.418] - signal: TRUE
[13:35:14.418] - resignal: FALSE
[13:35:14.418] - force: TRUE
[13:35:14.418] - relayed: [n=2] FALSE, FALSE
[13:35:14.418] - queued futures: [n=2] FALSE, FALSE
[13:35:14.418]  - until=1
[13:35:14.419]  - relaying element #1
[13:35:14.419] result() for ClusterFuture ...
[13:35:14.419] - result already collected: FutureResult
[13:35:14.419] result() for ClusterFuture ... done
[13:35:14.419] result() for ClusterFuture ...
[13:35:14.419] - result already collected: FutureResult
[13:35:14.419] result() for ClusterFuture ... done
[13:35:14.419] result() for ClusterFuture ...
[13:35:14.419] - result already collected: FutureResult
[13:35:14.419] result() for ClusterFuture ... done
[13:35:14.419] result() for ClusterFuture ...
[13:35:14.420] - result already collected: FutureResult
[13:35:14.420] result() for ClusterFuture ... done
[13:35:14.420] - relayed: [n=2] TRUE, FALSE
[13:35:14.420] - queued futures: [n=2] TRUE, FALSE
[13:35:14.420] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:14.420]  length: 1 (resolved future 1)
[13:35:14.448] receiveMessageFromWorker() for ClusterFuture ...
[13:35:14.448] - Validating connection of MultisessionFuture
[13:35:14.448] - received message: FutureResult
[13:35:14.448] - Received FutureResult
[13:35:14.448] - Erased future from FutureRegistry
[13:35:14.449] result() for ClusterFuture ...
[13:35:14.449] - result already collected: FutureResult
[13:35:14.449] result() for ClusterFuture ... done
[13:35:14.449] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:14.449] Future #2
[13:35:14.449] result() for ClusterFuture ...
[13:35:14.449] - result already collected: FutureResult
[13:35:14.449] result() for ClusterFuture ... done
[13:35:14.449] result() for ClusterFuture ...
[13:35:14.449] - result already collected: FutureResult
[13:35:14.449] result() for ClusterFuture ... done
[13:35:14.450] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:14.450] - nx: 2
[13:35:14.450] - relay: TRUE
[13:35:14.450] - stdout: TRUE
[13:35:14.450] - signal: TRUE
[13:35:14.450] - resignal: FALSE
[13:35:14.450] - force: TRUE
[13:35:14.450] - relayed: [n=2] TRUE, FALSE
[13:35:14.450] - queued futures: [n=2] TRUE, FALSE
[13:35:14.450]  - until=2
[13:35:14.450]  - relaying element #2
[13:35:14.450] result() for ClusterFuture ...
[13:35:14.451] - result already collected: FutureResult
[13:35:14.451] result() for ClusterFuture ... done
[13:35:14.451] result() for ClusterFuture ...
[13:35:14.451] - result already collected: FutureResult
[13:35:14.451] result() for ClusterFuture ... done
[13:35:14.451] result() for ClusterFuture ...
[13:35:14.451] - result already collected: FutureResult
[13:35:14.451] result() for ClusterFuture ... done
[13:35:14.451] result() for ClusterFuture ...
[13:35:14.451] - result already collected: FutureResult
[13:35:14.451] result() for ClusterFuture ... done
[13:35:14.452] - relayed: [n=2] TRUE, TRUE
[13:35:14.452] - queued futures: [n=2] TRUE, TRUE
[13:35:14.452] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:14.452]  length: 0 (resolved future 2)
[13:35:14.452] Relaying remaining futures
[13:35:14.452] signalConditionsASAP(NULL, pos=0) ...
[13:35:14.452] - nx: 2
[13:35:14.452] - relay: TRUE
[13:35:14.452] - stdout: TRUE
[13:35:14.452] - signal: TRUE
[13:35:14.452] - resignal: FALSE
[13:35:14.453] - force: TRUE
[13:35:14.453] - relayed: [n=2] TRUE, TRUE
[13:35:14.453] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:14.453] - relayed: [n=2] TRUE, TRUE
[13:35:14.453] - queued futures: [n=2] TRUE, TRUE
[13:35:14.453] signalConditionsASAP(NULL, pos=0) ... done
[13:35:14.453] resolve() on list ... DONE
[13:35:14.453] result() for ClusterFuture ...
[13:35:14.453] - result already collected: FutureResult
[13:35:14.453] result() for ClusterFuture ... done
[13:35:14.453] result() for ClusterFuture ...
[13:35:14.454] - result already collected: FutureResult
[13:35:14.454] result() for ClusterFuture ... done
[13:35:14.454] result() for ClusterFuture ...
[13:35:14.454] - result already collected: FutureResult
[13:35:14.454] result() for ClusterFuture ... done
[13:35:14.454] result() for ClusterFuture ...
[13:35:14.454] - result already collected: FutureResult
[13:35:14.454] result() for ClusterFuture ... done
[13:35:14.454]  - Number of value chunks collected: 2
[13:35:14.454] Resolving 2 futures (chunks) ... DONE
[13:35:14.454] Reducing values from 2 chunks ...
[13:35:14.455]  - Number of values collected after concatenation: 11
[13:35:14.455]  - Number of values expected: 11
[13:35:14.455] Reducing values from 2 chunks ... DONE
[13:35:14.455] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[13:35:14.456] future_lapply() ...
[13:35:14.461] Number of chunks: 2
[13:35:14.461] getGlobalsAndPackagesXApply() ...
[13:35:14.462]  - future.globals: TRUE
[13:35:14.462] getGlobalsAndPackages() ...
[13:35:14.462] Searching for globals...
[13:35:14.465] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:14.465] Searching for globals ... DONE
[13:35:14.465] Resolving globals: FALSE
[13:35:14.466] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[13:35:14.466] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:14.467] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:14.467] - packages: [1] ‘future.apply’
[13:35:14.467] getGlobalsAndPackages() ... DONE
[13:35:14.467]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:14.467]  - needed namespaces: [n=1] ‘future.apply’
[13:35:14.467] Finding globals ... DONE
[13:35:14.467]  - use_args: TRUE
[13:35:14.467]  - Getting '...' globals ...
[13:35:14.468] resolve() on list ...
[13:35:14.468]  recursive: 0
[13:35:14.468]  length: 1
[13:35:14.468]  elements: ‘...’
[13:35:14.468]  length: 0 (resolved future 1)
[13:35:14.468] resolve() on list ... DONE
[13:35:14.468]    - '...' content: [n=0] 
[13:35:14.468] List of 1
[13:35:14.468]  $ ...: list()
[13:35:14.468]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:14.468]  - attr(*, "where")=List of 1
[13:35:14.468]   ..$ ...:<environment: 0x5574d1ca7798> 
[13:35:14.468]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:14.468]  - attr(*, "resolved")= logi TRUE
[13:35:14.468]  - attr(*, "total_size")= num NA
[13:35:14.471]  - Getting '...' globals ... DONE
[13:35:14.471] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:14.471] List of 8
[13:35:14.471]  $ ...future.FUN:function (x, ...)  
[13:35:14.471]  $ x_FUN        :function (x)  
[13:35:14.471]  $ times        : int 1
[13:35:14.471]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:14.471]  $ stop_if_not  :function (...)  
[13:35:14.471]  $ dim          : NULL
[13:35:14.471]  $ valid_types  : chr [1:2] "logical" "integer"
[13:35:14.471]  $ ...          : list()
[13:35:14.471]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:14.471]  - attr(*, "where")=List of 8
[13:35:14.471]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:14.471]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:14.471]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:14.471]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:14.471]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:14.471]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:14.471]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:14.471]   ..$ ...          :<environment: 0x5574d1ca7798> 
[13:35:14.471]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:14.471]  - attr(*, "resolved")= logi FALSE
[13:35:14.471]  - attr(*, "total_size")= num 94264
[13:35:14.477] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:14.477] getGlobalsAndPackagesXApply() ... DONE
[13:35:14.477] Number of futures (= number of chunks): 2
[13:35:14.477] Launching 2 futures (chunks) ...
[13:35:14.477] Chunk #1 of 2 ...
[13:35:14.477]  - Finding globals in 'X' for chunk #1 ...
[13:35:14.478] getGlobalsAndPackages() ...
[13:35:14.478] Searching for globals...
[13:35:14.478] 
[13:35:14.478] Searching for globals ... DONE
[13:35:14.478] - globals: [0] <none>
[13:35:14.478] getGlobalsAndPackages() ... DONE
[13:35:14.478]    + additional globals found: [n=0] 
[13:35:14.479]    + additional namespaces needed: [n=0] 
[13:35:14.479]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:14.479]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:14.479]  - seeds: <none>
[13:35:14.479]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.479] getGlobalsAndPackages() ...
[13:35:14.479] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.479] Resolving globals: FALSE
[13:35:14.479] Tweak future expression to call with '...' arguments ...
[13:35:14.480] {
[13:35:14.480]     do.call(function(...) {
[13:35:14.480]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.480]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:14.480]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.480]             on.exit(options(oopts), add = TRUE)
[13:35:14.480]         }
[13:35:14.480]         {
[13:35:14.480]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:14.480]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.480]                 ...future.FUN(...future.X_jj, ...)
[13:35:14.480]             })
[13:35:14.480]         }
[13:35:14.480]     }, args = future.call.arguments)
[13:35:14.480] }
[13:35:14.480] Tweak future expression to call with '...' arguments ... DONE
[13:35:14.480] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.480] - packages: [1] ‘future.apply’
[13:35:14.480] getGlobalsAndPackages() ... DONE
[13:35:14.481] run() for ‘Future’ ...
[13:35:14.481] - state: ‘created’
[13:35:14.481] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:14.495] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:14.495] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:14.495]   - Field: ‘node’
[13:35:14.496]   - Field: ‘label’
[13:35:14.496]   - Field: ‘local’
[13:35:14.496]   - Field: ‘owner’
[13:35:14.496]   - Field: ‘envir’
[13:35:14.496]   - Field: ‘workers’
[13:35:14.496]   - Field: ‘packages’
[13:35:14.496]   - Field: ‘gc’
[13:35:14.496]   - Field: ‘conditions’
[13:35:14.496]   - Field: ‘persistent’
[13:35:14.496]   - Field: ‘expr’
[13:35:14.497]   - Field: ‘uuid’
[13:35:14.497]   - Field: ‘seed’
[13:35:14.497]   - Field: ‘version’
[13:35:14.497]   - Field: ‘result’
[13:35:14.497]   - Field: ‘asynchronous’
[13:35:14.497]   - Field: ‘calls’
[13:35:14.497]   - Field: ‘globals’
[13:35:14.497]   - Field: ‘stdout’
[13:35:14.497]   - Field: ‘earlySignal’
[13:35:14.497]   - Field: ‘lazy’
[13:35:14.497]   - Field: ‘state’
[13:35:14.498] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:14.498] - Launch lazy future ...
[13:35:14.498] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:14.498] Packages needed by future strategies (n = 0): <none>
[13:35:14.499] {
[13:35:14.499]     {
[13:35:14.499]         {
[13:35:14.499]             ...future.startTime <- base::Sys.time()
[13:35:14.499]             {
[13:35:14.499]                 {
[13:35:14.499]                   {
[13:35:14.499]                     {
[13:35:14.499]                       {
[13:35:14.499]                         base::local({
[13:35:14.499]                           has_future <- base::requireNamespace("future", 
[13:35:14.499]                             quietly = TRUE)
[13:35:14.499]                           if (has_future) {
[13:35:14.499]                             ns <- base::getNamespace("future")
[13:35:14.499]                             version <- ns[[".package"]][["version"]]
[13:35:14.499]                             if (is.null(version)) 
[13:35:14.499]                               version <- utils::packageVersion("future")
[13:35:14.499]                           }
[13:35:14.499]                           else {
[13:35:14.499]                             version <- NULL
[13:35:14.499]                           }
[13:35:14.499]                           if (!has_future || version < "1.8.0") {
[13:35:14.499]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:14.499]                               "", base::R.version$version.string), 
[13:35:14.499]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:14.499]                                 base::R.version$platform, 8 * 
[13:35:14.499]                                   base::.Machine$sizeof.pointer), 
[13:35:14.499]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:14.499]                                 "release", "version")], collapse = " "), 
[13:35:14.499]                               hostname = base::Sys.info()[["nodename"]])
[13:35:14.499]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:14.499]                               info)
[13:35:14.499]                             info <- base::paste(info, collapse = "; ")
[13:35:14.499]                             if (!has_future) {
[13:35:14.499]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:14.499]                                 info)
[13:35:14.499]                             }
[13:35:14.499]                             else {
[13:35:14.499]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:14.499]                                 info, version)
[13:35:14.499]                             }
[13:35:14.499]                             base::stop(msg)
[13:35:14.499]                           }
[13:35:14.499]                         })
[13:35:14.499]                       }
[13:35:14.499]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:14.499]                       base::options(mc.cores = 1L)
[13:35:14.499]                     }
[13:35:14.499]                     base::local({
[13:35:14.499]                       for (pkg in "future.apply") {
[13:35:14.499]                         base::loadNamespace(pkg)
[13:35:14.499]                         base::library(pkg, character.only = TRUE)
[13:35:14.499]                       }
[13:35:14.499]                     })
[13:35:14.499]                   }
[13:35:14.499]                   ...future.strategy.old <- future::plan("list")
[13:35:14.499]                   options(future.plan = NULL)
[13:35:14.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:14.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:14.499]                 }
[13:35:14.499]                 ...future.workdir <- getwd()
[13:35:14.499]             }
[13:35:14.499]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:14.499]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:14.499]         }
[13:35:14.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:14.499]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:14.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:14.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:14.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:14.499]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:14.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:14.499]             base::names(...future.oldOptions))
[13:35:14.499]     }
[13:35:14.499]     if (FALSE) {
[13:35:14.499]     }
[13:35:14.499]     else {
[13:35:14.499]         if (TRUE) {
[13:35:14.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:14.499]                 open = "w")
[13:35:14.499]         }
[13:35:14.499]         else {
[13:35:14.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:14.499]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:14.499]         }
[13:35:14.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:14.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:14.499]             base::sink(type = "output", split = FALSE)
[13:35:14.499]             base::close(...future.stdout)
[13:35:14.499]         }, add = TRUE)
[13:35:14.499]     }
[13:35:14.499]     ...future.frame <- base::sys.nframe()
[13:35:14.499]     ...future.conditions <- base::list()
[13:35:14.499]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:14.499]     if (FALSE) {
[13:35:14.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:14.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:14.499]     }
[13:35:14.499]     ...future.result <- base::tryCatch({
[13:35:14.499]         base::withCallingHandlers({
[13:35:14.499]             ...future.value <- base::withVisible(base::local({
[13:35:14.499]                 ...future.makeSendCondition <- base::local({
[13:35:14.499]                   sendCondition <- NULL
[13:35:14.499]                   function(frame = 1L) {
[13:35:14.499]                     if (is.function(sendCondition)) 
[13:35:14.499]                       return(sendCondition)
[13:35:14.499]                     ns <- getNamespace("parallel")
[13:35:14.499]                     if (exists("sendData", mode = "function", 
[13:35:14.499]                       envir = ns)) {
[13:35:14.499]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:14.499]                         envir = ns)
[13:35:14.499]                       envir <- sys.frame(frame)
[13:35:14.499]                       master <- NULL
[13:35:14.499]                       while (!identical(envir, .GlobalEnv) && 
[13:35:14.499]                         !identical(envir, emptyenv())) {
[13:35:14.499]                         if (exists("master", mode = "list", envir = envir, 
[13:35:14.499]                           inherits = FALSE)) {
[13:35:14.499]                           master <- get("master", mode = "list", 
[13:35:14.499]                             envir = envir, inherits = FALSE)
[13:35:14.499]                           if (inherits(master, c("SOCKnode", 
[13:35:14.499]                             "SOCK0node"))) {
[13:35:14.499]                             sendCondition <<- function(cond) {
[13:35:14.499]                               data <- list(type = "VALUE", value = cond, 
[13:35:14.499]                                 success = TRUE)
[13:35:14.499]                               parallel_sendData(master, data)
[13:35:14.499]                             }
[13:35:14.499]                             return(sendCondition)
[13:35:14.499]                           }
[13:35:14.499]                         }
[13:35:14.499]                         frame <- frame + 1L
[13:35:14.499]                         envir <- sys.frame(frame)
[13:35:14.499]                       }
[13:35:14.499]                     }
[13:35:14.499]                     sendCondition <<- function(cond) NULL
[13:35:14.499]                   }
[13:35:14.499]                 })
[13:35:14.499]                 withCallingHandlers({
[13:35:14.499]                   {
[13:35:14.499]                     do.call(function(...) {
[13:35:14.499]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.499]                       if (!identical(...future.globals.maxSize.org, 
[13:35:14.499]                         ...future.globals.maxSize)) {
[13:35:14.499]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.499]                         on.exit(options(oopts), add = TRUE)
[13:35:14.499]                       }
[13:35:14.499]                       {
[13:35:14.499]                         lapply(seq_along(...future.elements_ii), 
[13:35:14.499]                           FUN = function(jj) {
[13:35:14.499]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.499]                             ...future.FUN(...future.X_jj, ...)
[13:35:14.499]                           })
[13:35:14.499]                       }
[13:35:14.499]                     }, args = future.call.arguments)
[13:35:14.499]                   }
[13:35:14.499]                 }, immediateCondition = function(cond) {
[13:35:14.499]                   sendCondition <- ...future.makeSendCondition()
[13:35:14.499]                   sendCondition(cond)
[13:35:14.499]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.499]                   {
[13:35:14.499]                     inherits <- base::inherits
[13:35:14.499]                     invokeRestart <- base::invokeRestart
[13:35:14.499]                     is.null <- base::is.null
[13:35:14.499]                     muffled <- FALSE
[13:35:14.499]                     if (inherits(cond, "message")) {
[13:35:14.499]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:14.499]                       if (muffled) 
[13:35:14.499]                         invokeRestart("muffleMessage")
[13:35:14.499]                     }
[13:35:14.499]                     else if (inherits(cond, "warning")) {
[13:35:14.499]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:14.499]                       if (muffled) 
[13:35:14.499]                         invokeRestart("muffleWarning")
[13:35:14.499]                     }
[13:35:14.499]                     else if (inherits(cond, "condition")) {
[13:35:14.499]                       if (!is.null(pattern)) {
[13:35:14.499]                         computeRestarts <- base::computeRestarts
[13:35:14.499]                         grepl <- base::grepl
[13:35:14.499]                         restarts <- computeRestarts(cond)
[13:35:14.499]                         for (restart in restarts) {
[13:35:14.499]                           name <- restart$name
[13:35:14.499]                           if (is.null(name)) 
[13:35:14.499]                             next
[13:35:14.499]                           if (!grepl(pattern, name)) 
[13:35:14.499]                             next
[13:35:14.499]                           invokeRestart(restart)
[13:35:14.499]                           muffled <- TRUE
[13:35:14.499]                           break
[13:35:14.499]                         }
[13:35:14.499]                       }
[13:35:14.499]                     }
[13:35:14.499]                     invisible(muffled)
[13:35:14.499]                   }
[13:35:14.499]                   muffleCondition(cond)
[13:35:14.499]                 })
[13:35:14.499]             }))
[13:35:14.499]             future::FutureResult(value = ...future.value$value, 
[13:35:14.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:14.499]                   ...future.rng), globalenv = if (FALSE) 
[13:35:14.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:14.499]                     ...future.globalenv.names))
[13:35:14.499]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:14.499]         }, condition = base::local({
[13:35:14.499]             c <- base::c
[13:35:14.499]             inherits <- base::inherits
[13:35:14.499]             invokeRestart <- base::invokeRestart
[13:35:14.499]             length <- base::length
[13:35:14.499]             list <- base::list
[13:35:14.499]             seq.int <- base::seq.int
[13:35:14.499]             signalCondition <- base::signalCondition
[13:35:14.499]             sys.calls <- base::sys.calls
[13:35:14.499]             `[[` <- base::`[[`
[13:35:14.499]             `+` <- base::`+`
[13:35:14.499]             `<<-` <- base::`<<-`
[13:35:14.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:14.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:14.499]                   3L)]
[13:35:14.499]             }
[13:35:14.499]             function(cond) {
[13:35:14.499]                 is_error <- inherits(cond, "error")
[13:35:14.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:14.499]                   NULL)
[13:35:14.499]                 if (is_error) {
[13:35:14.499]                   sessionInformation <- function() {
[13:35:14.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:14.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:14.499]                       search = base::search(), system = base::Sys.info())
[13:35:14.499]                   }
[13:35:14.499]                   ...future.conditions[[length(...future.conditions) + 
[13:35:14.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:14.499]                     cond$call), session = sessionInformation(), 
[13:35:14.499]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:14.499]                   signalCondition(cond)
[13:35:14.499]                 }
[13:35:14.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:14.499]                 "immediateCondition"))) {
[13:35:14.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:14.499]                   ...future.conditions[[length(...future.conditions) + 
[13:35:14.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:14.499]                   if (TRUE && !signal) {
[13:35:14.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.499]                     {
[13:35:14.499]                       inherits <- base::inherits
[13:35:14.499]                       invokeRestart <- base::invokeRestart
[13:35:14.499]                       is.null <- base::is.null
[13:35:14.499]                       muffled <- FALSE
[13:35:14.499]                       if (inherits(cond, "message")) {
[13:35:14.499]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:14.499]                         if (muffled) 
[13:35:14.499]                           invokeRestart("muffleMessage")
[13:35:14.499]                       }
[13:35:14.499]                       else if (inherits(cond, "warning")) {
[13:35:14.499]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:14.499]                         if (muffled) 
[13:35:14.499]                           invokeRestart("muffleWarning")
[13:35:14.499]                       }
[13:35:14.499]                       else if (inherits(cond, "condition")) {
[13:35:14.499]                         if (!is.null(pattern)) {
[13:35:14.499]                           computeRestarts <- base::computeRestarts
[13:35:14.499]                           grepl <- base::grepl
[13:35:14.499]                           restarts <- computeRestarts(cond)
[13:35:14.499]                           for (restart in restarts) {
[13:35:14.499]                             name <- restart$name
[13:35:14.499]                             if (is.null(name)) 
[13:35:14.499]                               next
[13:35:14.499]                             if (!grepl(pattern, name)) 
[13:35:14.499]                               next
[13:35:14.499]                             invokeRestart(restart)
[13:35:14.499]                             muffled <- TRUE
[13:35:14.499]                             break
[13:35:14.499]                           }
[13:35:14.499]                         }
[13:35:14.499]                       }
[13:35:14.499]                       invisible(muffled)
[13:35:14.499]                     }
[13:35:14.499]                     muffleCondition(cond, pattern = "^muffle")
[13:35:14.499]                   }
[13:35:14.499]                 }
[13:35:14.499]                 else {
[13:35:14.499]                   if (TRUE) {
[13:35:14.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.499]                     {
[13:35:14.499]                       inherits <- base::inherits
[13:35:14.499]                       invokeRestart <- base::invokeRestart
[13:35:14.499]                       is.null <- base::is.null
[13:35:14.499]                       muffled <- FALSE
[13:35:14.499]                       if (inherits(cond, "message")) {
[13:35:14.499]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:14.499]                         if (muffled) 
[13:35:14.499]                           invokeRestart("muffleMessage")
[13:35:14.499]                       }
[13:35:14.499]                       else if (inherits(cond, "warning")) {
[13:35:14.499]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:14.499]                         if (muffled) 
[13:35:14.499]                           invokeRestart("muffleWarning")
[13:35:14.499]                       }
[13:35:14.499]                       else if (inherits(cond, "condition")) {
[13:35:14.499]                         if (!is.null(pattern)) {
[13:35:14.499]                           computeRestarts <- base::computeRestarts
[13:35:14.499]                           grepl <- base::grepl
[13:35:14.499]                           restarts <- computeRestarts(cond)
[13:35:14.499]                           for (restart in restarts) {
[13:35:14.499]                             name <- restart$name
[13:35:14.499]                             if (is.null(name)) 
[13:35:14.499]                               next
[13:35:14.499]                             if (!grepl(pattern, name)) 
[13:35:14.499]                               next
[13:35:14.499]                             invokeRestart(restart)
[13:35:14.499]                             muffled <- TRUE
[13:35:14.499]                             break
[13:35:14.499]                           }
[13:35:14.499]                         }
[13:35:14.499]                       }
[13:35:14.499]                       invisible(muffled)
[13:35:14.499]                     }
[13:35:14.499]                     muffleCondition(cond, pattern = "^muffle")
[13:35:14.499]                   }
[13:35:14.499]                 }
[13:35:14.499]             }
[13:35:14.499]         }))
[13:35:14.499]     }, error = function(ex) {
[13:35:14.499]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:14.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:14.499]                 ...future.rng), started = ...future.startTime, 
[13:35:14.499]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:14.499]             version = "1.8"), class = "FutureResult")
[13:35:14.499]     }, finally = {
[13:35:14.499]         if (!identical(...future.workdir, getwd())) 
[13:35:14.499]             setwd(...future.workdir)
[13:35:14.499]         {
[13:35:14.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:14.499]                 ...future.oldOptions$nwarnings <- NULL
[13:35:14.499]             }
[13:35:14.499]             base::options(...future.oldOptions)
[13:35:14.499]             if (.Platform$OS.type == "windows") {
[13:35:14.499]                 old_names <- names(...future.oldEnvVars)
[13:35:14.499]                 envs <- base::Sys.getenv()
[13:35:14.499]                 names <- names(envs)
[13:35:14.499]                 common <- intersect(names, old_names)
[13:35:14.499]                 added <- setdiff(names, old_names)
[13:35:14.499]                 removed <- setdiff(old_names, names)
[13:35:14.499]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:14.499]                   envs[common]]
[13:35:14.499]                 NAMES <- toupper(changed)
[13:35:14.499]                 args <- list()
[13:35:14.499]                 for (kk in seq_along(NAMES)) {
[13:35:14.499]                   name <- changed[[kk]]
[13:35:14.499]                   NAME <- NAMES[[kk]]
[13:35:14.499]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.499]                     next
[13:35:14.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:14.499]                 }
[13:35:14.499]                 NAMES <- toupper(added)
[13:35:14.499]                 for (kk in seq_along(NAMES)) {
[13:35:14.499]                   name <- added[[kk]]
[13:35:14.499]                   NAME <- NAMES[[kk]]
[13:35:14.499]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.499]                     next
[13:35:14.499]                   args[[name]] <- ""
[13:35:14.499]                 }
[13:35:14.499]                 NAMES <- toupper(removed)
[13:35:14.499]                 for (kk in seq_along(NAMES)) {
[13:35:14.499]                   name <- removed[[kk]]
[13:35:14.499]                   NAME <- NAMES[[kk]]
[13:35:14.499]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.499]                     next
[13:35:14.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:14.499]                 }
[13:35:14.499]                 if (length(args) > 0) 
[13:35:14.499]                   base::do.call(base::Sys.setenv, args = args)
[13:35:14.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:14.499]             }
[13:35:14.499]             else {
[13:35:14.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:14.499]             }
[13:35:14.499]             {
[13:35:14.499]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:14.499]                   0L) {
[13:35:14.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:14.499]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:14.499]                   base::options(opts)
[13:35:14.499]                 }
[13:35:14.499]                 {
[13:35:14.499]                   {
[13:35:14.499]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:14.499]                     NULL
[13:35:14.499]                   }
[13:35:14.499]                   options(future.plan = NULL)
[13:35:14.499]                   if (is.na(NA_character_)) 
[13:35:14.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:14.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:14.499]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:14.499]                     .init = FALSE)
[13:35:14.499]                 }
[13:35:14.499]             }
[13:35:14.499]         }
[13:35:14.499]     })
[13:35:14.499]     if (TRUE) {
[13:35:14.499]         base::sink(type = "output", split = FALSE)
[13:35:14.499]         if (TRUE) {
[13:35:14.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:14.499]         }
[13:35:14.499]         else {
[13:35:14.499]             ...future.result["stdout"] <- base::list(NULL)
[13:35:14.499]         }
[13:35:14.499]         base::close(...future.stdout)
[13:35:14.499]         ...future.stdout <- NULL
[13:35:14.499]     }
[13:35:14.499]     ...future.result$conditions <- ...future.conditions
[13:35:14.499]     ...future.result$finished <- base::Sys.time()
[13:35:14.499]     ...future.result
[13:35:14.499] }
[13:35:14.501] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[13:35:14.502] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:14.542] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:14.543] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[13:35:14.543] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[13:35:14.543] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:14.544] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:14.544] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:14.586] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:14.587] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:14.630] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:14.631] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:14.631] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:14.631] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[13:35:14.632] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[13:35:14.632] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:14.632] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:14.632] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:35:14.633] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:35:14.633] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:14.633] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:14.633] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:14.634] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:14.634] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[13:35:14.634] MultisessionFuture started
[13:35:14.635] - Launch lazy future ... done
[13:35:14.635] run() for ‘MultisessionFuture’ ... done
[13:35:14.635] Created future:
[13:35:14.635] MultisessionFuture:
[13:35:14.635] Label: ‘future_vapply-1’
[13:35:14.635] Expression:
[13:35:14.635] {
[13:35:14.635]     do.call(function(...) {
[13:35:14.635]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.635]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:14.635]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.635]             on.exit(options(oopts), add = TRUE)
[13:35:14.635]         }
[13:35:14.635]         {
[13:35:14.635]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:14.635]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.635]                 ...future.FUN(...future.X_jj, ...)
[13:35:14.635]             })
[13:35:14.635]         }
[13:35:14.635]     }, args = future.call.arguments)
[13:35:14.635] }
[13:35:14.635] Lazy evaluation: FALSE
[13:35:14.635] Asynchronous evaluation: TRUE
[13:35:14.635] Local evaluation: TRUE
[13:35:14.635] Environment: R_GlobalEnv
[13:35:14.635] Capture standard output: TRUE
[13:35:14.635] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:14.635] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:14.635] Packages: 1 packages (‘future.apply’)
[13:35:14.635] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:14.635] Resolved: FALSE
[13:35:14.635] Value: <not collected>
[13:35:14.635] Conditions captured: <none>
[13:35:14.635] Early signaling: FALSE
[13:35:14.635] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:14.635] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:14.647] Chunk #1 of 2 ... DONE
[13:35:14.647] Chunk #2 of 2 ...
[13:35:14.647]  - Finding globals in 'X' for chunk #2 ...
[13:35:14.647] getGlobalsAndPackages() ...
[13:35:14.647] Searching for globals...
[13:35:14.647] 
[13:35:14.647] Searching for globals ... DONE
[13:35:14.647] - globals: [0] <none>
[13:35:14.648] getGlobalsAndPackages() ... DONE
[13:35:14.648]    + additional globals found: [n=0] 
[13:35:14.648]    + additional namespaces needed: [n=0] 
[13:35:14.648]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:14.648]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:14.648]  - seeds: <none>
[13:35:14.648]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.648] getGlobalsAndPackages() ...
[13:35:14.648] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.648] Resolving globals: FALSE
[13:35:14.649] Tweak future expression to call with '...' arguments ...
[13:35:14.649] {
[13:35:14.649]     do.call(function(...) {
[13:35:14.649]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.649]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:14.649]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.649]             on.exit(options(oopts), add = TRUE)
[13:35:14.649]         }
[13:35:14.649]         {
[13:35:14.649]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:14.649]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.649]                 ...future.FUN(...future.X_jj, ...)
[13:35:14.649]             })
[13:35:14.649]         }
[13:35:14.649]     }, args = future.call.arguments)
[13:35:14.649] }
[13:35:14.649] Tweak future expression to call with '...' arguments ... DONE
[13:35:14.649] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.649] - packages: [1] ‘future.apply’
[13:35:14.650] getGlobalsAndPackages() ... DONE
[13:35:14.650] run() for ‘Future’ ...
[13:35:14.650] - state: ‘created’
[13:35:14.650] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:14.664] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:14.664] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:14.667]   - Field: ‘node’
[13:35:14.667]   - Field: ‘label’
[13:35:14.667]   - Field: ‘local’
[13:35:14.667]   - Field: ‘owner’
[13:35:14.667]   - Field: ‘envir’
[13:35:14.667]   - Field: ‘workers’
[13:35:14.667]   - Field: ‘packages’
[13:35:14.668]   - Field: ‘gc’
[13:35:14.668]   - Field: ‘conditions’
[13:35:14.668]   - Field: ‘persistent’
[13:35:14.668]   - Field: ‘expr’
[13:35:14.668]   - Field: ‘uuid’
[13:35:14.668]   - Field: ‘seed’
[13:35:14.668]   - Field: ‘version’
[13:35:14.668]   - Field: ‘result’
[13:35:14.668]   - Field: ‘asynchronous’
[13:35:14.668]   - Field: ‘calls’
[13:35:14.668]   - Field: ‘globals’
[13:35:14.668]   - Field: ‘stdout’
[13:35:14.669]   - Field: ‘earlySignal’
[13:35:14.669]   - Field: ‘lazy’
[13:35:14.669]   - Field: ‘state’
[13:35:14.669] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:14.669] - Launch lazy future ...
[13:35:14.669] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:14.669] Packages needed by future strategies (n = 0): <none>
[13:35:14.670] {
[13:35:14.670]     {
[13:35:14.670]         {
[13:35:14.670]             ...future.startTime <- base::Sys.time()
[13:35:14.670]             {
[13:35:14.670]                 {
[13:35:14.670]                   {
[13:35:14.670]                     {
[13:35:14.670]                       {
[13:35:14.670]                         base::local({
[13:35:14.670]                           has_future <- base::requireNamespace("future", 
[13:35:14.670]                             quietly = TRUE)
[13:35:14.670]                           if (has_future) {
[13:35:14.670]                             ns <- base::getNamespace("future")
[13:35:14.670]                             version <- ns[[".package"]][["version"]]
[13:35:14.670]                             if (is.null(version)) 
[13:35:14.670]                               version <- utils::packageVersion("future")
[13:35:14.670]                           }
[13:35:14.670]                           else {
[13:35:14.670]                             version <- NULL
[13:35:14.670]                           }
[13:35:14.670]                           if (!has_future || version < "1.8.0") {
[13:35:14.670]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:14.670]                               "", base::R.version$version.string), 
[13:35:14.670]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:14.670]                                 base::R.version$platform, 8 * 
[13:35:14.670]                                   base::.Machine$sizeof.pointer), 
[13:35:14.670]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:14.670]                                 "release", "version")], collapse = " "), 
[13:35:14.670]                               hostname = base::Sys.info()[["nodename"]])
[13:35:14.670]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:14.670]                               info)
[13:35:14.670]                             info <- base::paste(info, collapse = "; ")
[13:35:14.670]                             if (!has_future) {
[13:35:14.670]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:14.670]                                 info)
[13:35:14.670]                             }
[13:35:14.670]                             else {
[13:35:14.670]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:14.670]                                 info, version)
[13:35:14.670]                             }
[13:35:14.670]                             base::stop(msg)
[13:35:14.670]                           }
[13:35:14.670]                         })
[13:35:14.670]                       }
[13:35:14.670]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:14.670]                       base::options(mc.cores = 1L)
[13:35:14.670]                     }
[13:35:14.670]                     base::local({
[13:35:14.670]                       for (pkg in "future.apply") {
[13:35:14.670]                         base::loadNamespace(pkg)
[13:35:14.670]                         base::library(pkg, character.only = TRUE)
[13:35:14.670]                       }
[13:35:14.670]                     })
[13:35:14.670]                   }
[13:35:14.670]                   ...future.strategy.old <- future::plan("list")
[13:35:14.670]                   options(future.plan = NULL)
[13:35:14.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:14.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:14.670]                 }
[13:35:14.670]                 ...future.workdir <- getwd()
[13:35:14.670]             }
[13:35:14.670]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:14.670]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:14.670]         }
[13:35:14.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:14.670]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:14.670]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:14.670]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:14.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:14.670]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:14.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:14.670]             base::names(...future.oldOptions))
[13:35:14.670]     }
[13:35:14.670]     if (FALSE) {
[13:35:14.670]     }
[13:35:14.670]     else {
[13:35:14.670]         if (TRUE) {
[13:35:14.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:14.670]                 open = "w")
[13:35:14.670]         }
[13:35:14.670]         else {
[13:35:14.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:14.670]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:14.670]         }
[13:35:14.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:14.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:14.670]             base::sink(type = "output", split = FALSE)
[13:35:14.670]             base::close(...future.stdout)
[13:35:14.670]         }, add = TRUE)
[13:35:14.670]     }
[13:35:14.670]     ...future.frame <- base::sys.nframe()
[13:35:14.670]     ...future.conditions <- base::list()
[13:35:14.670]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:14.670]     if (FALSE) {
[13:35:14.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:14.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:14.670]     }
[13:35:14.670]     ...future.result <- base::tryCatch({
[13:35:14.670]         base::withCallingHandlers({
[13:35:14.670]             ...future.value <- base::withVisible(base::local({
[13:35:14.670]                 ...future.makeSendCondition <- base::local({
[13:35:14.670]                   sendCondition <- NULL
[13:35:14.670]                   function(frame = 1L) {
[13:35:14.670]                     if (is.function(sendCondition)) 
[13:35:14.670]                       return(sendCondition)
[13:35:14.670]                     ns <- getNamespace("parallel")
[13:35:14.670]                     if (exists("sendData", mode = "function", 
[13:35:14.670]                       envir = ns)) {
[13:35:14.670]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:14.670]                         envir = ns)
[13:35:14.670]                       envir <- sys.frame(frame)
[13:35:14.670]                       master <- NULL
[13:35:14.670]                       while (!identical(envir, .GlobalEnv) && 
[13:35:14.670]                         !identical(envir, emptyenv())) {
[13:35:14.670]                         if (exists("master", mode = "list", envir = envir, 
[13:35:14.670]                           inherits = FALSE)) {
[13:35:14.670]                           master <- get("master", mode = "list", 
[13:35:14.670]                             envir = envir, inherits = FALSE)
[13:35:14.670]                           if (inherits(master, c("SOCKnode", 
[13:35:14.670]                             "SOCK0node"))) {
[13:35:14.670]                             sendCondition <<- function(cond) {
[13:35:14.670]                               data <- list(type = "VALUE", value = cond, 
[13:35:14.670]                                 success = TRUE)
[13:35:14.670]                               parallel_sendData(master, data)
[13:35:14.670]                             }
[13:35:14.670]                             return(sendCondition)
[13:35:14.670]                           }
[13:35:14.670]                         }
[13:35:14.670]                         frame <- frame + 1L
[13:35:14.670]                         envir <- sys.frame(frame)
[13:35:14.670]                       }
[13:35:14.670]                     }
[13:35:14.670]                     sendCondition <<- function(cond) NULL
[13:35:14.670]                   }
[13:35:14.670]                 })
[13:35:14.670]                 withCallingHandlers({
[13:35:14.670]                   {
[13:35:14.670]                     do.call(function(...) {
[13:35:14.670]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.670]                       if (!identical(...future.globals.maxSize.org, 
[13:35:14.670]                         ...future.globals.maxSize)) {
[13:35:14.670]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.670]                         on.exit(options(oopts), add = TRUE)
[13:35:14.670]                       }
[13:35:14.670]                       {
[13:35:14.670]                         lapply(seq_along(...future.elements_ii), 
[13:35:14.670]                           FUN = function(jj) {
[13:35:14.670]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.670]                             ...future.FUN(...future.X_jj, ...)
[13:35:14.670]                           })
[13:35:14.670]                       }
[13:35:14.670]                     }, args = future.call.arguments)
[13:35:14.670]                   }
[13:35:14.670]                 }, immediateCondition = function(cond) {
[13:35:14.670]                   sendCondition <- ...future.makeSendCondition()
[13:35:14.670]                   sendCondition(cond)
[13:35:14.670]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.670]                   {
[13:35:14.670]                     inherits <- base::inherits
[13:35:14.670]                     invokeRestart <- base::invokeRestart
[13:35:14.670]                     is.null <- base::is.null
[13:35:14.670]                     muffled <- FALSE
[13:35:14.670]                     if (inherits(cond, "message")) {
[13:35:14.670]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:14.670]                       if (muffled) 
[13:35:14.670]                         invokeRestart("muffleMessage")
[13:35:14.670]                     }
[13:35:14.670]                     else if (inherits(cond, "warning")) {
[13:35:14.670]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:14.670]                       if (muffled) 
[13:35:14.670]                         invokeRestart("muffleWarning")
[13:35:14.670]                     }
[13:35:14.670]                     else if (inherits(cond, "condition")) {
[13:35:14.670]                       if (!is.null(pattern)) {
[13:35:14.670]                         computeRestarts <- base::computeRestarts
[13:35:14.670]                         grepl <- base::grepl
[13:35:14.670]                         restarts <- computeRestarts(cond)
[13:35:14.670]                         for (restart in restarts) {
[13:35:14.670]                           name <- restart$name
[13:35:14.670]                           if (is.null(name)) 
[13:35:14.670]                             next
[13:35:14.670]                           if (!grepl(pattern, name)) 
[13:35:14.670]                             next
[13:35:14.670]                           invokeRestart(restart)
[13:35:14.670]                           muffled <- TRUE
[13:35:14.670]                           break
[13:35:14.670]                         }
[13:35:14.670]                       }
[13:35:14.670]                     }
[13:35:14.670]                     invisible(muffled)
[13:35:14.670]                   }
[13:35:14.670]                   muffleCondition(cond)
[13:35:14.670]                 })
[13:35:14.670]             }))
[13:35:14.670]             future::FutureResult(value = ...future.value$value, 
[13:35:14.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:14.670]                   ...future.rng), globalenv = if (FALSE) 
[13:35:14.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:14.670]                     ...future.globalenv.names))
[13:35:14.670]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:14.670]         }, condition = base::local({
[13:35:14.670]             c <- base::c
[13:35:14.670]             inherits <- base::inherits
[13:35:14.670]             invokeRestart <- base::invokeRestart
[13:35:14.670]             length <- base::length
[13:35:14.670]             list <- base::list
[13:35:14.670]             seq.int <- base::seq.int
[13:35:14.670]             signalCondition <- base::signalCondition
[13:35:14.670]             sys.calls <- base::sys.calls
[13:35:14.670]             `[[` <- base::`[[`
[13:35:14.670]             `+` <- base::`+`
[13:35:14.670]             `<<-` <- base::`<<-`
[13:35:14.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:14.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:14.670]                   3L)]
[13:35:14.670]             }
[13:35:14.670]             function(cond) {
[13:35:14.670]                 is_error <- inherits(cond, "error")
[13:35:14.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:14.670]                   NULL)
[13:35:14.670]                 if (is_error) {
[13:35:14.670]                   sessionInformation <- function() {
[13:35:14.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:14.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:14.670]                       search = base::search(), system = base::Sys.info())
[13:35:14.670]                   }
[13:35:14.670]                   ...future.conditions[[length(...future.conditions) + 
[13:35:14.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:14.670]                     cond$call), session = sessionInformation(), 
[13:35:14.670]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:14.670]                   signalCondition(cond)
[13:35:14.670]                 }
[13:35:14.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:14.670]                 "immediateCondition"))) {
[13:35:14.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:14.670]                   ...future.conditions[[length(...future.conditions) + 
[13:35:14.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:14.670]                   if (TRUE && !signal) {
[13:35:14.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.670]                     {
[13:35:14.670]                       inherits <- base::inherits
[13:35:14.670]                       invokeRestart <- base::invokeRestart
[13:35:14.670]                       is.null <- base::is.null
[13:35:14.670]                       muffled <- FALSE
[13:35:14.670]                       if (inherits(cond, "message")) {
[13:35:14.670]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:14.670]                         if (muffled) 
[13:35:14.670]                           invokeRestart("muffleMessage")
[13:35:14.670]                       }
[13:35:14.670]                       else if (inherits(cond, "warning")) {
[13:35:14.670]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:14.670]                         if (muffled) 
[13:35:14.670]                           invokeRestart("muffleWarning")
[13:35:14.670]                       }
[13:35:14.670]                       else if (inherits(cond, "condition")) {
[13:35:14.670]                         if (!is.null(pattern)) {
[13:35:14.670]                           computeRestarts <- base::computeRestarts
[13:35:14.670]                           grepl <- base::grepl
[13:35:14.670]                           restarts <- computeRestarts(cond)
[13:35:14.670]                           for (restart in restarts) {
[13:35:14.670]                             name <- restart$name
[13:35:14.670]                             if (is.null(name)) 
[13:35:14.670]                               next
[13:35:14.670]                             if (!grepl(pattern, name)) 
[13:35:14.670]                               next
[13:35:14.670]                             invokeRestart(restart)
[13:35:14.670]                             muffled <- TRUE
[13:35:14.670]                             break
[13:35:14.670]                           }
[13:35:14.670]                         }
[13:35:14.670]                       }
[13:35:14.670]                       invisible(muffled)
[13:35:14.670]                     }
[13:35:14.670]                     muffleCondition(cond, pattern = "^muffle")
[13:35:14.670]                   }
[13:35:14.670]                 }
[13:35:14.670]                 else {
[13:35:14.670]                   if (TRUE) {
[13:35:14.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.670]                     {
[13:35:14.670]                       inherits <- base::inherits
[13:35:14.670]                       invokeRestart <- base::invokeRestart
[13:35:14.670]                       is.null <- base::is.null
[13:35:14.670]                       muffled <- FALSE
[13:35:14.670]                       if (inherits(cond, "message")) {
[13:35:14.670]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:14.670]                         if (muffled) 
[13:35:14.670]                           invokeRestart("muffleMessage")
[13:35:14.670]                       }
[13:35:14.670]                       else if (inherits(cond, "warning")) {
[13:35:14.670]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:14.670]                         if (muffled) 
[13:35:14.670]                           invokeRestart("muffleWarning")
[13:35:14.670]                       }
[13:35:14.670]                       else if (inherits(cond, "condition")) {
[13:35:14.670]                         if (!is.null(pattern)) {
[13:35:14.670]                           computeRestarts <- base::computeRestarts
[13:35:14.670]                           grepl <- base::grepl
[13:35:14.670]                           restarts <- computeRestarts(cond)
[13:35:14.670]                           for (restart in restarts) {
[13:35:14.670]                             name <- restart$name
[13:35:14.670]                             if (is.null(name)) 
[13:35:14.670]                               next
[13:35:14.670]                             if (!grepl(pattern, name)) 
[13:35:14.670]                               next
[13:35:14.670]                             invokeRestart(restart)
[13:35:14.670]                             muffled <- TRUE
[13:35:14.670]                             break
[13:35:14.670]                           }
[13:35:14.670]                         }
[13:35:14.670]                       }
[13:35:14.670]                       invisible(muffled)
[13:35:14.670]                     }
[13:35:14.670]                     muffleCondition(cond, pattern = "^muffle")
[13:35:14.670]                   }
[13:35:14.670]                 }
[13:35:14.670]             }
[13:35:14.670]         }))
[13:35:14.670]     }, error = function(ex) {
[13:35:14.670]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:14.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:14.670]                 ...future.rng), started = ...future.startTime, 
[13:35:14.670]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:14.670]             version = "1.8"), class = "FutureResult")
[13:35:14.670]     }, finally = {
[13:35:14.670]         if (!identical(...future.workdir, getwd())) 
[13:35:14.670]             setwd(...future.workdir)
[13:35:14.670]         {
[13:35:14.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:14.670]                 ...future.oldOptions$nwarnings <- NULL
[13:35:14.670]             }
[13:35:14.670]             base::options(...future.oldOptions)
[13:35:14.670]             if (.Platform$OS.type == "windows") {
[13:35:14.670]                 old_names <- names(...future.oldEnvVars)
[13:35:14.670]                 envs <- base::Sys.getenv()
[13:35:14.670]                 names <- names(envs)
[13:35:14.670]                 common <- intersect(names, old_names)
[13:35:14.670]                 added <- setdiff(names, old_names)
[13:35:14.670]                 removed <- setdiff(old_names, names)
[13:35:14.670]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:14.670]                   envs[common]]
[13:35:14.670]                 NAMES <- toupper(changed)
[13:35:14.670]                 args <- list()
[13:35:14.670]                 for (kk in seq_along(NAMES)) {
[13:35:14.670]                   name <- changed[[kk]]
[13:35:14.670]                   NAME <- NAMES[[kk]]
[13:35:14.670]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.670]                     next
[13:35:14.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:14.670]                 }
[13:35:14.670]                 NAMES <- toupper(added)
[13:35:14.670]                 for (kk in seq_along(NAMES)) {
[13:35:14.670]                   name <- added[[kk]]
[13:35:14.670]                   NAME <- NAMES[[kk]]
[13:35:14.670]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.670]                     next
[13:35:14.670]                   args[[name]] <- ""
[13:35:14.670]                 }
[13:35:14.670]                 NAMES <- toupper(removed)
[13:35:14.670]                 for (kk in seq_along(NAMES)) {
[13:35:14.670]                   name <- removed[[kk]]
[13:35:14.670]                   NAME <- NAMES[[kk]]
[13:35:14.670]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.670]                     next
[13:35:14.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:14.670]                 }
[13:35:14.670]                 if (length(args) > 0) 
[13:35:14.670]                   base::do.call(base::Sys.setenv, args = args)
[13:35:14.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:14.670]             }
[13:35:14.670]             else {
[13:35:14.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:14.670]             }
[13:35:14.670]             {
[13:35:14.670]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:14.670]                   0L) {
[13:35:14.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:14.670]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:14.670]                   base::options(opts)
[13:35:14.670]                 }
[13:35:14.670]                 {
[13:35:14.670]                   {
[13:35:14.670]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:14.670]                     NULL
[13:35:14.670]                   }
[13:35:14.670]                   options(future.plan = NULL)
[13:35:14.670]                   if (is.na(NA_character_)) 
[13:35:14.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:14.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:14.670]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:14.670]                     .init = FALSE)
[13:35:14.670]                 }
[13:35:14.670]             }
[13:35:14.670]         }
[13:35:14.670]     })
[13:35:14.670]     if (TRUE) {
[13:35:14.670]         base::sink(type = "output", split = FALSE)
[13:35:14.670]         if (TRUE) {
[13:35:14.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:14.670]         }
[13:35:14.670]         else {
[13:35:14.670]             ...future.result["stdout"] <- base::list(NULL)
[13:35:14.670]         }
[13:35:14.670]         base::close(...future.stdout)
[13:35:14.670]         ...future.stdout <- NULL
[13:35:14.670]     }
[13:35:14.670]     ...future.result$conditions <- ...future.conditions
[13:35:14.670]     ...future.result$finished <- base::Sys.time()
[13:35:14.670]     ...future.result
[13:35:14.670] }
[13:35:14.672] Exporting 11 global objects (92.05 KiB) to cluster node #2 ...
[13:35:14.673] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[13:35:14.714] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[13:35:14.715] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[13:35:14.715] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[13:35:14.715] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[13:35:14.716] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[13:35:14.716] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[13:35:14.758] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[13:35:14.759] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[13:35:14.802] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[13:35:14.803] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[13:35:14.803] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[13:35:14.803] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[13:35:14.804] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[13:35:14.804] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[13:35:14.804] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[13:35:14.804] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[13:35:14.805] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[13:35:14.805] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[13:35:14.805] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[13:35:14.805] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[13:35:14.806] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[13:35:14.806] Exporting 11 global objects (92.05 KiB) to cluster node #2 ... DONE
[13:35:14.807] MultisessionFuture started
[13:35:14.807] - Launch lazy future ... done
[13:35:14.807] run() for ‘MultisessionFuture’ ... done
[13:35:14.807] Created future:
[13:35:14.807] MultisessionFuture:
[13:35:14.807] Label: ‘future_vapply-2’
[13:35:14.807] Expression:
[13:35:14.807] {
[13:35:14.807]     do.call(function(...) {
[13:35:14.807]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.807]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:14.807]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.807]             on.exit(options(oopts), add = TRUE)
[13:35:14.807]         }
[13:35:14.807]         {
[13:35:14.807]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:14.807]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.807]                 ...future.FUN(...future.X_jj, ...)
[13:35:14.807]             })
[13:35:14.807]         }
[13:35:14.807]     }, args = future.call.arguments)
[13:35:14.807] }
[13:35:14.807] Lazy evaluation: FALSE
[13:35:14.807] Asynchronous evaluation: TRUE
[13:35:14.807] Local evaluation: TRUE
[13:35:14.807] Environment: R_GlobalEnv
[13:35:14.807] Capture standard output: TRUE
[13:35:14.807] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:14.807] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:14.807] Packages: 1 packages (‘future.apply’)
[13:35:14.807] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:14.807] Resolved: FALSE
[13:35:14.807] Value: <not collected>
[13:35:14.807] Conditions captured: <none>
[13:35:14.807] Early signaling: FALSE
[13:35:14.807] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:14.807] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:14.819] Chunk #2 of 2 ... DONE
[13:35:14.819] Launching 2 futures (chunks) ... DONE
[13:35:14.819] Resolving 2 futures (chunks) ...
[13:35:14.819] resolve() on list ...
[13:35:14.819]  recursive: 0
[13:35:14.819]  length: 2
[13:35:14.819] 
[13:35:14.820] receiveMessageFromWorker() for ClusterFuture ...
[13:35:14.820] - Validating connection of MultisessionFuture
[13:35:14.820] - received message: FutureResult
[13:35:14.820] - Received FutureResult
[13:35:14.820] - Erased future from FutureRegistry
[13:35:14.820] result() for ClusterFuture ...
[13:35:14.821] - result already collected: FutureResult
[13:35:14.821] result() for ClusterFuture ... done
[13:35:14.821] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:14.821] Future #1
[13:35:14.821] result() for ClusterFuture ...
[13:35:14.821] - result already collected: FutureResult
[13:35:14.821] result() for ClusterFuture ... done
[13:35:14.821] result() for ClusterFuture ...
[13:35:14.821] - result already collected: FutureResult
[13:35:14.821] result() for ClusterFuture ... done
[13:35:14.822] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:14.822] - nx: 2
[13:35:14.822] - relay: TRUE
[13:35:14.822] - stdout: TRUE
[13:35:14.822] - signal: TRUE
[13:35:14.822] - resignal: FALSE
[13:35:14.822] - force: TRUE
[13:35:14.822] - relayed: [n=2] FALSE, FALSE
[13:35:14.822] - queued futures: [n=2] FALSE, FALSE
[13:35:14.822]  - until=1
[13:35:14.822]  - relaying element #1
[13:35:14.823] result() for ClusterFuture ...
[13:35:14.823] - result already collected: FutureResult
[13:35:14.823] result() for ClusterFuture ... done
[13:35:14.823] result() for ClusterFuture ...
[13:35:14.823] - result already collected: FutureResult
[13:35:14.823] result() for ClusterFuture ... done
[13:35:14.823] result() for ClusterFuture ...
[13:35:14.823] - result already collected: FutureResult
[13:35:14.823] result() for ClusterFuture ... done
[13:35:14.823] result() for ClusterFuture ...
[13:35:14.823] - result already collected: FutureResult
[13:35:14.824] result() for ClusterFuture ... done
[13:35:14.824] - relayed: [n=2] TRUE, FALSE
[13:35:14.824] - queued futures: [n=2] TRUE, FALSE
[13:35:14.824] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:14.824]  length: 1 (resolved future 1)
[13:35:14.852] receiveMessageFromWorker() for ClusterFuture ...
[13:35:14.852] - Validating connection of MultisessionFuture
[13:35:14.852] - received message: FutureResult
[13:35:14.852] - Received FutureResult
[13:35:14.852] - Erased future from FutureRegistry
[13:35:14.853] result() for ClusterFuture ...
[13:35:14.853] - result already collected: FutureResult
[13:35:14.853] result() for ClusterFuture ... done
[13:35:14.853] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:14.853] Future #2
[13:35:14.853] result() for ClusterFuture ...
[13:35:14.853] - result already collected: FutureResult
[13:35:14.853] result() for ClusterFuture ... done
[13:35:14.853] result() for ClusterFuture ...
[13:35:14.853] - result already collected: FutureResult
[13:35:14.853] result() for ClusterFuture ... done
[13:35:14.854] signalConditionsASAP(MultisessionFuture, pos=2) ...
[13:35:14.854] - nx: 2
[13:35:14.854] - relay: TRUE
[13:35:14.854] - stdout: TRUE
[13:35:14.854] - signal: TRUE
[13:35:14.854] - resignal: FALSE
[13:35:14.854] - force: TRUE
[13:35:14.854] - relayed: [n=2] TRUE, FALSE
[13:35:14.854] - queued futures: [n=2] TRUE, FALSE
[13:35:14.854]  - until=2
[13:35:14.854]  - relaying element #2
[13:35:14.855] result() for ClusterFuture ...
[13:35:14.855] - result already collected: FutureResult
[13:35:14.855] result() for ClusterFuture ... done
[13:35:14.855] result() for ClusterFuture ...
[13:35:14.855] - result already collected: FutureResult
[13:35:14.855] result() for ClusterFuture ... done
[13:35:14.855] result() for ClusterFuture ...
[13:35:14.855] - result already collected: FutureResult
[13:35:14.855] result() for ClusterFuture ... done
[13:35:14.855] result() for ClusterFuture ...
[13:35:14.856] - result already collected: FutureResult
[13:35:14.856] result() for ClusterFuture ... done
[13:35:14.856] - relayed: [n=2] TRUE, TRUE
[13:35:14.856] - queued futures: [n=2] TRUE, TRUE
[13:35:14.856] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[13:35:14.856]  length: 0 (resolved future 2)
[13:35:14.856] Relaying remaining futures
[13:35:14.856] signalConditionsASAP(NULL, pos=0) ...
[13:35:14.856] - nx: 2
[13:35:14.856] - relay: TRUE
[13:35:14.856] - stdout: TRUE
[13:35:14.856] - signal: TRUE
[13:35:14.857] - resignal: FALSE
[13:35:14.857] - force: TRUE
[13:35:14.857] - relayed: [n=2] TRUE, TRUE
[13:35:14.857] - queued futures: [n=2] TRUE, TRUE
 - flush all
[13:35:14.857] - relayed: [n=2] TRUE, TRUE
[13:35:14.857] - queued futures: [n=2] TRUE, TRUE
[13:35:14.857] signalConditionsASAP(NULL, pos=0) ... done
[13:35:14.857] resolve() on list ... DONE
[13:35:14.857] result() for ClusterFuture ...
[13:35:14.857] - result already collected: FutureResult
[13:35:14.857] result() for ClusterFuture ... done
[13:35:14.858] result() for ClusterFuture ...
[13:35:14.858] - result already collected: FutureResult
[13:35:14.858] result() for ClusterFuture ... done
[13:35:14.858] result() for ClusterFuture ...
[13:35:14.858] - result already collected: FutureResult
[13:35:14.858] result() for ClusterFuture ... done
[13:35:14.858] result() for ClusterFuture ...
[13:35:14.858] - result already collected: FutureResult
[13:35:14.858] result() for ClusterFuture ... done
[13:35:14.858]  - Number of value chunks collected: 2
[13:35:14.858] Resolving 2 futures (chunks) ... DONE
[13:35:14.859] Reducing values from 2 chunks ...
[13:35:14.859]  - Number of values collected after concatenation: 3
[13:35:14.859]  - Number of values expected: 3
[13:35:14.859] Reducing values from 2 chunks ... DONE
[13:35:14.859] future_lapply() ... DONE
- exceptions ...
[13:35:14.859] future_lapply() ...
[13:35:14.864] Number of chunks: 2
[13:35:14.864] getGlobalsAndPackagesXApply() ...
[13:35:14.864]  - future.globals: TRUE
[13:35:14.865] getGlobalsAndPackages() ...
[13:35:14.865] Searching for globals...
[13:35:14.868] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[13:35:14.868] Searching for globals ... DONE
[13:35:14.868] Resolving globals: FALSE
[13:35:14.869] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[13:35:14.869] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[13:35:14.870] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:14.870] - packages: [1] ‘future.apply’
[13:35:14.870] getGlobalsAndPackages() ... DONE
[13:35:14.870]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[13:35:14.870]  - needed namespaces: [n=1] ‘future.apply’
[13:35:14.870] Finding globals ... DONE
[13:35:14.870]  - use_args: TRUE
[13:35:14.870]  - Getting '...' globals ...
[13:35:14.871] resolve() on list ...
[13:35:14.871]  recursive: 0
[13:35:14.871]  length: 1
[13:35:14.871]  elements: ‘...’
[13:35:14.871]  length: 0 (resolved future 1)
[13:35:14.871] resolve() on list ... DONE
[13:35:14.871]    - '...' content: [n=0] 
[13:35:14.871] List of 1
[13:35:14.871]  $ ...: list()
[13:35:14.871]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:14.871]  - attr(*, "where")=List of 1
[13:35:14.871]   ..$ ...:<environment: 0x5574d16bf218> 
[13:35:14.871]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:14.871]  - attr(*, "resolved")= logi TRUE
[13:35:14.871]  - attr(*, "total_size")= num NA
[13:35:14.874]  - Getting '...' globals ... DONE
[13:35:14.874] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[13:35:14.874] List of 8
[13:35:14.874]  $ ...future.FUN:function (x, ...)  
[13:35:14.874]  $ x_FUN        :function (x)  
[13:35:14.874]  $ times        : int 2
[13:35:14.874]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[13:35:14.874]  $ stop_if_not  :function (...)  
[13:35:14.874]  $ dim          : NULL
[13:35:14.874]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[13:35:14.874]  $ ...          : list()
[13:35:14.874]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[13:35:14.874]  - attr(*, "where")=List of 8
[13:35:14.874]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[13:35:14.874]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[13:35:14.874]   ..$ times        :<environment: R_EmptyEnv> 
[13:35:14.874]   ..$ stopf        :<environment: R_EmptyEnv> 
[13:35:14.874]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[13:35:14.874]   ..$ dim          :<environment: R_EmptyEnv> 
[13:35:14.874]   ..$ valid_types  :<environment: R_EmptyEnv> 
[13:35:14.874]   ..$ ...          :<environment: 0x5574d16bf218> 
[13:35:14.874]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[13:35:14.874]  - attr(*, "resolved")= logi FALSE
[13:35:14.874]  - attr(*, "total_size")= num 95128
[13:35:14.879] Packages to be attached in all futures: [n=1] ‘future.apply’
[13:35:14.879] getGlobalsAndPackagesXApply() ... DONE
[13:35:14.880] Number of futures (= number of chunks): 2
[13:35:14.880] Launching 2 futures (chunks) ...
[13:35:14.880] Chunk #1 of 2 ...
[13:35:14.880]  - Finding globals in 'X' for chunk #1 ...
[13:35:14.880] getGlobalsAndPackages() ...
[13:35:14.880] Searching for globals...
[13:35:14.880] 
[13:35:14.880] Searching for globals ... DONE
[13:35:14.881] - globals: [0] <none>
[13:35:14.881] getGlobalsAndPackages() ... DONE
[13:35:14.881]    + additional globals found: [n=0] 
[13:35:14.881]    + additional namespaces needed: [n=0] 
[13:35:14.881]  - Finding globals in 'X' for chunk #1 ... DONE
[13:35:14.881]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:14.881]  - seeds: <none>
[13:35:14.881]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.881] getGlobalsAndPackages() ...
[13:35:14.881] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.881] Resolving globals: FALSE
[13:35:14.882] Tweak future expression to call with '...' arguments ...
[13:35:14.882] {
[13:35:14.882]     do.call(function(...) {
[13:35:14.882]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.882]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:14.882]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.882]             on.exit(options(oopts), add = TRUE)
[13:35:14.882]         }
[13:35:14.882]         {
[13:35:14.882]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:14.882]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.882]                 ...future.FUN(...future.X_jj, ...)
[13:35:14.882]             })
[13:35:14.882]         }
[13:35:14.882]     }, args = future.call.arguments)
[13:35:14.882] }
[13:35:14.882] Tweak future expression to call with '...' arguments ... DONE
[13:35:14.882] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:14.883] - packages: [1] ‘future.apply’
[13:35:14.883] getGlobalsAndPackages() ... DONE
[13:35:14.883] run() for ‘Future’ ...
[13:35:14.883] - state: ‘created’
[13:35:14.883] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:14.897] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:14.897] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:14.897]   - Field: ‘node’
[13:35:14.897]   - Field: ‘label’
[13:35:14.897]   - Field: ‘local’
[13:35:14.897]   - Field: ‘owner’
[13:35:14.897]   - Field: ‘envir’
[13:35:14.897]   - Field: ‘workers’
[13:35:14.897]   - Field: ‘packages’
[13:35:14.898]   - Field: ‘gc’
[13:35:14.898]   - Field: ‘conditions’
[13:35:14.898]   - Field: ‘persistent’
[13:35:14.898]   - Field: ‘expr’
[13:35:14.898]   - Field: ‘uuid’
[13:35:14.898]   - Field: ‘seed’
[13:35:14.898]   - Field: ‘version’
[13:35:14.898]   - Field: ‘result’
[13:35:14.898]   - Field: ‘asynchronous’
[13:35:14.898]   - Field: ‘calls’
[13:35:14.898]   - Field: ‘globals’
[13:35:14.899]   - Field: ‘stdout’
[13:35:14.899]   - Field: ‘earlySignal’
[13:35:14.899]   - Field: ‘lazy’
[13:35:14.899]   - Field: ‘state’
[13:35:14.899] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:14.899] - Launch lazy future ...
[13:35:14.899] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:14.899] Packages needed by future strategies (n = 0): <none>
[13:35:14.900] {
[13:35:14.900]     {
[13:35:14.900]         {
[13:35:14.900]             ...future.startTime <- base::Sys.time()
[13:35:14.900]             {
[13:35:14.900]                 {
[13:35:14.900]                   {
[13:35:14.900]                     {
[13:35:14.900]                       {
[13:35:14.900]                         base::local({
[13:35:14.900]                           has_future <- base::requireNamespace("future", 
[13:35:14.900]                             quietly = TRUE)
[13:35:14.900]                           if (has_future) {
[13:35:14.900]                             ns <- base::getNamespace("future")
[13:35:14.900]                             version <- ns[[".package"]][["version"]]
[13:35:14.900]                             if (is.null(version)) 
[13:35:14.900]                               version <- utils::packageVersion("future")
[13:35:14.900]                           }
[13:35:14.900]                           else {
[13:35:14.900]                             version <- NULL
[13:35:14.900]                           }
[13:35:14.900]                           if (!has_future || version < "1.8.0") {
[13:35:14.900]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:14.900]                               "", base::R.version$version.string), 
[13:35:14.900]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:14.900]                                 base::R.version$platform, 8 * 
[13:35:14.900]                                   base::.Machine$sizeof.pointer), 
[13:35:14.900]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:14.900]                                 "release", "version")], collapse = " "), 
[13:35:14.900]                               hostname = base::Sys.info()[["nodename"]])
[13:35:14.900]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:14.900]                               info)
[13:35:14.900]                             info <- base::paste(info, collapse = "; ")
[13:35:14.900]                             if (!has_future) {
[13:35:14.900]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:14.900]                                 info)
[13:35:14.900]                             }
[13:35:14.900]                             else {
[13:35:14.900]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:14.900]                                 info, version)
[13:35:14.900]                             }
[13:35:14.900]                             base::stop(msg)
[13:35:14.900]                           }
[13:35:14.900]                         })
[13:35:14.900]                       }
[13:35:14.900]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:14.900]                       base::options(mc.cores = 1L)
[13:35:14.900]                     }
[13:35:14.900]                     base::local({
[13:35:14.900]                       for (pkg in "future.apply") {
[13:35:14.900]                         base::loadNamespace(pkg)
[13:35:14.900]                         base::library(pkg, character.only = TRUE)
[13:35:14.900]                       }
[13:35:14.900]                     })
[13:35:14.900]                   }
[13:35:14.900]                   ...future.strategy.old <- future::plan("list")
[13:35:14.900]                   options(future.plan = NULL)
[13:35:14.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:14.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:14.900]                 }
[13:35:14.900]                 ...future.workdir <- getwd()
[13:35:14.900]             }
[13:35:14.900]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:14.900]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:14.900]         }
[13:35:14.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:14.900]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:14.900]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:14.900]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:14.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:14.900]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:14.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:14.900]             base::names(...future.oldOptions))
[13:35:14.900]     }
[13:35:14.900]     if (FALSE) {
[13:35:14.900]     }
[13:35:14.900]     else {
[13:35:14.900]         if (TRUE) {
[13:35:14.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:14.900]                 open = "w")
[13:35:14.900]         }
[13:35:14.900]         else {
[13:35:14.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:14.900]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:14.900]         }
[13:35:14.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:14.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:14.900]             base::sink(type = "output", split = FALSE)
[13:35:14.900]             base::close(...future.stdout)
[13:35:14.900]         }, add = TRUE)
[13:35:14.900]     }
[13:35:14.900]     ...future.frame <- base::sys.nframe()
[13:35:14.900]     ...future.conditions <- base::list()
[13:35:14.900]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:14.900]     if (FALSE) {
[13:35:14.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:14.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:14.900]     }
[13:35:14.900]     ...future.result <- base::tryCatch({
[13:35:14.900]         base::withCallingHandlers({
[13:35:14.900]             ...future.value <- base::withVisible(base::local({
[13:35:14.900]                 ...future.makeSendCondition <- base::local({
[13:35:14.900]                   sendCondition <- NULL
[13:35:14.900]                   function(frame = 1L) {
[13:35:14.900]                     if (is.function(sendCondition)) 
[13:35:14.900]                       return(sendCondition)
[13:35:14.900]                     ns <- getNamespace("parallel")
[13:35:14.900]                     if (exists("sendData", mode = "function", 
[13:35:14.900]                       envir = ns)) {
[13:35:14.900]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:14.900]                         envir = ns)
[13:35:14.900]                       envir <- sys.frame(frame)
[13:35:14.900]                       master <- NULL
[13:35:14.900]                       while (!identical(envir, .GlobalEnv) && 
[13:35:14.900]                         !identical(envir, emptyenv())) {
[13:35:14.900]                         if (exists("master", mode = "list", envir = envir, 
[13:35:14.900]                           inherits = FALSE)) {
[13:35:14.900]                           master <- get("master", mode = "list", 
[13:35:14.900]                             envir = envir, inherits = FALSE)
[13:35:14.900]                           if (inherits(master, c("SOCKnode", 
[13:35:14.900]                             "SOCK0node"))) {
[13:35:14.900]                             sendCondition <<- function(cond) {
[13:35:14.900]                               data <- list(type = "VALUE", value = cond, 
[13:35:14.900]                                 success = TRUE)
[13:35:14.900]                               parallel_sendData(master, data)
[13:35:14.900]                             }
[13:35:14.900]                             return(sendCondition)
[13:35:14.900]                           }
[13:35:14.900]                         }
[13:35:14.900]                         frame <- frame + 1L
[13:35:14.900]                         envir <- sys.frame(frame)
[13:35:14.900]                       }
[13:35:14.900]                     }
[13:35:14.900]                     sendCondition <<- function(cond) NULL
[13:35:14.900]                   }
[13:35:14.900]                 })
[13:35:14.900]                 withCallingHandlers({
[13:35:14.900]                   {
[13:35:14.900]                     do.call(function(...) {
[13:35:14.900]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:14.900]                       if (!identical(...future.globals.maxSize.org, 
[13:35:14.900]                         ...future.globals.maxSize)) {
[13:35:14.900]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:14.900]                         on.exit(options(oopts), add = TRUE)
[13:35:14.900]                       }
[13:35:14.900]                       {
[13:35:14.900]                         lapply(seq_along(...future.elements_ii), 
[13:35:14.900]                           FUN = function(jj) {
[13:35:14.900]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:14.900]                             ...future.FUN(...future.X_jj, ...)
[13:35:14.900]                           })
[13:35:14.900]                       }
[13:35:14.900]                     }, args = future.call.arguments)
[13:35:14.900]                   }
[13:35:14.900]                 }, immediateCondition = function(cond) {
[13:35:14.900]                   sendCondition <- ...future.makeSendCondition()
[13:35:14.900]                   sendCondition(cond)
[13:35:14.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.900]                   {
[13:35:14.900]                     inherits <- base::inherits
[13:35:14.900]                     invokeRestart <- base::invokeRestart
[13:35:14.900]                     is.null <- base::is.null
[13:35:14.900]                     muffled <- FALSE
[13:35:14.900]                     if (inherits(cond, "message")) {
[13:35:14.900]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:14.900]                       if (muffled) 
[13:35:14.900]                         invokeRestart("muffleMessage")
[13:35:14.900]                     }
[13:35:14.900]                     else if (inherits(cond, "warning")) {
[13:35:14.900]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:14.900]                       if (muffled) 
[13:35:14.900]                         invokeRestart("muffleWarning")
[13:35:14.900]                     }
[13:35:14.900]                     else if (inherits(cond, "condition")) {
[13:35:14.900]                       if (!is.null(pattern)) {
[13:35:14.900]                         computeRestarts <- base::computeRestarts
[13:35:14.900]                         grepl <- base::grepl
[13:35:14.900]                         restarts <- computeRestarts(cond)
[13:35:14.900]                         for (restart in restarts) {
[13:35:14.900]                           name <- restart$name
[13:35:14.900]                           if (is.null(name)) 
[13:35:14.900]                             next
[13:35:14.900]                           if (!grepl(pattern, name)) 
[13:35:14.900]                             next
[13:35:14.900]                           invokeRestart(restart)
[13:35:14.900]                           muffled <- TRUE
[13:35:14.900]                           break
[13:35:14.900]                         }
[13:35:14.900]                       }
[13:35:14.900]                     }
[13:35:14.900]                     invisible(muffled)
[13:35:14.900]                   }
[13:35:14.900]                   muffleCondition(cond)
[13:35:14.900]                 })
[13:35:14.900]             }))
[13:35:14.900]             future::FutureResult(value = ...future.value$value, 
[13:35:14.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:14.900]                   ...future.rng), globalenv = if (FALSE) 
[13:35:14.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:14.900]                     ...future.globalenv.names))
[13:35:14.900]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:14.900]         }, condition = base::local({
[13:35:14.900]             c <- base::c
[13:35:14.900]             inherits <- base::inherits
[13:35:14.900]             invokeRestart <- base::invokeRestart
[13:35:14.900]             length <- base::length
[13:35:14.900]             list <- base::list
[13:35:14.900]             seq.int <- base::seq.int
[13:35:14.900]             signalCondition <- base::signalCondition
[13:35:14.900]             sys.calls <- base::sys.calls
[13:35:14.900]             `[[` <- base::`[[`
[13:35:14.900]             `+` <- base::`+`
[13:35:14.900]             `<<-` <- base::`<<-`
[13:35:14.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:14.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:14.900]                   3L)]
[13:35:14.900]             }
[13:35:14.900]             function(cond) {
[13:35:14.900]                 is_error <- inherits(cond, "error")
[13:35:14.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:14.900]                   NULL)
[13:35:14.900]                 if (is_error) {
[13:35:14.900]                   sessionInformation <- function() {
[13:35:14.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:14.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:14.900]                       search = base::search(), system = base::Sys.info())
[13:35:14.900]                   }
[13:35:14.900]                   ...future.conditions[[length(...future.conditions) + 
[13:35:14.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:14.900]                     cond$call), session = sessionInformation(), 
[13:35:14.900]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:14.900]                   signalCondition(cond)
[13:35:14.900]                 }
[13:35:14.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:14.900]                 "immediateCondition"))) {
[13:35:14.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:14.900]                   ...future.conditions[[length(...future.conditions) + 
[13:35:14.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:14.900]                   if (TRUE && !signal) {
[13:35:14.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.900]                     {
[13:35:14.900]                       inherits <- base::inherits
[13:35:14.900]                       invokeRestart <- base::invokeRestart
[13:35:14.900]                       is.null <- base::is.null
[13:35:14.900]                       muffled <- FALSE
[13:35:14.900]                       if (inherits(cond, "message")) {
[13:35:14.900]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:14.900]                         if (muffled) 
[13:35:14.900]                           invokeRestart("muffleMessage")
[13:35:14.900]                       }
[13:35:14.900]                       else if (inherits(cond, "warning")) {
[13:35:14.900]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:14.900]                         if (muffled) 
[13:35:14.900]                           invokeRestart("muffleWarning")
[13:35:14.900]                       }
[13:35:14.900]                       else if (inherits(cond, "condition")) {
[13:35:14.900]                         if (!is.null(pattern)) {
[13:35:14.900]                           computeRestarts <- base::computeRestarts
[13:35:14.900]                           grepl <- base::grepl
[13:35:14.900]                           restarts <- computeRestarts(cond)
[13:35:14.900]                           for (restart in restarts) {
[13:35:14.900]                             name <- restart$name
[13:35:14.900]                             if (is.null(name)) 
[13:35:14.900]                               next
[13:35:14.900]                             if (!grepl(pattern, name)) 
[13:35:14.900]                               next
[13:35:14.900]                             invokeRestart(restart)
[13:35:14.900]                             muffled <- TRUE
[13:35:14.900]                             break
[13:35:14.900]                           }
[13:35:14.900]                         }
[13:35:14.900]                       }
[13:35:14.900]                       invisible(muffled)
[13:35:14.900]                     }
[13:35:14.900]                     muffleCondition(cond, pattern = "^muffle")
[13:35:14.900]                   }
[13:35:14.900]                 }
[13:35:14.900]                 else {
[13:35:14.900]                   if (TRUE) {
[13:35:14.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:14.900]                     {
[13:35:14.900]                       inherits <- base::inherits
[13:35:14.900]                       invokeRestart <- base::invokeRestart
[13:35:14.900]                       is.null <- base::is.null
[13:35:14.900]                       muffled <- FALSE
[13:35:14.900]                       if (inherits(cond, "message")) {
[13:35:14.900]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:14.900]                         if (muffled) 
[13:35:14.900]                           invokeRestart("muffleMessage")
[13:35:14.900]                       }
[13:35:14.900]                       else if (inherits(cond, "warning")) {
[13:35:14.900]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:14.900]                         if (muffled) 
[13:35:14.900]                           invokeRestart("muffleWarning")
[13:35:14.900]                       }
[13:35:14.900]                       else if (inherits(cond, "condition")) {
[13:35:14.900]                         if (!is.null(pattern)) {
[13:35:14.900]                           computeRestarts <- base::computeRestarts
[13:35:14.900]                           grepl <- base::grepl
[13:35:14.900]                           restarts <- computeRestarts(cond)
[13:35:14.900]                           for (restart in restarts) {
[13:35:14.900]                             name <- restart$name
[13:35:14.900]                             if (is.null(name)) 
[13:35:14.900]                               next
[13:35:14.900]                             if (!grepl(pattern, name)) 
[13:35:14.900]                               next
[13:35:14.900]                             invokeRestart(restart)
[13:35:14.900]                             muffled <- TRUE
[13:35:14.900]                             break
[13:35:14.900]                           }
[13:35:14.900]                         }
[13:35:14.900]                       }
[13:35:14.900]                       invisible(muffled)
[13:35:14.900]                     }
[13:35:14.900]                     muffleCondition(cond, pattern = "^muffle")
[13:35:14.900]                   }
[13:35:14.900]                 }
[13:35:14.900]             }
[13:35:14.900]         }))
[13:35:14.900]     }, error = function(ex) {
[13:35:14.900]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:14.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:14.900]                 ...future.rng), started = ...future.startTime, 
[13:35:14.900]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:14.900]             version = "1.8"), class = "FutureResult")
[13:35:14.900]     }, finally = {
[13:35:14.900]         if (!identical(...future.workdir, getwd())) 
[13:35:14.900]             setwd(...future.workdir)
[13:35:14.900]         {
[13:35:14.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:14.900]                 ...future.oldOptions$nwarnings <- NULL
[13:35:14.900]             }
[13:35:14.900]             base::options(...future.oldOptions)
[13:35:14.900]             if (.Platform$OS.type == "windows") {
[13:35:14.900]                 old_names <- names(...future.oldEnvVars)
[13:35:14.900]                 envs <- base::Sys.getenv()
[13:35:14.900]                 names <- names(envs)
[13:35:14.900]                 common <- intersect(names, old_names)
[13:35:14.900]                 added <- setdiff(names, old_names)
[13:35:14.900]                 removed <- setdiff(old_names, names)
[13:35:14.900]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:14.900]                   envs[common]]
[13:35:14.900]                 NAMES <- toupper(changed)
[13:35:14.900]                 args <- list()
[13:35:14.900]                 for (kk in seq_along(NAMES)) {
[13:35:14.900]                   name <- changed[[kk]]
[13:35:14.900]                   NAME <- NAMES[[kk]]
[13:35:14.900]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.900]                     next
[13:35:14.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:14.900]                 }
[13:35:14.900]                 NAMES <- toupper(added)
[13:35:14.900]                 for (kk in seq_along(NAMES)) {
[13:35:14.900]                   name <- added[[kk]]
[13:35:14.900]                   NAME <- NAMES[[kk]]
[13:35:14.900]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.900]                     next
[13:35:14.900]                   args[[name]] <- ""
[13:35:14.900]                 }
[13:35:14.900]                 NAMES <- toupper(removed)
[13:35:14.900]                 for (kk in seq_along(NAMES)) {
[13:35:14.900]                   name <- removed[[kk]]
[13:35:14.900]                   NAME <- NAMES[[kk]]
[13:35:14.900]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:14.900]                     next
[13:35:14.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:14.900]                 }
[13:35:14.900]                 if (length(args) > 0) 
[13:35:14.900]                   base::do.call(base::Sys.setenv, args = args)
[13:35:14.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:14.900]             }
[13:35:14.900]             else {
[13:35:14.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:14.900]             }
[13:35:14.900]             {
[13:35:14.900]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:14.900]                   0L) {
[13:35:14.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:14.900]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:14.900]                   base::options(opts)
[13:35:14.900]                 }
[13:35:14.900]                 {
[13:35:14.900]                   {
[13:35:14.900]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:14.900]                     NULL
[13:35:14.900]                   }
[13:35:14.900]                   options(future.plan = NULL)
[13:35:14.900]                   if (is.na(NA_character_)) 
[13:35:14.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:14.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:14.900]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:14.900]                     .init = FALSE)
[13:35:14.900]                 }
[13:35:14.900]             }
[13:35:14.900]         }
[13:35:14.900]     })
[13:35:14.900]     if (TRUE) {
[13:35:14.900]         base::sink(type = "output", split = FALSE)
[13:35:14.900]         if (TRUE) {
[13:35:14.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:14.900]         }
[13:35:14.900]         else {
[13:35:14.900]             ...future.result["stdout"] <- base::list(NULL)
[13:35:14.900]         }
[13:35:14.900]         base::close(...future.stdout)
[13:35:14.900]         ...future.stdout <- NULL
[13:35:14.900]     }
[13:35:14.900]     ...future.result$conditions <- ...future.conditions
[13:35:14.900]     ...future.result$finished <- base::Sys.time()
[13:35:14.900]     ...future.result
[13:35:14.900] }
[13:35:14.903] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[13:35:14.903] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:14.946] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:14.947] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[13:35:14.947] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[13:35:14.947] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:14.948] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:14.948] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:14.990] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:14.991] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:15.034] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:15.035] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:15.035] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:15.035] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:15.036] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:15.036] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:15.036] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:15.036] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[13:35:15.037] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[13:35:15.037] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:15.037] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:15.037] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:15.038] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:15.038] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[13:35:15.038] MultisessionFuture started
[13:35:15.038] - Launch lazy future ... done
[13:35:15.039] run() for ‘MultisessionFuture’ ... done
[13:35:15.039] Created future:
[13:35:15.040] receiveMessageFromWorker() for ClusterFuture ...
[13:35:15.041] - Validating connection of MultisessionFuture
[13:35:15.041] - received message: FutureResult
[13:35:15.041] - Received FutureResult
[13:35:15.041] - Erased future from FutureRegistry
[13:35:15.041] result() for ClusterFuture ...
[13:35:15.041] - result already collected: FutureResult
[13:35:15.042] result() for ClusterFuture ... done
[13:35:15.042] signalConditions() ...
[13:35:15.042]  - include = ‘immediateCondition’
[13:35:15.042]  - exclude = 
[13:35:15.042]  - resignal = FALSE
[13:35:15.042]  - Number of conditions: 1
[13:35:15.042] signalConditions() ... done
[13:35:15.042] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:15.039] MultisessionFuture:
[13:35:15.039] Label: ‘future_vapply-1’
[13:35:15.039] Expression:
[13:35:15.039] {
[13:35:15.039]     do.call(function(...) {
[13:35:15.039]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:15.039]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:15.039]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:15.039]             on.exit(options(oopts), add = TRUE)
[13:35:15.039]         }
[13:35:15.039]         {
[13:35:15.039]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:15.039]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:15.039]                 ...future.FUN(...future.X_jj, ...)
[13:35:15.039]             })
[13:35:15.039]         }
[13:35:15.039]     }, args = future.call.arguments)
[13:35:15.039] }
[13:35:15.039] Lazy evaluation: FALSE
[13:35:15.039] Asynchronous evaluation: TRUE
[13:35:15.039] Local evaluation: TRUE
[13:35:15.039] Environment: R_GlobalEnv
[13:35:15.039] Capture standard output: TRUE
[13:35:15.039] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:15.039] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:15.039] Packages: 1 packages (‘future.apply’)
[13:35:15.039] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:15.039] Resolved: TRUE
[13:35:15.039] Value: <not collected>
[13:35:15.039] Conditions captured: <none>
[13:35:15.039] Early signaling: FALSE
[13:35:15.039] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:15.039] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:15.042] Chunk #1 of 2 ... DONE
[13:35:15.043] Chunk #2 of 2 ...
[13:35:15.043]  - Finding globals in 'X' for chunk #2 ...
[13:35:15.043] getGlobalsAndPackages() ...
[13:35:15.043] Searching for globals...
[13:35:15.043] 
[13:35:15.043] Searching for globals ... DONE
[13:35:15.043] - globals: [0] <none>
[13:35:15.043] getGlobalsAndPackages() ... DONE
[13:35:15.043]    + additional globals found: [n=0] 
[13:35:15.044]    + additional namespaces needed: [n=0] 
[13:35:15.044]  - Finding globals in 'X' for chunk #2 ... DONE
[13:35:15.044]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[13:35:15.044]  - seeds: <none>
[13:35:15.044]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:15.044] getGlobalsAndPackages() ...
[13:35:15.044] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:15.044] Resolving globals: FALSE
[13:35:15.044] Tweak future expression to call with '...' arguments ...
[13:35:15.044] {
[13:35:15.044]     do.call(function(...) {
[13:35:15.044]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:15.044]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:15.044]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:15.044]             on.exit(options(oopts), add = TRUE)
[13:35:15.044]         }
[13:35:15.044]         {
[13:35:15.044]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:15.044]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:15.044]                 ...future.FUN(...future.X_jj, ...)
[13:35:15.044]             })
[13:35:15.044]         }
[13:35:15.044]     }, args = future.call.arguments)
[13:35:15.044] }
[13:35:15.045] Tweak future expression to call with '...' arguments ... DONE
[13:35:15.045] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[13:35:15.045] - packages: [1] ‘future.apply’
[13:35:15.045] getGlobalsAndPackages() ... DONE
[13:35:15.046] run() for ‘Future’ ...
[13:35:15.046] - state: ‘created’
[13:35:15.046] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[13:35:15.059] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:15.059] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[13:35:15.060]   - Field: ‘node’
[13:35:15.060]   - Field: ‘label’
[13:35:15.060]   - Field: ‘local’
[13:35:15.060]   - Field: ‘owner’
[13:35:15.060]   - Field: ‘envir’
[13:35:15.060]   - Field: ‘workers’
[13:35:15.060]   - Field: ‘packages’
[13:35:15.060]   - Field: ‘gc’
[13:35:15.060]   - Field: ‘conditions’
[13:35:15.060]   - Field: ‘persistent’
[13:35:15.060]   - Field: ‘expr’
[13:35:15.061]   - Field: ‘uuid’
[13:35:15.061]   - Field: ‘seed’
[13:35:15.061]   - Field: ‘version’
[13:35:15.061]   - Field: ‘result’
[13:35:15.061]   - Field: ‘asynchronous’
[13:35:15.061]   - Field: ‘calls’
[13:35:15.061]   - Field: ‘globals’
[13:35:15.061]   - Field: ‘stdout’
[13:35:15.061]   - Field: ‘earlySignal’
[13:35:15.061]   - Field: ‘lazy’
[13:35:15.061]   - Field: ‘state’
[13:35:15.062] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[13:35:15.062] - Launch lazy future ...
[13:35:15.062] Packages needed by the future expression (n = 1): ‘future.apply’
[13:35:15.062] Packages needed by future strategies (n = 0): <none>
[13:35:15.063] {
[13:35:15.063]     {
[13:35:15.063]         {
[13:35:15.063]             ...future.startTime <- base::Sys.time()
[13:35:15.063]             {
[13:35:15.063]                 {
[13:35:15.063]                   {
[13:35:15.063]                     {
[13:35:15.063]                       {
[13:35:15.063]                         base::local({
[13:35:15.063]                           has_future <- base::requireNamespace("future", 
[13:35:15.063]                             quietly = TRUE)
[13:35:15.063]                           if (has_future) {
[13:35:15.063]                             ns <- base::getNamespace("future")
[13:35:15.063]                             version <- ns[[".package"]][["version"]]
[13:35:15.063]                             if (is.null(version)) 
[13:35:15.063]                               version <- utils::packageVersion("future")
[13:35:15.063]                           }
[13:35:15.063]                           else {
[13:35:15.063]                             version <- NULL
[13:35:15.063]                           }
[13:35:15.063]                           if (!has_future || version < "1.8.0") {
[13:35:15.063]                             info <- base::c(r_version = base::gsub("R version ", 
[13:35:15.063]                               "", base::R.version$version.string), 
[13:35:15.063]                               platform = base::sprintf("%s (%s-bit)", 
[13:35:15.063]                                 base::R.version$platform, 8 * 
[13:35:15.063]                                   base::.Machine$sizeof.pointer), 
[13:35:15.063]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[13:35:15.063]                                 "release", "version")], collapse = " "), 
[13:35:15.063]                               hostname = base::Sys.info()[["nodename"]])
[13:35:15.063]                             info <- base::sprintf("%s: %s", base::names(info), 
[13:35:15.063]                               info)
[13:35:15.063]                             info <- base::paste(info, collapse = "; ")
[13:35:15.063]                             if (!has_future) {
[13:35:15.063]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[13:35:15.063]                                 info)
[13:35:15.063]                             }
[13:35:15.063]                             else {
[13:35:15.063]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[13:35:15.063]                                 info, version)
[13:35:15.063]                             }
[13:35:15.063]                             base::stop(msg)
[13:35:15.063]                           }
[13:35:15.063]                         })
[13:35:15.063]                       }
[13:35:15.063]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[13:35:15.063]                       base::options(mc.cores = 1L)
[13:35:15.063]                     }
[13:35:15.063]                     base::local({
[13:35:15.063]                       for (pkg in "future.apply") {
[13:35:15.063]                         base::loadNamespace(pkg)
[13:35:15.063]                         base::library(pkg, character.only = TRUE)
[13:35:15.063]                       }
[13:35:15.063]                     })
[13:35:15.063]                   }
[13:35:15.063]                   ...future.strategy.old <- future::plan("list")
[13:35:15.063]                   options(future.plan = NULL)
[13:35:15.063]                   Sys.unsetenv("R_FUTURE_PLAN")
[13:35:15.063]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[13:35:15.063]                 }
[13:35:15.063]                 ...future.workdir <- getwd()
[13:35:15.063]             }
[13:35:15.063]             ...future.oldOptions <- base::as.list(base::.Options)
[13:35:15.063]             ...future.oldEnvVars <- base::Sys.getenv()
[13:35:15.063]         }
[13:35:15.063]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[13:35:15.063]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[13:35:15.063]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[13:35:15.063]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[13:35:15.063]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[13:35:15.063]             future.stdout.windows.reencode = NULL, width = 80L)
[13:35:15.063]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[13:35:15.063]             base::names(...future.oldOptions))
[13:35:15.063]     }
[13:35:15.063]     if (FALSE) {
[13:35:15.063]     }
[13:35:15.063]     else {
[13:35:15.063]         if (TRUE) {
[13:35:15.063]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[13:35:15.063]                 open = "w")
[13:35:15.063]         }
[13:35:15.063]         else {
[13:35:15.063]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[13:35:15.063]                 windows = "NUL", "/dev/null"), open = "w")
[13:35:15.063]         }
[13:35:15.063]         base::sink(...future.stdout, type = "output", split = FALSE)
[13:35:15.063]         base::on.exit(if (!base::is.null(...future.stdout)) {
[13:35:15.063]             base::sink(type = "output", split = FALSE)
[13:35:15.063]             base::close(...future.stdout)
[13:35:15.063]         }, add = TRUE)
[13:35:15.063]     }
[13:35:15.063]     ...future.frame <- base::sys.nframe()
[13:35:15.063]     ...future.conditions <- base::list()
[13:35:15.063]     ...future.rng <- base::globalenv()$.Random.seed
[13:35:15.063]     if (FALSE) {
[13:35:15.063]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[13:35:15.063]             "...future.value", "...future.globalenv.names", ".Random.seed")
[13:35:15.063]     }
[13:35:15.063]     ...future.result <- base::tryCatch({
[13:35:15.063]         base::withCallingHandlers({
[13:35:15.063]             ...future.value <- base::withVisible(base::local({
[13:35:15.063]                 ...future.makeSendCondition <- base::local({
[13:35:15.063]                   sendCondition <- NULL
[13:35:15.063]                   function(frame = 1L) {
[13:35:15.063]                     if (is.function(sendCondition)) 
[13:35:15.063]                       return(sendCondition)
[13:35:15.063]                     ns <- getNamespace("parallel")
[13:35:15.063]                     if (exists("sendData", mode = "function", 
[13:35:15.063]                       envir = ns)) {
[13:35:15.063]                       parallel_sendData <- get("sendData", mode = "function", 
[13:35:15.063]                         envir = ns)
[13:35:15.063]                       envir <- sys.frame(frame)
[13:35:15.063]                       master <- NULL
[13:35:15.063]                       while (!identical(envir, .GlobalEnv) && 
[13:35:15.063]                         !identical(envir, emptyenv())) {
[13:35:15.063]                         if (exists("master", mode = "list", envir = envir, 
[13:35:15.063]                           inherits = FALSE)) {
[13:35:15.063]                           master <- get("master", mode = "list", 
[13:35:15.063]                             envir = envir, inherits = FALSE)
[13:35:15.063]                           if (inherits(master, c("SOCKnode", 
[13:35:15.063]                             "SOCK0node"))) {
[13:35:15.063]                             sendCondition <<- function(cond) {
[13:35:15.063]                               data <- list(type = "VALUE", value = cond, 
[13:35:15.063]                                 success = TRUE)
[13:35:15.063]                               parallel_sendData(master, data)
[13:35:15.063]                             }
[13:35:15.063]                             return(sendCondition)
[13:35:15.063]                           }
[13:35:15.063]                         }
[13:35:15.063]                         frame <- frame + 1L
[13:35:15.063]                         envir <- sys.frame(frame)
[13:35:15.063]                       }
[13:35:15.063]                     }
[13:35:15.063]                     sendCondition <<- function(cond) NULL
[13:35:15.063]                   }
[13:35:15.063]                 })
[13:35:15.063]                 withCallingHandlers({
[13:35:15.063]                   {
[13:35:15.063]                     do.call(function(...) {
[13:35:15.063]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:15.063]                       if (!identical(...future.globals.maxSize.org, 
[13:35:15.063]                         ...future.globals.maxSize)) {
[13:35:15.063]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:15.063]                         on.exit(options(oopts), add = TRUE)
[13:35:15.063]                       }
[13:35:15.063]                       {
[13:35:15.063]                         lapply(seq_along(...future.elements_ii), 
[13:35:15.063]                           FUN = function(jj) {
[13:35:15.063]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:15.063]                             ...future.FUN(...future.X_jj, ...)
[13:35:15.063]                           })
[13:35:15.063]                       }
[13:35:15.063]                     }, args = future.call.arguments)
[13:35:15.063]                   }
[13:35:15.063]                 }, immediateCondition = function(cond) {
[13:35:15.063]                   sendCondition <- ...future.makeSendCondition()
[13:35:15.063]                   sendCondition(cond)
[13:35:15.063]                   muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:15.063]                   {
[13:35:15.063]                     inherits <- base::inherits
[13:35:15.063]                     invokeRestart <- base::invokeRestart
[13:35:15.063]                     is.null <- base::is.null
[13:35:15.063]                     muffled <- FALSE
[13:35:15.063]                     if (inherits(cond, "message")) {
[13:35:15.063]                       muffled <- grepl(pattern, "muffleMessage")
[13:35:15.063]                       if (muffled) 
[13:35:15.063]                         invokeRestart("muffleMessage")
[13:35:15.063]                     }
[13:35:15.063]                     else if (inherits(cond, "warning")) {
[13:35:15.063]                       muffled <- grepl(pattern, "muffleWarning")
[13:35:15.063]                       if (muffled) 
[13:35:15.063]                         invokeRestart("muffleWarning")
[13:35:15.063]                     }
[13:35:15.063]                     else if (inherits(cond, "condition")) {
[13:35:15.063]                       if (!is.null(pattern)) {
[13:35:15.063]                         computeRestarts <- base::computeRestarts
[13:35:15.063]                         grepl <- base::grepl
[13:35:15.063]                         restarts <- computeRestarts(cond)
[13:35:15.063]                         for (restart in restarts) {
[13:35:15.063]                           name <- restart$name
[13:35:15.063]                           if (is.null(name)) 
[13:35:15.063]                             next
[13:35:15.063]                           if (!grepl(pattern, name)) 
[13:35:15.063]                             next
[13:35:15.063]                           invokeRestart(restart)
[13:35:15.063]                           muffled <- TRUE
[13:35:15.063]                           break
[13:35:15.063]                         }
[13:35:15.063]                       }
[13:35:15.063]                     }
[13:35:15.063]                     invisible(muffled)
[13:35:15.063]                   }
[13:35:15.063]                   muffleCondition(cond)
[13:35:15.063]                 })
[13:35:15.063]             }))
[13:35:15.063]             future::FutureResult(value = ...future.value$value, 
[13:35:15.063]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:15.063]                   ...future.rng), globalenv = if (FALSE) 
[13:35:15.063]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[13:35:15.063]                     ...future.globalenv.names))
[13:35:15.063]                 else NULL, started = ...future.startTime, version = "1.8")
[13:35:15.063]         }, condition = base::local({
[13:35:15.063]             c <- base::c
[13:35:15.063]             inherits <- base::inherits
[13:35:15.063]             invokeRestart <- base::invokeRestart
[13:35:15.063]             length <- base::length
[13:35:15.063]             list <- base::list
[13:35:15.063]             seq.int <- base::seq.int
[13:35:15.063]             signalCondition <- base::signalCondition
[13:35:15.063]             sys.calls <- base::sys.calls
[13:35:15.063]             `[[` <- base::`[[`
[13:35:15.063]             `+` <- base::`+`
[13:35:15.063]             `<<-` <- base::`<<-`
[13:35:15.063]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[13:35:15.063]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[13:35:15.063]                   3L)]
[13:35:15.063]             }
[13:35:15.063]             function(cond) {
[13:35:15.063]                 is_error <- inherits(cond, "error")
[13:35:15.063]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[13:35:15.063]                   NULL)
[13:35:15.063]                 if (is_error) {
[13:35:15.063]                   sessionInformation <- function() {
[13:35:15.063]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[13:35:15.063]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[13:35:15.063]                       search = base::search(), system = base::Sys.info())
[13:35:15.063]                   }
[13:35:15.063]                   ...future.conditions[[length(...future.conditions) + 
[13:35:15.063]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[13:35:15.063]                     cond$call), session = sessionInformation(), 
[13:35:15.063]                     timestamp = base::Sys.time(), signaled = 0L)
[13:35:15.063]                   signalCondition(cond)
[13:35:15.063]                 }
[13:35:15.063]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[13:35:15.063]                 "immediateCondition"))) {
[13:35:15.063]                   signal <- TRUE && inherits(cond, "immediateCondition")
[13:35:15.063]                   ...future.conditions[[length(...future.conditions) + 
[13:35:15.063]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[13:35:15.063]                   if (TRUE && !signal) {
[13:35:15.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:15.063]                     {
[13:35:15.063]                       inherits <- base::inherits
[13:35:15.063]                       invokeRestart <- base::invokeRestart
[13:35:15.063]                       is.null <- base::is.null
[13:35:15.063]                       muffled <- FALSE
[13:35:15.063]                       if (inherits(cond, "message")) {
[13:35:15.063]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:15.063]                         if (muffled) 
[13:35:15.063]                           invokeRestart("muffleMessage")
[13:35:15.063]                       }
[13:35:15.063]                       else if (inherits(cond, "warning")) {
[13:35:15.063]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:15.063]                         if (muffled) 
[13:35:15.063]                           invokeRestart("muffleWarning")
[13:35:15.063]                       }
[13:35:15.063]                       else if (inherits(cond, "condition")) {
[13:35:15.063]                         if (!is.null(pattern)) {
[13:35:15.063]                           computeRestarts <- base::computeRestarts
[13:35:15.063]                           grepl <- base::grepl
[13:35:15.063]                           restarts <- computeRestarts(cond)
[13:35:15.063]                           for (restart in restarts) {
[13:35:15.063]                             name <- restart$name
[13:35:15.063]                             if (is.null(name)) 
[13:35:15.063]                               next
[13:35:15.063]                             if (!grepl(pattern, name)) 
[13:35:15.063]                               next
[13:35:15.063]                             invokeRestart(restart)
[13:35:15.063]                             muffled <- TRUE
[13:35:15.063]                             break
[13:35:15.063]                           }
[13:35:15.063]                         }
[13:35:15.063]                       }
[13:35:15.063]                       invisible(muffled)
[13:35:15.063]                     }
[13:35:15.063]                     muffleCondition(cond, pattern = "^muffle")
[13:35:15.063]                   }
[13:35:15.063]                 }
[13:35:15.063]                 else {
[13:35:15.063]                   if (TRUE) {
[13:35:15.063]                     muffleCondition <- function (cond, pattern = "^muffle") 
[13:35:15.063]                     {
[13:35:15.063]                       inherits <- base::inherits
[13:35:15.063]                       invokeRestart <- base::invokeRestart
[13:35:15.063]                       is.null <- base::is.null
[13:35:15.063]                       muffled <- FALSE
[13:35:15.063]                       if (inherits(cond, "message")) {
[13:35:15.063]                         muffled <- grepl(pattern, "muffleMessage")
[13:35:15.063]                         if (muffled) 
[13:35:15.063]                           invokeRestart("muffleMessage")
[13:35:15.063]                       }
[13:35:15.063]                       else if (inherits(cond, "warning")) {
[13:35:15.063]                         muffled <- grepl(pattern, "muffleWarning")
[13:35:15.063]                         if (muffled) 
[13:35:15.063]                           invokeRestart("muffleWarning")
[13:35:15.063]                       }
[13:35:15.063]                       else if (inherits(cond, "condition")) {
[13:35:15.063]                         if (!is.null(pattern)) {
[13:35:15.063]                           computeRestarts <- base::computeRestarts
[13:35:15.063]                           grepl <- base::grepl
[13:35:15.063]                           restarts <- computeRestarts(cond)
[13:35:15.063]                           for (restart in restarts) {
[13:35:15.063]                             name <- restart$name
[13:35:15.063]                             if (is.null(name)) 
[13:35:15.063]                               next
[13:35:15.063]                             if (!grepl(pattern, name)) 
[13:35:15.063]                               next
[13:35:15.063]                             invokeRestart(restart)
[13:35:15.063]                             muffled <- TRUE
[13:35:15.063]                             break
[13:35:15.063]                           }
[13:35:15.063]                         }
[13:35:15.063]                       }
[13:35:15.063]                       invisible(muffled)
[13:35:15.063]                     }
[13:35:15.063]                     muffleCondition(cond, pattern = "^muffle")
[13:35:15.063]                   }
[13:35:15.063]                 }
[13:35:15.063]             }
[13:35:15.063]         }))
[13:35:15.063]     }, error = function(ex) {
[13:35:15.063]         base::structure(base::list(value = NULL, visible = NULL, 
[13:35:15.063]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[13:35:15.063]                 ...future.rng), started = ...future.startTime, 
[13:35:15.063]             finished = Sys.time(), session_uuid = NA_character_, 
[13:35:15.063]             version = "1.8"), class = "FutureResult")
[13:35:15.063]     }, finally = {
[13:35:15.063]         if (!identical(...future.workdir, getwd())) 
[13:35:15.063]             setwd(...future.workdir)
[13:35:15.063]         {
[13:35:15.063]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[13:35:15.063]                 ...future.oldOptions$nwarnings <- NULL
[13:35:15.063]             }
[13:35:15.063]             base::options(...future.oldOptions)
[13:35:15.063]             if (.Platform$OS.type == "windows") {
[13:35:15.063]                 old_names <- names(...future.oldEnvVars)
[13:35:15.063]                 envs <- base::Sys.getenv()
[13:35:15.063]                 names <- names(envs)
[13:35:15.063]                 common <- intersect(names, old_names)
[13:35:15.063]                 added <- setdiff(names, old_names)
[13:35:15.063]                 removed <- setdiff(old_names, names)
[13:35:15.063]                 changed <- common[...future.oldEnvVars[common] != 
[13:35:15.063]                   envs[common]]
[13:35:15.063]                 NAMES <- toupper(changed)
[13:35:15.063]                 args <- list()
[13:35:15.063]                 for (kk in seq_along(NAMES)) {
[13:35:15.063]                   name <- changed[[kk]]
[13:35:15.063]                   NAME <- NAMES[[kk]]
[13:35:15.063]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:15.063]                     next
[13:35:15.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:15.063]                 }
[13:35:15.063]                 NAMES <- toupper(added)
[13:35:15.063]                 for (kk in seq_along(NAMES)) {
[13:35:15.063]                   name <- added[[kk]]
[13:35:15.063]                   NAME <- NAMES[[kk]]
[13:35:15.063]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:15.063]                     next
[13:35:15.063]                   args[[name]] <- ""
[13:35:15.063]                 }
[13:35:15.063]                 NAMES <- toupper(removed)
[13:35:15.063]                 for (kk in seq_along(NAMES)) {
[13:35:15.063]                   name <- removed[[kk]]
[13:35:15.063]                   NAME <- NAMES[[kk]]
[13:35:15.063]                   if (name != NAME && is.element(NAME, old_names)) 
[13:35:15.063]                     next
[13:35:15.063]                   args[[name]] <- ...future.oldEnvVars[[name]]
[13:35:15.063]                 }
[13:35:15.063]                 if (length(args) > 0) 
[13:35:15.063]                   base::do.call(base::Sys.setenv, args = args)
[13:35:15.063]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[13:35:15.063]             }
[13:35:15.063]             else {
[13:35:15.063]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[13:35:15.063]             }
[13:35:15.063]             {
[13:35:15.063]                 if (base::length(...future.futureOptionsAdded) > 
[13:35:15.063]                   0L) {
[13:35:15.063]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[13:35:15.063]                   base::names(opts) <- ...future.futureOptionsAdded
[13:35:15.063]                   base::options(opts)
[13:35:15.063]                 }
[13:35:15.063]                 {
[13:35:15.063]                   {
[13:35:15.063]                     base::options(mc.cores = ...future.mc.cores.old)
[13:35:15.063]                     NULL
[13:35:15.063]                   }
[13:35:15.063]                   options(future.plan = NULL)
[13:35:15.063]                   if (is.na(NA_character_)) 
[13:35:15.063]                     Sys.unsetenv("R_FUTURE_PLAN")
[13:35:15.063]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[13:35:15.063]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[13:35:15.063]                     .init = FALSE)
[13:35:15.063]                 }
[13:35:15.063]             }
[13:35:15.063]         }
[13:35:15.063]     })
[13:35:15.063]     if (TRUE) {
[13:35:15.063]         base::sink(type = "output", split = FALSE)
[13:35:15.063]         if (TRUE) {
[13:35:15.063]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[13:35:15.063]         }
[13:35:15.063]         else {
[13:35:15.063]             ...future.result["stdout"] <- base::list(NULL)
[13:35:15.063]         }
[13:35:15.063]         base::close(...future.stdout)
[13:35:15.063]         ...future.stdout <- NULL
[13:35:15.063]     }
[13:35:15.063]     ...future.result$conditions <- ...future.conditions
[13:35:15.063]     ...future.result$finished <- base::Sys.time()
[13:35:15.063]     ...future.result
[13:35:15.063] }
[13:35:15.065] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[13:35:15.065] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[13:35:15.106] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[13:35:15.107] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[13:35:15.107] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[13:35:15.107] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[13:35:15.107] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[13:35:15.108] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[13:35:15.150] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[13:35:15.151] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[13:35:15.194] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[13:35:15.195] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[13:35:15.195] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[13:35:15.195] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[13:35:15.196] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[13:35:15.196] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[13:35:15.196] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[13:35:15.196] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[13:35:15.197] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[13:35:15.197] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[13:35:15.197] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[13:35:15.197] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[13:35:15.198] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[13:35:15.198] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[13:35:15.198] MultisessionFuture started
[13:35:15.198] - Launch lazy future ... done
[13:35:15.198] run() for ‘MultisessionFuture’ ... done
[13:35:15.199] Created future:
[13:35:15.200] receiveMessageFromWorker() for ClusterFuture ...
[13:35:15.200] - Validating connection of MultisessionFuture
[13:35:15.200] - received message: FutureResult
[13:35:15.201] - Received FutureResult
[13:35:15.201] - Erased future from FutureRegistry
[13:35:15.201] result() for ClusterFuture ...
[13:35:15.201] - result already collected: FutureResult
[13:35:15.201] result() for ClusterFuture ... done
[13:35:15.201] signalConditions() ...
[13:35:15.201]  - include = ‘immediateCondition’
[13:35:15.201]  - exclude = 
[13:35:15.201]  - resignal = FALSE
[13:35:15.201]  - Number of conditions: 1
[13:35:15.201] signalConditions() ... done
[13:35:15.202] receiveMessageFromWorker() for ClusterFuture ... done
[13:35:15.199] MultisessionFuture:
[13:35:15.199] Label: ‘future_vapply-2’
[13:35:15.199] Expression:
[13:35:15.199] {
[13:35:15.199]     do.call(function(...) {
[13:35:15.199]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[13:35:15.199]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[13:35:15.199]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[13:35:15.199]             on.exit(options(oopts), add = TRUE)
[13:35:15.199]         }
[13:35:15.199]         {
[13:35:15.199]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[13:35:15.199]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[13:35:15.199]                 ...future.FUN(...future.X_jj, ...)
[13:35:15.199]             })
[13:35:15.199]         }
[13:35:15.199]     }, args = future.call.arguments)
[13:35:15.199] }
[13:35:15.199] Lazy evaluation: FALSE
[13:35:15.199] Asynchronous evaluation: TRUE
[13:35:15.199] Local evaluation: TRUE
[13:35:15.199] Environment: R_GlobalEnv
[13:35:15.199] Capture standard output: TRUE
[13:35:15.199] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[13:35:15.199] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[13:35:15.199] Packages: 1 packages (‘future.apply’)
[13:35:15.199] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[13:35:15.199] Resolved: TRUE
[13:35:15.199] Value: <not collected>
[13:35:15.199] Conditions captured: <none>
[13:35:15.199] Early signaling: FALSE
[13:35:15.199] Owner process: 6dff4542-b009-34de-4010-b4b434cb435f
[13:35:15.199] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[13:35:15.202] Chunk #2 of 2 ... DONE
[13:35:15.202] Launching 2 futures (chunks) ... DONE
[13:35:15.202] Resolving 2 futures (chunks) ...
[13:35:15.202] resolve() on list ...
[13:35:15.202]  recursive: 0
[13:35:15.202]  length: 2
[13:35:15.202] 
[13:35:15.203] Future #1
[13:35:15.203] result() for ClusterFuture ...
[13:35:15.203] - result already collected: FutureResult
[13:35:15.203] result() for ClusterFuture ... done
[13:35:15.203] result() for ClusterFuture ...
[13:35:15.203] - result already collected: FutureResult
[13:35:15.203] result() for ClusterFuture ... done
[13:35:15.203] signalConditions() ...
[13:35:15.203]  - include = ‘immediateCondition’
[13:35:15.203]  - exclude = 
[13:35:15.203]  - resignal = FALSE
[13:35:15.204]  - Number of conditions: 1
[13:35:15.204] signalConditions() ... done
[13:35:15.204] signalConditionsASAP(MultisessionFuture, pos=1) ...
[13:35:15.204] - nx: 2
[13:35:15.204] - relay: TRUE
[13:35:15.204] - stdout: TRUE
[13:35:15.204] - signal: TRUE
[13:35:15.204] - resignal: FALSE
[13:35:15.204] - force: TRUE
[13:35:15.207] - relayed: [n=2] FALSE, FALSE
[13:35:15.207] - queued futures: [n=2] FALSE, FALSE
[13:35:15.208]  - until=1
[13:35:15.208]  - relaying element #1
[13:35:15.208] result() for ClusterFuture ...
[13:35:15.208] - result already collected: FutureResult
[13:35:15.208] result() for ClusterFuture ... done
[13:35:15.208] result() for ClusterFuture ...
[13:35:15.208] - result already collected: FutureResult
[13:35:15.208] result() for ClusterFuture ... done
[13:35:15.208] signalConditions() ...
[13:35:15.208]  - include = ‘immediateCondition’
[13:35:15.208]  - exclude = 
[13:35:15.208]  - resignal = FALSE
[13:35:15.209]  - Number of conditions: 1
[13:35:15.209] signalConditions() ... done
[13:35:15.209] result() for ClusterFuture ...
[13:35:15.209] - result already collected: FutureResult
[13:35:15.209] result() for ClusterFuture ... done
[13:35:15.209] signalConditions() ...
[13:35:15.209]  - include = ‘immediateCondition’
[13:35:15.209]  - exclude = 
[13:35:15.209]  - resignal = FALSE
[13:35:15.209]  - Number of conditions: 1
[13:35:15.209] signalConditions() ... done
[13:35:15.210] result() for ClusterFuture ...
[13:35:15.210] - result already collected: FutureResult
[13:35:15.210] result() for ClusterFuture ... done
[13:35:15.210] signalConditions() ...
[13:35:15.210]  - include = ‘condition’
[13:35:15.210]  - exclude = ‘immediateCondition’
[13:35:15.210]  - resignal = TRUE
[13:35:15.210]  - Number of conditions: 1
[13:35:15.210]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[13:35:15.210] signalConditions() ... done
[13:35:15.210] - relayed: [n=2] FALSE, FALSE
[13:35:15.211] - queued futures: [n=2] TRUE, FALSE
[13:35:15.211] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[13:35:15.211] plan(): Setting new future strategy stack:
[13:35:15.211] List of future strategies:
[13:35:15.211] 1. sequential:
[13:35:15.211]    - args: function (..., envir = parent.frame())
[13:35:15.211]    - tweaked: FALSE
[13:35:15.211]    - call: plan(sequential)
[13:35:15.212] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[13:35:15.213] plan(): Setting new future strategy stack:
[13:35:15.213] List of future strategies:
[13:35:15.213] 1. FutureStrategy:
[13:35:15.213]    - args: function (..., envir = parent.frame())
[13:35:15.213]    - tweaked: FALSE
[13:35:15.213]    - call: future::plan(oplan)
[13:35:15.213] plan(): nbrOfWorkers() = 1
> 
