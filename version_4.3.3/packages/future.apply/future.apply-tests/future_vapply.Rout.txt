
R version 4.3.3 (2024-02-29) -- "Angel Food Cake"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
Loading required package: future
[10:31:21.376] plan(): Setting new future strategy stack:
[10:31:21.376] List of future strategies:
[10:31:21.376] 1. sequential:
[10:31:21.376]    - args: function (..., envir = parent.frame())
[10:31:21.376]    - tweaked: FALSE
[10:31:21.376]    - call: future::plan("sequential")
[10:31:21.391] plan(): nbrOfWorkers() = 1
> 
> 
> message("*** future_vapply() ...")
*** future_vapply() ...
> 
> for (strategy in supportedStrategies()) {
+   message(sprintf("*** strategy = %s ...", sQuote(strategy)))
+   plan(strategy)
+   
+   x <- NULL
+   fun <- is.factor
+   fun_name <- "is.factor"
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   y2 <- future_vapply(x, FUN = fun_name, FUN.VALUE = fun_value)
+   str(y2)
+   stopifnot(all.equal(y2, y0))
+   
+   x <- list()
+   fun <- is.numeric
+   fun_value <- logical(1L)
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- integer()
+   fun <- identity
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   
+   df <- data.frame(x = 1:10, y = letters[1:10], stringsAsFactors=FALSE)
+   fun <- class
+   fun_value <- character(1L)
+   y0 <- vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(df, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   x <- 1:10
+   fun <- function(x) double(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) integer(0L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- sqrt
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) c(x, x^2)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(integer(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   fun <- function(x) matrix(x, nrow = 2L, ncol = 2L)
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   ## Ditto with dimnames on FUN.VALUE
+   fun <- function(x) {
+     matrix(x, nrow = 2L, ncol = 2L, dimnames = list(c("a", "b"), c("A", "B")))
+   }
+   fun_value <- fun(double(1L))
+   y0 <- vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y0)
+   y1 <- future_vapply(x, FUN = fun, FUN.VALUE = fun_value)
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   message("- From example(vapply) ...")
+   x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE, FALSE, FALSE, TRUE))
+   y0 <- vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   y1 <- future_vapply(x, FUN = quantile, FUN.VALUE = double(5L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+   
+   i39 <- sapply(3:9, seq)
+   ys0 <- sapply(i39, fivenum)
+   ys1 <- future_sapply(i39, fivenum)
+   stopifnot(all.equal(ys1, ys0))
+   
+   yv0 <- vapply(i39, fivenum,
+           c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   yv1 <- future_vapply(i39, fivenum,
+          c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   v <- structure(10*(5:8), names = LETTERS[1:4])
+   f <- function(x, y) outer(rep(x, length.out = 3L), y)
+   ys0 <- sapply(v, f, y = 2*(1:5), simplify = "array")
+   ys1 <- future_sapply(v, f, y = 2*(1:5), simplify = "array")
+   stopifnot(all.equal(ys1, ys0))
+   
+   fv <- outer(1:3, 1:5)
+   y <- 2*(1:5)
+   yv0 <- vapply(v, f, fv, y = y)
+   yv1 <- future_vapply(v, f, fv, y = y)
+   str(yv1)
+   stopifnot(all.equal(yv1, yv0))
+   
+   y0 <- vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   y1 <- future_vapply(mtcars, FUN = is.numeric, FUN.VALUE = logical(1L))
+   str(y1)
+   stopifnot(all.equal(y1, y0))
+ 
+   message("- future_vapply(x, ...) where length(x) != length(as.list(x)) ...")
+   x <- structure(list(a = 1, b = 2), class = "Foo")
+   as.list.Foo <- function(x, ...) c(x, c = 3)
+   y0 <- vapply(x, FUN = length, FUN.VALUE = -1L)
+   y1 <- future_vapply(x, FUN = length, FUN.VALUE = -1L)
+   stopifnot(identical(y1, y0))
+ 
+   message("- exceptions ...")
+   res <- tryCatch({
+     y0 <- vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   res <- tryCatch({
+     y1 <- future_vapply(1:3, FUN = identity, FUN.VALUE = c(3, 3))
+   }, error = identity)
+   stopifnot(inherits(res, "error"))
+   
+   plan(sequential)
+   message(sprintf("*** strategy = %s ... done", sQuote(strategy)))
+ } ## for (strategy in ...) 
*** strategy = ‘sequential’ ...
[10:31:21.496] plan(): Setting new future strategy stack:
[10:31:21.496] List of future strategies:
[10:31:21.496] 1. sequential:
[10:31:21.496]    - args: function (..., envir = parent.frame())
[10:31:21.496]    - tweaked: FALSE
[10:31:21.496]    - call: plan(strategy)
[10:31:21.509] plan(): nbrOfWorkers() = 1
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[10:31:21.514] future_lapply() ...
[10:31:21.521] Number of chunks: 1
[10:31:21.521] getGlobalsAndPackagesXApply() ...
[10:31:21.521]  - future.globals: TRUE
[10:31:21.522] getGlobalsAndPackages() ...
[10:31:21.522] Searching for globals...
[10:31:21.526] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:21.526] Searching for globals ... DONE
[10:31:21.526] Resolving globals: FALSE
[10:31:21.528] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[10:31:21.529] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:21.529] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.529] - packages: [1] ‘future.apply’
[10:31:21.529] getGlobalsAndPackages() ... DONE
[10:31:21.529]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.529]  - needed namespaces: [n=1] ‘future.apply’
[10:31:21.529] Finding globals ... DONE
[10:31:21.529]  - use_args: TRUE
[10:31:21.529]  - Getting '...' globals ...
[10:31:21.530] resolve() on list ...
[10:31:21.530]  recursive: 0
[10:31:21.531]  length: 1
[10:31:21.531]  elements: ‘...’
[10:31:21.531]  length: 0 (resolved future 1)
[10:31:21.531] resolve() on list ... DONE
[10:31:21.531]    - '...' content: [n=0] 
[10:31:21.531] List of 1
[10:31:21.531]  $ ...: list()
[10:31:21.531]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.531]  - attr(*, "where")=List of 1
[10:31:21.531]   ..$ ...:<environment: 0x55de84176b28> 
[10:31:21.531]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.531]  - attr(*, "resolved")= logi TRUE
[10:31:21.531]  - attr(*, "total_size")= num NA
[10:31:21.534]  - Getting '...' globals ... DONE
[10:31:21.534] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:21.534] List of 8
[10:31:21.534]  $ ...future.FUN:function (x, ...)  
[10:31:21.534]  $ x_FUN        :function (x)  
[10:31:21.534]  $ times        : int 1
[10:31:21.534]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.534]  $ stop_if_not  :function (...)  
[10:31:21.534]  $ dim          : NULL
[10:31:21.534]  $ valid_types  : chr "character"
[10:31:21.534]  $ ...          : list()
[10:31:21.534]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.534]  - attr(*, "where")=List of 8
[10:31:21.534]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:21.534]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:21.534]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:21.534]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:21.534]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:21.534]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:21.534]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:21.534]   ..$ ...          :<environment: 0x55de84176b28> 
[10:31:21.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.534]  - attr(*, "resolved")= logi FALSE
[10:31:21.534]  - attr(*, "total_size")= num 94208
[10:31:21.542] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:21.542] getGlobalsAndPackagesXApply() ... DONE
[10:31:21.543] Number of futures (= number of chunks): 1
[10:31:21.543] Launching 1 futures (chunks) ...
[10:31:21.543] Chunk #1 of 1 ...
[10:31:21.543]  - Finding globals in 'X' for chunk #1 ...
[10:31:21.543] getGlobalsAndPackages() ...
[10:31:21.544] Searching for globals...
[10:31:21.544] 
[10:31:21.544] Searching for globals ... DONE
[10:31:21.544] - globals: [0] <none>
[10:31:21.544] getGlobalsAndPackages() ... DONE
[10:31:21.544]    + additional globals found: [n=0] 
[10:31:21.544]    + additional namespaces needed: [n=0] 
[10:31:21.544]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:21.545]  - seeds: <none>
[10:31:21.545]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.545] getGlobalsAndPackages() ...
[10:31:21.545] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.545] Resolving globals: FALSE
[10:31:21.545] Tweak future expression to call with '...' arguments ...
[10:31:21.545] {
[10:31:21.545]     do.call(function(...) {
[10:31:21.545]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.545]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.545]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.545]             on.exit(options(oopts), add = TRUE)
[10:31:21.545]         }
[10:31:21.545]         {
[10:31:21.545]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.545]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.545]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.545]             })
[10:31:21.545]         }
[10:31:21.545]     }, args = future.call.arguments)
[10:31:21.545] }
[10:31:21.546] Tweak future expression to call with '...' arguments ... DONE
[10:31:21.546] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.546] - packages: [1] ‘future.apply’
[10:31:21.546] getGlobalsAndPackages() ... DONE
[10:31:21.547] run() for ‘Future’ ...
[10:31:21.547] - state: ‘created’
[10:31:21.547] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:21.548] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.548] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:21.548]   - Field: ‘label’
[10:31:21.548]   - Field: ‘local’
[10:31:21.548]   - Field: ‘owner’
[10:31:21.548]   - Field: ‘envir’
[10:31:21.548]   - Field: ‘packages’
[10:31:21.549]   - Field: ‘gc’
[10:31:21.549]   - Field: ‘conditions’
[10:31:21.549]   - Field: ‘expr’
[10:31:21.549]   - Field: ‘uuid’
[10:31:21.549]   - Field: ‘seed’
[10:31:21.549]   - Field: ‘version’
[10:31:21.549]   - Field: ‘result’
[10:31:21.549]   - Field: ‘asynchronous’
[10:31:21.549]   - Field: ‘calls’
[10:31:21.549]   - Field: ‘globals’
[10:31:21.549]   - Field: ‘stdout’
[10:31:21.550]   - Field: ‘earlySignal’
[10:31:21.550]   - Field: ‘lazy’
[10:31:21.550]   - Field: ‘state’
[10:31:21.550] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:21.550] - Launch lazy future ...
[10:31:21.551] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:21.551] Packages needed by future strategies (n = 0): <none>
[10:31:21.552] {
[10:31:21.552]     {
[10:31:21.552]         {
[10:31:21.552]             ...future.startTime <- base::Sys.time()
[10:31:21.552]             {
[10:31:21.552]                 {
[10:31:21.552]                   {
[10:31:21.552]                     {
[10:31:21.552]                       base::local({
[10:31:21.552]                         has_future <- base::requireNamespace("future", 
[10:31:21.552]                           quietly = TRUE)
[10:31:21.552]                         if (has_future) {
[10:31:21.552]                           ns <- base::getNamespace("future")
[10:31:21.552]                           version <- ns[[".package"]][["version"]]
[10:31:21.552]                           if (is.null(version)) 
[10:31:21.552]                             version <- utils::packageVersion("future")
[10:31:21.552]                         }
[10:31:21.552]                         else {
[10:31:21.552]                           version <- NULL
[10:31:21.552]                         }
[10:31:21.552]                         if (!has_future || version < "1.8.0") {
[10:31:21.552]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:21.552]                             "", base::R.version$version.string), 
[10:31:21.552]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:21.552]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:21.552]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:21.552]                               "release", "version")], collapse = " "), 
[10:31:21.552]                             hostname = base::Sys.info()[["nodename"]])
[10:31:21.552]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:21.552]                             info)
[10:31:21.552]                           info <- base::paste(info, collapse = "; ")
[10:31:21.552]                           if (!has_future) {
[10:31:21.552]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:21.552]                               info)
[10:31:21.552]                           }
[10:31:21.552]                           else {
[10:31:21.552]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:21.552]                               info, version)
[10:31:21.552]                           }
[10:31:21.552]                           base::stop(msg)
[10:31:21.552]                         }
[10:31:21.552]                       })
[10:31:21.552]                     }
[10:31:21.552]                     base::local({
[10:31:21.552]                       for (pkg in "future.apply") {
[10:31:21.552]                         base::loadNamespace(pkg)
[10:31:21.552]                         base::library(pkg, character.only = TRUE)
[10:31:21.552]                       }
[10:31:21.552]                     })
[10:31:21.552]                   }
[10:31:21.552]                   ...future.strategy.old <- future::plan("list")
[10:31:21.552]                   options(future.plan = NULL)
[10:31:21.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:21.552]                 }
[10:31:21.552]                 ...future.workdir <- getwd()
[10:31:21.552]             }
[10:31:21.552]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:21.552]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:21.552]         }
[10:31:21.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:21.552]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:21.552]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:21.552]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:21.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:21.552]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:21.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:21.552]             base::names(...future.oldOptions))
[10:31:21.552]     }
[10:31:21.552]     if (FALSE) {
[10:31:21.552]     }
[10:31:21.552]     else {
[10:31:21.552]         if (TRUE) {
[10:31:21.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:21.552]                 open = "w")
[10:31:21.552]         }
[10:31:21.552]         else {
[10:31:21.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:21.552]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:21.552]         }
[10:31:21.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:21.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:21.552]             base::sink(type = "output", split = FALSE)
[10:31:21.552]             base::close(...future.stdout)
[10:31:21.552]         }, add = TRUE)
[10:31:21.552]     }
[10:31:21.552]     ...future.frame <- base::sys.nframe()
[10:31:21.552]     ...future.conditions <- base::list()
[10:31:21.552]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:21.552]     if (FALSE) {
[10:31:21.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:21.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:21.552]     }
[10:31:21.552]     ...future.result <- base::tryCatch({
[10:31:21.552]         base::withCallingHandlers({
[10:31:21.552]             ...future.value <- base::withVisible(base::local({
[10:31:21.552]                 do.call(function(...) {
[10:31:21.552]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.552]                   if (!identical(...future.globals.maxSize.org, 
[10:31:21.552]                     ...future.globals.maxSize)) {
[10:31:21.552]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.552]                     on.exit(options(oopts), add = TRUE)
[10:31:21.552]                   }
[10:31:21.552]                   {
[10:31:21.552]                     lapply(seq_along(...future.elements_ii), 
[10:31:21.552]                       FUN = function(jj) {
[10:31:21.552]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.552]                         ...future.FUN(...future.X_jj, ...)
[10:31:21.552]                       })
[10:31:21.552]                   }
[10:31:21.552]                 }, args = future.call.arguments)
[10:31:21.552]             }))
[10:31:21.552]             future::FutureResult(value = ...future.value$value, 
[10:31:21.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.552]                   ...future.rng), globalenv = if (FALSE) 
[10:31:21.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:21.552]                     ...future.globalenv.names))
[10:31:21.552]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:21.552]         }, condition = base::local({
[10:31:21.552]             c <- base::c
[10:31:21.552]             inherits <- base::inherits
[10:31:21.552]             invokeRestart <- base::invokeRestart
[10:31:21.552]             length <- base::length
[10:31:21.552]             list <- base::list
[10:31:21.552]             seq.int <- base::seq.int
[10:31:21.552]             signalCondition <- base::signalCondition
[10:31:21.552]             sys.calls <- base::sys.calls
[10:31:21.552]             `[[` <- base::`[[`
[10:31:21.552]             `+` <- base::`+`
[10:31:21.552]             `<<-` <- base::`<<-`
[10:31:21.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:21.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:21.552]                   3L)]
[10:31:21.552]             }
[10:31:21.552]             function(cond) {
[10:31:21.552]                 is_error <- inherits(cond, "error")
[10:31:21.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:21.552]                   NULL)
[10:31:21.552]                 if (is_error) {
[10:31:21.552]                   sessionInformation <- function() {
[10:31:21.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:21.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:21.552]                       search = base::search(), system = base::Sys.info())
[10:31:21.552]                   }
[10:31:21.552]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:21.552]                     cond$call), session = sessionInformation(), 
[10:31:21.552]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:21.552]                   signalCondition(cond)
[10:31:21.552]                 }
[10:31:21.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:21.552]                 "immediateCondition"))) {
[10:31:21.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:21.552]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:21.552]                   if (TRUE && !signal) {
[10:31:21.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.552]                     {
[10:31:21.552]                       inherits <- base::inherits
[10:31:21.552]                       invokeRestart <- base::invokeRestart
[10:31:21.552]                       is.null <- base::is.null
[10:31:21.552]                       muffled <- FALSE
[10:31:21.552]                       if (inherits(cond, "message")) {
[10:31:21.552]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.552]                         if (muffled) 
[10:31:21.552]                           invokeRestart("muffleMessage")
[10:31:21.552]                       }
[10:31:21.552]                       else if (inherits(cond, "warning")) {
[10:31:21.552]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.552]                         if (muffled) 
[10:31:21.552]                           invokeRestart("muffleWarning")
[10:31:21.552]                       }
[10:31:21.552]                       else if (inherits(cond, "condition")) {
[10:31:21.552]                         if (!is.null(pattern)) {
[10:31:21.552]                           computeRestarts <- base::computeRestarts
[10:31:21.552]                           grepl <- base::grepl
[10:31:21.552]                           restarts <- computeRestarts(cond)
[10:31:21.552]                           for (restart in restarts) {
[10:31:21.552]                             name <- restart$name
[10:31:21.552]                             if (is.null(name)) 
[10:31:21.552]                               next
[10:31:21.552]                             if (!grepl(pattern, name)) 
[10:31:21.552]                               next
[10:31:21.552]                             invokeRestart(restart)
[10:31:21.552]                             muffled <- TRUE
[10:31:21.552]                             break
[10:31:21.552]                           }
[10:31:21.552]                         }
[10:31:21.552]                       }
[10:31:21.552]                       invisible(muffled)
[10:31:21.552]                     }
[10:31:21.552]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.552]                   }
[10:31:21.552]                 }
[10:31:21.552]                 else {
[10:31:21.552]                   if (TRUE) {
[10:31:21.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.552]                     {
[10:31:21.552]                       inherits <- base::inherits
[10:31:21.552]                       invokeRestart <- base::invokeRestart
[10:31:21.552]                       is.null <- base::is.null
[10:31:21.552]                       muffled <- FALSE
[10:31:21.552]                       if (inherits(cond, "message")) {
[10:31:21.552]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.552]                         if (muffled) 
[10:31:21.552]                           invokeRestart("muffleMessage")
[10:31:21.552]                       }
[10:31:21.552]                       else if (inherits(cond, "warning")) {
[10:31:21.552]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.552]                         if (muffled) 
[10:31:21.552]                           invokeRestart("muffleWarning")
[10:31:21.552]                       }
[10:31:21.552]                       else if (inherits(cond, "condition")) {
[10:31:21.552]                         if (!is.null(pattern)) {
[10:31:21.552]                           computeRestarts <- base::computeRestarts
[10:31:21.552]                           grepl <- base::grepl
[10:31:21.552]                           restarts <- computeRestarts(cond)
[10:31:21.552]                           for (restart in restarts) {
[10:31:21.552]                             name <- restart$name
[10:31:21.552]                             if (is.null(name)) 
[10:31:21.552]                               next
[10:31:21.552]                             if (!grepl(pattern, name)) 
[10:31:21.552]                               next
[10:31:21.552]                             invokeRestart(restart)
[10:31:21.552]                             muffled <- TRUE
[10:31:21.552]                             break
[10:31:21.552]                           }
[10:31:21.552]                         }
[10:31:21.552]                       }
[10:31:21.552]                       invisible(muffled)
[10:31:21.552]                     }
[10:31:21.552]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.552]                   }
[10:31:21.552]                 }
[10:31:21.552]             }
[10:31:21.552]         }))
[10:31:21.552]     }, error = function(ex) {
[10:31:21.552]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:21.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.552]                 ...future.rng), started = ...future.startTime, 
[10:31:21.552]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:21.552]             version = "1.8"), class = "FutureResult")
[10:31:21.552]     }, finally = {
[10:31:21.552]         if (!identical(...future.workdir, getwd())) 
[10:31:21.552]             setwd(...future.workdir)
[10:31:21.552]         {
[10:31:21.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:21.552]                 ...future.oldOptions$nwarnings <- NULL
[10:31:21.552]             }
[10:31:21.552]             base::options(...future.oldOptions)
[10:31:21.552]             if (.Platform$OS.type == "windows") {
[10:31:21.552]                 old_names <- names(...future.oldEnvVars)
[10:31:21.552]                 envs <- base::Sys.getenv()
[10:31:21.552]                 names <- names(envs)
[10:31:21.552]                 common <- intersect(names, old_names)
[10:31:21.552]                 added <- setdiff(names, old_names)
[10:31:21.552]                 removed <- setdiff(old_names, names)
[10:31:21.552]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:21.552]                   envs[common]]
[10:31:21.552]                 NAMES <- toupper(changed)
[10:31:21.552]                 args <- list()
[10:31:21.552]                 for (kk in seq_along(NAMES)) {
[10:31:21.552]                   name <- changed[[kk]]
[10:31:21.552]                   NAME <- NAMES[[kk]]
[10:31:21.552]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.552]                     next
[10:31:21.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.552]                 }
[10:31:21.552]                 NAMES <- toupper(added)
[10:31:21.552]                 for (kk in seq_along(NAMES)) {
[10:31:21.552]                   name <- added[[kk]]
[10:31:21.552]                   NAME <- NAMES[[kk]]
[10:31:21.552]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.552]                     next
[10:31:21.552]                   args[[name]] <- ""
[10:31:21.552]                 }
[10:31:21.552]                 NAMES <- toupper(removed)
[10:31:21.552]                 for (kk in seq_along(NAMES)) {
[10:31:21.552]                   name <- removed[[kk]]
[10:31:21.552]                   NAME <- NAMES[[kk]]
[10:31:21.552]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.552]                     next
[10:31:21.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.552]                 }
[10:31:21.552]                 if (length(args) > 0) 
[10:31:21.552]                   base::do.call(base::Sys.setenv, args = args)
[10:31:21.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:21.552]             }
[10:31:21.552]             else {
[10:31:21.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:21.552]             }
[10:31:21.552]             {
[10:31:21.552]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:21.552]                   0L) {
[10:31:21.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:21.552]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:21.552]                   base::options(opts)
[10:31:21.552]                 }
[10:31:21.552]                 {
[10:31:21.552]                   {
[10:31:21.552]                     NULL
[10:31:21.552]                     RNGkind("Mersenne-Twister")
[10:31:21.552]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:21.552]                       inherits = FALSE)
[10:31:21.552]                   }
[10:31:21.552]                   options(future.plan = NULL)
[10:31:21.552]                   if (is.na(NA_character_)) 
[10:31:21.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:21.552]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:21.552]                     .init = FALSE)
[10:31:21.552]                 }
[10:31:21.552]             }
[10:31:21.552]         }
[10:31:21.552]     })
[10:31:21.552]     if (TRUE) {
[10:31:21.552]         base::sink(type = "output", split = FALSE)
[10:31:21.552]         if (TRUE) {
[10:31:21.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:21.552]         }
[10:31:21.552]         else {
[10:31:21.552]             ...future.result["stdout"] <- base::list(NULL)
[10:31:21.552]         }
[10:31:21.552]         base::close(...future.stdout)
[10:31:21.552]         ...future.stdout <- NULL
[10:31:21.552]     }
[10:31:21.552]     ...future.result$conditions <- ...future.conditions
[10:31:21.552]     ...future.result$finished <- base::Sys.time()
[10:31:21.552]     ...future.result
[10:31:21.552] }
[10:31:21.554] assign_globals() ...
[10:31:21.554] List of 11
[10:31:21.554]  $ ...future.FUN            :function (x, ...)  
[10:31:21.554]  $ x_FUN                    :function (x)  
[10:31:21.554]  $ times                    : int 1
[10:31:21.554]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.554]  $ stop_if_not              :function (...)  
[10:31:21.554]  $ dim                      : NULL
[10:31:21.554]  $ valid_types              : chr "character"
[10:31:21.554]  $ future.call.arguments    : list()
[10:31:21.554]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.554]  $ ...future.elements_ii    :List of 2
[10:31:21.554]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:31:21.554]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[10:31:21.554]  $ ...future.seeds_ii       : NULL
[10:31:21.554]  $ ...future.globals.maxSize: NULL
[10:31:21.554]  - attr(*, "where")=List of 11
[10:31:21.554]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:21.554]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:21.554]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:21.554]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:21.554]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:21.554]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:21.554]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:21.554]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:21.554]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:21.554]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:21.554]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:21.554]  - attr(*, "resolved")= logi FALSE
[10:31:21.554]  - attr(*, "total_size")= num 94208
[10:31:21.554]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.554]  - attr(*, "already-done")= logi TRUE
[10:31:21.561] - copied ‘...future.FUN’ to environment
[10:31:21.561] - copied ‘x_FUN’ to environment
[10:31:21.561] - copied ‘times’ to environment
[10:31:21.562] - copied ‘stopf’ to environment
[10:31:21.562] - copied ‘stop_if_not’ to environment
[10:31:21.562] - copied ‘dim’ to environment
[10:31:21.562] - copied ‘valid_types’ to environment
[10:31:21.562] - copied ‘future.call.arguments’ to environment
[10:31:21.562] - copied ‘...future.elements_ii’ to environment
[10:31:21.562] - copied ‘...future.seeds_ii’ to environment
[10:31:21.562] - copied ‘...future.globals.maxSize’ to environment
[10:31:21.562] assign_globals() ... done
[10:31:21.563] plan(): Setting new future strategy stack:
[10:31:21.563] List of future strategies:
[10:31:21.563] 1. sequential:
[10:31:21.563]    - args: function (..., envir = parent.frame())
[10:31:21.563]    - tweaked: FALSE
[10:31:21.563]    - call: NULL
[10:31:21.563] plan(): nbrOfWorkers() = 1
[10:31:21.564] plan(): Setting new future strategy stack:
[10:31:21.565] List of future strategies:
[10:31:21.565] 1. sequential:
[10:31:21.565]    - args: function (..., envir = parent.frame())
[10:31:21.565]    - tweaked: FALSE
[10:31:21.565]    - call: plan(strategy)
[10:31:21.565] plan(): nbrOfWorkers() = 1
[10:31:21.565] SequentialFuture started (and completed)
[10:31:21.566] - Launch lazy future ... done
[10:31:21.566] run() for ‘SequentialFuture’ ... done
[10:31:21.566] Created future:
[10:31:21.566] SequentialFuture:
[10:31:21.566] Label: ‘future_vapply-1’
[10:31:21.566] Expression:
[10:31:21.566] {
[10:31:21.566]     do.call(function(...) {
[10:31:21.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.566]             on.exit(options(oopts), add = TRUE)
[10:31:21.566]         }
[10:31:21.566]         {
[10:31:21.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.566]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.566]             })
[10:31:21.566]         }
[10:31:21.566]     }, args = future.call.arguments)
[10:31:21.566] }
[10:31:21.566] Lazy evaluation: FALSE
[10:31:21.566] Asynchronous evaluation: FALSE
[10:31:21.566] Local evaluation: TRUE
[10:31:21.566] Environment: R_GlobalEnv
[10:31:21.566] Capture standard output: TRUE
[10:31:21.566] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:21.566] Globals: 11 objects totaling 92.81 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:21.566] Packages: 1 packages (‘future.apply’)
[10:31:21.566] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:21.566] Resolved: TRUE
[10:31:21.566] Value: 232 bytes of class ‘list’
[10:31:21.566] Early signaling: FALSE
[10:31:21.566] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:21.566] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.568] Chunk #1 of 1 ... DONE
[10:31:21.568] Launching 1 futures (chunks) ... DONE
[10:31:21.568] Resolving 1 futures (chunks) ...
[10:31:21.568] resolve() on list ...
[10:31:21.568]  recursive: 0
[10:31:21.568]  length: 1
[10:31:21.568] 
[10:31:21.568] resolved() for ‘SequentialFuture’ ...
[10:31:21.568] - state: ‘finished’
[10:31:21.569] - run: TRUE
[10:31:21.569] - result: ‘FutureResult’
[10:31:21.569] resolved() for ‘SequentialFuture’ ... done
[10:31:21.571] Future #1
[10:31:21.571] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:21.571] - nx: 1
[10:31:21.571] - relay: TRUE
[10:31:21.571] - stdout: TRUE
[10:31:21.571] - signal: TRUE
[10:31:21.572] - resignal: FALSE
[10:31:21.572] - force: TRUE
[10:31:21.572] - relayed: [n=1] FALSE
[10:31:21.572] - queued futures: [n=1] FALSE
[10:31:21.572]  - until=1
[10:31:21.572]  - relaying element #1
[10:31:21.572] - relayed: [n=1] TRUE
[10:31:21.572] - queued futures: [n=1] TRUE
[10:31:21.572] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:21.573]  length: 0 (resolved future 1)
[10:31:21.573] Relaying remaining futures
[10:31:21.573] signalConditionsASAP(NULL, pos=0) ...
[10:31:21.573] - nx: 1
[10:31:21.573] - relay: TRUE
[10:31:21.573] - stdout: TRUE
[10:31:21.573] - signal: TRUE
[10:31:21.573] - resignal: FALSE
[10:31:21.573] - force: TRUE
[10:31:21.573] - relayed: [n=1] TRUE
[10:31:21.574] - queued futures: [n=1] TRUE
 - flush all
[10:31:21.574] - relayed: [n=1] TRUE
[10:31:21.574] - queued futures: [n=1] TRUE
[10:31:21.574] signalConditionsASAP(NULL, pos=0) ... done
[10:31:21.574] resolve() on list ... DONE
[10:31:21.574]  - Number of value chunks collected: 1
[10:31:21.574] Resolving 1 futures (chunks) ... DONE
[10:31:21.574] Reducing values from 1 chunks ...
[10:31:21.574]  - Number of values collected after concatenation: 2
[10:31:21.575]  - Number of values expected: 2
[10:31:21.575] Reducing values from 1 chunks ... DONE
[10:31:21.575] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[10:31:21.576] future_lapply() ...
[10:31:21.578] Number of chunks: 1
[10:31:21.578] getGlobalsAndPackagesXApply() ...
[10:31:21.578]  - future.globals: TRUE
[10:31:21.578] getGlobalsAndPackages() ...
[10:31:21.578] Searching for globals...
[10:31:21.582] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[10:31:21.582] Searching for globals ... DONE
[10:31:21.582] Resolving globals: FALSE
[10:31:21.583] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[10:31:21.583] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:21.583] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.583] - packages: [1] ‘future.apply’
[10:31:21.583] getGlobalsAndPackages() ... DONE
[10:31:21.584]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.584]  - needed namespaces: [n=1] ‘future.apply’
[10:31:21.584] Finding globals ... DONE
[10:31:21.584]  - use_args: TRUE
[10:31:21.584]  - Getting '...' globals ...
[10:31:21.584] resolve() on list ...
[10:31:21.584]  recursive: 0
[10:31:21.584]  length: 1
[10:31:21.585]  elements: ‘...’
[10:31:21.585]  length: 0 (resolved future 1)
[10:31:21.585] resolve() on list ... DONE
[10:31:21.585]    - '...' content: [n=0] 
[10:31:21.585] List of 1
[10:31:21.585]  $ ...: list()
[10:31:21.585]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.585]  - attr(*, "where")=List of 1
[10:31:21.585]   ..$ ...:<environment: 0x55de84dd85c8> 
[10:31:21.585]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.585]  - attr(*, "resolved")= logi TRUE
[10:31:21.585]  - attr(*, "total_size")= num NA
[10:31:21.587]  - Getting '...' globals ... DONE
[10:31:21.588] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:21.588] List of 8
[10:31:21.588]  $ ...future.FUN:function (x, ...)  
[10:31:21.588]  $ x_FUN        :function (x)  
[10:31:21.588]  $ times        : int 0
[10:31:21.588]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.588]  $ stop_if_not  :function (...)  
[10:31:21.588]  $ dim          : NULL
[10:31:21.588]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:21.588]  $ ...          : list()
[10:31:21.588]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.588]  - attr(*, "where")=List of 8
[10:31:21.588]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:21.588]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:21.588]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:21.588]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:21.588]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:21.588]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:21.588]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:21.588]   ..$ ...          :<environment: 0x55de84dd85c8> 
[10:31:21.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.588]  - attr(*, "resolved")= logi FALSE
[10:31:21.588]  - attr(*, "total_size")= num 95472
[10:31:21.595] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:21.595] getGlobalsAndPackagesXApply() ... DONE
[10:31:21.595] Number of futures (= number of chunks): 1
[10:31:21.595] Launching 1 futures (chunks) ...
[10:31:21.595] Chunk #1 of 1 ...
[10:31:21.595]  - Finding globals in 'X' for chunk #1 ...
[10:31:21.595] getGlobalsAndPackages() ...
[10:31:21.595] Searching for globals...
[10:31:21.596] 
[10:31:21.596] Searching for globals ... DONE
[10:31:21.596] - globals: [0] <none>
[10:31:21.596] getGlobalsAndPackages() ... DONE
[10:31:21.596]    + additional globals found: [n=0] 
[10:31:21.596]    + additional namespaces needed: [n=0] 
[10:31:21.596]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:21.596]  - seeds: <none>
[10:31:21.596]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.597] getGlobalsAndPackages() ...
[10:31:21.597] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.597] Resolving globals: FALSE
[10:31:21.597] Tweak future expression to call with '...' arguments ...
[10:31:21.597] {
[10:31:21.597]     do.call(function(...) {
[10:31:21.597]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.597]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.597]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.597]             on.exit(options(oopts), add = TRUE)
[10:31:21.597]         }
[10:31:21.597]         {
[10:31:21.597]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.597]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.597]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.597]             })
[10:31:21.597]         }
[10:31:21.597]     }, args = future.call.arguments)
[10:31:21.597] }
[10:31:21.597] Tweak future expression to call with '...' arguments ... DONE
[10:31:21.598] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.598] - packages: [1] ‘future.apply’
[10:31:21.598] getGlobalsAndPackages() ... DONE
[10:31:21.598] run() for ‘Future’ ...
[10:31:21.598] - state: ‘created’
[10:31:21.599] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:21.599] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.599] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:21.599]   - Field: ‘label’
[10:31:21.599]   - Field: ‘local’
[10:31:21.599]   - Field: ‘owner’
[10:31:21.599]   - Field: ‘envir’
[10:31:21.599]   - Field: ‘packages’
[10:31:21.600]   - Field: ‘gc’
[10:31:21.600]   - Field: ‘conditions’
[10:31:21.600]   - Field: ‘expr’
[10:31:21.600]   - Field: ‘uuid’
[10:31:21.600]   - Field: ‘seed’
[10:31:21.600]   - Field: ‘version’
[10:31:21.600]   - Field: ‘result’
[10:31:21.600]   - Field: ‘asynchronous’
[10:31:21.600]   - Field: ‘calls’
[10:31:21.600]   - Field: ‘globals’
[10:31:21.601]   - Field: ‘stdout’
[10:31:21.601]   - Field: ‘earlySignal’
[10:31:21.601]   - Field: ‘lazy’
[10:31:21.601]   - Field: ‘state’
[10:31:21.601] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:21.601] - Launch lazy future ...
[10:31:21.601] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:21.601] Packages needed by future strategies (n = 0): <none>
[10:31:21.602] {
[10:31:21.602]     {
[10:31:21.602]         {
[10:31:21.602]             ...future.startTime <- base::Sys.time()
[10:31:21.602]             {
[10:31:21.602]                 {
[10:31:21.602]                   {
[10:31:21.602]                     {
[10:31:21.602]                       base::local({
[10:31:21.602]                         has_future <- base::requireNamespace("future", 
[10:31:21.602]                           quietly = TRUE)
[10:31:21.602]                         if (has_future) {
[10:31:21.602]                           ns <- base::getNamespace("future")
[10:31:21.602]                           version <- ns[[".package"]][["version"]]
[10:31:21.602]                           if (is.null(version)) 
[10:31:21.602]                             version <- utils::packageVersion("future")
[10:31:21.602]                         }
[10:31:21.602]                         else {
[10:31:21.602]                           version <- NULL
[10:31:21.602]                         }
[10:31:21.602]                         if (!has_future || version < "1.8.0") {
[10:31:21.602]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:21.602]                             "", base::R.version$version.string), 
[10:31:21.602]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:21.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:21.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:21.602]                               "release", "version")], collapse = " "), 
[10:31:21.602]                             hostname = base::Sys.info()[["nodename"]])
[10:31:21.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:21.602]                             info)
[10:31:21.602]                           info <- base::paste(info, collapse = "; ")
[10:31:21.602]                           if (!has_future) {
[10:31:21.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:21.602]                               info)
[10:31:21.602]                           }
[10:31:21.602]                           else {
[10:31:21.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:21.602]                               info, version)
[10:31:21.602]                           }
[10:31:21.602]                           base::stop(msg)
[10:31:21.602]                         }
[10:31:21.602]                       })
[10:31:21.602]                     }
[10:31:21.602]                     base::local({
[10:31:21.602]                       for (pkg in "future.apply") {
[10:31:21.602]                         base::loadNamespace(pkg)
[10:31:21.602]                         base::library(pkg, character.only = TRUE)
[10:31:21.602]                       }
[10:31:21.602]                     })
[10:31:21.602]                   }
[10:31:21.602]                   ...future.strategy.old <- future::plan("list")
[10:31:21.602]                   options(future.plan = NULL)
[10:31:21.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:21.602]                 }
[10:31:21.602]                 ...future.workdir <- getwd()
[10:31:21.602]             }
[10:31:21.602]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:21.602]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:21.602]         }
[10:31:21.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:21.602]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:21.602]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:21.602]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:21.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:21.602]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:21.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:21.602]             base::names(...future.oldOptions))
[10:31:21.602]     }
[10:31:21.602]     if (FALSE) {
[10:31:21.602]     }
[10:31:21.602]     else {
[10:31:21.602]         if (TRUE) {
[10:31:21.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:21.602]                 open = "w")
[10:31:21.602]         }
[10:31:21.602]         else {
[10:31:21.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:21.602]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:21.602]         }
[10:31:21.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:21.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:21.602]             base::sink(type = "output", split = FALSE)
[10:31:21.602]             base::close(...future.stdout)
[10:31:21.602]         }, add = TRUE)
[10:31:21.602]     }
[10:31:21.602]     ...future.frame <- base::sys.nframe()
[10:31:21.602]     ...future.conditions <- base::list()
[10:31:21.602]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:21.602]     if (FALSE) {
[10:31:21.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:21.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:21.602]     }
[10:31:21.602]     ...future.result <- base::tryCatch({
[10:31:21.602]         base::withCallingHandlers({
[10:31:21.602]             ...future.value <- base::withVisible(base::local({
[10:31:21.602]                 do.call(function(...) {
[10:31:21.602]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.602]                   if (!identical(...future.globals.maxSize.org, 
[10:31:21.602]                     ...future.globals.maxSize)) {
[10:31:21.602]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.602]                     on.exit(options(oopts), add = TRUE)
[10:31:21.602]                   }
[10:31:21.602]                   {
[10:31:21.602]                     lapply(seq_along(...future.elements_ii), 
[10:31:21.602]                       FUN = function(jj) {
[10:31:21.602]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.602]                         ...future.FUN(...future.X_jj, ...)
[10:31:21.602]                       })
[10:31:21.602]                   }
[10:31:21.602]                 }, args = future.call.arguments)
[10:31:21.602]             }))
[10:31:21.602]             future::FutureResult(value = ...future.value$value, 
[10:31:21.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.602]                   ...future.rng), globalenv = if (FALSE) 
[10:31:21.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:21.602]                     ...future.globalenv.names))
[10:31:21.602]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:21.602]         }, condition = base::local({
[10:31:21.602]             c <- base::c
[10:31:21.602]             inherits <- base::inherits
[10:31:21.602]             invokeRestart <- base::invokeRestart
[10:31:21.602]             length <- base::length
[10:31:21.602]             list <- base::list
[10:31:21.602]             seq.int <- base::seq.int
[10:31:21.602]             signalCondition <- base::signalCondition
[10:31:21.602]             sys.calls <- base::sys.calls
[10:31:21.602]             `[[` <- base::`[[`
[10:31:21.602]             `+` <- base::`+`
[10:31:21.602]             `<<-` <- base::`<<-`
[10:31:21.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:21.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:21.602]                   3L)]
[10:31:21.602]             }
[10:31:21.602]             function(cond) {
[10:31:21.602]                 is_error <- inherits(cond, "error")
[10:31:21.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:21.602]                   NULL)
[10:31:21.602]                 if (is_error) {
[10:31:21.602]                   sessionInformation <- function() {
[10:31:21.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:21.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:21.602]                       search = base::search(), system = base::Sys.info())
[10:31:21.602]                   }
[10:31:21.602]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:21.602]                     cond$call), session = sessionInformation(), 
[10:31:21.602]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:21.602]                   signalCondition(cond)
[10:31:21.602]                 }
[10:31:21.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:21.602]                 "immediateCondition"))) {
[10:31:21.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:21.602]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:21.602]                   if (TRUE && !signal) {
[10:31:21.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.602]                     {
[10:31:21.602]                       inherits <- base::inherits
[10:31:21.602]                       invokeRestart <- base::invokeRestart
[10:31:21.602]                       is.null <- base::is.null
[10:31:21.602]                       muffled <- FALSE
[10:31:21.602]                       if (inherits(cond, "message")) {
[10:31:21.602]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.602]                         if (muffled) 
[10:31:21.602]                           invokeRestart("muffleMessage")
[10:31:21.602]                       }
[10:31:21.602]                       else if (inherits(cond, "warning")) {
[10:31:21.602]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.602]                         if (muffled) 
[10:31:21.602]                           invokeRestart("muffleWarning")
[10:31:21.602]                       }
[10:31:21.602]                       else if (inherits(cond, "condition")) {
[10:31:21.602]                         if (!is.null(pattern)) {
[10:31:21.602]                           computeRestarts <- base::computeRestarts
[10:31:21.602]                           grepl <- base::grepl
[10:31:21.602]                           restarts <- computeRestarts(cond)
[10:31:21.602]                           for (restart in restarts) {
[10:31:21.602]                             name <- restart$name
[10:31:21.602]                             if (is.null(name)) 
[10:31:21.602]                               next
[10:31:21.602]                             if (!grepl(pattern, name)) 
[10:31:21.602]                               next
[10:31:21.602]                             invokeRestart(restart)
[10:31:21.602]                             muffled <- TRUE
[10:31:21.602]                             break
[10:31:21.602]                           }
[10:31:21.602]                         }
[10:31:21.602]                       }
[10:31:21.602]                       invisible(muffled)
[10:31:21.602]                     }
[10:31:21.602]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.602]                   }
[10:31:21.602]                 }
[10:31:21.602]                 else {
[10:31:21.602]                   if (TRUE) {
[10:31:21.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.602]                     {
[10:31:21.602]                       inherits <- base::inherits
[10:31:21.602]                       invokeRestart <- base::invokeRestart
[10:31:21.602]                       is.null <- base::is.null
[10:31:21.602]                       muffled <- FALSE
[10:31:21.602]                       if (inherits(cond, "message")) {
[10:31:21.602]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.602]                         if (muffled) 
[10:31:21.602]                           invokeRestart("muffleMessage")
[10:31:21.602]                       }
[10:31:21.602]                       else if (inherits(cond, "warning")) {
[10:31:21.602]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.602]                         if (muffled) 
[10:31:21.602]                           invokeRestart("muffleWarning")
[10:31:21.602]                       }
[10:31:21.602]                       else if (inherits(cond, "condition")) {
[10:31:21.602]                         if (!is.null(pattern)) {
[10:31:21.602]                           computeRestarts <- base::computeRestarts
[10:31:21.602]                           grepl <- base::grepl
[10:31:21.602]                           restarts <- computeRestarts(cond)
[10:31:21.602]                           for (restart in restarts) {
[10:31:21.602]                             name <- restart$name
[10:31:21.602]                             if (is.null(name)) 
[10:31:21.602]                               next
[10:31:21.602]                             if (!grepl(pattern, name)) 
[10:31:21.602]                               next
[10:31:21.602]                             invokeRestart(restart)
[10:31:21.602]                             muffled <- TRUE
[10:31:21.602]                             break
[10:31:21.602]                           }
[10:31:21.602]                         }
[10:31:21.602]                       }
[10:31:21.602]                       invisible(muffled)
[10:31:21.602]                     }
[10:31:21.602]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.602]                   }
[10:31:21.602]                 }
[10:31:21.602]             }
[10:31:21.602]         }))
[10:31:21.602]     }, error = function(ex) {
[10:31:21.602]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:21.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.602]                 ...future.rng), started = ...future.startTime, 
[10:31:21.602]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:21.602]             version = "1.8"), class = "FutureResult")
[10:31:21.602]     }, finally = {
[10:31:21.602]         if (!identical(...future.workdir, getwd())) 
[10:31:21.602]             setwd(...future.workdir)
[10:31:21.602]         {
[10:31:21.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:21.602]                 ...future.oldOptions$nwarnings <- NULL
[10:31:21.602]             }
[10:31:21.602]             base::options(...future.oldOptions)
[10:31:21.602]             if (.Platform$OS.type == "windows") {
[10:31:21.602]                 old_names <- names(...future.oldEnvVars)
[10:31:21.602]                 envs <- base::Sys.getenv()
[10:31:21.602]                 names <- names(envs)
[10:31:21.602]                 common <- intersect(names, old_names)
[10:31:21.602]                 added <- setdiff(names, old_names)
[10:31:21.602]                 removed <- setdiff(old_names, names)
[10:31:21.602]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:21.602]                   envs[common]]
[10:31:21.602]                 NAMES <- toupper(changed)
[10:31:21.602]                 args <- list()
[10:31:21.602]                 for (kk in seq_along(NAMES)) {
[10:31:21.602]                   name <- changed[[kk]]
[10:31:21.602]                   NAME <- NAMES[[kk]]
[10:31:21.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.602]                     next
[10:31:21.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.602]                 }
[10:31:21.602]                 NAMES <- toupper(added)
[10:31:21.602]                 for (kk in seq_along(NAMES)) {
[10:31:21.602]                   name <- added[[kk]]
[10:31:21.602]                   NAME <- NAMES[[kk]]
[10:31:21.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.602]                     next
[10:31:21.602]                   args[[name]] <- ""
[10:31:21.602]                 }
[10:31:21.602]                 NAMES <- toupper(removed)
[10:31:21.602]                 for (kk in seq_along(NAMES)) {
[10:31:21.602]                   name <- removed[[kk]]
[10:31:21.602]                   NAME <- NAMES[[kk]]
[10:31:21.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.602]                     next
[10:31:21.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.602]                 }
[10:31:21.602]                 if (length(args) > 0) 
[10:31:21.602]                   base::do.call(base::Sys.setenv, args = args)
[10:31:21.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:21.602]             }
[10:31:21.602]             else {
[10:31:21.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:21.602]             }
[10:31:21.602]             {
[10:31:21.602]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:21.602]                   0L) {
[10:31:21.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:21.602]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:21.602]                   base::options(opts)
[10:31:21.602]                 }
[10:31:21.602]                 {
[10:31:21.602]                   {
[10:31:21.602]                     NULL
[10:31:21.602]                     RNGkind("Mersenne-Twister")
[10:31:21.602]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:21.602]                       inherits = FALSE)
[10:31:21.602]                   }
[10:31:21.602]                   options(future.plan = NULL)
[10:31:21.602]                   if (is.na(NA_character_)) 
[10:31:21.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:21.602]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:21.602]                     .init = FALSE)
[10:31:21.602]                 }
[10:31:21.602]             }
[10:31:21.602]         }
[10:31:21.602]     })
[10:31:21.602]     if (TRUE) {
[10:31:21.602]         base::sink(type = "output", split = FALSE)
[10:31:21.602]         if (TRUE) {
[10:31:21.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:21.602]         }
[10:31:21.602]         else {
[10:31:21.602]             ...future.result["stdout"] <- base::list(NULL)
[10:31:21.602]         }
[10:31:21.602]         base::close(...future.stdout)
[10:31:21.602]         ...future.stdout <- NULL
[10:31:21.602]     }
[10:31:21.602]     ...future.result$conditions <- ...future.conditions
[10:31:21.602]     ...future.result$finished <- base::Sys.time()
[10:31:21.602]     ...future.result
[10:31:21.602] }
[10:31:21.604] assign_globals() ...
[10:31:21.604] List of 11
[10:31:21.604]  $ ...future.FUN            :function (x, ...)  
[10:31:21.604]  $ x_FUN                    :function (x)  
[10:31:21.604]  $ times                    : int 0
[10:31:21.604]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.604]  $ stop_if_not              :function (...)  
[10:31:21.604]  $ dim                      : NULL
[10:31:21.604]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:21.604]  $ future.call.arguments    : list()
[10:31:21.604]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.604]  $ ...future.elements_ii    :List of 10
[10:31:21.604]   ..$ : int 1
[10:31:21.604]   ..$ : int 2
[10:31:21.604]   ..$ : int 3
[10:31:21.604]   ..$ : int 4
[10:31:21.604]   ..$ : int 5
[10:31:21.604]   ..$ : int 6
[10:31:21.604]   ..$ : int 7
[10:31:21.604]   ..$ : int 8
[10:31:21.604]   ..$ : int 9
[10:31:21.604]   ..$ : int 10
[10:31:21.604]  $ ...future.seeds_ii       : NULL
[10:31:21.604]  $ ...future.globals.maxSize: NULL
[10:31:21.604]  - attr(*, "where")=List of 11
[10:31:21.604]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:21.604]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:21.604]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:21.604]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:21.604]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:21.604]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:21.604]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:21.604]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:21.604]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:21.604]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:21.604]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:21.604]  - attr(*, "resolved")= logi FALSE
[10:31:21.604]  - attr(*, "total_size")= num 95472
[10:31:21.604]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.604]  - attr(*, "already-done")= logi TRUE
[10:31:21.614] - copied ‘...future.FUN’ to environment
[10:31:21.614] - reassign environment for ‘x_FUN’
[10:31:21.614] - copied ‘x_FUN’ to environment
[10:31:21.614] - copied ‘times’ to environment
[10:31:21.614] - copied ‘stopf’ to environment
[10:31:21.614] - copied ‘stop_if_not’ to environment
[10:31:21.614] - copied ‘dim’ to environment
[10:31:21.614] - copied ‘valid_types’ to environment
[10:31:21.614] - copied ‘future.call.arguments’ to environment
[10:31:21.614] - copied ‘...future.elements_ii’ to environment
[10:31:21.615] - copied ‘...future.seeds_ii’ to environment
[10:31:21.615] - copied ‘...future.globals.maxSize’ to environment
[10:31:21.615] assign_globals() ... done
[10:31:21.615] plan(): Setting new future strategy stack:
[10:31:21.615] List of future strategies:
[10:31:21.615] 1. sequential:
[10:31:21.615]    - args: function (..., envir = parent.frame())
[10:31:21.615]    - tweaked: FALSE
[10:31:21.615]    - call: NULL
[10:31:21.616] plan(): nbrOfWorkers() = 1
[10:31:21.618] plan(): Setting new future strategy stack:
[10:31:21.618] List of future strategies:
[10:31:21.618] 1. sequential:
[10:31:21.618]    - args: function (..., envir = parent.frame())
[10:31:21.618]    - tweaked: FALSE
[10:31:21.618]    - call: plan(strategy)
[10:31:21.619] plan(): nbrOfWorkers() = 1
[10:31:21.619] SequentialFuture started (and completed)
[10:31:21.619] - Launch lazy future ... done
[10:31:21.619] run() for ‘SequentialFuture’ ... done
[10:31:21.619] Created future:
[10:31:21.619] SequentialFuture:
[10:31:21.619] Label: ‘future_vapply-1’
[10:31:21.619] Expression:
[10:31:21.619] {
[10:31:21.619]     do.call(function(...) {
[10:31:21.619]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.619]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.619]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.619]             on.exit(options(oopts), add = TRUE)
[10:31:21.619]         }
[10:31:21.619]         {
[10:31:21.619]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.619]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.619]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.619]             })
[10:31:21.619]         }
[10:31:21.619]     }, args = future.call.arguments)
[10:31:21.619] }
[10:31:21.619] Lazy evaluation: FALSE
[10:31:21.619] Asynchronous evaluation: FALSE
[10:31:21.619] Local evaluation: TRUE
[10:31:21.619] Environment: R_GlobalEnv
[10:31:21.619] Capture standard output: TRUE
[10:31:21.619] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:21.619] Globals: 11 objects totaling 93.78 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:21.619] Packages: 1 packages (‘future.apply’)
[10:31:21.619] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:21.619] Resolved: TRUE
[10:31:21.619] Value: 480 bytes of class ‘list’
[10:31:21.619] Early signaling: FALSE
[10:31:21.619] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:21.619] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.620] Chunk #1 of 1 ... DONE
[10:31:21.620] Launching 1 futures (chunks) ... DONE
[10:31:21.621] Resolving 1 futures (chunks) ...
[10:31:21.621] resolve() on list ...
[10:31:21.621]  recursive: 0
[10:31:21.621]  length: 1
[10:31:21.621] 
[10:31:21.621] resolved() for ‘SequentialFuture’ ...
[10:31:21.621] - state: ‘finished’
[10:31:21.621] - run: TRUE
[10:31:21.621] - result: ‘FutureResult’
[10:31:21.621] resolved() for ‘SequentialFuture’ ... done
[10:31:21.622] Future #1
[10:31:21.622] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:21.622] - nx: 1
[10:31:21.622] - relay: TRUE
[10:31:21.622] - stdout: TRUE
[10:31:21.622] - signal: TRUE
[10:31:21.622] - resignal: FALSE
[10:31:21.622] - force: TRUE
[10:31:21.622] - relayed: [n=1] FALSE
[10:31:21.622] - queued futures: [n=1] FALSE
[10:31:21.622]  - until=1
[10:31:21.623]  - relaying element #1
[10:31:21.623] - relayed: [n=1] TRUE
[10:31:21.623] - queued futures: [n=1] TRUE
[10:31:21.623] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:21.623]  length: 0 (resolved future 1)
[10:31:21.623] Relaying remaining futures
[10:31:21.623] signalConditionsASAP(NULL, pos=0) ...
[10:31:21.623] - nx: 1
[10:31:21.623] - relay: TRUE
[10:31:21.624] - stdout: TRUE
[10:31:21.624] - signal: TRUE
[10:31:21.624] - resignal: FALSE
[10:31:21.624] - force: TRUE
[10:31:21.624] - relayed: [n=1] TRUE
[10:31:21.624] - queued futures: [n=1] TRUE
 - flush all
[10:31:21.624] - relayed: [n=1] TRUE
[10:31:21.624] - queued futures: [n=1] TRUE
[10:31:21.624] signalConditionsASAP(NULL, pos=0) ... done
[10:31:21.624] resolve() on list ... DONE
[10:31:21.624]  - Number of value chunks collected: 1
[10:31:21.625] Resolving 1 futures (chunks) ... DONE
[10:31:21.625] Reducing values from 1 chunks ...
[10:31:21.625]  - Number of values collected after concatenation: 10
[10:31:21.625]  - Number of values expected: 10
[10:31:21.625] Reducing values from 1 chunks ... DONE
[10:31:21.625] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[10:31:21.626] future_lapply() ...
[10:31:21.628] Number of chunks: 1
[10:31:21.628] getGlobalsAndPackagesXApply() ...
[10:31:21.628]  - future.globals: TRUE
[10:31:21.628] getGlobalsAndPackages() ...
[10:31:21.628] Searching for globals...
[10:31:21.631] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[10:31:21.631] Searching for globals ... DONE
[10:31:21.632] Resolving globals: FALSE
[10:31:21.632] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[10:31:21.633] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:21.633] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.633] - packages: [1] ‘future.apply’
[10:31:21.633] getGlobalsAndPackages() ... DONE
[10:31:21.633]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.633]  - needed namespaces: [n=1] ‘future.apply’
[10:31:21.633] Finding globals ... DONE
[10:31:21.634]  - use_args: TRUE
[10:31:21.634]  - Getting '...' globals ...
[10:31:21.634] resolve() on list ...
[10:31:21.634]  recursive: 0
[10:31:21.634]  length: 1
[10:31:21.634]  elements: ‘...’
[10:31:21.634]  length: 0 (resolved future 1)
[10:31:21.634] resolve() on list ... DONE
[10:31:21.635]    - '...' content: [n=0] 
[10:31:21.635] List of 1
[10:31:21.635]  $ ...: list()
[10:31:21.635]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.635]  - attr(*, "where")=List of 1
[10:31:21.635]   ..$ ...:<environment: 0x55de8524b850> 
[10:31:21.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.635]  - attr(*, "resolved")= logi TRUE
[10:31:21.635]  - attr(*, "total_size")= num NA
[10:31:21.637]  - Getting '...' globals ... DONE
[10:31:21.637] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:21.637] List of 8
[10:31:21.637]  $ ...future.FUN:function (x, ...)  
[10:31:21.637]  $ x_FUN        :function (x)  
[10:31:21.637]  $ times        : int 0
[10:31:21.637]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.637]  $ stop_if_not  :function (...)  
[10:31:21.637]  $ dim          : NULL
[10:31:21.637]  $ valid_types  : chr [1:2] "logical" "integer"
[10:31:21.637]  $ ...          : list()
[10:31:21.637]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.637]  - attr(*, "where")=List of 8
[10:31:21.637]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:21.637]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:21.637]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:21.637]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:21.637]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:21.637]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:21.637]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:21.637]   ..$ ...          :<environment: 0x55de8524b850> 
[10:31:21.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.637]  - attr(*, "resolved")= logi FALSE
[10:31:21.637]  - attr(*, "total_size")= num 95400
[10:31:21.644] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:21.644] getGlobalsAndPackagesXApply() ... DONE
[10:31:21.644] Number of futures (= number of chunks): 1
[10:31:21.644] Launching 1 futures (chunks) ...
[10:31:21.644] Chunk #1 of 1 ...
[10:31:21.645]  - Finding globals in 'X' for chunk #1 ...
[10:31:21.645] getGlobalsAndPackages() ...
[10:31:21.645] Searching for globals...
[10:31:21.645] 
[10:31:21.645] Searching for globals ... DONE
[10:31:21.645] - globals: [0] <none>
[10:31:21.645] getGlobalsAndPackages() ... DONE
[10:31:21.645]    + additional globals found: [n=0] 
[10:31:21.646]    + additional namespaces needed: [n=0] 
[10:31:21.646]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:21.646]  - seeds: <none>
[10:31:21.646]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.646] getGlobalsAndPackages() ...
[10:31:21.646] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.646] Resolving globals: FALSE
[10:31:21.646] Tweak future expression to call with '...' arguments ...
[10:31:21.646] {
[10:31:21.646]     do.call(function(...) {
[10:31:21.646]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.646]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.646]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.646]             on.exit(options(oopts), add = TRUE)
[10:31:21.646]         }
[10:31:21.646]         {
[10:31:21.646]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.646]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.646]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.646]             })
[10:31:21.646]         }
[10:31:21.646]     }, args = future.call.arguments)
[10:31:21.646] }
[10:31:21.647] Tweak future expression to call with '...' arguments ... DONE
[10:31:21.647] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.647] - packages: [1] ‘future.apply’
[10:31:21.647] getGlobalsAndPackages() ... DONE
[10:31:21.648] run() for ‘Future’ ...
[10:31:21.648] - state: ‘created’
[10:31:21.648] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:21.648] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.648] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:21.648]   - Field: ‘label’
[10:31:21.649]   - Field: ‘local’
[10:31:21.649]   - Field: ‘owner’
[10:31:21.649]   - Field: ‘envir’
[10:31:21.649]   - Field: ‘packages’
[10:31:21.649]   - Field: ‘gc’
[10:31:21.649]   - Field: ‘conditions’
[10:31:21.649]   - Field: ‘expr’
[10:31:21.649]   - Field: ‘uuid’
[10:31:21.649]   - Field: ‘seed’
[10:31:21.649]   - Field: ‘version’
[10:31:21.649]   - Field: ‘result’
[10:31:21.650]   - Field: ‘asynchronous’
[10:31:21.650]   - Field: ‘calls’
[10:31:21.650]   - Field: ‘globals’
[10:31:21.650]   - Field: ‘stdout’
[10:31:21.650]   - Field: ‘earlySignal’
[10:31:21.650]   - Field: ‘lazy’
[10:31:21.650]   - Field: ‘state’
[10:31:21.650] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:21.650] - Launch lazy future ...
[10:31:21.650] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:21.651] Packages needed by future strategies (n = 0): <none>
[10:31:21.651] {
[10:31:21.651]     {
[10:31:21.651]         {
[10:31:21.651]             ...future.startTime <- base::Sys.time()
[10:31:21.651]             {
[10:31:21.651]                 {
[10:31:21.651]                   {
[10:31:21.651]                     {
[10:31:21.651]                       base::local({
[10:31:21.651]                         has_future <- base::requireNamespace("future", 
[10:31:21.651]                           quietly = TRUE)
[10:31:21.651]                         if (has_future) {
[10:31:21.651]                           ns <- base::getNamespace("future")
[10:31:21.651]                           version <- ns[[".package"]][["version"]]
[10:31:21.651]                           if (is.null(version)) 
[10:31:21.651]                             version <- utils::packageVersion("future")
[10:31:21.651]                         }
[10:31:21.651]                         else {
[10:31:21.651]                           version <- NULL
[10:31:21.651]                         }
[10:31:21.651]                         if (!has_future || version < "1.8.0") {
[10:31:21.651]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:21.651]                             "", base::R.version$version.string), 
[10:31:21.651]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:21.651]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:21.651]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:21.651]                               "release", "version")], collapse = " "), 
[10:31:21.651]                             hostname = base::Sys.info()[["nodename"]])
[10:31:21.651]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:21.651]                             info)
[10:31:21.651]                           info <- base::paste(info, collapse = "; ")
[10:31:21.651]                           if (!has_future) {
[10:31:21.651]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:21.651]                               info)
[10:31:21.651]                           }
[10:31:21.651]                           else {
[10:31:21.651]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:21.651]                               info, version)
[10:31:21.651]                           }
[10:31:21.651]                           base::stop(msg)
[10:31:21.651]                         }
[10:31:21.651]                       })
[10:31:21.651]                     }
[10:31:21.651]                     base::local({
[10:31:21.651]                       for (pkg in "future.apply") {
[10:31:21.651]                         base::loadNamespace(pkg)
[10:31:21.651]                         base::library(pkg, character.only = TRUE)
[10:31:21.651]                       }
[10:31:21.651]                     })
[10:31:21.651]                   }
[10:31:21.651]                   ...future.strategy.old <- future::plan("list")
[10:31:21.651]                   options(future.plan = NULL)
[10:31:21.651]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.651]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:21.651]                 }
[10:31:21.651]                 ...future.workdir <- getwd()
[10:31:21.651]             }
[10:31:21.651]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:21.651]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:21.651]         }
[10:31:21.651]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:21.651]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:21.651]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:21.651]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:21.651]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:21.651]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:21.651]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:21.651]             base::names(...future.oldOptions))
[10:31:21.651]     }
[10:31:21.651]     if (FALSE) {
[10:31:21.651]     }
[10:31:21.651]     else {
[10:31:21.651]         if (TRUE) {
[10:31:21.651]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:21.651]                 open = "w")
[10:31:21.651]         }
[10:31:21.651]         else {
[10:31:21.651]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:21.651]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:21.651]         }
[10:31:21.651]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:21.651]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:21.651]             base::sink(type = "output", split = FALSE)
[10:31:21.651]             base::close(...future.stdout)
[10:31:21.651]         }, add = TRUE)
[10:31:21.651]     }
[10:31:21.651]     ...future.frame <- base::sys.nframe()
[10:31:21.651]     ...future.conditions <- base::list()
[10:31:21.651]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:21.651]     if (FALSE) {
[10:31:21.651]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:21.651]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:21.651]     }
[10:31:21.651]     ...future.result <- base::tryCatch({
[10:31:21.651]         base::withCallingHandlers({
[10:31:21.651]             ...future.value <- base::withVisible(base::local({
[10:31:21.651]                 do.call(function(...) {
[10:31:21.651]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.651]                   if (!identical(...future.globals.maxSize.org, 
[10:31:21.651]                     ...future.globals.maxSize)) {
[10:31:21.651]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.651]                     on.exit(options(oopts), add = TRUE)
[10:31:21.651]                   }
[10:31:21.651]                   {
[10:31:21.651]                     lapply(seq_along(...future.elements_ii), 
[10:31:21.651]                       FUN = function(jj) {
[10:31:21.651]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.651]                         ...future.FUN(...future.X_jj, ...)
[10:31:21.651]                       })
[10:31:21.651]                   }
[10:31:21.651]                 }, args = future.call.arguments)
[10:31:21.651]             }))
[10:31:21.651]             future::FutureResult(value = ...future.value$value, 
[10:31:21.651]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.651]                   ...future.rng), globalenv = if (FALSE) 
[10:31:21.651]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:21.651]                     ...future.globalenv.names))
[10:31:21.651]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:21.651]         }, condition = base::local({
[10:31:21.651]             c <- base::c
[10:31:21.651]             inherits <- base::inherits
[10:31:21.651]             invokeRestart <- base::invokeRestart
[10:31:21.651]             length <- base::length
[10:31:21.651]             list <- base::list
[10:31:21.651]             seq.int <- base::seq.int
[10:31:21.651]             signalCondition <- base::signalCondition
[10:31:21.651]             sys.calls <- base::sys.calls
[10:31:21.651]             `[[` <- base::`[[`
[10:31:21.651]             `+` <- base::`+`
[10:31:21.651]             `<<-` <- base::`<<-`
[10:31:21.651]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:21.651]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:21.651]                   3L)]
[10:31:21.651]             }
[10:31:21.651]             function(cond) {
[10:31:21.651]                 is_error <- inherits(cond, "error")
[10:31:21.651]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:21.651]                   NULL)
[10:31:21.651]                 if (is_error) {
[10:31:21.651]                   sessionInformation <- function() {
[10:31:21.651]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:21.651]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:21.651]                       search = base::search(), system = base::Sys.info())
[10:31:21.651]                   }
[10:31:21.651]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.651]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:21.651]                     cond$call), session = sessionInformation(), 
[10:31:21.651]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:21.651]                   signalCondition(cond)
[10:31:21.651]                 }
[10:31:21.651]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:21.651]                 "immediateCondition"))) {
[10:31:21.651]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:21.651]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.651]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:21.651]                   if (TRUE && !signal) {
[10:31:21.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.651]                     {
[10:31:21.651]                       inherits <- base::inherits
[10:31:21.651]                       invokeRestart <- base::invokeRestart
[10:31:21.651]                       is.null <- base::is.null
[10:31:21.651]                       muffled <- FALSE
[10:31:21.651]                       if (inherits(cond, "message")) {
[10:31:21.651]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.651]                         if (muffled) 
[10:31:21.651]                           invokeRestart("muffleMessage")
[10:31:21.651]                       }
[10:31:21.651]                       else if (inherits(cond, "warning")) {
[10:31:21.651]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.651]                         if (muffled) 
[10:31:21.651]                           invokeRestart("muffleWarning")
[10:31:21.651]                       }
[10:31:21.651]                       else if (inherits(cond, "condition")) {
[10:31:21.651]                         if (!is.null(pattern)) {
[10:31:21.651]                           computeRestarts <- base::computeRestarts
[10:31:21.651]                           grepl <- base::grepl
[10:31:21.651]                           restarts <- computeRestarts(cond)
[10:31:21.651]                           for (restart in restarts) {
[10:31:21.651]                             name <- restart$name
[10:31:21.651]                             if (is.null(name)) 
[10:31:21.651]                               next
[10:31:21.651]                             if (!grepl(pattern, name)) 
[10:31:21.651]                               next
[10:31:21.651]                             invokeRestart(restart)
[10:31:21.651]                             muffled <- TRUE
[10:31:21.651]                             break
[10:31:21.651]                           }
[10:31:21.651]                         }
[10:31:21.651]                       }
[10:31:21.651]                       invisible(muffled)
[10:31:21.651]                     }
[10:31:21.651]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.651]                   }
[10:31:21.651]                 }
[10:31:21.651]                 else {
[10:31:21.651]                   if (TRUE) {
[10:31:21.651]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.651]                     {
[10:31:21.651]                       inherits <- base::inherits
[10:31:21.651]                       invokeRestart <- base::invokeRestart
[10:31:21.651]                       is.null <- base::is.null
[10:31:21.651]                       muffled <- FALSE
[10:31:21.651]                       if (inherits(cond, "message")) {
[10:31:21.651]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.651]                         if (muffled) 
[10:31:21.651]                           invokeRestart("muffleMessage")
[10:31:21.651]                       }
[10:31:21.651]                       else if (inherits(cond, "warning")) {
[10:31:21.651]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.651]                         if (muffled) 
[10:31:21.651]                           invokeRestart("muffleWarning")
[10:31:21.651]                       }
[10:31:21.651]                       else if (inherits(cond, "condition")) {
[10:31:21.651]                         if (!is.null(pattern)) {
[10:31:21.651]                           computeRestarts <- base::computeRestarts
[10:31:21.651]                           grepl <- base::grepl
[10:31:21.651]                           restarts <- computeRestarts(cond)
[10:31:21.651]                           for (restart in restarts) {
[10:31:21.651]                             name <- restart$name
[10:31:21.651]                             if (is.null(name)) 
[10:31:21.651]                               next
[10:31:21.651]                             if (!grepl(pattern, name)) 
[10:31:21.651]                               next
[10:31:21.651]                             invokeRestart(restart)
[10:31:21.651]                             muffled <- TRUE
[10:31:21.651]                             break
[10:31:21.651]                           }
[10:31:21.651]                         }
[10:31:21.651]                       }
[10:31:21.651]                       invisible(muffled)
[10:31:21.651]                     }
[10:31:21.651]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.651]                   }
[10:31:21.651]                 }
[10:31:21.651]             }
[10:31:21.651]         }))
[10:31:21.651]     }, error = function(ex) {
[10:31:21.651]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:21.651]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.651]                 ...future.rng), started = ...future.startTime, 
[10:31:21.651]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:21.651]             version = "1.8"), class = "FutureResult")
[10:31:21.651]     }, finally = {
[10:31:21.651]         if (!identical(...future.workdir, getwd())) 
[10:31:21.651]             setwd(...future.workdir)
[10:31:21.651]         {
[10:31:21.651]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:21.651]                 ...future.oldOptions$nwarnings <- NULL
[10:31:21.651]             }
[10:31:21.651]             base::options(...future.oldOptions)
[10:31:21.651]             if (.Platform$OS.type == "windows") {
[10:31:21.651]                 old_names <- names(...future.oldEnvVars)
[10:31:21.651]                 envs <- base::Sys.getenv()
[10:31:21.651]                 names <- names(envs)
[10:31:21.651]                 common <- intersect(names, old_names)
[10:31:21.651]                 added <- setdiff(names, old_names)
[10:31:21.651]                 removed <- setdiff(old_names, names)
[10:31:21.651]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:21.651]                   envs[common]]
[10:31:21.651]                 NAMES <- toupper(changed)
[10:31:21.651]                 args <- list()
[10:31:21.651]                 for (kk in seq_along(NAMES)) {
[10:31:21.651]                   name <- changed[[kk]]
[10:31:21.651]                   NAME <- NAMES[[kk]]
[10:31:21.651]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.651]                     next
[10:31:21.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.651]                 }
[10:31:21.651]                 NAMES <- toupper(added)
[10:31:21.651]                 for (kk in seq_along(NAMES)) {
[10:31:21.651]                   name <- added[[kk]]
[10:31:21.651]                   NAME <- NAMES[[kk]]
[10:31:21.651]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.651]                     next
[10:31:21.651]                   args[[name]] <- ""
[10:31:21.651]                 }
[10:31:21.651]                 NAMES <- toupper(removed)
[10:31:21.651]                 for (kk in seq_along(NAMES)) {
[10:31:21.651]                   name <- removed[[kk]]
[10:31:21.651]                   NAME <- NAMES[[kk]]
[10:31:21.651]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.651]                     next
[10:31:21.651]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.651]                 }
[10:31:21.651]                 if (length(args) > 0) 
[10:31:21.651]                   base::do.call(base::Sys.setenv, args = args)
[10:31:21.651]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:21.651]             }
[10:31:21.651]             else {
[10:31:21.651]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:21.651]             }
[10:31:21.651]             {
[10:31:21.651]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:21.651]                   0L) {
[10:31:21.651]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:21.651]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:21.651]                   base::options(opts)
[10:31:21.651]                 }
[10:31:21.651]                 {
[10:31:21.651]                   {
[10:31:21.651]                     NULL
[10:31:21.651]                     RNGkind("Mersenne-Twister")
[10:31:21.651]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:21.651]                       inherits = FALSE)
[10:31:21.651]                   }
[10:31:21.651]                   options(future.plan = NULL)
[10:31:21.651]                   if (is.na(NA_character_)) 
[10:31:21.651]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.651]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:21.651]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:21.651]                     .init = FALSE)
[10:31:21.651]                 }
[10:31:21.651]             }
[10:31:21.651]         }
[10:31:21.651]     })
[10:31:21.651]     if (TRUE) {
[10:31:21.651]         base::sink(type = "output", split = FALSE)
[10:31:21.651]         if (TRUE) {
[10:31:21.651]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:21.651]         }
[10:31:21.651]         else {
[10:31:21.651]             ...future.result["stdout"] <- base::list(NULL)
[10:31:21.651]         }
[10:31:21.651]         base::close(...future.stdout)
[10:31:21.651]         ...future.stdout <- NULL
[10:31:21.651]     }
[10:31:21.651]     ...future.result$conditions <- ...future.conditions
[10:31:21.651]     ...future.result$finished <- base::Sys.time()
[10:31:21.651]     ...future.result
[10:31:21.651] }
[10:31:21.653] assign_globals() ...
[10:31:21.653] List of 11
[10:31:21.653]  $ ...future.FUN            :function (x, ...)  
[10:31:21.653]  $ x_FUN                    :function (x)  
[10:31:21.653]  $ times                    : int 0
[10:31:21.653]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.653]  $ stop_if_not              :function (...)  
[10:31:21.653]  $ dim                      : NULL
[10:31:21.653]  $ valid_types              : chr [1:2] "logical" "integer"
[10:31:21.653]  $ future.call.arguments    : list()
[10:31:21.653]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.653]  $ ...future.elements_ii    :List of 10
[10:31:21.653]   ..$ : int 1
[10:31:21.653]   ..$ : int 2
[10:31:21.653]   ..$ : int 3
[10:31:21.653]   ..$ : int 4
[10:31:21.653]   ..$ : int 5
[10:31:21.653]   ..$ : int 6
[10:31:21.653]   ..$ : int 7
[10:31:21.653]   ..$ : int 8
[10:31:21.653]   ..$ : int 9
[10:31:21.653]   ..$ : int 10
[10:31:21.653]  $ ...future.seeds_ii       : NULL
[10:31:21.653]  $ ...future.globals.maxSize: NULL
[10:31:21.653]  - attr(*, "where")=List of 11
[10:31:21.653]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:21.653]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:21.653]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:21.653]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:21.653]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:21.653]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:21.653]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:21.653]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:21.653]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:21.653]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:21.653]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:21.653]  - attr(*, "resolved")= logi FALSE
[10:31:21.653]  - attr(*, "total_size")= num 95400
[10:31:21.653]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.653]  - attr(*, "already-done")= logi TRUE
[10:31:21.664] - copied ‘...future.FUN’ to environment
[10:31:21.665] - reassign environment for ‘x_FUN’
[10:31:21.665] - copied ‘x_FUN’ to environment
[10:31:21.665] - copied ‘times’ to environment
[10:31:21.665] - copied ‘stopf’ to environment
[10:31:21.665] - copied ‘stop_if_not’ to environment
[10:31:21.665] - copied ‘dim’ to environment
[10:31:21.665] - copied ‘valid_types’ to environment
[10:31:21.665] - copied ‘future.call.arguments’ to environment
[10:31:21.665] - copied ‘...future.elements_ii’ to environment
[10:31:21.666] - copied ‘...future.seeds_ii’ to environment
[10:31:21.666] - copied ‘...future.globals.maxSize’ to environment
[10:31:21.666] assign_globals() ... done
[10:31:21.666] plan(): Setting new future strategy stack:
[10:31:21.666] List of future strategies:
[10:31:21.666] 1. sequential:
[10:31:21.666]    - args: function (..., envir = parent.frame())
[10:31:21.666]    - tweaked: FALSE
[10:31:21.666]    - call: NULL
[10:31:21.667] plan(): nbrOfWorkers() = 1
[10:31:21.667] plan(): Setting new future strategy stack:
[10:31:21.667] List of future strategies:
[10:31:21.667] 1. sequential:
[10:31:21.667]    - args: function (..., envir = parent.frame())
[10:31:21.667]    - tweaked: FALSE
[10:31:21.667]    - call: plan(strategy)
[10:31:21.668] plan(): nbrOfWorkers() = 1
[10:31:21.668] SequentialFuture started (and completed)
[10:31:21.668] - Launch lazy future ... done
[10:31:21.668] run() for ‘SequentialFuture’ ... done
[10:31:21.668] Created future:
[10:31:21.668] SequentialFuture:
[10:31:21.668] Label: ‘future_vapply-1’
[10:31:21.668] Expression:
[10:31:21.668] {
[10:31:21.668]     do.call(function(...) {
[10:31:21.668]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.668]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.668]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.668]             on.exit(options(oopts), add = TRUE)
[10:31:21.668]         }
[10:31:21.668]         {
[10:31:21.668]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.668]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.668]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.668]             })
[10:31:21.668]         }
[10:31:21.668]     }, args = future.call.arguments)
[10:31:21.668] }
[10:31:21.668] Lazy evaluation: FALSE
[10:31:21.668] Asynchronous evaluation: FALSE
[10:31:21.668] Local evaluation: TRUE
[10:31:21.668] Environment: R_GlobalEnv
[10:31:21.668] Capture standard output: TRUE
[10:31:21.668] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:21.668] Globals: 11 objects totaling 93.71 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:21.668] Packages: 1 packages (‘future.apply’)
[10:31:21.668] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:21.668] Resolved: TRUE
[10:31:21.668] Value: 480 bytes of class ‘list’
[10:31:21.668] Early signaling: FALSE
[10:31:21.668] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:21.668] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.670] Chunk #1 of 1 ... DONE
[10:31:21.670] Launching 1 futures (chunks) ... DONE
[10:31:21.670] Resolving 1 futures (chunks) ...
[10:31:21.670] resolve() on list ...
[10:31:21.670]  recursive: 0
[10:31:21.670]  length: 1
[10:31:21.670] 
[10:31:21.670] resolved() for ‘SequentialFuture’ ...
[10:31:21.670] - state: ‘finished’
[10:31:21.671] - run: TRUE
[10:31:21.671] - result: ‘FutureResult’
[10:31:21.671] resolved() for ‘SequentialFuture’ ... done
[10:31:21.671] Future #1
[10:31:21.671] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:21.671] - nx: 1
[10:31:21.671] - relay: TRUE
[10:31:21.671] - stdout: TRUE
[10:31:21.671] - signal: TRUE
[10:31:21.671] - resignal: FALSE
[10:31:21.671] - force: TRUE
[10:31:21.672] - relayed: [n=1] FALSE
[10:31:21.672] - queued futures: [n=1] FALSE
[10:31:21.672]  - until=1
[10:31:21.672]  - relaying element #1
[10:31:21.672] - relayed: [n=1] TRUE
[10:31:21.672] - queued futures: [n=1] TRUE
[10:31:21.672] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:21.672]  length: 0 (resolved future 1)
[10:31:21.672] Relaying remaining futures
[10:31:21.673] signalConditionsASAP(NULL, pos=0) ...
[10:31:21.673] - nx: 1
[10:31:21.673] - relay: TRUE
[10:31:21.673] - stdout: TRUE
[10:31:21.673] - signal: TRUE
[10:31:21.673] - resignal: FALSE
[10:31:21.673] - force: TRUE
[10:31:21.673] - relayed: [n=1] TRUE
[10:31:21.673] - queued futures: [n=1] TRUE
 - flush all
[10:31:21.673] - relayed: [n=1] TRUE
[10:31:21.673] - queued futures: [n=1] TRUE
[10:31:21.674] signalConditionsASAP(NULL, pos=0) ... done
[10:31:21.674] resolve() on list ... DONE
[10:31:21.674]  - Number of value chunks collected: 1
[10:31:21.674] Resolving 1 futures (chunks) ... DONE
[10:31:21.674] Reducing values from 1 chunks ...
[10:31:21.674]  - Number of values collected after concatenation: 10
[10:31:21.674]  - Number of values expected: 10
[10:31:21.674] Reducing values from 1 chunks ... DONE
[10:31:21.674] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[10:31:21.675] future_lapply() ...
[10:31:21.677] Number of chunks: 1
[10:31:21.677] getGlobalsAndPackagesXApply() ...
[10:31:21.677]  - future.globals: TRUE
[10:31:21.677] getGlobalsAndPackages() ...
[10:31:21.677] Searching for globals...
[10:31:21.680] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:21.680] Searching for globals ... DONE
[10:31:21.680] Resolving globals: FALSE
[10:31:21.681] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[10:31:21.682] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:21.682] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.682] - packages: [1] ‘future.apply’
[10:31:21.682] getGlobalsAndPackages() ... DONE
[10:31:21.682]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.682]  - needed namespaces: [n=1] ‘future.apply’
[10:31:21.682] Finding globals ... DONE
[10:31:21.683]  - use_args: TRUE
[10:31:21.683]  - Getting '...' globals ...
[10:31:21.683] resolve() on list ...
[10:31:21.683]  recursive: 0
[10:31:21.683]  length: 1
[10:31:21.683]  elements: ‘...’
[10:31:21.683]  length: 0 (resolved future 1)
[10:31:21.683] resolve() on list ... DONE
[10:31:21.683]    - '...' content: [n=0] 
[10:31:21.684] List of 1
[10:31:21.684]  $ ...: list()
[10:31:21.684]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.684]  - attr(*, "where")=List of 1
[10:31:21.684]   ..$ ...:<environment: 0x55de85929578> 
[10:31:21.684]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.684]  - attr(*, "resolved")= logi TRUE
[10:31:21.684]  - attr(*, "total_size")= num NA
[10:31:21.688]  - Getting '...' globals ... DONE
[10:31:21.688] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:21.688] List of 8
[10:31:21.688]  $ ...future.FUN:function (x, ...)  
[10:31:21.688]  $ x_FUN        :function (x)  
[10:31:21.688]  $ times        : int 1
[10:31:21.688]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.688]  $ stop_if_not  :function (...)  
[10:31:21.688]  $ dim          : NULL
[10:31:21.688]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:21.688]  $ ...          : list()
[10:31:21.688]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.688]  - attr(*, "where")=List of 8
[10:31:21.688]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:21.688]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:21.688]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:21.688]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:21.688]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:21.688]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:21.688]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:21.688]   ..$ ...          :<environment: 0x55de85929578> 
[10:31:21.688]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.688]  - attr(*, "resolved")= logi FALSE
[10:31:21.688]  - attr(*, "total_size")= num 94336
[10:31:21.694] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:21.694] getGlobalsAndPackagesXApply() ... DONE
[10:31:21.694] Number of futures (= number of chunks): 1
[10:31:21.694] Launching 1 futures (chunks) ...
[10:31:21.694] Chunk #1 of 1 ...
[10:31:21.694]  - Finding globals in 'X' for chunk #1 ...
[10:31:21.695] getGlobalsAndPackages() ...
[10:31:21.695] Searching for globals...
[10:31:21.695] 
[10:31:21.695] Searching for globals ... DONE
[10:31:21.695] - globals: [0] <none>
[10:31:21.695] getGlobalsAndPackages() ... DONE
[10:31:21.695]    + additional globals found: [n=0] 
[10:31:21.695]    + additional namespaces needed: [n=0] 
[10:31:21.695]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:21.696]  - seeds: <none>
[10:31:21.696]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.696] getGlobalsAndPackages() ...
[10:31:21.696] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.696] Resolving globals: FALSE
[10:31:21.696] Tweak future expression to call with '...' arguments ...
[10:31:21.696] {
[10:31:21.696]     do.call(function(...) {
[10:31:21.696]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.696]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.696]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.696]             on.exit(options(oopts), add = TRUE)
[10:31:21.696]         }
[10:31:21.696]         {
[10:31:21.696]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.696]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.696]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.696]             })
[10:31:21.696]         }
[10:31:21.696]     }, args = future.call.arguments)
[10:31:21.696] }
[10:31:21.696] Tweak future expression to call with '...' arguments ... DONE
[10:31:21.697] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.697] - packages: [1] ‘future.apply’
[10:31:21.697] getGlobalsAndPackages() ... DONE
[10:31:21.698] run() for ‘Future’ ...
[10:31:21.698] - state: ‘created’
[10:31:21.698] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:21.698] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.698] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:21.698]   - Field: ‘label’
[10:31:21.698]   - Field: ‘local’
[10:31:21.698]   - Field: ‘owner’
[10:31:21.699]   - Field: ‘envir’
[10:31:21.699]   - Field: ‘packages’
[10:31:21.699]   - Field: ‘gc’
[10:31:21.699]   - Field: ‘conditions’
[10:31:21.699]   - Field: ‘expr’
[10:31:21.699]   - Field: ‘uuid’
[10:31:21.699]   - Field: ‘seed’
[10:31:21.699]   - Field: ‘version’
[10:31:21.699]   - Field: ‘result’
[10:31:21.699]   - Field: ‘asynchronous’
[10:31:21.699]   - Field: ‘calls’
[10:31:21.700]   - Field: ‘globals’
[10:31:21.700]   - Field: ‘stdout’
[10:31:21.700]   - Field: ‘earlySignal’
[10:31:21.700]   - Field: ‘lazy’
[10:31:21.700]   - Field: ‘state’
[10:31:21.700] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:21.700] - Launch lazy future ...
[10:31:21.700] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:21.700] Packages needed by future strategies (n = 0): <none>
[10:31:21.701] {
[10:31:21.701]     {
[10:31:21.701]         {
[10:31:21.701]             ...future.startTime <- base::Sys.time()
[10:31:21.701]             {
[10:31:21.701]                 {
[10:31:21.701]                   {
[10:31:21.701]                     {
[10:31:21.701]                       base::local({
[10:31:21.701]                         has_future <- base::requireNamespace("future", 
[10:31:21.701]                           quietly = TRUE)
[10:31:21.701]                         if (has_future) {
[10:31:21.701]                           ns <- base::getNamespace("future")
[10:31:21.701]                           version <- ns[[".package"]][["version"]]
[10:31:21.701]                           if (is.null(version)) 
[10:31:21.701]                             version <- utils::packageVersion("future")
[10:31:21.701]                         }
[10:31:21.701]                         else {
[10:31:21.701]                           version <- NULL
[10:31:21.701]                         }
[10:31:21.701]                         if (!has_future || version < "1.8.0") {
[10:31:21.701]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:21.701]                             "", base::R.version$version.string), 
[10:31:21.701]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:21.701]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:21.701]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:21.701]                               "release", "version")], collapse = " "), 
[10:31:21.701]                             hostname = base::Sys.info()[["nodename"]])
[10:31:21.701]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:21.701]                             info)
[10:31:21.701]                           info <- base::paste(info, collapse = "; ")
[10:31:21.701]                           if (!has_future) {
[10:31:21.701]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:21.701]                               info)
[10:31:21.701]                           }
[10:31:21.701]                           else {
[10:31:21.701]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:21.701]                               info, version)
[10:31:21.701]                           }
[10:31:21.701]                           base::stop(msg)
[10:31:21.701]                         }
[10:31:21.701]                       })
[10:31:21.701]                     }
[10:31:21.701]                     base::local({
[10:31:21.701]                       for (pkg in "future.apply") {
[10:31:21.701]                         base::loadNamespace(pkg)
[10:31:21.701]                         base::library(pkg, character.only = TRUE)
[10:31:21.701]                       }
[10:31:21.701]                     })
[10:31:21.701]                   }
[10:31:21.701]                   ...future.strategy.old <- future::plan("list")
[10:31:21.701]                   options(future.plan = NULL)
[10:31:21.701]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.701]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:21.701]                 }
[10:31:21.701]                 ...future.workdir <- getwd()
[10:31:21.701]             }
[10:31:21.701]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:21.701]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:21.701]         }
[10:31:21.701]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:21.701]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:21.701]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:21.701]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:21.701]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:21.701]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:21.701]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:21.701]             base::names(...future.oldOptions))
[10:31:21.701]     }
[10:31:21.701]     if (FALSE) {
[10:31:21.701]     }
[10:31:21.701]     else {
[10:31:21.701]         if (TRUE) {
[10:31:21.701]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:21.701]                 open = "w")
[10:31:21.701]         }
[10:31:21.701]         else {
[10:31:21.701]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:21.701]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:21.701]         }
[10:31:21.701]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:21.701]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:21.701]             base::sink(type = "output", split = FALSE)
[10:31:21.701]             base::close(...future.stdout)
[10:31:21.701]         }, add = TRUE)
[10:31:21.701]     }
[10:31:21.701]     ...future.frame <- base::sys.nframe()
[10:31:21.701]     ...future.conditions <- base::list()
[10:31:21.701]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:21.701]     if (FALSE) {
[10:31:21.701]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:21.701]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:21.701]     }
[10:31:21.701]     ...future.result <- base::tryCatch({
[10:31:21.701]         base::withCallingHandlers({
[10:31:21.701]             ...future.value <- base::withVisible(base::local({
[10:31:21.701]                 do.call(function(...) {
[10:31:21.701]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.701]                   if (!identical(...future.globals.maxSize.org, 
[10:31:21.701]                     ...future.globals.maxSize)) {
[10:31:21.701]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.701]                     on.exit(options(oopts), add = TRUE)
[10:31:21.701]                   }
[10:31:21.701]                   {
[10:31:21.701]                     lapply(seq_along(...future.elements_ii), 
[10:31:21.701]                       FUN = function(jj) {
[10:31:21.701]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.701]                         ...future.FUN(...future.X_jj, ...)
[10:31:21.701]                       })
[10:31:21.701]                   }
[10:31:21.701]                 }, args = future.call.arguments)
[10:31:21.701]             }))
[10:31:21.701]             future::FutureResult(value = ...future.value$value, 
[10:31:21.701]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.701]                   ...future.rng), globalenv = if (FALSE) 
[10:31:21.701]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:21.701]                     ...future.globalenv.names))
[10:31:21.701]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:21.701]         }, condition = base::local({
[10:31:21.701]             c <- base::c
[10:31:21.701]             inherits <- base::inherits
[10:31:21.701]             invokeRestart <- base::invokeRestart
[10:31:21.701]             length <- base::length
[10:31:21.701]             list <- base::list
[10:31:21.701]             seq.int <- base::seq.int
[10:31:21.701]             signalCondition <- base::signalCondition
[10:31:21.701]             sys.calls <- base::sys.calls
[10:31:21.701]             `[[` <- base::`[[`
[10:31:21.701]             `+` <- base::`+`
[10:31:21.701]             `<<-` <- base::`<<-`
[10:31:21.701]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:21.701]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:21.701]                   3L)]
[10:31:21.701]             }
[10:31:21.701]             function(cond) {
[10:31:21.701]                 is_error <- inherits(cond, "error")
[10:31:21.701]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:21.701]                   NULL)
[10:31:21.701]                 if (is_error) {
[10:31:21.701]                   sessionInformation <- function() {
[10:31:21.701]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:21.701]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:21.701]                       search = base::search(), system = base::Sys.info())
[10:31:21.701]                   }
[10:31:21.701]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.701]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:21.701]                     cond$call), session = sessionInformation(), 
[10:31:21.701]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:21.701]                   signalCondition(cond)
[10:31:21.701]                 }
[10:31:21.701]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:21.701]                 "immediateCondition"))) {
[10:31:21.701]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:21.701]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.701]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:21.701]                   if (TRUE && !signal) {
[10:31:21.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.701]                     {
[10:31:21.701]                       inherits <- base::inherits
[10:31:21.701]                       invokeRestart <- base::invokeRestart
[10:31:21.701]                       is.null <- base::is.null
[10:31:21.701]                       muffled <- FALSE
[10:31:21.701]                       if (inherits(cond, "message")) {
[10:31:21.701]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.701]                         if (muffled) 
[10:31:21.701]                           invokeRestart("muffleMessage")
[10:31:21.701]                       }
[10:31:21.701]                       else if (inherits(cond, "warning")) {
[10:31:21.701]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.701]                         if (muffled) 
[10:31:21.701]                           invokeRestart("muffleWarning")
[10:31:21.701]                       }
[10:31:21.701]                       else if (inherits(cond, "condition")) {
[10:31:21.701]                         if (!is.null(pattern)) {
[10:31:21.701]                           computeRestarts <- base::computeRestarts
[10:31:21.701]                           grepl <- base::grepl
[10:31:21.701]                           restarts <- computeRestarts(cond)
[10:31:21.701]                           for (restart in restarts) {
[10:31:21.701]                             name <- restart$name
[10:31:21.701]                             if (is.null(name)) 
[10:31:21.701]                               next
[10:31:21.701]                             if (!grepl(pattern, name)) 
[10:31:21.701]                               next
[10:31:21.701]                             invokeRestart(restart)
[10:31:21.701]                             muffled <- TRUE
[10:31:21.701]                             break
[10:31:21.701]                           }
[10:31:21.701]                         }
[10:31:21.701]                       }
[10:31:21.701]                       invisible(muffled)
[10:31:21.701]                     }
[10:31:21.701]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.701]                   }
[10:31:21.701]                 }
[10:31:21.701]                 else {
[10:31:21.701]                   if (TRUE) {
[10:31:21.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.701]                     {
[10:31:21.701]                       inherits <- base::inherits
[10:31:21.701]                       invokeRestart <- base::invokeRestart
[10:31:21.701]                       is.null <- base::is.null
[10:31:21.701]                       muffled <- FALSE
[10:31:21.701]                       if (inherits(cond, "message")) {
[10:31:21.701]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.701]                         if (muffled) 
[10:31:21.701]                           invokeRestart("muffleMessage")
[10:31:21.701]                       }
[10:31:21.701]                       else if (inherits(cond, "warning")) {
[10:31:21.701]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.701]                         if (muffled) 
[10:31:21.701]                           invokeRestart("muffleWarning")
[10:31:21.701]                       }
[10:31:21.701]                       else if (inherits(cond, "condition")) {
[10:31:21.701]                         if (!is.null(pattern)) {
[10:31:21.701]                           computeRestarts <- base::computeRestarts
[10:31:21.701]                           grepl <- base::grepl
[10:31:21.701]                           restarts <- computeRestarts(cond)
[10:31:21.701]                           for (restart in restarts) {
[10:31:21.701]                             name <- restart$name
[10:31:21.701]                             if (is.null(name)) 
[10:31:21.701]                               next
[10:31:21.701]                             if (!grepl(pattern, name)) 
[10:31:21.701]                               next
[10:31:21.701]                             invokeRestart(restart)
[10:31:21.701]                             muffled <- TRUE
[10:31:21.701]                             break
[10:31:21.701]                           }
[10:31:21.701]                         }
[10:31:21.701]                       }
[10:31:21.701]                       invisible(muffled)
[10:31:21.701]                     }
[10:31:21.701]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.701]                   }
[10:31:21.701]                 }
[10:31:21.701]             }
[10:31:21.701]         }))
[10:31:21.701]     }, error = function(ex) {
[10:31:21.701]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:21.701]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.701]                 ...future.rng), started = ...future.startTime, 
[10:31:21.701]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:21.701]             version = "1.8"), class = "FutureResult")
[10:31:21.701]     }, finally = {
[10:31:21.701]         if (!identical(...future.workdir, getwd())) 
[10:31:21.701]             setwd(...future.workdir)
[10:31:21.701]         {
[10:31:21.701]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:21.701]                 ...future.oldOptions$nwarnings <- NULL
[10:31:21.701]             }
[10:31:21.701]             base::options(...future.oldOptions)
[10:31:21.701]             if (.Platform$OS.type == "windows") {
[10:31:21.701]                 old_names <- names(...future.oldEnvVars)
[10:31:21.701]                 envs <- base::Sys.getenv()
[10:31:21.701]                 names <- names(envs)
[10:31:21.701]                 common <- intersect(names, old_names)
[10:31:21.701]                 added <- setdiff(names, old_names)
[10:31:21.701]                 removed <- setdiff(old_names, names)
[10:31:21.701]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:21.701]                   envs[common]]
[10:31:21.701]                 NAMES <- toupper(changed)
[10:31:21.701]                 args <- list()
[10:31:21.701]                 for (kk in seq_along(NAMES)) {
[10:31:21.701]                   name <- changed[[kk]]
[10:31:21.701]                   NAME <- NAMES[[kk]]
[10:31:21.701]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.701]                     next
[10:31:21.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.701]                 }
[10:31:21.701]                 NAMES <- toupper(added)
[10:31:21.701]                 for (kk in seq_along(NAMES)) {
[10:31:21.701]                   name <- added[[kk]]
[10:31:21.701]                   NAME <- NAMES[[kk]]
[10:31:21.701]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.701]                     next
[10:31:21.701]                   args[[name]] <- ""
[10:31:21.701]                 }
[10:31:21.701]                 NAMES <- toupper(removed)
[10:31:21.701]                 for (kk in seq_along(NAMES)) {
[10:31:21.701]                   name <- removed[[kk]]
[10:31:21.701]                   NAME <- NAMES[[kk]]
[10:31:21.701]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.701]                     next
[10:31:21.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.701]                 }
[10:31:21.701]                 if (length(args) > 0) 
[10:31:21.701]                   base::do.call(base::Sys.setenv, args = args)
[10:31:21.701]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:21.701]             }
[10:31:21.701]             else {
[10:31:21.701]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:21.701]             }
[10:31:21.701]             {
[10:31:21.701]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:21.701]                   0L) {
[10:31:21.701]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:21.701]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:21.701]                   base::options(opts)
[10:31:21.701]                 }
[10:31:21.701]                 {
[10:31:21.701]                   {
[10:31:21.701]                     NULL
[10:31:21.701]                     RNGkind("Mersenne-Twister")
[10:31:21.701]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:21.701]                       inherits = FALSE)
[10:31:21.701]                   }
[10:31:21.701]                   options(future.plan = NULL)
[10:31:21.701]                   if (is.na(NA_character_)) 
[10:31:21.701]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.701]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:21.701]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:21.701]                     .init = FALSE)
[10:31:21.701]                 }
[10:31:21.701]             }
[10:31:21.701]         }
[10:31:21.701]     })
[10:31:21.701]     if (TRUE) {
[10:31:21.701]         base::sink(type = "output", split = FALSE)
[10:31:21.701]         if (TRUE) {
[10:31:21.701]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:21.701]         }
[10:31:21.701]         else {
[10:31:21.701]             ...future.result["stdout"] <- base::list(NULL)
[10:31:21.701]         }
[10:31:21.701]         base::close(...future.stdout)
[10:31:21.701]         ...future.stdout <- NULL
[10:31:21.701]     }
[10:31:21.701]     ...future.result$conditions <- ...future.conditions
[10:31:21.701]     ...future.result$finished <- base::Sys.time()
[10:31:21.701]     ...future.result
[10:31:21.701] }
[10:31:21.703] assign_globals() ...
[10:31:21.703] List of 11
[10:31:21.703]  $ ...future.FUN            :function (x, ...)  
[10:31:21.703]  $ x_FUN                    :function (x)  
[10:31:21.703]  $ times                    : int 1
[10:31:21.703]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.703]  $ stop_if_not              :function (...)  
[10:31:21.703]  $ dim                      : NULL
[10:31:21.703]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:21.703]  $ future.call.arguments    : list()
[10:31:21.703]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.703]  $ ...future.elements_ii    :List of 10
[10:31:21.703]   ..$ : int 1
[10:31:21.703]   ..$ : int 2
[10:31:21.703]   ..$ : int 3
[10:31:21.703]   ..$ : int 4
[10:31:21.703]   ..$ : int 5
[10:31:21.703]   ..$ : int 6
[10:31:21.703]   ..$ : int 7
[10:31:21.703]   ..$ : int 8
[10:31:21.703]   ..$ : int 9
[10:31:21.703]   ..$ : int 10
[10:31:21.703]  $ ...future.seeds_ii       : NULL
[10:31:21.703]  $ ...future.globals.maxSize: NULL
[10:31:21.703]  - attr(*, "where")=List of 11
[10:31:21.703]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:21.703]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:21.703]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:21.703]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:21.703]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:21.703]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:21.703]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:21.703]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:21.703]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:21.703]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:21.703]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:21.703]  - attr(*, "resolved")= logi FALSE
[10:31:21.703]  - attr(*, "total_size")= num 94336
[10:31:21.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.703]  - attr(*, "already-done")= logi TRUE
[10:31:21.716] - copied ‘...future.FUN’ to environment
[10:31:21.716] - copied ‘x_FUN’ to environment
[10:31:21.716] - copied ‘times’ to environment
[10:31:21.716] - copied ‘stopf’ to environment
[10:31:21.716] - copied ‘stop_if_not’ to environment
[10:31:21.716] - copied ‘dim’ to environment
[10:31:21.716] - copied ‘valid_types’ to environment
[10:31:21.717] - copied ‘future.call.arguments’ to environment
[10:31:21.717] - copied ‘...future.elements_ii’ to environment
[10:31:21.717] - copied ‘...future.seeds_ii’ to environment
[10:31:21.717] - copied ‘...future.globals.maxSize’ to environment
[10:31:21.717] assign_globals() ... done
[10:31:21.718] plan(): Setting new future strategy stack:
[10:31:21.718] List of future strategies:
[10:31:21.718] 1. sequential:
[10:31:21.718]    - args: function (..., envir = parent.frame())
[10:31:21.718]    - tweaked: FALSE
[10:31:21.718]    - call: NULL
[10:31:21.718] plan(): nbrOfWorkers() = 1
[10:31:21.720] plan(): Setting new future strategy stack:
[10:31:21.720] List of future strategies:
[10:31:21.720] 1. sequential:
[10:31:21.720]    - args: function (..., envir = parent.frame())
[10:31:21.720]    - tweaked: FALSE
[10:31:21.720]    - call: plan(strategy)
[10:31:21.720] plan(): nbrOfWorkers() = 1
[10:31:21.720] SequentialFuture started (and completed)
[10:31:21.721] - Launch lazy future ... done
[10:31:21.721] run() for ‘SequentialFuture’ ... done
[10:31:21.721] Created future:
[10:31:21.721] SequentialFuture:
[10:31:21.721] Label: ‘future_vapply-1’
[10:31:21.721] Expression:
[10:31:21.721] {
[10:31:21.721]     do.call(function(...) {
[10:31:21.721]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.721]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.721]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.721]             on.exit(options(oopts), add = TRUE)
[10:31:21.721]         }
[10:31:21.721]         {
[10:31:21.721]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.721]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.721]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.721]             })
[10:31:21.721]         }
[10:31:21.721]     }, args = future.call.arguments)
[10:31:21.721] }
[10:31:21.721] Lazy evaluation: FALSE
[10:31:21.721] Asynchronous evaluation: FALSE
[10:31:21.721] Local evaluation: TRUE
[10:31:21.721] Environment: R_GlobalEnv
[10:31:21.721] Capture standard output: TRUE
[10:31:21.721] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:21.721] Globals: 11 objects totaling 92.67 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:21.721] Packages: 1 packages (‘future.apply’)
[10:31:21.721] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:21.721] Resolved: TRUE
[10:31:21.721] Value: 560 bytes of class ‘list’
[10:31:21.721] Early signaling: FALSE
[10:31:21.721] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:21.721] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.723] Chunk #1 of 1 ... DONE
[10:31:21.723] Launching 1 futures (chunks) ... DONE
[10:31:21.723] Resolving 1 futures (chunks) ...
[10:31:21.723] resolve() on list ...
[10:31:21.723]  recursive: 0
[10:31:21.723]  length: 1
[10:31:21.723] 
[10:31:21.723] resolved() for ‘SequentialFuture’ ...
[10:31:21.723] - state: ‘finished’
[10:31:21.724] - run: TRUE
[10:31:21.724] - result: ‘FutureResult’
[10:31:21.724] resolved() for ‘SequentialFuture’ ... done
[10:31:21.724] Future #1
[10:31:21.724] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:21.724] - nx: 1
[10:31:21.724] - relay: TRUE
[10:31:21.724] - stdout: TRUE
[10:31:21.724] - signal: TRUE
[10:31:21.724] - resignal: FALSE
[10:31:21.724] - force: TRUE
[10:31:21.725] - relayed: [n=1] FALSE
[10:31:21.725] - queued futures: [n=1] FALSE
[10:31:21.725]  - until=1
[10:31:21.725]  - relaying element #1
[10:31:21.725] - relayed: [n=1] TRUE
[10:31:21.725] - queued futures: [n=1] TRUE
[10:31:21.725] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:21.725]  length: 0 (resolved future 1)
[10:31:21.725] Relaying remaining futures
[10:31:21.726] signalConditionsASAP(NULL, pos=0) ...
[10:31:21.726] - nx: 1
[10:31:21.726] - relay: TRUE
[10:31:21.726] - stdout: TRUE
[10:31:21.726] - signal: TRUE
[10:31:21.726] - resignal: FALSE
[10:31:21.726] - force: TRUE
[10:31:21.726] - relayed: [n=1] TRUE
[10:31:21.726] - queued futures: [n=1] TRUE
 - flush all
[10:31:21.726] - relayed: [n=1] TRUE
[10:31:21.726] - queued futures: [n=1] TRUE
[10:31:21.727] signalConditionsASAP(NULL, pos=0) ... done
[10:31:21.727] resolve() on list ... DONE
[10:31:21.727]  - Number of value chunks collected: 1
[10:31:21.727] Resolving 1 futures (chunks) ... DONE
[10:31:21.727] Reducing values from 1 chunks ...
[10:31:21.727]  - Number of values collected after concatenation: 10
[10:31:21.727]  - Number of values expected: 10
[10:31:21.727] Reducing values from 1 chunks ... DONE
[10:31:21.727] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[10:31:21.728] future_lapply() ...
[10:31:21.730] Number of chunks: 1
[10:31:21.730] getGlobalsAndPackagesXApply() ...
[10:31:21.730]  - future.globals: TRUE
[10:31:21.730] getGlobalsAndPackages() ...
[10:31:21.730] Searching for globals...
[10:31:21.736] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[10:31:21.736] Searching for globals ... DONE
[10:31:21.736] Resolving globals: FALSE
[10:31:21.737] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[10:31:21.737] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:21.737] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.737] - packages: [1] ‘future.apply’
[10:31:21.737] getGlobalsAndPackages() ... DONE
[10:31:21.738]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.738]  - needed namespaces: [n=1] ‘future.apply’
[10:31:21.738] Finding globals ... DONE
[10:31:21.738]  - use_args: TRUE
[10:31:21.738]  - Getting '...' globals ...
[10:31:21.738] resolve() on list ...
[10:31:21.738]  recursive: 0
[10:31:21.738]  length: 1
[10:31:21.739]  elements: ‘...’
[10:31:21.739]  length: 0 (resolved future 1)
[10:31:21.739] resolve() on list ... DONE
[10:31:21.739]    - '...' content: [n=0] 
[10:31:21.739] List of 1
[10:31:21.739]  $ ...: list()
[10:31:21.739]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.739]  - attr(*, "where")=List of 1
[10:31:21.739]   ..$ ...:<environment: 0x55de85baff78> 
[10:31:21.739]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.739]  - attr(*, "resolved")= logi TRUE
[10:31:21.739]  - attr(*, "total_size")= num NA
[10:31:21.743]  - Getting '...' globals ... DONE
[10:31:21.743] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:21.743] List of 8
[10:31:21.743]  $ ...future.FUN:function (x, ...)  
[10:31:21.743]  $ x_FUN        :function (x)  
[10:31:21.743]  $ times        : int 2
[10:31:21.743]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.743]  $ stop_if_not  :function (...)  
[10:31:21.743]  $ dim          : NULL
[10:31:21.743]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:21.743]  $ ...          : list()
[10:31:21.743]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.743]  - attr(*, "where")=List of 8
[10:31:21.743]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:21.743]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:21.743]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:21.743]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:21.743]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:21.743]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:21.743]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:21.743]   ..$ ...          :<environment: 0x55de85baff78> 
[10:31:21.743]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.743]  - attr(*, "resolved")= logi FALSE
[10:31:21.743]  - attr(*, "total_size")= num 96456
[10:31:21.753] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:21.753] getGlobalsAndPackagesXApply() ... DONE
[10:31:21.753] Number of futures (= number of chunks): 1
[10:31:21.754] Launching 1 futures (chunks) ...
[10:31:21.754] Chunk #1 of 1 ...
[10:31:21.754]  - Finding globals in 'X' for chunk #1 ...
[10:31:21.754] getGlobalsAndPackages() ...
[10:31:21.754] Searching for globals...
[10:31:21.755] 
[10:31:21.755] Searching for globals ... DONE
[10:31:21.755] - globals: [0] <none>
[10:31:21.755] getGlobalsAndPackages() ... DONE
[10:31:21.756]    + additional globals found: [n=0] 
[10:31:21.756]    + additional namespaces needed: [n=0] 
[10:31:21.756]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:21.756]  - seeds: <none>
[10:31:21.756]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.756] getGlobalsAndPackages() ...
[10:31:21.757] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.757] Resolving globals: FALSE
[10:31:21.757] Tweak future expression to call with '...' arguments ...
[10:31:21.757] {
[10:31:21.757]     do.call(function(...) {
[10:31:21.757]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.757]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.757]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.757]             on.exit(options(oopts), add = TRUE)
[10:31:21.757]         }
[10:31:21.757]         {
[10:31:21.757]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.757]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.757]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.757]             })
[10:31:21.757]         }
[10:31:21.757]     }, args = future.call.arguments)
[10:31:21.757] }
[10:31:21.758] Tweak future expression to call with '...' arguments ... DONE
[10:31:21.758] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.759] - packages: [1] ‘future.apply’
[10:31:21.759] getGlobalsAndPackages() ... DONE
[10:31:21.759] run() for ‘Future’ ...
[10:31:21.759] - state: ‘created’
[10:31:21.760] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:21.760] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.760] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:21.760]   - Field: ‘label’
[10:31:21.760]   - Field: ‘local’
[10:31:21.761]   - Field: ‘owner’
[10:31:21.761]   - Field: ‘envir’
[10:31:21.761]   - Field: ‘packages’
[10:31:21.761]   - Field: ‘gc’
[10:31:21.761]   - Field: ‘conditions’
[10:31:21.761]   - Field: ‘expr’
[10:31:21.762]   - Field: ‘uuid’
[10:31:21.762]   - Field: ‘seed’
[10:31:21.762]   - Field: ‘version’
[10:31:21.762]   - Field: ‘result’
[10:31:21.762]   - Field: ‘asynchronous’
[10:31:21.762]   - Field: ‘calls’
[10:31:21.762]   - Field: ‘globals’
[10:31:21.762]   - Field: ‘stdout’
[10:31:21.763]   - Field: ‘earlySignal’
[10:31:21.763]   - Field: ‘lazy’
[10:31:21.763]   - Field: ‘state’
[10:31:21.763] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:21.763] - Launch lazy future ...
[10:31:21.763] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:21.764] Packages needed by future strategies (n = 0): <none>
[10:31:21.767] {
[10:31:21.767]     {
[10:31:21.767]         {
[10:31:21.767]             ...future.startTime <- base::Sys.time()
[10:31:21.767]             {
[10:31:21.767]                 {
[10:31:21.767]                   {
[10:31:21.767]                     {
[10:31:21.767]                       base::local({
[10:31:21.767]                         has_future <- base::requireNamespace("future", 
[10:31:21.767]                           quietly = TRUE)
[10:31:21.767]                         if (has_future) {
[10:31:21.767]                           ns <- base::getNamespace("future")
[10:31:21.767]                           version <- ns[[".package"]][["version"]]
[10:31:21.767]                           if (is.null(version)) 
[10:31:21.767]                             version <- utils::packageVersion("future")
[10:31:21.767]                         }
[10:31:21.767]                         else {
[10:31:21.767]                           version <- NULL
[10:31:21.767]                         }
[10:31:21.767]                         if (!has_future || version < "1.8.0") {
[10:31:21.767]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:21.767]                             "", base::R.version$version.string), 
[10:31:21.767]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:21.767]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:21.767]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:21.767]                               "release", "version")], collapse = " "), 
[10:31:21.767]                             hostname = base::Sys.info()[["nodename"]])
[10:31:21.767]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:21.767]                             info)
[10:31:21.767]                           info <- base::paste(info, collapse = "; ")
[10:31:21.767]                           if (!has_future) {
[10:31:21.767]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:21.767]                               info)
[10:31:21.767]                           }
[10:31:21.767]                           else {
[10:31:21.767]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:21.767]                               info, version)
[10:31:21.767]                           }
[10:31:21.767]                           base::stop(msg)
[10:31:21.767]                         }
[10:31:21.767]                       })
[10:31:21.767]                     }
[10:31:21.767]                     base::local({
[10:31:21.767]                       for (pkg in "future.apply") {
[10:31:21.767]                         base::loadNamespace(pkg)
[10:31:21.767]                         base::library(pkg, character.only = TRUE)
[10:31:21.767]                       }
[10:31:21.767]                     })
[10:31:21.767]                   }
[10:31:21.767]                   ...future.strategy.old <- future::plan("list")
[10:31:21.767]                   options(future.plan = NULL)
[10:31:21.767]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.767]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:21.767]                 }
[10:31:21.767]                 ...future.workdir <- getwd()
[10:31:21.767]             }
[10:31:21.767]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:21.767]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:21.767]         }
[10:31:21.767]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:21.767]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:21.767]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:21.767]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:21.767]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:21.767]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:21.767]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:21.767]             base::names(...future.oldOptions))
[10:31:21.767]     }
[10:31:21.767]     if (FALSE) {
[10:31:21.767]     }
[10:31:21.767]     else {
[10:31:21.767]         if (TRUE) {
[10:31:21.767]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:21.767]                 open = "w")
[10:31:21.767]         }
[10:31:21.767]         else {
[10:31:21.767]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:21.767]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:21.767]         }
[10:31:21.767]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:21.767]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:21.767]             base::sink(type = "output", split = FALSE)
[10:31:21.767]             base::close(...future.stdout)
[10:31:21.767]         }, add = TRUE)
[10:31:21.767]     }
[10:31:21.767]     ...future.frame <- base::sys.nframe()
[10:31:21.767]     ...future.conditions <- base::list()
[10:31:21.767]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:21.767]     if (FALSE) {
[10:31:21.767]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:21.767]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:21.767]     }
[10:31:21.767]     ...future.result <- base::tryCatch({
[10:31:21.767]         base::withCallingHandlers({
[10:31:21.767]             ...future.value <- base::withVisible(base::local({
[10:31:21.767]                 do.call(function(...) {
[10:31:21.767]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.767]                   if (!identical(...future.globals.maxSize.org, 
[10:31:21.767]                     ...future.globals.maxSize)) {
[10:31:21.767]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.767]                     on.exit(options(oopts), add = TRUE)
[10:31:21.767]                   }
[10:31:21.767]                   {
[10:31:21.767]                     lapply(seq_along(...future.elements_ii), 
[10:31:21.767]                       FUN = function(jj) {
[10:31:21.767]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.767]                         ...future.FUN(...future.X_jj, ...)
[10:31:21.767]                       })
[10:31:21.767]                   }
[10:31:21.767]                 }, args = future.call.arguments)
[10:31:21.767]             }))
[10:31:21.767]             future::FutureResult(value = ...future.value$value, 
[10:31:21.767]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.767]                   ...future.rng), globalenv = if (FALSE) 
[10:31:21.767]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:21.767]                     ...future.globalenv.names))
[10:31:21.767]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:21.767]         }, condition = base::local({
[10:31:21.767]             c <- base::c
[10:31:21.767]             inherits <- base::inherits
[10:31:21.767]             invokeRestart <- base::invokeRestart
[10:31:21.767]             length <- base::length
[10:31:21.767]             list <- base::list
[10:31:21.767]             seq.int <- base::seq.int
[10:31:21.767]             signalCondition <- base::signalCondition
[10:31:21.767]             sys.calls <- base::sys.calls
[10:31:21.767]             `[[` <- base::`[[`
[10:31:21.767]             `+` <- base::`+`
[10:31:21.767]             `<<-` <- base::`<<-`
[10:31:21.767]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:21.767]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:21.767]                   3L)]
[10:31:21.767]             }
[10:31:21.767]             function(cond) {
[10:31:21.767]                 is_error <- inherits(cond, "error")
[10:31:21.767]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:21.767]                   NULL)
[10:31:21.767]                 if (is_error) {
[10:31:21.767]                   sessionInformation <- function() {
[10:31:21.767]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:21.767]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:21.767]                       search = base::search(), system = base::Sys.info())
[10:31:21.767]                   }
[10:31:21.767]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.767]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:21.767]                     cond$call), session = sessionInformation(), 
[10:31:21.767]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:21.767]                   signalCondition(cond)
[10:31:21.767]                 }
[10:31:21.767]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:21.767]                 "immediateCondition"))) {
[10:31:21.767]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:21.767]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.767]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:21.767]                   if (TRUE && !signal) {
[10:31:21.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.767]                     {
[10:31:21.767]                       inherits <- base::inherits
[10:31:21.767]                       invokeRestart <- base::invokeRestart
[10:31:21.767]                       is.null <- base::is.null
[10:31:21.767]                       muffled <- FALSE
[10:31:21.767]                       if (inherits(cond, "message")) {
[10:31:21.767]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.767]                         if (muffled) 
[10:31:21.767]                           invokeRestart("muffleMessage")
[10:31:21.767]                       }
[10:31:21.767]                       else if (inherits(cond, "warning")) {
[10:31:21.767]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.767]                         if (muffled) 
[10:31:21.767]                           invokeRestart("muffleWarning")
[10:31:21.767]                       }
[10:31:21.767]                       else if (inherits(cond, "condition")) {
[10:31:21.767]                         if (!is.null(pattern)) {
[10:31:21.767]                           computeRestarts <- base::computeRestarts
[10:31:21.767]                           grepl <- base::grepl
[10:31:21.767]                           restarts <- computeRestarts(cond)
[10:31:21.767]                           for (restart in restarts) {
[10:31:21.767]                             name <- restart$name
[10:31:21.767]                             if (is.null(name)) 
[10:31:21.767]                               next
[10:31:21.767]                             if (!grepl(pattern, name)) 
[10:31:21.767]                               next
[10:31:21.767]                             invokeRestart(restart)
[10:31:21.767]                             muffled <- TRUE
[10:31:21.767]                             break
[10:31:21.767]                           }
[10:31:21.767]                         }
[10:31:21.767]                       }
[10:31:21.767]                       invisible(muffled)
[10:31:21.767]                     }
[10:31:21.767]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.767]                   }
[10:31:21.767]                 }
[10:31:21.767]                 else {
[10:31:21.767]                   if (TRUE) {
[10:31:21.767]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.767]                     {
[10:31:21.767]                       inherits <- base::inherits
[10:31:21.767]                       invokeRestart <- base::invokeRestart
[10:31:21.767]                       is.null <- base::is.null
[10:31:21.767]                       muffled <- FALSE
[10:31:21.767]                       if (inherits(cond, "message")) {
[10:31:21.767]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.767]                         if (muffled) 
[10:31:21.767]                           invokeRestart("muffleMessage")
[10:31:21.767]                       }
[10:31:21.767]                       else if (inherits(cond, "warning")) {
[10:31:21.767]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.767]                         if (muffled) 
[10:31:21.767]                           invokeRestart("muffleWarning")
[10:31:21.767]                       }
[10:31:21.767]                       else if (inherits(cond, "condition")) {
[10:31:21.767]                         if (!is.null(pattern)) {
[10:31:21.767]                           computeRestarts <- base::computeRestarts
[10:31:21.767]                           grepl <- base::grepl
[10:31:21.767]                           restarts <- computeRestarts(cond)
[10:31:21.767]                           for (restart in restarts) {
[10:31:21.767]                             name <- restart$name
[10:31:21.767]                             if (is.null(name)) 
[10:31:21.767]                               next
[10:31:21.767]                             if (!grepl(pattern, name)) 
[10:31:21.767]                               next
[10:31:21.767]                             invokeRestart(restart)
[10:31:21.767]                             muffled <- TRUE
[10:31:21.767]                             break
[10:31:21.767]                           }
[10:31:21.767]                         }
[10:31:21.767]                       }
[10:31:21.767]                       invisible(muffled)
[10:31:21.767]                     }
[10:31:21.767]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.767]                   }
[10:31:21.767]                 }
[10:31:21.767]             }
[10:31:21.767]         }))
[10:31:21.767]     }, error = function(ex) {
[10:31:21.767]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:21.767]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.767]                 ...future.rng), started = ...future.startTime, 
[10:31:21.767]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:21.767]             version = "1.8"), class = "FutureResult")
[10:31:21.767]     }, finally = {
[10:31:21.767]         if (!identical(...future.workdir, getwd())) 
[10:31:21.767]             setwd(...future.workdir)
[10:31:21.767]         {
[10:31:21.767]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:21.767]                 ...future.oldOptions$nwarnings <- NULL
[10:31:21.767]             }
[10:31:21.767]             base::options(...future.oldOptions)
[10:31:21.767]             if (.Platform$OS.type == "windows") {
[10:31:21.767]                 old_names <- names(...future.oldEnvVars)
[10:31:21.767]                 envs <- base::Sys.getenv()
[10:31:21.767]                 names <- names(envs)
[10:31:21.767]                 common <- intersect(names, old_names)
[10:31:21.767]                 added <- setdiff(names, old_names)
[10:31:21.767]                 removed <- setdiff(old_names, names)
[10:31:21.767]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:21.767]                   envs[common]]
[10:31:21.767]                 NAMES <- toupper(changed)
[10:31:21.767]                 args <- list()
[10:31:21.767]                 for (kk in seq_along(NAMES)) {
[10:31:21.767]                   name <- changed[[kk]]
[10:31:21.767]                   NAME <- NAMES[[kk]]
[10:31:21.767]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.767]                     next
[10:31:21.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.767]                 }
[10:31:21.767]                 NAMES <- toupper(added)
[10:31:21.767]                 for (kk in seq_along(NAMES)) {
[10:31:21.767]                   name <- added[[kk]]
[10:31:21.767]                   NAME <- NAMES[[kk]]
[10:31:21.767]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.767]                     next
[10:31:21.767]                   args[[name]] <- ""
[10:31:21.767]                 }
[10:31:21.767]                 NAMES <- toupper(removed)
[10:31:21.767]                 for (kk in seq_along(NAMES)) {
[10:31:21.767]                   name <- removed[[kk]]
[10:31:21.767]                   NAME <- NAMES[[kk]]
[10:31:21.767]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.767]                     next
[10:31:21.767]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.767]                 }
[10:31:21.767]                 if (length(args) > 0) 
[10:31:21.767]                   base::do.call(base::Sys.setenv, args = args)
[10:31:21.767]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:21.767]             }
[10:31:21.767]             else {
[10:31:21.767]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:21.767]             }
[10:31:21.767]             {
[10:31:21.767]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:21.767]                   0L) {
[10:31:21.767]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:21.767]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:21.767]                   base::options(opts)
[10:31:21.767]                 }
[10:31:21.767]                 {
[10:31:21.767]                   {
[10:31:21.767]                     NULL
[10:31:21.767]                     RNGkind("Mersenne-Twister")
[10:31:21.767]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:21.767]                       inherits = FALSE)
[10:31:21.767]                   }
[10:31:21.767]                   options(future.plan = NULL)
[10:31:21.767]                   if (is.na(NA_character_)) 
[10:31:21.767]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.767]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:21.767]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:21.767]                     .init = FALSE)
[10:31:21.767]                 }
[10:31:21.767]             }
[10:31:21.767]         }
[10:31:21.767]     })
[10:31:21.767]     if (TRUE) {
[10:31:21.767]         base::sink(type = "output", split = FALSE)
[10:31:21.767]         if (TRUE) {
[10:31:21.767]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:21.767]         }
[10:31:21.767]         else {
[10:31:21.767]             ...future.result["stdout"] <- base::list(NULL)
[10:31:21.767]         }
[10:31:21.767]         base::close(...future.stdout)
[10:31:21.767]         ...future.stdout <- NULL
[10:31:21.767]     }
[10:31:21.767]     ...future.result$conditions <- ...future.conditions
[10:31:21.767]     ...future.result$finished <- base::Sys.time()
[10:31:21.767]     ...future.result
[10:31:21.767] }
[10:31:21.769] assign_globals() ...
[10:31:21.769] List of 11
[10:31:21.769]  $ ...future.FUN            :function (x, ...)  
[10:31:21.769]  $ x_FUN                    :function (x)  
[10:31:21.769]  $ times                    : int 2
[10:31:21.769]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.769]  $ stop_if_not              :function (...)  
[10:31:21.769]  $ dim                      : NULL
[10:31:21.769]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:21.769]  $ future.call.arguments    : list()
[10:31:21.769]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.769]  $ ...future.elements_ii    :List of 10
[10:31:21.769]   ..$ : int 1
[10:31:21.769]   ..$ : int 2
[10:31:21.769]   ..$ : int 3
[10:31:21.769]   ..$ : int 4
[10:31:21.769]   ..$ : int 5
[10:31:21.769]   ..$ : int 6
[10:31:21.769]   ..$ : int 7
[10:31:21.769]   ..$ : int 8
[10:31:21.769]   ..$ : int 9
[10:31:21.769]   ..$ : int 10
[10:31:21.769]  $ ...future.seeds_ii       : NULL
[10:31:21.769]  $ ...future.globals.maxSize: NULL
[10:31:21.769]  - attr(*, "where")=List of 11
[10:31:21.769]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:21.769]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:21.769]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:21.769]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:21.769]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:21.769]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:21.769]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:21.769]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:21.769]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:21.769]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:21.769]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:21.769]  - attr(*, "resolved")= logi FALSE
[10:31:21.769]  - attr(*, "total_size")= num 96456
[10:31:21.769]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.769]  - attr(*, "already-done")= logi TRUE
[10:31:21.779] - copied ‘...future.FUN’ to environment
[10:31:21.779] - reassign environment for ‘x_FUN’
[10:31:21.779] - copied ‘x_FUN’ to environment
[10:31:21.779] - copied ‘times’ to environment
[10:31:21.779] - copied ‘stopf’ to environment
[10:31:21.780] - copied ‘stop_if_not’ to environment
[10:31:21.780] - copied ‘dim’ to environment
[10:31:21.780] - copied ‘valid_types’ to environment
[10:31:21.780] - copied ‘future.call.arguments’ to environment
[10:31:21.780] - copied ‘...future.elements_ii’ to environment
[10:31:21.780] - copied ‘...future.seeds_ii’ to environment
[10:31:21.780] - copied ‘...future.globals.maxSize’ to environment
[10:31:21.780] assign_globals() ... done
[10:31:21.781] plan(): Setting new future strategy stack:
[10:31:21.781] List of future strategies:
[10:31:21.781] 1. sequential:
[10:31:21.781]    - args: function (..., envir = parent.frame())
[10:31:21.781]    - tweaked: FALSE
[10:31:21.781]    - call: NULL
[10:31:21.781] plan(): nbrOfWorkers() = 1
[10:31:21.782] plan(): Setting new future strategy stack:
[10:31:21.782] List of future strategies:
[10:31:21.782] 1. sequential:
[10:31:21.782]    - args: function (..., envir = parent.frame())
[10:31:21.782]    - tweaked: FALSE
[10:31:21.782]    - call: plan(strategy)
[10:31:21.782] plan(): nbrOfWorkers() = 1
[10:31:21.783] SequentialFuture started (and completed)
[10:31:21.783] - Launch lazy future ... done
[10:31:21.783] run() for ‘SequentialFuture’ ... done
[10:31:21.783] Created future:
[10:31:21.783] SequentialFuture:
[10:31:21.783] Label: ‘future_vapply-1’
[10:31:21.783] Expression:
[10:31:21.783] {
[10:31:21.783]     do.call(function(...) {
[10:31:21.783]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.783]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.783]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.783]             on.exit(options(oopts), add = TRUE)
[10:31:21.783]         }
[10:31:21.783]         {
[10:31:21.783]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.783]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.783]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.783]             })
[10:31:21.783]         }
[10:31:21.783]     }, args = future.call.arguments)
[10:31:21.783] }
[10:31:21.783] Lazy evaluation: FALSE
[10:31:21.783] Asynchronous evaluation: FALSE
[10:31:21.783] Local evaluation: TRUE
[10:31:21.783] Environment: R_GlobalEnv
[10:31:21.783] Capture standard output: TRUE
[10:31:21.783] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:21.783] Globals: 11 objects totaling 94.74 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:21.783] Packages: 1 packages (‘future.apply’)
[10:31:21.783] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:21.783] Resolved: TRUE
[10:31:21.783] Value: 640 bytes of class ‘list’
[10:31:21.783] Early signaling: FALSE
[10:31:21.783] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:21.783] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.784] Chunk #1 of 1 ... DONE
[10:31:21.784] Launching 1 futures (chunks) ... DONE
[10:31:21.784] Resolving 1 futures (chunks) ...
[10:31:21.785] resolve() on list ...
[10:31:21.785]  recursive: 0
[10:31:21.785]  length: 1
[10:31:21.785] 
[10:31:21.785] resolved() for ‘SequentialFuture’ ...
[10:31:21.785] - state: ‘finished’
[10:31:21.785] - run: TRUE
[10:31:21.785] - result: ‘FutureResult’
[10:31:21.785] resolved() for ‘SequentialFuture’ ... done
[10:31:21.785] Future #1
[10:31:21.786] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:21.786] - nx: 1
[10:31:21.786] - relay: TRUE
[10:31:21.786] - stdout: TRUE
[10:31:21.786] - signal: TRUE
[10:31:21.786] - resignal: FALSE
[10:31:21.786] - force: TRUE
[10:31:21.786] - relayed: [n=1] FALSE
[10:31:21.786] - queued futures: [n=1] FALSE
[10:31:21.786]  - until=1
[10:31:21.786]  - relaying element #1
[10:31:21.787] - relayed: [n=1] TRUE
[10:31:21.787] - queued futures: [n=1] TRUE
[10:31:21.787] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:21.787]  length: 0 (resolved future 1)
[10:31:21.787] Relaying remaining futures
[10:31:21.787] signalConditionsASAP(NULL, pos=0) ...
[10:31:21.787] - nx: 1
[10:31:21.787] - relay: TRUE
[10:31:21.787] - stdout: TRUE
[10:31:21.787] - signal: TRUE
[10:31:21.788] - resignal: FALSE
[10:31:21.788] - force: TRUE
[10:31:21.788] - relayed: [n=1] TRUE
[10:31:21.788] - queued futures: [n=1] TRUE
 - flush all
[10:31:21.788] - relayed: [n=1] TRUE
[10:31:21.788] - queued futures: [n=1] TRUE
[10:31:21.788] signalConditionsASAP(NULL, pos=0) ... done
[10:31:21.788] resolve() on list ... DONE
[10:31:21.788]  - Number of value chunks collected: 1
[10:31:21.788] Resolving 1 futures (chunks) ... DONE
[10:31:21.790] Reducing values from 1 chunks ...
[10:31:21.790]  - Number of values collected after concatenation: 10
[10:31:21.790]  - Number of values expected: 10
[10:31:21.790] Reducing values from 1 chunks ... DONE
[10:31:21.791] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:31:21.792] future_lapply() ...
[10:31:21.793] Number of chunks: 1
[10:31:21.793] getGlobalsAndPackagesXApply() ...
[10:31:21.794]  - future.globals: TRUE
[10:31:21.794] getGlobalsAndPackages() ...
[10:31:21.794] Searching for globals...
[10:31:21.797] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:31:21.797] Searching for globals ... DONE
[10:31:21.797] Resolving globals: FALSE
[10:31:21.798] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[10:31:21.799] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:21.799] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.799] - packages: [1] ‘future.apply’
[10:31:21.799] getGlobalsAndPackages() ... DONE
[10:31:21.799]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.799]  - needed namespaces: [n=1] ‘future.apply’
[10:31:21.799] Finding globals ... DONE
[10:31:21.799]  - use_args: TRUE
[10:31:21.800]  - Getting '...' globals ...
[10:31:21.800] resolve() on list ...
[10:31:21.800]  recursive: 0
[10:31:21.800]  length: 1
[10:31:21.800]  elements: ‘...’
[10:31:21.800]  length: 0 (resolved future 1)
[10:31:21.800] resolve() on list ... DONE
[10:31:21.800]    - '...' content: [n=0] 
[10:31:21.801] List of 1
[10:31:21.801]  $ ...: list()
[10:31:21.801]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.801]  - attr(*, "where")=List of 1
[10:31:21.801]   ..$ ...:<environment: 0x55de8467a3b0> 
[10:31:21.801]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.801]  - attr(*, "resolved")= logi TRUE
[10:31:21.801]  - attr(*, "total_size")= num NA
[10:31:21.803]  - Getting '...' globals ... DONE
[10:31:21.803] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:21.803] List of 8
[10:31:21.803]  $ ...future.FUN:function (x, ...)  
[10:31:21.803]  $ x_FUN        :function (x)  
[10:31:21.803]  $ times        : int 4
[10:31:21.803]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.803]  $ stop_if_not  :function (...)  
[10:31:21.803]  $ dim          : int [1:2] 2 2
[10:31:21.803]  $ valid_types  : chr [1:2] "logical" "integer"
[10:31:21.803]  $ ...          : list()
[10:31:21.803]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.803]  - attr(*, "where")=List of 8
[10:31:21.803]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:21.803]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:21.803]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:21.803]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:21.803]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:21.803]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:21.803]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:21.803]   ..$ ...          :<environment: 0x55de8467a3b0> 
[10:31:21.803]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.803]  - attr(*, "resolved")= logi FALSE
[10:31:21.803]  - attr(*, "total_size")= num 97232
[10:31:21.809] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:21.809] getGlobalsAndPackagesXApply() ... DONE
[10:31:21.809] Number of futures (= number of chunks): 1
[10:31:21.809] Launching 1 futures (chunks) ...
[10:31:21.809] Chunk #1 of 1 ...
[10:31:21.811]  - Finding globals in 'X' for chunk #1 ...
[10:31:21.811] getGlobalsAndPackages() ...
[10:31:21.811] Searching for globals...
[10:31:21.811] 
[10:31:21.812] Searching for globals ... DONE
[10:31:21.812] - globals: [0] <none>
[10:31:21.812] getGlobalsAndPackages() ... DONE
[10:31:21.812]    + additional globals found: [n=0] 
[10:31:21.812]    + additional namespaces needed: [n=0] 
[10:31:21.812]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:21.812]  - seeds: <none>
[10:31:21.812]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.812] getGlobalsAndPackages() ...
[10:31:21.812] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.813] Resolving globals: FALSE
[10:31:21.813] Tweak future expression to call with '...' arguments ...
[10:31:21.813] {
[10:31:21.813]     do.call(function(...) {
[10:31:21.813]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.813]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.813]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.813]             on.exit(options(oopts), add = TRUE)
[10:31:21.813]         }
[10:31:21.813]         {
[10:31:21.813]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.813]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.813]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.813]             })
[10:31:21.813]         }
[10:31:21.813]     }, args = future.call.arguments)
[10:31:21.813] }
[10:31:21.813] Tweak future expression to call with '...' arguments ... DONE
[10:31:21.814] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.814] - packages: [1] ‘future.apply’
[10:31:21.814] getGlobalsAndPackages() ... DONE
[10:31:21.814] run() for ‘Future’ ...
[10:31:21.814] - state: ‘created’
[10:31:21.814] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:21.815] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.815] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:21.815]   - Field: ‘label’
[10:31:21.815]   - Field: ‘local’
[10:31:21.815]   - Field: ‘owner’
[10:31:21.815]   - Field: ‘envir’
[10:31:21.815]   - Field: ‘packages’
[10:31:21.815]   - Field: ‘gc’
[10:31:21.815]   - Field: ‘conditions’
[10:31:21.816]   - Field: ‘expr’
[10:31:21.816]   - Field: ‘uuid’
[10:31:21.816]   - Field: ‘seed’
[10:31:21.816]   - Field: ‘version’
[10:31:21.816]   - Field: ‘result’
[10:31:21.816]   - Field: ‘asynchronous’
[10:31:21.816]   - Field: ‘calls’
[10:31:21.816]   - Field: ‘globals’
[10:31:21.816]   - Field: ‘stdout’
[10:31:21.816]   - Field: ‘earlySignal’
[10:31:21.816]   - Field: ‘lazy’
[10:31:21.817]   - Field: ‘state’
[10:31:21.817] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:21.817] - Launch lazy future ...
[10:31:21.817] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:21.817] Packages needed by future strategies (n = 0): <none>
[10:31:21.818] {
[10:31:21.818]     {
[10:31:21.818]         {
[10:31:21.818]             ...future.startTime <- base::Sys.time()
[10:31:21.818]             {
[10:31:21.818]                 {
[10:31:21.818]                   {
[10:31:21.818]                     {
[10:31:21.818]                       base::local({
[10:31:21.818]                         has_future <- base::requireNamespace("future", 
[10:31:21.818]                           quietly = TRUE)
[10:31:21.818]                         if (has_future) {
[10:31:21.818]                           ns <- base::getNamespace("future")
[10:31:21.818]                           version <- ns[[".package"]][["version"]]
[10:31:21.818]                           if (is.null(version)) 
[10:31:21.818]                             version <- utils::packageVersion("future")
[10:31:21.818]                         }
[10:31:21.818]                         else {
[10:31:21.818]                           version <- NULL
[10:31:21.818]                         }
[10:31:21.818]                         if (!has_future || version < "1.8.0") {
[10:31:21.818]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:21.818]                             "", base::R.version$version.string), 
[10:31:21.818]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:21.818]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:21.818]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:21.818]                               "release", "version")], collapse = " "), 
[10:31:21.818]                             hostname = base::Sys.info()[["nodename"]])
[10:31:21.818]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:21.818]                             info)
[10:31:21.818]                           info <- base::paste(info, collapse = "; ")
[10:31:21.818]                           if (!has_future) {
[10:31:21.818]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:21.818]                               info)
[10:31:21.818]                           }
[10:31:21.818]                           else {
[10:31:21.818]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:21.818]                               info, version)
[10:31:21.818]                           }
[10:31:21.818]                           base::stop(msg)
[10:31:21.818]                         }
[10:31:21.818]                       })
[10:31:21.818]                     }
[10:31:21.818]                     base::local({
[10:31:21.818]                       for (pkg in "future.apply") {
[10:31:21.818]                         base::loadNamespace(pkg)
[10:31:21.818]                         base::library(pkg, character.only = TRUE)
[10:31:21.818]                       }
[10:31:21.818]                     })
[10:31:21.818]                   }
[10:31:21.818]                   ...future.strategy.old <- future::plan("list")
[10:31:21.818]                   options(future.plan = NULL)
[10:31:21.818]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.818]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:21.818]                 }
[10:31:21.818]                 ...future.workdir <- getwd()
[10:31:21.818]             }
[10:31:21.818]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:21.818]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:21.818]         }
[10:31:21.818]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:21.818]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:21.818]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:21.818]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:21.818]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:21.818]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:21.818]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:21.818]             base::names(...future.oldOptions))
[10:31:21.818]     }
[10:31:21.818]     if (FALSE) {
[10:31:21.818]     }
[10:31:21.818]     else {
[10:31:21.818]         if (TRUE) {
[10:31:21.818]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:21.818]                 open = "w")
[10:31:21.818]         }
[10:31:21.818]         else {
[10:31:21.818]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:21.818]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:21.818]         }
[10:31:21.818]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:21.818]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:21.818]             base::sink(type = "output", split = FALSE)
[10:31:21.818]             base::close(...future.stdout)
[10:31:21.818]         }, add = TRUE)
[10:31:21.818]     }
[10:31:21.818]     ...future.frame <- base::sys.nframe()
[10:31:21.818]     ...future.conditions <- base::list()
[10:31:21.818]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:21.818]     if (FALSE) {
[10:31:21.818]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:21.818]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:21.818]     }
[10:31:21.818]     ...future.result <- base::tryCatch({
[10:31:21.818]         base::withCallingHandlers({
[10:31:21.818]             ...future.value <- base::withVisible(base::local({
[10:31:21.818]                 do.call(function(...) {
[10:31:21.818]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.818]                   if (!identical(...future.globals.maxSize.org, 
[10:31:21.818]                     ...future.globals.maxSize)) {
[10:31:21.818]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.818]                     on.exit(options(oopts), add = TRUE)
[10:31:21.818]                   }
[10:31:21.818]                   {
[10:31:21.818]                     lapply(seq_along(...future.elements_ii), 
[10:31:21.818]                       FUN = function(jj) {
[10:31:21.818]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.818]                         ...future.FUN(...future.X_jj, ...)
[10:31:21.818]                       })
[10:31:21.818]                   }
[10:31:21.818]                 }, args = future.call.arguments)
[10:31:21.818]             }))
[10:31:21.818]             future::FutureResult(value = ...future.value$value, 
[10:31:21.818]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.818]                   ...future.rng), globalenv = if (FALSE) 
[10:31:21.818]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:21.818]                     ...future.globalenv.names))
[10:31:21.818]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:21.818]         }, condition = base::local({
[10:31:21.818]             c <- base::c
[10:31:21.818]             inherits <- base::inherits
[10:31:21.818]             invokeRestart <- base::invokeRestart
[10:31:21.818]             length <- base::length
[10:31:21.818]             list <- base::list
[10:31:21.818]             seq.int <- base::seq.int
[10:31:21.818]             signalCondition <- base::signalCondition
[10:31:21.818]             sys.calls <- base::sys.calls
[10:31:21.818]             `[[` <- base::`[[`
[10:31:21.818]             `+` <- base::`+`
[10:31:21.818]             `<<-` <- base::`<<-`
[10:31:21.818]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:21.818]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:21.818]                   3L)]
[10:31:21.818]             }
[10:31:21.818]             function(cond) {
[10:31:21.818]                 is_error <- inherits(cond, "error")
[10:31:21.818]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:21.818]                   NULL)
[10:31:21.818]                 if (is_error) {
[10:31:21.818]                   sessionInformation <- function() {
[10:31:21.818]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:21.818]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:21.818]                       search = base::search(), system = base::Sys.info())
[10:31:21.818]                   }
[10:31:21.818]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.818]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:21.818]                     cond$call), session = sessionInformation(), 
[10:31:21.818]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:21.818]                   signalCondition(cond)
[10:31:21.818]                 }
[10:31:21.818]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:21.818]                 "immediateCondition"))) {
[10:31:21.818]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:21.818]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.818]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:21.818]                   if (TRUE && !signal) {
[10:31:21.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.818]                     {
[10:31:21.818]                       inherits <- base::inherits
[10:31:21.818]                       invokeRestart <- base::invokeRestart
[10:31:21.818]                       is.null <- base::is.null
[10:31:21.818]                       muffled <- FALSE
[10:31:21.818]                       if (inherits(cond, "message")) {
[10:31:21.818]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.818]                         if (muffled) 
[10:31:21.818]                           invokeRestart("muffleMessage")
[10:31:21.818]                       }
[10:31:21.818]                       else if (inherits(cond, "warning")) {
[10:31:21.818]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.818]                         if (muffled) 
[10:31:21.818]                           invokeRestart("muffleWarning")
[10:31:21.818]                       }
[10:31:21.818]                       else if (inherits(cond, "condition")) {
[10:31:21.818]                         if (!is.null(pattern)) {
[10:31:21.818]                           computeRestarts <- base::computeRestarts
[10:31:21.818]                           grepl <- base::grepl
[10:31:21.818]                           restarts <- computeRestarts(cond)
[10:31:21.818]                           for (restart in restarts) {
[10:31:21.818]                             name <- restart$name
[10:31:21.818]                             if (is.null(name)) 
[10:31:21.818]                               next
[10:31:21.818]                             if (!grepl(pattern, name)) 
[10:31:21.818]                               next
[10:31:21.818]                             invokeRestart(restart)
[10:31:21.818]                             muffled <- TRUE
[10:31:21.818]                             break
[10:31:21.818]                           }
[10:31:21.818]                         }
[10:31:21.818]                       }
[10:31:21.818]                       invisible(muffled)
[10:31:21.818]                     }
[10:31:21.818]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.818]                   }
[10:31:21.818]                 }
[10:31:21.818]                 else {
[10:31:21.818]                   if (TRUE) {
[10:31:21.818]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.818]                     {
[10:31:21.818]                       inherits <- base::inherits
[10:31:21.818]                       invokeRestart <- base::invokeRestart
[10:31:21.818]                       is.null <- base::is.null
[10:31:21.818]                       muffled <- FALSE
[10:31:21.818]                       if (inherits(cond, "message")) {
[10:31:21.818]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.818]                         if (muffled) 
[10:31:21.818]                           invokeRestart("muffleMessage")
[10:31:21.818]                       }
[10:31:21.818]                       else if (inherits(cond, "warning")) {
[10:31:21.818]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.818]                         if (muffled) 
[10:31:21.818]                           invokeRestart("muffleWarning")
[10:31:21.818]                       }
[10:31:21.818]                       else if (inherits(cond, "condition")) {
[10:31:21.818]                         if (!is.null(pattern)) {
[10:31:21.818]                           computeRestarts <- base::computeRestarts
[10:31:21.818]                           grepl <- base::grepl
[10:31:21.818]                           restarts <- computeRestarts(cond)
[10:31:21.818]                           for (restart in restarts) {
[10:31:21.818]                             name <- restart$name
[10:31:21.818]                             if (is.null(name)) 
[10:31:21.818]                               next
[10:31:21.818]                             if (!grepl(pattern, name)) 
[10:31:21.818]                               next
[10:31:21.818]                             invokeRestart(restart)
[10:31:21.818]                             muffled <- TRUE
[10:31:21.818]                             break
[10:31:21.818]                           }
[10:31:21.818]                         }
[10:31:21.818]                       }
[10:31:21.818]                       invisible(muffled)
[10:31:21.818]                     }
[10:31:21.818]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.818]                   }
[10:31:21.818]                 }
[10:31:21.818]             }
[10:31:21.818]         }))
[10:31:21.818]     }, error = function(ex) {
[10:31:21.818]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:21.818]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.818]                 ...future.rng), started = ...future.startTime, 
[10:31:21.818]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:21.818]             version = "1.8"), class = "FutureResult")
[10:31:21.818]     }, finally = {
[10:31:21.818]         if (!identical(...future.workdir, getwd())) 
[10:31:21.818]             setwd(...future.workdir)
[10:31:21.818]         {
[10:31:21.818]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:21.818]                 ...future.oldOptions$nwarnings <- NULL
[10:31:21.818]             }
[10:31:21.818]             base::options(...future.oldOptions)
[10:31:21.818]             if (.Platform$OS.type == "windows") {
[10:31:21.818]                 old_names <- names(...future.oldEnvVars)
[10:31:21.818]                 envs <- base::Sys.getenv()
[10:31:21.818]                 names <- names(envs)
[10:31:21.818]                 common <- intersect(names, old_names)
[10:31:21.818]                 added <- setdiff(names, old_names)
[10:31:21.818]                 removed <- setdiff(old_names, names)
[10:31:21.818]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:21.818]                   envs[common]]
[10:31:21.818]                 NAMES <- toupper(changed)
[10:31:21.818]                 args <- list()
[10:31:21.818]                 for (kk in seq_along(NAMES)) {
[10:31:21.818]                   name <- changed[[kk]]
[10:31:21.818]                   NAME <- NAMES[[kk]]
[10:31:21.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.818]                     next
[10:31:21.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.818]                 }
[10:31:21.818]                 NAMES <- toupper(added)
[10:31:21.818]                 for (kk in seq_along(NAMES)) {
[10:31:21.818]                   name <- added[[kk]]
[10:31:21.818]                   NAME <- NAMES[[kk]]
[10:31:21.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.818]                     next
[10:31:21.818]                   args[[name]] <- ""
[10:31:21.818]                 }
[10:31:21.818]                 NAMES <- toupper(removed)
[10:31:21.818]                 for (kk in seq_along(NAMES)) {
[10:31:21.818]                   name <- removed[[kk]]
[10:31:21.818]                   NAME <- NAMES[[kk]]
[10:31:21.818]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.818]                     next
[10:31:21.818]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.818]                 }
[10:31:21.818]                 if (length(args) > 0) 
[10:31:21.818]                   base::do.call(base::Sys.setenv, args = args)
[10:31:21.818]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:21.818]             }
[10:31:21.818]             else {
[10:31:21.818]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:21.818]             }
[10:31:21.818]             {
[10:31:21.818]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:21.818]                   0L) {
[10:31:21.818]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:21.818]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:21.818]                   base::options(opts)
[10:31:21.818]                 }
[10:31:21.818]                 {
[10:31:21.818]                   {
[10:31:21.818]                     NULL
[10:31:21.818]                     RNGkind("Mersenne-Twister")
[10:31:21.818]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:21.818]                       inherits = FALSE)
[10:31:21.818]                   }
[10:31:21.818]                   options(future.plan = NULL)
[10:31:21.818]                   if (is.na(NA_character_)) 
[10:31:21.818]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.818]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:21.818]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:21.818]                     .init = FALSE)
[10:31:21.818]                 }
[10:31:21.818]             }
[10:31:21.818]         }
[10:31:21.818]     })
[10:31:21.818]     if (TRUE) {
[10:31:21.818]         base::sink(type = "output", split = FALSE)
[10:31:21.818]         if (TRUE) {
[10:31:21.818]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:21.818]         }
[10:31:21.818]         else {
[10:31:21.818]             ...future.result["stdout"] <- base::list(NULL)
[10:31:21.818]         }
[10:31:21.818]         base::close(...future.stdout)
[10:31:21.818]         ...future.stdout <- NULL
[10:31:21.818]     }
[10:31:21.818]     ...future.result$conditions <- ...future.conditions
[10:31:21.818]     ...future.result$finished <- base::Sys.time()
[10:31:21.818]     ...future.result
[10:31:21.818] }
[10:31:21.819] assign_globals() ...
[10:31:21.820] List of 11
[10:31:21.820]  $ ...future.FUN            :function (x, ...)  
[10:31:21.820]  $ x_FUN                    :function (x)  
[10:31:21.820]  $ times                    : int 4
[10:31:21.820]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.820]  $ stop_if_not              :function (...)  
[10:31:21.820]  $ dim                      : int [1:2] 2 2
[10:31:21.820]  $ valid_types              : chr [1:2] "logical" "integer"
[10:31:21.820]  $ future.call.arguments    : list()
[10:31:21.820]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.820]  $ ...future.elements_ii    :List of 10
[10:31:21.820]   ..$ : int 1
[10:31:21.820]   ..$ : int 2
[10:31:21.820]   ..$ : int 3
[10:31:21.820]   ..$ : int 4
[10:31:21.820]   ..$ : int 5
[10:31:21.820]   ..$ : int 6
[10:31:21.820]   ..$ : int 7
[10:31:21.820]   ..$ : int 8
[10:31:21.820]   ..$ : int 9
[10:31:21.820]   ..$ : int 10
[10:31:21.820]  $ ...future.seeds_ii       : NULL
[10:31:21.820]  $ ...future.globals.maxSize: NULL
[10:31:21.820]  - attr(*, "where")=List of 11
[10:31:21.820]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:21.820]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:21.820]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:21.820]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:21.820]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:21.820]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:21.820]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:21.820]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:21.820]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:21.820]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:21.820]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:21.820]  - attr(*, "resolved")= logi FALSE
[10:31:21.820]  - attr(*, "total_size")= num 97232
[10:31:21.820]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.820]  - attr(*, "already-done")= logi TRUE
[10:31:21.829] - copied ‘...future.FUN’ to environment
[10:31:21.829] - reassign environment for ‘x_FUN’
[10:31:21.830] - copied ‘x_FUN’ to environment
[10:31:21.830] - copied ‘times’ to environment
[10:31:21.830] - copied ‘stopf’ to environment
[10:31:21.830] - copied ‘stop_if_not’ to environment
[10:31:21.830] - copied ‘dim’ to environment
[10:31:21.830] - copied ‘valid_types’ to environment
[10:31:21.830] - copied ‘future.call.arguments’ to environment
[10:31:21.830] - copied ‘...future.elements_ii’ to environment
[10:31:21.830] - copied ‘...future.seeds_ii’ to environment
[10:31:21.830] - copied ‘...future.globals.maxSize’ to environment
[10:31:21.830] assign_globals() ... done
[10:31:21.831] plan(): Setting new future strategy stack:
[10:31:21.831] List of future strategies:
[10:31:21.831] 1. sequential:
[10:31:21.831]    - args: function (..., envir = parent.frame())
[10:31:21.831]    - tweaked: FALSE
[10:31:21.831]    - call: NULL
[10:31:21.831] plan(): nbrOfWorkers() = 1
[10:31:21.834] plan(): Setting new future strategy stack:
[10:31:21.834] List of future strategies:
[10:31:21.834] 1. sequential:
[10:31:21.834]    - args: function (..., envir = parent.frame())
[10:31:21.834]    - tweaked: FALSE
[10:31:21.834]    - call: plan(strategy)
[10:31:21.834] plan(): nbrOfWorkers() = 1
[10:31:21.835] SequentialFuture started (and completed)
[10:31:21.835] - Launch lazy future ... done
[10:31:21.835] run() for ‘SequentialFuture’ ... done
[10:31:21.835] Created future:
[10:31:21.835] SequentialFuture:
[10:31:21.835] Label: ‘future_vapply-1’
[10:31:21.835] Expression:
[10:31:21.835] {
[10:31:21.835]     do.call(function(...) {
[10:31:21.835]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.835]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.835]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.835]             on.exit(options(oopts), add = TRUE)
[10:31:21.835]         }
[10:31:21.835]         {
[10:31:21.835]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.835]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.835]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.835]             })
[10:31:21.835]         }
[10:31:21.835]     }, args = future.call.arguments)
[10:31:21.835] }
[10:31:21.835] Lazy evaluation: FALSE
[10:31:21.835] Asynchronous evaluation: FALSE
[10:31:21.835] Local evaluation: TRUE
[10:31:21.835] Environment: R_GlobalEnv
[10:31:21.835] Capture standard output: TRUE
[10:31:21.835] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:21.835] Globals: 11 objects totaling 95.50 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:21.835] Packages: 1 packages (‘future.apply’)
[10:31:21.835] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:21.835] Resolved: TRUE
[10:31:21.835] Value: 2.27 KiB of class ‘list’
[10:31:21.835] Early signaling: FALSE
[10:31:21.835] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:21.835] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.836] Chunk #1 of 1 ... DONE
[10:31:21.836] Launching 1 futures (chunks) ... DONE
[10:31:21.836] Resolving 1 futures (chunks) ...
[10:31:21.837] resolve() on list ...
[10:31:21.837]  recursive: 0
[10:31:21.837]  length: 1
[10:31:21.837] 
[10:31:21.837] resolved() for ‘SequentialFuture’ ...
[10:31:21.837] - state: ‘finished’
[10:31:21.837] - run: TRUE
[10:31:21.837] - result: ‘FutureResult’
[10:31:21.837] resolved() for ‘SequentialFuture’ ... done
[10:31:21.837] Future #1
[10:31:21.838] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:21.838] - nx: 1
[10:31:21.838] - relay: TRUE
[10:31:21.838] - stdout: TRUE
[10:31:21.838] - signal: TRUE
[10:31:21.838] - resignal: FALSE
[10:31:21.838] - force: TRUE
[10:31:21.838] - relayed: [n=1] FALSE
[10:31:21.838] - queued futures: [n=1] FALSE
[10:31:21.838]  - until=1
[10:31:21.838]  - relaying element #1
[10:31:21.839] - relayed: [n=1] TRUE
[10:31:21.839] - queued futures: [n=1] TRUE
[10:31:21.839] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:21.839]  length: 0 (resolved future 1)
[10:31:21.839] Relaying remaining futures
[10:31:21.839] signalConditionsASAP(NULL, pos=0) ...
[10:31:21.839] - nx: 1
[10:31:21.839] - relay: TRUE
[10:31:21.839] - stdout: TRUE
[10:31:21.839] - signal: TRUE
[10:31:21.840] - resignal: FALSE
[10:31:21.840] - force: TRUE
[10:31:21.840] - relayed: [n=1] TRUE
[10:31:21.840] - queued futures: [n=1] TRUE
 - flush all
[10:31:21.840] - relayed: [n=1] TRUE
[10:31:21.840] - queued futures: [n=1] TRUE
[10:31:21.840] signalConditionsASAP(NULL, pos=0) ... done
[10:31:21.840] resolve() on list ... DONE
[10:31:21.840]  - Number of value chunks collected: 1
[10:31:21.840] Resolving 1 futures (chunks) ... DONE
[10:31:21.841] Reducing values from 1 chunks ...
[10:31:21.841]  - Number of values collected after concatenation: 10
[10:31:21.841]  - Number of values expected: 10
[10:31:21.841] Reducing values from 1 chunks ... DONE
[10:31:21.841] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:31:21.842] future_lapply() ...
[10:31:21.844] Number of chunks: 1
[10:31:21.844] getGlobalsAndPackagesXApply() ...
[10:31:21.844]  - future.globals: TRUE
[10:31:21.844] getGlobalsAndPackages() ...
[10:31:21.844] Searching for globals...
[10:31:21.847] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:31:21.847] Searching for globals ... DONE
[10:31:21.848] Resolving globals: FALSE
[10:31:21.848] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[10:31:21.849] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:21.849] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.849] - packages: [1] ‘future.apply’
[10:31:21.849] getGlobalsAndPackages() ... DONE
[10:31:21.849]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.849]  - needed namespaces: [n=1] ‘future.apply’
[10:31:21.849] Finding globals ... DONE
[10:31:21.850]  - use_args: TRUE
[10:31:21.850]  - Getting '...' globals ...
[10:31:21.850] resolve() on list ...
[10:31:21.850]  recursive: 0
[10:31:21.850]  length: 1
[10:31:21.850]  elements: ‘...’
[10:31:21.850]  length: 0 (resolved future 1)
[10:31:21.850] resolve() on list ... DONE
[10:31:21.851]    - '...' content: [n=0] 
[10:31:21.851] List of 1
[10:31:21.851]  $ ...: list()
[10:31:21.851]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.851]  - attr(*, "where")=List of 1
[10:31:21.851]   ..$ ...:<environment: 0x55de85233920> 
[10:31:21.851]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.851]  - attr(*, "resolved")= logi TRUE
[10:31:21.851]  - attr(*, "total_size")= num NA
[10:31:21.853]  - Getting '...' globals ... DONE
[10:31:21.853] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:21.855] List of 8
[10:31:21.855]  $ ...future.FUN:function (x, ...)  
[10:31:21.855]  $ x_FUN        :function (x)  
[10:31:21.855]  $ times        : int 4
[10:31:21.855]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.855]  $ stop_if_not  :function (...)  
[10:31:21.855]  $ dim          : int [1:2] 2 2
[10:31:21.855]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:21.855]  $ ...          : list()
[10:31:21.855]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.855]  - attr(*, "where")=List of 8
[10:31:21.855]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:21.855]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:21.855]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:21.855]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:21.855]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:21.855]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:21.855]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:21.855]   ..$ ...          :<environment: 0x55de85233920> 
[10:31:21.855]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.855]  - attr(*, "resolved")= logi FALSE
[10:31:21.855]  - attr(*, "total_size")= num 97304
[10:31:21.860] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:21.860] getGlobalsAndPackagesXApply() ... DONE
[10:31:21.861] Number of futures (= number of chunks): 1
[10:31:21.861] Launching 1 futures (chunks) ...
[10:31:21.861] Chunk #1 of 1 ...
[10:31:21.861]  - Finding globals in 'X' for chunk #1 ...
[10:31:21.861] getGlobalsAndPackages() ...
[10:31:21.861] Searching for globals...
[10:31:21.861] 
[10:31:21.862] Searching for globals ... DONE
[10:31:21.862] - globals: [0] <none>
[10:31:21.862] getGlobalsAndPackages() ... DONE
[10:31:21.862]    + additional globals found: [n=0] 
[10:31:21.862]    + additional namespaces needed: [n=0] 
[10:31:21.862]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:21.862]  - seeds: <none>
[10:31:21.862]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.862] getGlobalsAndPackages() ...
[10:31:21.862] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.863] Resolving globals: FALSE
[10:31:21.863] Tweak future expression to call with '...' arguments ...
[10:31:21.863] {
[10:31:21.863]     do.call(function(...) {
[10:31:21.863]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.863]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.863]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.863]             on.exit(options(oopts), add = TRUE)
[10:31:21.863]         }
[10:31:21.863]         {
[10:31:21.863]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.863]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.863]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.863]             })
[10:31:21.863]         }
[10:31:21.863]     }, args = future.call.arguments)
[10:31:21.863] }
[10:31:21.863] Tweak future expression to call with '...' arguments ... DONE
[10:31:21.864] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.864] - packages: [1] ‘future.apply’
[10:31:21.864] getGlobalsAndPackages() ... DONE
[10:31:21.864] run() for ‘Future’ ...
[10:31:21.864] - state: ‘created’
[10:31:21.864] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:21.865] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.865] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:21.865]   - Field: ‘label’
[10:31:21.865]   - Field: ‘local’
[10:31:21.865]   - Field: ‘owner’
[10:31:21.865]   - Field: ‘envir’
[10:31:21.865]   - Field: ‘packages’
[10:31:21.865]   - Field: ‘gc’
[10:31:21.865]   - Field: ‘conditions’
[10:31:21.865]   - Field: ‘expr’
[10:31:21.866]   - Field: ‘uuid’
[10:31:21.866]   - Field: ‘seed’
[10:31:21.866]   - Field: ‘version’
[10:31:21.866]   - Field: ‘result’
[10:31:21.866]   - Field: ‘asynchronous’
[10:31:21.866]   - Field: ‘calls’
[10:31:21.866]   - Field: ‘globals’
[10:31:21.866]   - Field: ‘stdout’
[10:31:21.866]   - Field: ‘earlySignal’
[10:31:21.866]   - Field: ‘lazy’
[10:31:21.866]   - Field: ‘state’
[10:31:21.867] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:21.867] - Launch lazy future ...
[10:31:21.867] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:21.867] Packages needed by future strategies (n = 0): <none>
[10:31:21.867] {
[10:31:21.867]     {
[10:31:21.867]         {
[10:31:21.867]             ...future.startTime <- base::Sys.time()
[10:31:21.867]             {
[10:31:21.867]                 {
[10:31:21.867]                   {
[10:31:21.867]                     {
[10:31:21.867]                       base::local({
[10:31:21.867]                         has_future <- base::requireNamespace("future", 
[10:31:21.867]                           quietly = TRUE)
[10:31:21.867]                         if (has_future) {
[10:31:21.867]                           ns <- base::getNamespace("future")
[10:31:21.867]                           version <- ns[[".package"]][["version"]]
[10:31:21.867]                           if (is.null(version)) 
[10:31:21.867]                             version <- utils::packageVersion("future")
[10:31:21.867]                         }
[10:31:21.867]                         else {
[10:31:21.867]                           version <- NULL
[10:31:21.867]                         }
[10:31:21.867]                         if (!has_future || version < "1.8.0") {
[10:31:21.867]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:21.867]                             "", base::R.version$version.string), 
[10:31:21.867]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:21.867]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:21.867]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:21.867]                               "release", "version")], collapse = " "), 
[10:31:21.867]                             hostname = base::Sys.info()[["nodename"]])
[10:31:21.867]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:21.867]                             info)
[10:31:21.867]                           info <- base::paste(info, collapse = "; ")
[10:31:21.867]                           if (!has_future) {
[10:31:21.867]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:21.867]                               info)
[10:31:21.867]                           }
[10:31:21.867]                           else {
[10:31:21.867]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:21.867]                               info, version)
[10:31:21.867]                           }
[10:31:21.867]                           base::stop(msg)
[10:31:21.867]                         }
[10:31:21.867]                       })
[10:31:21.867]                     }
[10:31:21.867]                     base::local({
[10:31:21.867]                       for (pkg in "future.apply") {
[10:31:21.867]                         base::loadNamespace(pkg)
[10:31:21.867]                         base::library(pkg, character.only = TRUE)
[10:31:21.867]                       }
[10:31:21.867]                     })
[10:31:21.867]                   }
[10:31:21.867]                   ...future.strategy.old <- future::plan("list")
[10:31:21.867]                   options(future.plan = NULL)
[10:31:21.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:21.867]                 }
[10:31:21.867]                 ...future.workdir <- getwd()
[10:31:21.867]             }
[10:31:21.867]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:21.867]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:21.867]         }
[10:31:21.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:21.867]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:21.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:21.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:21.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:21.867]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:21.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:21.867]             base::names(...future.oldOptions))
[10:31:21.867]     }
[10:31:21.867]     if (FALSE) {
[10:31:21.867]     }
[10:31:21.867]     else {
[10:31:21.867]         if (TRUE) {
[10:31:21.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:21.867]                 open = "w")
[10:31:21.867]         }
[10:31:21.867]         else {
[10:31:21.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:21.867]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:21.867]         }
[10:31:21.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:21.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:21.867]             base::sink(type = "output", split = FALSE)
[10:31:21.867]             base::close(...future.stdout)
[10:31:21.867]         }, add = TRUE)
[10:31:21.867]     }
[10:31:21.867]     ...future.frame <- base::sys.nframe()
[10:31:21.867]     ...future.conditions <- base::list()
[10:31:21.867]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:21.867]     if (FALSE) {
[10:31:21.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:21.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:21.867]     }
[10:31:21.867]     ...future.result <- base::tryCatch({
[10:31:21.867]         base::withCallingHandlers({
[10:31:21.867]             ...future.value <- base::withVisible(base::local({
[10:31:21.867]                 do.call(function(...) {
[10:31:21.867]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.867]                   if (!identical(...future.globals.maxSize.org, 
[10:31:21.867]                     ...future.globals.maxSize)) {
[10:31:21.867]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.867]                     on.exit(options(oopts), add = TRUE)
[10:31:21.867]                   }
[10:31:21.867]                   {
[10:31:21.867]                     lapply(seq_along(...future.elements_ii), 
[10:31:21.867]                       FUN = function(jj) {
[10:31:21.867]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.867]                         ...future.FUN(...future.X_jj, ...)
[10:31:21.867]                       })
[10:31:21.867]                   }
[10:31:21.867]                 }, args = future.call.arguments)
[10:31:21.867]             }))
[10:31:21.867]             future::FutureResult(value = ...future.value$value, 
[10:31:21.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.867]                   ...future.rng), globalenv = if (FALSE) 
[10:31:21.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:21.867]                     ...future.globalenv.names))
[10:31:21.867]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:21.867]         }, condition = base::local({
[10:31:21.867]             c <- base::c
[10:31:21.867]             inherits <- base::inherits
[10:31:21.867]             invokeRestart <- base::invokeRestart
[10:31:21.867]             length <- base::length
[10:31:21.867]             list <- base::list
[10:31:21.867]             seq.int <- base::seq.int
[10:31:21.867]             signalCondition <- base::signalCondition
[10:31:21.867]             sys.calls <- base::sys.calls
[10:31:21.867]             `[[` <- base::`[[`
[10:31:21.867]             `+` <- base::`+`
[10:31:21.867]             `<<-` <- base::`<<-`
[10:31:21.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:21.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:21.867]                   3L)]
[10:31:21.867]             }
[10:31:21.867]             function(cond) {
[10:31:21.867]                 is_error <- inherits(cond, "error")
[10:31:21.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:21.867]                   NULL)
[10:31:21.867]                 if (is_error) {
[10:31:21.867]                   sessionInformation <- function() {
[10:31:21.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:21.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:21.867]                       search = base::search(), system = base::Sys.info())
[10:31:21.867]                   }
[10:31:21.867]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:21.867]                     cond$call), session = sessionInformation(), 
[10:31:21.867]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:21.867]                   signalCondition(cond)
[10:31:21.867]                 }
[10:31:21.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:21.867]                 "immediateCondition"))) {
[10:31:21.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:21.867]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:21.867]                   if (TRUE && !signal) {
[10:31:21.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.867]                     {
[10:31:21.867]                       inherits <- base::inherits
[10:31:21.867]                       invokeRestart <- base::invokeRestart
[10:31:21.867]                       is.null <- base::is.null
[10:31:21.867]                       muffled <- FALSE
[10:31:21.867]                       if (inherits(cond, "message")) {
[10:31:21.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.867]                         if (muffled) 
[10:31:21.867]                           invokeRestart("muffleMessage")
[10:31:21.867]                       }
[10:31:21.867]                       else if (inherits(cond, "warning")) {
[10:31:21.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.867]                         if (muffled) 
[10:31:21.867]                           invokeRestart("muffleWarning")
[10:31:21.867]                       }
[10:31:21.867]                       else if (inherits(cond, "condition")) {
[10:31:21.867]                         if (!is.null(pattern)) {
[10:31:21.867]                           computeRestarts <- base::computeRestarts
[10:31:21.867]                           grepl <- base::grepl
[10:31:21.867]                           restarts <- computeRestarts(cond)
[10:31:21.867]                           for (restart in restarts) {
[10:31:21.867]                             name <- restart$name
[10:31:21.867]                             if (is.null(name)) 
[10:31:21.867]                               next
[10:31:21.867]                             if (!grepl(pattern, name)) 
[10:31:21.867]                               next
[10:31:21.867]                             invokeRestart(restart)
[10:31:21.867]                             muffled <- TRUE
[10:31:21.867]                             break
[10:31:21.867]                           }
[10:31:21.867]                         }
[10:31:21.867]                       }
[10:31:21.867]                       invisible(muffled)
[10:31:21.867]                     }
[10:31:21.867]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.867]                   }
[10:31:21.867]                 }
[10:31:21.867]                 else {
[10:31:21.867]                   if (TRUE) {
[10:31:21.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.867]                     {
[10:31:21.867]                       inherits <- base::inherits
[10:31:21.867]                       invokeRestart <- base::invokeRestart
[10:31:21.867]                       is.null <- base::is.null
[10:31:21.867]                       muffled <- FALSE
[10:31:21.867]                       if (inherits(cond, "message")) {
[10:31:21.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.867]                         if (muffled) 
[10:31:21.867]                           invokeRestart("muffleMessage")
[10:31:21.867]                       }
[10:31:21.867]                       else if (inherits(cond, "warning")) {
[10:31:21.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.867]                         if (muffled) 
[10:31:21.867]                           invokeRestart("muffleWarning")
[10:31:21.867]                       }
[10:31:21.867]                       else if (inherits(cond, "condition")) {
[10:31:21.867]                         if (!is.null(pattern)) {
[10:31:21.867]                           computeRestarts <- base::computeRestarts
[10:31:21.867]                           grepl <- base::grepl
[10:31:21.867]                           restarts <- computeRestarts(cond)
[10:31:21.867]                           for (restart in restarts) {
[10:31:21.867]                             name <- restart$name
[10:31:21.867]                             if (is.null(name)) 
[10:31:21.867]                               next
[10:31:21.867]                             if (!grepl(pattern, name)) 
[10:31:21.867]                               next
[10:31:21.867]                             invokeRestart(restart)
[10:31:21.867]                             muffled <- TRUE
[10:31:21.867]                             break
[10:31:21.867]                           }
[10:31:21.867]                         }
[10:31:21.867]                       }
[10:31:21.867]                       invisible(muffled)
[10:31:21.867]                     }
[10:31:21.867]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.867]                   }
[10:31:21.867]                 }
[10:31:21.867]             }
[10:31:21.867]         }))
[10:31:21.867]     }, error = function(ex) {
[10:31:21.867]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:21.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.867]                 ...future.rng), started = ...future.startTime, 
[10:31:21.867]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:21.867]             version = "1.8"), class = "FutureResult")
[10:31:21.867]     }, finally = {
[10:31:21.867]         if (!identical(...future.workdir, getwd())) 
[10:31:21.867]             setwd(...future.workdir)
[10:31:21.867]         {
[10:31:21.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:21.867]                 ...future.oldOptions$nwarnings <- NULL
[10:31:21.867]             }
[10:31:21.867]             base::options(...future.oldOptions)
[10:31:21.867]             if (.Platform$OS.type == "windows") {
[10:31:21.867]                 old_names <- names(...future.oldEnvVars)
[10:31:21.867]                 envs <- base::Sys.getenv()
[10:31:21.867]                 names <- names(envs)
[10:31:21.867]                 common <- intersect(names, old_names)
[10:31:21.867]                 added <- setdiff(names, old_names)
[10:31:21.867]                 removed <- setdiff(old_names, names)
[10:31:21.867]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:21.867]                   envs[common]]
[10:31:21.867]                 NAMES <- toupper(changed)
[10:31:21.867]                 args <- list()
[10:31:21.867]                 for (kk in seq_along(NAMES)) {
[10:31:21.867]                   name <- changed[[kk]]
[10:31:21.867]                   NAME <- NAMES[[kk]]
[10:31:21.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.867]                     next
[10:31:21.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.867]                 }
[10:31:21.867]                 NAMES <- toupper(added)
[10:31:21.867]                 for (kk in seq_along(NAMES)) {
[10:31:21.867]                   name <- added[[kk]]
[10:31:21.867]                   NAME <- NAMES[[kk]]
[10:31:21.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.867]                     next
[10:31:21.867]                   args[[name]] <- ""
[10:31:21.867]                 }
[10:31:21.867]                 NAMES <- toupper(removed)
[10:31:21.867]                 for (kk in seq_along(NAMES)) {
[10:31:21.867]                   name <- removed[[kk]]
[10:31:21.867]                   NAME <- NAMES[[kk]]
[10:31:21.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.867]                     next
[10:31:21.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.867]                 }
[10:31:21.867]                 if (length(args) > 0) 
[10:31:21.867]                   base::do.call(base::Sys.setenv, args = args)
[10:31:21.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:21.867]             }
[10:31:21.867]             else {
[10:31:21.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:21.867]             }
[10:31:21.867]             {
[10:31:21.867]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:21.867]                   0L) {
[10:31:21.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:21.867]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:21.867]                   base::options(opts)
[10:31:21.867]                 }
[10:31:21.867]                 {
[10:31:21.867]                   {
[10:31:21.867]                     NULL
[10:31:21.867]                     RNGkind("Mersenne-Twister")
[10:31:21.867]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:21.867]                       inherits = FALSE)
[10:31:21.867]                   }
[10:31:21.867]                   options(future.plan = NULL)
[10:31:21.867]                   if (is.na(NA_character_)) 
[10:31:21.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:21.867]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:21.867]                     .init = FALSE)
[10:31:21.867]                 }
[10:31:21.867]             }
[10:31:21.867]         }
[10:31:21.867]     })
[10:31:21.867]     if (TRUE) {
[10:31:21.867]         base::sink(type = "output", split = FALSE)
[10:31:21.867]         if (TRUE) {
[10:31:21.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:21.867]         }
[10:31:21.867]         else {
[10:31:21.867]             ...future.result["stdout"] <- base::list(NULL)
[10:31:21.867]         }
[10:31:21.867]         base::close(...future.stdout)
[10:31:21.867]         ...future.stdout <- NULL
[10:31:21.867]     }
[10:31:21.867]     ...future.result$conditions <- ...future.conditions
[10:31:21.867]     ...future.result$finished <- base::Sys.time()
[10:31:21.867]     ...future.result
[10:31:21.867] }
[10:31:21.869] assign_globals() ...
[10:31:21.869] List of 11
[10:31:21.869]  $ ...future.FUN            :function (x, ...)  
[10:31:21.869]  $ x_FUN                    :function (x)  
[10:31:21.869]  $ times                    : int 4
[10:31:21.869]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.869]  $ stop_if_not              :function (...)  
[10:31:21.869]  $ dim                      : int [1:2] 2 2
[10:31:21.869]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:21.869]  $ future.call.arguments    : list()
[10:31:21.869]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.869]  $ ...future.elements_ii    :List of 10
[10:31:21.869]   ..$ : int 1
[10:31:21.869]   ..$ : int 2
[10:31:21.869]   ..$ : int 3
[10:31:21.869]   ..$ : int 4
[10:31:21.869]   ..$ : int 5
[10:31:21.869]   ..$ : int 6
[10:31:21.869]   ..$ : int 7
[10:31:21.869]   ..$ : int 8
[10:31:21.869]   ..$ : int 9
[10:31:21.869]   ..$ : int 10
[10:31:21.869]  $ ...future.seeds_ii       : NULL
[10:31:21.869]  $ ...future.globals.maxSize: NULL
[10:31:21.869]  - attr(*, "where")=List of 11
[10:31:21.869]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:21.869]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:21.869]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:21.869]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:21.869]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:21.869]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:21.869]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:21.869]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:21.869]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:21.869]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:21.869]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:21.869]  - attr(*, "resolved")= logi FALSE
[10:31:21.869]  - attr(*, "total_size")= num 97304
[10:31:21.869]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.869]  - attr(*, "already-done")= logi TRUE
[10:31:21.908] - copied ‘...future.FUN’ to environment
[10:31:21.908] - reassign environment for ‘x_FUN’
[10:31:21.908] - copied ‘x_FUN’ to environment
[10:31:21.908] - copied ‘times’ to environment
[10:31:21.908] - copied ‘stopf’ to environment
[10:31:21.908] - copied ‘stop_if_not’ to environment
[10:31:21.908] - copied ‘dim’ to environment
[10:31:21.908] - copied ‘valid_types’ to environment
[10:31:21.908] - copied ‘future.call.arguments’ to environment
[10:31:21.909] - copied ‘...future.elements_ii’ to environment
[10:31:21.909] - copied ‘...future.seeds_ii’ to environment
[10:31:21.909] - copied ‘...future.globals.maxSize’ to environment
[10:31:21.909] assign_globals() ... done
[10:31:21.909] plan(): Setting new future strategy stack:
[10:31:21.909] List of future strategies:
[10:31:21.909] 1. sequential:
[10:31:21.909]    - args: function (..., envir = parent.frame())
[10:31:21.909]    - tweaked: FALSE
[10:31:21.909]    - call: NULL
[10:31:21.910] plan(): nbrOfWorkers() = 1
[10:31:21.911] plan(): Setting new future strategy stack:
[10:31:21.911] List of future strategies:
[10:31:21.911] 1. sequential:
[10:31:21.911]    - args: function (..., envir = parent.frame())
[10:31:21.911]    - tweaked: FALSE
[10:31:21.911]    - call: plan(strategy)
[10:31:21.911] plan(): nbrOfWorkers() = 1
[10:31:21.911] SequentialFuture started (and completed)
[10:31:21.911] - Launch lazy future ... done
[10:31:21.911] run() for ‘SequentialFuture’ ... done
[10:31:21.912] Created future:
[10:31:21.912] SequentialFuture:
[10:31:21.912] Label: ‘future_vapply-1’
[10:31:21.912] Expression:
[10:31:21.912] {
[10:31:21.912]     do.call(function(...) {
[10:31:21.912]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.912]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.912]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.912]             on.exit(options(oopts), add = TRUE)
[10:31:21.912]         }
[10:31:21.912]         {
[10:31:21.912]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.912]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.912]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.912]             })
[10:31:21.912]         }
[10:31:21.912]     }, args = future.call.arguments)
[10:31:21.912] }
[10:31:21.912] Lazy evaluation: FALSE
[10:31:21.912] Asynchronous evaluation: FALSE
[10:31:21.912] Local evaluation: TRUE
[10:31:21.912] Environment: R_GlobalEnv
[10:31:21.912] Capture standard output: TRUE
[10:31:21.912] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:21.912] Globals: 11 objects totaling 95.57 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:21.912] Packages: 1 packages (‘future.apply’)
[10:31:21.912] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:21.912] Resolved: TRUE
[10:31:21.912] Value: 2.27 KiB of class ‘list’
[10:31:21.912] Early signaling: FALSE
[10:31:21.912] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:21.912] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.913] Chunk #1 of 1 ... DONE
[10:31:21.913] Launching 1 futures (chunks) ... DONE
[10:31:21.913] Resolving 1 futures (chunks) ...
[10:31:21.913] resolve() on list ...
[10:31:21.913]  recursive: 0
[10:31:21.913]  length: 1
[10:31:21.914] 
[10:31:21.914] resolved() for ‘SequentialFuture’ ...
[10:31:21.914] - state: ‘finished’
[10:31:21.914] - run: TRUE
[10:31:21.914] - result: ‘FutureResult’
[10:31:21.914] resolved() for ‘SequentialFuture’ ... done
[10:31:21.914] Future #1
[10:31:21.914] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:21.914] - nx: 1
[10:31:21.914] - relay: TRUE
[10:31:21.915] - stdout: TRUE
[10:31:21.915] - signal: TRUE
[10:31:21.915] - resignal: FALSE
[10:31:21.915] - force: TRUE
[10:31:21.915] - relayed: [n=1] FALSE
[10:31:21.915] - queued futures: [n=1] FALSE
[10:31:21.915]  - until=1
[10:31:21.915]  - relaying element #1
[10:31:21.915] - relayed: [n=1] TRUE
[10:31:21.915] - queued futures: [n=1] TRUE
[10:31:21.916] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:21.916]  length: 0 (resolved future 1)
[10:31:21.916] Relaying remaining futures
[10:31:21.916] signalConditionsASAP(NULL, pos=0) ...
[10:31:21.916] - nx: 1
[10:31:21.916] - relay: TRUE
[10:31:21.916] - stdout: TRUE
[10:31:21.916] - signal: TRUE
[10:31:21.916] - resignal: FALSE
[10:31:21.916] - force: TRUE
[10:31:21.916] - relayed: [n=1] TRUE
[10:31:21.916] - queued futures: [n=1] TRUE
 - flush all
[10:31:21.917] - relayed: [n=1] TRUE
[10:31:21.917] - queued futures: [n=1] TRUE
[10:31:21.917] signalConditionsASAP(NULL, pos=0) ... done
[10:31:21.917] resolve() on list ... DONE
[10:31:21.917]  - Number of value chunks collected: 1
[10:31:21.917] Resolving 1 futures (chunks) ... DONE
[10:31:21.917] Reducing values from 1 chunks ...
[10:31:21.917]  - Number of values collected after concatenation: 10
[10:31:21.917]  - Number of values expected: 10
[10:31:21.918] Reducing values from 1 chunks ... DONE
[10:31:21.918] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[10:31:21.920] future_lapply() ...
[10:31:21.921] Number of chunks: 1
[10:31:21.921] getGlobalsAndPackagesXApply() ...
[10:31:21.922]  - future.globals: TRUE
[10:31:21.922] getGlobalsAndPackages() ...
[10:31:21.922] Searching for globals...
[10:31:21.925] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[10:31:21.927] Searching for globals ... DONE
[10:31:21.927] Resolving globals: FALSE
[10:31:21.928] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[10:31:21.928] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:21.929] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.929] - packages: [1] ‘future.apply’
[10:31:21.929] getGlobalsAndPackages() ... DONE
[10:31:21.929]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.929]  - needed namespaces: [n=1] ‘future.apply’
[10:31:21.929] Finding globals ... DONE
[10:31:21.929]  - use_args: TRUE
[10:31:21.929]  - Getting '...' globals ...
[10:31:21.930] resolve() on list ...
[10:31:21.930]  recursive: 0
[10:31:21.930]  length: 1
[10:31:21.930]  elements: ‘...’
[10:31:21.930]  length: 0 (resolved future 1)
[10:31:21.930] resolve() on list ... DONE
[10:31:21.930]    - '...' content: [n=0] 
[10:31:21.930] List of 1
[10:31:21.930]  $ ...: list()
[10:31:21.930]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.930]  - attr(*, "where")=List of 1
[10:31:21.930]   ..$ ...:<environment: 0x55de85aadf48> 
[10:31:21.930]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.930]  - attr(*, "resolved")= logi TRUE
[10:31:21.930]  - attr(*, "total_size")= num NA
[10:31:21.933]  - Getting '...' globals ... DONE
[10:31:21.934] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:21.934] List of 8
[10:31:21.934]  $ ...future.FUN:function (x, ...)  
[10:31:21.934]  $ x_FUN        :function (x)  
[10:31:21.934]  $ times        : int 4
[10:31:21.934]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.934]  $ stop_if_not  :function (...)  
[10:31:21.934]  $ dim          : int [1:2] 2 2
[10:31:21.934]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:21.934]  $ ...          : list()
[10:31:21.934]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.934]  - attr(*, "where")=List of 8
[10:31:21.934]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:21.934]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:21.934]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:21.934]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:21.934]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:21.934]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:21.934]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:21.934]   ..$ ...          :<environment: 0x55de85aadf48> 
[10:31:21.934]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.934]  - attr(*, "resolved")= logi FALSE
[10:31:21.934]  - attr(*, "total_size")= num 105552
[10:31:21.940] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:21.940] getGlobalsAndPackagesXApply() ... DONE
[10:31:21.940] Number of futures (= number of chunks): 1
[10:31:21.940] Launching 1 futures (chunks) ...
[10:31:21.940] Chunk #1 of 1 ...
[10:31:21.940]  - Finding globals in 'X' for chunk #1 ...
[10:31:21.940] getGlobalsAndPackages() ...
[10:31:21.941] Searching for globals...
[10:31:21.941] 
[10:31:21.941] Searching for globals ... DONE
[10:31:21.941] - globals: [0] <none>
[10:31:21.941] getGlobalsAndPackages() ... DONE
[10:31:21.941]    + additional globals found: [n=0] 
[10:31:21.941]    + additional namespaces needed: [n=0] 
[10:31:21.941]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:21.942]  - seeds: <none>
[10:31:21.942]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.942] getGlobalsAndPackages() ...
[10:31:21.942] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.942] Resolving globals: FALSE
[10:31:21.942] Tweak future expression to call with '...' arguments ...
[10:31:21.942] {
[10:31:21.942]     do.call(function(...) {
[10:31:21.942]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.942]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.942]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.942]             on.exit(options(oopts), add = TRUE)
[10:31:21.942]         }
[10:31:21.942]         {
[10:31:21.942]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.942]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.942]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.942]             })
[10:31:21.942]         }
[10:31:21.942]     }, args = future.call.arguments)
[10:31:21.942] }
[10:31:21.942] Tweak future expression to call with '...' arguments ... DONE
[10:31:21.943] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.943] - packages: [1] ‘future.apply’
[10:31:21.943] getGlobalsAndPackages() ... DONE
[10:31:21.944] run() for ‘Future’ ...
[10:31:21.944] - state: ‘created’
[10:31:21.944] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:21.944] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.944] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:21.944]   - Field: ‘label’
[10:31:21.944]   - Field: ‘local’
[10:31:21.945]   - Field: ‘owner’
[10:31:21.945]   - Field: ‘envir’
[10:31:21.945]   - Field: ‘packages’
[10:31:21.945]   - Field: ‘gc’
[10:31:21.945]   - Field: ‘conditions’
[10:31:21.945]   - Field: ‘expr’
[10:31:21.945]   - Field: ‘uuid’
[10:31:21.945]   - Field: ‘seed’
[10:31:21.945]   - Field: ‘version’
[10:31:21.945]   - Field: ‘result’
[10:31:21.945]   - Field: ‘asynchronous’
[10:31:21.946]   - Field: ‘calls’
[10:31:21.946]   - Field: ‘globals’
[10:31:21.946]   - Field: ‘stdout’
[10:31:21.946]   - Field: ‘earlySignal’
[10:31:21.946]   - Field: ‘lazy’
[10:31:21.946]   - Field: ‘state’
[10:31:21.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:21.946] - Launch lazy future ...
[10:31:21.946] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:21.947] Packages needed by future strategies (n = 0): <none>
[10:31:21.947] {
[10:31:21.947]     {
[10:31:21.947]         {
[10:31:21.947]             ...future.startTime <- base::Sys.time()
[10:31:21.947]             {
[10:31:21.947]                 {
[10:31:21.947]                   {
[10:31:21.947]                     {
[10:31:21.947]                       base::local({
[10:31:21.947]                         has_future <- base::requireNamespace("future", 
[10:31:21.947]                           quietly = TRUE)
[10:31:21.947]                         if (has_future) {
[10:31:21.947]                           ns <- base::getNamespace("future")
[10:31:21.947]                           version <- ns[[".package"]][["version"]]
[10:31:21.947]                           if (is.null(version)) 
[10:31:21.947]                             version <- utils::packageVersion("future")
[10:31:21.947]                         }
[10:31:21.947]                         else {
[10:31:21.947]                           version <- NULL
[10:31:21.947]                         }
[10:31:21.947]                         if (!has_future || version < "1.8.0") {
[10:31:21.947]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:21.947]                             "", base::R.version$version.string), 
[10:31:21.947]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:21.947]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:21.947]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:21.947]                               "release", "version")], collapse = " "), 
[10:31:21.947]                             hostname = base::Sys.info()[["nodename"]])
[10:31:21.947]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:21.947]                             info)
[10:31:21.947]                           info <- base::paste(info, collapse = "; ")
[10:31:21.947]                           if (!has_future) {
[10:31:21.947]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:21.947]                               info)
[10:31:21.947]                           }
[10:31:21.947]                           else {
[10:31:21.947]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:21.947]                               info, version)
[10:31:21.947]                           }
[10:31:21.947]                           base::stop(msg)
[10:31:21.947]                         }
[10:31:21.947]                       })
[10:31:21.947]                     }
[10:31:21.947]                     base::local({
[10:31:21.947]                       for (pkg in "future.apply") {
[10:31:21.947]                         base::loadNamespace(pkg)
[10:31:21.947]                         base::library(pkg, character.only = TRUE)
[10:31:21.947]                       }
[10:31:21.947]                     })
[10:31:21.947]                   }
[10:31:21.947]                   ...future.strategy.old <- future::plan("list")
[10:31:21.947]                   options(future.plan = NULL)
[10:31:21.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:21.947]                 }
[10:31:21.947]                 ...future.workdir <- getwd()
[10:31:21.947]             }
[10:31:21.947]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:21.947]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:21.947]         }
[10:31:21.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:21.947]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:21.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:21.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:21.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:21.947]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:21.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:21.947]             base::names(...future.oldOptions))
[10:31:21.947]     }
[10:31:21.947]     if (FALSE) {
[10:31:21.947]     }
[10:31:21.947]     else {
[10:31:21.947]         if (TRUE) {
[10:31:21.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:21.947]                 open = "w")
[10:31:21.947]         }
[10:31:21.947]         else {
[10:31:21.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:21.947]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:21.947]         }
[10:31:21.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:21.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:21.947]             base::sink(type = "output", split = FALSE)
[10:31:21.947]             base::close(...future.stdout)
[10:31:21.947]         }, add = TRUE)
[10:31:21.947]     }
[10:31:21.947]     ...future.frame <- base::sys.nframe()
[10:31:21.947]     ...future.conditions <- base::list()
[10:31:21.947]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:21.947]     if (FALSE) {
[10:31:21.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:21.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:21.947]     }
[10:31:21.947]     ...future.result <- base::tryCatch({
[10:31:21.947]         base::withCallingHandlers({
[10:31:21.947]             ...future.value <- base::withVisible(base::local({
[10:31:21.947]                 do.call(function(...) {
[10:31:21.947]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.947]                   if (!identical(...future.globals.maxSize.org, 
[10:31:21.947]                     ...future.globals.maxSize)) {
[10:31:21.947]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.947]                     on.exit(options(oopts), add = TRUE)
[10:31:21.947]                   }
[10:31:21.947]                   {
[10:31:21.947]                     lapply(seq_along(...future.elements_ii), 
[10:31:21.947]                       FUN = function(jj) {
[10:31:21.947]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.947]                         ...future.FUN(...future.X_jj, ...)
[10:31:21.947]                       })
[10:31:21.947]                   }
[10:31:21.947]                 }, args = future.call.arguments)
[10:31:21.947]             }))
[10:31:21.947]             future::FutureResult(value = ...future.value$value, 
[10:31:21.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.947]                   ...future.rng), globalenv = if (FALSE) 
[10:31:21.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:21.947]                     ...future.globalenv.names))
[10:31:21.947]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:21.947]         }, condition = base::local({
[10:31:21.947]             c <- base::c
[10:31:21.947]             inherits <- base::inherits
[10:31:21.947]             invokeRestart <- base::invokeRestart
[10:31:21.947]             length <- base::length
[10:31:21.947]             list <- base::list
[10:31:21.947]             seq.int <- base::seq.int
[10:31:21.947]             signalCondition <- base::signalCondition
[10:31:21.947]             sys.calls <- base::sys.calls
[10:31:21.947]             `[[` <- base::`[[`
[10:31:21.947]             `+` <- base::`+`
[10:31:21.947]             `<<-` <- base::`<<-`
[10:31:21.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:21.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:21.947]                   3L)]
[10:31:21.947]             }
[10:31:21.947]             function(cond) {
[10:31:21.947]                 is_error <- inherits(cond, "error")
[10:31:21.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:21.947]                   NULL)
[10:31:21.947]                 if (is_error) {
[10:31:21.947]                   sessionInformation <- function() {
[10:31:21.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:21.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:21.947]                       search = base::search(), system = base::Sys.info())
[10:31:21.947]                   }
[10:31:21.947]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:21.947]                     cond$call), session = sessionInformation(), 
[10:31:21.947]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:21.947]                   signalCondition(cond)
[10:31:21.947]                 }
[10:31:21.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:21.947]                 "immediateCondition"))) {
[10:31:21.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:21.947]                   ...future.conditions[[length(...future.conditions) + 
[10:31:21.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:21.947]                   if (TRUE && !signal) {
[10:31:21.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.947]                     {
[10:31:21.947]                       inherits <- base::inherits
[10:31:21.947]                       invokeRestart <- base::invokeRestart
[10:31:21.947]                       is.null <- base::is.null
[10:31:21.947]                       muffled <- FALSE
[10:31:21.947]                       if (inherits(cond, "message")) {
[10:31:21.947]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.947]                         if (muffled) 
[10:31:21.947]                           invokeRestart("muffleMessage")
[10:31:21.947]                       }
[10:31:21.947]                       else if (inherits(cond, "warning")) {
[10:31:21.947]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.947]                         if (muffled) 
[10:31:21.947]                           invokeRestart("muffleWarning")
[10:31:21.947]                       }
[10:31:21.947]                       else if (inherits(cond, "condition")) {
[10:31:21.947]                         if (!is.null(pattern)) {
[10:31:21.947]                           computeRestarts <- base::computeRestarts
[10:31:21.947]                           grepl <- base::grepl
[10:31:21.947]                           restarts <- computeRestarts(cond)
[10:31:21.947]                           for (restart in restarts) {
[10:31:21.947]                             name <- restart$name
[10:31:21.947]                             if (is.null(name)) 
[10:31:21.947]                               next
[10:31:21.947]                             if (!grepl(pattern, name)) 
[10:31:21.947]                               next
[10:31:21.947]                             invokeRestart(restart)
[10:31:21.947]                             muffled <- TRUE
[10:31:21.947]                             break
[10:31:21.947]                           }
[10:31:21.947]                         }
[10:31:21.947]                       }
[10:31:21.947]                       invisible(muffled)
[10:31:21.947]                     }
[10:31:21.947]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.947]                   }
[10:31:21.947]                 }
[10:31:21.947]                 else {
[10:31:21.947]                   if (TRUE) {
[10:31:21.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:21.947]                     {
[10:31:21.947]                       inherits <- base::inherits
[10:31:21.947]                       invokeRestart <- base::invokeRestart
[10:31:21.947]                       is.null <- base::is.null
[10:31:21.947]                       muffled <- FALSE
[10:31:21.947]                       if (inherits(cond, "message")) {
[10:31:21.947]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:21.947]                         if (muffled) 
[10:31:21.947]                           invokeRestart("muffleMessage")
[10:31:21.947]                       }
[10:31:21.947]                       else if (inherits(cond, "warning")) {
[10:31:21.947]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:21.947]                         if (muffled) 
[10:31:21.947]                           invokeRestart("muffleWarning")
[10:31:21.947]                       }
[10:31:21.947]                       else if (inherits(cond, "condition")) {
[10:31:21.947]                         if (!is.null(pattern)) {
[10:31:21.947]                           computeRestarts <- base::computeRestarts
[10:31:21.947]                           grepl <- base::grepl
[10:31:21.947]                           restarts <- computeRestarts(cond)
[10:31:21.947]                           for (restart in restarts) {
[10:31:21.947]                             name <- restart$name
[10:31:21.947]                             if (is.null(name)) 
[10:31:21.947]                               next
[10:31:21.947]                             if (!grepl(pattern, name)) 
[10:31:21.947]                               next
[10:31:21.947]                             invokeRestart(restart)
[10:31:21.947]                             muffled <- TRUE
[10:31:21.947]                             break
[10:31:21.947]                           }
[10:31:21.947]                         }
[10:31:21.947]                       }
[10:31:21.947]                       invisible(muffled)
[10:31:21.947]                     }
[10:31:21.947]                     muffleCondition(cond, pattern = "^muffle")
[10:31:21.947]                   }
[10:31:21.947]                 }
[10:31:21.947]             }
[10:31:21.947]         }))
[10:31:21.947]     }, error = function(ex) {
[10:31:21.947]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:21.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:21.947]                 ...future.rng), started = ...future.startTime, 
[10:31:21.947]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:21.947]             version = "1.8"), class = "FutureResult")
[10:31:21.947]     }, finally = {
[10:31:21.947]         if (!identical(...future.workdir, getwd())) 
[10:31:21.947]             setwd(...future.workdir)
[10:31:21.947]         {
[10:31:21.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:21.947]                 ...future.oldOptions$nwarnings <- NULL
[10:31:21.947]             }
[10:31:21.947]             base::options(...future.oldOptions)
[10:31:21.947]             if (.Platform$OS.type == "windows") {
[10:31:21.947]                 old_names <- names(...future.oldEnvVars)
[10:31:21.947]                 envs <- base::Sys.getenv()
[10:31:21.947]                 names <- names(envs)
[10:31:21.947]                 common <- intersect(names, old_names)
[10:31:21.947]                 added <- setdiff(names, old_names)
[10:31:21.947]                 removed <- setdiff(old_names, names)
[10:31:21.947]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:21.947]                   envs[common]]
[10:31:21.947]                 NAMES <- toupper(changed)
[10:31:21.947]                 args <- list()
[10:31:21.947]                 for (kk in seq_along(NAMES)) {
[10:31:21.947]                   name <- changed[[kk]]
[10:31:21.947]                   NAME <- NAMES[[kk]]
[10:31:21.947]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.947]                     next
[10:31:21.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.947]                 }
[10:31:21.947]                 NAMES <- toupper(added)
[10:31:21.947]                 for (kk in seq_along(NAMES)) {
[10:31:21.947]                   name <- added[[kk]]
[10:31:21.947]                   NAME <- NAMES[[kk]]
[10:31:21.947]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.947]                     next
[10:31:21.947]                   args[[name]] <- ""
[10:31:21.947]                 }
[10:31:21.947]                 NAMES <- toupper(removed)
[10:31:21.947]                 for (kk in seq_along(NAMES)) {
[10:31:21.947]                   name <- removed[[kk]]
[10:31:21.947]                   NAME <- NAMES[[kk]]
[10:31:21.947]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:21.947]                     next
[10:31:21.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:21.947]                 }
[10:31:21.947]                 if (length(args) > 0) 
[10:31:21.947]                   base::do.call(base::Sys.setenv, args = args)
[10:31:21.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:21.947]             }
[10:31:21.947]             else {
[10:31:21.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:21.947]             }
[10:31:21.947]             {
[10:31:21.947]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:21.947]                   0L) {
[10:31:21.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:21.947]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:21.947]                   base::options(opts)
[10:31:21.947]                 }
[10:31:21.947]                 {
[10:31:21.947]                   {
[10:31:21.947]                     NULL
[10:31:21.947]                     RNGkind("Mersenne-Twister")
[10:31:21.947]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:21.947]                       inherits = FALSE)
[10:31:21.947]                   }
[10:31:21.947]                   options(future.plan = NULL)
[10:31:21.947]                   if (is.na(NA_character_)) 
[10:31:21.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:21.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:21.947]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:21.947]                     .init = FALSE)
[10:31:21.947]                 }
[10:31:21.947]             }
[10:31:21.947]         }
[10:31:21.947]     })
[10:31:21.947]     if (TRUE) {
[10:31:21.947]         base::sink(type = "output", split = FALSE)
[10:31:21.947]         if (TRUE) {
[10:31:21.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:21.947]         }
[10:31:21.947]         else {
[10:31:21.947]             ...future.result["stdout"] <- base::list(NULL)
[10:31:21.947]         }
[10:31:21.947]         base::close(...future.stdout)
[10:31:21.947]         ...future.stdout <- NULL
[10:31:21.947]     }
[10:31:21.947]     ...future.result$conditions <- ...future.conditions
[10:31:21.947]     ...future.result$finished <- base::Sys.time()
[10:31:21.947]     ...future.result
[10:31:21.947] }
[10:31:21.949] assign_globals() ...
[10:31:21.949] List of 11
[10:31:21.949]  $ ...future.FUN            :function (x, ...)  
[10:31:21.949]  $ x_FUN                    :function (x)  
[10:31:21.949]  $ times                    : int 4
[10:31:21.949]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.949]  $ stop_if_not              :function (...)  
[10:31:21.949]  $ dim                      : int [1:2] 2 2
[10:31:21.949]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:21.949]  $ future.call.arguments    : list()
[10:31:21.949]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.949]  $ ...future.elements_ii    :List of 10
[10:31:21.949]   ..$ : int 1
[10:31:21.949]   ..$ : int 2
[10:31:21.949]   ..$ : int 3
[10:31:21.949]   ..$ : int 4
[10:31:21.949]   ..$ : int 5
[10:31:21.949]   ..$ : int 6
[10:31:21.949]   ..$ : int 7
[10:31:21.949]   ..$ : int 8
[10:31:21.949]   ..$ : int 9
[10:31:21.949]   ..$ : int 10
[10:31:21.949]  $ ...future.seeds_ii       : NULL
[10:31:21.949]  $ ...future.globals.maxSize: NULL
[10:31:21.949]  - attr(*, "where")=List of 11
[10:31:21.949]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:21.949]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:21.949]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:21.949]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:21.949]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:21.949]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:21.949]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:21.949]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:21.949]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:21.949]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:21.949]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:21.949]  - attr(*, "resolved")= logi FALSE
[10:31:21.949]  - attr(*, "total_size")= num 105552
[10:31:21.949]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.949]  - attr(*, "already-done")= logi TRUE
[10:31:21.961] - copied ‘...future.FUN’ to environment
[10:31:21.961] - reassign environment for ‘x_FUN’
[10:31:21.961] - copied ‘x_FUN’ to environment
[10:31:21.961] - copied ‘times’ to environment
[10:31:21.961] - copied ‘stopf’ to environment
[10:31:21.962] - copied ‘stop_if_not’ to environment
[10:31:21.962] - copied ‘dim’ to environment
[10:31:21.962] - copied ‘valid_types’ to environment
[10:31:21.962] - copied ‘future.call.arguments’ to environment
[10:31:21.962] - copied ‘...future.elements_ii’ to environment
[10:31:21.962] - copied ‘...future.seeds_ii’ to environment
[10:31:21.962] - copied ‘...future.globals.maxSize’ to environment
[10:31:21.962] assign_globals() ... done
[10:31:21.963] plan(): Setting new future strategy stack:
[10:31:21.963] List of future strategies:
[10:31:21.963] 1. sequential:
[10:31:21.963]    - args: function (..., envir = parent.frame())
[10:31:21.963]    - tweaked: FALSE
[10:31:21.963]    - call: NULL
[10:31:21.963] plan(): nbrOfWorkers() = 1
[10:31:21.964] plan(): Setting new future strategy stack:
[10:31:21.964] List of future strategies:
[10:31:21.964] 1. sequential:
[10:31:21.964]    - args: function (..., envir = parent.frame())
[10:31:21.964]    - tweaked: FALSE
[10:31:21.964]    - call: plan(strategy)
[10:31:21.965] plan(): nbrOfWorkers() = 1
[10:31:21.965] SequentialFuture started (and completed)
[10:31:21.965] - Launch lazy future ... done
[10:31:21.965] run() for ‘SequentialFuture’ ... done
[10:31:21.965] Created future:
[10:31:21.965] SequentialFuture:
[10:31:21.965] Label: ‘future_vapply-1’
[10:31:21.965] Expression:
[10:31:21.965] {
[10:31:21.965]     do.call(function(...) {
[10:31:21.965]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.965]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.965]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.965]             on.exit(options(oopts), add = TRUE)
[10:31:21.965]         }
[10:31:21.965]         {
[10:31:21.965]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.965]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.965]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.965]             })
[10:31:21.965]         }
[10:31:21.965]     }, args = future.call.arguments)
[10:31:21.965] }
[10:31:21.965] Lazy evaluation: FALSE
[10:31:21.965] Asynchronous evaluation: FALSE
[10:31:21.965] Local evaluation: TRUE
[10:31:21.965] Environment: R_GlobalEnv
[10:31:21.965] Capture standard output: TRUE
[10:31:21.965] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:21.965] Globals: 11 objects totaling 103.62 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:21.965] Packages: 1 packages (‘future.apply’)
[10:31:21.965] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:21.965] Resolved: TRUE
[10:31:21.965] Value: 7.42 KiB of class ‘list’
[10:31:21.965] Early signaling: FALSE
[10:31:21.965] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:21.965] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:21.967] Chunk #1 of 1 ... DONE
[10:31:21.967] Launching 1 futures (chunks) ... DONE
[10:31:21.967] Resolving 1 futures (chunks) ...
[10:31:21.967] resolve() on list ...
[10:31:21.967]  recursive: 0
[10:31:21.967]  length: 1
[10:31:21.967] 
[10:31:21.967] resolved() for ‘SequentialFuture’ ...
[10:31:21.967] - state: ‘finished’
[10:31:21.967] - run: TRUE
[10:31:21.967] - result: ‘FutureResult’
[10:31:21.968] resolved() for ‘SequentialFuture’ ... done
[10:31:21.968] Future #1
[10:31:21.968] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:21.968] - nx: 1
[10:31:21.968] - relay: TRUE
[10:31:21.968] - stdout: TRUE
[10:31:21.968] - signal: TRUE
[10:31:21.968] - resignal: FALSE
[10:31:21.968] - force: TRUE
[10:31:21.968] - relayed: [n=1] FALSE
[10:31:21.968] - queued futures: [n=1] FALSE
[10:31:21.969]  - until=1
[10:31:21.969]  - relaying element #1
[10:31:21.969] - relayed: [n=1] TRUE
[10:31:21.969] - queued futures: [n=1] TRUE
[10:31:21.969] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:21.969]  length: 0 (resolved future 1)
[10:31:21.970] Relaying remaining futures
[10:31:21.970] signalConditionsASAP(NULL, pos=0) ...
[10:31:21.970] - nx: 1
[10:31:21.970] - relay: TRUE
[10:31:21.970] - stdout: TRUE
[10:31:21.970] - signal: TRUE
[10:31:21.970] - resignal: FALSE
[10:31:21.971] - force: TRUE
[10:31:21.971] - relayed: [n=1] TRUE
[10:31:21.971] - queued futures: [n=1] TRUE
 - flush all
[10:31:21.971] - relayed: [n=1] TRUE
[10:31:21.971] - queued futures: [n=1] TRUE
[10:31:21.971] signalConditionsASAP(NULL, pos=0) ... done
[10:31:21.971] resolve() on list ... DONE
[10:31:21.972]  - Number of value chunks collected: 1
[10:31:21.972] Resolving 1 futures (chunks) ... DONE
[10:31:21.972] Reducing values from 1 chunks ...
[10:31:21.972]  - Number of values collected after concatenation: 10
[10:31:21.972]  - Number of values expected: 10
[10:31:21.972] Reducing values from 1 chunks ... DONE
[10:31:21.972] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[10:31:21.976] future_lapply() ...
[10:31:21.978] Number of chunks: 1
[10:31:21.978] getGlobalsAndPackagesXApply() ...
[10:31:21.978]  - future.globals: TRUE
[10:31:21.980] getGlobalsAndPackages() ...
[10:31:21.980] Searching for globals...
[10:31:21.984] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[10:31:21.984] Searching for globals ... DONE
[10:31:21.984] Resolving globals: FALSE
[10:31:21.985] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[10:31:21.985] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:21.985] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.986] - packages: [2] ‘stats’, ‘future.apply’
[10:31:21.986] getGlobalsAndPackages() ... DONE
[10:31:21.986]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:21.986]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:31:21.986] Finding globals ... DONE
[10:31:21.986]  - use_args: TRUE
[10:31:21.986]  - Getting '...' globals ...
[10:31:21.986] resolve() on list ...
[10:31:21.987]  recursive: 0
[10:31:21.987]  length: 1
[10:31:21.987]  elements: ‘...’
[10:31:21.987]  length: 0 (resolved future 1)
[10:31:21.987] resolve() on list ... DONE
[10:31:21.987]    - '...' content: [n=0] 
[10:31:21.987] List of 1
[10:31:21.987]  $ ...: list()
[10:31:21.987]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.987]  - attr(*, "where")=List of 1
[10:31:21.987]   ..$ ...:<environment: 0x55de85da9590> 
[10:31:21.987]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.987]  - attr(*, "resolved")= logi TRUE
[10:31:21.987]  - attr(*, "total_size")= num NA
[10:31:21.990]  - Getting '...' globals ... DONE
[10:31:21.990] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:21.990] List of 8
[10:31:21.990]  $ ...future.FUN:function (x, ...)  
[10:31:21.990]  $ x_FUN        :function (x, ...)  
[10:31:21.990]  $ times        : int 5
[10:31:21.990]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:21.990]  $ stop_if_not  :function (...)  
[10:31:21.990]  $ dim          : NULL
[10:31:21.990]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:21.990]  $ ...          : list()
[10:31:21.990]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:21.990]  - attr(*, "where")=List of 8
[10:31:21.990]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:21.990]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:21.990]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:21.990]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:21.990]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:21.990]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:21.990]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:21.990]   ..$ ...          :<environment: 0x55de85da9590> 
[10:31:21.990]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:21.990]  - attr(*, "resolved")= logi FALSE
[10:31:21.990]  - attr(*, "total_size")= num 95528
[10:31:21.995] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:31:21.995] getGlobalsAndPackagesXApply() ... DONE
[10:31:21.996] Number of futures (= number of chunks): 1
[10:31:21.996] Launching 1 futures (chunks) ...
[10:31:21.996] Chunk #1 of 1 ...
[10:31:21.996]  - Finding globals in 'X' for chunk #1 ...
[10:31:21.996] getGlobalsAndPackages() ...
[10:31:21.996] Searching for globals...
[10:31:21.996] 
[10:31:21.997] Searching for globals ... DONE
[10:31:21.997] - globals: [0] <none>
[10:31:21.997] getGlobalsAndPackages() ... DONE
[10:31:21.997]    + additional globals found: [n=0] 
[10:31:21.997]    + additional namespaces needed: [n=0] 
[10:31:21.997]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:21.997]  - seeds: <none>
[10:31:21.997]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.997] getGlobalsAndPackages() ...
[10:31:21.997] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.997] Resolving globals: FALSE
[10:31:21.998] Tweak future expression to call with '...' arguments ...
[10:31:21.998] {
[10:31:21.998]     do.call(function(...) {
[10:31:21.998]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:21.998]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:21.998]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:21.998]             on.exit(options(oopts), add = TRUE)
[10:31:21.998]         }
[10:31:21.998]         {
[10:31:21.998]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:21.998]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:21.998]                 ...future.FUN(...future.X_jj, ...)
[10:31:21.998]             })
[10:31:21.998]         }
[10:31:21.998]     }, args = future.call.arguments)
[10:31:21.998] }
[10:31:21.998] Tweak future expression to call with '...' arguments ... DONE
[10:31:21.998] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:21.999] - packages: [2] ‘stats’, ‘future.apply’
[10:31:21.999] getGlobalsAndPackages() ... DONE
[10:31:21.999] run() for ‘Future’ ...
[10:31:21.999] - state: ‘created’
[10:31:21.999] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:22.000] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.000] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:22.000]   - Field: ‘label’
[10:31:22.000]   - Field: ‘local’
[10:31:22.000]   - Field: ‘owner’
[10:31:22.000]   - Field: ‘envir’
[10:31:22.000]   - Field: ‘packages’
[10:31:22.000]   - Field: ‘gc’
[10:31:22.000]   - Field: ‘conditions’
[10:31:22.000]   - Field: ‘expr’
[10:31:22.001]   - Field: ‘uuid’
[10:31:22.001]   - Field: ‘seed’
[10:31:22.001]   - Field: ‘version’
[10:31:22.001]   - Field: ‘result’
[10:31:22.001]   - Field: ‘asynchronous’
[10:31:22.002]   - Field: ‘calls’
[10:31:22.003]   - Field: ‘globals’
[10:31:22.003]   - Field: ‘stdout’
[10:31:22.003]   - Field: ‘earlySignal’
[10:31:22.003]   - Field: ‘lazy’
[10:31:22.003]   - Field: ‘state’
[10:31:22.003] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:22.003] - Launch lazy future ...
[10:31:22.004] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:31:22.004] Packages needed by future strategies (n = 0): <none>
[10:31:22.004] {
[10:31:22.004]     {
[10:31:22.004]         {
[10:31:22.004]             ...future.startTime <- base::Sys.time()
[10:31:22.004]             {
[10:31:22.004]                 {
[10:31:22.004]                   {
[10:31:22.004]                     {
[10:31:22.004]                       base::local({
[10:31:22.004]                         has_future <- base::requireNamespace("future", 
[10:31:22.004]                           quietly = TRUE)
[10:31:22.004]                         if (has_future) {
[10:31:22.004]                           ns <- base::getNamespace("future")
[10:31:22.004]                           version <- ns[[".package"]][["version"]]
[10:31:22.004]                           if (is.null(version)) 
[10:31:22.004]                             version <- utils::packageVersion("future")
[10:31:22.004]                         }
[10:31:22.004]                         else {
[10:31:22.004]                           version <- NULL
[10:31:22.004]                         }
[10:31:22.004]                         if (!has_future || version < "1.8.0") {
[10:31:22.004]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.004]                             "", base::R.version$version.string), 
[10:31:22.004]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:22.004]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:22.004]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.004]                               "release", "version")], collapse = " "), 
[10:31:22.004]                             hostname = base::Sys.info()[["nodename"]])
[10:31:22.004]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.004]                             info)
[10:31:22.004]                           info <- base::paste(info, collapse = "; ")
[10:31:22.004]                           if (!has_future) {
[10:31:22.004]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.004]                               info)
[10:31:22.004]                           }
[10:31:22.004]                           else {
[10:31:22.004]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.004]                               info, version)
[10:31:22.004]                           }
[10:31:22.004]                           base::stop(msg)
[10:31:22.004]                         }
[10:31:22.004]                       })
[10:31:22.004]                     }
[10:31:22.004]                     base::local({
[10:31:22.004]                       for (pkg in c("stats", "future.apply")) {
[10:31:22.004]                         base::loadNamespace(pkg)
[10:31:22.004]                         base::library(pkg, character.only = TRUE)
[10:31:22.004]                       }
[10:31:22.004]                     })
[10:31:22.004]                   }
[10:31:22.004]                   ...future.strategy.old <- future::plan("list")
[10:31:22.004]                   options(future.plan = NULL)
[10:31:22.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.004]                 }
[10:31:22.004]                 ...future.workdir <- getwd()
[10:31:22.004]             }
[10:31:22.004]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.004]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.004]         }
[10:31:22.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.004]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:22.004]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.004]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.004]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.004]             base::names(...future.oldOptions))
[10:31:22.004]     }
[10:31:22.004]     if (FALSE) {
[10:31:22.004]     }
[10:31:22.004]     else {
[10:31:22.004]         if (TRUE) {
[10:31:22.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.004]                 open = "w")
[10:31:22.004]         }
[10:31:22.004]         else {
[10:31:22.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.004]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.004]         }
[10:31:22.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.004]             base::sink(type = "output", split = FALSE)
[10:31:22.004]             base::close(...future.stdout)
[10:31:22.004]         }, add = TRUE)
[10:31:22.004]     }
[10:31:22.004]     ...future.frame <- base::sys.nframe()
[10:31:22.004]     ...future.conditions <- base::list()
[10:31:22.004]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.004]     if (FALSE) {
[10:31:22.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.004]     }
[10:31:22.004]     ...future.result <- base::tryCatch({
[10:31:22.004]         base::withCallingHandlers({
[10:31:22.004]             ...future.value <- base::withVisible(base::local({
[10:31:22.004]                 do.call(function(...) {
[10:31:22.004]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.004]                   if (!identical(...future.globals.maxSize.org, 
[10:31:22.004]                     ...future.globals.maxSize)) {
[10:31:22.004]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.004]                     on.exit(options(oopts), add = TRUE)
[10:31:22.004]                   }
[10:31:22.004]                   {
[10:31:22.004]                     lapply(seq_along(...future.elements_ii), 
[10:31:22.004]                       FUN = function(jj) {
[10:31:22.004]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.004]                         ...future.FUN(...future.X_jj, ...)
[10:31:22.004]                       })
[10:31:22.004]                   }
[10:31:22.004]                 }, args = future.call.arguments)
[10:31:22.004]             }))
[10:31:22.004]             future::FutureResult(value = ...future.value$value, 
[10:31:22.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.004]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.004]                     ...future.globalenv.names))
[10:31:22.004]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.004]         }, condition = base::local({
[10:31:22.004]             c <- base::c
[10:31:22.004]             inherits <- base::inherits
[10:31:22.004]             invokeRestart <- base::invokeRestart
[10:31:22.004]             length <- base::length
[10:31:22.004]             list <- base::list
[10:31:22.004]             seq.int <- base::seq.int
[10:31:22.004]             signalCondition <- base::signalCondition
[10:31:22.004]             sys.calls <- base::sys.calls
[10:31:22.004]             `[[` <- base::`[[`
[10:31:22.004]             `+` <- base::`+`
[10:31:22.004]             `<<-` <- base::`<<-`
[10:31:22.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.004]                   3L)]
[10:31:22.004]             }
[10:31:22.004]             function(cond) {
[10:31:22.004]                 is_error <- inherits(cond, "error")
[10:31:22.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.004]                   NULL)
[10:31:22.004]                 if (is_error) {
[10:31:22.004]                   sessionInformation <- function() {
[10:31:22.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.004]                       search = base::search(), system = base::Sys.info())
[10:31:22.004]                   }
[10:31:22.004]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.004]                     cond$call), session = sessionInformation(), 
[10:31:22.004]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.004]                   signalCondition(cond)
[10:31:22.004]                 }
[10:31:22.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.004]                 "immediateCondition"))) {
[10:31:22.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.004]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.004]                   if (TRUE && !signal) {
[10:31:22.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.004]                     {
[10:31:22.004]                       inherits <- base::inherits
[10:31:22.004]                       invokeRestart <- base::invokeRestart
[10:31:22.004]                       is.null <- base::is.null
[10:31:22.004]                       muffled <- FALSE
[10:31:22.004]                       if (inherits(cond, "message")) {
[10:31:22.004]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.004]                         if (muffled) 
[10:31:22.004]                           invokeRestart("muffleMessage")
[10:31:22.004]                       }
[10:31:22.004]                       else if (inherits(cond, "warning")) {
[10:31:22.004]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.004]                         if (muffled) 
[10:31:22.004]                           invokeRestart("muffleWarning")
[10:31:22.004]                       }
[10:31:22.004]                       else if (inherits(cond, "condition")) {
[10:31:22.004]                         if (!is.null(pattern)) {
[10:31:22.004]                           computeRestarts <- base::computeRestarts
[10:31:22.004]                           grepl <- base::grepl
[10:31:22.004]                           restarts <- computeRestarts(cond)
[10:31:22.004]                           for (restart in restarts) {
[10:31:22.004]                             name <- restart$name
[10:31:22.004]                             if (is.null(name)) 
[10:31:22.004]                               next
[10:31:22.004]                             if (!grepl(pattern, name)) 
[10:31:22.004]                               next
[10:31:22.004]                             invokeRestart(restart)
[10:31:22.004]                             muffled <- TRUE
[10:31:22.004]                             break
[10:31:22.004]                           }
[10:31:22.004]                         }
[10:31:22.004]                       }
[10:31:22.004]                       invisible(muffled)
[10:31:22.004]                     }
[10:31:22.004]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.004]                   }
[10:31:22.004]                 }
[10:31:22.004]                 else {
[10:31:22.004]                   if (TRUE) {
[10:31:22.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.004]                     {
[10:31:22.004]                       inherits <- base::inherits
[10:31:22.004]                       invokeRestart <- base::invokeRestart
[10:31:22.004]                       is.null <- base::is.null
[10:31:22.004]                       muffled <- FALSE
[10:31:22.004]                       if (inherits(cond, "message")) {
[10:31:22.004]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.004]                         if (muffled) 
[10:31:22.004]                           invokeRestart("muffleMessage")
[10:31:22.004]                       }
[10:31:22.004]                       else if (inherits(cond, "warning")) {
[10:31:22.004]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.004]                         if (muffled) 
[10:31:22.004]                           invokeRestart("muffleWarning")
[10:31:22.004]                       }
[10:31:22.004]                       else if (inherits(cond, "condition")) {
[10:31:22.004]                         if (!is.null(pattern)) {
[10:31:22.004]                           computeRestarts <- base::computeRestarts
[10:31:22.004]                           grepl <- base::grepl
[10:31:22.004]                           restarts <- computeRestarts(cond)
[10:31:22.004]                           for (restart in restarts) {
[10:31:22.004]                             name <- restart$name
[10:31:22.004]                             if (is.null(name)) 
[10:31:22.004]                               next
[10:31:22.004]                             if (!grepl(pattern, name)) 
[10:31:22.004]                               next
[10:31:22.004]                             invokeRestart(restart)
[10:31:22.004]                             muffled <- TRUE
[10:31:22.004]                             break
[10:31:22.004]                           }
[10:31:22.004]                         }
[10:31:22.004]                       }
[10:31:22.004]                       invisible(muffled)
[10:31:22.004]                     }
[10:31:22.004]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.004]                   }
[10:31:22.004]                 }
[10:31:22.004]             }
[10:31:22.004]         }))
[10:31:22.004]     }, error = function(ex) {
[10:31:22.004]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.004]                 ...future.rng), started = ...future.startTime, 
[10:31:22.004]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.004]             version = "1.8"), class = "FutureResult")
[10:31:22.004]     }, finally = {
[10:31:22.004]         if (!identical(...future.workdir, getwd())) 
[10:31:22.004]             setwd(...future.workdir)
[10:31:22.004]         {
[10:31:22.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.004]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.004]             }
[10:31:22.004]             base::options(...future.oldOptions)
[10:31:22.004]             if (.Platform$OS.type == "windows") {
[10:31:22.004]                 old_names <- names(...future.oldEnvVars)
[10:31:22.004]                 envs <- base::Sys.getenv()
[10:31:22.004]                 names <- names(envs)
[10:31:22.004]                 common <- intersect(names, old_names)
[10:31:22.004]                 added <- setdiff(names, old_names)
[10:31:22.004]                 removed <- setdiff(old_names, names)
[10:31:22.004]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.004]                   envs[common]]
[10:31:22.004]                 NAMES <- toupper(changed)
[10:31:22.004]                 args <- list()
[10:31:22.004]                 for (kk in seq_along(NAMES)) {
[10:31:22.004]                   name <- changed[[kk]]
[10:31:22.004]                   NAME <- NAMES[[kk]]
[10:31:22.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.004]                     next
[10:31:22.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.004]                 }
[10:31:22.004]                 NAMES <- toupper(added)
[10:31:22.004]                 for (kk in seq_along(NAMES)) {
[10:31:22.004]                   name <- added[[kk]]
[10:31:22.004]                   NAME <- NAMES[[kk]]
[10:31:22.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.004]                     next
[10:31:22.004]                   args[[name]] <- ""
[10:31:22.004]                 }
[10:31:22.004]                 NAMES <- toupper(removed)
[10:31:22.004]                 for (kk in seq_along(NAMES)) {
[10:31:22.004]                   name <- removed[[kk]]
[10:31:22.004]                   NAME <- NAMES[[kk]]
[10:31:22.004]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.004]                     next
[10:31:22.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.004]                 }
[10:31:22.004]                 if (length(args) > 0) 
[10:31:22.004]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.004]             }
[10:31:22.004]             else {
[10:31:22.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.004]             }
[10:31:22.004]             {
[10:31:22.004]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.004]                   0L) {
[10:31:22.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.004]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.004]                   base::options(opts)
[10:31:22.004]                 }
[10:31:22.004]                 {
[10:31:22.004]                   {
[10:31:22.004]                     NULL
[10:31:22.004]                     RNGkind("Mersenne-Twister")
[10:31:22.004]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:22.004]                       inherits = FALSE)
[10:31:22.004]                   }
[10:31:22.004]                   options(future.plan = NULL)
[10:31:22.004]                   if (is.na(NA_character_)) 
[10:31:22.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.004]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.004]                     .init = FALSE)
[10:31:22.004]                 }
[10:31:22.004]             }
[10:31:22.004]         }
[10:31:22.004]     })
[10:31:22.004]     if (TRUE) {
[10:31:22.004]         base::sink(type = "output", split = FALSE)
[10:31:22.004]         if (TRUE) {
[10:31:22.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.004]         }
[10:31:22.004]         else {
[10:31:22.004]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.004]         }
[10:31:22.004]         base::close(...future.stdout)
[10:31:22.004]         ...future.stdout <- NULL
[10:31:22.004]     }
[10:31:22.004]     ...future.result$conditions <- ...future.conditions
[10:31:22.004]     ...future.result$finished <- base::Sys.time()
[10:31:22.004]     ...future.result
[10:31:22.004] }
[10:31:22.006] assign_globals() ...
[10:31:22.006] List of 11
[10:31:22.006]  $ ...future.FUN            :function (x, ...)  
[10:31:22.006]  $ x_FUN                    :function (x, ...)  
[10:31:22.006]  $ times                    : int 5
[10:31:22.006]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.006]  $ stop_if_not              :function (...)  
[10:31:22.006]  $ dim                      : NULL
[10:31:22.006]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:22.006]  $ future.call.arguments    : list()
[10:31:22.006]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.006]  $ ...future.elements_ii    :List of 3
[10:31:22.006]   ..$ a    : int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:31:22.006]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:31:22.006]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:31:22.006]  $ ...future.seeds_ii       : NULL
[10:31:22.006]  $ ...future.globals.maxSize: NULL
[10:31:22.006]  - attr(*, "where")=List of 11
[10:31:22.006]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.006]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.006]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.006]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.006]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.006]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.006]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.006]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.006]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.006]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.006]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.006]  - attr(*, "resolved")= logi FALSE
[10:31:22.006]  - attr(*, "total_size")= num 95528
[10:31:22.006]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.006]  - attr(*, "already-done")= logi TRUE
[10:31:22.014] - copied ‘...future.FUN’ to environment
[10:31:22.014] - copied ‘x_FUN’ to environment
[10:31:22.014] - copied ‘times’ to environment
[10:31:22.015] - copied ‘stopf’ to environment
[10:31:22.015] - copied ‘stop_if_not’ to environment
[10:31:22.015] - copied ‘dim’ to environment
[10:31:22.015] - copied ‘valid_types’ to environment
[10:31:22.015] - copied ‘future.call.arguments’ to environment
[10:31:22.015] - copied ‘...future.elements_ii’ to environment
[10:31:22.015] - copied ‘...future.seeds_ii’ to environment
[10:31:22.015] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.015] assign_globals() ... done
[10:31:22.016] plan(): Setting new future strategy stack:
[10:31:22.016] List of future strategies:
[10:31:22.016] 1. sequential:
[10:31:22.016]    - args: function (..., envir = parent.frame())
[10:31:22.016]    - tweaked: FALSE
[10:31:22.016]    - call: NULL
[10:31:22.016] plan(): nbrOfWorkers() = 1
[10:31:22.018] plan(): Setting new future strategy stack:
[10:31:22.018] List of future strategies:
[10:31:22.018] 1. sequential:
[10:31:22.018]    - args: function (..., envir = parent.frame())
[10:31:22.018]    - tweaked: FALSE
[10:31:22.018]    - call: plan(strategy)
[10:31:22.018] plan(): nbrOfWorkers() = 1
[10:31:22.019] SequentialFuture started (and completed)
[10:31:22.019] - Launch lazy future ... done
[10:31:22.019] run() for ‘SequentialFuture’ ... done
[10:31:22.019] Created future:
[10:31:22.019] SequentialFuture:
[10:31:22.019] Label: ‘future_vapply-1’
[10:31:22.019] Expression:
[10:31:22.019] {
[10:31:22.019]     do.call(function(...) {
[10:31:22.019]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.019]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.019]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.019]             on.exit(options(oopts), add = TRUE)
[10:31:22.019]         }
[10:31:22.019]         {
[10:31:22.019]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.019]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.019]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.019]             })
[10:31:22.019]         }
[10:31:22.019]     }, args = future.call.arguments)
[10:31:22.019] }
[10:31:22.019] Lazy evaluation: FALSE
[10:31:22.019] Asynchronous evaluation: FALSE
[10:31:22.019] Local evaluation: TRUE
[10:31:22.019] Environment: R_GlobalEnv
[10:31:22.019] Capture standard output: TRUE
[10:31:22.019] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.019] Globals: 11 objects totaling 93.55 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.019] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:31:22.019] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.019] Resolved: TRUE
[10:31:22.019] Value: 1.71 KiB of class ‘list’
[10:31:22.019] Early signaling: FALSE
[10:31:22.019] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.019] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.020] Chunk #1 of 1 ... DONE
[10:31:22.020] Launching 1 futures (chunks) ... DONE
[10:31:22.020] Resolving 1 futures (chunks) ...
[10:31:22.021] resolve() on list ...
[10:31:22.021]  recursive: 0
[10:31:22.021]  length: 1
[10:31:22.021] 
[10:31:22.021] resolved() for ‘SequentialFuture’ ...
[10:31:22.021] - state: ‘finished’
[10:31:22.021] - run: TRUE
[10:31:22.021] - result: ‘FutureResult’
[10:31:22.022] resolved() for ‘SequentialFuture’ ... done
[10:31:22.022] Future #1
[10:31:22.022] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:22.022] - nx: 1
[10:31:22.022] - relay: TRUE
[10:31:22.022] - stdout: TRUE
[10:31:22.022] - signal: TRUE
[10:31:22.022] - resignal: FALSE
[10:31:22.022] - force: TRUE
[10:31:22.023] - relayed: [n=1] FALSE
[10:31:22.023] - queued futures: [n=1] FALSE
[10:31:22.023]  - until=1
[10:31:22.023]  - relaying element #1
[10:31:22.023] - relayed: [n=1] TRUE
[10:31:22.023] - queued futures: [n=1] TRUE
[10:31:22.023] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:22.024]  length: 0 (resolved future 1)
[10:31:22.024] Relaying remaining futures
[10:31:22.024] signalConditionsASAP(NULL, pos=0) ...
[10:31:22.024] - nx: 1
[10:31:22.024] - relay: TRUE
[10:31:22.024] - stdout: TRUE
[10:31:22.024] - signal: TRUE
[10:31:22.024] - resignal: FALSE
[10:31:22.024] - force: TRUE
[10:31:22.024] - relayed: [n=1] TRUE
[10:31:22.025] - queued futures: [n=1] TRUE
 - flush all
[10:31:22.025] - relayed: [n=1] TRUE
[10:31:22.025] - queued futures: [n=1] TRUE
[10:31:22.025] signalConditionsASAP(NULL, pos=0) ... done
[10:31:22.025] resolve() on list ... DONE
[10:31:22.025]  - Number of value chunks collected: 1
[10:31:22.025] Resolving 1 futures (chunks) ... DONE
[10:31:22.026] Reducing values from 1 chunks ...
[10:31:22.026]  - Number of values collected after concatenation: 3
[10:31:22.026]  - Number of values expected: 3
[10:31:22.026] Reducing values from 1 chunks ... DONE
[10:31:22.026] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[10:31:22.029] future_lapply() ...
[10:31:22.033] Number of chunks: 1
[10:31:22.034] getGlobalsAndPackagesXApply() ...
[10:31:22.034]  - future.globals: TRUE
[10:31:22.034] getGlobalsAndPackages() ...
[10:31:22.034] Searching for globals...
[10:31:22.039] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:31:22.039] Searching for globals ... DONE
[10:31:22.039] Resolving globals: FALSE
[10:31:22.040] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[10:31:22.040] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[10:31:22.040] - globals: [1] ‘FUN’
[10:31:22.040] - packages: [1] ‘stats’
[10:31:22.041] getGlobalsAndPackages() ... DONE
[10:31:22.041]  - globals found/used: [n=1] ‘FUN’
[10:31:22.041]  - needed namespaces: [n=1] ‘stats’
[10:31:22.041] Finding globals ... DONE
[10:31:22.041]  - use_args: TRUE
[10:31:22.041]  - Getting '...' globals ...
[10:31:22.041] resolve() on list ...
[10:31:22.042]  recursive: 0
[10:31:22.042]  length: 1
[10:31:22.042]  elements: ‘...’
[10:31:22.042]  length: 0 (resolved future 1)
[10:31:22.042] resolve() on list ... DONE
[10:31:22.042]    - '...' content: [n=0] 
[10:31:22.042] List of 1
[10:31:22.042]  $ ...: list()
[10:31:22.042]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.042]  - attr(*, "where")=List of 1
[10:31:22.042]   ..$ ...:<environment: 0x55de85c7ba60> 
[10:31:22.042]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.042]  - attr(*, "resolved")= logi TRUE
[10:31:22.042]  - attr(*, "total_size")= num NA
[10:31:22.045]  - Getting '...' globals ... DONE
[10:31:22.045] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:22.045] List of 2
[10:31:22.045]  $ ...future.FUN:function (x, na.rm = TRUE)  
[10:31:22.045]  $ ...          : list()
[10:31:22.045]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.045]  - attr(*, "where")=List of 2
[10:31:22.045]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:22.045]   ..$ ...          :<environment: 0x55de85c7ba60> 
[10:31:22.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.045]  - attr(*, "resolved")= logi FALSE
[10:31:22.045]  - attr(*, "total_size")= num 46960
[10:31:22.048] Packages to be attached in all futures: [n=1] ‘stats’
[10:31:22.048] getGlobalsAndPackagesXApply() ... DONE
[10:31:22.048] Number of futures (= number of chunks): 1
[10:31:22.048] Launching 1 futures (chunks) ...
[10:31:22.048] Chunk #1 of 1 ...
[10:31:22.048]  - Finding globals in 'X' for chunk #1 ...
[10:31:22.048] getGlobalsAndPackages() ...
[10:31:22.050] Searching for globals...
[10:31:22.050] 
[10:31:22.051] Searching for globals ... DONE
[10:31:22.051] - globals: [0] <none>
[10:31:22.051] getGlobalsAndPackages() ... DONE
[10:31:22.051]    + additional globals found: [n=0] 
[10:31:22.051]    + additional namespaces needed: [n=0] 
[10:31:22.051]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:22.051]  - seeds: <none>
[10:31:22.051]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.052] getGlobalsAndPackages() ...
[10:31:22.052] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.052] Resolving globals: FALSE
[10:31:22.052] Tweak future expression to call with '...' arguments ...
[10:31:22.052] {
[10:31:22.052]     do.call(function(...) {
[10:31:22.052]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.052]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.052]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.052]             on.exit(options(oopts), add = TRUE)
[10:31:22.052]         }
[10:31:22.052]         {
[10:31:22.052]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.052]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.052]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.052]             })
[10:31:22.052]         }
[10:31:22.052]     }, args = future.call.arguments)
[10:31:22.052] }
[10:31:22.052] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.053] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.053] - packages: [1] ‘stats’
[10:31:22.053] getGlobalsAndPackages() ... DONE
[10:31:22.053] run() for ‘Future’ ...
[10:31:22.053] - state: ‘created’
[10:31:22.054] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:22.054] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.054] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:22.054]   - Field: ‘label’
[10:31:22.054]   - Field: ‘local’
[10:31:22.054]   - Field: ‘owner’
[10:31:22.054]   - Field: ‘envir’
[10:31:22.054]   - Field: ‘packages’
[10:31:22.055]   - Field: ‘gc’
[10:31:22.055]   - Field: ‘conditions’
[10:31:22.055]   - Field: ‘expr’
[10:31:22.055]   - Field: ‘uuid’
[10:31:22.055]   - Field: ‘seed’
[10:31:22.055]   - Field: ‘version’
[10:31:22.055]   - Field: ‘result’
[10:31:22.055]   - Field: ‘asynchronous’
[10:31:22.055]   - Field: ‘calls’
[10:31:22.055]   - Field: ‘globals’
[10:31:22.056]   - Field: ‘stdout’
[10:31:22.056]   - Field: ‘earlySignal’
[10:31:22.056]   - Field: ‘lazy’
[10:31:22.056]   - Field: ‘state’
[10:31:22.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:22.056] - Launch lazy future ...
[10:31:22.056] Packages needed by the future expression (n = 1): ‘stats’
[10:31:22.056] Packages needed by future strategies (n = 0): <none>
[10:31:22.057] {
[10:31:22.057]     {
[10:31:22.057]         {
[10:31:22.057]             ...future.startTime <- base::Sys.time()
[10:31:22.057]             {
[10:31:22.057]                 {
[10:31:22.057]                   {
[10:31:22.057]                     {
[10:31:22.057]                       base::local({
[10:31:22.057]                         has_future <- base::requireNamespace("future", 
[10:31:22.057]                           quietly = TRUE)
[10:31:22.057]                         if (has_future) {
[10:31:22.057]                           ns <- base::getNamespace("future")
[10:31:22.057]                           version <- ns[[".package"]][["version"]]
[10:31:22.057]                           if (is.null(version)) 
[10:31:22.057]                             version <- utils::packageVersion("future")
[10:31:22.057]                         }
[10:31:22.057]                         else {
[10:31:22.057]                           version <- NULL
[10:31:22.057]                         }
[10:31:22.057]                         if (!has_future || version < "1.8.0") {
[10:31:22.057]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.057]                             "", base::R.version$version.string), 
[10:31:22.057]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:22.057]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:22.057]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.057]                               "release", "version")], collapse = " "), 
[10:31:22.057]                             hostname = base::Sys.info()[["nodename"]])
[10:31:22.057]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.057]                             info)
[10:31:22.057]                           info <- base::paste(info, collapse = "; ")
[10:31:22.057]                           if (!has_future) {
[10:31:22.057]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.057]                               info)
[10:31:22.057]                           }
[10:31:22.057]                           else {
[10:31:22.057]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.057]                               info, version)
[10:31:22.057]                           }
[10:31:22.057]                           base::stop(msg)
[10:31:22.057]                         }
[10:31:22.057]                       })
[10:31:22.057]                     }
[10:31:22.057]                     base::local({
[10:31:22.057]                       for (pkg in "stats") {
[10:31:22.057]                         base::loadNamespace(pkg)
[10:31:22.057]                         base::library(pkg, character.only = TRUE)
[10:31:22.057]                       }
[10:31:22.057]                     })
[10:31:22.057]                   }
[10:31:22.057]                   ...future.strategy.old <- future::plan("list")
[10:31:22.057]                   options(future.plan = NULL)
[10:31:22.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.057]                 }
[10:31:22.057]                 ...future.workdir <- getwd()
[10:31:22.057]             }
[10:31:22.057]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.057]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.057]         }
[10:31:22.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.057]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:22.057]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.057]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.057]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.057]             base::names(...future.oldOptions))
[10:31:22.057]     }
[10:31:22.057]     if (FALSE) {
[10:31:22.057]     }
[10:31:22.057]     else {
[10:31:22.057]         if (TRUE) {
[10:31:22.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.057]                 open = "w")
[10:31:22.057]         }
[10:31:22.057]         else {
[10:31:22.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.057]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.057]         }
[10:31:22.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.057]             base::sink(type = "output", split = FALSE)
[10:31:22.057]             base::close(...future.stdout)
[10:31:22.057]         }, add = TRUE)
[10:31:22.057]     }
[10:31:22.057]     ...future.frame <- base::sys.nframe()
[10:31:22.057]     ...future.conditions <- base::list()
[10:31:22.057]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.057]     if (FALSE) {
[10:31:22.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.057]     }
[10:31:22.057]     ...future.result <- base::tryCatch({
[10:31:22.057]         base::withCallingHandlers({
[10:31:22.057]             ...future.value <- base::withVisible(base::local({
[10:31:22.057]                 do.call(function(...) {
[10:31:22.057]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.057]                   if (!identical(...future.globals.maxSize.org, 
[10:31:22.057]                     ...future.globals.maxSize)) {
[10:31:22.057]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.057]                     on.exit(options(oopts), add = TRUE)
[10:31:22.057]                   }
[10:31:22.057]                   {
[10:31:22.057]                     lapply(seq_along(...future.elements_ii), 
[10:31:22.057]                       FUN = function(jj) {
[10:31:22.057]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.057]                         ...future.FUN(...future.X_jj, ...)
[10:31:22.057]                       })
[10:31:22.057]                   }
[10:31:22.057]                 }, args = future.call.arguments)
[10:31:22.057]             }))
[10:31:22.057]             future::FutureResult(value = ...future.value$value, 
[10:31:22.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.057]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.057]                     ...future.globalenv.names))
[10:31:22.057]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.057]         }, condition = base::local({
[10:31:22.057]             c <- base::c
[10:31:22.057]             inherits <- base::inherits
[10:31:22.057]             invokeRestart <- base::invokeRestart
[10:31:22.057]             length <- base::length
[10:31:22.057]             list <- base::list
[10:31:22.057]             seq.int <- base::seq.int
[10:31:22.057]             signalCondition <- base::signalCondition
[10:31:22.057]             sys.calls <- base::sys.calls
[10:31:22.057]             `[[` <- base::`[[`
[10:31:22.057]             `+` <- base::`+`
[10:31:22.057]             `<<-` <- base::`<<-`
[10:31:22.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.057]                   3L)]
[10:31:22.057]             }
[10:31:22.057]             function(cond) {
[10:31:22.057]                 is_error <- inherits(cond, "error")
[10:31:22.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.057]                   NULL)
[10:31:22.057]                 if (is_error) {
[10:31:22.057]                   sessionInformation <- function() {
[10:31:22.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.057]                       search = base::search(), system = base::Sys.info())
[10:31:22.057]                   }
[10:31:22.057]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.057]                     cond$call), session = sessionInformation(), 
[10:31:22.057]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.057]                   signalCondition(cond)
[10:31:22.057]                 }
[10:31:22.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.057]                 "immediateCondition"))) {
[10:31:22.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.057]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.057]                   if (TRUE && !signal) {
[10:31:22.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.057]                     {
[10:31:22.057]                       inherits <- base::inherits
[10:31:22.057]                       invokeRestart <- base::invokeRestart
[10:31:22.057]                       is.null <- base::is.null
[10:31:22.057]                       muffled <- FALSE
[10:31:22.057]                       if (inherits(cond, "message")) {
[10:31:22.057]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.057]                         if (muffled) 
[10:31:22.057]                           invokeRestart("muffleMessage")
[10:31:22.057]                       }
[10:31:22.057]                       else if (inherits(cond, "warning")) {
[10:31:22.057]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.057]                         if (muffled) 
[10:31:22.057]                           invokeRestart("muffleWarning")
[10:31:22.057]                       }
[10:31:22.057]                       else if (inherits(cond, "condition")) {
[10:31:22.057]                         if (!is.null(pattern)) {
[10:31:22.057]                           computeRestarts <- base::computeRestarts
[10:31:22.057]                           grepl <- base::grepl
[10:31:22.057]                           restarts <- computeRestarts(cond)
[10:31:22.057]                           for (restart in restarts) {
[10:31:22.057]                             name <- restart$name
[10:31:22.057]                             if (is.null(name)) 
[10:31:22.057]                               next
[10:31:22.057]                             if (!grepl(pattern, name)) 
[10:31:22.057]                               next
[10:31:22.057]                             invokeRestart(restart)
[10:31:22.057]                             muffled <- TRUE
[10:31:22.057]                             break
[10:31:22.057]                           }
[10:31:22.057]                         }
[10:31:22.057]                       }
[10:31:22.057]                       invisible(muffled)
[10:31:22.057]                     }
[10:31:22.057]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.057]                   }
[10:31:22.057]                 }
[10:31:22.057]                 else {
[10:31:22.057]                   if (TRUE) {
[10:31:22.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.057]                     {
[10:31:22.057]                       inherits <- base::inherits
[10:31:22.057]                       invokeRestart <- base::invokeRestart
[10:31:22.057]                       is.null <- base::is.null
[10:31:22.057]                       muffled <- FALSE
[10:31:22.057]                       if (inherits(cond, "message")) {
[10:31:22.057]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.057]                         if (muffled) 
[10:31:22.057]                           invokeRestart("muffleMessage")
[10:31:22.057]                       }
[10:31:22.057]                       else if (inherits(cond, "warning")) {
[10:31:22.057]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.057]                         if (muffled) 
[10:31:22.057]                           invokeRestart("muffleWarning")
[10:31:22.057]                       }
[10:31:22.057]                       else if (inherits(cond, "condition")) {
[10:31:22.057]                         if (!is.null(pattern)) {
[10:31:22.057]                           computeRestarts <- base::computeRestarts
[10:31:22.057]                           grepl <- base::grepl
[10:31:22.057]                           restarts <- computeRestarts(cond)
[10:31:22.057]                           for (restart in restarts) {
[10:31:22.057]                             name <- restart$name
[10:31:22.057]                             if (is.null(name)) 
[10:31:22.057]                               next
[10:31:22.057]                             if (!grepl(pattern, name)) 
[10:31:22.057]                               next
[10:31:22.057]                             invokeRestart(restart)
[10:31:22.057]                             muffled <- TRUE
[10:31:22.057]                             break
[10:31:22.057]                           }
[10:31:22.057]                         }
[10:31:22.057]                       }
[10:31:22.057]                       invisible(muffled)
[10:31:22.057]                     }
[10:31:22.057]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.057]                   }
[10:31:22.057]                 }
[10:31:22.057]             }
[10:31:22.057]         }))
[10:31:22.057]     }, error = function(ex) {
[10:31:22.057]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.057]                 ...future.rng), started = ...future.startTime, 
[10:31:22.057]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.057]             version = "1.8"), class = "FutureResult")
[10:31:22.057]     }, finally = {
[10:31:22.057]         if (!identical(...future.workdir, getwd())) 
[10:31:22.057]             setwd(...future.workdir)
[10:31:22.057]         {
[10:31:22.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.057]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.057]             }
[10:31:22.057]             base::options(...future.oldOptions)
[10:31:22.057]             if (.Platform$OS.type == "windows") {
[10:31:22.057]                 old_names <- names(...future.oldEnvVars)
[10:31:22.057]                 envs <- base::Sys.getenv()
[10:31:22.057]                 names <- names(envs)
[10:31:22.057]                 common <- intersect(names, old_names)
[10:31:22.057]                 added <- setdiff(names, old_names)
[10:31:22.057]                 removed <- setdiff(old_names, names)
[10:31:22.057]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.057]                   envs[common]]
[10:31:22.057]                 NAMES <- toupper(changed)
[10:31:22.057]                 args <- list()
[10:31:22.057]                 for (kk in seq_along(NAMES)) {
[10:31:22.057]                   name <- changed[[kk]]
[10:31:22.057]                   NAME <- NAMES[[kk]]
[10:31:22.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.057]                     next
[10:31:22.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.057]                 }
[10:31:22.057]                 NAMES <- toupper(added)
[10:31:22.057]                 for (kk in seq_along(NAMES)) {
[10:31:22.057]                   name <- added[[kk]]
[10:31:22.057]                   NAME <- NAMES[[kk]]
[10:31:22.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.057]                     next
[10:31:22.057]                   args[[name]] <- ""
[10:31:22.057]                 }
[10:31:22.057]                 NAMES <- toupper(removed)
[10:31:22.057]                 for (kk in seq_along(NAMES)) {
[10:31:22.057]                   name <- removed[[kk]]
[10:31:22.057]                   NAME <- NAMES[[kk]]
[10:31:22.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.057]                     next
[10:31:22.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.057]                 }
[10:31:22.057]                 if (length(args) > 0) 
[10:31:22.057]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.057]             }
[10:31:22.057]             else {
[10:31:22.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.057]             }
[10:31:22.057]             {
[10:31:22.057]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.057]                   0L) {
[10:31:22.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.057]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.057]                   base::options(opts)
[10:31:22.057]                 }
[10:31:22.057]                 {
[10:31:22.057]                   {
[10:31:22.057]                     NULL
[10:31:22.057]                     RNGkind("Mersenne-Twister")
[10:31:22.057]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:22.057]                       inherits = FALSE)
[10:31:22.057]                   }
[10:31:22.057]                   options(future.plan = NULL)
[10:31:22.057]                   if (is.na(NA_character_)) 
[10:31:22.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.057]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.057]                     .init = FALSE)
[10:31:22.057]                 }
[10:31:22.057]             }
[10:31:22.057]         }
[10:31:22.057]     })
[10:31:22.057]     if (TRUE) {
[10:31:22.057]         base::sink(type = "output", split = FALSE)
[10:31:22.057]         if (TRUE) {
[10:31:22.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.057]         }
[10:31:22.057]         else {
[10:31:22.057]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.057]         }
[10:31:22.057]         base::close(...future.stdout)
[10:31:22.057]         ...future.stdout <- NULL
[10:31:22.057]     }
[10:31:22.057]     ...future.result$conditions <- ...future.conditions
[10:31:22.057]     ...future.result$finished <- base::Sys.time()
[10:31:22.057]     ...future.result
[10:31:22.057] }
[10:31:22.059] assign_globals() ...
[10:31:22.059] List of 5
[10:31:22.059]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[10:31:22.059]  $ future.call.arguments    : list()
[10:31:22.059]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.059]  $ ...future.elements_ii    :List of 7
[10:31:22.059]   ..$ : int [1:3] 1 2 3
[10:31:22.059]   ..$ : int [1:4] 1 2 3 4
[10:31:22.059]   ..$ : int [1:5] 1 2 3 4 5
[10:31:22.059]   ..$ : int [1:6] 1 2 3 4 5 6
[10:31:22.059]   ..$ : int [1:7] 1 2 3 4 5 6 7
[10:31:22.059]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[10:31:22.059]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[10:31:22.059]  $ ...future.seeds_ii       : NULL
[10:31:22.059]  $ ...future.globals.maxSize: NULL
[10:31:22.059]  - attr(*, "where")=List of 5
[10:31:22.059]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.059]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.059]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.059]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.059]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.059]  - attr(*, "resolved")= logi FALSE
[10:31:22.059]  - attr(*, "total_size")= num 46960
[10:31:22.059]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.059]  - attr(*, "already-done")= logi TRUE
[10:31:22.065] - copied ‘...future.FUN’ to environment
[10:31:22.065] - copied ‘future.call.arguments’ to environment
[10:31:22.065] - copied ‘...future.elements_ii’ to environment
[10:31:22.066] - copied ‘...future.seeds_ii’ to environment
[10:31:22.066] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.066] assign_globals() ... done
[10:31:22.066] plan(): Setting new future strategy stack:
[10:31:22.066] List of future strategies:
[10:31:22.066] 1. sequential:
[10:31:22.066]    - args: function (..., envir = parent.frame())
[10:31:22.066]    - tweaked: FALSE
[10:31:22.066]    - call: NULL
[10:31:22.067] plan(): nbrOfWorkers() = 1
[10:31:22.068] plan(): Setting new future strategy stack:
[10:31:22.068] List of future strategies:
[10:31:22.068] 1. sequential:
[10:31:22.068]    - args: function (..., envir = parent.frame())
[10:31:22.068]    - tweaked: FALSE
[10:31:22.068]    - call: plan(strategy)
[10:31:22.068] plan(): nbrOfWorkers() = 1
[10:31:22.068] SequentialFuture started (and completed)
[10:31:22.068] - Launch lazy future ... done
[10:31:22.068] run() for ‘SequentialFuture’ ... done
[10:31:22.069] Created future:
[10:31:22.069] SequentialFuture:
[10:31:22.069] Label: ‘future_sapply-1’
[10:31:22.069] Expression:
[10:31:22.069] {
[10:31:22.069]     do.call(function(...) {
[10:31:22.069]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.069]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.069]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.069]             on.exit(options(oopts), add = TRUE)
[10:31:22.069]         }
[10:31:22.069]         {
[10:31:22.069]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.069]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.069]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.069]             })
[10:31:22.069]         }
[10:31:22.069]     }, args = future.call.arguments)
[10:31:22.069] }
[10:31:22.069] Lazy evaluation: FALSE
[10:31:22.069] Asynchronous evaluation: FALSE
[10:31:22.069] Local evaluation: TRUE
[10:31:22.069] Environment: R_GlobalEnv
[10:31:22.069] Capture standard output: TRUE
[10:31:22.069] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.069] Globals: 5 objects totaling 46.39 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 544 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:22.069] Packages: 1 packages (‘stats’)
[10:31:22.069] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.069] Resolved: TRUE
[10:31:22.069] Value: 672 bytes of class ‘list’
[10:31:22.069] Early signaling: FALSE
[10:31:22.069] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.069] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.070] Chunk #1 of 1 ... DONE
[10:31:22.070] Launching 1 futures (chunks) ... DONE
[10:31:22.070] Resolving 1 futures (chunks) ...
[10:31:22.070] resolve() on list ...
[10:31:22.070]  recursive: 0
[10:31:22.070]  length: 1
[10:31:22.070] 
[10:31:22.070] resolved() for ‘SequentialFuture’ ...
[10:31:22.071] - state: ‘finished’
[10:31:22.071] - run: TRUE
[10:31:22.071] - result: ‘FutureResult’
[10:31:22.071] resolved() for ‘SequentialFuture’ ... done
[10:31:22.071] Future #1
[10:31:22.071] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:22.072] - nx: 1
[10:31:22.072] - relay: TRUE
[10:31:22.072] - stdout: TRUE
[10:31:22.072] - signal: TRUE
[10:31:22.072] - resignal: FALSE
[10:31:22.072] - force: TRUE
[10:31:22.072] - relayed: [n=1] FALSE
[10:31:22.073] - queued futures: [n=1] FALSE
[10:31:22.073]  - until=1
[10:31:22.073]  - relaying element #1
[10:31:22.073] - relayed: [n=1] TRUE
[10:31:22.073] - queued futures: [n=1] TRUE
[10:31:22.073] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:22.074]  length: 0 (resolved future 1)
[10:31:22.074] Relaying remaining futures
[10:31:22.074] signalConditionsASAP(NULL, pos=0) ...
[10:31:22.074] - nx: 1
[10:31:22.074] - relay: TRUE
[10:31:22.074] - stdout: TRUE
[10:31:22.074] - signal: TRUE
[10:31:22.074] - resignal: FALSE
[10:31:22.074] - force: TRUE
[10:31:22.074] - relayed: [n=1] TRUE
[10:31:22.074] - queued futures: [n=1] TRUE
 - flush all
[10:31:22.075] - relayed: [n=1] TRUE
[10:31:22.075] - queued futures: [n=1] TRUE
[10:31:22.075] signalConditionsASAP(NULL, pos=0) ... done
[10:31:22.075] resolve() on list ... DONE
[10:31:22.077]  - Number of value chunks collected: 1
[10:31:22.077] Resolving 1 futures (chunks) ... DONE
[10:31:22.077] Reducing values from 1 chunks ...
[10:31:22.077]  - Number of values collected after concatenation: 7
[10:31:22.077]  - Number of values expected: 7
[10:31:22.077] Reducing values from 1 chunks ... DONE
[10:31:22.077] future_lapply() ... DONE
[10:31:22.078] future_lapply() ...
[10:31:22.080] Number of chunks: 1
[10:31:22.080] getGlobalsAndPackagesXApply() ...
[10:31:22.080]  - future.globals: TRUE
[10:31:22.080] getGlobalsAndPackages() ...
[10:31:22.080] Searching for globals...
[10:31:22.087] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:31:22.087] Searching for globals ... DONE
[10:31:22.088] Resolving globals: FALSE
[10:31:22.089] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[10:31:22.089] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[10:31:22.089] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.090] - packages: [2] ‘stats’, ‘future.apply’
[10:31:22.090] getGlobalsAndPackages() ... DONE
[10:31:22.090]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.090]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:31:22.090] Finding globals ... DONE
[10:31:22.090]  - use_args: TRUE
[10:31:22.090]  - Getting '...' globals ...
[10:31:22.091] resolve() on list ...
[10:31:22.091]  recursive: 0
[10:31:22.091]  length: 1
[10:31:22.091]  elements: ‘...’
[10:31:22.091]  length: 0 (resolved future 1)
[10:31:22.091] resolve() on list ... DONE
[10:31:22.091]    - '...' content: [n=0] 
[10:31:22.091] List of 1
[10:31:22.091]  $ ...: list()
[10:31:22.091]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.091]  - attr(*, "where")=List of 1
[10:31:22.091]   ..$ ...:<environment: 0x55de857bdc10> 
[10:31:22.091]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.091]  - attr(*, "resolved")= logi TRUE
[10:31:22.091]  - attr(*, "total_size")= num NA
[10:31:22.094]  - Getting '...' globals ... DONE
[10:31:22.094] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:22.094] List of 8
[10:31:22.094]  $ ...future.FUN:function (x, ...)  
[10:31:22.094]  $ x_FUN        :function (x, na.rm = TRUE)  
[10:31:22.094]  $ times        : int 5
[10:31:22.094]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.094]  $ stop_if_not  :function (...)  
[10:31:22.094]  $ dim          : NULL
[10:31:22.094]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:22.094]  $ ...          : list()
[10:31:22.094]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.094]  - attr(*, "where")=List of 8
[10:31:22.094]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:22.094]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:22.094]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:22.094]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:22.094]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:22.094]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:22.094]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:22.094]   ..$ ...          :<environment: 0x55de857bdc10> 
[10:31:22.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.094]  - attr(*, "resolved")= logi FALSE
[10:31:22.094]  - attr(*, "total_size")= num 141240
[10:31:22.102] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:31:22.102] getGlobalsAndPackagesXApply() ... DONE
[10:31:22.102] Number of futures (= number of chunks): 1
[10:31:22.102] Launching 1 futures (chunks) ...
[10:31:22.102] Chunk #1 of 1 ...
[10:31:22.102]  - Finding globals in 'X' for chunk #1 ...
[10:31:22.102] getGlobalsAndPackages() ...
[10:31:22.103] Searching for globals...
[10:31:22.103] 
[10:31:22.103] Searching for globals ... DONE
[10:31:22.103] - globals: [0] <none>
[10:31:22.103] getGlobalsAndPackages() ... DONE
[10:31:22.103]    + additional globals found: [n=0] 
[10:31:22.103]    + additional namespaces needed: [n=0] 
[10:31:22.103]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:22.103]  - seeds: <none>
[10:31:22.104]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.104] getGlobalsAndPackages() ...
[10:31:22.104] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.104] Resolving globals: FALSE
[10:31:22.104] Tweak future expression to call with '...' arguments ...
[10:31:22.104] {
[10:31:22.104]     do.call(function(...) {
[10:31:22.104]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.104]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.104]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.104]             on.exit(options(oopts), add = TRUE)
[10:31:22.104]         }
[10:31:22.104]         {
[10:31:22.104]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.104]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.104]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.104]             })
[10:31:22.104]         }
[10:31:22.104]     }, args = future.call.arguments)
[10:31:22.104] }
[10:31:22.104] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.105] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.105] - packages: [2] ‘stats’, ‘future.apply’
[10:31:22.105] getGlobalsAndPackages() ... DONE
[10:31:22.105] run() for ‘Future’ ...
[10:31:22.106] - state: ‘created’
[10:31:22.106] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:22.106] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.106] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:22.106]   - Field: ‘label’
[10:31:22.106]   - Field: ‘local’
[10:31:22.106]   - Field: ‘owner’
[10:31:22.106]   - Field: ‘envir’
[10:31:22.107]   - Field: ‘packages’
[10:31:22.107]   - Field: ‘gc’
[10:31:22.107]   - Field: ‘conditions’
[10:31:22.107]   - Field: ‘expr’
[10:31:22.107]   - Field: ‘uuid’
[10:31:22.107]   - Field: ‘seed’
[10:31:22.107]   - Field: ‘version’
[10:31:22.107]   - Field: ‘result’
[10:31:22.107]   - Field: ‘asynchronous’
[10:31:22.107]   - Field: ‘calls’
[10:31:22.108]   - Field: ‘globals’
[10:31:22.108]   - Field: ‘stdout’
[10:31:22.108]   - Field: ‘earlySignal’
[10:31:22.108]   - Field: ‘lazy’
[10:31:22.108]   - Field: ‘state’
[10:31:22.108] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:22.108] - Launch lazy future ...
[10:31:22.108] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:31:22.108] Packages needed by future strategies (n = 0): <none>
[10:31:22.109] {
[10:31:22.109]     {
[10:31:22.109]         {
[10:31:22.109]             ...future.startTime <- base::Sys.time()
[10:31:22.109]             {
[10:31:22.109]                 {
[10:31:22.109]                   {
[10:31:22.109]                     {
[10:31:22.109]                       base::local({
[10:31:22.109]                         has_future <- base::requireNamespace("future", 
[10:31:22.109]                           quietly = TRUE)
[10:31:22.109]                         if (has_future) {
[10:31:22.109]                           ns <- base::getNamespace("future")
[10:31:22.109]                           version <- ns[[".package"]][["version"]]
[10:31:22.109]                           if (is.null(version)) 
[10:31:22.109]                             version <- utils::packageVersion("future")
[10:31:22.109]                         }
[10:31:22.109]                         else {
[10:31:22.109]                           version <- NULL
[10:31:22.109]                         }
[10:31:22.109]                         if (!has_future || version < "1.8.0") {
[10:31:22.109]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.109]                             "", base::R.version$version.string), 
[10:31:22.109]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:22.109]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:22.109]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.109]                               "release", "version")], collapse = " "), 
[10:31:22.109]                             hostname = base::Sys.info()[["nodename"]])
[10:31:22.109]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.109]                             info)
[10:31:22.109]                           info <- base::paste(info, collapse = "; ")
[10:31:22.109]                           if (!has_future) {
[10:31:22.109]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.109]                               info)
[10:31:22.109]                           }
[10:31:22.109]                           else {
[10:31:22.109]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.109]                               info, version)
[10:31:22.109]                           }
[10:31:22.109]                           base::stop(msg)
[10:31:22.109]                         }
[10:31:22.109]                       })
[10:31:22.109]                     }
[10:31:22.109]                     base::local({
[10:31:22.109]                       for (pkg in c("stats", "future.apply")) {
[10:31:22.109]                         base::loadNamespace(pkg)
[10:31:22.109]                         base::library(pkg, character.only = TRUE)
[10:31:22.109]                       }
[10:31:22.109]                     })
[10:31:22.109]                   }
[10:31:22.109]                   ...future.strategy.old <- future::plan("list")
[10:31:22.109]                   options(future.plan = NULL)
[10:31:22.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.109]                 }
[10:31:22.109]                 ...future.workdir <- getwd()
[10:31:22.109]             }
[10:31:22.109]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.109]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.109]         }
[10:31:22.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.109]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:22.109]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.109]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.109]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.109]             base::names(...future.oldOptions))
[10:31:22.109]     }
[10:31:22.109]     if (FALSE) {
[10:31:22.109]     }
[10:31:22.109]     else {
[10:31:22.109]         if (TRUE) {
[10:31:22.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.109]                 open = "w")
[10:31:22.109]         }
[10:31:22.109]         else {
[10:31:22.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.109]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.109]         }
[10:31:22.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.109]             base::sink(type = "output", split = FALSE)
[10:31:22.109]             base::close(...future.stdout)
[10:31:22.109]         }, add = TRUE)
[10:31:22.109]     }
[10:31:22.109]     ...future.frame <- base::sys.nframe()
[10:31:22.109]     ...future.conditions <- base::list()
[10:31:22.109]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.109]     if (FALSE) {
[10:31:22.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.109]     }
[10:31:22.109]     ...future.result <- base::tryCatch({
[10:31:22.109]         base::withCallingHandlers({
[10:31:22.109]             ...future.value <- base::withVisible(base::local({
[10:31:22.109]                 do.call(function(...) {
[10:31:22.109]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.109]                   if (!identical(...future.globals.maxSize.org, 
[10:31:22.109]                     ...future.globals.maxSize)) {
[10:31:22.109]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.109]                     on.exit(options(oopts), add = TRUE)
[10:31:22.109]                   }
[10:31:22.109]                   {
[10:31:22.109]                     lapply(seq_along(...future.elements_ii), 
[10:31:22.109]                       FUN = function(jj) {
[10:31:22.109]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.109]                         ...future.FUN(...future.X_jj, ...)
[10:31:22.109]                       })
[10:31:22.109]                   }
[10:31:22.109]                 }, args = future.call.arguments)
[10:31:22.109]             }))
[10:31:22.109]             future::FutureResult(value = ...future.value$value, 
[10:31:22.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.109]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.109]                     ...future.globalenv.names))
[10:31:22.109]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.109]         }, condition = base::local({
[10:31:22.109]             c <- base::c
[10:31:22.109]             inherits <- base::inherits
[10:31:22.109]             invokeRestart <- base::invokeRestart
[10:31:22.109]             length <- base::length
[10:31:22.109]             list <- base::list
[10:31:22.109]             seq.int <- base::seq.int
[10:31:22.109]             signalCondition <- base::signalCondition
[10:31:22.109]             sys.calls <- base::sys.calls
[10:31:22.109]             `[[` <- base::`[[`
[10:31:22.109]             `+` <- base::`+`
[10:31:22.109]             `<<-` <- base::`<<-`
[10:31:22.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.109]                   3L)]
[10:31:22.109]             }
[10:31:22.109]             function(cond) {
[10:31:22.109]                 is_error <- inherits(cond, "error")
[10:31:22.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.109]                   NULL)
[10:31:22.109]                 if (is_error) {
[10:31:22.109]                   sessionInformation <- function() {
[10:31:22.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.109]                       search = base::search(), system = base::Sys.info())
[10:31:22.109]                   }
[10:31:22.109]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.109]                     cond$call), session = sessionInformation(), 
[10:31:22.109]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.109]                   signalCondition(cond)
[10:31:22.109]                 }
[10:31:22.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.109]                 "immediateCondition"))) {
[10:31:22.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.109]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.109]                   if (TRUE && !signal) {
[10:31:22.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.109]                     {
[10:31:22.109]                       inherits <- base::inherits
[10:31:22.109]                       invokeRestart <- base::invokeRestart
[10:31:22.109]                       is.null <- base::is.null
[10:31:22.109]                       muffled <- FALSE
[10:31:22.109]                       if (inherits(cond, "message")) {
[10:31:22.109]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.109]                         if (muffled) 
[10:31:22.109]                           invokeRestart("muffleMessage")
[10:31:22.109]                       }
[10:31:22.109]                       else if (inherits(cond, "warning")) {
[10:31:22.109]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.109]                         if (muffled) 
[10:31:22.109]                           invokeRestart("muffleWarning")
[10:31:22.109]                       }
[10:31:22.109]                       else if (inherits(cond, "condition")) {
[10:31:22.109]                         if (!is.null(pattern)) {
[10:31:22.109]                           computeRestarts <- base::computeRestarts
[10:31:22.109]                           grepl <- base::grepl
[10:31:22.109]                           restarts <- computeRestarts(cond)
[10:31:22.109]                           for (restart in restarts) {
[10:31:22.109]                             name <- restart$name
[10:31:22.109]                             if (is.null(name)) 
[10:31:22.109]                               next
[10:31:22.109]                             if (!grepl(pattern, name)) 
[10:31:22.109]                               next
[10:31:22.109]                             invokeRestart(restart)
[10:31:22.109]                             muffled <- TRUE
[10:31:22.109]                             break
[10:31:22.109]                           }
[10:31:22.109]                         }
[10:31:22.109]                       }
[10:31:22.109]                       invisible(muffled)
[10:31:22.109]                     }
[10:31:22.109]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.109]                   }
[10:31:22.109]                 }
[10:31:22.109]                 else {
[10:31:22.109]                   if (TRUE) {
[10:31:22.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.109]                     {
[10:31:22.109]                       inherits <- base::inherits
[10:31:22.109]                       invokeRestart <- base::invokeRestart
[10:31:22.109]                       is.null <- base::is.null
[10:31:22.109]                       muffled <- FALSE
[10:31:22.109]                       if (inherits(cond, "message")) {
[10:31:22.109]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.109]                         if (muffled) 
[10:31:22.109]                           invokeRestart("muffleMessage")
[10:31:22.109]                       }
[10:31:22.109]                       else if (inherits(cond, "warning")) {
[10:31:22.109]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.109]                         if (muffled) 
[10:31:22.109]                           invokeRestart("muffleWarning")
[10:31:22.109]                       }
[10:31:22.109]                       else if (inherits(cond, "condition")) {
[10:31:22.109]                         if (!is.null(pattern)) {
[10:31:22.109]                           computeRestarts <- base::computeRestarts
[10:31:22.109]                           grepl <- base::grepl
[10:31:22.109]                           restarts <- computeRestarts(cond)
[10:31:22.109]                           for (restart in restarts) {
[10:31:22.109]                             name <- restart$name
[10:31:22.109]                             if (is.null(name)) 
[10:31:22.109]                               next
[10:31:22.109]                             if (!grepl(pattern, name)) 
[10:31:22.109]                               next
[10:31:22.109]                             invokeRestart(restart)
[10:31:22.109]                             muffled <- TRUE
[10:31:22.109]                             break
[10:31:22.109]                           }
[10:31:22.109]                         }
[10:31:22.109]                       }
[10:31:22.109]                       invisible(muffled)
[10:31:22.109]                     }
[10:31:22.109]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.109]                   }
[10:31:22.109]                 }
[10:31:22.109]             }
[10:31:22.109]         }))
[10:31:22.109]     }, error = function(ex) {
[10:31:22.109]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.109]                 ...future.rng), started = ...future.startTime, 
[10:31:22.109]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.109]             version = "1.8"), class = "FutureResult")
[10:31:22.109]     }, finally = {
[10:31:22.109]         if (!identical(...future.workdir, getwd())) 
[10:31:22.109]             setwd(...future.workdir)
[10:31:22.109]         {
[10:31:22.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.109]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.109]             }
[10:31:22.109]             base::options(...future.oldOptions)
[10:31:22.109]             if (.Platform$OS.type == "windows") {
[10:31:22.109]                 old_names <- names(...future.oldEnvVars)
[10:31:22.109]                 envs <- base::Sys.getenv()
[10:31:22.109]                 names <- names(envs)
[10:31:22.109]                 common <- intersect(names, old_names)
[10:31:22.109]                 added <- setdiff(names, old_names)
[10:31:22.109]                 removed <- setdiff(old_names, names)
[10:31:22.109]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.109]                   envs[common]]
[10:31:22.109]                 NAMES <- toupper(changed)
[10:31:22.109]                 args <- list()
[10:31:22.109]                 for (kk in seq_along(NAMES)) {
[10:31:22.109]                   name <- changed[[kk]]
[10:31:22.109]                   NAME <- NAMES[[kk]]
[10:31:22.109]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.109]                     next
[10:31:22.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.109]                 }
[10:31:22.109]                 NAMES <- toupper(added)
[10:31:22.109]                 for (kk in seq_along(NAMES)) {
[10:31:22.109]                   name <- added[[kk]]
[10:31:22.109]                   NAME <- NAMES[[kk]]
[10:31:22.109]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.109]                     next
[10:31:22.109]                   args[[name]] <- ""
[10:31:22.109]                 }
[10:31:22.109]                 NAMES <- toupper(removed)
[10:31:22.109]                 for (kk in seq_along(NAMES)) {
[10:31:22.109]                   name <- removed[[kk]]
[10:31:22.109]                   NAME <- NAMES[[kk]]
[10:31:22.109]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.109]                     next
[10:31:22.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.109]                 }
[10:31:22.109]                 if (length(args) > 0) 
[10:31:22.109]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.109]             }
[10:31:22.109]             else {
[10:31:22.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.109]             }
[10:31:22.109]             {
[10:31:22.109]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.109]                   0L) {
[10:31:22.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.109]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.109]                   base::options(opts)
[10:31:22.109]                 }
[10:31:22.109]                 {
[10:31:22.109]                   {
[10:31:22.109]                     NULL
[10:31:22.109]                     RNGkind("Mersenne-Twister")
[10:31:22.109]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:22.109]                       inherits = FALSE)
[10:31:22.109]                   }
[10:31:22.109]                   options(future.plan = NULL)
[10:31:22.109]                   if (is.na(NA_character_)) 
[10:31:22.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.109]                     .init = FALSE)
[10:31:22.109]                 }
[10:31:22.109]             }
[10:31:22.109]         }
[10:31:22.109]     })
[10:31:22.109]     if (TRUE) {
[10:31:22.109]         base::sink(type = "output", split = FALSE)
[10:31:22.109]         if (TRUE) {
[10:31:22.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.109]         }
[10:31:22.109]         else {
[10:31:22.109]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.109]         }
[10:31:22.109]         base::close(...future.stdout)
[10:31:22.109]         ...future.stdout <- NULL
[10:31:22.109]     }
[10:31:22.109]     ...future.result$conditions <- ...future.conditions
[10:31:22.109]     ...future.result$finished <- base::Sys.time()
[10:31:22.109]     ...future.result
[10:31:22.109] }
[10:31:22.111] assign_globals() ...
[10:31:22.111] List of 11
[10:31:22.111]  $ ...future.FUN            :function (x, ...)  
[10:31:22.111]  $ x_FUN                    :function (x, na.rm = TRUE)  
[10:31:22.111]  $ times                    : int 5
[10:31:22.111]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.111]  $ stop_if_not              :function (...)  
[10:31:22.111]  $ dim                      : NULL
[10:31:22.111]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:22.111]  $ future.call.arguments    : list()
[10:31:22.111]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.111]  $ ...future.elements_ii    :List of 7
[10:31:22.111]   ..$ : int [1:3] 1 2 3
[10:31:22.111]   ..$ : int [1:4] 1 2 3 4
[10:31:22.111]   ..$ : int [1:5] 1 2 3 4 5
[10:31:22.111]   ..$ : int [1:6] 1 2 3 4 5 6
[10:31:22.111]   ..$ : int [1:7] 1 2 3 4 5 6 7
[10:31:22.111]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[10:31:22.111]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[10:31:22.111]  $ ...future.seeds_ii       : NULL
[10:31:22.111]  $ ...future.globals.maxSize: NULL
[10:31:22.111]  - attr(*, "where")=List of 11
[10:31:22.111]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.111]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.111]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.111]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.111]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.111]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.111]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.111]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.111]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.111]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.111]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.111]  - attr(*, "resolved")= logi FALSE
[10:31:22.111]  - attr(*, "total_size")= num 141240
[10:31:22.111]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.111]  - attr(*, "already-done")= logi TRUE
[10:31:22.122] - copied ‘...future.FUN’ to environment
[10:31:22.122] - copied ‘x_FUN’ to environment
[10:31:22.122] - copied ‘times’ to environment
[10:31:22.122] - copied ‘stopf’ to environment
[10:31:22.122] - copied ‘stop_if_not’ to environment
[10:31:22.122] - copied ‘dim’ to environment
[10:31:22.122] - copied ‘valid_types’ to environment
[10:31:22.123] - copied ‘future.call.arguments’ to environment
[10:31:22.123] - copied ‘...future.elements_ii’ to environment
[10:31:22.123] - copied ‘...future.seeds_ii’ to environment
[10:31:22.123] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.123] assign_globals() ... done
[10:31:22.124] plan(): Setting new future strategy stack:
[10:31:22.124] List of future strategies:
[10:31:22.124] 1. sequential:
[10:31:22.124]    - args: function (..., envir = parent.frame())
[10:31:22.124]    - tweaked: FALSE
[10:31:22.124]    - call: NULL
[10:31:22.124] plan(): nbrOfWorkers() = 1
[10:31:22.125] plan(): Setting new future strategy stack:
[10:31:22.125] List of future strategies:
[10:31:22.125] 1. sequential:
[10:31:22.125]    - args: function (..., envir = parent.frame())
[10:31:22.125]    - tweaked: FALSE
[10:31:22.125]    - call: plan(strategy)
[10:31:22.125] plan(): nbrOfWorkers() = 1
[10:31:22.126] SequentialFuture started (and completed)
[10:31:22.126] - Launch lazy future ... done
[10:31:22.126] run() for ‘SequentialFuture’ ... done
[10:31:22.126] Created future:
[10:31:22.126] SequentialFuture:
[10:31:22.126] Label: ‘future_vapply-1’
[10:31:22.126] Expression:
[10:31:22.126] {
[10:31:22.126]     do.call(function(...) {
[10:31:22.126]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.126]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.126]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.126]             on.exit(options(oopts), add = TRUE)
[10:31:22.126]         }
[10:31:22.126]         {
[10:31:22.126]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.126]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.126]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.126]             })
[10:31:22.126]         }
[10:31:22.126]     }, args = future.call.arguments)
[10:31:22.126] }
[10:31:22.126] Lazy evaluation: FALSE
[10:31:22.126] Asynchronous evaluation: FALSE
[10:31:22.126] Local evaluation: TRUE
[10:31:22.126] Environment: R_GlobalEnv
[10:31:22.126] Capture standard output: TRUE
[10:31:22.126] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.126] Globals: 11 objects totaling 138.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.126] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:31:22.126] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.126] Resolved: TRUE
[10:31:22.126] Value: 672 bytes of class ‘list’
[10:31:22.126] Early signaling: FALSE
[10:31:22.126] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.126] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.127] Chunk #1 of 1 ... DONE
[10:31:22.127] Launching 1 futures (chunks) ... DONE
[10:31:22.127] Resolving 1 futures (chunks) ...
[10:31:22.128] resolve() on list ...
[10:31:22.128]  recursive: 0
[10:31:22.128]  length: 1
[10:31:22.128] 
[10:31:22.128] resolved() for ‘SequentialFuture’ ...
[10:31:22.128] - state: ‘finished’
[10:31:22.128] - run: TRUE
[10:31:22.128] - result: ‘FutureResult’
[10:31:22.128] resolved() for ‘SequentialFuture’ ... done
[10:31:22.128] Future #1
[10:31:22.129] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:22.129] - nx: 1
[10:31:22.129] - relay: TRUE
[10:31:22.129] - stdout: TRUE
[10:31:22.129] - signal: TRUE
[10:31:22.129] - resignal: FALSE
[10:31:22.129] - force: TRUE
[10:31:22.129] - relayed: [n=1] FALSE
[10:31:22.129] - queued futures: [n=1] FALSE
[10:31:22.129]  - until=1
[10:31:22.129]  - relaying element #1
[10:31:22.130] - relayed: [n=1] TRUE
[10:31:22.130] - queued futures: [n=1] TRUE
[10:31:22.130] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:22.130]  length: 0 (resolved future 1)
[10:31:22.130] Relaying remaining futures
[10:31:22.130] signalConditionsASAP(NULL, pos=0) ...
[10:31:22.130] - nx: 1
[10:31:22.130] - relay: TRUE
[10:31:22.130] - stdout: TRUE
[10:31:22.130] - signal: TRUE
[10:31:22.131] - resignal: FALSE
[10:31:22.131] - force: TRUE
[10:31:22.131] - relayed: [n=1] TRUE
[10:31:22.131] - queued futures: [n=1] TRUE
 - flush all
[10:31:22.131] - relayed: [n=1] TRUE
[10:31:22.131] - queued futures: [n=1] TRUE
[10:31:22.131] signalConditionsASAP(NULL, pos=0) ... done
[10:31:22.131] resolve() on list ... DONE
[10:31:22.131]  - Number of value chunks collected: 1
[10:31:22.131] Resolving 1 futures (chunks) ... DONE
[10:31:22.132] Reducing values from 1 chunks ...
[10:31:22.132]  - Number of values collected after concatenation: 7
[10:31:22.132]  - Number of values expected: 7
[10:31:22.132] Reducing values from 1 chunks ... DONE
[10:31:22.132] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[10:31:22.134] future_lapply() ...
[10:31:22.134] Number of chunks: 1
[10:31:22.134] getGlobalsAndPackagesXApply() ...
[10:31:22.135]  - future.globals: TRUE
[10:31:22.135] getGlobalsAndPackages() ...
[10:31:22.135] Searching for globals...
[10:31:22.136] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[10:31:22.136] Searching for globals ... DONE
[10:31:22.137] Resolving globals: FALSE
[10:31:22.137] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[10:31:22.137] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[10:31:22.138] - globals: [1] ‘FUN’
[10:31:22.138] 
[10:31:22.138] getGlobalsAndPackages() ... DONE
[10:31:22.138]  - globals found/used: [n=1] ‘FUN’
[10:31:22.138]  - needed namespaces: [n=0] 
[10:31:22.138] Finding globals ... DONE
[10:31:22.138]  - use_args: TRUE
[10:31:22.138]  - Getting '...' globals ...
[10:31:22.139] resolve() on list ...
[10:31:22.139]  recursive: 0
[10:31:22.139]  length: 1
[10:31:22.139]  elements: ‘...’
[10:31:22.139]  length: 0 (resolved future 1)
[10:31:22.139] resolve() on list ... DONE
[10:31:22.139]    - '...' content: [n=1] ‘y’
[10:31:22.140] List of 1
[10:31:22.140]  $ ...:List of 1
[10:31:22.140]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:22.140]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.140]  - attr(*, "where")=List of 1
[10:31:22.140]   ..$ ...:<environment: 0x55de8576cdd8> 
[10:31:22.140]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.140]  - attr(*, "resolved")= logi TRUE
[10:31:22.140]  - attr(*, "total_size")= num NA
[10:31:22.143]  - Getting '...' globals ... DONE
[10:31:22.143] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:22.143] List of 2
[10:31:22.143]  $ ...future.FUN:function (x, y)  
[10:31:22.143]  $ ...          :List of 1
[10:31:22.143]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:22.143]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.143]  - attr(*, "where")=List of 2
[10:31:22.143]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:22.143]   ..$ ...          :<environment: 0x55de8576cdd8> 
[10:31:22.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.143]  - attr(*, "resolved")= logi FALSE
[10:31:22.143]  - attr(*, "total_size")= num 4264
[10:31:22.149] Packages to be attached in all futures: [n=0] 
[10:31:22.149] getGlobalsAndPackagesXApply() ... DONE
[10:31:22.149] Number of futures (= number of chunks): 1
[10:31:22.149] Launching 1 futures (chunks) ...
[10:31:22.149] Chunk #1 of 1 ...
[10:31:22.149]  - Finding globals in 'X' for chunk #1 ...
[10:31:22.149] getGlobalsAndPackages() ...
[10:31:22.150] Searching for globals...
[10:31:22.150] 
[10:31:22.150] Searching for globals ... DONE
[10:31:22.150] - globals: [0] <none>
[10:31:22.150] getGlobalsAndPackages() ... DONE
[10:31:22.150]    + additional globals found: [n=0] 
[10:31:22.150]    + additional namespaces needed: [n=0] 
[10:31:22.150]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:22.150]  - seeds: <none>
[10:31:22.151]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.151] getGlobalsAndPackages() ...
[10:31:22.151] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.151] Resolving globals: FALSE
[10:31:22.151] Tweak future expression to call with '...' arguments ...
[10:31:22.151] {
[10:31:22.151]     do.call(function(...) {
[10:31:22.151]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.151]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.151]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.151]             on.exit(options(oopts), add = TRUE)
[10:31:22.151]         }
[10:31:22.151]         {
[10:31:22.151]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.151]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.151]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.151]             })
[10:31:22.151]         }
[10:31:22.151]     }, args = future.call.arguments)
[10:31:22.151] }
[10:31:22.151] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.152] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.152] 
[10:31:22.152] getGlobalsAndPackages() ... DONE
[10:31:22.152] run() for ‘Future’ ...
[10:31:22.152] - state: ‘created’
[10:31:22.153] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:22.153] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.153] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:22.153]   - Field: ‘label’
[10:31:22.153]   - Field: ‘local’
[10:31:22.153]   - Field: ‘owner’
[10:31:22.153]   - Field: ‘envir’
[10:31:22.153]   - Field: ‘packages’
[10:31:22.154]   - Field: ‘gc’
[10:31:22.154]   - Field: ‘conditions’
[10:31:22.154]   - Field: ‘expr’
[10:31:22.154]   - Field: ‘uuid’
[10:31:22.154]   - Field: ‘seed’
[10:31:22.154]   - Field: ‘version’
[10:31:22.154]   - Field: ‘result’
[10:31:22.154]   - Field: ‘asynchronous’
[10:31:22.154]   - Field: ‘calls’
[10:31:22.154]   - Field: ‘globals’
[10:31:22.154]   - Field: ‘stdout’
[10:31:22.155]   - Field: ‘earlySignal’
[10:31:22.155]   - Field: ‘lazy’
[10:31:22.155]   - Field: ‘state’
[10:31:22.155] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:22.155] - Launch lazy future ...
[10:31:22.155] Packages needed by the future expression (n = 0): <none>
[10:31:22.155] Packages needed by future strategies (n = 0): <none>
[10:31:22.156] {
[10:31:22.156]     {
[10:31:22.156]         {
[10:31:22.156]             ...future.startTime <- base::Sys.time()
[10:31:22.156]             {
[10:31:22.156]                 {
[10:31:22.156]                   {
[10:31:22.156]                     base::local({
[10:31:22.156]                       has_future <- base::requireNamespace("future", 
[10:31:22.156]                         quietly = TRUE)
[10:31:22.156]                       if (has_future) {
[10:31:22.156]                         ns <- base::getNamespace("future")
[10:31:22.156]                         version <- ns[[".package"]][["version"]]
[10:31:22.156]                         if (is.null(version)) 
[10:31:22.156]                           version <- utils::packageVersion("future")
[10:31:22.156]                       }
[10:31:22.156]                       else {
[10:31:22.156]                         version <- NULL
[10:31:22.156]                       }
[10:31:22.156]                       if (!has_future || version < "1.8.0") {
[10:31:22.156]                         info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.156]                           "", base::R.version$version.string), 
[10:31:22.156]                           platform = base::sprintf("%s (%s-bit)", 
[10:31:22.156]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:22.156]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.156]                             "release", "version")], collapse = " "), 
[10:31:22.156]                           hostname = base::Sys.info()[["nodename"]])
[10:31:22.156]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.156]                           info)
[10:31:22.156]                         info <- base::paste(info, collapse = "; ")
[10:31:22.156]                         if (!has_future) {
[10:31:22.156]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.156]                             info)
[10:31:22.156]                         }
[10:31:22.156]                         else {
[10:31:22.156]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.156]                             info, version)
[10:31:22.156]                         }
[10:31:22.156]                         base::stop(msg)
[10:31:22.156]                       }
[10:31:22.156]                     })
[10:31:22.156]                   }
[10:31:22.156]                   ...future.strategy.old <- future::plan("list")
[10:31:22.156]                   options(future.plan = NULL)
[10:31:22.156]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.156]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.156]                 }
[10:31:22.156]                 ...future.workdir <- getwd()
[10:31:22.156]             }
[10:31:22.156]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.156]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.156]         }
[10:31:22.156]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.156]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:22.156]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.156]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.156]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.156]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.156]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.156]             base::names(...future.oldOptions))
[10:31:22.156]     }
[10:31:22.156]     if (FALSE) {
[10:31:22.156]     }
[10:31:22.156]     else {
[10:31:22.156]         if (TRUE) {
[10:31:22.156]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.156]                 open = "w")
[10:31:22.156]         }
[10:31:22.156]         else {
[10:31:22.156]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.156]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.156]         }
[10:31:22.156]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.156]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.156]             base::sink(type = "output", split = FALSE)
[10:31:22.156]             base::close(...future.stdout)
[10:31:22.156]         }, add = TRUE)
[10:31:22.156]     }
[10:31:22.156]     ...future.frame <- base::sys.nframe()
[10:31:22.156]     ...future.conditions <- base::list()
[10:31:22.156]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.156]     if (FALSE) {
[10:31:22.156]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.156]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.156]     }
[10:31:22.156]     ...future.result <- base::tryCatch({
[10:31:22.156]         base::withCallingHandlers({
[10:31:22.156]             ...future.value <- base::withVisible(base::local({
[10:31:22.156]                 do.call(function(...) {
[10:31:22.156]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.156]                   if (!identical(...future.globals.maxSize.org, 
[10:31:22.156]                     ...future.globals.maxSize)) {
[10:31:22.156]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.156]                     on.exit(options(oopts), add = TRUE)
[10:31:22.156]                   }
[10:31:22.156]                   {
[10:31:22.156]                     lapply(seq_along(...future.elements_ii), 
[10:31:22.156]                       FUN = function(jj) {
[10:31:22.156]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.156]                         ...future.FUN(...future.X_jj, ...)
[10:31:22.156]                       })
[10:31:22.156]                   }
[10:31:22.156]                 }, args = future.call.arguments)
[10:31:22.156]             }))
[10:31:22.156]             future::FutureResult(value = ...future.value$value, 
[10:31:22.156]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.156]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.156]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.156]                     ...future.globalenv.names))
[10:31:22.156]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.156]         }, condition = base::local({
[10:31:22.156]             c <- base::c
[10:31:22.156]             inherits <- base::inherits
[10:31:22.156]             invokeRestart <- base::invokeRestart
[10:31:22.156]             length <- base::length
[10:31:22.156]             list <- base::list
[10:31:22.156]             seq.int <- base::seq.int
[10:31:22.156]             signalCondition <- base::signalCondition
[10:31:22.156]             sys.calls <- base::sys.calls
[10:31:22.156]             `[[` <- base::`[[`
[10:31:22.156]             `+` <- base::`+`
[10:31:22.156]             `<<-` <- base::`<<-`
[10:31:22.156]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.156]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.156]                   3L)]
[10:31:22.156]             }
[10:31:22.156]             function(cond) {
[10:31:22.156]                 is_error <- inherits(cond, "error")
[10:31:22.156]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.156]                   NULL)
[10:31:22.156]                 if (is_error) {
[10:31:22.156]                   sessionInformation <- function() {
[10:31:22.156]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.156]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.156]                       search = base::search(), system = base::Sys.info())
[10:31:22.156]                   }
[10:31:22.156]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.156]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.156]                     cond$call), session = sessionInformation(), 
[10:31:22.156]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.156]                   signalCondition(cond)
[10:31:22.156]                 }
[10:31:22.156]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.156]                 "immediateCondition"))) {
[10:31:22.156]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.156]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.156]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.156]                   if (TRUE && !signal) {
[10:31:22.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.156]                     {
[10:31:22.156]                       inherits <- base::inherits
[10:31:22.156]                       invokeRestart <- base::invokeRestart
[10:31:22.156]                       is.null <- base::is.null
[10:31:22.156]                       muffled <- FALSE
[10:31:22.156]                       if (inherits(cond, "message")) {
[10:31:22.156]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.156]                         if (muffled) 
[10:31:22.156]                           invokeRestart("muffleMessage")
[10:31:22.156]                       }
[10:31:22.156]                       else if (inherits(cond, "warning")) {
[10:31:22.156]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.156]                         if (muffled) 
[10:31:22.156]                           invokeRestart("muffleWarning")
[10:31:22.156]                       }
[10:31:22.156]                       else if (inherits(cond, "condition")) {
[10:31:22.156]                         if (!is.null(pattern)) {
[10:31:22.156]                           computeRestarts <- base::computeRestarts
[10:31:22.156]                           grepl <- base::grepl
[10:31:22.156]                           restarts <- computeRestarts(cond)
[10:31:22.156]                           for (restart in restarts) {
[10:31:22.156]                             name <- restart$name
[10:31:22.156]                             if (is.null(name)) 
[10:31:22.156]                               next
[10:31:22.156]                             if (!grepl(pattern, name)) 
[10:31:22.156]                               next
[10:31:22.156]                             invokeRestart(restart)
[10:31:22.156]                             muffled <- TRUE
[10:31:22.156]                             break
[10:31:22.156]                           }
[10:31:22.156]                         }
[10:31:22.156]                       }
[10:31:22.156]                       invisible(muffled)
[10:31:22.156]                     }
[10:31:22.156]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.156]                   }
[10:31:22.156]                 }
[10:31:22.156]                 else {
[10:31:22.156]                   if (TRUE) {
[10:31:22.156]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.156]                     {
[10:31:22.156]                       inherits <- base::inherits
[10:31:22.156]                       invokeRestart <- base::invokeRestart
[10:31:22.156]                       is.null <- base::is.null
[10:31:22.156]                       muffled <- FALSE
[10:31:22.156]                       if (inherits(cond, "message")) {
[10:31:22.156]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.156]                         if (muffled) 
[10:31:22.156]                           invokeRestart("muffleMessage")
[10:31:22.156]                       }
[10:31:22.156]                       else if (inherits(cond, "warning")) {
[10:31:22.156]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.156]                         if (muffled) 
[10:31:22.156]                           invokeRestart("muffleWarning")
[10:31:22.156]                       }
[10:31:22.156]                       else if (inherits(cond, "condition")) {
[10:31:22.156]                         if (!is.null(pattern)) {
[10:31:22.156]                           computeRestarts <- base::computeRestarts
[10:31:22.156]                           grepl <- base::grepl
[10:31:22.156]                           restarts <- computeRestarts(cond)
[10:31:22.156]                           for (restart in restarts) {
[10:31:22.156]                             name <- restart$name
[10:31:22.156]                             if (is.null(name)) 
[10:31:22.156]                               next
[10:31:22.156]                             if (!grepl(pattern, name)) 
[10:31:22.156]                               next
[10:31:22.156]                             invokeRestart(restart)
[10:31:22.156]                             muffled <- TRUE
[10:31:22.156]                             break
[10:31:22.156]                           }
[10:31:22.156]                         }
[10:31:22.156]                       }
[10:31:22.156]                       invisible(muffled)
[10:31:22.156]                     }
[10:31:22.156]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.156]                   }
[10:31:22.156]                 }
[10:31:22.156]             }
[10:31:22.156]         }))
[10:31:22.156]     }, error = function(ex) {
[10:31:22.156]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.156]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.156]                 ...future.rng), started = ...future.startTime, 
[10:31:22.156]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.156]             version = "1.8"), class = "FutureResult")
[10:31:22.156]     }, finally = {
[10:31:22.156]         if (!identical(...future.workdir, getwd())) 
[10:31:22.156]             setwd(...future.workdir)
[10:31:22.156]         {
[10:31:22.156]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.156]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.156]             }
[10:31:22.156]             base::options(...future.oldOptions)
[10:31:22.156]             if (.Platform$OS.type == "windows") {
[10:31:22.156]                 old_names <- names(...future.oldEnvVars)
[10:31:22.156]                 envs <- base::Sys.getenv()
[10:31:22.156]                 names <- names(envs)
[10:31:22.156]                 common <- intersect(names, old_names)
[10:31:22.156]                 added <- setdiff(names, old_names)
[10:31:22.156]                 removed <- setdiff(old_names, names)
[10:31:22.156]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.156]                   envs[common]]
[10:31:22.156]                 NAMES <- toupper(changed)
[10:31:22.156]                 args <- list()
[10:31:22.156]                 for (kk in seq_along(NAMES)) {
[10:31:22.156]                   name <- changed[[kk]]
[10:31:22.156]                   NAME <- NAMES[[kk]]
[10:31:22.156]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.156]                     next
[10:31:22.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.156]                 }
[10:31:22.156]                 NAMES <- toupper(added)
[10:31:22.156]                 for (kk in seq_along(NAMES)) {
[10:31:22.156]                   name <- added[[kk]]
[10:31:22.156]                   NAME <- NAMES[[kk]]
[10:31:22.156]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.156]                     next
[10:31:22.156]                   args[[name]] <- ""
[10:31:22.156]                 }
[10:31:22.156]                 NAMES <- toupper(removed)
[10:31:22.156]                 for (kk in seq_along(NAMES)) {
[10:31:22.156]                   name <- removed[[kk]]
[10:31:22.156]                   NAME <- NAMES[[kk]]
[10:31:22.156]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.156]                     next
[10:31:22.156]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.156]                 }
[10:31:22.156]                 if (length(args) > 0) 
[10:31:22.156]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.156]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.156]             }
[10:31:22.156]             else {
[10:31:22.156]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.156]             }
[10:31:22.156]             {
[10:31:22.156]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.156]                   0L) {
[10:31:22.156]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.156]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.156]                   base::options(opts)
[10:31:22.156]                 }
[10:31:22.156]                 {
[10:31:22.156]                   {
[10:31:22.156]                     NULL
[10:31:22.156]                     RNGkind("Mersenne-Twister")
[10:31:22.156]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:22.156]                       inherits = FALSE)
[10:31:22.156]                   }
[10:31:22.156]                   options(future.plan = NULL)
[10:31:22.156]                   if (is.na(NA_character_)) 
[10:31:22.156]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.156]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.156]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.156]                     .init = FALSE)
[10:31:22.156]                 }
[10:31:22.156]             }
[10:31:22.156]         }
[10:31:22.156]     })
[10:31:22.156]     if (TRUE) {
[10:31:22.156]         base::sink(type = "output", split = FALSE)
[10:31:22.156]         if (TRUE) {
[10:31:22.156]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.156]         }
[10:31:22.156]         else {
[10:31:22.156]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.156]         }
[10:31:22.156]         base::close(...future.stdout)
[10:31:22.156]         ...future.stdout <- NULL
[10:31:22.156]     }
[10:31:22.156]     ...future.result$conditions <- ...future.conditions
[10:31:22.156]     ...future.result$finished <- base::Sys.time()
[10:31:22.156]     ...future.result
[10:31:22.156] }
[10:31:22.157] assign_globals() ...
[10:31:22.158] List of 5
[10:31:22.158]  $ ...future.FUN            :function (x, y)  
[10:31:22.158]  $ future.call.arguments    :List of 1
[10:31:22.158]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:22.158]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.158]  $ ...future.elements_ii    :List of 4
[10:31:22.158]   ..$ A: num 50
[10:31:22.158]   ..$ B: num 60
[10:31:22.158]   ..$ C: num 70
[10:31:22.158]   ..$ D: num 80
[10:31:22.158]  $ ...future.seeds_ii       : NULL
[10:31:22.158]  $ ...future.globals.maxSize: NULL
[10:31:22.158]  - attr(*, "where")=List of 5
[10:31:22.158]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.158]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.158]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.158]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.158]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.158]  - attr(*, "resolved")= logi FALSE
[10:31:22.158]  - attr(*, "total_size")= num 4264
[10:31:22.158]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.158]  - attr(*, "already-done")= logi TRUE
[10:31:22.164] - reassign environment for ‘...future.FUN’
[10:31:22.164] - copied ‘...future.FUN’ to environment
[10:31:22.164] - copied ‘future.call.arguments’ to environment
[10:31:22.164] - copied ‘...future.elements_ii’ to environment
[10:31:22.164] - copied ‘...future.seeds_ii’ to environment
[10:31:22.164] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.164] assign_globals() ... done
[10:31:22.164] plan(): Setting new future strategy stack:
[10:31:22.164] List of future strategies:
[10:31:22.164] 1. sequential:
[10:31:22.164]    - args: function (..., envir = parent.frame())
[10:31:22.164]    - tweaked: FALSE
[10:31:22.164]    - call: NULL
[10:31:22.165] plan(): nbrOfWorkers() = 1
[10:31:22.166] plan(): Setting new future strategy stack:
[10:31:22.166] List of future strategies:
[10:31:22.166] 1. sequential:
[10:31:22.166]    - args: function (..., envir = parent.frame())
[10:31:22.166]    - tweaked: FALSE
[10:31:22.166]    - call: plan(strategy)
[10:31:22.166] plan(): nbrOfWorkers() = 1
[10:31:22.166] SequentialFuture started (and completed)
[10:31:22.166] - Launch lazy future ... done
[10:31:22.167] run() for ‘SequentialFuture’ ... done
[10:31:22.167] Created future:
[10:31:22.167] SequentialFuture:
[10:31:22.167] Label: ‘future_sapply-1’
[10:31:22.167] Expression:
[10:31:22.167] {
[10:31:22.167]     do.call(function(...) {
[10:31:22.167]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.167]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.167]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.167]             on.exit(options(oopts), add = TRUE)
[10:31:22.167]         }
[10:31:22.167]         {
[10:31:22.167]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.167]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.167]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.167]             })
[10:31:22.167]         }
[10:31:22.167]     }, args = future.call.arguments)
[10:31:22.167] }
[10:31:22.167] Lazy evaluation: FALSE
[10:31:22.167] Asynchronous evaluation: FALSE
[10:31:22.167] Local evaluation: TRUE
[10:31:22.167] Environment: R_GlobalEnv
[10:31:22.167] Capture standard output: TRUE
[10:31:22.167] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.167] Globals: 5 objects totaling 4.38 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 224 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:22.167] Packages: <none>
[10:31:22.167] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.167] Resolved: TRUE
[10:31:22.167] Value: 1.34 KiB of class ‘list’
[10:31:22.167] Early signaling: FALSE
[10:31:22.167] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.167] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.168] Chunk #1 of 1 ... DONE
[10:31:22.168] Launching 1 futures (chunks) ... DONE
[10:31:22.168] Resolving 1 futures (chunks) ...
[10:31:22.168] resolve() on list ...
[10:31:22.168]  recursive: 0
[10:31:22.168]  length: 1
[10:31:22.168] 
[10:31:22.168] resolved() for ‘SequentialFuture’ ...
[10:31:22.169] - state: ‘finished’
[10:31:22.169] - run: TRUE
[10:31:22.169] - result: ‘FutureResult’
[10:31:22.169] resolved() for ‘SequentialFuture’ ... done
[10:31:22.169] Future #1
[10:31:22.169] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:22.169] - nx: 1
[10:31:22.169] - relay: TRUE
[10:31:22.169] - stdout: TRUE
[10:31:22.169] - signal: TRUE
[10:31:22.170] - resignal: FALSE
[10:31:22.170] - force: TRUE
[10:31:22.170] - relayed: [n=1] FALSE
[10:31:22.170] - queued futures: [n=1] FALSE
[10:31:22.171]  - until=1
[10:31:22.172]  - relaying element #1
[10:31:22.172] - relayed: [n=1] TRUE
[10:31:22.172] - queued futures: [n=1] TRUE
[10:31:22.172] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:22.172]  length: 0 (resolved future 1)
[10:31:22.172] Relaying remaining futures
[10:31:22.172] signalConditionsASAP(NULL, pos=0) ...
[10:31:22.172] - nx: 1
[10:31:22.173] - relay: TRUE
[10:31:22.173] - stdout: TRUE
[10:31:22.173] - signal: TRUE
[10:31:22.173] - resignal: FALSE
[10:31:22.173] - force: TRUE
[10:31:22.173] - relayed: [n=1] TRUE
[10:31:22.173] - queued futures: [n=1] TRUE
 - flush all
[10:31:22.173] - relayed: [n=1] TRUE
[10:31:22.173] - queued futures: [n=1] TRUE
[10:31:22.174] signalConditionsASAP(NULL, pos=0) ... done
[10:31:22.174] resolve() on list ... DONE
[10:31:22.174]  - Number of value chunks collected: 1
[10:31:22.174] Resolving 1 futures (chunks) ... DONE
[10:31:22.174] Reducing values from 1 chunks ...
[10:31:22.174]  - Number of values collected after concatenation: 4
[10:31:22.174]  - Number of values expected: 4
[10:31:22.174] Reducing values from 1 chunks ... DONE
[10:31:22.174] future_lapply() ... DONE
[10:31:22.175] future_lapply() ...
[10:31:22.177] Number of chunks: 1
[10:31:22.177] getGlobalsAndPackagesXApply() ...
[10:31:22.177]  - future.globals: TRUE
[10:31:22.177] getGlobalsAndPackages() ...
[10:31:22.177] Searching for globals...
[10:31:22.181] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[10:31:22.181] Searching for globals ... DONE
[10:31:22.181] Resolving globals: FALSE
[10:31:22.182] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[10:31:22.182] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:22.182] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.182] - packages: [1] ‘future.apply’
[10:31:22.183] getGlobalsAndPackages() ... DONE
[10:31:22.183]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.183]  - needed namespaces: [n=1] ‘future.apply’
[10:31:22.183] Finding globals ... DONE
[10:31:22.183]  - use_args: TRUE
[10:31:22.183]  - Getting '...' globals ...
[10:31:22.183] resolve() on list ...
[10:31:22.183]  recursive: 0
[10:31:22.184]  length: 1
[10:31:22.184]  elements: ‘...’
[10:31:22.184]  length: 0 (resolved future 1)
[10:31:22.184] resolve() on list ... DONE
[10:31:22.184]    - '...' content: [n=1] ‘y’
[10:31:22.184] List of 1
[10:31:22.184]  $ ...:List of 1
[10:31:22.184]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:22.184]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.184]  - attr(*, "where")=List of 1
[10:31:22.184]   ..$ ...:<environment: 0x55de8462b5a0> 
[10:31:22.184]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.184]  - attr(*, "resolved")= logi TRUE
[10:31:22.184]  - attr(*, "total_size")= num NA
[10:31:22.187]  - Getting '...' globals ... DONE
[10:31:22.187] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:22.188] List of 8
[10:31:22.188]  $ ...future.FUN:function (x, ...)  
[10:31:22.188]  $ x_FUN        :function (x, y)  
[10:31:22.188]  $ times        : int 15
[10:31:22.188]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.188]  $ stop_if_not  :function (...)  
[10:31:22.188]  $ dim          : int [1:2] 3 5
[10:31:22.188]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:22.188]  $ ...          :List of 1
[10:31:22.188]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:22.188]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.188]  - attr(*, "where")=List of 8
[10:31:22.188]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:22.188]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:22.188]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:22.188]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:22.188]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:22.188]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:22.188]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:22.188]   ..$ ...          :<environment: 0x55de8462b5a0> 
[10:31:22.188]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.188]  - attr(*, "resolved")= logi FALSE
[10:31:22.188]  - attr(*, "total_size")= num 98600
[10:31:22.196] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:22.196] getGlobalsAndPackagesXApply() ... DONE
[10:31:22.197] Number of futures (= number of chunks): 1
[10:31:22.197] Launching 1 futures (chunks) ...
[10:31:22.197] Chunk #1 of 1 ...
[10:31:22.197]  - Finding globals in 'X' for chunk #1 ...
[10:31:22.197] getGlobalsAndPackages() ...
[10:31:22.197] Searching for globals...
[10:31:22.197] 
[10:31:22.198] Searching for globals ... DONE
[10:31:22.198] - globals: [0] <none>
[10:31:22.198] getGlobalsAndPackages() ... DONE
[10:31:22.198]    + additional globals found: [n=0] 
[10:31:22.198]    + additional namespaces needed: [n=0] 
[10:31:22.198]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:22.198]  - seeds: <none>
[10:31:22.198]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.198] getGlobalsAndPackages() ...
[10:31:22.198] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.199] Resolving globals: FALSE
[10:31:22.199] Tweak future expression to call with '...' arguments ...
[10:31:22.199] {
[10:31:22.199]     do.call(function(...) {
[10:31:22.199]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.199]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.199]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.199]             on.exit(options(oopts), add = TRUE)
[10:31:22.199]         }
[10:31:22.199]         {
[10:31:22.199]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.199]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.199]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.199]             })
[10:31:22.199]         }
[10:31:22.199]     }, args = future.call.arguments)
[10:31:22.199] }
[10:31:22.199] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.200] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.200] - packages: [1] ‘future.apply’
[10:31:22.200] getGlobalsAndPackages() ... DONE
[10:31:22.200] run() for ‘Future’ ...
[10:31:22.200] - state: ‘created’
[10:31:22.200] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:22.201] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.201] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:22.201]   - Field: ‘label’
[10:31:22.201]   - Field: ‘local’
[10:31:22.201]   - Field: ‘owner’
[10:31:22.201]   - Field: ‘envir’
[10:31:22.201]   - Field: ‘packages’
[10:31:22.202]   - Field: ‘gc’
[10:31:22.202]   - Field: ‘conditions’
[10:31:22.202]   - Field: ‘expr’
[10:31:22.202]   - Field: ‘uuid’
[10:31:22.202]   - Field: ‘seed’
[10:31:22.202]   - Field: ‘version’
[10:31:22.202]   - Field: ‘result’
[10:31:22.202]   - Field: ‘asynchronous’
[10:31:22.202]   - Field: ‘calls’
[10:31:22.202]   - Field: ‘globals’
[10:31:22.202]   - Field: ‘stdout’
[10:31:22.203]   - Field: ‘earlySignal’
[10:31:22.203]   - Field: ‘lazy’
[10:31:22.203]   - Field: ‘state’
[10:31:22.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:22.203] - Launch lazy future ...
[10:31:22.203] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.203] Packages needed by future strategies (n = 0): <none>
[10:31:22.204] {
[10:31:22.204]     {
[10:31:22.204]         {
[10:31:22.204]             ...future.startTime <- base::Sys.time()
[10:31:22.204]             {
[10:31:22.204]                 {
[10:31:22.204]                   {
[10:31:22.204]                     {
[10:31:22.204]                       base::local({
[10:31:22.204]                         has_future <- base::requireNamespace("future", 
[10:31:22.204]                           quietly = TRUE)
[10:31:22.204]                         if (has_future) {
[10:31:22.204]                           ns <- base::getNamespace("future")
[10:31:22.204]                           version <- ns[[".package"]][["version"]]
[10:31:22.204]                           if (is.null(version)) 
[10:31:22.204]                             version <- utils::packageVersion("future")
[10:31:22.204]                         }
[10:31:22.204]                         else {
[10:31:22.204]                           version <- NULL
[10:31:22.204]                         }
[10:31:22.204]                         if (!has_future || version < "1.8.0") {
[10:31:22.204]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.204]                             "", base::R.version$version.string), 
[10:31:22.204]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:22.204]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:22.204]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.204]                               "release", "version")], collapse = " "), 
[10:31:22.204]                             hostname = base::Sys.info()[["nodename"]])
[10:31:22.204]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.204]                             info)
[10:31:22.204]                           info <- base::paste(info, collapse = "; ")
[10:31:22.204]                           if (!has_future) {
[10:31:22.204]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.204]                               info)
[10:31:22.204]                           }
[10:31:22.204]                           else {
[10:31:22.204]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.204]                               info, version)
[10:31:22.204]                           }
[10:31:22.204]                           base::stop(msg)
[10:31:22.204]                         }
[10:31:22.204]                       })
[10:31:22.204]                     }
[10:31:22.204]                     base::local({
[10:31:22.204]                       for (pkg in "future.apply") {
[10:31:22.204]                         base::loadNamespace(pkg)
[10:31:22.204]                         base::library(pkg, character.only = TRUE)
[10:31:22.204]                       }
[10:31:22.204]                     })
[10:31:22.204]                   }
[10:31:22.204]                   ...future.strategy.old <- future::plan("list")
[10:31:22.204]                   options(future.plan = NULL)
[10:31:22.204]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.204]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.204]                 }
[10:31:22.204]                 ...future.workdir <- getwd()
[10:31:22.204]             }
[10:31:22.204]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.204]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.204]         }
[10:31:22.204]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.204]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:22.204]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.204]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.204]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.204]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.204]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.204]             base::names(...future.oldOptions))
[10:31:22.204]     }
[10:31:22.204]     if (FALSE) {
[10:31:22.204]     }
[10:31:22.204]     else {
[10:31:22.204]         if (TRUE) {
[10:31:22.204]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.204]                 open = "w")
[10:31:22.204]         }
[10:31:22.204]         else {
[10:31:22.204]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.204]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.204]         }
[10:31:22.204]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.204]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.204]             base::sink(type = "output", split = FALSE)
[10:31:22.204]             base::close(...future.stdout)
[10:31:22.204]         }, add = TRUE)
[10:31:22.204]     }
[10:31:22.204]     ...future.frame <- base::sys.nframe()
[10:31:22.204]     ...future.conditions <- base::list()
[10:31:22.204]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.204]     if (FALSE) {
[10:31:22.204]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.204]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.204]     }
[10:31:22.204]     ...future.result <- base::tryCatch({
[10:31:22.204]         base::withCallingHandlers({
[10:31:22.204]             ...future.value <- base::withVisible(base::local({
[10:31:22.204]                 do.call(function(...) {
[10:31:22.204]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.204]                   if (!identical(...future.globals.maxSize.org, 
[10:31:22.204]                     ...future.globals.maxSize)) {
[10:31:22.204]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.204]                     on.exit(options(oopts), add = TRUE)
[10:31:22.204]                   }
[10:31:22.204]                   {
[10:31:22.204]                     lapply(seq_along(...future.elements_ii), 
[10:31:22.204]                       FUN = function(jj) {
[10:31:22.204]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.204]                         ...future.FUN(...future.X_jj, ...)
[10:31:22.204]                       })
[10:31:22.204]                   }
[10:31:22.204]                 }, args = future.call.arguments)
[10:31:22.204]             }))
[10:31:22.204]             future::FutureResult(value = ...future.value$value, 
[10:31:22.204]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.204]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.204]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.204]                     ...future.globalenv.names))
[10:31:22.204]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.204]         }, condition = base::local({
[10:31:22.204]             c <- base::c
[10:31:22.204]             inherits <- base::inherits
[10:31:22.204]             invokeRestart <- base::invokeRestart
[10:31:22.204]             length <- base::length
[10:31:22.204]             list <- base::list
[10:31:22.204]             seq.int <- base::seq.int
[10:31:22.204]             signalCondition <- base::signalCondition
[10:31:22.204]             sys.calls <- base::sys.calls
[10:31:22.204]             `[[` <- base::`[[`
[10:31:22.204]             `+` <- base::`+`
[10:31:22.204]             `<<-` <- base::`<<-`
[10:31:22.204]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.204]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.204]                   3L)]
[10:31:22.204]             }
[10:31:22.204]             function(cond) {
[10:31:22.204]                 is_error <- inherits(cond, "error")
[10:31:22.204]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.204]                   NULL)
[10:31:22.204]                 if (is_error) {
[10:31:22.204]                   sessionInformation <- function() {
[10:31:22.204]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.204]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.204]                       search = base::search(), system = base::Sys.info())
[10:31:22.204]                   }
[10:31:22.204]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.204]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.204]                     cond$call), session = sessionInformation(), 
[10:31:22.204]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.204]                   signalCondition(cond)
[10:31:22.204]                 }
[10:31:22.204]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.204]                 "immediateCondition"))) {
[10:31:22.204]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.204]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.204]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.204]                   if (TRUE && !signal) {
[10:31:22.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.204]                     {
[10:31:22.204]                       inherits <- base::inherits
[10:31:22.204]                       invokeRestart <- base::invokeRestart
[10:31:22.204]                       is.null <- base::is.null
[10:31:22.204]                       muffled <- FALSE
[10:31:22.204]                       if (inherits(cond, "message")) {
[10:31:22.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.204]                         if (muffled) 
[10:31:22.204]                           invokeRestart("muffleMessage")
[10:31:22.204]                       }
[10:31:22.204]                       else if (inherits(cond, "warning")) {
[10:31:22.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.204]                         if (muffled) 
[10:31:22.204]                           invokeRestart("muffleWarning")
[10:31:22.204]                       }
[10:31:22.204]                       else if (inherits(cond, "condition")) {
[10:31:22.204]                         if (!is.null(pattern)) {
[10:31:22.204]                           computeRestarts <- base::computeRestarts
[10:31:22.204]                           grepl <- base::grepl
[10:31:22.204]                           restarts <- computeRestarts(cond)
[10:31:22.204]                           for (restart in restarts) {
[10:31:22.204]                             name <- restart$name
[10:31:22.204]                             if (is.null(name)) 
[10:31:22.204]                               next
[10:31:22.204]                             if (!grepl(pattern, name)) 
[10:31:22.204]                               next
[10:31:22.204]                             invokeRestart(restart)
[10:31:22.204]                             muffled <- TRUE
[10:31:22.204]                             break
[10:31:22.204]                           }
[10:31:22.204]                         }
[10:31:22.204]                       }
[10:31:22.204]                       invisible(muffled)
[10:31:22.204]                     }
[10:31:22.204]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.204]                   }
[10:31:22.204]                 }
[10:31:22.204]                 else {
[10:31:22.204]                   if (TRUE) {
[10:31:22.204]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.204]                     {
[10:31:22.204]                       inherits <- base::inherits
[10:31:22.204]                       invokeRestart <- base::invokeRestart
[10:31:22.204]                       is.null <- base::is.null
[10:31:22.204]                       muffled <- FALSE
[10:31:22.204]                       if (inherits(cond, "message")) {
[10:31:22.204]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.204]                         if (muffled) 
[10:31:22.204]                           invokeRestart("muffleMessage")
[10:31:22.204]                       }
[10:31:22.204]                       else if (inherits(cond, "warning")) {
[10:31:22.204]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.204]                         if (muffled) 
[10:31:22.204]                           invokeRestart("muffleWarning")
[10:31:22.204]                       }
[10:31:22.204]                       else if (inherits(cond, "condition")) {
[10:31:22.204]                         if (!is.null(pattern)) {
[10:31:22.204]                           computeRestarts <- base::computeRestarts
[10:31:22.204]                           grepl <- base::grepl
[10:31:22.204]                           restarts <- computeRestarts(cond)
[10:31:22.204]                           for (restart in restarts) {
[10:31:22.204]                             name <- restart$name
[10:31:22.204]                             if (is.null(name)) 
[10:31:22.204]                               next
[10:31:22.204]                             if (!grepl(pattern, name)) 
[10:31:22.204]                               next
[10:31:22.204]                             invokeRestart(restart)
[10:31:22.204]                             muffled <- TRUE
[10:31:22.204]                             break
[10:31:22.204]                           }
[10:31:22.204]                         }
[10:31:22.204]                       }
[10:31:22.204]                       invisible(muffled)
[10:31:22.204]                     }
[10:31:22.204]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.204]                   }
[10:31:22.204]                 }
[10:31:22.204]             }
[10:31:22.204]         }))
[10:31:22.204]     }, error = function(ex) {
[10:31:22.204]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.204]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.204]                 ...future.rng), started = ...future.startTime, 
[10:31:22.204]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.204]             version = "1.8"), class = "FutureResult")
[10:31:22.204]     }, finally = {
[10:31:22.204]         if (!identical(...future.workdir, getwd())) 
[10:31:22.204]             setwd(...future.workdir)
[10:31:22.204]         {
[10:31:22.204]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.204]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.204]             }
[10:31:22.204]             base::options(...future.oldOptions)
[10:31:22.204]             if (.Platform$OS.type == "windows") {
[10:31:22.204]                 old_names <- names(...future.oldEnvVars)
[10:31:22.204]                 envs <- base::Sys.getenv()
[10:31:22.204]                 names <- names(envs)
[10:31:22.204]                 common <- intersect(names, old_names)
[10:31:22.204]                 added <- setdiff(names, old_names)
[10:31:22.204]                 removed <- setdiff(old_names, names)
[10:31:22.204]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.204]                   envs[common]]
[10:31:22.204]                 NAMES <- toupper(changed)
[10:31:22.204]                 args <- list()
[10:31:22.204]                 for (kk in seq_along(NAMES)) {
[10:31:22.204]                   name <- changed[[kk]]
[10:31:22.204]                   NAME <- NAMES[[kk]]
[10:31:22.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.204]                     next
[10:31:22.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.204]                 }
[10:31:22.204]                 NAMES <- toupper(added)
[10:31:22.204]                 for (kk in seq_along(NAMES)) {
[10:31:22.204]                   name <- added[[kk]]
[10:31:22.204]                   NAME <- NAMES[[kk]]
[10:31:22.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.204]                     next
[10:31:22.204]                   args[[name]] <- ""
[10:31:22.204]                 }
[10:31:22.204]                 NAMES <- toupper(removed)
[10:31:22.204]                 for (kk in seq_along(NAMES)) {
[10:31:22.204]                   name <- removed[[kk]]
[10:31:22.204]                   NAME <- NAMES[[kk]]
[10:31:22.204]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.204]                     next
[10:31:22.204]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.204]                 }
[10:31:22.204]                 if (length(args) > 0) 
[10:31:22.204]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.204]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.204]             }
[10:31:22.204]             else {
[10:31:22.204]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.204]             }
[10:31:22.204]             {
[10:31:22.204]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.204]                   0L) {
[10:31:22.204]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.204]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.204]                   base::options(opts)
[10:31:22.204]                 }
[10:31:22.204]                 {
[10:31:22.204]                   {
[10:31:22.204]                     NULL
[10:31:22.204]                     RNGkind("Mersenne-Twister")
[10:31:22.204]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:22.204]                       inherits = FALSE)
[10:31:22.204]                   }
[10:31:22.204]                   options(future.plan = NULL)
[10:31:22.204]                   if (is.na(NA_character_)) 
[10:31:22.204]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.204]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.204]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.204]                     .init = FALSE)
[10:31:22.204]                 }
[10:31:22.204]             }
[10:31:22.204]         }
[10:31:22.204]     })
[10:31:22.204]     if (TRUE) {
[10:31:22.204]         base::sink(type = "output", split = FALSE)
[10:31:22.204]         if (TRUE) {
[10:31:22.204]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.204]         }
[10:31:22.204]         else {
[10:31:22.204]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.204]         }
[10:31:22.204]         base::close(...future.stdout)
[10:31:22.204]         ...future.stdout <- NULL
[10:31:22.204]     }
[10:31:22.204]     ...future.result$conditions <- ...future.conditions
[10:31:22.204]     ...future.result$finished <- base::Sys.time()
[10:31:22.204]     ...future.result
[10:31:22.204] }
[10:31:22.206] assign_globals() ...
[10:31:22.206] List of 11
[10:31:22.206]  $ ...future.FUN            :function (x, ...)  
[10:31:22.206]  $ x_FUN                    :function (x, y)  
[10:31:22.206]  $ times                    : int 15
[10:31:22.206]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.206]  $ stop_if_not              :function (...)  
[10:31:22.206]  $ dim                      : int [1:2] 3 5
[10:31:22.206]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:22.206]  $ future.call.arguments    :List of 1
[10:31:22.206]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:22.206]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.206]  $ ...future.elements_ii    :List of 4
[10:31:22.206]   ..$ A: num 50
[10:31:22.206]   ..$ B: num 60
[10:31:22.206]   ..$ C: num 70
[10:31:22.206]   ..$ D: num 80
[10:31:22.206]  $ ...future.seeds_ii       : NULL
[10:31:22.206]  $ ...future.globals.maxSize: NULL
[10:31:22.206]  - attr(*, "where")=List of 11
[10:31:22.206]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.206]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.206]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.206]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.206]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.206]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.206]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.206]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.206]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.206]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.206]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.206]  - attr(*, "resolved")= logi FALSE
[10:31:22.206]  - attr(*, "total_size")= num 98600
[10:31:22.206]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.206]  - attr(*, "already-done")= logi TRUE
[10:31:22.215] - copied ‘...future.FUN’ to environment
[10:31:22.215] - reassign environment for ‘x_FUN’
[10:31:22.215] - copied ‘x_FUN’ to environment
[10:31:22.215] - copied ‘times’ to environment
[10:31:22.215] - copied ‘stopf’ to environment
[10:31:22.215] - copied ‘stop_if_not’ to environment
[10:31:22.215] - copied ‘dim’ to environment
[10:31:22.215] - copied ‘valid_types’ to environment
[10:31:22.215] - copied ‘future.call.arguments’ to environment
[10:31:22.216] - copied ‘...future.elements_ii’ to environment
[10:31:22.216] - copied ‘...future.seeds_ii’ to environment
[10:31:22.217] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.217] assign_globals() ... done
[10:31:22.218] plan(): Setting new future strategy stack:
[10:31:22.218] List of future strategies:
[10:31:22.218] 1. sequential:
[10:31:22.218]    - args: function (..., envir = parent.frame())
[10:31:22.218]    - tweaked: FALSE
[10:31:22.218]    - call: NULL
[10:31:22.218] plan(): nbrOfWorkers() = 1
[10:31:22.219] plan(): Setting new future strategy stack:
[10:31:22.219] List of future strategies:
[10:31:22.219] 1. sequential:
[10:31:22.219]    - args: function (..., envir = parent.frame())
[10:31:22.219]    - tweaked: FALSE
[10:31:22.219]    - call: plan(strategy)
[10:31:22.220] plan(): nbrOfWorkers() = 1
[10:31:22.220] SequentialFuture started (and completed)
[10:31:22.220] - Launch lazy future ... done
[10:31:22.220] run() for ‘SequentialFuture’ ... done
[10:31:22.220] Created future:
[10:31:22.221] SequentialFuture:
[10:31:22.221] Label: ‘future_vapply-1’
[10:31:22.221] Expression:
[10:31:22.221] {
[10:31:22.221]     do.call(function(...) {
[10:31:22.221]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.221]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.221]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.221]             on.exit(options(oopts), add = TRUE)
[10:31:22.221]         }
[10:31:22.221]         {
[10:31:22.221]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.221]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.221]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.221]             })
[10:31:22.221]         }
[10:31:22.221]     }, args = future.call.arguments)
[10:31:22.221] }
[10:31:22.221] Lazy evaluation: FALSE
[10:31:22.221] Asynchronous evaluation: FALSE
[10:31:22.221] Local evaluation: TRUE
[10:31:22.221] Environment: R_GlobalEnv
[10:31:22.221] Capture standard output: TRUE
[10:31:22.221] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.221] Globals: 11 objects totaling 96.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.221] Packages: 1 packages (‘future.apply’)
[10:31:22.221] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.221] Resolved: TRUE
[10:31:22.221] Value: 1.34 KiB of class ‘list’
[10:31:22.221] Early signaling: FALSE
[10:31:22.221] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.221] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.222] Chunk #1 of 1 ... DONE
[10:31:22.222] Launching 1 futures (chunks) ... DONE
[10:31:22.222] Resolving 1 futures (chunks) ...
[10:31:22.222] resolve() on list ...
[10:31:22.222]  recursive: 0
[10:31:22.222]  length: 1
[10:31:22.222] 
[10:31:22.222] resolved() for ‘SequentialFuture’ ...
[10:31:22.223] - state: ‘finished’
[10:31:22.223] - run: TRUE
[10:31:22.223] - result: ‘FutureResult’
[10:31:22.223] resolved() for ‘SequentialFuture’ ... done
[10:31:22.223] Future #1
[10:31:22.223] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:22.223] - nx: 1
[10:31:22.223] - relay: TRUE
[10:31:22.223] - stdout: TRUE
[10:31:22.223] - signal: TRUE
[10:31:22.224] - resignal: FALSE
[10:31:22.224] - force: TRUE
[10:31:22.224] - relayed: [n=1] FALSE
[10:31:22.224] - queued futures: [n=1] FALSE
[10:31:22.224]  - until=1
[10:31:22.224]  - relaying element #1
[10:31:22.224] - relayed: [n=1] TRUE
[10:31:22.224] - queued futures: [n=1] TRUE
[10:31:22.224] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:22.225]  length: 0 (resolved future 1)
[10:31:22.225] Relaying remaining futures
[10:31:22.225] signalConditionsASAP(NULL, pos=0) ...
[10:31:22.225] - nx: 1
[10:31:22.225] - relay: TRUE
[10:31:22.225] - stdout: TRUE
[10:31:22.226] - signal: TRUE
[10:31:22.226] - resignal: FALSE
[10:31:22.226] - force: TRUE
[10:31:22.226] - relayed: [n=1] TRUE
[10:31:22.226] - queued futures: [n=1] TRUE
 - flush all
[10:31:22.226] - relayed: [n=1] TRUE
[10:31:22.226] - queued futures: [n=1] TRUE
[10:31:22.226] signalConditionsASAP(NULL, pos=0) ... done
[10:31:22.226] resolve() on list ... DONE
[10:31:22.227]  - Number of value chunks collected: 1
[10:31:22.227] Resolving 1 futures (chunks) ... DONE
[10:31:22.227] Reducing values from 1 chunks ...
[10:31:22.227]  - Number of values collected after concatenation: 4
[10:31:22.227]  - Number of values expected: 4
[10:31:22.227] Reducing values from 1 chunks ... DONE
[10:31:22.227] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[10:31:22.229] future_lapply() ...
[10:31:22.231] Number of chunks: 1
[10:31:22.231] getGlobalsAndPackagesXApply() ...
[10:31:22.231]  - future.globals: TRUE
[10:31:22.231] getGlobalsAndPackages() ...
[10:31:22.231] Searching for globals...
[10:31:22.234] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:22.234] Searching for globals ... DONE
[10:31:22.235] Resolving globals: FALSE
[10:31:22.235] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[10:31:22.236] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:22.236] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.236] - packages: [1] ‘future.apply’
[10:31:22.236] getGlobalsAndPackages() ... DONE
[10:31:22.236]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.236]  - needed namespaces: [n=1] ‘future.apply’
[10:31:22.237] Finding globals ... DONE
[10:31:22.237]  - use_args: TRUE
[10:31:22.237]  - Getting '...' globals ...
[10:31:22.237] resolve() on list ...
[10:31:22.237]  recursive: 0
[10:31:22.237]  length: 1
[10:31:22.237]  elements: ‘...’
[10:31:22.237]  length: 0 (resolved future 1)
[10:31:22.238] resolve() on list ... DONE
[10:31:22.238]    - '...' content: [n=0] 
[10:31:22.238] List of 1
[10:31:22.238]  $ ...: list()
[10:31:22.238]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.238]  - attr(*, "where")=List of 1
[10:31:22.238]   ..$ ...:<environment: 0x55de856a4f50> 
[10:31:22.238]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.238]  - attr(*, "resolved")= logi TRUE
[10:31:22.238]  - attr(*, "total_size")= num NA
[10:31:22.242]  - Getting '...' globals ... DONE
[10:31:22.242] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:22.243] List of 8
[10:31:22.243]  $ ...future.FUN:function (x, ...)  
[10:31:22.243]  $ x_FUN        :function (x)  
[10:31:22.243]  $ times        : int 1
[10:31:22.243]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.243]  $ stop_if_not  :function (...)  
[10:31:22.243]  $ dim          : NULL
[10:31:22.243]  $ valid_types  : chr "logical"
[10:31:22.243]  $ ...          : list()
[10:31:22.243]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.243]  - attr(*, "where")=List of 8
[10:31:22.243]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:22.243]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:22.243]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:22.243]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:22.243]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:22.243]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:22.243]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:22.243]   ..$ ...          :<environment: 0x55de856a4f50> 
[10:31:22.243]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.243]  - attr(*, "resolved")= logi FALSE
[10:31:22.243]  - attr(*, "total_size")= num 94200
[10:31:22.248] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:22.248] getGlobalsAndPackagesXApply() ... DONE
[10:31:22.249] Number of futures (= number of chunks): 1
[10:31:22.249] Launching 1 futures (chunks) ...
[10:31:22.249] Chunk #1 of 1 ...
[10:31:22.249]  - Finding globals in 'X' for chunk #1 ...
[10:31:22.249] getGlobalsAndPackages() ...
[10:31:22.249] Searching for globals...
[10:31:22.249] 
[10:31:22.249] Searching for globals ... DONE
[10:31:22.250] - globals: [0] <none>
[10:31:22.250] getGlobalsAndPackages() ... DONE
[10:31:22.250]    + additional globals found: [n=0] 
[10:31:22.250]    + additional namespaces needed: [n=0] 
[10:31:22.250]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:22.250]  - seeds: <none>
[10:31:22.250]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.250] getGlobalsAndPackages() ...
[10:31:22.250] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.250] Resolving globals: FALSE
[10:31:22.251] Tweak future expression to call with '...' arguments ...
[10:31:22.251] {
[10:31:22.251]     do.call(function(...) {
[10:31:22.251]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.251]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.251]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.251]             on.exit(options(oopts), add = TRUE)
[10:31:22.251]         }
[10:31:22.251]         {
[10:31:22.251]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.251]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.251]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.251]             })
[10:31:22.251]         }
[10:31:22.251]     }, args = future.call.arguments)
[10:31:22.251] }
[10:31:22.251] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.251] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.252] - packages: [1] ‘future.apply’
[10:31:22.252] getGlobalsAndPackages() ... DONE
[10:31:22.252] run() for ‘Future’ ...
[10:31:22.252] - state: ‘created’
[10:31:22.252] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:22.253] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.253] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:22.253]   - Field: ‘label’
[10:31:22.253]   - Field: ‘local’
[10:31:22.253]   - Field: ‘owner’
[10:31:22.253]   - Field: ‘envir’
[10:31:22.253]   - Field: ‘packages’
[10:31:22.253]   - Field: ‘gc’
[10:31:22.253]   - Field: ‘conditions’
[10:31:22.253]   - Field: ‘expr’
[10:31:22.254]   - Field: ‘uuid’
[10:31:22.254]   - Field: ‘seed’
[10:31:22.254]   - Field: ‘version’
[10:31:22.254]   - Field: ‘result’
[10:31:22.254]   - Field: ‘asynchronous’
[10:31:22.254]   - Field: ‘calls’
[10:31:22.254]   - Field: ‘globals’
[10:31:22.254]   - Field: ‘stdout’
[10:31:22.254]   - Field: ‘earlySignal’
[10:31:22.254]   - Field: ‘lazy’
[10:31:22.254]   - Field: ‘state’
[10:31:22.255] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:22.255] - Launch lazy future ...
[10:31:22.255] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.255] Packages needed by future strategies (n = 0): <none>
[10:31:22.255] {
[10:31:22.255]     {
[10:31:22.255]         {
[10:31:22.255]             ...future.startTime <- base::Sys.time()
[10:31:22.255]             {
[10:31:22.255]                 {
[10:31:22.255]                   {
[10:31:22.255]                     {
[10:31:22.255]                       base::local({
[10:31:22.255]                         has_future <- base::requireNamespace("future", 
[10:31:22.255]                           quietly = TRUE)
[10:31:22.255]                         if (has_future) {
[10:31:22.255]                           ns <- base::getNamespace("future")
[10:31:22.255]                           version <- ns[[".package"]][["version"]]
[10:31:22.255]                           if (is.null(version)) 
[10:31:22.255]                             version <- utils::packageVersion("future")
[10:31:22.255]                         }
[10:31:22.255]                         else {
[10:31:22.255]                           version <- NULL
[10:31:22.255]                         }
[10:31:22.255]                         if (!has_future || version < "1.8.0") {
[10:31:22.255]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.255]                             "", base::R.version$version.string), 
[10:31:22.255]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:22.255]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:22.255]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.255]                               "release", "version")], collapse = " "), 
[10:31:22.255]                             hostname = base::Sys.info()[["nodename"]])
[10:31:22.255]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.255]                             info)
[10:31:22.255]                           info <- base::paste(info, collapse = "; ")
[10:31:22.255]                           if (!has_future) {
[10:31:22.255]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.255]                               info)
[10:31:22.255]                           }
[10:31:22.255]                           else {
[10:31:22.255]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.255]                               info, version)
[10:31:22.255]                           }
[10:31:22.255]                           base::stop(msg)
[10:31:22.255]                         }
[10:31:22.255]                       })
[10:31:22.255]                     }
[10:31:22.255]                     base::local({
[10:31:22.255]                       for (pkg in "future.apply") {
[10:31:22.255]                         base::loadNamespace(pkg)
[10:31:22.255]                         base::library(pkg, character.only = TRUE)
[10:31:22.255]                       }
[10:31:22.255]                     })
[10:31:22.255]                   }
[10:31:22.255]                   ...future.strategy.old <- future::plan("list")
[10:31:22.255]                   options(future.plan = NULL)
[10:31:22.255]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.255]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.255]                 }
[10:31:22.255]                 ...future.workdir <- getwd()
[10:31:22.255]             }
[10:31:22.255]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.255]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.255]         }
[10:31:22.255]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.255]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:22.255]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.255]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.255]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.255]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.255]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.255]             base::names(...future.oldOptions))
[10:31:22.255]     }
[10:31:22.255]     if (FALSE) {
[10:31:22.255]     }
[10:31:22.255]     else {
[10:31:22.255]         if (TRUE) {
[10:31:22.255]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.255]                 open = "w")
[10:31:22.255]         }
[10:31:22.255]         else {
[10:31:22.255]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.255]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.255]         }
[10:31:22.255]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.255]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.255]             base::sink(type = "output", split = FALSE)
[10:31:22.255]             base::close(...future.stdout)
[10:31:22.255]         }, add = TRUE)
[10:31:22.255]     }
[10:31:22.255]     ...future.frame <- base::sys.nframe()
[10:31:22.255]     ...future.conditions <- base::list()
[10:31:22.255]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.255]     if (FALSE) {
[10:31:22.255]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.255]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.255]     }
[10:31:22.255]     ...future.result <- base::tryCatch({
[10:31:22.255]         base::withCallingHandlers({
[10:31:22.255]             ...future.value <- base::withVisible(base::local({
[10:31:22.255]                 do.call(function(...) {
[10:31:22.255]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.255]                   if (!identical(...future.globals.maxSize.org, 
[10:31:22.255]                     ...future.globals.maxSize)) {
[10:31:22.255]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.255]                     on.exit(options(oopts), add = TRUE)
[10:31:22.255]                   }
[10:31:22.255]                   {
[10:31:22.255]                     lapply(seq_along(...future.elements_ii), 
[10:31:22.255]                       FUN = function(jj) {
[10:31:22.255]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.255]                         ...future.FUN(...future.X_jj, ...)
[10:31:22.255]                       })
[10:31:22.255]                   }
[10:31:22.255]                 }, args = future.call.arguments)
[10:31:22.255]             }))
[10:31:22.255]             future::FutureResult(value = ...future.value$value, 
[10:31:22.255]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.255]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.255]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.255]                     ...future.globalenv.names))
[10:31:22.255]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.255]         }, condition = base::local({
[10:31:22.255]             c <- base::c
[10:31:22.255]             inherits <- base::inherits
[10:31:22.255]             invokeRestart <- base::invokeRestart
[10:31:22.255]             length <- base::length
[10:31:22.255]             list <- base::list
[10:31:22.255]             seq.int <- base::seq.int
[10:31:22.255]             signalCondition <- base::signalCondition
[10:31:22.255]             sys.calls <- base::sys.calls
[10:31:22.255]             `[[` <- base::`[[`
[10:31:22.255]             `+` <- base::`+`
[10:31:22.255]             `<<-` <- base::`<<-`
[10:31:22.255]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.255]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.255]                   3L)]
[10:31:22.255]             }
[10:31:22.255]             function(cond) {
[10:31:22.255]                 is_error <- inherits(cond, "error")
[10:31:22.255]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.255]                   NULL)
[10:31:22.255]                 if (is_error) {
[10:31:22.255]                   sessionInformation <- function() {
[10:31:22.255]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.255]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.255]                       search = base::search(), system = base::Sys.info())
[10:31:22.255]                   }
[10:31:22.255]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.255]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.255]                     cond$call), session = sessionInformation(), 
[10:31:22.255]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.255]                   signalCondition(cond)
[10:31:22.255]                 }
[10:31:22.255]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.255]                 "immediateCondition"))) {
[10:31:22.255]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.255]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.255]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.255]                   if (TRUE && !signal) {
[10:31:22.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.255]                     {
[10:31:22.255]                       inherits <- base::inherits
[10:31:22.255]                       invokeRestart <- base::invokeRestart
[10:31:22.255]                       is.null <- base::is.null
[10:31:22.255]                       muffled <- FALSE
[10:31:22.255]                       if (inherits(cond, "message")) {
[10:31:22.255]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.255]                         if (muffled) 
[10:31:22.255]                           invokeRestart("muffleMessage")
[10:31:22.255]                       }
[10:31:22.255]                       else if (inherits(cond, "warning")) {
[10:31:22.255]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.255]                         if (muffled) 
[10:31:22.255]                           invokeRestart("muffleWarning")
[10:31:22.255]                       }
[10:31:22.255]                       else if (inherits(cond, "condition")) {
[10:31:22.255]                         if (!is.null(pattern)) {
[10:31:22.255]                           computeRestarts <- base::computeRestarts
[10:31:22.255]                           grepl <- base::grepl
[10:31:22.255]                           restarts <- computeRestarts(cond)
[10:31:22.255]                           for (restart in restarts) {
[10:31:22.255]                             name <- restart$name
[10:31:22.255]                             if (is.null(name)) 
[10:31:22.255]                               next
[10:31:22.255]                             if (!grepl(pattern, name)) 
[10:31:22.255]                               next
[10:31:22.255]                             invokeRestart(restart)
[10:31:22.255]                             muffled <- TRUE
[10:31:22.255]                             break
[10:31:22.255]                           }
[10:31:22.255]                         }
[10:31:22.255]                       }
[10:31:22.255]                       invisible(muffled)
[10:31:22.255]                     }
[10:31:22.255]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.255]                   }
[10:31:22.255]                 }
[10:31:22.255]                 else {
[10:31:22.255]                   if (TRUE) {
[10:31:22.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.255]                     {
[10:31:22.255]                       inherits <- base::inherits
[10:31:22.255]                       invokeRestart <- base::invokeRestart
[10:31:22.255]                       is.null <- base::is.null
[10:31:22.255]                       muffled <- FALSE
[10:31:22.255]                       if (inherits(cond, "message")) {
[10:31:22.255]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.255]                         if (muffled) 
[10:31:22.255]                           invokeRestart("muffleMessage")
[10:31:22.255]                       }
[10:31:22.255]                       else if (inherits(cond, "warning")) {
[10:31:22.255]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.255]                         if (muffled) 
[10:31:22.255]                           invokeRestart("muffleWarning")
[10:31:22.255]                       }
[10:31:22.255]                       else if (inherits(cond, "condition")) {
[10:31:22.255]                         if (!is.null(pattern)) {
[10:31:22.255]                           computeRestarts <- base::computeRestarts
[10:31:22.255]                           grepl <- base::grepl
[10:31:22.255]                           restarts <- computeRestarts(cond)
[10:31:22.255]                           for (restart in restarts) {
[10:31:22.255]                             name <- restart$name
[10:31:22.255]                             if (is.null(name)) 
[10:31:22.255]                               next
[10:31:22.255]                             if (!grepl(pattern, name)) 
[10:31:22.255]                               next
[10:31:22.255]                             invokeRestart(restart)
[10:31:22.255]                             muffled <- TRUE
[10:31:22.255]                             break
[10:31:22.255]                           }
[10:31:22.255]                         }
[10:31:22.255]                       }
[10:31:22.255]                       invisible(muffled)
[10:31:22.255]                     }
[10:31:22.255]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.255]                   }
[10:31:22.255]                 }
[10:31:22.255]             }
[10:31:22.255]         }))
[10:31:22.255]     }, error = function(ex) {
[10:31:22.255]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.255]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.255]                 ...future.rng), started = ...future.startTime, 
[10:31:22.255]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.255]             version = "1.8"), class = "FutureResult")
[10:31:22.255]     }, finally = {
[10:31:22.255]         if (!identical(...future.workdir, getwd())) 
[10:31:22.255]             setwd(...future.workdir)
[10:31:22.255]         {
[10:31:22.255]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.255]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.255]             }
[10:31:22.255]             base::options(...future.oldOptions)
[10:31:22.255]             if (.Platform$OS.type == "windows") {
[10:31:22.255]                 old_names <- names(...future.oldEnvVars)
[10:31:22.255]                 envs <- base::Sys.getenv()
[10:31:22.255]                 names <- names(envs)
[10:31:22.255]                 common <- intersect(names, old_names)
[10:31:22.255]                 added <- setdiff(names, old_names)
[10:31:22.255]                 removed <- setdiff(old_names, names)
[10:31:22.255]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.255]                   envs[common]]
[10:31:22.255]                 NAMES <- toupper(changed)
[10:31:22.255]                 args <- list()
[10:31:22.255]                 for (kk in seq_along(NAMES)) {
[10:31:22.255]                   name <- changed[[kk]]
[10:31:22.255]                   NAME <- NAMES[[kk]]
[10:31:22.255]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.255]                     next
[10:31:22.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.255]                 }
[10:31:22.255]                 NAMES <- toupper(added)
[10:31:22.255]                 for (kk in seq_along(NAMES)) {
[10:31:22.255]                   name <- added[[kk]]
[10:31:22.255]                   NAME <- NAMES[[kk]]
[10:31:22.255]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.255]                     next
[10:31:22.255]                   args[[name]] <- ""
[10:31:22.255]                 }
[10:31:22.255]                 NAMES <- toupper(removed)
[10:31:22.255]                 for (kk in seq_along(NAMES)) {
[10:31:22.255]                   name <- removed[[kk]]
[10:31:22.255]                   NAME <- NAMES[[kk]]
[10:31:22.255]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.255]                     next
[10:31:22.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.255]                 }
[10:31:22.255]                 if (length(args) > 0) 
[10:31:22.255]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.255]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.255]             }
[10:31:22.255]             else {
[10:31:22.255]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.255]             }
[10:31:22.255]             {
[10:31:22.255]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.255]                   0L) {
[10:31:22.255]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.255]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.255]                   base::options(opts)
[10:31:22.255]                 }
[10:31:22.255]                 {
[10:31:22.255]                   {
[10:31:22.255]                     NULL
[10:31:22.255]                     RNGkind("Mersenne-Twister")
[10:31:22.255]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:22.255]                       inherits = FALSE)
[10:31:22.255]                   }
[10:31:22.255]                   options(future.plan = NULL)
[10:31:22.255]                   if (is.na(NA_character_)) 
[10:31:22.255]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.255]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.255]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.255]                     .init = FALSE)
[10:31:22.255]                 }
[10:31:22.255]             }
[10:31:22.255]         }
[10:31:22.255]     })
[10:31:22.255]     if (TRUE) {
[10:31:22.255]         base::sink(type = "output", split = FALSE)
[10:31:22.255]         if (TRUE) {
[10:31:22.255]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.255]         }
[10:31:22.255]         else {
[10:31:22.255]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.255]         }
[10:31:22.255]         base::close(...future.stdout)
[10:31:22.255]         ...future.stdout <- NULL
[10:31:22.255]     }
[10:31:22.255]     ...future.result$conditions <- ...future.conditions
[10:31:22.255]     ...future.result$finished <- base::Sys.time()
[10:31:22.255]     ...future.result
[10:31:22.255] }
[10:31:22.257] assign_globals() ...
[10:31:22.257] List of 11
[10:31:22.257]  $ ...future.FUN            :function (x, ...)  
[10:31:22.257]  $ x_FUN                    :function (x)  
[10:31:22.257]  $ times                    : int 1
[10:31:22.257]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.257]  $ stop_if_not              :function (...)  
[10:31:22.257]  $ dim                      : NULL
[10:31:22.257]  $ valid_types              : chr "logical"
[10:31:22.257]  $ future.call.arguments    : list()
[10:31:22.257]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.257]  $ ...future.elements_ii    :List of 11
[10:31:22.257]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[10:31:22.257]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[10:31:22.257]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[10:31:22.257]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[10:31:22.257]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[10:31:22.257]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[10:31:22.257]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[10:31:22.257]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[10:31:22.257]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[10:31:22.257]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[10:31:22.257]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[10:31:22.257]  $ ...future.seeds_ii       : NULL
[10:31:22.257]  $ ...future.globals.maxSize: NULL
[10:31:22.257]  - attr(*, "where")=List of 11
[10:31:22.257]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.257]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.257]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.257]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.257]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.257]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.257]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.257]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.257]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.257]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.257]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.257]  - attr(*, "resolved")= logi FALSE
[10:31:22.257]  - attr(*, "total_size")= num 94200
[10:31:22.257]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.257]  - attr(*, "already-done")= logi TRUE
[10:31:22.270] - copied ‘...future.FUN’ to environment
[10:31:22.270] - copied ‘x_FUN’ to environment
[10:31:22.270] - copied ‘times’ to environment
[10:31:22.270] - copied ‘stopf’ to environment
[10:31:22.270] - copied ‘stop_if_not’ to environment
[10:31:22.270] - copied ‘dim’ to environment
[10:31:22.270] - copied ‘valid_types’ to environment
[10:31:22.270] - copied ‘future.call.arguments’ to environment
[10:31:22.271] - copied ‘...future.elements_ii’ to environment
[10:31:22.271] - copied ‘...future.seeds_ii’ to environment
[10:31:22.271] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.271] assign_globals() ... done
[10:31:22.271] plan(): Setting new future strategy stack:
[10:31:22.271] List of future strategies:
[10:31:22.271] 1. sequential:
[10:31:22.271]    - args: function (..., envir = parent.frame())
[10:31:22.271]    - tweaked: FALSE
[10:31:22.271]    - call: NULL
[10:31:22.272] plan(): nbrOfWorkers() = 1
[10:31:22.273] plan(): Setting new future strategy stack:
[10:31:22.273] List of future strategies:
[10:31:22.273] 1. sequential:
[10:31:22.273]    - args: function (..., envir = parent.frame())
[10:31:22.273]    - tweaked: FALSE
[10:31:22.273]    - call: plan(strategy)
[10:31:22.273] plan(): nbrOfWorkers() = 1
[10:31:22.273] SequentialFuture started (and completed)
[10:31:22.273] - Launch lazy future ... done
[10:31:22.273] run() for ‘SequentialFuture’ ... done
[10:31:22.274] Created future:
[10:31:22.274] SequentialFuture:
[10:31:22.274] Label: ‘future_vapply-1’
[10:31:22.274] Expression:
[10:31:22.274] {
[10:31:22.274]     do.call(function(...) {
[10:31:22.274]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.274]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.274]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.274]             on.exit(options(oopts), add = TRUE)
[10:31:22.274]         }
[10:31:22.274]         {
[10:31:22.274]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.274]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.274]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.274]             })
[10:31:22.274]         }
[10:31:22.274]     }, args = future.call.arguments)
[10:31:22.274] }
[10:31:22.274] Lazy evaluation: FALSE
[10:31:22.274] Asynchronous evaluation: FALSE
[10:31:22.274] Local evaluation: TRUE
[10:31:22.274] Environment: R_GlobalEnv
[10:31:22.274] Capture standard output: TRUE
[10:31:22.274] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.274] Globals: 11 objects totaling 95.26 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.274] Packages: 1 packages (‘future.apply’)
[10:31:22.274] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.274] Resolved: TRUE
[10:31:22.274] Value: 616 bytes of class ‘list’
[10:31:22.274] Early signaling: FALSE
[10:31:22.274] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.274] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.275] Chunk #1 of 1 ... DONE
[10:31:22.275] Launching 1 futures (chunks) ... DONE
[10:31:22.275] Resolving 1 futures (chunks) ...
[10:31:22.275] resolve() on list ...
[10:31:22.275]  recursive: 0
[10:31:22.275]  length: 1
[10:31:22.275] 
[10:31:22.275] resolved() for ‘SequentialFuture’ ...
[10:31:22.276] - state: ‘finished’
[10:31:22.276] - run: TRUE
[10:31:22.276] - result: ‘FutureResult’
[10:31:22.276] resolved() for ‘SequentialFuture’ ... done
[10:31:22.276] Future #1
[10:31:22.276] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:22.276] - nx: 1
[10:31:22.276] - relay: TRUE
[10:31:22.276] - stdout: TRUE
[10:31:22.276] - signal: TRUE
[10:31:22.277] - resignal: FALSE
[10:31:22.277] - force: TRUE
[10:31:22.277] - relayed: [n=1] FALSE
[10:31:22.277] - queued futures: [n=1] FALSE
[10:31:22.277]  - until=1
[10:31:22.277]  - relaying element #1
[10:31:22.277] - relayed: [n=1] TRUE
[10:31:22.277] - queued futures: [n=1] TRUE
[10:31:22.277] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:22.277]  length: 0 (resolved future 1)
[10:31:22.278] Relaying remaining futures
[10:31:22.278] signalConditionsASAP(NULL, pos=0) ...
[10:31:22.278] - nx: 1
[10:31:22.278] - relay: TRUE
[10:31:22.278] - stdout: TRUE
[10:31:22.278] - signal: TRUE
[10:31:22.278] - resignal: FALSE
[10:31:22.278] - force: TRUE
[10:31:22.278] - relayed: [n=1] TRUE
[10:31:22.278] - queued futures: [n=1] TRUE
 - flush all
[10:31:22.278] - relayed: [n=1] TRUE
[10:31:22.279] - queued futures: [n=1] TRUE
[10:31:22.279] signalConditionsASAP(NULL, pos=0) ... done
[10:31:22.279] resolve() on list ... DONE
[10:31:22.279]  - Number of value chunks collected: 1
[10:31:22.279] Resolving 1 futures (chunks) ... DONE
[10:31:22.279] Reducing values from 1 chunks ...
[10:31:22.279]  - Number of values collected after concatenation: 11
[10:31:22.279]  - Number of values expected: 11
[10:31:22.279] Reducing values from 1 chunks ... DONE
[10:31:22.279] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[10:31:22.280] future_lapply() ...
[10:31:22.282] Number of chunks: 1
[10:31:22.282] getGlobalsAndPackagesXApply() ...
[10:31:22.282]  - future.globals: TRUE
[10:31:22.282] getGlobalsAndPackages() ...
[10:31:22.282] Searching for globals...
[10:31:22.287] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:22.288] Searching for globals ... DONE
[10:31:22.288] Resolving globals: FALSE
[10:31:22.289] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[10:31:22.289] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:22.289] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.289] - packages: [1] ‘future.apply’
[10:31:22.289] getGlobalsAndPackages() ... DONE
[10:31:22.289]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.290]  - needed namespaces: [n=1] ‘future.apply’
[10:31:22.290] Finding globals ... DONE
[10:31:22.290]  - use_args: TRUE
[10:31:22.290]  - Getting '...' globals ...
[10:31:22.290] resolve() on list ...
[10:31:22.290]  recursive: 0
[10:31:22.290]  length: 1
[10:31:22.290]  elements: ‘...’
[10:31:22.291]  length: 0 (resolved future 1)
[10:31:22.291] resolve() on list ... DONE
[10:31:22.291]    - '...' content: [n=0] 
[10:31:22.291] List of 1
[10:31:22.291]  $ ...: list()
[10:31:22.291]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.291]  - attr(*, "where")=List of 1
[10:31:22.291]   ..$ ...:<environment: 0x55de85b53ef8> 
[10:31:22.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.291]  - attr(*, "resolved")= logi TRUE
[10:31:22.291]  - attr(*, "total_size")= num NA
[10:31:22.293]  - Getting '...' globals ... DONE
[10:31:22.294] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:22.294] List of 8
[10:31:22.294]  $ ...future.FUN:function (x, ...)  
[10:31:22.294]  $ x_FUN        :function (x)  
[10:31:22.294]  $ times        : int 1
[10:31:22.294]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.294]  $ stop_if_not  :function (...)  
[10:31:22.294]  $ dim          : NULL
[10:31:22.294]  $ valid_types  : chr [1:2] "logical" "integer"
[10:31:22.294]  $ ...          : list()
[10:31:22.294]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.294]  - attr(*, "where")=List of 8
[10:31:22.294]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:22.294]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:22.294]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:22.294]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:22.294]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:22.294]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:22.294]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:22.294]   ..$ ...          :<environment: 0x55de85b53ef8> 
[10:31:22.294]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.294]  - attr(*, "resolved")= logi FALSE
[10:31:22.294]  - attr(*, "total_size")= num 94264
[10:31:22.299] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:22.299] getGlobalsAndPackagesXApply() ... DONE
[10:31:22.299] Number of futures (= number of chunks): 1
[10:31:22.300] Launching 1 futures (chunks) ...
[10:31:22.300] Chunk #1 of 1 ...
[10:31:22.300]  - Finding globals in 'X' for chunk #1 ...
[10:31:22.300] getGlobalsAndPackages() ...
[10:31:22.300] Searching for globals...
[10:31:22.300] 
[10:31:22.300] Searching for globals ... DONE
[10:31:22.300] - globals: [0] <none>
[10:31:22.300] getGlobalsAndPackages() ... DONE
[10:31:22.301]    + additional globals found: [n=0] 
[10:31:22.301]    + additional namespaces needed: [n=0] 
[10:31:22.301]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:22.301]  - seeds: <none>
[10:31:22.301]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.301] getGlobalsAndPackages() ...
[10:31:22.301] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.301] Resolving globals: FALSE
[10:31:22.301] Tweak future expression to call with '...' arguments ...
[10:31:22.301] {
[10:31:22.301]     do.call(function(...) {
[10:31:22.301]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.301]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.301]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.301]             on.exit(options(oopts), add = TRUE)
[10:31:22.301]         }
[10:31:22.301]         {
[10:31:22.301]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.301]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.301]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.301]             })
[10:31:22.301]         }
[10:31:22.301]     }, args = future.call.arguments)
[10:31:22.301] }
[10:31:22.302] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.302] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.302] - packages: [1] ‘future.apply’
[10:31:22.302] getGlobalsAndPackages() ... DONE
[10:31:22.303] run() for ‘Future’ ...
[10:31:22.303] - state: ‘created’
[10:31:22.303] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:22.303] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.303] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:22.303]   - Field: ‘label’
[10:31:22.304]   - Field: ‘local’
[10:31:22.304]   - Field: ‘owner’
[10:31:22.304]   - Field: ‘envir’
[10:31:22.304]   - Field: ‘packages’
[10:31:22.304]   - Field: ‘gc’
[10:31:22.304]   - Field: ‘conditions’
[10:31:22.304]   - Field: ‘expr’
[10:31:22.304]   - Field: ‘uuid’
[10:31:22.304]   - Field: ‘seed’
[10:31:22.304]   - Field: ‘version’
[10:31:22.304]   - Field: ‘result’
[10:31:22.305]   - Field: ‘asynchronous’
[10:31:22.305]   - Field: ‘calls’
[10:31:22.306]   - Field: ‘globals’
[10:31:22.306]   - Field: ‘stdout’
[10:31:22.306]   - Field: ‘earlySignal’
[10:31:22.306]   - Field: ‘lazy’
[10:31:22.307]   - Field: ‘state’
[10:31:22.307] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:22.307] - Launch lazy future ...
[10:31:22.307] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.307] Packages needed by future strategies (n = 0): <none>
[10:31:22.308] {
[10:31:22.308]     {
[10:31:22.308]         {
[10:31:22.308]             ...future.startTime <- base::Sys.time()
[10:31:22.308]             {
[10:31:22.308]                 {
[10:31:22.308]                   {
[10:31:22.308]                     {
[10:31:22.308]                       base::local({
[10:31:22.308]                         has_future <- base::requireNamespace("future", 
[10:31:22.308]                           quietly = TRUE)
[10:31:22.308]                         if (has_future) {
[10:31:22.308]                           ns <- base::getNamespace("future")
[10:31:22.308]                           version <- ns[[".package"]][["version"]]
[10:31:22.308]                           if (is.null(version)) 
[10:31:22.308]                             version <- utils::packageVersion("future")
[10:31:22.308]                         }
[10:31:22.308]                         else {
[10:31:22.308]                           version <- NULL
[10:31:22.308]                         }
[10:31:22.308]                         if (!has_future || version < "1.8.0") {
[10:31:22.308]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.308]                             "", base::R.version$version.string), 
[10:31:22.308]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:22.308]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:22.308]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.308]                               "release", "version")], collapse = " "), 
[10:31:22.308]                             hostname = base::Sys.info()[["nodename"]])
[10:31:22.308]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.308]                             info)
[10:31:22.308]                           info <- base::paste(info, collapse = "; ")
[10:31:22.308]                           if (!has_future) {
[10:31:22.308]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.308]                               info)
[10:31:22.308]                           }
[10:31:22.308]                           else {
[10:31:22.308]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.308]                               info, version)
[10:31:22.308]                           }
[10:31:22.308]                           base::stop(msg)
[10:31:22.308]                         }
[10:31:22.308]                       })
[10:31:22.308]                     }
[10:31:22.308]                     base::local({
[10:31:22.308]                       for (pkg in "future.apply") {
[10:31:22.308]                         base::loadNamespace(pkg)
[10:31:22.308]                         base::library(pkg, character.only = TRUE)
[10:31:22.308]                       }
[10:31:22.308]                     })
[10:31:22.308]                   }
[10:31:22.308]                   ...future.strategy.old <- future::plan("list")
[10:31:22.308]                   options(future.plan = NULL)
[10:31:22.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.308]                 }
[10:31:22.308]                 ...future.workdir <- getwd()
[10:31:22.308]             }
[10:31:22.308]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.308]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.308]         }
[10:31:22.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.308]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:22.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.308]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.308]             base::names(...future.oldOptions))
[10:31:22.308]     }
[10:31:22.308]     if (FALSE) {
[10:31:22.308]     }
[10:31:22.308]     else {
[10:31:22.308]         if (TRUE) {
[10:31:22.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.308]                 open = "w")
[10:31:22.308]         }
[10:31:22.308]         else {
[10:31:22.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.308]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.308]         }
[10:31:22.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.308]             base::sink(type = "output", split = FALSE)
[10:31:22.308]             base::close(...future.stdout)
[10:31:22.308]         }, add = TRUE)
[10:31:22.308]     }
[10:31:22.308]     ...future.frame <- base::sys.nframe()
[10:31:22.308]     ...future.conditions <- base::list()
[10:31:22.308]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.308]     if (FALSE) {
[10:31:22.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.308]     }
[10:31:22.308]     ...future.result <- base::tryCatch({
[10:31:22.308]         base::withCallingHandlers({
[10:31:22.308]             ...future.value <- base::withVisible(base::local({
[10:31:22.308]                 do.call(function(...) {
[10:31:22.308]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.308]                   if (!identical(...future.globals.maxSize.org, 
[10:31:22.308]                     ...future.globals.maxSize)) {
[10:31:22.308]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.308]                     on.exit(options(oopts), add = TRUE)
[10:31:22.308]                   }
[10:31:22.308]                   {
[10:31:22.308]                     lapply(seq_along(...future.elements_ii), 
[10:31:22.308]                       FUN = function(jj) {
[10:31:22.308]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.308]                         ...future.FUN(...future.X_jj, ...)
[10:31:22.308]                       })
[10:31:22.308]                   }
[10:31:22.308]                 }, args = future.call.arguments)
[10:31:22.308]             }))
[10:31:22.308]             future::FutureResult(value = ...future.value$value, 
[10:31:22.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.308]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.308]                     ...future.globalenv.names))
[10:31:22.308]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.308]         }, condition = base::local({
[10:31:22.308]             c <- base::c
[10:31:22.308]             inherits <- base::inherits
[10:31:22.308]             invokeRestart <- base::invokeRestart
[10:31:22.308]             length <- base::length
[10:31:22.308]             list <- base::list
[10:31:22.308]             seq.int <- base::seq.int
[10:31:22.308]             signalCondition <- base::signalCondition
[10:31:22.308]             sys.calls <- base::sys.calls
[10:31:22.308]             `[[` <- base::`[[`
[10:31:22.308]             `+` <- base::`+`
[10:31:22.308]             `<<-` <- base::`<<-`
[10:31:22.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.308]                   3L)]
[10:31:22.308]             }
[10:31:22.308]             function(cond) {
[10:31:22.308]                 is_error <- inherits(cond, "error")
[10:31:22.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.308]                   NULL)
[10:31:22.308]                 if (is_error) {
[10:31:22.308]                   sessionInformation <- function() {
[10:31:22.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.308]                       search = base::search(), system = base::Sys.info())
[10:31:22.308]                   }
[10:31:22.308]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.308]                     cond$call), session = sessionInformation(), 
[10:31:22.308]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.308]                   signalCondition(cond)
[10:31:22.308]                 }
[10:31:22.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.308]                 "immediateCondition"))) {
[10:31:22.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.308]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.308]                   if (TRUE && !signal) {
[10:31:22.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.308]                     {
[10:31:22.308]                       inherits <- base::inherits
[10:31:22.308]                       invokeRestart <- base::invokeRestart
[10:31:22.308]                       is.null <- base::is.null
[10:31:22.308]                       muffled <- FALSE
[10:31:22.308]                       if (inherits(cond, "message")) {
[10:31:22.308]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.308]                         if (muffled) 
[10:31:22.308]                           invokeRestart("muffleMessage")
[10:31:22.308]                       }
[10:31:22.308]                       else if (inherits(cond, "warning")) {
[10:31:22.308]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.308]                         if (muffled) 
[10:31:22.308]                           invokeRestart("muffleWarning")
[10:31:22.308]                       }
[10:31:22.308]                       else if (inherits(cond, "condition")) {
[10:31:22.308]                         if (!is.null(pattern)) {
[10:31:22.308]                           computeRestarts <- base::computeRestarts
[10:31:22.308]                           grepl <- base::grepl
[10:31:22.308]                           restarts <- computeRestarts(cond)
[10:31:22.308]                           for (restart in restarts) {
[10:31:22.308]                             name <- restart$name
[10:31:22.308]                             if (is.null(name)) 
[10:31:22.308]                               next
[10:31:22.308]                             if (!grepl(pattern, name)) 
[10:31:22.308]                               next
[10:31:22.308]                             invokeRestart(restart)
[10:31:22.308]                             muffled <- TRUE
[10:31:22.308]                             break
[10:31:22.308]                           }
[10:31:22.308]                         }
[10:31:22.308]                       }
[10:31:22.308]                       invisible(muffled)
[10:31:22.308]                     }
[10:31:22.308]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.308]                   }
[10:31:22.308]                 }
[10:31:22.308]                 else {
[10:31:22.308]                   if (TRUE) {
[10:31:22.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.308]                     {
[10:31:22.308]                       inherits <- base::inherits
[10:31:22.308]                       invokeRestart <- base::invokeRestart
[10:31:22.308]                       is.null <- base::is.null
[10:31:22.308]                       muffled <- FALSE
[10:31:22.308]                       if (inherits(cond, "message")) {
[10:31:22.308]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.308]                         if (muffled) 
[10:31:22.308]                           invokeRestart("muffleMessage")
[10:31:22.308]                       }
[10:31:22.308]                       else if (inherits(cond, "warning")) {
[10:31:22.308]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.308]                         if (muffled) 
[10:31:22.308]                           invokeRestart("muffleWarning")
[10:31:22.308]                       }
[10:31:22.308]                       else if (inherits(cond, "condition")) {
[10:31:22.308]                         if (!is.null(pattern)) {
[10:31:22.308]                           computeRestarts <- base::computeRestarts
[10:31:22.308]                           grepl <- base::grepl
[10:31:22.308]                           restarts <- computeRestarts(cond)
[10:31:22.308]                           for (restart in restarts) {
[10:31:22.308]                             name <- restart$name
[10:31:22.308]                             if (is.null(name)) 
[10:31:22.308]                               next
[10:31:22.308]                             if (!grepl(pattern, name)) 
[10:31:22.308]                               next
[10:31:22.308]                             invokeRestart(restart)
[10:31:22.308]                             muffled <- TRUE
[10:31:22.308]                             break
[10:31:22.308]                           }
[10:31:22.308]                         }
[10:31:22.308]                       }
[10:31:22.308]                       invisible(muffled)
[10:31:22.308]                     }
[10:31:22.308]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.308]                   }
[10:31:22.308]                 }
[10:31:22.308]             }
[10:31:22.308]         }))
[10:31:22.308]     }, error = function(ex) {
[10:31:22.308]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.308]                 ...future.rng), started = ...future.startTime, 
[10:31:22.308]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.308]             version = "1.8"), class = "FutureResult")
[10:31:22.308]     }, finally = {
[10:31:22.308]         if (!identical(...future.workdir, getwd())) 
[10:31:22.308]             setwd(...future.workdir)
[10:31:22.308]         {
[10:31:22.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.308]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.308]             }
[10:31:22.308]             base::options(...future.oldOptions)
[10:31:22.308]             if (.Platform$OS.type == "windows") {
[10:31:22.308]                 old_names <- names(...future.oldEnvVars)
[10:31:22.308]                 envs <- base::Sys.getenv()
[10:31:22.308]                 names <- names(envs)
[10:31:22.308]                 common <- intersect(names, old_names)
[10:31:22.308]                 added <- setdiff(names, old_names)
[10:31:22.308]                 removed <- setdiff(old_names, names)
[10:31:22.308]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.308]                   envs[common]]
[10:31:22.308]                 NAMES <- toupper(changed)
[10:31:22.308]                 args <- list()
[10:31:22.308]                 for (kk in seq_along(NAMES)) {
[10:31:22.308]                   name <- changed[[kk]]
[10:31:22.308]                   NAME <- NAMES[[kk]]
[10:31:22.308]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.308]                     next
[10:31:22.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.308]                 }
[10:31:22.308]                 NAMES <- toupper(added)
[10:31:22.308]                 for (kk in seq_along(NAMES)) {
[10:31:22.308]                   name <- added[[kk]]
[10:31:22.308]                   NAME <- NAMES[[kk]]
[10:31:22.308]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.308]                     next
[10:31:22.308]                   args[[name]] <- ""
[10:31:22.308]                 }
[10:31:22.308]                 NAMES <- toupper(removed)
[10:31:22.308]                 for (kk in seq_along(NAMES)) {
[10:31:22.308]                   name <- removed[[kk]]
[10:31:22.308]                   NAME <- NAMES[[kk]]
[10:31:22.308]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.308]                     next
[10:31:22.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.308]                 }
[10:31:22.308]                 if (length(args) > 0) 
[10:31:22.308]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.308]             }
[10:31:22.308]             else {
[10:31:22.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.308]             }
[10:31:22.308]             {
[10:31:22.308]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.308]                   0L) {
[10:31:22.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.308]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.308]                   base::options(opts)
[10:31:22.308]                 }
[10:31:22.308]                 {
[10:31:22.308]                   {
[10:31:22.308]                     NULL
[10:31:22.308]                     RNGkind("Mersenne-Twister")
[10:31:22.308]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:22.308]                       inherits = FALSE)
[10:31:22.308]                   }
[10:31:22.308]                   options(future.plan = NULL)
[10:31:22.308]                   if (is.na(NA_character_)) 
[10:31:22.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.308]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.308]                     .init = FALSE)
[10:31:22.308]                 }
[10:31:22.308]             }
[10:31:22.308]         }
[10:31:22.308]     })
[10:31:22.308]     if (TRUE) {
[10:31:22.308]         base::sink(type = "output", split = FALSE)
[10:31:22.308]         if (TRUE) {
[10:31:22.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.308]         }
[10:31:22.308]         else {
[10:31:22.308]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.308]         }
[10:31:22.308]         base::close(...future.stdout)
[10:31:22.308]         ...future.stdout <- NULL
[10:31:22.308]     }
[10:31:22.308]     ...future.result$conditions <- ...future.conditions
[10:31:22.308]     ...future.result$finished <- base::Sys.time()
[10:31:22.308]     ...future.result
[10:31:22.308] }
[10:31:22.309] assign_globals() ...
[10:31:22.310] List of 11
[10:31:22.310]  $ ...future.FUN            :function (x, ...)  
[10:31:22.310]  $ x_FUN                    :function (x)  
[10:31:22.310]  $ times                    : int 1
[10:31:22.310]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.310]  $ stop_if_not              :function (...)  
[10:31:22.310]  $ dim                      : NULL
[10:31:22.310]  $ valid_types              : chr [1:2] "logical" "integer"
[10:31:22.310]  $ future.call.arguments    : list()
[10:31:22.310]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.310]  $ ...future.elements_ii    :List of 3
[10:31:22.310]   ..$ a: num 1
[10:31:22.310]   ..$ b: num 2
[10:31:22.310]   ..$ c: num 3
[10:31:22.310]  $ ...future.seeds_ii       : NULL
[10:31:22.310]  $ ...future.globals.maxSize: NULL
[10:31:22.310]  - attr(*, "where")=List of 11
[10:31:22.310]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.310]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.310]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.310]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.310]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.310]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.310]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.310]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.310]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.310]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.310]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.310]  - attr(*, "resolved")= logi FALSE
[10:31:22.310]  - attr(*, "total_size")= num 94264
[10:31:22.310]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.310]  - attr(*, "already-done")= logi TRUE
[10:31:22.318] - copied ‘...future.FUN’ to environment
[10:31:22.318] - copied ‘x_FUN’ to environment
[10:31:22.318] - copied ‘times’ to environment
[10:31:22.318] - copied ‘stopf’ to environment
[10:31:22.318] - copied ‘stop_if_not’ to environment
[10:31:22.318] - copied ‘dim’ to environment
[10:31:22.318] - copied ‘valid_types’ to environment
[10:31:22.318] - copied ‘future.call.arguments’ to environment
[10:31:22.319] - copied ‘...future.elements_ii’ to environment
[10:31:22.319] - copied ‘...future.seeds_ii’ to environment
[10:31:22.319] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.319] assign_globals() ... done
[10:31:22.319] plan(): Setting new future strategy stack:
[10:31:22.319] List of future strategies:
[10:31:22.319] 1. sequential:
[10:31:22.319]    - args: function (..., envir = parent.frame())
[10:31:22.319]    - tweaked: FALSE
[10:31:22.319]    - call: NULL
[10:31:22.320] plan(): nbrOfWorkers() = 1
[10:31:22.320] plan(): Setting new future strategy stack:
[10:31:22.321] List of future strategies:
[10:31:22.321] 1. sequential:
[10:31:22.321]    - args: function (..., envir = parent.frame())
[10:31:22.321]    - tweaked: FALSE
[10:31:22.321]    - call: plan(strategy)
[10:31:22.321] plan(): nbrOfWorkers() = 1
[10:31:22.321] SequentialFuture started (and completed)
[10:31:22.321] - Launch lazy future ... done
[10:31:22.321] run() for ‘SequentialFuture’ ... done
[10:31:22.321] Created future:
[10:31:22.322] SequentialFuture:
[10:31:22.322] Label: ‘future_vapply-1’
[10:31:22.322] Expression:
[10:31:22.322] {
[10:31:22.322]     do.call(function(...) {
[10:31:22.322]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.322]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.322]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.322]             on.exit(options(oopts), add = TRUE)
[10:31:22.322]         }
[10:31:22.322]         {
[10:31:22.322]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.322]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.322]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.322]             })
[10:31:22.322]         }
[10:31:22.322]     }, args = future.call.arguments)
[10:31:22.322] }
[10:31:22.322] Lazy evaluation: FALSE
[10:31:22.322] Asynchronous evaluation: FALSE
[10:31:22.322] Local evaluation: TRUE
[10:31:22.322] Environment: R_GlobalEnv
[10:31:22.322] Capture standard output: TRUE
[10:31:22.322] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.322] Globals: 11 objects totaling 92.22 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.322] Packages: 1 packages (‘future.apply’)
[10:31:22.322] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.322] Resolved: TRUE
[10:31:22.322] Value: 168 bytes of class ‘list’
[10:31:22.322] Early signaling: FALSE
[10:31:22.322] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.322] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.323] Chunk #1 of 1 ... DONE
[10:31:22.323] Launching 1 futures (chunks) ... DONE
[10:31:22.323] Resolving 1 futures (chunks) ...
[10:31:22.323] resolve() on list ...
[10:31:22.323]  recursive: 0
[10:31:22.323]  length: 1
[10:31:22.323] 
[10:31:22.323] resolved() for ‘SequentialFuture’ ...
[10:31:22.323] - state: ‘finished’
[10:31:22.324] - run: TRUE
[10:31:22.324] - result: ‘FutureResult’
[10:31:22.324] resolved() for ‘SequentialFuture’ ... done
[10:31:22.324] Future #1
[10:31:22.324] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:22.324] - nx: 1
[10:31:22.324] - relay: TRUE
[10:31:22.324] - stdout: TRUE
[10:31:22.324] - signal: TRUE
[10:31:22.324] - resignal: FALSE
[10:31:22.325] - force: TRUE
[10:31:22.325] - relayed: [n=1] FALSE
[10:31:22.325] - queued futures: [n=1] FALSE
[10:31:22.325]  - until=1
[10:31:22.325]  - relaying element #1
[10:31:22.325] - relayed: [n=1] TRUE
[10:31:22.325] - queued futures: [n=1] TRUE
[10:31:22.325] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:22.325]  length: 0 (resolved future 1)
[10:31:22.325] Relaying remaining futures
[10:31:22.326] signalConditionsASAP(NULL, pos=0) ...
[10:31:22.326] - nx: 1
[10:31:22.326] - relay: TRUE
[10:31:22.326] - stdout: TRUE
[10:31:22.326] - signal: TRUE
[10:31:22.326] - resignal: FALSE
[10:31:22.326] - force: TRUE
[10:31:22.326] - relayed: [n=1] TRUE
[10:31:22.326] - queued futures: [n=1] TRUE
 - flush all
[10:31:22.326] - relayed: [n=1] TRUE
[10:31:22.326] - queued futures: [n=1] TRUE
[10:31:22.327] signalConditionsASAP(NULL, pos=0) ... done
[10:31:22.327] resolve() on list ... DONE
[10:31:22.327]  - Number of value chunks collected: 1
[10:31:22.327] Resolving 1 futures (chunks) ... DONE
[10:31:22.327] Reducing values from 1 chunks ...
[10:31:22.327]  - Number of values collected after concatenation: 3
[10:31:22.327]  - Number of values expected: 3
[10:31:22.327] Reducing values from 1 chunks ... DONE
[10:31:22.329] future_lapply() ... DONE
- exceptions ...
[10:31:22.329] future_lapply() ...
[10:31:22.331] Number of chunks: 1
[10:31:22.332] getGlobalsAndPackagesXApply() ...
[10:31:22.332]  - future.globals: TRUE
[10:31:22.332] getGlobalsAndPackages() ...
[10:31:22.332] Searching for globals...
[10:31:22.335] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:22.335] Searching for globals ... DONE
[10:31:22.336] Resolving globals: FALSE
[10:31:22.336] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[10:31:22.337] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:22.337] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.337] - packages: [1] ‘future.apply’
[10:31:22.337] getGlobalsAndPackages() ... DONE
[10:31:22.337]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.337]  - needed namespaces: [n=1] ‘future.apply’
[10:31:22.337] Finding globals ... DONE
[10:31:22.338]  - use_args: TRUE
[10:31:22.338]  - Getting '...' globals ...
[10:31:22.338] resolve() on list ...
[10:31:22.338]  recursive: 0
[10:31:22.338]  length: 1
[10:31:22.338]  elements: ‘...’
[10:31:22.338]  length: 0 (resolved future 1)
[10:31:22.339] resolve() on list ... DONE
[10:31:22.339]    - '...' content: [n=0] 
[10:31:22.339] List of 1
[10:31:22.339]  $ ...: list()
[10:31:22.339]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.339]  - attr(*, "where")=List of 1
[10:31:22.339]   ..$ ...:<environment: 0x55de83c85928> 
[10:31:22.339]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.339]  - attr(*, "resolved")= logi TRUE
[10:31:22.339]  - attr(*, "total_size")= num NA
[10:31:22.341]  - Getting '...' globals ... DONE
[10:31:22.341] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:22.342] List of 8
[10:31:22.342]  $ ...future.FUN:function (x, ...)  
[10:31:22.342]  $ x_FUN        :function (x)  
[10:31:22.342]  $ times        : int 2
[10:31:22.342]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.342]  $ stop_if_not  :function (...)  
[10:31:22.342]  $ dim          : NULL
[10:31:22.342]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:22.342]  $ ...          : list()
[10:31:22.342]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.342]  - attr(*, "where")=List of 8
[10:31:22.342]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:22.342]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:22.342]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:22.342]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:22.342]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:22.342]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:22.342]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:22.342]   ..$ ...          :<environment: 0x55de83c85928> 
[10:31:22.342]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.342]  - attr(*, "resolved")= logi FALSE
[10:31:22.342]  - attr(*, "total_size")= num 95128
[10:31:22.347] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:22.347] getGlobalsAndPackagesXApply() ... DONE
[10:31:22.347] Number of futures (= number of chunks): 1
[10:31:22.347] Launching 1 futures (chunks) ...
[10:31:22.347] Chunk #1 of 1 ...
[10:31:22.347]  - Finding globals in 'X' for chunk #1 ...
[10:31:22.348] getGlobalsAndPackages() ...
[10:31:22.348] Searching for globals...
[10:31:22.349] 
[10:31:22.350] Searching for globals ... DONE
[10:31:22.350] - globals: [0] <none>
[10:31:22.350] getGlobalsAndPackages() ... DONE
[10:31:22.350]    + additional globals found: [n=0] 
[10:31:22.350]    + additional namespaces needed: [n=0] 
[10:31:22.350]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:22.350]  - seeds: <none>
[10:31:22.350]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.350] getGlobalsAndPackages() ...
[10:31:22.350] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.351] Resolving globals: FALSE
[10:31:22.351] Tweak future expression to call with '...' arguments ...
[10:31:22.351] {
[10:31:22.351]     do.call(function(...) {
[10:31:22.351]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.351]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.351]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.351]             on.exit(options(oopts), add = TRUE)
[10:31:22.351]         }
[10:31:22.351]         {
[10:31:22.351]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.351]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.351]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.351]             })
[10:31:22.351]         }
[10:31:22.351]     }, args = future.call.arguments)
[10:31:22.351] }
[10:31:22.351] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.352] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.352] - packages: [1] ‘future.apply’
[10:31:22.352] getGlobalsAndPackages() ... DONE
[10:31:22.352] run() for ‘Future’ ...
[10:31:22.352] - state: ‘created’
[10:31:22.352] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:31:22.353] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.353] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:31:22.353]   - Field: ‘label’
[10:31:22.353]   - Field: ‘local’
[10:31:22.353]   - Field: ‘owner’
[10:31:22.353]   - Field: ‘envir’
[10:31:22.353]   - Field: ‘packages’
[10:31:22.353]   - Field: ‘gc’
[10:31:22.354]   - Field: ‘conditions’
[10:31:22.354]   - Field: ‘expr’
[10:31:22.354]   - Field: ‘uuid’
[10:31:22.354]   - Field: ‘seed’
[10:31:22.354]   - Field: ‘version’
[10:31:22.354]   - Field: ‘result’
[10:31:22.354]   - Field: ‘asynchronous’
[10:31:22.354]   - Field: ‘calls’
[10:31:22.354]   - Field: ‘globals’
[10:31:22.354]   - Field: ‘stdout’
[10:31:22.354]   - Field: ‘earlySignal’
[10:31:22.355]   - Field: ‘lazy’
[10:31:22.355]   - Field: ‘state’
[10:31:22.355] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:31:22.355] - Launch lazy future ...
[10:31:22.355] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.355] Packages needed by future strategies (n = 0): <none>
[10:31:22.356] {
[10:31:22.356]     {
[10:31:22.356]         {
[10:31:22.356]             ...future.startTime <- base::Sys.time()
[10:31:22.356]             {
[10:31:22.356]                 {
[10:31:22.356]                   {
[10:31:22.356]                     {
[10:31:22.356]                       base::local({
[10:31:22.356]                         has_future <- base::requireNamespace("future", 
[10:31:22.356]                           quietly = TRUE)
[10:31:22.356]                         if (has_future) {
[10:31:22.356]                           ns <- base::getNamespace("future")
[10:31:22.356]                           version <- ns[[".package"]][["version"]]
[10:31:22.356]                           if (is.null(version)) 
[10:31:22.356]                             version <- utils::packageVersion("future")
[10:31:22.356]                         }
[10:31:22.356]                         else {
[10:31:22.356]                           version <- NULL
[10:31:22.356]                         }
[10:31:22.356]                         if (!has_future || version < "1.8.0") {
[10:31:22.356]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.356]                             "", base::R.version$version.string), 
[10:31:22.356]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:22.356]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:22.356]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.356]                               "release", "version")], collapse = " "), 
[10:31:22.356]                             hostname = base::Sys.info()[["nodename"]])
[10:31:22.356]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.356]                             info)
[10:31:22.356]                           info <- base::paste(info, collapse = "; ")
[10:31:22.356]                           if (!has_future) {
[10:31:22.356]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.356]                               info)
[10:31:22.356]                           }
[10:31:22.356]                           else {
[10:31:22.356]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.356]                               info, version)
[10:31:22.356]                           }
[10:31:22.356]                           base::stop(msg)
[10:31:22.356]                         }
[10:31:22.356]                       })
[10:31:22.356]                     }
[10:31:22.356]                     base::local({
[10:31:22.356]                       for (pkg in "future.apply") {
[10:31:22.356]                         base::loadNamespace(pkg)
[10:31:22.356]                         base::library(pkg, character.only = TRUE)
[10:31:22.356]                       }
[10:31:22.356]                     })
[10:31:22.356]                   }
[10:31:22.356]                   ...future.strategy.old <- future::plan("list")
[10:31:22.356]                   options(future.plan = NULL)
[10:31:22.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.356]                 }
[10:31:22.356]                 ...future.workdir <- getwd()
[10:31:22.356]             }
[10:31:22.356]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.356]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.356]         }
[10:31:22.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.356]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:22.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.356]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.356]             base::names(...future.oldOptions))
[10:31:22.356]     }
[10:31:22.356]     if (FALSE) {
[10:31:22.356]     }
[10:31:22.356]     else {
[10:31:22.356]         if (TRUE) {
[10:31:22.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.356]                 open = "w")
[10:31:22.356]         }
[10:31:22.356]         else {
[10:31:22.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.356]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.356]         }
[10:31:22.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.356]             base::sink(type = "output", split = FALSE)
[10:31:22.356]             base::close(...future.stdout)
[10:31:22.356]         }, add = TRUE)
[10:31:22.356]     }
[10:31:22.356]     ...future.frame <- base::sys.nframe()
[10:31:22.356]     ...future.conditions <- base::list()
[10:31:22.356]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.356]     if (FALSE) {
[10:31:22.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.356]     }
[10:31:22.356]     ...future.result <- base::tryCatch({
[10:31:22.356]         base::withCallingHandlers({
[10:31:22.356]             ...future.value <- base::withVisible(base::local({
[10:31:22.356]                 do.call(function(...) {
[10:31:22.356]                   ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.356]                   if (!identical(...future.globals.maxSize.org, 
[10:31:22.356]                     ...future.globals.maxSize)) {
[10:31:22.356]                     oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.356]                     on.exit(options(oopts), add = TRUE)
[10:31:22.356]                   }
[10:31:22.356]                   {
[10:31:22.356]                     lapply(seq_along(...future.elements_ii), 
[10:31:22.356]                       FUN = function(jj) {
[10:31:22.356]                         ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.356]                         ...future.FUN(...future.X_jj, ...)
[10:31:22.356]                       })
[10:31:22.356]                   }
[10:31:22.356]                 }, args = future.call.arguments)
[10:31:22.356]             }))
[10:31:22.356]             future::FutureResult(value = ...future.value$value, 
[10:31:22.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.356]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.356]                     ...future.globalenv.names))
[10:31:22.356]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.356]         }, condition = base::local({
[10:31:22.356]             c <- base::c
[10:31:22.356]             inherits <- base::inherits
[10:31:22.356]             invokeRestart <- base::invokeRestart
[10:31:22.356]             length <- base::length
[10:31:22.356]             list <- base::list
[10:31:22.356]             seq.int <- base::seq.int
[10:31:22.356]             signalCondition <- base::signalCondition
[10:31:22.356]             sys.calls <- base::sys.calls
[10:31:22.356]             `[[` <- base::`[[`
[10:31:22.356]             `+` <- base::`+`
[10:31:22.356]             `<<-` <- base::`<<-`
[10:31:22.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.356]                   3L)]
[10:31:22.356]             }
[10:31:22.356]             function(cond) {
[10:31:22.356]                 is_error <- inherits(cond, "error")
[10:31:22.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.356]                   NULL)
[10:31:22.356]                 if (is_error) {
[10:31:22.356]                   sessionInformation <- function() {
[10:31:22.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.356]                       search = base::search(), system = base::Sys.info())
[10:31:22.356]                   }
[10:31:22.356]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.356]                     cond$call), session = sessionInformation(), 
[10:31:22.356]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.356]                   signalCondition(cond)
[10:31:22.356]                 }
[10:31:22.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.356]                 "immediateCondition"))) {
[10:31:22.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.356]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.356]                   if (TRUE && !signal) {
[10:31:22.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.356]                     {
[10:31:22.356]                       inherits <- base::inherits
[10:31:22.356]                       invokeRestart <- base::invokeRestart
[10:31:22.356]                       is.null <- base::is.null
[10:31:22.356]                       muffled <- FALSE
[10:31:22.356]                       if (inherits(cond, "message")) {
[10:31:22.356]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.356]                         if (muffled) 
[10:31:22.356]                           invokeRestart("muffleMessage")
[10:31:22.356]                       }
[10:31:22.356]                       else if (inherits(cond, "warning")) {
[10:31:22.356]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.356]                         if (muffled) 
[10:31:22.356]                           invokeRestart("muffleWarning")
[10:31:22.356]                       }
[10:31:22.356]                       else if (inherits(cond, "condition")) {
[10:31:22.356]                         if (!is.null(pattern)) {
[10:31:22.356]                           computeRestarts <- base::computeRestarts
[10:31:22.356]                           grepl <- base::grepl
[10:31:22.356]                           restarts <- computeRestarts(cond)
[10:31:22.356]                           for (restart in restarts) {
[10:31:22.356]                             name <- restart$name
[10:31:22.356]                             if (is.null(name)) 
[10:31:22.356]                               next
[10:31:22.356]                             if (!grepl(pattern, name)) 
[10:31:22.356]                               next
[10:31:22.356]                             invokeRestart(restart)
[10:31:22.356]                             muffled <- TRUE
[10:31:22.356]                             break
[10:31:22.356]                           }
[10:31:22.356]                         }
[10:31:22.356]                       }
[10:31:22.356]                       invisible(muffled)
[10:31:22.356]                     }
[10:31:22.356]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.356]                   }
[10:31:22.356]                 }
[10:31:22.356]                 else {
[10:31:22.356]                   if (TRUE) {
[10:31:22.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.356]                     {
[10:31:22.356]                       inherits <- base::inherits
[10:31:22.356]                       invokeRestart <- base::invokeRestart
[10:31:22.356]                       is.null <- base::is.null
[10:31:22.356]                       muffled <- FALSE
[10:31:22.356]                       if (inherits(cond, "message")) {
[10:31:22.356]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.356]                         if (muffled) 
[10:31:22.356]                           invokeRestart("muffleMessage")
[10:31:22.356]                       }
[10:31:22.356]                       else if (inherits(cond, "warning")) {
[10:31:22.356]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.356]                         if (muffled) 
[10:31:22.356]                           invokeRestart("muffleWarning")
[10:31:22.356]                       }
[10:31:22.356]                       else if (inherits(cond, "condition")) {
[10:31:22.356]                         if (!is.null(pattern)) {
[10:31:22.356]                           computeRestarts <- base::computeRestarts
[10:31:22.356]                           grepl <- base::grepl
[10:31:22.356]                           restarts <- computeRestarts(cond)
[10:31:22.356]                           for (restart in restarts) {
[10:31:22.356]                             name <- restart$name
[10:31:22.356]                             if (is.null(name)) 
[10:31:22.356]                               next
[10:31:22.356]                             if (!grepl(pattern, name)) 
[10:31:22.356]                               next
[10:31:22.356]                             invokeRestart(restart)
[10:31:22.356]                             muffled <- TRUE
[10:31:22.356]                             break
[10:31:22.356]                           }
[10:31:22.356]                         }
[10:31:22.356]                       }
[10:31:22.356]                       invisible(muffled)
[10:31:22.356]                     }
[10:31:22.356]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.356]                   }
[10:31:22.356]                 }
[10:31:22.356]             }
[10:31:22.356]         }))
[10:31:22.356]     }, error = function(ex) {
[10:31:22.356]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.356]                 ...future.rng), started = ...future.startTime, 
[10:31:22.356]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.356]             version = "1.8"), class = "FutureResult")
[10:31:22.356]     }, finally = {
[10:31:22.356]         if (!identical(...future.workdir, getwd())) 
[10:31:22.356]             setwd(...future.workdir)
[10:31:22.356]         {
[10:31:22.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.356]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.356]             }
[10:31:22.356]             base::options(...future.oldOptions)
[10:31:22.356]             if (.Platform$OS.type == "windows") {
[10:31:22.356]                 old_names <- names(...future.oldEnvVars)
[10:31:22.356]                 envs <- base::Sys.getenv()
[10:31:22.356]                 names <- names(envs)
[10:31:22.356]                 common <- intersect(names, old_names)
[10:31:22.356]                 added <- setdiff(names, old_names)
[10:31:22.356]                 removed <- setdiff(old_names, names)
[10:31:22.356]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.356]                   envs[common]]
[10:31:22.356]                 NAMES <- toupper(changed)
[10:31:22.356]                 args <- list()
[10:31:22.356]                 for (kk in seq_along(NAMES)) {
[10:31:22.356]                   name <- changed[[kk]]
[10:31:22.356]                   NAME <- NAMES[[kk]]
[10:31:22.356]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.356]                     next
[10:31:22.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.356]                 }
[10:31:22.356]                 NAMES <- toupper(added)
[10:31:22.356]                 for (kk in seq_along(NAMES)) {
[10:31:22.356]                   name <- added[[kk]]
[10:31:22.356]                   NAME <- NAMES[[kk]]
[10:31:22.356]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.356]                     next
[10:31:22.356]                   args[[name]] <- ""
[10:31:22.356]                 }
[10:31:22.356]                 NAMES <- toupper(removed)
[10:31:22.356]                 for (kk in seq_along(NAMES)) {
[10:31:22.356]                   name <- removed[[kk]]
[10:31:22.356]                   NAME <- NAMES[[kk]]
[10:31:22.356]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.356]                     next
[10:31:22.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.356]                 }
[10:31:22.356]                 if (length(args) > 0) 
[10:31:22.356]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.356]             }
[10:31:22.356]             else {
[10:31:22.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.356]             }
[10:31:22.356]             {
[10:31:22.356]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.356]                   0L) {
[10:31:22.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.356]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.356]                   base::options(opts)
[10:31:22.356]                 }
[10:31:22.356]                 {
[10:31:22.356]                   {
[10:31:22.356]                     NULL
[10:31:22.356]                     RNGkind("Mersenne-Twister")
[10:31:22.356]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:31:22.356]                       inherits = FALSE)
[10:31:22.356]                   }
[10:31:22.356]                   options(future.plan = NULL)
[10:31:22.356]                   if (is.na(NA_character_)) 
[10:31:22.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.356]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.356]                     .init = FALSE)
[10:31:22.356]                 }
[10:31:22.356]             }
[10:31:22.356]         }
[10:31:22.356]     })
[10:31:22.356]     if (TRUE) {
[10:31:22.356]         base::sink(type = "output", split = FALSE)
[10:31:22.356]         if (TRUE) {
[10:31:22.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.356]         }
[10:31:22.356]         else {
[10:31:22.356]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.356]         }
[10:31:22.356]         base::close(...future.stdout)
[10:31:22.356]         ...future.stdout <- NULL
[10:31:22.356]     }
[10:31:22.356]     ...future.result$conditions <- ...future.conditions
[10:31:22.356]     ...future.result$finished <- base::Sys.time()
[10:31:22.356]     ...future.result
[10:31:22.356] }
[10:31:22.357] assign_globals() ...
[10:31:22.357] List of 11
[10:31:22.357]  $ ...future.FUN            :function (x, ...)  
[10:31:22.357]  $ x_FUN                    :function (x)  
[10:31:22.357]  $ times                    : int 2
[10:31:22.357]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.357]  $ stop_if_not              :function (...)  
[10:31:22.357]  $ dim                      : NULL
[10:31:22.357]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:22.357]  $ future.call.arguments    : list()
[10:31:22.357]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.357]  $ ...future.elements_ii    :List of 3
[10:31:22.357]   ..$ : int 1
[10:31:22.357]   ..$ : int 2
[10:31:22.357]   ..$ : int 3
[10:31:22.357]  $ ...future.seeds_ii       : NULL
[10:31:22.357]  $ ...future.globals.maxSize: NULL
[10:31:22.357]  - attr(*, "where")=List of 11
[10:31:22.357]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.357]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.357]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.357]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.357]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.357]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.357]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.357]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.357]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.357]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.357]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.357]  - attr(*, "resolved")= logi FALSE
[10:31:22.357]  - attr(*, "total_size")= num 95128
[10:31:22.357]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.357]  - attr(*, "already-done")= logi TRUE
[10:31:22.365] - copied ‘...future.FUN’ to environment
[10:31:22.365] - copied ‘x_FUN’ to environment
[10:31:22.366] - copied ‘times’ to environment
[10:31:22.366] - copied ‘stopf’ to environment
[10:31:22.366] - copied ‘stop_if_not’ to environment
[10:31:22.366] - copied ‘dim’ to environment
[10:31:22.366] - copied ‘valid_types’ to environment
[10:31:22.366] - copied ‘future.call.arguments’ to environment
[10:31:22.366] - copied ‘...future.elements_ii’ to environment
[10:31:22.366] - copied ‘...future.seeds_ii’ to environment
[10:31:22.366] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.366] assign_globals() ... done
[10:31:22.367] plan(): Setting new future strategy stack:
[10:31:22.367] List of future strategies:
[10:31:22.367] 1. sequential:
[10:31:22.367]    - args: function (..., envir = parent.frame())
[10:31:22.367]    - tweaked: FALSE
[10:31:22.367]    - call: NULL
[10:31:22.367] plan(): nbrOfWorkers() = 1
[10:31:22.368] plan(): Setting new future strategy stack:
[10:31:22.368] List of future strategies:
[10:31:22.368] 1. sequential:
[10:31:22.368]    - args: function (..., envir = parent.frame())
[10:31:22.368]    - tweaked: FALSE
[10:31:22.368]    - call: plan(strategy)
[10:31:22.369] plan(): nbrOfWorkers() = 1
[10:31:22.369] SequentialFuture started (and completed)
[10:31:22.369] signalConditions() ...
[10:31:22.369]  - include = ‘immediateCondition’
[10:31:22.369]  - exclude = 
[10:31:22.369]  - resignal = FALSE
[10:31:22.370]  - Number of conditions: 1
[10:31:22.370] signalConditions() ... done
[10:31:22.370] - Launch lazy future ... done
[10:31:22.370] run() for ‘SequentialFuture’ ... done
[10:31:22.370] Created future:
[10:31:22.370] SequentialFuture:
[10:31:22.370] Label: ‘future_vapply-1’
[10:31:22.370] Expression:
[10:31:22.370] {
[10:31:22.370]     do.call(function(...) {
[10:31:22.370]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.370]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.370]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.370]             on.exit(options(oopts), add = TRUE)
[10:31:22.370]         }
[10:31:22.370]         {
[10:31:22.370]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.370]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.370]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.370]             })
[10:31:22.370]         }
[10:31:22.370]     }, args = future.call.arguments)
[10:31:22.370] }
[10:31:22.370] Lazy evaluation: FALSE
[10:31:22.370] Asynchronous evaluation: FALSE
[10:31:22.370] Local evaluation: TRUE
[10:31:22.370] Environment: R_GlobalEnv
[10:31:22.370] Capture standard output: TRUE
[10:31:22.370] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.370] Globals: 11 objects totaling 93.06 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.370] Packages: 1 packages (‘future.apply’)
[10:31:22.370] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.370] Resolved: TRUE
[10:31:22.370] Value: 0 bytes of class ‘NULL’
[10:31:22.370] Conditions captured: [n=1] ‘simpleError’
[10:31:22.370] Early signaling: FALSE
[10:31:22.370] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.370] Class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:31:22.373] Chunk #1 of 1 ... DONE
[10:31:22.373] Launching 1 futures (chunks) ... DONE
[10:31:22.373] Resolving 1 futures (chunks) ...
[10:31:22.373] resolve() on list ...
[10:31:22.374]  recursive: 0
[10:31:22.374]  length: 1
[10:31:22.374] 
[10:31:22.374] resolved() for ‘SequentialFuture’ ...
[10:31:22.374] - state: ‘finished’
[10:31:22.374] - run: TRUE
[10:31:22.374] - result: ‘FutureResult’
[10:31:22.374] resolved() for ‘SequentialFuture’ ... done
[10:31:22.374] Future #1
[10:31:22.375] signalConditions() ...
[10:31:22.375]  - include = ‘immediateCondition’
[10:31:22.375]  - exclude = 
[10:31:22.375]  - resignal = FALSE
[10:31:22.375]  - Number of conditions: 1
[10:31:22.375] signalConditions() ... done
[10:31:22.375] signalConditionsASAP(SequentialFuture, pos=1) ...
[10:31:22.375] - nx: 1
[10:31:22.375] - relay: TRUE
[10:31:22.375] - stdout: TRUE
[10:31:22.376] - signal: TRUE
[10:31:22.376] - resignal: FALSE
[10:31:22.376] - force: TRUE
[10:31:22.376] - relayed: [n=1] FALSE
[10:31:22.376] - queued futures: [n=1] FALSE
[10:31:22.376]  - until=1
[10:31:22.376]  - relaying element #1
[10:31:22.376] signalConditions() ...
[10:31:22.376]  - include = ‘immediateCondition’
[10:31:22.376]  - exclude = 
[10:31:22.376]  - resignal = FALSE
[10:31:22.377]  - Number of conditions: 1
[10:31:22.377] signalConditions() ... done
[10:31:22.377] signalConditions() ...
[10:31:22.377]  - include = ‘immediateCondition’
[10:31:22.377]  - exclude = 
[10:31:22.377]  - resignal = FALSE
[10:31:22.377]  - Number of conditions: 1
[10:31:22.377] signalConditions() ... done
[10:31:22.377] signalConditions() ...
[10:31:22.377]  - include = ‘condition’
[10:31:22.378]  - exclude = ‘immediateCondition’
[10:31:22.378]  - resignal = TRUE
[10:31:22.378]  - Number of conditions: 1
[10:31:22.378]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:31:22.378] signalConditions() ... done
[10:31:22.378] - relayed: [n=1] FALSE
[10:31:22.378] - queued futures: [n=1] TRUE
[10:31:22.378] signalConditionsASAP(SequentialFuture, pos=1) ... done
[10:31:22.378] plan(): Setting new future strategy stack:
[10:31:22.378] List of future strategies:
[10:31:22.378] 1. sequential:
[10:31:22.378]    - args: function (..., envir = parent.frame())
[10:31:22.378]    - tweaked: FALSE
[10:31:22.378]    - call: plan(sequential)
[10:31:22.379] plan(): nbrOfWorkers() = 1
*** strategy = ‘sequential’ ... done
*** strategy = ‘multicore’ ...
[10:31:22.379] plan(): Setting new future strategy stack:
[10:31:22.379] List of future strategies:
[10:31:22.379] 1. multicore:
[10:31:22.379]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:22.379]    - tweaked: FALSE
[10:31:22.379]    - call: plan(strategy)
[10:31:22.383] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[10:31:22.386] future_lapply() ...
[10:31:22.391] Number of chunks: 2
[10:31:22.391] getGlobalsAndPackagesXApply() ...
[10:31:22.391]  - future.globals: TRUE
[10:31:22.392] getGlobalsAndPackages() ...
[10:31:22.392] Searching for globals...
[10:31:22.395] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:22.395] Searching for globals ... DONE
[10:31:22.395] Resolving globals: FALSE
[10:31:22.396] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[10:31:22.396] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:22.396] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.397] - packages: [1] ‘future.apply’
[10:31:22.397] getGlobalsAndPackages() ... DONE
[10:31:22.397]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.397]  - needed namespaces: [n=1] ‘future.apply’
[10:31:22.397] Finding globals ... DONE
[10:31:22.397]  - use_args: TRUE
[10:31:22.401]  - Getting '...' globals ...
[10:31:22.402] resolve() on list ...
[10:31:22.402]  recursive: 0
[10:31:22.402]  length: 1
[10:31:22.402]  elements: ‘...’
[10:31:22.402]  length: 0 (resolved future 1)
[10:31:22.402] resolve() on list ... DONE
[10:31:22.402]    - '...' content: [n=0] 
[10:31:22.402] List of 1
[10:31:22.402]  $ ...: list()
[10:31:22.402]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.402]  - attr(*, "where")=List of 1
[10:31:22.402]   ..$ ...:<environment: 0x55de8570e850> 
[10:31:22.402]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.402]  - attr(*, "resolved")= logi TRUE
[10:31:22.402]  - attr(*, "total_size")= num NA
[10:31:22.405]  - Getting '...' globals ... DONE
[10:31:22.406] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:22.406] List of 8
[10:31:22.406]  $ ...future.FUN:function (x, ...)  
[10:31:22.406]  $ x_FUN        :function (x)  
[10:31:22.406]  $ times        : int 1
[10:31:22.406]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.406]  $ stop_if_not  :function (...)  
[10:31:22.406]  $ dim          : NULL
[10:31:22.406]  $ valid_types  : chr "character"
[10:31:22.406]  $ ...          : list()
[10:31:22.406]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.406]  - attr(*, "where")=List of 8
[10:31:22.406]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:22.406]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:22.406]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:22.406]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:22.406]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:22.406]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:22.406]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:22.406]   ..$ ...          :<environment: 0x55de8570e850> 
[10:31:22.406]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.406]  - attr(*, "resolved")= logi FALSE
[10:31:22.406]  - attr(*, "total_size")= num 94208
[10:31:22.411] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:22.411] getGlobalsAndPackagesXApply() ... DONE
[10:31:22.412] Number of futures (= number of chunks): 2
[10:31:22.412] Launching 2 futures (chunks) ...
[10:31:22.412] Chunk #1 of 2 ...
[10:31:22.412]  - Finding globals in 'X' for chunk #1 ...
[10:31:22.412] getGlobalsAndPackages() ...
[10:31:22.412] Searching for globals...
[10:31:22.412] 
[10:31:22.412] Searching for globals ... DONE
[10:31:22.413] - globals: [0] <none>
[10:31:22.413] getGlobalsAndPackages() ... DONE
[10:31:22.413]    + additional globals found: [n=0] 
[10:31:22.413]    + additional namespaces needed: [n=0] 
[10:31:22.413]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:22.413]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:22.413]  - seeds: <none>
[10:31:22.413]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.413] getGlobalsAndPackages() ...
[10:31:22.413] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.414] Resolving globals: FALSE
[10:31:22.414] Tweak future expression to call with '...' arguments ...
[10:31:22.414] {
[10:31:22.414]     do.call(function(...) {
[10:31:22.414]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.414]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.414]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.414]             on.exit(options(oopts), add = TRUE)
[10:31:22.414]         }
[10:31:22.414]         {
[10:31:22.414]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.414]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.414]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.414]             })
[10:31:22.414]         }
[10:31:22.414]     }, args = future.call.arguments)
[10:31:22.414] }
[10:31:22.414] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.415] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.415] - packages: [1] ‘future.apply’
[10:31:22.415] getGlobalsAndPackages() ... DONE
[10:31:22.415] run() for ‘Future’ ...
[10:31:22.415] - state: ‘created’
[10:31:22.415] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:22.419] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.419] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:22.420]   - Field: ‘label’
[10:31:22.420]   - Field: ‘local’
[10:31:22.420]   - Field: ‘owner’
[10:31:22.420]   - Field: ‘envir’
[10:31:22.420]   - Field: ‘workers’
[10:31:22.420]   - Field: ‘packages’
[10:31:22.420]   - Field: ‘gc’
[10:31:22.420]   - Field: ‘job’
[10:31:22.420]   - Field: ‘conditions’
[10:31:22.420]   - Field: ‘expr’
[10:31:22.421]   - Field: ‘uuid’
[10:31:22.421]   - Field: ‘seed’
[10:31:22.421]   - Field: ‘version’
[10:31:22.421]   - Field: ‘result’
[10:31:22.421]   - Field: ‘asynchronous’
[10:31:22.421]   - Field: ‘calls’
[10:31:22.421]   - Field: ‘globals’
[10:31:22.421]   - Field: ‘stdout’
[10:31:22.421]   - Field: ‘earlySignal’
[10:31:22.421]   - Field: ‘lazy’
[10:31:22.422]   - Field: ‘state’
[10:31:22.422] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:22.422] - Launch lazy future ...
[10:31:22.423] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.423] Packages needed by future strategies (n = 0): <none>
[10:31:22.424] {
[10:31:22.424]     {
[10:31:22.424]         {
[10:31:22.424]             ...future.startTime <- base::Sys.time()
[10:31:22.424]             {
[10:31:22.424]                 {
[10:31:22.424]                   {
[10:31:22.424]                     {
[10:31:22.424]                       {
[10:31:22.424]                         base::local({
[10:31:22.424]                           has_future <- base::requireNamespace("future", 
[10:31:22.424]                             quietly = TRUE)
[10:31:22.424]                           if (has_future) {
[10:31:22.424]                             ns <- base::getNamespace("future")
[10:31:22.424]                             version <- ns[[".package"]][["version"]]
[10:31:22.424]                             if (is.null(version)) 
[10:31:22.424]                               version <- utils::packageVersion("future")
[10:31:22.424]                           }
[10:31:22.424]                           else {
[10:31:22.424]                             version <- NULL
[10:31:22.424]                           }
[10:31:22.424]                           if (!has_future || version < "1.8.0") {
[10:31:22.424]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.424]                               "", base::R.version$version.string), 
[10:31:22.424]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:22.424]                                 base::R.version$platform, 8 * 
[10:31:22.424]                                   base::.Machine$sizeof.pointer), 
[10:31:22.424]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.424]                                 "release", "version")], collapse = " "), 
[10:31:22.424]                               hostname = base::Sys.info()[["nodename"]])
[10:31:22.424]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.424]                               info)
[10:31:22.424]                             info <- base::paste(info, collapse = "; ")
[10:31:22.424]                             if (!has_future) {
[10:31:22.424]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.424]                                 info)
[10:31:22.424]                             }
[10:31:22.424]                             else {
[10:31:22.424]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.424]                                 info, version)
[10:31:22.424]                             }
[10:31:22.424]                             base::stop(msg)
[10:31:22.424]                           }
[10:31:22.424]                         })
[10:31:22.424]                       }
[10:31:22.424]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:22.424]                       base::options(mc.cores = 1L)
[10:31:22.424]                     }
[10:31:22.424]                     base::local({
[10:31:22.424]                       for (pkg in "future.apply") {
[10:31:22.424]                         base::loadNamespace(pkg)
[10:31:22.424]                         base::library(pkg, character.only = TRUE)
[10:31:22.424]                       }
[10:31:22.424]                     })
[10:31:22.424]                   }
[10:31:22.424]                   ...future.strategy.old <- future::plan("list")
[10:31:22.424]                   options(future.plan = NULL)
[10:31:22.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.424]                 }
[10:31:22.424]                 ...future.workdir <- getwd()
[10:31:22.424]             }
[10:31:22.424]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.424]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.424]         }
[10:31:22.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.424]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:22.424]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.424]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.424]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.424]             base::names(...future.oldOptions))
[10:31:22.424]     }
[10:31:22.424]     if (FALSE) {
[10:31:22.424]     }
[10:31:22.424]     else {
[10:31:22.424]         if (TRUE) {
[10:31:22.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.424]                 open = "w")
[10:31:22.424]         }
[10:31:22.424]         else {
[10:31:22.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.424]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.424]         }
[10:31:22.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.424]             base::sink(type = "output", split = FALSE)
[10:31:22.424]             base::close(...future.stdout)
[10:31:22.424]         }, add = TRUE)
[10:31:22.424]     }
[10:31:22.424]     ...future.frame <- base::sys.nframe()
[10:31:22.424]     ...future.conditions <- base::list()
[10:31:22.424]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.424]     if (FALSE) {
[10:31:22.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.424]     }
[10:31:22.424]     ...future.result <- base::tryCatch({
[10:31:22.424]         base::withCallingHandlers({
[10:31:22.424]             ...future.value <- base::withVisible(base::local({
[10:31:22.424]                 withCallingHandlers({
[10:31:22.424]                   {
[10:31:22.424]                     do.call(function(...) {
[10:31:22.424]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.424]                       if (!identical(...future.globals.maxSize.org, 
[10:31:22.424]                         ...future.globals.maxSize)) {
[10:31:22.424]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.424]                         on.exit(options(oopts), add = TRUE)
[10:31:22.424]                       }
[10:31:22.424]                       {
[10:31:22.424]                         lapply(seq_along(...future.elements_ii), 
[10:31:22.424]                           FUN = function(jj) {
[10:31:22.424]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.424]                             ...future.FUN(...future.X_jj, ...)
[10:31:22.424]                           })
[10:31:22.424]                       }
[10:31:22.424]                     }, args = future.call.arguments)
[10:31:22.424]                   }
[10:31:22.424]                 }, immediateCondition = function(cond) {
[10:31:22.424]                   save_rds <- function (object, pathname, ...) 
[10:31:22.424]                   {
[10:31:22.424]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:22.424]                     if (file_test("-f", pathname_tmp)) {
[10:31:22.424]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.424]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:22.424]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.424]                         fi_tmp[["mtime"]])
[10:31:22.424]                     }
[10:31:22.424]                     tryCatch({
[10:31:22.424]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:22.424]                     }, error = function(ex) {
[10:31:22.424]                       msg <- conditionMessage(ex)
[10:31:22.424]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.424]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:22.424]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.424]                         fi_tmp[["mtime"]], msg)
[10:31:22.424]                       ex$message <- msg
[10:31:22.424]                       stop(ex)
[10:31:22.424]                     })
[10:31:22.424]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:22.424]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:22.424]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:22.424]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.424]                       fi <- file.info(pathname)
[10:31:22.424]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:22.424]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.424]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:22.424]                         fi[["size"]], fi[["mtime"]])
[10:31:22.424]                       stop(msg)
[10:31:22.424]                     }
[10:31:22.424]                     invisible(pathname)
[10:31:22.424]                   }
[10:31:22.424]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:22.424]                     rootPath = tempdir()) 
[10:31:22.424]                   {
[10:31:22.424]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:22.424]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:22.424]                       tmpdir = path, fileext = ".rds")
[10:31:22.424]                     save_rds(obj, file)
[10:31:22.424]                   }
[10:31:22.424]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:22.424]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.424]                   {
[10:31:22.424]                     inherits <- base::inherits
[10:31:22.424]                     invokeRestart <- base::invokeRestart
[10:31:22.424]                     is.null <- base::is.null
[10:31:22.424]                     muffled <- FALSE
[10:31:22.424]                     if (inherits(cond, "message")) {
[10:31:22.424]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:22.424]                       if (muffled) 
[10:31:22.424]                         invokeRestart("muffleMessage")
[10:31:22.424]                     }
[10:31:22.424]                     else if (inherits(cond, "warning")) {
[10:31:22.424]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:22.424]                       if (muffled) 
[10:31:22.424]                         invokeRestart("muffleWarning")
[10:31:22.424]                     }
[10:31:22.424]                     else if (inherits(cond, "condition")) {
[10:31:22.424]                       if (!is.null(pattern)) {
[10:31:22.424]                         computeRestarts <- base::computeRestarts
[10:31:22.424]                         grepl <- base::grepl
[10:31:22.424]                         restarts <- computeRestarts(cond)
[10:31:22.424]                         for (restart in restarts) {
[10:31:22.424]                           name <- restart$name
[10:31:22.424]                           if (is.null(name)) 
[10:31:22.424]                             next
[10:31:22.424]                           if (!grepl(pattern, name)) 
[10:31:22.424]                             next
[10:31:22.424]                           invokeRestart(restart)
[10:31:22.424]                           muffled <- TRUE
[10:31:22.424]                           break
[10:31:22.424]                         }
[10:31:22.424]                       }
[10:31:22.424]                     }
[10:31:22.424]                     invisible(muffled)
[10:31:22.424]                   }
[10:31:22.424]                   muffleCondition(cond)
[10:31:22.424]                 })
[10:31:22.424]             }))
[10:31:22.424]             future::FutureResult(value = ...future.value$value, 
[10:31:22.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.424]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.424]                     ...future.globalenv.names))
[10:31:22.424]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.424]         }, condition = base::local({
[10:31:22.424]             c <- base::c
[10:31:22.424]             inherits <- base::inherits
[10:31:22.424]             invokeRestart <- base::invokeRestart
[10:31:22.424]             length <- base::length
[10:31:22.424]             list <- base::list
[10:31:22.424]             seq.int <- base::seq.int
[10:31:22.424]             signalCondition <- base::signalCondition
[10:31:22.424]             sys.calls <- base::sys.calls
[10:31:22.424]             `[[` <- base::`[[`
[10:31:22.424]             `+` <- base::`+`
[10:31:22.424]             `<<-` <- base::`<<-`
[10:31:22.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.424]                   3L)]
[10:31:22.424]             }
[10:31:22.424]             function(cond) {
[10:31:22.424]                 is_error <- inherits(cond, "error")
[10:31:22.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.424]                   NULL)
[10:31:22.424]                 if (is_error) {
[10:31:22.424]                   sessionInformation <- function() {
[10:31:22.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.424]                       search = base::search(), system = base::Sys.info())
[10:31:22.424]                   }
[10:31:22.424]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.424]                     cond$call), session = sessionInformation(), 
[10:31:22.424]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.424]                   signalCondition(cond)
[10:31:22.424]                 }
[10:31:22.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.424]                 "immediateCondition"))) {
[10:31:22.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.424]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.424]                   if (TRUE && !signal) {
[10:31:22.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.424]                     {
[10:31:22.424]                       inherits <- base::inherits
[10:31:22.424]                       invokeRestart <- base::invokeRestart
[10:31:22.424]                       is.null <- base::is.null
[10:31:22.424]                       muffled <- FALSE
[10:31:22.424]                       if (inherits(cond, "message")) {
[10:31:22.424]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.424]                         if (muffled) 
[10:31:22.424]                           invokeRestart("muffleMessage")
[10:31:22.424]                       }
[10:31:22.424]                       else if (inherits(cond, "warning")) {
[10:31:22.424]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.424]                         if (muffled) 
[10:31:22.424]                           invokeRestart("muffleWarning")
[10:31:22.424]                       }
[10:31:22.424]                       else if (inherits(cond, "condition")) {
[10:31:22.424]                         if (!is.null(pattern)) {
[10:31:22.424]                           computeRestarts <- base::computeRestarts
[10:31:22.424]                           grepl <- base::grepl
[10:31:22.424]                           restarts <- computeRestarts(cond)
[10:31:22.424]                           for (restart in restarts) {
[10:31:22.424]                             name <- restart$name
[10:31:22.424]                             if (is.null(name)) 
[10:31:22.424]                               next
[10:31:22.424]                             if (!grepl(pattern, name)) 
[10:31:22.424]                               next
[10:31:22.424]                             invokeRestart(restart)
[10:31:22.424]                             muffled <- TRUE
[10:31:22.424]                             break
[10:31:22.424]                           }
[10:31:22.424]                         }
[10:31:22.424]                       }
[10:31:22.424]                       invisible(muffled)
[10:31:22.424]                     }
[10:31:22.424]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.424]                   }
[10:31:22.424]                 }
[10:31:22.424]                 else {
[10:31:22.424]                   if (TRUE) {
[10:31:22.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.424]                     {
[10:31:22.424]                       inherits <- base::inherits
[10:31:22.424]                       invokeRestart <- base::invokeRestart
[10:31:22.424]                       is.null <- base::is.null
[10:31:22.424]                       muffled <- FALSE
[10:31:22.424]                       if (inherits(cond, "message")) {
[10:31:22.424]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.424]                         if (muffled) 
[10:31:22.424]                           invokeRestart("muffleMessage")
[10:31:22.424]                       }
[10:31:22.424]                       else if (inherits(cond, "warning")) {
[10:31:22.424]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.424]                         if (muffled) 
[10:31:22.424]                           invokeRestart("muffleWarning")
[10:31:22.424]                       }
[10:31:22.424]                       else if (inherits(cond, "condition")) {
[10:31:22.424]                         if (!is.null(pattern)) {
[10:31:22.424]                           computeRestarts <- base::computeRestarts
[10:31:22.424]                           grepl <- base::grepl
[10:31:22.424]                           restarts <- computeRestarts(cond)
[10:31:22.424]                           for (restart in restarts) {
[10:31:22.424]                             name <- restart$name
[10:31:22.424]                             if (is.null(name)) 
[10:31:22.424]                               next
[10:31:22.424]                             if (!grepl(pattern, name)) 
[10:31:22.424]                               next
[10:31:22.424]                             invokeRestart(restart)
[10:31:22.424]                             muffled <- TRUE
[10:31:22.424]                             break
[10:31:22.424]                           }
[10:31:22.424]                         }
[10:31:22.424]                       }
[10:31:22.424]                       invisible(muffled)
[10:31:22.424]                     }
[10:31:22.424]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.424]                   }
[10:31:22.424]                 }
[10:31:22.424]             }
[10:31:22.424]         }))
[10:31:22.424]     }, error = function(ex) {
[10:31:22.424]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.424]                 ...future.rng), started = ...future.startTime, 
[10:31:22.424]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.424]             version = "1.8"), class = "FutureResult")
[10:31:22.424]     }, finally = {
[10:31:22.424]         if (!identical(...future.workdir, getwd())) 
[10:31:22.424]             setwd(...future.workdir)
[10:31:22.424]         {
[10:31:22.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.424]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.424]             }
[10:31:22.424]             base::options(...future.oldOptions)
[10:31:22.424]             if (.Platform$OS.type == "windows") {
[10:31:22.424]                 old_names <- names(...future.oldEnvVars)
[10:31:22.424]                 envs <- base::Sys.getenv()
[10:31:22.424]                 names <- names(envs)
[10:31:22.424]                 common <- intersect(names, old_names)
[10:31:22.424]                 added <- setdiff(names, old_names)
[10:31:22.424]                 removed <- setdiff(old_names, names)
[10:31:22.424]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.424]                   envs[common]]
[10:31:22.424]                 NAMES <- toupper(changed)
[10:31:22.424]                 args <- list()
[10:31:22.424]                 for (kk in seq_along(NAMES)) {
[10:31:22.424]                   name <- changed[[kk]]
[10:31:22.424]                   NAME <- NAMES[[kk]]
[10:31:22.424]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.424]                     next
[10:31:22.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.424]                 }
[10:31:22.424]                 NAMES <- toupper(added)
[10:31:22.424]                 for (kk in seq_along(NAMES)) {
[10:31:22.424]                   name <- added[[kk]]
[10:31:22.424]                   NAME <- NAMES[[kk]]
[10:31:22.424]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.424]                     next
[10:31:22.424]                   args[[name]] <- ""
[10:31:22.424]                 }
[10:31:22.424]                 NAMES <- toupper(removed)
[10:31:22.424]                 for (kk in seq_along(NAMES)) {
[10:31:22.424]                   name <- removed[[kk]]
[10:31:22.424]                   NAME <- NAMES[[kk]]
[10:31:22.424]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.424]                     next
[10:31:22.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.424]                 }
[10:31:22.424]                 if (length(args) > 0) 
[10:31:22.424]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.424]             }
[10:31:22.424]             else {
[10:31:22.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.424]             }
[10:31:22.424]             {
[10:31:22.424]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.424]                   0L) {
[10:31:22.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.424]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.424]                   base::options(opts)
[10:31:22.424]                 }
[10:31:22.424]                 {
[10:31:22.424]                   {
[10:31:22.424]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:22.424]                     NULL
[10:31:22.424]                   }
[10:31:22.424]                   options(future.plan = NULL)
[10:31:22.424]                   if (is.na(NA_character_)) 
[10:31:22.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.424]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.424]                     .init = FALSE)
[10:31:22.424]                 }
[10:31:22.424]             }
[10:31:22.424]         }
[10:31:22.424]     })
[10:31:22.424]     if (TRUE) {
[10:31:22.424]         base::sink(type = "output", split = FALSE)
[10:31:22.424]         if (TRUE) {
[10:31:22.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.424]         }
[10:31:22.424]         else {
[10:31:22.424]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.424]         }
[10:31:22.424]         base::close(...future.stdout)
[10:31:22.424]         ...future.stdout <- NULL
[10:31:22.424]     }
[10:31:22.424]     ...future.result$conditions <- ...future.conditions
[10:31:22.424]     ...future.result$finished <- base::Sys.time()
[10:31:22.424]     ...future.result
[10:31:22.424] }
[10:31:22.426] assign_globals() ...
[10:31:22.426] List of 11
[10:31:22.426]  $ ...future.FUN            :function (x, ...)  
[10:31:22.426]  $ x_FUN                    :function (x)  
[10:31:22.426]  $ times                    : int 1
[10:31:22.426]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.426]  $ stop_if_not              :function (...)  
[10:31:22.426]  $ dim                      : NULL
[10:31:22.426]  $ valid_types              : chr "character"
[10:31:22.426]  $ future.call.arguments    : list()
[10:31:22.426]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.426]  $ ...future.elements_ii    :List of 1
[10:31:22.426]   ..$ x: int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:31:22.426]  $ ...future.seeds_ii       : NULL
[10:31:22.426]  $ ...future.globals.maxSize: NULL
[10:31:22.426]  - attr(*, "where")=List of 11
[10:31:22.426]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.426]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.426]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.426]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.426]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.426]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.426]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.426]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.426]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.426]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.426]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.426]  - attr(*, "resolved")= logi FALSE
[10:31:22.426]  - attr(*, "total_size")= num 94208
[10:31:22.426]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.426]  - attr(*, "already-done")= logi TRUE
[10:31:22.436] - copied ‘...future.FUN’ to environment
[10:31:22.437] - copied ‘x_FUN’ to environment
[10:31:22.437] - copied ‘times’ to environment
[10:31:22.437] - copied ‘stopf’ to environment
[10:31:22.437] - copied ‘stop_if_not’ to environment
[10:31:22.437] - copied ‘dim’ to environment
[10:31:22.437] - copied ‘valid_types’ to environment
[10:31:22.437] - copied ‘future.call.arguments’ to environment
[10:31:22.437] - copied ‘...future.elements_ii’ to environment
[10:31:22.437] - copied ‘...future.seeds_ii’ to environment
[10:31:22.438] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.438] assign_globals() ... done
[10:31:22.438] requestCore(): workers = 2
[10:31:22.442] MulticoreFuture started
[10:31:22.442] - Launch lazy future ... done
[10:31:22.442] run() for ‘MulticoreFuture’ ... done
[10:31:22.443] Created future:
[10:31:22.443] plan(): Setting new future strategy stack:
[10:31:22.443] List of future strategies:
[10:31:22.443] 1. sequential:
[10:31:22.443]    - args: function (..., envir = parent.frame())
[10:31:22.443]    - tweaked: FALSE
[10:31:22.443]    - call: NULL
[10:31:22.444] plan(): nbrOfWorkers() = 1
[10:31:22.446] plan(): Setting new future strategy stack:
[10:31:22.446] List of future strategies:
[10:31:22.446] 1. multicore:
[10:31:22.446]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:22.446]    - tweaked: FALSE
[10:31:22.446]    - call: plan(strategy)
[10:31:22.451] plan(): nbrOfWorkers() = 2
[10:31:22.443] MulticoreFuture:
[10:31:22.443] Label: ‘future_vapply-1’
[10:31:22.443] Expression:
[10:31:22.443] {
[10:31:22.443]     do.call(function(...) {
[10:31:22.443]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.443]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.443]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.443]             on.exit(options(oopts), add = TRUE)
[10:31:22.443]         }
[10:31:22.443]         {
[10:31:22.443]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.443]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.443]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.443]             })
[10:31:22.443]         }
[10:31:22.443]     }, args = future.call.arguments)
[10:31:22.443] }
[10:31:22.443] Lazy evaluation: FALSE
[10:31:22.443] Asynchronous evaluation: TRUE
[10:31:22.443] Local evaluation: TRUE
[10:31:22.443] Environment: R_GlobalEnv
[10:31:22.443] Capture standard output: TRUE
[10:31:22.443] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.443] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.443] Packages: 1 packages (‘future.apply’)
[10:31:22.443] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.443] Resolved: TRUE
[10:31:22.443] Value: <not collected>
[10:31:22.443] Conditions captured: <none>
[10:31:22.443] Early signaling: FALSE
[10:31:22.443] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.443] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.453] Chunk #1 of 2 ... DONE
[10:31:22.453] Chunk #2 of 2 ...
[10:31:22.453]  - Finding globals in 'X' for chunk #2 ...
[10:31:22.453] getGlobalsAndPackages() ...
[10:31:22.454] Searching for globals...
[10:31:22.454] 
[10:31:22.454] Searching for globals ... DONE
[10:31:22.454] - globals: [0] <none>
[10:31:22.454] getGlobalsAndPackages() ... DONE
[10:31:22.455]    + additional globals found: [n=0] 
[10:31:22.455]    + additional namespaces needed: [n=0] 
[10:31:22.455]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:22.455]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:22.455]  - seeds: <none>
[10:31:22.455]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.456] getGlobalsAndPackages() ...
[10:31:22.456] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.456] Resolving globals: FALSE
[10:31:22.456] Tweak future expression to call with '...' arguments ...
[10:31:22.456] {
[10:31:22.456]     do.call(function(...) {
[10:31:22.456]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.456]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.456]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.456]             on.exit(options(oopts), add = TRUE)
[10:31:22.456]         }
[10:31:22.456]         {
[10:31:22.456]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.456]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.456]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.456]             })
[10:31:22.456]         }
[10:31:22.456]     }, args = future.call.arguments)
[10:31:22.456] }
[10:31:22.457] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.458] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.458] - packages: [1] ‘future.apply’
[10:31:22.458] getGlobalsAndPackages() ... DONE
[10:31:22.459] run() for ‘Future’ ...
[10:31:22.459] - state: ‘created’
[10:31:22.459] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:22.463] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.464] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:22.464]   - Field: ‘label’
[10:31:22.464]   - Field: ‘local’
[10:31:22.464]   - Field: ‘owner’
[10:31:22.464]   - Field: ‘envir’
[10:31:22.464]   - Field: ‘workers’
[10:31:22.464]   - Field: ‘packages’
[10:31:22.465]   - Field: ‘gc’
[10:31:22.465]   - Field: ‘job’
[10:31:22.465]   - Field: ‘conditions’
[10:31:22.465]   - Field: ‘expr’
[10:31:22.465]   - Field: ‘uuid’
[10:31:22.465]   - Field: ‘seed’
[10:31:22.465]   - Field: ‘version’
[10:31:22.466]   - Field: ‘result’
[10:31:22.466]   - Field: ‘asynchronous’
[10:31:22.466]   - Field: ‘calls’
[10:31:22.466]   - Field: ‘globals’
[10:31:22.466]   - Field: ‘stdout’
[10:31:22.466]   - Field: ‘earlySignal’
[10:31:22.466]   - Field: ‘lazy’
[10:31:22.467]   - Field: ‘state’
[10:31:22.467] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:22.467] - Launch lazy future ...
[10:31:22.467] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.467] Packages needed by future strategies (n = 0): <none>
[10:31:22.468] {
[10:31:22.468]     {
[10:31:22.468]         {
[10:31:22.468]             ...future.startTime <- base::Sys.time()
[10:31:22.468]             {
[10:31:22.468]                 {
[10:31:22.468]                   {
[10:31:22.468]                     {
[10:31:22.468]                       {
[10:31:22.468]                         base::local({
[10:31:22.468]                           has_future <- base::requireNamespace("future", 
[10:31:22.468]                             quietly = TRUE)
[10:31:22.468]                           if (has_future) {
[10:31:22.468]                             ns <- base::getNamespace("future")
[10:31:22.468]                             version <- ns[[".package"]][["version"]]
[10:31:22.468]                             if (is.null(version)) 
[10:31:22.468]                               version <- utils::packageVersion("future")
[10:31:22.468]                           }
[10:31:22.468]                           else {
[10:31:22.468]                             version <- NULL
[10:31:22.468]                           }
[10:31:22.468]                           if (!has_future || version < "1.8.0") {
[10:31:22.468]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.468]                               "", base::R.version$version.string), 
[10:31:22.468]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:22.468]                                 base::R.version$platform, 8 * 
[10:31:22.468]                                   base::.Machine$sizeof.pointer), 
[10:31:22.468]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.468]                                 "release", "version")], collapse = " "), 
[10:31:22.468]                               hostname = base::Sys.info()[["nodename"]])
[10:31:22.468]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.468]                               info)
[10:31:22.468]                             info <- base::paste(info, collapse = "; ")
[10:31:22.468]                             if (!has_future) {
[10:31:22.468]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.468]                                 info)
[10:31:22.468]                             }
[10:31:22.468]                             else {
[10:31:22.468]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.468]                                 info, version)
[10:31:22.468]                             }
[10:31:22.468]                             base::stop(msg)
[10:31:22.468]                           }
[10:31:22.468]                         })
[10:31:22.468]                       }
[10:31:22.468]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:22.468]                       base::options(mc.cores = 1L)
[10:31:22.468]                     }
[10:31:22.468]                     base::local({
[10:31:22.468]                       for (pkg in "future.apply") {
[10:31:22.468]                         base::loadNamespace(pkg)
[10:31:22.468]                         base::library(pkg, character.only = TRUE)
[10:31:22.468]                       }
[10:31:22.468]                     })
[10:31:22.468]                   }
[10:31:22.468]                   ...future.strategy.old <- future::plan("list")
[10:31:22.468]                   options(future.plan = NULL)
[10:31:22.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.468]                 }
[10:31:22.468]                 ...future.workdir <- getwd()
[10:31:22.468]             }
[10:31:22.468]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.468]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.468]         }
[10:31:22.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.468]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:22.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.468]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.468]             base::names(...future.oldOptions))
[10:31:22.468]     }
[10:31:22.468]     if (FALSE) {
[10:31:22.468]     }
[10:31:22.468]     else {
[10:31:22.468]         if (TRUE) {
[10:31:22.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.468]                 open = "w")
[10:31:22.468]         }
[10:31:22.468]         else {
[10:31:22.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.468]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.468]         }
[10:31:22.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.468]             base::sink(type = "output", split = FALSE)
[10:31:22.468]             base::close(...future.stdout)
[10:31:22.468]         }, add = TRUE)
[10:31:22.468]     }
[10:31:22.468]     ...future.frame <- base::sys.nframe()
[10:31:22.468]     ...future.conditions <- base::list()
[10:31:22.468]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.468]     if (FALSE) {
[10:31:22.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.468]     }
[10:31:22.468]     ...future.result <- base::tryCatch({
[10:31:22.468]         base::withCallingHandlers({
[10:31:22.468]             ...future.value <- base::withVisible(base::local({
[10:31:22.468]                 withCallingHandlers({
[10:31:22.468]                   {
[10:31:22.468]                     do.call(function(...) {
[10:31:22.468]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.468]                       if (!identical(...future.globals.maxSize.org, 
[10:31:22.468]                         ...future.globals.maxSize)) {
[10:31:22.468]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.468]                         on.exit(options(oopts), add = TRUE)
[10:31:22.468]                       }
[10:31:22.468]                       {
[10:31:22.468]                         lapply(seq_along(...future.elements_ii), 
[10:31:22.468]                           FUN = function(jj) {
[10:31:22.468]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.468]                             ...future.FUN(...future.X_jj, ...)
[10:31:22.468]                           })
[10:31:22.468]                       }
[10:31:22.468]                     }, args = future.call.arguments)
[10:31:22.468]                   }
[10:31:22.468]                 }, immediateCondition = function(cond) {
[10:31:22.468]                   save_rds <- function (object, pathname, ...) 
[10:31:22.468]                   {
[10:31:22.468]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:22.468]                     if (file_test("-f", pathname_tmp)) {
[10:31:22.468]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.468]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:22.468]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.468]                         fi_tmp[["mtime"]])
[10:31:22.468]                     }
[10:31:22.468]                     tryCatch({
[10:31:22.468]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:22.468]                     }, error = function(ex) {
[10:31:22.468]                       msg <- conditionMessage(ex)
[10:31:22.468]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.468]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:22.468]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.468]                         fi_tmp[["mtime"]], msg)
[10:31:22.468]                       ex$message <- msg
[10:31:22.468]                       stop(ex)
[10:31:22.468]                     })
[10:31:22.468]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:22.468]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:22.468]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:22.468]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.468]                       fi <- file.info(pathname)
[10:31:22.468]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:22.468]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.468]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:22.468]                         fi[["size"]], fi[["mtime"]])
[10:31:22.468]                       stop(msg)
[10:31:22.468]                     }
[10:31:22.468]                     invisible(pathname)
[10:31:22.468]                   }
[10:31:22.468]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:22.468]                     rootPath = tempdir()) 
[10:31:22.468]                   {
[10:31:22.468]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:22.468]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:22.468]                       tmpdir = path, fileext = ".rds")
[10:31:22.468]                     save_rds(obj, file)
[10:31:22.468]                   }
[10:31:22.468]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:22.468]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.468]                   {
[10:31:22.468]                     inherits <- base::inherits
[10:31:22.468]                     invokeRestart <- base::invokeRestart
[10:31:22.468]                     is.null <- base::is.null
[10:31:22.468]                     muffled <- FALSE
[10:31:22.468]                     if (inherits(cond, "message")) {
[10:31:22.468]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:22.468]                       if (muffled) 
[10:31:22.468]                         invokeRestart("muffleMessage")
[10:31:22.468]                     }
[10:31:22.468]                     else if (inherits(cond, "warning")) {
[10:31:22.468]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:22.468]                       if (muffled) 
[10:31:22.468]                         invokeRestart("muffleWarning")
[10:31:22.468]                     }
[10:31:22.468]                     else if (inherits(cond, "condition")) {
[10:31:22.468]                       if (!is.null(pattern)) {
[10:31:22.468]                         computeRestarts <- base::computeRestarts
[10:31:22.468]                         grepl <- base::grepl
[10:31:22.468]                         restarts <- computeRestarts(cond)
[10:31:22.468]                         for (restart in restarts) {
[10:31:22.468]                           name <- restart$name
[10:31:22.468]                           if (is.null(name)) 
[10:31:22.468]                             next
[10:31:22.468]                           if (!grepl(pattern, name)) 
[10:31:22.468]                             next
[10:31:22.468]                           invokeRestart(restart)
[10:31:22.468]                           muffled <- TRUE
[10:31:22.468]                           break
[10:31:22.468]                         }
[10:31:22.468]                       }
[10:31:22.468]                     }
[10:31:22.468]                     invisible(muffled)
[10:31:22.468]                   }
[10:31:22.468]                   muffleCondition(cond)
[10:31:22.468]                 })
[10:31:22.468]             }))
[10:31:22.468]             future::FutureResult(value = ...future.value$value, 
[10:31:22.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.468]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.468]                     ...future.globalenv.names))
[10:31:22.468]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.468]         }, condition = base::local({
[10:31:22.468]             c <- base::c
[10:31:22.468]             inherits <- base::inherits
[10:31:22.468]             invokeRestart <- base::invokeRestart
[10:31:22.468]             length <- base::length
[10:31:22.468]             list <- base::list
[10:31:22.468]             seq.int <- base::seq.int
[10:31:22.468]             signalCondition <- base::signalCondition
[10:31:22.468]             sys.calls <- base::sys.calls
[10:31:22.468]             `[[` <- base::`[[`
[10:31:22.468]             `+` <- base::`+`
[10:31:22.468]             `<<-` <- base::`<<-`
[10:31:22.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.468]                   3L)]
[10:31:22.468]             }
[10:31:22.468]             function(cond) {
[10:31:22.468]                 is_error <- inherits(cond, "error")
[10:31:22.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.468]                   NULL)
[10:31:22.468]                 if (is_error) {
[10:31:22.468]                   sessionInformation <- function() {
[10:31:22.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.468]                       search = base::search(), system = base::Sys.info())
[10:31:22.468]                   }
[10:31:22.468]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.468]                     cond$call), session = sessionInformation(), 
[10:31:22.468]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.468]                   signalCondition(cond)
[10:31:22.468]                 }
[10:31:22.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.468]                 "immediateCondition"))) {
[10:31:22.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.468]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.468]                   if (TRUE && !signal) {
[10:31:22.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.468]                     {
[10:31:22.468]                       inherits <- base::inherits
[10:31:22.468]                       invokeRestart <- base::invokeRestart
[10:31:22.468]                       is.null <- base::is.null
[10:31:22.468]                       muffled <- FALSE
[10:31:22.468]                       if (inherits(cond, "message")) {
[10:31:22.468]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.468]                         if (muffled) 
[10:31:22.468]                           invokeRestart("muffleMessage")
[10:31:22.468]                       }
[10:31:22.468]                       else if (inherits(cond, "warning")) {
[10:31:22.468]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.468]                         if (muffled) 
[10:31:22.468]                           invokeRestart("muffleWarning")
[10:31:22.468]                       }
[10:31:22.468]                       else if (inherits(cond, "condition")) {
[10:31:22.468]                         if (!is.null(pattern)) {
[10:31:22.468]                           computeRestarts <- base::computeRestarts
[10:31:22.468]                           grepl <- base::grepl
[10:31:22.468]                           restarts <- computeRestarts(cond)
[10:31:22.468]                           for (restart in restarts) {
[10:31:22.468]                             name <- restart$name
[10:31:22.468]                             if (is.null(name)) 
[10:31:22.468]                               next
[10:31:22.468]                             if (!grepl(pattern, name)) 
[10:31:22.468]                               next
[10:31:22.468]                             invokeRestart(restart)
[10:31:22.468]                             muffled <- TRUE
[10:31:22.468]                             break
[10:31:22.468]                           }
[10:31:22.468]                         }
[10:31:22.468]                       }
[10:31:22.468]                       invisible(muffled)
[10:31:22.468]                     }
[10:31:22.468]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.468]                   }
[10:31:22.468]                 }
[10:31:22.468]                 else {
[10:31:22.468]                   if (TRUE) {
[10:31:22.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.468]                     {
[10:31:22.468]                       inherits <- base::inherits
[10:31:22.468]                       invokeRestart <- base::invokeRestart
[10:31:22.468]                       is.null <- base::is.null
[10:31:22.468]                       muffled <- FALSE
[10:31:22.468]                       if (inherits(cond, "message")) {
[10:31:22.468]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.468]                         if (muffled) 
[10:31:22.468]                           invokeRestart("muffleMessage")
[10:31:22.468]                       }
[10:31:22.468]                       else if (inherits(cond, "warning")) {
[10:31:22.468]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.468]                         if (muffled) 
[10:31:22.468]                           invokeRestart("muffleWarning")
[10:31:22.468]                       }
[10:31:22.468]                       else if (inherits(cond, "condition")) {
[10:31:22.468]                         if (!is.null(pattern)) {
[10:31:22.468]                           computeRestarts <- base::computeRestarts
[10:31:22.468]                           grepl <- base::grepl
[10:31:22.468]                           restarts <- computeRestarts(cond)
[10:31:22.468]                           for (restart in restarts) {
[10:31:22.468]                             name <- restart$name
[10:31:22.468]                             if (is.null(name)) 
[10:31:22.468]                               next
[10:31:22.468]                             if (!grepl(pattern, name)) 
[10:31:22.468]                               next
[10:31:22.468]                             invokeRestart(restart)
[10:31:22.468]                             muffled <- TRUE
[10:31:22.468]                             break
[10:31:22.468]                           }
[10:31:22.468]                         }
[10:31:22.468]                       }
[10:31:22.468]                       invisible(muffled)
[10:31:22.468]                     }
[10:31:22.468]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.468]                   }
[10:31:22.468]                 }
[10:31:22.468]             }
[10:31:22.468]         }))
[10:31:22.468]     }, error = function(ex) {
[10:31:22.468]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.468]                 ...future.rng), started = ...future.startTime, 
[10:31:22.468]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.468]             version = "1.8"), class = "FutureResult")
[10:31:22.468]     }, finally = {
[10:31:22.468]         if (!identical(...future.workdir, getwd())) 
[10:31:22.468]             setwd(...future.workdir)
[10:31:22.468]         {
[10:31:22.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.468]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.468]             }
[10:31:22.468]             base::options(...future.oldOptions)
[10:31:22.468]             if (.Platform$OS.type == "windows") {
[10:31:22.468]                 old_names <- names(...future.oldEnvVars)
[10:31:22.468]                 envs <- base::Sys.getenv()
[10:31:22.468]                 names <- names(envs)
[10:31:22.468]                 common <- intersect(names, old_names)
[10:31:22.468]                 added <- setdiff(names, old_names)
[10:31:22.468]                 removed <- setdiff(old_names, names)
[10:31:22.468]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.468]                   envs[common]]
[10:31:22.468]                 NAMES <- toupper(changed)
[10:31:22.468]                 args <- list()
[10:31:22.468]                 for (kk in seq_along(NAMES)) {
[10:31:22.468]                   name <- changed[[kk]]
[10:31:22.468]                   NAME <- NAMES[[kk]]
[10:31:22.468]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.468]                     next
[10:31:22.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.468]                 }
[10:31:22.468]                 NAMES <- toupper(added)
[10:31:22.468]                 for (kk in seq_along(NAMES)) {
[10:31:22.468]                   name <- added[[kk]]
[10:31:22.468]                   NAME <- NAMES[[kk]]
[10:31:22.468]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.468]                     next
[10:31:22.468]                   args[[name]] <- ""
[10:31:22.468]                 }
[10:31:22.468]                 NAMES <- toupper(removed)
[10:31:22.468]                 for (kk in seq_along(NAMES)) {
[10:31:22.468]                   name <- removed[[kk]]
[10:31:22.468]                   NAME <- NAMES[[kk]]
[10:31:22.468]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.468]                     next
[10:31:22.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.468]                 }
[10:31:22.468]                 if (length(args) > 0) 
[10:31:22.468]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.468]             }
[10:31:22.468]             else {
[10:31:22.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.468]             }
[10:31:22.468]             {
[10:31:22.468]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.468]                   0L) {
[10:31:22.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.468]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.468]                   base::options(opts)
[10:31:22.468]                 }
[10:31:22.468]                 {
[10:31:22.468]                   {
[10:31:22.468]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:22.468]                     NULL
[10:31:22.468]                   }
[10:31:22.468]                   options(future.plan = NULL)
[10:31:22.468]                   if (is.na(NA_character_)) 
[10:31:22.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.468]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.468]                     .init = FALSE)
[10:31:22.468]                 }
[10:31:22.468]             }
[10:31:22.468]         }
[10:31:22.468]     })
[10:31:22.468]     if (TRUE) {
[10:31:22.468]         base::sink(type = "output", split = FALSE)
[10:31:22.468]         if (TRUE) {
[10:31:22.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.468]         }
[10:31:22.468]         else {
[10:31:22.468]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.468]         }
[10:31:22.468]         base::close(...future.stdout)
[10:31:22.468]         ...future.stdout <- NULL
[10:31:22.468]     }
[10:31:22.468]     ...future.result$conditions <- ...future.conditions
[10:31:22.468]     ...future.result$finished <- base::Sys.time()
[10:31:22.468]     ...future.result
[10:31:22.468] }
[10:31:22.472] assign_globals() ...
[10:31:22.472] List of 11
[10:31:22.472]  $ ...future.FUN            :function (x, ...)  
[10:31:22.472]  $ x_FUN                    :function (x)  
[10:31:22.472]  $ times                    : int 1
[10:31:22.472]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.472]  $ stop_if_not              :function (...)  
[10:31:22.472]  $ dim                      : NULL
[10:31:22.472]  $ valid_types              : chr "character"
[10:31:22.472]  $ future.call.arguments    : list()
[10:31:22.472]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.472]  $ ...future.elements_ii    :List of 1
[10:31:22.472]   ..$ y: chr [1:10] "a" "b" "c" "d" ...
[10:31:22.472]  $ ...future.seeds_ii       : NULL
[10:31:22.472]  $ ...future.globals.maxSize: NULL
[10:31:22.472]  - attr(*, "where")=List of 11
[10:31:22.472]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.472]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.472]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.472]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.472]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.472]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.472]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.472]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.472]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.472]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.472]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.472]  - attr(*, "resolved")= logi FALSE
[10:31:22.472]  - attr(*, "total_size")= num 94208
[10:31:22.472]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.472]  - attr(*, "already-done")= logi TRUE
[10:31:22.487] - copied ‘...future.FUN’ to environment
[10:31:22.488] - copied ‘x_FUN’ to environment
[10:31:22.488] - copied ‘times’ to environment
[10:31:22.488] - copied ‘stopf’ to environment
[10:31:22.488] - copied ‘stop_if_not’ to environment
[10:31:22.488] - copied ‘dim’ to environment
[10:31:22.488] - copied ‘valid_types’ to environment
[10:31:22.488] - copied ‘future.call.arguments’ to environment
[10:31:22.489] - copied ‘...future.elements_ii’ to environment
[10:31:22.489] - copied ‘...future.seeds_ii’ to environment
[10:31:22.489] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.489] assign_globals() ... done
[10:31:22.489] requestCore(): workers = 2
[10:31:22.495] MulticoreFuture started
[10:31:22.495] - Launch lazy future ... done
[10:31:22.496] run() for ‘MulticoreFuture’ ... done
[10:31:22.496] Created future:
[10:31:22.496] plan(): Setting new future strategy stack:
[10:31:22.497] List of future strategies:
[10:31:22.497] 1. sequential:
[10:31:22.497]    - args: function (..., envir = parent.frame())
[10:31:22.497]    - tweaked: FALSE
[10:31:22.497]    - call: NULL
[10:31:22.497] plan(): nbrOfWorkers() = 1
[10:31:22.500] plan(): Setting new future strategy stack:
[10:31:22.500] List of future strategies:
[10:31:22.500] 1. multicore:
[10:31:22.500]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:22.500]    - tweaked: FALSE
[10:31:22.500]    - call: plan(strategy)
[10:31:22.505] plan(): nbrOfWorkers() = 2
[10:31:22.496] MulticoreFuture:
[10:31:22.496] Label: ‘future_vapply-2’
[10:31:22.496] Expression:
[10:31:22.496] {
[10:31:22.496]     do.call(function(...) {
[10:31:22.496]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.496]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.496]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.496]             on.exit(options(oopts), add = TRUE)
[10:31:22.496]         }
[10:31:22.496]         {
[10:31:22.496]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.496]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.496]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.496]             })
[10:31:22.496]         }
[10:31:22.496]     }, args = future.call.arguments)
[10:31:22.496] }
[10:31:22.496] Lazy evaluation: FALSE
[10:31:22.496] Asynchronous evaluation: TRUE
[10:31:22.496] Local evaluation: TRUE
[10:31:22.496] Environment: R_GlobalEnv
[10:31:22.496] Capture standard output: TRUE
[10:31:22.496] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.496] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.496] Packages: 1 packages (‘future.apply’)
[10:31:22.496] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.496] Resolved: TRUE
[10:31:22.496] Value: <not collected>
[10:31:22.496] Conditions captured: <none>
[10:31:22.496] Early signaling: FALSE
[10:31:22.496] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.496] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.506] Chunk #2 of 2 ... DONE
[10:31:22.506] Launching 2 futures (chunks) ... DONE
[10:31:22.506] Resolving 2 futures (chunks) ...
[10:31:22.507] resolve() on list ...
[10:31:22.507]  recursive: 0
[10:31:22.507]  length: 2
[10:31:22.507] 
[10:31:22.507] Future #1
[10:31:22.508] result() for MulticoreFuture ...
[10:31:22.510] result() for MulticoreFuture ...
[10:31:22.510] result() for MulticoreFuture ... done
[10:31:22.511] result() for MulticoreFuture ... done
[10:31:22.511] result() for MulticoreFuture ...
[10:31:22.511] result() for MulticoreFuture ... done
[10:31:22.511] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:22.511] - nx: 2
[10:31:22.511] - relay: TRUE
[10:31:22.511] - stdout: TRUE
[10:31:22.512] - signal: TRUE
[10:31:22.512] - resignal: FALSE
[10:31:22.512] - force: TRUE
[10:31:22.512] - relayed: [n=2] FALSE, FALSE
[10:31:22.512] - queued futures: [n=2] FALSE, FALSE
[10:31:22.512]  - until=1
[10:31:22.512]  - relaying element #1
[10:31:22.513] result() for MulticoreFuture ...
[10:31:22.513] result() for MulticoreFuture ... done
[10:31:22.513] result() for MulticoreFuture ...
[10:31:22.513] result() for MulticoreFuture ... done
[10:31:22.513] result() for MulticoreFuture ...
[10:31:22.513] result() for MulticoreFuture ... done
[10:31:22.513] result() for MulticoreFuture ...
[10:31:22.514] result() for MulticoreFuture ... done
[10:31:22.514] - relayed: [n=2] TRUE, FALSE
[10:31:22.514] - queued futures: [n=2] TRUE, FALSE
[10:31:22.514] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:22.514]  length: 1 (resolved future 1)
[10:31:22.515] Future #2
[10:31:22.515] result() for MulticoreFuture ...
[10:31:22.515] result() for MulticoreFuture ...
[10:31:22.516] result() for MulticoreFuture ... done
[10:31:22.516] result() for MulticoreFuture ... done
[10:31:22.516] result() for MulticoreFuture ...
[10:31:22.516] result() for MulticoreFuture ... done
[10:31:22.516] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:22.517] - nx: 2
[10:31:22.517] - relay: TRUE
[10:31:22.517] - stdout: TRUE
[10:31:22.517] - signal: TRUE
[10:31:22.517] - resignal: FALSE
[10:31:22.517] - force: TRUE
[10:31:22.518] - relayed: [n=2] TRUE, FALSE
[10:31:22.518] - queued futures: [n=2] TRUE, FALSE
[10:31:22.518]  - until=2
[10:31:22.518]  - relaying element #2
[10:31:22.518] result() for MulticoreFuture ...
[10:31:22.518] result() for MulticoreFuture ... done
[10:31:22.519] result() for MulticoreFuture ...
[10:31:22.519] result() for MulticoreFuture ... done
[10:31:22.519] result() for MulticoreFuture ...
[10:31:22.519] result() for MulticoreFuture ... done
[10:31:22.519] result() for MulticoreFuture ...
[10:31:22.519] result() for MulticoreFuture ... done
[10:31:22.519] - relayed: [n=2] TRUE, TRUE
[10:31:22.519] - queued futures: [n=2] TRUE, TRUE
[10:31:22.519] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:22.520]  length: 0 (resolved future 2)
[10:31:22.520] Relaying remaining futures
[10:31:22.520] signalConditionsASAP(NULL, pos=0) ...
[10:31:22.520] - nx: 2
[10:31:22.520] - relay: TRUE
[10:31:22.520] - stdout: TRUE
[10:31:22.520] - signal: TRUE
[10:31:22.520] - resignal: FALSE
[10:31:22.520] - force: TRUE
[10:31:22.521] - relayed: [n=2] TRUE, TRUE
[10:31:22.521] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:22.521] - relayed: [n=2] TRUE, TRUE
[10:31:22.521] - queued futures: [n=2] TRUE, TRUE
[10:31:22.523] signalConditionsASAP(NULL, pos=0) ... done
[10:31:22.523] resolve() on list ... DONE
[10:31:22.523] result() for MulticoreFuture ...
[10:31:22.524] result() for MulticoreFuture ... done
[10:31:22.524] result() for MulticoreFuture ...
[10:31:22.524] result() for MulticoreFuture ... done
[10:31:22.524] result() for MulticoreFuture ...
[10:31:22.524] result() for MulticoreFuture ... done
[10:31:22.524] result() for MulticoreFuture ...
[10:31:22.525] result() for MulticoreFuture ... done
[10:31:22.525]  - Number of value chunks collected: 2
[10:31:22.525] Resolving 2 futures (chunks) ... DONE
[10:31:22.525] Reducing values from 2 chunks ...
[10:31:22.525]  - Number of values collected after concatenation: 2
[10:31:22.525]  - Number of values expected: 2
[10:31:22.526] Reducing values from 2 chunks ... DONE
[10:31:22.526] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[10:31:22.528] future_lapply() ...
[10:31:22.534] Number of chunks: 2
[10:31:22.534] getGlobalsAndPackagesXApply() ...
[10:31:22.534]  - future.globals: TRUE
[10:31:22.535] getGlobalsAndPackages() ...
[10:31:22.535] Searching for globals...
[10:31:22.539] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[10:31:22.539] Searching for globals ... DONE
[10:31:22.539] Resolving globals: FALSE
[10:31:22.540] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[10:31:22.541] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:22.541] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.541] - packages: [1] ‘future.apply’
[10:31:22.541] getGlobalsAndPackages() ... DONE
[10:31:22.541]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.541]  - needed namespaces: [n=1] ‘future.apply’
[10:31:22.541] Finding globals ... DONE
[10:31:22.542]  - use_args: TRUE
[10:31:22.542]  - Getting '...' globals ...
[10:31:22.542] resolve() on list ...
[10:31:22.542]  recursive: 0
[10:31:22.542]  length: 1
[10:31:22.542]  elements: ‘...’
[10:31:22.542]  length: 0 (resolved future 1)
[10:31:22.542] resolve() on list ... DONE
[10:31:22.543]    - '...' content: [n=0] 
[10:31:22.543] List of 1
[10:31:22.543]  $ ...: list()
[10:31:22.543]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.543]  - attr(*, "where")=List of 1
[10:31:22.543]   ..$ ...:<environment: 0x55de851f4720> 
[10:31:22.543]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.543]  - attr(*, "resolved")= logi TRUE
[10:31:22.543]  - attr(*, "total_size")= num NA
[10:31:22.545]  - Getting '...' globals ... DONE
[10:31:22.546] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:22.546] List of 8
[10:31:22.546]  $ ...future.FUN:function (x, ...)  
[10:31:22.546]  $ x_FUN        :function (x)  
[10:31:22.546]  $ times        : int 0
[10:31:22.546]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.546]  $ stop_if_not  :function (...)  
[10:31:22.546]  $ dim          : NULL
[10:31:22.546]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:22.546]  $ ...          : list()
[10:31:22.546]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.546]  - attr(*, "where")=List of 8
[10:31:22.546]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:22.546]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:22.546]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:22.546]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:22.546]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:22.546]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:22.546]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:22.546]   ..$ ...          :<environment: 0x55de851f4720> 
[10:31:22.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.546]  - attr(*, "resolved")= logi FALSE
[10:31:22.546]  - attr(*, "total_size")= num 95472
[10:31:22.554] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:22.554] getGlobalsAndPackagesXApply() ... DONE
[10:31:22.554] Number of futures (= number of chunks): 2
[10:31:22.555] Launching 2 futures (chunks) ...
[10:31:22.555] Chunk #1 of 2 ...
[10:31:22.555]  - Finding globals in 'X' for chunk #1 ...
[10:31:22.555] getGlobalsAndPackages() ...
[10:31:22.555] Searching for globals...
[10:31:22.555] 
[10:31:22.556] Searching for globals ... DONE
[10:31:22.556] - globals: [0] <none>
[10:31:22.556] getGlobalsAndPackages() ... DONE
[10:31:22.556]    + additional globals found: [n=0] 
[10:31:22.556]    + additional namespaces needed: [n=0] 
[10:31:22.556]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:22.556]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:22.556]  - seeds: <none>
[10:31:22.556]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.556] getGlobalsAndPackages() ...
[10:31:22.557] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.557] Resolving globals: FALSE
[10:31:22.557] Tweak future expression to call with '...' arguments ...
[10:31:22.557] {
[10:31:22.557]     do.call(function(...) {
[10:31:22.557]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.557]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.557]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.557]             on.exit(options(oopts), add = TRUE)
[10:31:22.557]         }
[10:31:22.557]         {
[10:31:22.557]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.557]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.557]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.557]             })
[10:31:22.557]         }
[10:31:22.557]     }, args = future.call.arguments)
[10:31:22.557] }
[10:31:22.557] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.558] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.558] - packages: [1] ‘future.apply’
[10:31:22.558] getGlobalsAndPackages() ... DONE
[10:31:22.559] run() for ‘Future’ ...
[10:31:22.559] - state: ‘created’
[10:31:22.559] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:22.563] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.563] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:22.563]   - Field: ‘label’
[10:31:22.563]   - Field: ‘local’
[10:31:22.563]   - Field: ‘owner’
[10:31:22.563]   - Field: ‘envir’
[10:31:22.563]   - Field: ‘workers’
[10:31:22.563]   - Field: ‘packages’
[10:31:22.564]   - Field: ‘gc’
[10:31:22.564]   - Field: ‘job’
[10:31:22.564]   - Field: ‘conditions’
[10:31:22.564]   - Field: ‘expr’
[10:31:22.564]   - Field: ‘uuid’
[10:31:22.564]   - Field: ‘seed’
[10:31:22.564]   - Field: ‘version’
[10:31:22.564]   - Field: ‘result’
[10:31:22.564]   - Field: ‘asynchronous’
[10:31:22.564]   - Field: ‘calls’
[10:31:22.565]   - Field: ‘globals’
[10:31:22.565]   - Field: ‘stdout’
[10:31:22.565]   - Field: ‘earlySignal’
[10:31:22.565]   - Field: ‘lazy’
[10:31:22.565]   - Field: ‘state’
[10:31:22.565] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:22.565] - Launch lazy future ...
[10:31:22.565] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.566] Packages needed by future strategies (n = 0): <none>
[10:31:22.566] {
[10:31:22.566]     {
[10:31:22.566]         {
[10:31:22.566]             ...future.startTime <- base::Sys.time()
[10:31:22.566]             {
[10:31:22.566]                 {
[10:31:22.566]                   {
[10:31:22.566]                     {
[10:31:22.566]                       {
[10:31:22.566]                         base::local({
[10:31:22.566]                           has_future <- base::requireNamespace("future", 
[10:31:22.566]                             quietly = TRUE)
[10:31:22.566]                           if (has_future) {
[10:31:22.566]                             ns <- base::getNamespace("future")
[10:31:22.566]                             version <- ns[[".package"]][["version"]]
[10:31:22.566]                             if (is.null(version)) 
[10:31:22.566]                               version <- utils::packageVersion("future")
[10:31:22.566]                           }
[10:31:22.566]                           else {
[10:31:22.566]                             version <- NULL
[10:31:22.566]                           }
[10:31:22.566]                           if (!has_future || version < "1.8.0") {
[10:31:22.566]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.566]                               "", base::R.version$version.string), 
[10:31:22.566]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:22.566]                                 base::R.version$platform, 8 * 
[10:31:22.566]                                   base::.Machine$sizeof.pointer), 
[10:31:22.566]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.566]                                 "release", "version")], collapse = " "), 
[10:31:22.566]                               hostname = base::Sys.info()[["nodename"]])
[10:31:22.566]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.566]                               info)
[10:31:22.566]                             info <- base::paste(info, collapse = "; ")
[10:31:22.566]                             if (!has_future) {
[10:31:22.566]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.566]                                 info)
[10:31:22.566]                             }
[10:31:22.566]                             else {
[10:31:22.566]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.566]                                 info, version)
[10:31:22.566]                             }
[10:31:22.566]                             base::stop(msg)
[10:31:22.566]                           }
[10:31:22.566]                         })
[10:31:22.566]                       }
[10:31:22.566]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:22.566]                       base::options(mc.cores = 1L)
[10:31:22.566]                     }
[10:31:22.566]                     base::local({
[10:31:22.566]                       for (pkg in "future.apply") {
[10:31:22.566]                         base::loadNamespace(pkg)
[10:31:22.566]                         base::library(pkg, character.only = TRUE)
[10:31:22.566]                       }
[10:31:22.566]                     })
[10:31:22.566]                   }
[10:31:22.566]                   ...future.strategy.old <- future::plan("list")
[10:31:22.566]                   options(future.plan = NULL)
[10:31:22.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.566]                 }
[10:31:22.566]                 ...future.workdir <- getwd()
[10:31:22.566]             }
[10:31:22.566]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.566]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.566]         }
[10:31:22.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.566]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:22.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.566]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.566]             base::names(...future.oldOptions))
[10:31:22.566]     }
[10:31:22.566]     if (FALSE) {
[10:31:22.566]     }
[10:31:22.566]     else {
[10:31:22.566]         if (TRUE) {
[10:31:22.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.566]                 open = "w")
[10:31:22.566]         }
[10:31:22.566]         else {
[10:31:22.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.566]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.566]         }
[10:31:22.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.566]             base::sink(type = "output", split = FALSE)
[10:31:22.566]             base::close(...future.stdout)
[10:31:22.566]         }, add = TRUE)
[10:31:22.566]     }
[10:31:22.566]     ...future.frame <- base::sys.nframe()
[10:31:22.566]     ...future.conditions <- base::list()
[10:31:22.566]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.566]     if (FALSE) {
[10:31:22.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.566]     }
[10:31:22.566]     ...future.result <- base::tryCatch({
[10:31:22.566]         base::withCallingHandlers({
[10:31:22.566]             ...future.value <- base::withVisible(base::local({
[10:31:22.566]                 withCallingHandlers({
[10:31:22.566]                   {
[10:31:22.566]                     do.call(function(...) {
[10:31:22.566]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.566]                       if (!identical(...future.globals.maxSize.org, 
[10:31:22.566]                         ...future.globals.maxSize)) {
[10:31:22.566]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.566]                         on.exit(options(oopts), add = TRUE)
[10:31:22.566]                       }
[10:31:22.566]                       {
[10:31:22.566]                         lapply(seq_along(...future.elements_ii), 
[10:31:22.566]                           FUN = function(jj) {
[10:31:22.566]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.566]                             ...future.FUN(...future.X_jj, ...)
[10:31:22.566]                           })
[10:31:22.566]                       }
[10:31:22.566]                     }, args = future.call.arguments)
[10:31:22.566]                   }
[10:31:22.566]                 }, immediateCondition = function(cond) {
[10:31:22.566]                   save_rds <- function (object, pathname, ...) 
[10:31:22.566]                   {
[10:31:22.566]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:22.566]                     if (file_test("-f", pathname_tmp)) {
[10:31:22.566]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.566]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:22.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.566]                         fi_tmp[["mtime"]])
[10:31:22.566]                     }
[10:31:22.566]                     tryCatch({
[10:31:22.566]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:22.566]                     }, error = function(ex) {
[10:31:22.566]                       msg <- conditionMessage(ex)
[10:31:22.566]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.566]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:22.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.566]                         fi_tmp[["mtime"]], msg)
[10:31:22.566]                       ex$message <- msg
[10:31:22.566]                       stop(ex)
[10:31:22.566]                     })
[10:31:22.566]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:22.566]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:22.566]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:22.566]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.566]                       fi <- file.info(pathname)
[10:31:22.566]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:22.566]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.566]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:22.566]                         fi[["size"]], fi[["mtime"]])
[10:31:22.566]                       stop(msg)
[10:31:22.566]                     }
[10:31:22.566]                     invisible(pathname)
[10:31:22.566]                   }
[10:31:22.566]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:22.566]                     rootPath = tempdir()) 
[10:31:22.566]                   {
[10:31:22.566]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:22.566]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:22.566]                       tmpdir = path, fileext = ".rds")
[10:31:22.566]                     save_rds(obj, file)
[10:31:22.566]                   }
[10:31:22.566]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:22.566]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.566]                   {
[10:31:22.566]                     inherits <- base::inherits
[10:31:22.566]                     invokeRestart <- base::invokeRestart
[10:31:22.566]                     is.null <- base::is.null
[10:31:22.566]                     muffled <- FALSE
[10:31:22.566]                     if (inherits(cond, "message")) {
[10:31:22.566]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:22.566]                       if (muffled) 
[10:31:22.566]                         invokeRestart("muffleMessage")
[10:31:22.566]                     }
[10:31:22.566]                     else if (inherits(cond, "warning")) {
[10:31:22.566]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:22.566]                       if (muffled) 
[10:31:22.566]                         invokeRestart("muffleWarning")
[10:31:22.566]                     }
[10:31:22.566]                     else if (inherits(cond, "condition")) {
[10:31:22.566]                       if (!is.null(pattern)) {
[10:31:22.566]                         computeRestarts <- base::computeRestarts
[10:31:22.566]                         grepl <- base::grepl
[10:31:22.566]                         restarts <- computeRestarts(cond)
[10:31:22.566]                         for (restart in restarts) {
[10:31:22.566]                           name <- restart$name
[10:31:22.566]                           if (is.null(name)) 
[10:31:22.566]                             next
[10:31:22.566]                           if (!grepl(pattern, name)) 
[10:31:22.566]                             next
[10:31:22.566]                           invokeRestart(restart)
[10:31:22.566]                           muffled <- TRUE
[10:31:22.566]                           break
[10:31:22.566]                         }
[10:31:22.566]                       }
[10:31:22.566]                     }
[10:31:22.566]                     invisible(muffled)
[10:31:22.566]                   }
[10:31:22.566]                   muffleCondition(cond)
[10:31:22.566]                 })
[10:31:22.566]             }))
[10:31:22.566]             future::FutureResult(value = ...future.value$value, 
[10:31:22.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.566]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.566]                     ...future.globalenv.names))
[10:31:22.566]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.566]         }, condition = base::local({
[10:31:22.566]             c <- base::c
[10:31:22.566]             inherits <- base::inherits
[10:31:22.566]             invokeRestart <- base::invokeRestart
[10:31:22.566]             length <- base::length
[10:31:22.566]             list <- base::list
[10:31:22.566]             seq.int <- base::seq.int
[10:31:22.566]             signalCondition <- base::signalCondition
[10:31:22.566]             sys.calls <- base::sys.calls
[10:31:22.566]             `[[` <- base::`[[`
[10:31:22.566]             `+` <- base::`+`
[10:31:22.566]             `<<-` <- base::`<<-`
[10:31:22.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.566]                   3L)]
[10:31:22.566]             }
[10:31:22.566]             function(cond) {
[10:31:22.566]                 is_error <- inherits(cond, "error")
[10:31:22.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.566]                   NULL)
[10:31:22.566]                 if (is_error) {
[10:31:22.566]                   sessionInformation <- function() {
[10:31:22.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.566]                       search = base::search(), system = base::Sys.info())
[10:31:22.566]                   }
[10:31:22.566]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.566]                     cond$call), session = sessionInformation(), 
[10:31:22.566]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.566]                   signalCondition(cond)
[10:31:22.566]                 }
[10:31:22.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.566]                 "immediateCondition"))) {
[10:31:22.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.566]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.566]                   if (TRUE && !signal) {
[10:31:22.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.566]                     {
[10:31:22.566]                       inherits <- base::inherits
[10:31:22.566]                       invokeRestart <- base::invokeRestart
[10:31:22.566]                       is.null <- base::is.null
[10:31:22.566]                       muffled <- FALSE
[10:31:22.566]                       if (inherits(cond, "message")) {
[10:31:22.566]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.566]                         if (muffled) 
[10:31:22.566]                           invokeRestart("muffleMessage")
[10:31:22.566]                       }
[10:31:22.566]                       else if (inherits(cond, "warning")) {
[10:31:22.566]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.566]                         if (muffled) 
[10:31:22.566]                           invokeRestart("muffleWarning")
[10:31:22.566]                       }
[10:31:22.566]                       else if (inherits(cond, "condition")) {
[10:31:22.566]                         if (!is.null(pattern)) {
[10:31:22.566]                           computeRestarts <- base::computeRestarts
[10:31:22.566]                           grepl <- base::grepl
[10:31:22.566]                           restarts <- computeRestarts(cond)
[10:31:22.566]                           for (restart in restarts) {
[10:31:22.566]                             name <- restart$name
[10:31:22.566]                             if (is.null(name)) 
[10:31:22.566]                               next
[10:31:22.566]                             if (!grepl(pattern, name)) 
[10:31:22.566]                               next
[10:31:22.566]                             invokeRestart(restart)
[10:31:22.566]                             muffled <- TRUE
[10:31:22.566]                             break
[10:31:22.566]                           }
[10:31:22.566]                         }
[10:31:22.566]                       }
[10:31:22.566]                       invisible(muffled)
[10:31:22.566]                     }
[10:31:22.566]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.566]                   }
[10:31:22.566]                 }
[10:31:22.566]                 else {
[10:31:22.566]                   if (TRUE) {
[10:31:22.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.566]                     {
[10:31:22.566]                       inherits <- base::inherits
[10:31:22.566]                       invokeRestart <- base::invokeRestart
[10:31:22.566]                       is.null <- base::is.null
[10:31:22.566]                       muffled <- FALSE
[10:31:22.566]                       if (inherits(cond, "message")) {
[10:31:22.566]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.566]                         if (muffled) 
[10:31:22.566]                           invokeRestart("muffleMessage")
[10:31:22.566]                       }
[10:31:22.566]                       else if (inherits(cond, "warning")) {
[10:31:22.566]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.566]                         if (muffled) 
[10:31:22.566]                           invokeRestart("muffleWarning")
[10:31:22.566]                       }
[10:31:22.566]                       else if (inherits(cond, "condition")) {
[10:31:22.566]                         if (!is.null(pattern)) {
[10:31:22.566]                           computeRestarts <- base::computeRestarts
[10:31:22.566]                           grepl <- base::grepl
[10:31:22.566]                           restarts <- computeRestarts(cond)
[10:31:22.566]                           for (restart in restarts) {
[10:31:22.566]                             name <- restart$name
[10:31:22.566]                             if (is.null(name)) 
[10:31:22.566]                               next
[10:31:22.566]                             if (!grepl(pattern, name)) 
[10:31:22.566]                               next
[10:31:22.566]                             invokeRestart(restart)
[10:31:22.566]                             muffled <- TRUE
[10:31:22.566]                             break
[10:31:22.566]                           }
[10:31:22.566]                         }
[10:31:22.566]                       }
[10:31:22.566]                       invisible(muffled)
[10:31:22.566]                     }
[10:31:22.566]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.566]                   }
[10:31:22.566]                 }
[10:31:22.566]             }
[10:31:22.566]         }))
[10:31:22.566]     }, error = function(ex) {
[10:31:22.566]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.566]                 ...future.rng), started = ...future.startTime, 
[10:31:22.566]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.566]             version = "1.8"), class = "FutureResult")
[10:31:22.566]     }, finally = {
[10:31:22.566]         if (!identical(...future.workdir, getwd())) 
[10:31:22.566]             setwd(...future.workdir)
[10:31:22.566]         {
[10:31:22.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.566]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.566]             }
[10:31:22.566]             base::options(...future.oldOptions)
[10:31:22.566]             if (.Platform$OS.type == "windows") {
[10:31:22.566]                 old_names <- names(...future.oldEnvVars)
[10:31:22.566]                 envs <- base::Sys.getenv()
[10:31:22.566]                 names <- names(envs)
[10:31:22.566]                 common <- intersect(names, old_names)
[10:31:22.566]                 added <- setdiff(names, old_names)
[10:31:22.566]                 removed <- setdiff(old_names, names)
[10:31:22.566]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.566]                   envs[common]]
[10:31:22.566]                 NAMES <- toupper(changed)
[10:31:22.566]                 args <- list()
[10:31:22.566]                 for (kk in seq_along(NAMES)) {
[10:31:22.566]                   name <- changed[[kk]]
[10:31:22.566]                   NAME <- NAMES[[kk]]
[10:31:22.566]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.566]                     next
[10:31:22.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.566]                 }
[10:31:22.566]                 NAMES <- toupper(added)
[10:31:22.566]                 for (kk in seq_along(NAMES)) {
[10:31:22.566]                   name <- added[[kk]]
[10:31:22.566]                   NAME <- NAMES[[kk]]
[10:31:22.566]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.566]                     next
[10:31:22.566]                   args[[name]] <- ""
[10:31:22.566]                 }
[10:31:22.566]                 NAMES <- toupper(removed)
[10:31:22.566]                 for (kk in seq_along(NAMES)) {
[10:31:22.566]                   name <- removed[[kk]]
[10:31:22.566]                   NAME <- NAMES[[kk]]
[10:31:22.566]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.566]                     next
[10:31:22.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.566]                 }
[10:31:22.566]                 if (length(args) > 0) 
[10:31:22.566]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.566]             }
[10:31:22.566]             else {
[10:31:22.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.566]             }
[10:31:22.566]             {
[10:31:22.566]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.566]                   0L) {
[10:31:22.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.566]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.566]                   base::options(opts)
[10:31:22.566]                 }
[10:31:22.566]                 {
[10:31:22.566]                   {
[10:31:22.566]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:22.566]                     NULL
[10:31:22.566]                   }
[10:31:22.566]                   options(future.plan = NULL)
[10:31:22.566]                   if (is.na(NA_character_)) 
[10:31:22.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.566]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.566]                     .init = FALSE)
[10:31:22.566]                 }
[10:31:22.566]             }
[10:31:22.566]         }
[10:31:22.566]     })
[10:31:22.566]     if (TRUE) {
[10:31:22.566]         base::sink(type = "output", split = FALSE)
[10:31:22.566]         if (TRUE) {
[10:31:22.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.566]         }
[10:31:22.566]         else {
[10:31:22.566]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.566]         }
[10:31:22.566]         base::close(...future.stdout)
[10:31:22.566]         ...future.stdout <- NULL
[10:31:22.566]     }
[10:31:22.566]     ...future.result$conditions <- ...future.conditions
[10:31:22.566]     ...future.result$finished <- base::Sys.time()
[10:31:22.566]     ...future.result
[10:31:22.566] }
[10:31:22.569] assign_globals() ...
[10:31:22.569] List of 11
[10:31:22.569]  $ ...future.FUN            :function (x, ...)  
[10:31:22.569]  $ x_FUN                    :function (x)  
[10:31:22.569]  $ times                    : int 0
[10:31:22.569]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.569]  $ stop_if_not              :function (...)  
[10:31:22.569]  $ dim                      : NULL
[10:31:22.569]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:22.569]  $ future.call.arguments    : list()
[10:31:22.569]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.569]  $ ...future.elements_ii    :List of 5
[10:31:22.569]   ..$ : int 1
[10:31:22.569]   ..$ : int 2
[10:31:22.569]   ..$ : int 3
[10:31:22.569]   ..$ : int 4
[10:31:22.569]   ..$ : int 5
[10:31:22.569]  $ ...future.seeds_ii       : NULL
[10:31:22.569]  $ ...future.globals.maxSize: NULL
[10:31:22.569]  - attr(*, "where")=List of 11
[10:31:22.569]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.569]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.569]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.569]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.569]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.569]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.569]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.569]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.569]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.569]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.569]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.569]  - attr(*, "resolved")= logi FALSE
[10:31:22.569]  - attr(*, "total_size")= num 95472
[10:31:22.569]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.569]  - attr(*, "already-done")= logi TRUE
[10:31:22.580] - copied ‘...future.FUN’ to environment
[10:31:22.580] - reassign environment for ‘x_FUN’
[10:31:22.580] - copied ‘x_FUN’ to environment
[10:31:22.580] - copied ‘times’ to environment
[10:31:22.580] - copied ‘stopf’ to environment
[10:31:22.580] - copied ‘stop_if_not’ to environment
[10:31:22.580] - copied ‘dim’ to environment
[10:31:22.581] - copied ‘valid_types’ to environment
[10:31:22.581] - copied ‘future.call.arguments’ to environment
[10:31:22.581] - copied ‘...future.elements_ii’ to environment
[10:31:22.581] - copied ‘...future.seeds_ii’ to environment
[10:31:22.581] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.581] assign_globals() ... done
[10:31:22.581] requestCore(): workers = 2
[10:31:22.584] MulticoreFuture started
[10:31:22.584] - Launch lazy future ... done
[10:31:22.585] run() for ‘MulticoreFuture’ ... done
[10:31:22.586] Created future:
[10:31:22.586] plan(): Setting new future strategy stack:
[10:31:22.586] List of future strategies:
[10:31:22.586] 1. sequential:
[10:31:22.586]    - args: function (..., envir = parent.frame())
[10:31:22.586]    - tweaked: FALSE
[10:31:22.586]    - call: NULL
[10:31:22.588] plan(): nbrOfWorkers() = 1
[10:31:22.590] plan(): Setting new future strategy stack:
[10:31:22.590] List of future strategies:
[10:31:22.590] 1. multicore:
[10:31:22.590]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:22.590]    - tweaked: FALSE
[10:31:22.590]    - call: plan(strategy)
[10:31:22.596] plan(): nbrOfWorkers() = 2
[10:31:22.586] MulticoreFuture:
[10:31:22.586] Label: ‘future_vapply-1’
[10:31:22.586] Expression:
[10:31:22.586] {
[10:31:22.586]     do.call(function(...) {
[10:31:22.586]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.586]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.586]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.586]             on.exit(options(oopts), add = TRUE)
[10:31:22.586]         }
[10:31:22.586]         {
[10:31:22.586]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.586]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.586]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.586]             })
[10:31:22.586]         }
[10:31:22.586]     }, args = future.call.arguments)
[10:31:22.586] }
[10:31:22.586] Lazy evaluation: FALSE
[10:31:22.586] Asynchronous evaluation: TRUE
[10:31:22.586] Local evaluation: TRUE
[10:31:22.586] Environment: R_GlobalEnv
[10:31:22.586] Capture standard output: TRUE
[10:31:22.586] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.586] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.586] Packages: 1 packages (‘future.apply’)
[10:31:22.586] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.586] Resolved: TRUE
[10:31:22.586] Value: <not collected>
[10:31:22.586] Conditions captured: <none>
[10:31:22.586] Early signaling: FALSE
[10:31:22.586] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.586] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.597] Chunk #1 of 2 ... DONE
[10:31:22.597] Chunk #2 of 2 ...
[10:31:22.598]  - Finding globals in 'X' for chunk #2 ...
[10:31:22.598] getGlobalsAndPackages() ...
[10:31:22.598] Searching for globals...
[10:31:22.599] 
[10:31:22.599] Searching for globals ... DONE
[10:31:22.599] - globals: [0] <none>
[10:31:22.599] getGlobalsAndPackages() ... DONE
[10:31:22.599]    + additional globals found: [n=0] 
[10:31:22.599]    + additional namespaces needed: [n=0] 
[10:31:22.599]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:22.600]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:22.600]  - seeds: <none>
[10:31:22.600]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.600] getGlobalsAndPackages() ...
[10:31:22.601] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.601] Resolving globals: FALSE
[10:31:22.601] Tweak future expression to call with '...' arguments ...
[10:31:22.601] {
[10:31:22.601]     do.call(function(...) {
[10:31:22.601]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.601]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.601]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.601]             on.exit(options(oopts), add = TRUE)
[10:31:22.601]         }
[10:31:22.601]         {
[10:31:22.601]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.601]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.601]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.601]             })
[10:31:22.601]         }
[10:31:22.601]     }, args = future.call.arguments)
[10:31:22.601] }
[10:31:22.602] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.603] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.603] - packages: [1] ‘future.apply’
[10:31:22.603] getGlobalsAndPackages() ... DONE
[10:31:22.604] run() for ‘Future’ ...
[10:31:22.604] - state: ‘created’
[10:31:22.604] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:22.609] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.609] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:22.609]   - Field: ‘label’
[10:31:22.609]   - Field: ‘local’
[10:31:22.609]   - Field: ‘owner’
[10:31:22.610]   - Field: ‘envir’
[10:31:22.610]   - Field: ‘workers’
[10:31:22.610]   - Field: ‘packages’
[10:31:22.610]   - Field: ‘gc’
[10:31:22.610]   - Field: ‘job’
[10:31:22.610]   - Field: ‘conditions’
[10:31:22.611]   - Field: ‘expr’
[10:31:22.611]   - Field: ‘uuid’
[10:31:22.611]   - Field: ‘seed’
[10:31:22.611]   - Field: ‘version’
[10:31:22.611]   - Field: ‘result’
[10:31:22.611]   - Field: ‘asynchronous’
[10:31:22.611]   - Field: ‘calls’
[10:31:22.612]   - Field: ‘globals’
[10:31:22.612]   - Field: ‘stdout’
[10:31:22.612]   - Field: ‘earlySignal’
[10:31:22.612]   - Field: ‘lazy’
[10:31:22.612]   - Field: ‘state’
[10:31:22.612] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:22.612] - Launch lazy future ...
[10:31:22.613] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.613] Packages needed by future strategies (n = 0): <none>
[10:31:22.614] {
[10:31:22.614]     {
[10:31:22.614]         {
[10:31:22.614]             ...future.startTime <- base::Sys.time()
[10:31:22.614]             {
[10:31:22.614]                 {
[10:31:22.614]                   {
[10:31:22.614]                     {
[10:31:22.614]                       {
[10:31:22.614]                         base::local({
[10:31:22.614]                           has_future <- base::requireNamespace("future", 
[10:31:22.614]                             quietly = TRUE)
[10:31:22.614]                           if (has_future) {
[10:31:22.614]                             ns <- base::getNamespace("future")
[10:31:22.614]                             version <- ns[[".package"]][["version"]]
[10:31:22.614]                             if (is.null(version)) 
[10:31:22.614]                               version <- utils::packageVersion("future")
[10:31:22.614]                           }
[10:31:22.614]                           else {
[10:31:22.614]                             version <- NULL
[10:31:22.614]                           }
[10:31:22.614]                           if (!has_future || version < "1.8.0") {
[10:31:22.614]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.614]                               "", base::R.version$version.string), 
[10:31:22.614]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:22.614]                                 base::R.version$platform, 8 * 
[10:31:22.614]                                   base::.Machine$sizeof.pointer), 
[10:31:22.614]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.614]                                 "release", "version")], collapse = " "), 
[10:31:22.614]                               hostname = base::Sys.info()[["nodename"]])
[10:31:22.614]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.614]                               info)
[10:31:22.614]                             info <- base::paste(info, collapse = "; ")
[10:31:22.614]                             if (!has_future) {
[10:31:22.614]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.614]                                 info)
[10:31:22.614]                             }
[10:31:22.614]                             else {
[10:31:22.614]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.614]                                 info, version)
[10:31:22.614]                             }
[10:31:22.614]                             base::stop(msg)
[10:31:22.614]                           }
[10:31:22.614]                         })
[10:31:22.614]                       }
[10:31:22.614]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:22.614]                       base::options(mc.cores = 1L)
[10:31:22.614]                     }
[10:31:22.614]                     base::local({
[10:31:22.614]                       for (pkg in "future.apply") {
[10:31:22.614]                         base::loadNamespace(pkg)
[10:31:22.614]                         base::library(pkg, character.only = TRUE)
[10:31:22.614]                       }
[10:31:22.614]                     })
[10:31:22.614]                   }
[10:31:22.614]                   ...future.strategy.old <- future::plan("list")
[10:31:22.614]                   options(future.plan = NULL)
[10:31:22.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.614]                 }
[10:31:22.614]                 ...future.workdir <- getwd()
[10:31:22.614]             }
[10:31:22.614]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.614]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.614]         }
[10:31:22.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.614]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:22.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.614]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.614]             base::names(...future.oldOptions))
[10:31:22.614]     }
[10:31:22.614]     if (FALSE) {
[10:31:22.614]     }
[10:31:22.614]     else {
[10:31:22.614]         if (TRUE) {
[10:31:22.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.614]                 open = "w")
[10:31:22.614]         }
[10:31:22.614]         else {
[10:31:22.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.614]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.614]         }
[10:31:22.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.614]             base::sink(type = "output", split = FALSE)
[10:31:22.614]             base::close(...future.stdout)
[10:31:22.614]         }, add = TRUE)
[10:31:22.614]     }
[10:31:22.614]     ...future.frame <- base::sys.nframe()
[10:31:22.614]     ...future.conditions <- base::list()
[10:31:22.614]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.614]     if (FALSE) {
[10:31:22.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.614]     }
[10:31:22.614]     ...future.result <- base::tryCatch({
[10:31:22.614]         base::withCallingHandlers({
[10:31:22.614]             ...future.value <- base::withVisible(base::local({
[10:31:22.614]                 withCallingHandlers({
[10:31:22.614]                   {
[10:31:22.614]                     do.call(function(...) {
[10:31:22.614]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.614]                       if (!identical(...future.globals.maxSize.org, 
[10:31:22.614]                         ...future.globals.maxSize)) {
[10:31:22.614]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.614]                         on.exit(options(oopts), add = TRUE)
[10:31:22.614]                       }
[10:31:22.614]                       {
[10:31:22.614]                         lapply(seq_along(...future.elements_ii), 
[10:31:22.614]                           FUN = function(jj) {
[10:31:22.614]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.614]                             ...future.FUN(...future.X_jj, ...)
[10:31:22.614]                           })
[10:31:22.614]                       }
[10:31:22.614]                     }, args = future.call.arguments)
[10:31:22.614]                   }
[10:31:22.614]                 }, immediateCondition = function(cond) {
[10:31:22.614]                   save_rds <- function (object, pathname, ...) 
[10:31:22.614]                   {
[10:31:22.614]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:22.614]                     if (file_test("-f", pathname_tmp)) {
[10:31:22.614]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.614]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:22.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.614]                         fi_tmp[["mtime"]])
[10:31:22.614]                     }
[10:31:22.614]                     tryCatch({
[10:31:22.614]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:22.614]                     }, error = function(ex) {
[10:31:22.614]                       msg <- conditionMessage(ex)
[10:31:22.614]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.614]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:22.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.614]                         fi_tmp[["mtime"]], msg)
[10:31:22.614]                       ex$message <- msg
[10:31:22.614]                       stop(ex)
[10:31:22.614]                     })
[10:31:22.614]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:22.614]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:22.614]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:22.614]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.614]                       fi <- file.info(pathname)
[10:31:22.614]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:22.614]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.614]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:22.614]                         fi[["size"]], fi[["mtime"]])
[10:31:22.614]                       stop(msg)
[10:31:22.614]                     }
[10:31:22.614]                     invisible(pathname)
[10:31:22.614]                   }
[10:31:22.614]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:22.614]                     rootPath = tempdir()) 
[10:31:22.614]                   {
[10:31:22.614]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:22.614]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:22.614]                       tmpdir = path, fileext = ".rds")
[10:31:22.614]                     save_rds(obj, file)
[10:31:22.614]                   }
[10:31:22.614]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:22.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.614]                   {
[10:31:22.614]                     inherits <- base::inherits
[10:31:22.614]                     invokeRestart <- base::invokeRestart
[10:31:22.614]                     is.null <- base::is.null
[10:31:22.614]                     muffled <- FALSE
[10:31:22.614]                     if (inherits(cond, "message")) {
[10:31:22.614]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:22.614]                       if (muffled) 
[10:31:22.614]                         invokeRestart("muffleMessage")
[10:31:22.614]                     }
[10:31:22.614]                     else if (inherits(cond, "warning")) {
[10:31:22.614]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:22.614]                       if (muffled) 
[10:31:22.614]                         invokeRestart("muffleWarning")
[10:31:22.614]                     }
[10:31:22.614]                     else if (inherits(cond, "condition")) {
[10:31:22.614]                       if (!is.null(pattern)) {
[10:31:22.614]                         computeRestarts <- base::computeRestarts
[10:31:22.614]                         grepl <- base::grepl
[10:31:22.614]                         restarts <- computeRestarts(cond)
[10:31:22.614]                         for (restart in restarts) {
[10:31:22.614]                           name <- restart$name
[10:31:22.614]                           if (is.null(name)) 
[10:31:22.614]                             next
[10:31:22.614]                           if (!grepl(pattern, name)) 
[10:31:22.614]                             next
[10:31:22.614]                           invokeRestart(restart)
[10:31:22.614]                           muffled <- TRUE
[10:31:22.614]                           break
[10:31:22.614]                         }
[10:31:22.614]                       }
[10:31:22.614]                     }
[10:31:22.614]                     invisible(muffled)
[10:31:22.614]                   }
[10:31:22.614]                   muffleCondition(cond)
[10:31:22.614]                 })
[10:31:22.614]             }))
[10:31:22.614]             future::FutureResult(value = ...future.value$value, 
[10:31:22.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.614]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.614]                     ...future.globalenv.names))
[10:31:22.614]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.614]         }, condition = base::local({
[10:31:22.614]             c <- base::c
[10:31:22.614]             inherits <- base::inherits
[10:31:22.614]             invokeRestart <- base::invokeRestart
[10:31:22.614]             length <- base::length
[10:31:22.614]             list <- base::list
[10:31:22.614]             seq.int <- base::seq.int
[10:31:22.614]             signalCondition <- base::signalCondition
[10:31:22.614]             sys.calls <- base::sys.calls
[10:31:22.614]             `[[` <- base::`[[`
[10:31:22.614]             `+` <- base::`+`
[10:31:22.614]             `<<-` <- base::`<<-`
[10:31:22.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.614]                   3L)]
[10:31:22.614]             }
[10:31:22.614]             function(cond) {
[10:31:22.614]                 is_error <- inherits(cond, "error")
[10:31:22.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.614]                   NULL)
[10:31:22.614]                 if (is_error) {
[10:31:22.614]                   sessionInformation <- function() {
[10:31:22.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.614]                       search = base::search(), system = base::Sys.info())
[10:31:22.614]                   }
[10:31:22.614]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.614]                     cond$call), session = sessionInformation(), 
[10:31:22.614]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.614]                   signalCondition(cond)
[10:31:22.614]                 }
[10:31:22.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.614]                 "immediateCondition"))) {
[10:31:22.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.614]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.614]                   if (TRUE && !signal) {
[10:31:22.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.614]                     {
[10:31:22.614]                       inherits <- base::inherits
[10:31:22.614]                       invokeRestart <- base::invokeRestart
[10:31:22.614]                       is.null <- base::is.null
[10:31:22.614]                       muffled <- FALSE
[10:31:22.614]                       if (inherits(cond, "message")) {
[10:31:22.614]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.614]                         if (muffled) 
[10:31:22.614]                           invokeRestart("muffleMessage")
[10:31:22.614]                       }
[10:31:22.614]                       else if (inherits(cond, "warning")) {
[10:31:22.614]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.614]                         if (muffled) 
[10:31:22.614]                           invokeRestart("muffleWarning")
[10:31:22.614]                       }
[10:31:22.614]                       else if (inherits(cond, "condition")) {
[10:31:22.614]                         if (!is.null(pattern)) {
[10:31:22.614]                           computeRestarts <- base::computeRestarts
[10:31:22.614]                           grepl <- base::grepl
[10:31:22.614]                           restarts <- computeRestarts(cond)
[10:31:22.614]                           for (restart in restarts) {
[10:31:22.614]                             name <- restart$name
[10:31:22.614]                             if (is.null(name)) 
[10:31:22.614]                               next
[10:31:22.614]                             if (!grepl(pattern, name)) 
[10:31:22.614]                               next
[10:31:22.614]                             invokeRestart(restart)
[10:31:22.614]                             muffled <- TRUE
[10:31:22.614]                             break
[10:31:22.614]                           }
[10:31:22.614]                         }
[10:31:22.614]                       }
[10:31:22.614]                       invisible(muffled)
[10:31:22.614]                     }
[10:31:22.614]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.614]                   }
[10:31:22.614]                 }
[10:31:22.614]                 else {
[10:31:22.614]                   if (TRUE) {
[10:31:22.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.614]                     {
[10:31:22.614]                       inherits <- base::inherits
[10:31:22.614]                       invokeRestart <- base::invokeRestart
[10:31:22.614]                       is.null <- base::is.null
[10:31:22.614]                       muffled <- FALSE
[10:31:22.614]                       if (inherits(cond, "message")) {
[10:31:22.614]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.614]                         if (muffled) 
[10:31:22.614]                           invokeRestart("muffleMessage")
[10:31:22.614]                       }
[10:31:22.614]                       else if (inherits(cond, "warning")) {
[10:31:22.614]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.614]                         if (muffled) 
[10:31:22.614]                           invokeRestart("muffleWarning")
[10:31:22.614]                       }
[10:31:22.614]                       else if (inherits(cond, "condition")) {
[10:31:22.614]                         if (!is.null(pattern)) {
[10:31:22.614]                           computeRestarts <- base::computeRestarts
[10:31:22.614]                           grepl <- base::grepl
[10:31:22.614]                           restarts <- computeRestarts(cond)
[10:31:22.614]                           for (restart in restarts) {
[10:31:22.614]                             name <- restart$name
[10:31:22.614]                             if (is.null(name)) 
[10:31:22.614]                               next
[10:31:22.614]                             if (!grepl(pattern, name)) 
[10:31:22.614]                               next
[10:31:22.614]                             invokeRestart(restart)
[10:31:22.614]                             muffled <- TRUE
[10:31:22.614]                             break
[10:31:22.614]                           }
[10:31:22.614]                         }
[10:31:22.614]                       }
[10:31:22.614]                       invisible(muffled)
[10:31:22.614]                     }
[10:31:22.614]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.614]                   }
[10:31:22.614]                 }
[10:31:22.614]             }
[10:31:22.614]         }))
[10:31:22.614]     }, error = function(ex) {
[10:31:22.614]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.614]                 ...future.rng), started = ...future.startTime, 
[10:31:22.614]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.614]             version = "1.8"), class = "FutureResult")
[10:31:22.614]     }, finally = {
[10:31:22.614]         if (!identical(...future.workdir, getwd())) 
[10:31:22.614]             setwd(...future.workdir)
[10:31:22.614]         {
[10:31:22.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.614]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.614]             }
[10:31:22.614]             base::options(...future.oldOptions)
[10:31:22.614]             if (.Platform$OS.type == "windows") {
[10:31:22.614]                 old_names <- names(...future.oldEnvVars)
[10:31:22.614]                 envs <- base::Sys.getenv()
[10:31:22.614]                 names <- names(envs)
[10:31:22.614]                 common <- intersect(names, old_names)
[10:31:22.614]                 added <- setdiff(names, old_names)
[10:31:22.614]                 removed <- setdiff(old_names, names)
[10:31:22.614]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.614]                   envs[common]]
[10:31:22.614]                 NAMES <- toupper(changed)
[10:31:22.614]                 args <- list()
[10:31:22.614]                 for (kk in seq_along(NAMES)) {
[10:31:22.614]                   name <- changed[[kk]]
[10:31:22.614]                   NAME <- NAMES[[kk]]
[10:31:22.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.614]                     next
[10:31:22.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.614]                 }
[10:31:22.614]                 NAMES <- toupper(added)
[10:31:22.614]                 for (kk in seq_along(NAMES)) {
[10:31:22.614]                   name <- added[[kk]]
[10:31:22.614]                   NAME <- NAMES[[kk]]
[10:31:22.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.614]                     next
[10:31:22.614]                   args[[name]] <- ""
[10:31:22.614]                 }
[10:31:22.614]                 NAMES <- toupper(removed)
[10:31:22.614]                 for (kk in seq_along(NAMES)) {
[10:31:22.614]                   name <- removed[[kk]]
[10:31:22.614]                   NAME <- NAMES[[kk]]
[10:31:22.614]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.614]                     next
[10:31:22.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.614]                 }
[10:31:22.614]                 if (length(args) > 0) 
[10:31:22.614]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.614]             }
[10:31:22.614]             else {
[10:31:22.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.614]             }
[10:31:22.614]             {
[10:31:22.614]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.614]                   0L) {
[10:31:22.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.614]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.614]                   base::options(opts)
[10:31:22.614]                 }
[10:31:22.614]                 {
[10:31:22.614]                   {
[10:31:22.614]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:22.614]                     NULL
[10:31:22.614]                   }
[10:31:22.614]                   options(future.plan = NULL)
[10:31:22.614]                   if (is.na(NA_character_)) 
[10:31:22.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.614]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.614]                     .init = FALSE)
[10:31:22.614]                 }
[10:31:22.614]             }
[10:31:22.614]         }
[10:31:22.614]     })
[10:31:22.614]     if (TRUE) {
[10:31:22.614]         base::sink(type = "output", split = FALSE)
[10:31:22.614]         if (TRUE) {
[10:31:22.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.614]         }
[10:31:22.614]         else {
[10:31:22.614]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.614]         }
[10:31:22.614]         base::close(...future.stdout)
[10:31:22.614]         ...future.stdout <- NULL
[10:31:22.614]     }
[10:31:22.614]     ...future.result$conditions <- ...future.conditions
[10:31:22.614]     ...future.result$finished <- base::Sys.time()
[10:31:22.614]     ...future.result
[10:31:22.614] }
[10:31:22.617] assign_globals() ...
[10:31:22.617] List of 11
[10:31:22.617]  $ ...future.FUN            :function (x, ...)  
[10:31:22.617]  $ x_FUN                    :function (x)  
[10:31:22.617]  $ times                    : int 0
[10:31:22.617]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.617]  $ stop_if_not              :function (...)  
[10:31:22.617]  $ dim                      : NULL
[10:31:22.617]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:22.617]  $ future.call.arguments    : list()
[10:31:22.617]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.617]  $ ...future.elements_ii    :List of 5
[10:31:22.617]   ..$ : int 6
[10:31:22.617]   ..$ : int 7
[10:31:22.617]   ..$ : int 8
[10:31:22.617]   ..$ : int 9
[10:31:22.617]   ..$ : int 10
[10:31:22.617]  $ ...future.seeds_ii       : NULL
[10:31:22.617]  $ ...future.globals.maxSize: NULL
[10:31:22.617]  - attr(*, "where")=List of 11
[10:31:22.617]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.617]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.617]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.617]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.617]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.617]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.617]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.617]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.617]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.617]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.617]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.617]  - attr(*, "resolved")= logi FALSE
[10:31:22.617]  - attr(*, "total_size")= num 95472
[10:31:22.617]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.617]  - attr(*, "already-done")= logi TRUE
[10:31:22.632] - copied ‘...future.FUN’ to environment
[10:31:22.632] - reassign environment for ‘x_FUN’
[10:31:22.632] - copied ‘x_FUN’ to environment
[10:31:22.633] - copied ‘times’ to environment
[10:31:22.633] - copied ‘stopf’ to environment
[10:31:22.633] - copied ‘stop_if_not’ to environment
[10:31:22.633] - copied ‘dim’ to environment
[10:31:22.633] - copied ‘valid_types’ to environment
[10:31:22.633] - copied ‘future.call.arguments’ to environment
[10:31:22.633] - copied ‘...future.elements_ii’ to environment
[10:31:22.634] - copied ‘...future.seeds_ii’ to environment
[10:31:22.634] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.634] assign_globals() ... done
[10:31:22.634] requestCore(): workers = 2
[10:31:22.636] MulticoreFuture started
[10:31:22.637] - Launch lazy future ... done
[10:31:22.637] run() for ‘MulticoreFuture’ ... done
[10:31:22.638] Created future:
[10:31:22.638] plan(): Setting new future strategy stack:
[10:31:22.638] List of future strategies:
[10:31:22.638] 1. sequential:
[10:31:22.638]    - args: function (..., envir = parent.frame())
[10:31:22.638]    - tweaked: FALSE
[10:31:22.638]    - call: NULL
[10:31:22.639] plan(): nbrOfWorkers() = 1
[10:31:22.642] plan(): Setting new future strategy stack:
[10:31:22.642] List of future strategies:
[10:31:22.642] 1. multicore:
[10:31:22.642]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:22.642]    - tweaked: FALSE
[10:31:22.642]    - call: plan(strategy)
[10:31:22.648] plan(): nbrOfWorkers() = 2
[10:31:22.638] MulticoreFuture:
[10:31:22.638] Label: ‘future_vapply-2’
[10:31:22.638] Expression:
[10:31:22.638] {
[10:31:22.638]     do.call(function(...) {
[10:31:22.638]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.638]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.638]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.638]             on.exit(options(oopts), add = TRUE)
[10:31:22.638]         }
[10:31:22.638]         {
[10:31:22.638]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.638]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.638]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.638]             })
[10:31:22.638]         }
[10:31:22.638]     }, args = future.call.arguments)
[10:31:22.638] }
[10:31:22.638] Lazy evaluation: FALSE
[10:31:22.638] Asynchronous evaluation: TRUE
[10:31:22.638] Local evaluation: TRUE
[10:31:22.638] Environment: R_GlobalEnv
[10:31:22.638] Capture standard output: TRUE
[10:31:22.638] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.638] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.638] Packages: 1 packages (‘future.apply’)
[10:31:22.638] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.638] Resolved: TRUE
[10:31:22.638] Value: <not collected>
[10:31:22.638] Conditions captured: <none>
[10:31:22.638] Early signaling: FALSE
[10:31:22.638] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.638] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.649] Chunk #2 of 2 ... DONE
[10:31:22.650] Launching 2 futures (chunks) ... DONE
[10:31:22.650] Resolving 2 futures (chunks) ...
[10:31:22.650] resolve() on list ...
[10:31:22.650]  recursive: 0
[10:31:22.651]  length: 2
[10:31:22.651] 
[10:31:22.651] Future #1
[10:31:22.651] result() for MulticoreFuture ...
[10:31:22.652] result() for MulticoreFuture ...
[10:31:22.652] result() for MulticoreFuture ... done
[10:31:22.653] result() for MulticoreFuture ... done
[10:31:22.653] result() for MulticoreFuture ...
[10:31:22.653] result() for MulticoreFuture ... done
[10:31:22.653] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:22.654] - nx: 2
[10:31:22.654] - relay: TRUE
[10:31:22.654] - stdout: TRUE
[10:31:22.654] - signal: TRUE
[10:31:22.654] - resignal: FALSE
[10:31:22.655] - force: TRUE
[10:31:22.655] - relayed: [n=2] FALSE, FALSE
[10:31:22.655] - queued futures: [n=2] FALSE, FALSE
[10:31:22.655]  - until=1
[10:31:22.655]  - relaying element #1
[10:31:22.656] result() for MulticoreFuture ...
[10:31:22.656] result() for MulticoreFuture ... done
[10:31:22.656] result() for MulticoreFuture ...
[10:31:22.656] result() for MulticoreFuture ... done
[10:31:22.657] result() for MulticoreFuture ...
[10:31:22.657] result() for MulticoreFuture ... done
[10:31:22.657] result() for MulticoreFuture ...
[10:31:22.657] result() for MulticoreFuture ... done
[10:31:22.657] - relayed: [n=2] TRUE, FALSE
[10:31:22.658] - queued futures: [n=2] TRUE, FALSE
[10:31:22.658] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:22.658]  length: 1 (resolved future 1)
[10:31:22.658] Future #2
[10:31:22.658] result() for MulticoreFuture ...
[10:31:22.659] result() for MulticoreFuture ...
[10:31:22.659] result() for MulticoreFuture ... done
[10:31:22.659] result() for MulticoreFuture ... done
[10:31:22.660] result() for MulticoreFuture ...
[10:31:22.660] result() for MulticoreFuture ... done
[10:31:22.660] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:22.660] - nx: 2
[10:31:22.660] - relay: TRUE
[10:31:22.660] - stdout: TRUE
[10:31:22.660] - signal: TRUE
[10:31:22.661] - resignal: FALSE
[10:31:22.661] - force: TRUE
[10:31:22.661] - relayed: [n=2] TRUE, FALSE
[10:31:22.661] - queued futures: [n=2] TRUE, FALSE
[10:31:22.661]  - until=2
[10:31:22.661]  - relaying element #2
[10:31:22.661] result() for MulticoreFuture ...
[10:31:22.661] result() for MulticoreFuture ... done
[10:31:22.662] result() for MulticoreFuture ...
[10:31:22.662] result() for MulticoreFuture ... done
[10:31:22.662] result() for MulticoreFuture ...
[10:31:22.662] result() for MulticoreFuture ... done
[10:31:22.662] result() for MulticoreFuture ...
[10:31:22.662] result() for MulticoreFuture ... done
[10:31:22.662] - relayed: [n=2] TRUE, TRUE
[10:31:22.662] - queued futures: [n=2] TRUE, TRUE
[10:31:22.663] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:22.663]  length: 0 (resolved future 2)
[10:31:22.663] Relaying remaining futures
[10:31:22.663] signalConditionsASAP(NULL, pos=0) ...
[10:31:22.663] - nx: 2
[10:31:22.663] - relay: TRUE
[10:31:22.663] - stdout: TRUE
[10:31:22.663] - signal: TRUE
[10:31:22.663] - resignal: FALSE
[10:31:22.663] - force: TRUE
[10:31:22.664] - relayed: [n=2] TRUE, TRUE
[10:31:22.664] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:22.664] - relayed: [n=2] TRUE, TRUE
[10:31:22.664] - queued futures: [n=2] TRUE, TRUE
[10:31:22.664] signalConditionsASAP(NULL, pos=0) ... done
[10:31:22.664] resolve() on list ... DONE
[10:31:22.664] result() for MulticoreFuture ...
[10:31:22.664] result() for MulticoreFuture ... done
[10:31:22.665] result() for MulticoreFuture ...
[10:31:22.665] result() for MulticoreFuture ... done
[10:31:22.665] result() for MulticoreFuture ...
[10:31:22.665] result() for MulticoreFuture ... done
[10:31:22.665] result() for MulticoreFuture ...
[10:31:22.665] result() for MulticoreFuture ... done
[10:31:22.665]  - Number of value chunks collected: 2
[10:31:22.665] Resolving 2 futures (chunks) ... DONE
[10:31:22.666] Reducing values from 2 chunks ...
[10:31:22.666]  - Number of values collected after concatenation: 10
[10:31:22.666]  - Number of values expected: 10
[10:31:22.666] Reducing values from 2 chunks ... DONE
[10:31:22.666] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[10:31:22.667] future_lapply() ...
[10:31:22.676] Number of chunks: 2
[10:31:22.676] getGlobalsAndPackagesXApply() ...
[10:31:22.677]  - future.globals: TRUE
[10:31:22.677] getGlobalsAndPackages() ...
[10:31:22.677] Searching for globals...
[10:31:22.682] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[10:31:22.682] Searching for globals ... DONE
[10:31:22.682] Resolving globals: FALSE
[10:31:22.683] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[10:31:22.684] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:22.684] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.684] - packages: [1] ‘future.apply’
[10:31:22.684] getGlobalsAndPackages() ... DONE
[10:31:22.684]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.684]  - needed namespaces: [n=1] ‘future.apply’
[10:31:22.684] Finding globals ... DONE
[10:31:22.684]  - use_args: TRUE
[10:31:22.685]  - Getting '...' globals ...
[10:31:22.685] resolve() on list ...
[10:31:22.685]  recursive: 0
[10:31:22.685]  length: 1
[10:31:22.685]  elements: ‘...’
[10:31:22.685]  length: 0 (resolved future 1)
[10:31:22.685] resolve() on list ... DONE
[10:31:22.686]    - '...' content: [n=0] 
[10:31:22.686] List of 1
[10:31:22.686]  $ ...: list()
[10:31:22.686]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.686]  - attr(*, "where")=List of 1
[10:31:22.686]   ..$ ...:<environment: 0x55de85afca38> 
[10:31:22.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.686]  - attr(*, "resolved")= logi TRUE
[10:31:22.686]  - attr(*, "total_size")= num NA
[10:31:22.688]  - Getting '...' globals ... DONE
[10:31:22.689] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:22.689] List of 8
[10:31:22.689]  $ ...future.FUN:function (x, ...)  
[10:31:22.689]  $ x_FUN        :function (x)  
[10:31:22.689]  $ times        : int 0
[10:31:22.689]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.689]  $ stop_if_not  :function (...)  
[10:31:22.689]  $ dim          : NULL
[10:31:22.689]  $ valid_types  : chr [1:2] "logical" "integer"
[10:31:22.689]  $ ...          : list()
[10:31:22.689]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.689]  - attr(*, "where")=List of 8
[10:31:22.689]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:22.689]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:22.689]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:22.689]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:22.689]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:22.689]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:22.689]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:22.689]   ..$ ...          :<environment: 0x55de85afca38> 
[10:31:22.689]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.689]  - attr(*, "resolved")= logi FALSE
[10:31:22.689]  - attr(*, "total_size")= num 95400
[10:31:22.694] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:22.694] getGlobalsAndPackagesXApply() ... DONE
[10:31:22.695] Number of futures (= number of chunks): 2
[10:31:22.695] Launching 2 futures (chunks) ...
[10:31:22.695] Chunk #1 of 2 ...
[10:31:22.695]  - Finding globals in 'X' for chunk #1 ...
[10:31:22.695] getGlobalsAndPackages() ...
[10:31:22.695] Searching for globals...
[10:31:22.695] 
[10:31:22.696] Searching for globals ... DONE
[10:31:22.696] - globals: [0] <none>
[10:31:22.696] getGlobalsAndPackages() ... DONE
[10:31:22.696]    + additional globals found: [n=0] 
[10:31:22.696]    + additional namespaces needed: [n=0] 
[10:31:22.696]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:22.696]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:22.696]  - seeds: <none>
[10:31:22.696]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.699] getGlobalsAndPackages() ...
[10:31:22.699] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.699] Resolving globals: FALSE
[10:31:22.699] Tweak future expression to call with '...' arguments ...
[10:31:22.699] {
[10:31:22.699]     do.call(function(...) {
[10:31:22.699]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.699]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.699]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.699]             on.exit(options(oopts), add = TRUE)
[10:31:22.699]         }
[10:31:22.699]         {
[10:31:22.699]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.699]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.699]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.699]             })
[10:31:22.699]         }
[10:31:22.699]     }, args = future.call.arguments)
[10:31:22.699] }
[10:31:22.699] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.700] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.700] - packages: [1] ‘future.apply’
[10:31:22.700] getGlobalsAndPackages() ... DONE
[10:31:22.701] run() for ‘Future’ ...
[10:31:22.701] - state: ‘created’
[10:31:22.701] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:22.705] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.706] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:22.706]   - Field: ‘label’
[10:31:22.706]   - Field: ‘local’
[10:31:22.706]   - Field: ‘owner’
[10:31:22.706]   - Field: ‘envir’
[10:31:22.706]   - Field: ‘workers’
[10:31:22.707]   - Field: ‘packages’
[10:31:22.707]   - Field: ‘gc’
[10:31:22.707]   - Field: ‘job’
[10:31:22.707]   - Field: ‘conditions’
[10:31:22.707]   - Field: ‘expr’
[10:31:22.707]   - Field: ‘uuid’
[10:31:22.707]   - Field: ‘seed’
[10:31:22.707]   - Field: ‘version’
[10:31:22.707]   - Field: ‘result’
[10:31:22.707]   - Field: ‘asynchronous’
[10:31:22.708]   - Field: ‘calls’
[10:31:22.708]   - Field: ‘globals’
[10:31:22.708]   - Field: ‘stdout’
[10:31:22.708]   - Field: ‘earlySignal’
[10:31:22.708]   - Field: ‘lazy’
[10:31:22.708]   - Field: ‘state’
[10:31:22.708] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:22.708] - Launch lazy future ...
[10:31:22.709] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.709] Packages needed by future strategies (n = 0): <none>
[10:31:22.709] {
[10:31:22.709]     {
[10:31:22.709]         {
[10:31:22.709]             ...future.startTime <- base::Sys.time()
[10:31:22.709]             {
[10:31:22.709]                 {
[10:31:22.709]                   {
[10:31:22.709]                     {
[10:31:22.709]                       {
[10:31:22.709]                         base::local({
[10:31:22.709]                           has_future <- base::requireNamespace("future", 
[10:31:22.709]                             quietly = TRUE)
[10:31:22.709]                           if (has_future) {
[10:31:22.709]                             ns <- base::getNamespace("future")
[10:31:22.709]                             version <- ns[[".package"]][["version"]]
[10:31:22.709]                             if (is.null(version)) 
[10:31:22.709]                               version <- utils::packageVersion("future")
[10:31:22.709]                           }
[10:31:22.709]                           else {
[10:31:22.709]                             version <- NULL
[10:31:22.709]                           }
[10:31:22.709]                           if (!has_future || version < "1.8.0") {
[10:31:22.709]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.709]                               "", base::R.version$version.string), 
[10:31:22.709]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:22.709]                                 base::R.version$platform, 8 * 
[10:31:22.709]                                   base::.Machine$sizeof.pointer), 
[10:31:22.709]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.709]                                 "release", "version")], collapse = " "), 
[10:31:22.709]                               hostname = base::Sys.info()[["nodename"]])
[10:31:22.709]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.709]                               info)
[10:31:22.709]                             info <- base::paste(info, collapse = "; ")
[10:31:22.709]                             if (!has_future) {
[10:31:22.709]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.709]                                 info)
[10:31:22.709]                             }
[10:31:22.709]                             else {
[10:31:22.709]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.709]                                 info, version)
[10:31:22.709]                             }
[10:31:22.709]                             base::stop(msg)
[10:31:22.709]                           }
[10:31:22.709]                         })
[10:31:22.709]                       }
[10:31:22.709]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:22.709]                       base::options(mc.cores = 1L)
[10:31:22.709]                     }
[10:31:22.709]                     base::local({
[10:31:22.709]                       for (pkg in "future.apply") {
[10:31:22.709]                         base::loadNamespace(pkg)
[10:31:22.709]                         base::library(pkg, character.only = TRUE)
[10:31:22.709]                       }
[10:31:22.709]                     })
[10:31:22.709]                   }
[10:31:22.709]                   ...future.strategy.old <- future::plan("list")
[10:31:22.709]                   options(future.plan = NULL)
[10:31:22.709]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.709]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.709]                 }
[10:31:22.709]                 ...future.workdir <- getwd()
[10:31:22.709]             }
[10:31:22.709]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.709]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.709]         }
[10:31:22.709]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.709]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:22.709]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.709]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.709]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.709]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.709]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.709]             base::names(...future.oldOptions))
[10:31:22.709]     }
[10:31:22.709]     if (FALSE) {
[10:31:22.709]     }
[10:31:22.709]     else {
[10:31:22.709]         if (TRUE) {
[10:31:22.709]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.709]                 open = "w")
[10:31:22.709]         }
[10:31:22.709]         else {
[10:31:22.709]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.709]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.709]         }
[10:31:22.709]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.709]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.709]             base::sink(type = "output", split = FALSE)
[10:31:22.709]             base::close(...future.stdout)
[10:31:22.709]         }, add = TRUE)
[10:31:22.709]     }
[10:31:22.709]     ...future.frame <- base::sys.nframe()
[10:31:22.709]     ...future.conditions <- base::list()
[10:31:22.709]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.709]     if (FALSE) {
[10:31:22.709]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.709]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.709]     }
[10:31:22.709]     ...future.result <- base::tryCatch({
[10:31:22.709]         base::withCallingHandlers({
[10:31:22.709]             ...future.value <- base::withVisible(base::local({
[10:31:22.709]                 withCallingHandlers({
[10:31:22.709]                   {
[10:31:22.709]                     do.call(function(...) {
[10:31:22.709]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.709]                       if (!identical(...future.globals.maxSize.org, 
[10:31:22.709]                         ...future.globals.maxSize)) {
[10:31:22.709]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.709]                         on.exit(options(oopts), add = TRUE)
[10:31:22.709]                       }
[10:31:22.709]                       {
[10:31:22.709]                         lapply(seq_along(...future.elements_ii), 
[10:31:22.709]                           FUN = function(jj) {
[10:31:22.709]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.709]                             ...future.FUN(...future.X_jj, ...)
[10:31:22.709]                           })
[10:31:22.709]                       }
[10:31:22.709]                     }, args = future.call.arguments)
[10:31:22.709]                   }
[10:31:22.709]                 }, immediateCondition = function(cond) {
[10:31:22.709]                   save_rds <- function (object, pathname, ...) 
[10:31:22.709]                   {
[10:31:22.709]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:22.709]                     if (file_test("-f", pathname_tmp)) {
[10:31:22.709]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.709]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:22.709]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.709]                         fi_tmp[["mtime"]])
[10:31:22.709]                     }
[10:31:22.709]                     tryCatch({
[10:31:22.709]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:22.709]                     }, error = function(ex) {
[10:31:22.709]                       msg <- conditionMessage(ex)
[10:31:22.709]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.709]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:22.709]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.709]                         fi_tmp[["mtime"]], msg)
[10:31:22.709]                       ex$message <- msg
[10:31:22.709]                       stop(ex)
[10:31:22.709]                     })
[10:31:22.709]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:22.709]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:22.709]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:22.709]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.709]                       fi <- file.info(pathname)
[10:31:22.709]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:22.709]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.709]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:22.709]                         fi[["size"]], fi[["mtime"]])
[10:31:22.709]                       stop(msg)
[10:31:22.709]                     }
[10:31:22.709]                     invisible(pathname)
[10:31:22.709]                   }
[10:31:22.709]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:22.709]                     rootPath = tempdir()) 
[10:31:22.709]                   {
[10:31:22.709]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:22.709]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:22.709]                       tmpdir = path, fileext = ".rds")
[10:31:22.709]                     save_rds(obj, file)
[10:31:22.709]                   }
[10:31:22.709]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:22.709]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.709]                   {
[10:31:22.709]                     inherits <- base::inherits
[10:31:22.709]                     invokeRestart <- base::invokeRestart
[10:31:22.709]                     is.null <- base::is.null
[10:31:22.709]                     muffled <- FALSE
[10:31:22.709]                     if (inherits(cond, "message")) {
[10:31:22.709]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:22.709]                       if (muffled) 
[10:31:22.709]                         invokeRestart("muffleMessage")
[10:31:22.709]                     }
[10:31:22.709]                     else if (inherits(cond, "warning")) {
[10:31:22.709]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:22.709]                       if (muffled) 
[10:31:22.709]                         invokeRestart("muffleWarning")
[10:31:22.709]                     }
[10:31:22.709]                     else if (inherits(cond, "condition")) {
[10:31:22.709]                       if (!is.null(pattern)) {
[10:31:22.709]                         computeRestarts <- base::computeRestarts
[10:31:22.709]                         grepl <- base::grepl
[10:31:22.709]                         restarts <- computeRestarts(cond)
[10:31:22.709]                         for (restart in restarts) {
[10:31:22.709]                           name <- restart$name
[10:31:22.709]                           if (is.null(name)) 
[10:31:22.709]                             next
[10:31:22.709]                           if (!grepl(pattern, name)) 
[10:31:22.709]                             next
[10:31:22.709]                           invokeRestart(restart)
[10:31:22.709]                           muffled <- TRUE
[10:31:22.709]                           break
[10:31:22.709]                         }
[10:31:22.709]                       }
[10:31:22.709]                     }
[10:31:22.709]                     invisible(muffled)
[10:31:22.709]                   }
[10:31:22.709]                   muffleCondition(cond)
[10:31:22.709]                 })
[10:31:22.709]             }))
[10:31:22.709]             future::FutureResult(value = ...future.value$value, 
[10:31:22.709]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.709]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.709]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.709]                     ...future.globalenv.names))
[10:31:22.709]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.709]         }, condition = base::local({
[10:31:22.709]             c <- base::c
[10:31:22.709]             inherits <- base::inherits
[10:31:22.709]             invokeRestart <- base::invokeRestart
[10:31:22.709]             length <- base::length
[10:31:22.709]             list <- base::list
[10:31:22.709]             seq.int <- base::seq.int
[10:31:22.709]             signalCondition <- base::signalCondition
[10:31:22.709]             sys.calls <- base::sys.calls
[10:31:22.709]             `[[` <- base::`[[`
[10:31:22.709]             `+` <- base::`+`
[10:31:22.709]             `<<-` <- base::`<<-`
[10:31:22.709]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.709]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.709]                   3L)]
[10:31:22.709]             }
[10:31:22.709]             function(cond) {
[10:31:22.709]                 is_error <- inherits(cond, "error")
[10:31:22.709]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.709]                   NULL)
[10:31:22.709]                 if (is_error) {
[10:31:22.709]                   sessionInformation <- function() {
[10:31:22.709]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.709]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.709]                       search = base::search(), system = base::Sys.info())
[10:31:22.709]                   }
[10:31:22.709]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.709]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.709]                     cond$call), session = sessionInformation(), 
[10:31:22.709]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.709]                   signalCondition(cond)
[10:31:22.709]                 }
[10:31:22.709]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.709]                 "immediateCondition"))) {
[10:31:22.709]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.709]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.709]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.709]                   if (TRUE && !signal) {
[10:31:22.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.709]                     {
[10:31:22.709]                       inherits <- base::inherits
[10:31:22.709]                       invokeRestart <- base::invokeRestart
[10:31:22.709]                       is.null <- base::is.null
[10:31:22.709]                       muffled <- FALSE
[10:31:22.709]                       if (inherits(cond, "message")) {
[10:31:22.709]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.709]                         if (muffled) 
[10:31:22.709]                           invokeRestart("muffleMessage")
[10:31:22.709]                       }
[10:31:22.709]                       else if (inherits(cond, "warning")) {
[10:31:22.709]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.709]                         if (muffled) 
[10:31:22.709]                           invokeRestart("muffleWarning")
[10:31:22.709]                       }
[10:31:22.709]                       else if (inherits(cond, "condition")) {
[10:31:22.709]                         if (!is.null(pattern)) {
[10:31:22.709]                           computeRestarts <- base::computeRestarts
[10:31:22.709]                           grepl <- base::grepl
[10:31:22.709]                           restarts <- computeRestarts(cond)
[10:31:22.709]                           for (restart in restarts) {
[10:31:22.709]                             name <- restart$name
[10:31:22.709]                             if (is.null(name)) 
[10:31:22.709]                               next
[10:31:22.709]                             if (!grepl(pattern, name)) 
[10:31:22.709]                               next
[10:31:22.709]                             invokeRestart(restart)
[10:31:22.709]                             muffled <- TRUE
[10:31:22.709]                             break
[10:31:22.709]                           }
[10:31:22.709]                         }
[10:31:22.709]                       }
[10:31:22.709]                       invisible(muffled)
[10:31:22.709]                     }
[10:31:22.709]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.709]                   }
[10:31:22.709]                 }
[10:31:22.709]                 else {
[10:31:22.709]                   if (TRUE) {
[10:31:22.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.709]                     {
[10:31:22.709]                       inherits <- base::inherits
[10:31:22.709]                       invokeRestart <- base::invokeRestart
[10:31:22.709]                       is.null <- base::is.null
[10:31:22.709]                       muffled <- FALSE
[10:31:22.709]                       if (inherits(cond, "message")) {
[10:31:22.709]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.709]                         if (muffled) 
[10:31:22.709]                           invokeRestart("muffleMessage")
[10:31:22.709]                       }
[10:31:22.709]                       else if (inherits(cond, "warning")) {
[10:31:22.709]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.709]                         if (muffled) 
[10:31:22.709]                           invokeRestart("muffleWarning")
[10:31:22.709]                       }
[10:31:22.709]                       else if (inherits(cond, "condition")) {
[10:31:22.709]                         if (!is.null(pattern)) {
[10:31:22.709]                           computeRestarts <- base::computeRestarts
[10:31:22.709]                           grepl <- base::grepl
[10:31:22.709]                           restarts <- computeRestarts(cond)
[10:31:22.709]                           for (restart in restarts) {
[10:31:22.709]                             name <- restart$name
[10:31:22.709]                             if (is.null(name)) 
[10:31:22.709]                               next
[10:31:22.709]                             if (!grepl(pattern, name)) 
[10:31:22.709]                               next
[10:31:22.709]                             invokeRestart(restart)
[10:31:22.709]                             muffled <- TRUE
[10:31:22.709]                             break
[10:31:22.709]                           }
[10:31:22.709]                         }
[10:31:22.709]                       }
[10:31:22.709]                       invisible(muffled)
[10:31:22.709]                     }
[10:31:22.709]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.709]                   }
[10:31:22.709]                 }
[10:31:22.709]             }
[10:31:22.709]         }))
[10:31:22.709]     }, error = function(ex) {
[10:31:22.709]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.709]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.709]                 ...future.rng), started = ...future.startTime, 
[10:31:22.709]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.709]             version = "1.8"), class = "FutureResult")
[10:31:22.709]     }, finally = {
[10:31:22.709]         if (!identical(...future.workdir, getwd())) 
[10:31:22.709]             setwd(...future.workdir)
[10:31:22.709]         {
[10:31:22.709]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.709]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.709]             }
[10:31:22.709]             base::options(...future.oldOptions)
[10:31:22.709]             if (.Platform$OS.type == "windows") {
[10:31:22.709]                 old_names <- names(...future.oldEnvVars)
[10:31:22.709]                 envs <- base::Sys.getenv()
[10:31:22.709]                 names <- names(envs)
[10:31:22.709]                 common <- intersect(names, old_names)
[10:31:22.709]                 added <- setdiff(names, old_names)
[10:31:22.709]                 removed <- setdiff(old_names, names)
[10:31:22.709]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.709]                   envs[common]]
[10:31:22.709]                 NAMES <- toupper(changed)
[10:31:22.709]                 args <- list()
[10:31:22.709]                 for (kk in seq_along(NAMES)) {
[10:31:22.709]                   name <- changed[[kk]]
[10:31:22.709]                   NAME <- NAMES[[kk]]
[10:31:22.709]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.709]                     next
[10:31:22.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.709]                 }
[10:31:22.709]                 NAMES <- toupper(added)
[10:31:22.709]                 for (kk in seq_along(NAMES)) {
[10:31:22.709]                   name <- added[[kk]]
[10:31:22.709]                   NAME <- NAMES[[kk]]
[10:31:22.709]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.709]                     next
[10:31:22.709]                   args[[name]] <- ""
[10:31:22.709]                 }
[10:31:22.709]                 NAMES <- toupper(removed)
[10:31:22.709]                 for (kk in seq_along(NAMES)) {
[10:31:22.709]                   name <- removed[[kk]]
[10:31:22.709]                   NAME <- NAMES[[kk]]
[10:31:22.709]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.709]                     next
[10:31:22.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.709]                 }
[10:31:22.709]                 if (length(args) > 0) 
[10:31:22.709]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.709]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.709]             }
[10:31:22.709]             else {
[10:31:22.709]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.709]             }
[10:31:22.709]             {
[10:31:22.709]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.709]                   0L) {
[10:31:22.709]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.709]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.709]                   base::options(opts)
[10:31:22.709]                 }
[10:31:22.709]                 {
[10:31:22.709]                   {
[10:31:22.709]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:22.709]                     NULL
[10:31:22.709]                   }
[10:31:22.709]                   options(future.plan = NULL)
[10:31:22.709]                   if (is.na(NA_character_)) 
[10:31:22.709]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.709]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.709]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.709]                     .init = FALSE)
[10:31:22.709]                 }
[10:31:22.709]             }
[10:31:22.709]         }
[10:31:22.709]     })
[10:31:22.709]     if (TRUE) {
[10:31:22.709]         base::sink(type = "output", split = FALSE)
[10:31:22.709]         if (TRUE) {
[10:31:22.709]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.709]         }
[10:31:22.709]         else {
[10:31:22.709]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.709]         }
[10:31:22.709]         base::close(...future.stdout)
[10:31:22.709]         ...future.stdout <- NULL
[10:31:22.709]     }
[10:31:22.709]     ...future.result$conditions <- ...future.conditions
[10:31:22.709]     ...future.result$finished <- base::Sys.time()
[10:31:22.709]     ...future.result
[10:31:22.709] }
[10:31:22.712] assign_globals() ...
[10:31:22.712] List of 11
[10:31:22.712]  $ ...future.FUN            :function (x, ...)  
[10:31:22.712]  $ x_FUN                    :function (x)  
[10:31:22.712]  $ times                    : int 0
[10:31:22.712]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.712]  $ stop_if_not              :function (...)  
[10:31:22.712]  $ dim                      : NULL
[10:31:22.712]  $ valid_types              : chr [1:2] "logical" "integer"
[10:31:22.712]  $ future.call.arguments    : list()
[10:31:22.712]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.712]  $ ...future.elements_ii    :List of 5
[10:31:22.712]   ..$ : int 1
[10:31:22.712]   ..$ : int 2
[10:31:22.712]   ..$ : int 3
[10:31:22.712]   ..$ : int 4
[10:31:22.712]   ..$ : int 5
[10:31:22.712]  $ ...future.seeds_ii       : NULL
[10:31:22.712]  $ ...future.globals.maxSize: NULL
[10:31:22.712]  - attr(*, "where")=List of 11
[10:31:22.712]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.712]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.712]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.712]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.712]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.712]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.712]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.712]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.712]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.712]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.712]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.712]  - attr(*, "resolved")= logi FALSE
[10:31:22.712]  - attr(*, "total_size")= num 95400
[10:31:22.712]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.712]  - attr(*, "already-done")= logi TRUE
[10:31:22.721] - copied ‘...future.FUN’ to environment
[10:31:22.721] - reassign environment for ‘x_FUN’
[10:31:22.721] - copied ‘x_FUN’ to environment
[10:31:22.721] - copied ‘times’ to environment
[10:31:22.721] - copied ‘stopf’ to environment
[10:31:22.721] - copied ‘stop_if_not’ to environment
[10:31:22.722] - copied ‘dim’ to environment
[10:31:22.722] - copied ‘valid_types’ to environment
[10:31:22.722] - copied ‘future.call.arguments’ to environment
[10:31:22.722] - copied ‘...future.elements_ii’ to environment
[10:31:22.722] - copied ‘...future.seeds_ii’ to environment
[10:31:22.722] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.722] assign_globals() ... done
[10:31:22.722] requestCore(): workers = 2
[10:31:22.725] MulticoreFuture started
[10:31:22.725] - Launch lazy future ... done
[10:31:22.725] run() for ‘MulticoreFuture’ ... done
[10:31:22.725] Created future:
[10:31:22.726] plan(): Setting new future strategy stack:
[10:31:22.726] List of future strategies:
[10:31:22.726] 1. sequential:
[10:31:22.726]    - args: function (..., envir = parent.frame())
[10:31:22.726]    - tweaked: FALSE
[10:31:22.726]    - call: NULL
[10:31:22.727] plan(): nbrOfWorkers() = 1
[10:31:22.733] plan(): Setting new future strategy stack:
[10:31:22.733] List of future strategies:
[10:31:22.733] 1. multicore:
[10:31:22.733]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:22.733]    - tweaked: FALSE
[10:31:22.733]    - call: plan(strategy)
[10:31:22.740] plan(): nbrOfWorkers() = 2
[10:31:22.726] MulticoreFuture:
[10:31:22.726] Label: ‘future_vapply-1’
[10:31:22.726] Expression:
[10:31:22.726] {
[10:31:22.726]     do.call(function(...) {
[10:31:22.726]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.726]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.726]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.726]             on.exit(options(oopts), add = TRUE)
[10:31:22.726]         }
[10:31:22.726]         {
[10:31:22.726]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.726]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.726]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.726]             })
[10:31:22.726]         }
[10:31:22.726]     }, args = future.call.arguments)
[10:31:22.726] }
[10:31:22.726] Lazy evaluation: FALSE
[10:31:22.726] Asynchronous evaluation: TRUE
[10:31:22.726] Local evaluation: TRUE
[10:31:22.726] Environment: R_GlobalEnv
[10:31:22.726] Capture standard output: TRUE
[10:31:22.726] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.726] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.726] Packages: 1 packages (‘future.apply’)
[10:31:22.726] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.726] Resolved: TRUE
[10:31:22.726] Value: <not collected>
[10:31:22.726] Conditions captured: <none>
[10:31:22.726] Early signaling: FALSE
[10:31:22.726] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.726] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.742] Chunk #1 of 2 ... DONE
[10:31:22.742] Chunk #2 of 2 ...
[10:31:22.742]  - Finding globals in 'X' for chunk #2 ...
[10:31:22.742] getGlobalsAndPackages() ...
[10:31:22.743] Searching for globals...
[10:31:22.743] 
[10:31:22.744] Searching for globals ... DONE
[10:31:22.744] - globals: [0] <none>
[10:31:22.744] getGlobalsAndPackages() ... DONE
[10:31:22.744]    + additional globals found: [n=0] 
[10:31:22.744]    + additional namespaces needed: [n=0] 
[10:31:22.745]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:22.745]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:22.745]  - seeds: <none>
[10:31:22.745]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.746] getGlobalsAndPackages() ...
[10:31:22.746] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.746] Resolving globals: FALSE
[10:31:22.747] Tweak future expression to call with '...' arguments ...
[10:31:22.747] {
[10:31:22.747]     do.call(function(...) {
[10:31:22.747]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.747]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.747]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.747]             on.exit(options(oopts), add = TRUE)
[10:31:22.747]         }
[10:31:22.747]         {
[10:31:22.747]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.747]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.747]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.747]             })
[10:31:22.747]         }
[10:31:22.747]     }, args = future.call.arguments)
[10:31:22.747] }
[10:31:22.747] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.749] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.749] - packages: [1] ‘future.apply’
[10:31:22.749] getGlobalsAndPackages() ... DONE
[10:31:22.750] run() for ‘Future’ ...
[10:31:22.750] - state: ‘created’
[10:31:22.750] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:22.755] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.755] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:22.755]   - Field: ‘label’
[10:31:22.756]   - Field: ‘local’
[10:31:22.756]   - Field: ‘owner’
[10:31:22.756]   - Field: ‘envir’
[10:31:22.756]   - Field: ‘workers’
[10:31:22.757]   - Field: ‘packages’
[10:31:22.757]   - Field: ‘gc’
[10:31:22.757]   - Field: ‘job’
[10:31:22.757]   - Field: ‘conditions’
[10:31:22.757]   - Field: ‘expr’
[10:31:22.757]   - Field: ‘uuid’
[10:31:22.757]   - Field: ‘seed’
[10:31:22.758]   - Field: ‘version’
[10:31:22.758]   - Field: ‘result’
[10:31:22.758]   - Field: ‘asynchronous’
[10:31:22.758]   - Field: ‘calls’
[10:31:22.758]   - Field: ‘globals’
[10:31:22.758]   - Field: ‘stdout’
[10:31:22.758]   - Field: ‘earlySignal’
[10:31:22.759]   - Field: ‘lazy’
[10:31:22.759]   - Field: ‘state’
[10:31:22.759] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:22.759] - Launch lazy future ...
[10:31:22.759] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.760] Packages needed by future strategies (n = 0): <none>
[10:31:22.760] {
[10:31:22.760]     {
[10:31:22.760]         {
[10:31:22.760]             ...future.startTime <- base::Sys.time()
[10:31:22.760]             {
[10:31:22.760]                 {
[10:31:22.760]                   {
[10:31:22.760]                     {
[10:31:22.760]                       {
[10:31:22.760]                         base::local({
[10:31:22.760]                           has_future <- base::requireNamespace("future", 
[10:31:22.760]                             quietly = TRUE)
[10:31:22.760]                           if (has_future) {
[10:31:22.760]                             ns <- base::getNamespace("future")
[10:31:22.760]                             version <- ns[[".package"]][["version"]]
[10:31:22.760]                             if (is.null(version)) 
[10:31:22.760]                               version <- utils::packageVersion("future")
[10:31:22.760]                           }
[10:31:22.760]                           else {
[10:31:22.760]                             version <- NULL
[10:31:22.760]                           }
[10:31:22.760]                           if (!has_future || version < "1.8.0") {
[10:31:22.760]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.760]                               "", base::R.version$version.string), 
[10:31:22.760]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:22.760]                                 base::R.version$platform, 8 * 
[10:31:22.760]                                   base::.Machine$sizeof.pointer), 
[10:31:22.760]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.760]                                 "release", "version")], collapse = " "), 
[10:31:22.760]                               hostname = base::Sys.info()[["nodename"]])
[10:31:22.760]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.760]                               info)
[10:31:22.760]                             info <- base::paste(info, collapse = "; ")
[10:31:22.760]                             if (!has_future) {
[10:31:22.760]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.760]                                 info)
[10:31:22.760]                             }
[10:31:22.760]                             else {
[10:31:22.760]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.760]                                 info, version)
[10:31:22.760]                             }
[10:31:22.760]                             base::stop(msg)
[10:31:22.760]                           }
[10:31:22.760]                         })
[10:31:22.760]                       }
[10:31:22.760]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:22.760]                       base::options(mc.cores = 1L)
[10:31:22.760]                     }
[10:31:22.760]                     base::local({
[10:31:22.760]                       for (pkg in "future.apply") {
[10:31:22.760]                         base::loadNamespace(pkg)
[10:31:22.760]                         base::library(pkg, character.only = TRUE)
[10:31:22.760]                       }
[10:31:22.760]                     })
[10:31:22.760]                   }
[10:31:22.760]                   ...future.strategy.old <- future::plan("list")
[10:31:22.760]                   options(future.plan = NULL)
[10:31:22.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.760]                 }
[10:31:22.760]                 ...future.workdir <- getwd()
[10:31:22.760]             }
[10:31:22.760]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.760]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.760]         }
[10:31:22.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.760]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:22.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.760]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.760]             base::names(...future.oldOptions))
[10:31:22.760]     }
[10:31:22.760]     if (FALSE) {
[10:31:22.760]     }
[10:31:22.760]     else {
[10:31:22.760]         if (TRUE) {
[10:31:22.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.760]                 open = "w")
[10:31:22.760]         }
[10:31:22.760]         else {
[10:31:22.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.760]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.760]         }
[10:31:22.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.760]             base::sink(type = "output", split = FALSE)
[10:31:22.760]             base::close(...future.stdout)
[10:31:22.760]         }, add = TRUE)
[10:31:22.760]     }
[10:31:22.760]     ...future.frame <- base::sys.nframe()
[10:31:22.760]     ...future.conditions <- base::list()
[10:31:22.760]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.760]     if (FALSE) {
[10:31:22.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.760]     }
[10:31:22.760]     ...future.result <- base::tryCatch({
[10:31:22.760]         base::withCallingHandlers({
[10:31:22.760]             ...future.value <- base::withVisible(base::local({
[10:31:22.760]                 withCallingHandlers({
[10:31:22.760]                   {
[10:31:22.760]                     do.call(function(...) {
[10:31:22.760]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.760]                       if (!identical(...future.globals.maxSize.org, 
[10:31:22.760]                         ...future.globals.maxSize)) {
[10:31:22.760]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.760]                         on.exit(options(oopts), add = TRUE)
[10:31:22.760]                       }
[10:31:22.760]                       {
[10:31:22.760]                         lapply(seq_along(...future.elements_ii), 
[10:31:22.760]                           FUN = function(jj) {
[10:31:22.760]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.760]                             ...future.FUN(...future.X_jj, ...)
[10:31:22.760]                           })
[10:31:22.760]                       }
[10:31:22.760]                     }, args = future.call.arguments)
[10:31:22.760]                   }
[10:31:22.760]                 }, immediateCondition = function(cond) {
[10:31:22.760]                   save_rds <- function (object, pathname, ...) 
[10:31:22.760]                   {
[10:31:22.760]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:22.760]                     if (file_test("-f", pathname_tmp)) {
[10:31:22.760]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.760]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:22.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.760]                         fi_tmp[["mtime"]])
[10:31:22.760]                     }
[10:31:22.760]                     tryCatch({
[10:31:22.760]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:22.760]                     }, error = function(ex) {
[10:31:22.760]                       msg <- conditionMessage(ex)
[10:31:22.760]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.760]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:22.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.760]                         fi_tmp[["mtime"]], msg)
[10:31:22.760]                       ex$message <- msg
[10:31:22.760]                       stop(ex)
[10:31:22.760]                     })
[10:31:22.760]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:22.760]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:22.760]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:22.760]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.760]                       fi <- file.info(pathname)
[10:31:22.760]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:22.760]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.760]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:22.760]                         fi[["size"]], fi[["mtime"]])
[10:31:22.760]                       stop(msg)
[10:31:22.760]                     }
[10:31:22.760]                     invisible(pathname)
[10:31:22.760]                   }
[10:31:22.760]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:22.760]                     rootPath = tempdir()) 
[10:31:22.760]                   {
[10:31:22.760]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:22.760]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:22.760]                       tmpdir = path, fileext = ".rds")
[10:31:22.760]                     save_rds(obj, file)
[10:31:22.760]                   }
[10:31:22.760]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:22.760]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.760]                   {
[10:31:22.760]                     inherits <- base::inherits
[10:31:22.760]                     invokeRestart <- base::invokeRestart
[10:31:22.760]                     is.null <- base::is.null
[10:31:22.760]                     muffled <- FALSE
[10:31:22.760]                     if (inherits(cond, "message")) {
[10:31:22.760]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:22.760]                       if (muffled) 
[10:31:22.760]                         invokeRestart("muffleMessage")
[10:31:22.760]                     }
[10:31:22.760]                     else if (inherits(cond, "warning")) {
[10:31:22.760]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:22.760]                       if (muffled) 
[10:31:22.760]                         invokeRestart("muffleWarning")
[10:31:22.760]                     }
[10:31:22.760]                     else if (inherits(cond, "condition")) {
[10:31:22.760]                       if (!is.null(pattern)) {
[10:31:22.760]                         computeRestarts <- base::computeRestarts
[10:31:22.760]                         grepl <- base::grepl
[10:31:22.760]                         restarts <- computeRestarts(cond)
[10:31:22.760]                         for (restart in restarts) {
[10:31:22.760]                           name <- restart$name
[10:31:22.760]                           if (is.null(name)) 
[10:31:22.760]                             next
[10:31:22.760]                           if (!grepl(pattern, name)) 
[10:31:22.760]                             next
[10:31:22.760]                           invokeRestart(restart)
[10:31:22.760]                           muffled <- TRUE
[10:31:22.760]                           break
[10:31:22.760]                         }
[10:31:22.760]                       }
[10:31:22.760]                     }
[10:31:22.760]                     invisible(muffled)
[10:31:22.760]                   }
[10:31:22.760]                   muffleCondition(cond)
[10:31:22.760]                 })
[10:31:22.760]             }))
[10:31:22.760]             future::FutureResult(value = ...future.value$value, 
[10:31:22.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.760]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.760]                     ...future.globalenv.names))
[10:31:22.760]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.760]         }, condition = base::local({
[10:31:22.760]             c <- base::c
[10:31:22.760]             inherits <- base::inherits
[10:31:22.760]             invokeRestart <- base::invokeRestart
[10:31:22.760]             length <- base::length
[10:31:22.760]             list <- base::list
[10:31:22.760]             seq.int <- base::seq.int
[10:31:22.760]             signalCondition <- base::signalCondition
[10:31:22.760]             sys.calls <- base::sys.calls
[10:31:22.760]             `[[` <- base::`[[`
[10:31:22.760]             `+` <- base::`+`
[10:31:22.760]             `<<-` <- base::`<<-`
[10:31:22.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.760]                   3L)]
[10:31:22.760]             }
[10:31:22.760]             function(cond) {
[10:31:22.760]                 is_error <- inherits(cond, "error")
[10:31:22.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.760]                   NULL)
[10:31:22.760]                 if (is_error) {
[10:31:22.760]                   sessionInformation <- function() {
[10:31:22.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.760]                       search = base::search(), system = base::Sys.info())
[10:31:22.760]                   }
[10:31:22.760]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.760]                     cond$call), session = sessionInformation(), 
[10:31:22.760]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.760]                   signalCondition(cond)
[10:31:22.760]                 }
[10:31:22.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.760]                 "immediateCondition"))) {
[10:31:22.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.760]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.760]                   if (TRUE && !signal) {
[10:31:22.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.760]                     {
[10:31:22.760]                       inherits <- base::inherits
[10:31:22.760]                       invokeRestart <- base::invokeRestart
[10:31:22.760]                       is.null <- base::is.null
[10:31:22.760]                       muffled <- FALSE
[10:31:22.760]                       if (inherits(cond, "message")) {
[10:31:22.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.760]                         if (muffled) 
[10:31:22.760]                           invokeRestart("muffleMessage")
[10:31:22.760]                       }
[10:31:22.760]                       else if (inherits(cond, "warning")) {
[10:31:22.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.760]                         if (muffled) 
[10:31:22.760]                           invokeRestart("muffleWarning")
[10:31:22.760]                       }
[10:31:22.760]                       else if (inherits(cond, "condition")) {
[10:31:22.760]                         if (!is.null(pattern)) {
[10:31:22.760]                           computeRestarts <- base::computeRestarts
[10:31:22.760]                           grepl <- base::grepl
[10:31:22.760]                           restarts <- computeRestarts(cond)
[10:31:22.760]                           for (restart in restarts) {
[10:31:22.760]                             name <- restart$name
[10:31:22.760]                             if (is.null(name)) 
[10:31:22.760]                               next
[10:31:22.760]                             if (!grepl(pattern, name)) 
[10:31:22.760]                               next
[10:31:22.760]                             invokeRestart(restart)
[10:31:22.760]                             muffled <- TRUE
[10:31:22.760]                             break
[10:31:22.760]                           }
[10:31:22.760]                         }
[10:31:22.760]                       }
[10:31:22.760]                       invisible(muffled)
[10:31:22.760]                     }
[10:31:22.760]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.760]                   }
[10:31:22.760]                 }
[10:31:22.760]                 else {
[10:31:22.760]                   if (TRUE) {
[10:31:22.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.760]                     {
[10:31:22.760]                       inherits <- base::inherits
[10:31:22.760]                       invokeRestart <- base::invokeRestart
[10:31:22.760]                       is.null <- base::is.null
[10:31:22.760]                       muffled <- FALSE
[10:31:22.760]                       if (inherits(cond, "message")) {
[10:31:22.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.760]                         if (muffled) 
[10:31:22.760]                           invokeRestart("muffleMessage")
[10:31:22.760]                       }
[10:31:22.760]                       else if (inherits(cond, "warning")) {
[10:31:22.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.760]                         if (muffled) 
[10:31:22.760]                           invokeRestart("muffleWarning")
[10:31:22.760]                       }
[10:31:22.760]                       else if (inherits(cond, "condition")) {
[10:31:22.760]                         if (!is.null(pattern)) {
[10:31:22.760]                           computeRestarts <- base::computeRestarts
[10:31:22.760]                           grepl <- base::grepl
[10:31:22.760]                           restarts <- computeRestarts(cond)
[10:31:22.760]                           for (restart in restarts) {
[10:31:22.760]                             name <- restart$name
[10:31:22.760]                             if (is.null(name)) 
[10:31:22.760]                               next
[10:31:22.760]                             if (!grepl(pattern, name)) 
[10:31:22.760]                               next
[10:31:22.760]                             invokeRestart(restart)
[10:31:22.760]                             muffled <- TRUE
[10:31:22.760]                             break
[10:31:22.760]                           }
[10:31:22.760]                         }
[10:31:22.760]                       }
[10:31:22.760]                       invisible(muffled)
[10:31:22.760]                     }
[10:31:22.760]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.760]                   }
[10:31:22.760]                 }
[10:31:22.760]             }
[10:31:22.760]         }))
[10:31:22.760]     }, error = function(ex) {
[10:31:22.760]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.760]                 ...future.rng), started = ...future.startTime, 
[10:31:22.760]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.760]             version = "1.8"), class = "FutureResult")
[10:31:22.760]     }, finally = {
[10:31:22.760]         if (!identical(...future.workdir, getwd())) 
[10:31:22.760]             setwd(...future.workdir)
[10:31:22.760]         {
[10:31:22.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.760]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.760]             }
[10:31:22.760]             base::options(...future.oldOptions)
[10:31:22.760]             if (.Platform$OS.type == "windows") {
[10:31:22.760]                 old_names <- names(...future.oldEnvVars)
[10:31:22.760]                 envs <- base::Sys.getenv()
[10:31:22.760]                 names <- names(envs)
[10:31:22.760]                 common <- intersect(names, old_names)
[10:31:22.760]                 added <- setdiff(names, old_names)
[10:31:22.760]                 removed <- setdiff(old_names, names)
[10:31:22.760]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.760]                   envs[common]]
[10:31:22.760]                 NAMES <- toupper(changed)
[10:31:22.760]                 args <- list()
[10:31:22.760]                 for (kk in seq_along(NAMES)) {
[10:31:22.760]                   name <- changed[[kk]]
[10:31:22.760]                   NAME <- NAMES[[kk]]
[10:31:22.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.760]                     next
[10:31:22.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.760]                 }
[10:31:22.760]                 NAMES <- toupper(added)
[10:31:22.760]                 for (kk in seq_along(NAMES)) {
[10:31:22.760]                   name <- added[[kk]]
[10:31:22.760]                   NAME <- NAMES[[kk]]
[10:31:22.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.760]                     next
[10:31:22.760]                   args[[name]] <- ""
[10:31:22.760]                 }
[10:31:22.760]                 NAMES <- toupper(removed)
[10:31:22.760]                 for (kk in seq_along(NAMES)) {
[10:31:22.760]                   name <- removed[[kk]]
[10:31:22.760]                   NAME <- NAMES[[kk]]
[10:31:22.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.760]                     next
[10:31:22.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.760]                 }
[10:31:22.760]                 if (length(args) > 0) 
[10:31:22.760]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.760]             }
[10:31:22.760]             else {
[10:31:22.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.760]             }
[10:31:22.760]             {
[10:31:22.760]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.760]                   0L) {
[10:31:22.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.760]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.760]                   base::options(opts)
[10:31:22.760]                 }
[10:31:22.760]                 {
[10:31:22.760]                   {
[10:31:22.760]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:22.760]                     NULL
[10:31:22.760]                   }
[10:31:22.760]                   options(future.plan = NULL)
[10:31:22.760]                   if (is.na(NA_character_)) 
[10:31:22.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.760]                     .init = FALSE)
[10:31:22.760]                 }
[10:31:22.760]             }
[10:31:22.760]         }
[10:31:22.760]     })
[10:31:22.760]     if (TRUE) {
[10:31:22.760]         base::sink(type = "output", split = FALSE)
[10:31:22.760]         if (TRUE) {
[10:31:22.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.760]         }
[10:31:22.760]         else {
[10:31:22.760]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.760]         }
[10:31:22.760]         base::close(...future.stdout)
[10:31:22.760]         ...future.stdout <- NULL
[10:31:22.760]     }
[10:31:22.760]     ...future.result$conditions <- ...future.conditions
[10:31:22.760]     ...future.result$finished <- base::Sys.time()
[10:31:22.760]     ...future.result
[10:31:22.760] }
[10:31:22.763] assign_globals() ...
[10:31:22.763] List of 11
[10:31:22.763]  $ ...future.FUN            :function (x, ...)  
[10:31:22.763]  $ x_FUN                    :function (x)  
[10:31:22.763]  $ times                    : int 0
[10:31:22.763]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.763]  $ stop_if_not              :function (...)  
[10:31:22.763]  $ dim                      : NULL
[10:31:22.763]  $ valid_types              : chr [1:2] "logical" "integer"
[10:31:22.763]  $ future.call.arguments    : list()
[10:31:22.763]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.763]  $ ...future.elements_ii    :List of 5
[10:31:22.763]   ..$ : int 6
[10:31:22.763]   ..$ : int 7
[10:31:22.763]   ..$ : int 8
[10:31:22.763]   ..$ : int 9
[10:31:22.763]   ..$ : int 10
[10:31:22.763]  $ ...future.seeds_ii       : NULL
[10:31:22.763]  $ ...future.globals.maxSize: NULL
[10:31:22.763]  - attr(*, "where")=List of 11
[10:31:22.763]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.763]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.763]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.763]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.763]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.763]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.763]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.763]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.763]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.763]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.763]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.763]  - attr(*, "resolved")= logi FALSE
[10:31:22.763]  - attr(*, "total_size")= num 95400
[10:31:22.763]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.763]  - attr(*, "already-done")= logi TRUE
[10:31:22.774] - copied ‘...future.FUN’ to environment
[10:31:22.774] - reassign environment for ‘x_FUN’
[10:31:22.774] - copied ‘x_FUN’ to environment
[10:31:22.774] - copied ‘times’ to environment
[10:31:22.774] - copied ‘stopf’ to environment
[10:31:22.774] - copied ‘stop_if_not’ to environment
[10:31:22.776] - copied ‘dim’ to environment
[10:31:22.777] - copied ‘valid_types’ to environment
[10:31:22.777] - copied ‘future.call.arguments’ to environment
[10:31:22.777] - copied ‘...future.elements_ii’ to environment
[10:31:22.777] - copied ‘...future.seeds_ii’ to environment
[10:31:22.777] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.777] assign_globals() ... done
[10:31:22.777] requestCore(): workers = 2
[10:31:22.780] MulticoreFuture started
[10:31:22.781] - Launch lazy future ... done
[10:31:22.781] run() for ‘MulticoreFuture’ ... done
[10:31:22.782] Created future:
[10:31:22.782] plan(): Setting new future strategy stack:
[10:31:22.782] List of future strategies:
[10:31:22.782] 1. sequential:
[10:31:22.782]    - args: function (..., envir = parent.frame())
[10:31:22.782]    - tweaked: FALSE
[10:31:22.782]    - call: NULL
[10:31:22.784] plan(): nbrOfWorkers() = 1
[10:31:22.787] plan(): Setting new future strategy stack:
[10:31:22.787] List of future strategies:
[10:31:22.787] 1. multicore:
[10:31:22.787]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:22.787]    - tweaked: FALSE
[10:31:22.787]    - call: plan(strategy)
[10:31:22.794] plan(): nbrOfWorkers() = 2
[10:31:22.782] MulticoreFuture:
[10:31:22.782] Label: ‘future_vapply-2’
[10:31:22.782] Expression:
[10:31:22.782] {
[10:31:22.782]     do.call(function(...) {
[10:31:22.782]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.782]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.782]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.782]             on.exit(options(oopts), add = TRUE)
[10:31:22.782]         }
[10:31:22.782]         {
[10:31:22.782]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.782]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.782]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.782]             })
[10:31:22.782]         }
[10:31:22.782]     }, args = future.call.arguments)
[10:31:22.782] }
[10:31:22.782] Lazy evaluation: FALSE
[10:31:22.782] Asynchronous evaluation: TRUE
[10:31:22.782] Local evaluation: TRUE
[10:31:22.782] Environment: R_GlobalEnv
[10:31:22.782] Capture standard output: TRUE
[10:31:22.782] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.782] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.782] Packages: 1 packages (‘future.apply’)
[10:31:22.782] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.782] Resolved: TRUE
[10:31:22.782] Value: <not collected>
[10:31:22.782] Conditions captured: <none>
[10:31:22.782] Early signaling: FALSE
[10:31:22.782] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.782] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.795] Chunk #2 of 2 ... DONE
[10:31:22.795] Launching 2 futures (chunks) ... DONE
[10:31:22.796] Resolving 2 futures (chunks) ...
[10:31:22.796] resolve() on list ...
[10:31:22.796]  recursive: 0
[10:31:22.796]  length: 2
[10:31:22.797] 
[10:31:22.797] Future #1
[10:31:22.797] result() for MulticoreFuture ...
[10:31:22.798] result() for MulticoreFuture ...
[10:31:22.798] result() for MulticoreFuture ... done
[10:31:22.799] result() for MulticoreFuture ... done
[10:31:22.799] result() for MulticoreFuture ...
[10:31:22.799] result() for MulticoreFuture ... done
[10:31:22.799] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:22.800] - nx: 2
[10:31:22.800] - relay: TRUE
[10:31:22.800] - stdout: TRUE
[10:31:22.800] - signal: TRUE
[10:31:22.800] - resignal: FALSE
[10:31:22.801] - force: TRUE
[10:31:22.801] - relayed: [n=2] FALSE, FALSE
[10:31:22.801] - queued futures: [n=2] FALSE, FALSE
[10:31:22.801]  - until=1
[10:31:22.801]  - relaying element #1
[10:31:22.802] result() for MulticoreFuture ...
[10:31:22.802] result() for MulticoreFuture ... done
[10:31:22.802] result() for MulticoreFuture ...
[10:31:22.803] result() for MulticoreFuture ... done
[10:31:22.803] result() for MulticoreFuture ...
[10:31:22.803] result() for MulticoreFuture ... done
[10:31:22.804] result() for MulticoreFuture ...
[10:31:22.804] result() for MulticoreFuture ... done
[10:31:22.804] - relayed: [n=2] TRUE, FALSE
[10:31:22.804] - queued futures: [n=2] TRUE, FALSE
[10:31:22.804] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:22.804]  length: 1 (resolved future 1)
[10:31:22.805] Future #2
[10:31:22.805] result() for MulticoreFuture ...
[10:31:22.806] result() for MulticoreFuture ...
[10:31:22.806] result() for MulticoreFuture ... done
[10:31:22.806] result() for MulticoreFuture ... done
[10:31:22.806] result() for MulticoreFuture ...
[10:31:22.806] result() for MulticoreFuture ... done
[10:31:22.806] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:22.807] - nx: 2
[10:31:22.807] - relay: TRUE
[10:31:22.807] - stdout: TRUE
[10:31:22.807] - signal: TRUE
[10:31:22.807] - resignal: FALSE
[10:31:22.807] - force: TRUE
[10:31:22.807] - relayed: [n=2] TRUE, FALSE
[10:31:22.807] - queued futures: [n=2] TRUE, FALSE
[10:31:22.807]  - until=2
[10:31:22.808]  - relaying element #2
[10:31:22.808] result() for MulticoreFuture ...
[10:31:22.808] result() for MulticoreFuture ... done
[10:31:22.808] result() for MulticoreFuture ...
[10:31:22.808] result() for MulticoreFuture ... done
[10:31:22.808] result() for MulticoreFuture ...
[10:31:22.808] result() for MulticoreFuture ... done
[10:31:22.808] result() for MulticoreFuture ...
[10:31:22.809] result() for MulticoreFuture ... done
[10:31:22.809] - relayed: [n=2] TRUE, TRUE
[10:31:22.809] - queued futures: [n=2] TRUE, TRUE
[10:31:22.809] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:22.809]  length: 0 (resolved future 2)
[10:31:22.809] Relaying remaining futures
[10:31:22.809] signalConditionsASAP(NULL, pos=0) ...
[10:31:22.809] - nx: 2
[10:31:22.809] - relay: TRUE
[10:31:22.810] - stdout: TRUE
[10:31:22.810] - signal: TRUE
[10:31:22.810] - resignal: FALSE
[10:31:22.810] - force: TRUE
[10:31:22.810] - relayed: [n=2] TRUE, TRUE
[10:31:22.810] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:22.810] - relayed: [n=2] TRUE, TRUE
[10:31:22.810] - queued futures: [n=2] TRUE, TRUE
[10:31:22.811] signalConditionsASAP(NULL, pos=0) ... done
[10:31:22.811] resolve() on list ... DONE
[10:31:22.811] result() for MulticoreFuture ...
[10:31:22.811] result() for MulticoreFuture ... done
[10:31:22.811] result() for MulticoreFuture ...
[10:31:22.811] result() for MulticoreFuture ... done
[10:31:22.811] result() for MulticoreFuture ...
[10:31:22.811] result() for MulticoreFuture ... done
[10:31:22.811] result() for MulticoreFuture ...
[10:31:22.812] result() for MulticoreFuture ... done
[10:31:22.812]  - Number of value chunks collected: 2
[10:31:22.812] Resolving 2 futures (chunks) ... DONE
[10:31:22.812] Reducing values from 2 chunks ...
[10:31:22.812]  - Number of values collected after concatenation: 10
[10:31:22.812]  - Number of values expected: 10
[10:31:22.812] Reducing values from 2 chunks ... DONE
[10:31:22.812] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[10:31:22.814] future_lapply() ...
[10:31:22.820] Number of chunks: 2
[10:31:22.820] getGlobalsAndPackagesXApply() ...
[10:31:22.820]  - future.globals: TRUE
[10:31:22.820] getGlobalsAndPackages() ...
[10:31:22.820] Searching for globals...
[10:31:22.827] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:22.827] Searching for globals ... DONE
[10:31:22.827] Resolving globals: FALSE
[10:31:22.828] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[10:31:22.829] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:22.829] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.829] - packages: [1] ‘future.apply’
[10:31:22.829] getGlobalsAndPackages() ... DONE
[10:31:22.829]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.829]  - needed namespaces: [n=1] ‘future.apply’
[10:31:22.829] Finding globals ... DONE
[10:31:22.830]  - use_args: TRUE
[10:31:22.830]  - Getting '...' globals ...
[10:31:22.830] resolve() on list ...
[10:31:22.830]  recursive: 0
[10:31:22.830]  length: 1
[10:31:22.830]  elements: ‘...’
[10:31:22.831]  length: 0 (resolved future 1)
[10:31:22.831] resolve() on list ... DONE
[10:31:22.831]    - '...' content: [n=0] 
[10:31:22.831] List of 1
[10:31:22.831]  $ ...: list()
[10:31:22.831]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.831]  - attr(*, "where")=List of 1
[10:31:22.831]   ..$ ...:<environment: 0x55de85893f88> 
[10:31:22.831]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.831]  - attr(*, "resolved")= logi TRUE
[10:31:22.831]  - attr(*, "total_size")= num NA
[10:31:22.834]  - Getting '...' globals ... DONE
[10:31:22.834] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:22.834] List of 8
[10:31:22.834]  $ ...future.FUN:function (x, ...)  
[10:31:22.834]  $ x_FUN        :function (x)  
[10:31:22.834]  $ times        : int 1
[10:31:22.834]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.834]  $ stop_if_not  :function (...)  
[10:31:22.834]  $ dim          : NULL
[10:31:22.834]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:22.834]  $ ...          : list()
[10:31:22.834]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.834]  - attr(*, "where")=List of 8
[10:31:22.834]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:22.834]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:22.834]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:22.834]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:22.834]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:22.834]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:22.834]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:22.834]   ..$ ...          :<environment: 0x55de85893f88> 
[10:31:22.834]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.834]  - attr(*, "resolved")= logi FALSE
[10:31:22.834]  - attr(*, "total_size")= num 94336
[10:31:22.839] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:22.840] getGlobalsAndPackagesXApply() ... DONE
[10:31:22.840] Number of futures (= number of chunks): 2
[10:31:22.840] Launching 2 futures (chunks) ...
[10:31:22.840] Chunk #1 of 2 ...
[10:31:22.840]  - Finding globals in 'X' for chunk #1 ...
[10:31:22.840] getGlobalsAndPackages() ...
[10:31:22.840] Searching for globals...
[10:31:22.841] 
[10:31:22.841] Searching for globals ... DONE
[10:31:22.841] - globals: [0] <none>
[10:31:22.841] getGlobalsAndPackages() ... DONE
[10:31:22.841]    + additional globals found: [n=0] 
[10:31:22.841]    + additional namespaces needed: [n=0] 
[10:31:22.841]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:22.841]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:22.841]  - seeds: <none>
[10:31:22.842]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.842] getGlobalsAndPackages() ...
[10:31:22.842] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.842] Resolving globals: FALSE
[10:31:22.842] Tweak future expression to call with '...' arguments ...
[10:31:22.842] {
[10:31:22.842]     do.call(function(...) {
[10:31:22.842]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.842]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.842]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.842]             on.exit(options(oopts), add = TRUE)
[10:31:22.842]         }
[10:31:22.842]         {
[10:31:22.842]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.842]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.842]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.842]             })
[10:31:22.842]         }
[10:31:22.842]     }, args = future.call.arguments)
[10:31:22.842] }
[10:31:22.842] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.843] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.843] - packages: [1] ‘future.apply’
[10:31:22.843] getGlobalsAndPackages() ... DONE
[10:31:22.844] run() for ‘Future’ ...
[10:31:22.844] - state: ‘created’
[10:31:22.844] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:22.848] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.848] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:22.851]   - Field: ‘label’
[10:31:22.851]   - Field: ‘local’
[10:31:22.851]   - Field: ‘owner’
[10:31:22.851]   - Field: ‘envir’
[10:31:22.851]   - Field: ‘workers’
[10:31:22.851]   - Field: ‘packages’
[10:31:22.851]   - Field: ‘gc’
[10:31:22.851]   - Field: ‘job’
[10:31:22.852]   - Field: ‘conditions’
[10:31:22.852]   - Field: ‘expr’
[10:31:22.852]   - Field: ‘uuid’
[10:31:22.852]   - Field: ‘seed’
[10:31:22.852]   - Field: ‘version’
[10:31:22.852]   - Field: ‘result’
[10:31:22.852]   - Field: ‘asynchronous’
[10:31:22.852]   - Field: ‘calls’
[10:31:22.852]   - Field: ‘globals’
[10:31:22.853]   - Field: ‘stdout’
[10:31:22.853]   - Field: ‘earlySignal’
[10:31:22.853]   - Field: ‘lazy’
[10:31:22.853]   - Field: ‘state’
[10:31:22.853] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:22.853] - Launch lazy future ...
[10:31:22.854] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.854] Packages needed by future strategies (n = 0): <none>
[10:31:22.854] {
[10:31:22.854]     {
[10:31:22.854]         {
[10:31:22.854]             ...future.startTime <- base::Sys.time()
[10:31:22.854]             {
[10:31:22.854]                 {
[10:31:22.854]                   {
[10:31:22.854]                     {
[10:31:22.854]                       {
[10:31:22.854]                         base::local({
[10:31:22.854]                           has_future <- base::requireNamespace("future", 
[10:31:22.854]                             quietly = TRUE)
[10:31:22.854]                           if (has_future) {
[10:31:22.854]                             ns <- base::getNamespace("future")
[10:31:22.854]                             version <- ns[[".package"]][["version"]]
[10:31:22.854]                             if (is.null(version)) 
[10:31:22.854]                               version <- utils::packageVersion("future")
[10:31:22.854]                           }
[10:31:22.854]                           else {
[10:31:22.854]                             version <- NULL
[10:31:22.854]                           }
[10:31:22.854]                           if (!has_future || version < "1.8.0") {
[10:31:22.854]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.854]                               "", base::R.version$version.string), 
[10:31:22.854]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:22.854]                                 base::R.version$platform, 8 * 
[10:31:22.854]                                   base::.Machine$sizeof.pointer), 
[10:31:22.854]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.854]                                 "release", "version")], collapse = " "), 
[10:31:22.854]                               hostname = base::Sys.info()[["nodename"]])
[10:31:22.854]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.854]                               info)
[10:31:22.854]                             info <- base::paste(info, collapse = "; ")
[10:31:22.854]                             if (!has_future) {
[10:31:22.854]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.854]                                 info)
[10:31:22.854]                             }
[10:31:22.854]                             else {
[10:31:22.854]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.854]                                 info, version)
[10:31:22.854]                             }
[10:31:22.854]                             base::stop(msg)
[10:31:22.854]                           }
[10:31:22.854]                         })
[10:31:22.854]                       }
[10:31:22.854]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:22.854]                       base::options(mc.cores = 1L)
[10:31:22.854]                     }
[10:31:22.854]                     base::local({
[10:31:22.854]                       for (pkg in "future.apply") {
[10:31:22.854]                         base::loadNamespace(pkg)
[10:31:22.854]                         base::library(pkg, character.only = TRUE)
[10:31:22.854]                       }
[10:31:22.854]                     })
[10:31:22.854]                   }
[10:31:22.854]                   ...future.strategy.old <- future::plan("list")
[10:31:22.854]                   options(future.plan = NULL)
[10:31:22.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.854]                 }
[10:31:22.854]                 ...future.workdir <- getwd()
[10:31:22.854]             }
[10:31:22.854]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.854]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.854]         }
[10:31:22.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.854]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:22.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.854]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.854]             base::names(...future.oldOptions))
[10:31:22.854]     }
[10:31:22.854]     if (FALSE) {
[10:31:22.854]     }
[10:31:22.854]     else {
[10:31:22.854]         if (TRUE) {
[10:31:22.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.854]                 open = "w")
[10:31:22.854]         }
[10:31:22.854]         else {
[10:31:22.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.854]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.854]         }
[10:31:22.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.854]             base::sink(type = "output", split = FALSE)
[10:31:22.854]             base::close(...future.stdout)
[10:31:22.854]         }, add = TRUE)
[10:31:22.854]     }
[10:31:22.854]     ...future.frame <- base::sys.nframe()
[10:31:22.854]     ...future.conditions <- base::list()
[10:31:22.854]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.854]     if (FALSE) {
[10:31:22.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.854]     }
[10:31:22.854]     ...future.result <- base::tryCatch({
[10:31:22.854]         base::withCallingHandlers({
[10:31:22.854]             ...future.value <- base::withVisible(base::local({
[10:31:22.854]                 withCallingHandlers({
[10:31:22.854]                   {
[10:31:22.854]                     do.call(function(...) {
[10:31:22.854]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.854]                       if (!identical(...future.globals.maxSize.org, 
[10:31:22.854]                         ...future.globals.maxSize)) {
[10:31:22.854]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.854]                         on.exit(options(oopts), add = TRUE)
[10:31:22.854]                       }
[10:31:22.854]                       {
[10:31:22.854]                         lapply(seq_along(...future.elements_ii), 
[10:31:22.854]                           FUN = function(jj) {
[10:31:22.854]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.854]                             ...future.FUN(...future.X_jj, ...)
[10:31:22.854]                           })
[10:31:22.854]                       }
[10:31:22.854]                     }, args = future.call.arguments)
[10:31:22.854]                   }
[10:31:22.854]                 }, immediateCondition = function(cond) {
[10:31:22.854]                   save_rds <- function (object, pathname, ...) 
[10:31:22.854]                   {
[10:31:22.854]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:22.854]                     if (file_test("-f", pathname_tmp)) {
[10:31:22.854]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.854]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:22.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.854]                         fi_tmp[["mtime"]])
[10:31:22.854]                     }
[10:31:22.854]                     tryCatch({
[10:31:22.854]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:22.854]                     }, error = function(ex) {
[10:31:22.854]                       msg <- conditionMessage(ex)
[10:31:22.854]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.854]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:22.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.854]                         fi_tmp[["mtime"]], msg)
[10:31:22.854]                       ex$message <- msg
[10:31:22.854]                       stop(ex)
[10:31:22.854]                     })
[10:31:22.854]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:22.854]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:22.854]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:22.854]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.854]                       fi <- file.info(pathname)
[10:31:22.854]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:22.854]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.854]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:22.854]                         fi[["size"]], fi[["mtime"]])
[10:31:22.854]                       stop(msg)
[10:31:22.854]                     }
[10:31:22.854]                     invisible(pathname)
[10:31:22.854]                   }
[10:31:22.854]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:22.854]                     rootPath = tempdir()) 
[10:31:22.854]                   {
[10:31:22.854]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:22.854]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:22.854]                       tmpdir = path, fileext = ".rds")
[10:31:22.854]                     save_rds(obj, file)
[10:31:22.854]                   }
[10:31:22.854]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:22.854]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.854]                   {
[10:31:22.854]                     inherits <- base::inherits
[10:31:22.854]                     invokeRestart <- base::invokeRestart
[10:31:22.854]                     is.null <- base::is.null
[10:31:22.854]                     muffled <- FALSE
[10:31:22.854]                     if (inherits(cond, "message")) {
[10:31:22.854]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:22.854]                       if (muffled) 
[10:31:22.854]                         invokeRestart("muffleMessage")
[10:31:22.854]                     }
[10:31:22.854]                     else if (inherits(cond, "warning")) {
[10:31:22.854]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:22.854]                       if (muffled) 
[10:31:22.854]                         invokeRestart("muffleWarning")
[10:31:22.854]                     }
[10:31:22.854]                     else if (inherits(cond, "condition")) {
[10:31:22.854]                       if (!is.null(pattern)) {
[10:31:22.854]                         computeRestarts <- base::computeRestarts
[10:31:22.854]                         grepl <- base::grepl
[10:31:22.854]                         restarts <- computeRestarts(cond)
[10:31:22.854]                         for (restart in restarts) {
[10:31:22.854]                           name <- restart$name
[10:31:22.854]                           if (is.null(name)) 
[10:31:22.854]                             next
[10:31:22.854]                           if (!grepl(pattern, name)) 
[10:31:22.854]                             next
[10:31:22.854]                           invokeRestart(restart)
[10:31:22.854]                           muffled <- TRUE
[10:31:22.854]                           break
[10:31:22.854]                         }
[10:31:22.854]                       }
[10:31:22.854]                     }
[10:31:22.854]                     invisible(muffled)
[10:31:22.854]                   }
[10:31:22.854]                   muffleCondition(cond)
[10:31:22.854]                 })
[10:31:22.854]             }))
[10:31:22.854]             future::FutureResult(value = ...future.value$value, 
[10:31:22.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.854]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.854]                     ...future.globalenv.names))
[10:31:22.854]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.854]         }, condition = base::local({
[10:31:22.854]             c <- base::c
[10:31:22.854]             inherits <- base::inherits
[10:31:22.854]             invokeRestart <- base::invokeRestart
[10:31:22.854]             length <- base::length
[10:31:22.854]             list <- base::list
[10:31:22.854]             seq.int <- base::seq.int
[10:31:22.854]             signalCondition <- base::signalCondition
[10:31:22.854]             sys.calls <- base::sys.calls
[10:31:22.854]             `[[` <- base::`[[`
[10:31:22.854]             `+` <- base::`+`
[10:31:22.854]             `<<-` <- base::`<<-`
[10:31:22.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.854]                   3L)]
[10:31:22.854]             }
[10:31:22.854]             function(cond) {
[10:31:22.854]                 is_error <- inherits(cond, "error")
[10:31:22.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.854]                   NULL)
[10:31:22.854]                 if (is_error) {
[10:31:22.854]                   sessionInformation <- function() {
[10:31:22.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.854]                       search = base::search(), system = base::Sys.info())
[10:31:22.854]                   }
[10:31:22.854]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.854]                     cond$call), session = sessionInformation(), 
[10:31:22.854]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.854]                   signalCondition(cond)
[10:31:22.854]                 }
[10:31:22.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.854]                 "immediateCondition"))) {
[10:31:22.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.854]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.854]                   if (TRUE && !signal) {
[10:31:22.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.854]                     {
[10:31:22.854]                       inherits <- base::inherits
[10:31:22.854]                       invokeRestart <- base::invokeRestart
[10:31:22.854]                       is.null <- base::is.null
[10:31:22.854]                       muffled <- FALSE
[10:31:22.854]                       if (inherits(cond, "message")) {
[10:31:22.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.854]                         if (muffled) 
[10:31:22.854]                           invokeRestart("muffleMessage")
[10:31:22.854]                       }
[10:31:22.854]                       else if (inherits(cond, "warning")) {
[10:31:22.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.854]                         if (muffled) 
[10:31:22.854]                           invokeRestart("muffleWarning")
[10:31:22.854]                       }
[10:31:22.854]                       else if (inherits(cond, "condition")) {
[10:31:22.854]                         if (!is.null(pattern)) {
[10:31:22.854]                           computeRestarts <- base::computeRestarts
[10:31:22.854]                           grepl <- base::grepl
[10:31:22.854]                           restarts <- computeRestarts(cond)
[10:31:22.854]                           for (restart in restarts) {
[10:31:22.854]                             name <- restart$name
[10:31:22.854]                             if (is.null(name)) 
[10:31:22.854]                               next
[10:31:22.854]                             if (!grepl(pattern, name)) 
[10:31:22.854]                               next
[10:31:22.854]                             invokeRestart(restart)
[10:31:22.854]                             muffled <- TRUE
[10:31:22.854]                             break
[10:31:22.854]                           }
[10:31:22.854]                         }
[10:31:22.854]                       }
[10:31:22.854]                       invisible(muffled)
[10:31:22.854]                     }
[10:31:22.854]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.854]                   }
[10:31:22.854]                 }
[10:31:22.854]                 else {
[10:31:22.854]                   if (TRUE) {
[10:31:22.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.854]                     {
[10:31:22.854]                       inherits <- base::inherits
[10:31:22.854]                       invokeRestart <- base::invokeRestart
[10:31:22.854]                       is.null <- base::is.null
[10:31:22.854]                       muffled <- FALSE
[10:31:22.854]                       if (inherits(cond, "message")) {
[10:31:22.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.854]                         if (muffled) 
[10:31:22.854]                           invokeRestart("muffleMessage")
[10:31:22.854]                       }
[10:31:22.854]                       else if (inherits(cond, "warning")) {
[10:31:22.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.854]                         if (muffled) 
[10:31:22.854]                           invokeRestart("muffleWarning")
[10:31:22.854]                       }
[10:31:22.854]                       else if (inherits(cond, "condition")) {
[10:31:22.854]                         if (!is.null(pattern)) {
[10:31:22.854]                           computeRestarts <- base::computeRestarts
[10:31:22.854]                           grepl <- base::grepl
[10:31:22.854]                           restarts <- computeRestarts(cond)
[10:31:22.854]                           for (restart in restarts) {
[10:31:22.854]                             name <- restart$name
[10:31:22.854]                             if (is.null(name)) 
[10:31:22.854]                               next
[10:31:22.854]                             if (!grepl(pattern, name)) 
[10:31:22.854]                               next
[10:31:22.854]                             invokeRestart(restart)
[10:31:22.854]                             muffled <- TRUE
[10:31:22.854]                             break
[10:31:22.854]                           }
[10:31:22.854]                         }
[10:31:22.854]                       }
[10:31:22.854]                       invisible(muffled)
[10:31:22.854]                     }
[10:31:22.854]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.854]                   }
[10:31:22.854]                 }
[10:31:22.854]             }
[10:31:22.854]         }))
[10:31:22.854]     }, error = function(ex) {
[10:31:22.854]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.854]                 ...future.rng), started = ...future.startTime, 
[10:31:22.854]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.854]             version = "1.8"), class = "FutureResult")
[10:31:22.854]     }, finally = {
[10:31:22.854]         if (!identical(...future.workdir, getwd())) 
[10:31:22.854]             setwd(...future.workdir)
[10:31:22.854]         {
[10:31:22.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.854]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.854]             }
[10:31:22.854]             base::options(...future.oldOptions)
[10:31:22.854]             if (.Platform$OS.type == "windows") {
[10:31:22.854]                 old_names <- names(...future.oldEnvVars)
[10:31:22.854]                 envs <- base::Sys.getenv()
[10:31:22.854]                 names <- names(envs)
[10:31:22.854]                 common <- intersect(names, old_names)
[10:31:22.854]                 added <- setdiff(names, old_names)
[10:31:22.854]                 removed <- setdiff(old_names, names)
[10:31:22.854]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.854]                   envs[common]]
[10:31:22.854]                 NAMES <- toupper(changed)
[10:31:22.854]                 args <- list()
[10:31:22.854]                 for (kk in seq_along(NAMES)) {
[10:31:22.854]                   name <- changed[[kk]]
[10:31:22.854]                   NAME <- NAMES[[kk]]
[10:31:22.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.854]                     next
[10:31:22.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.854]                 }
[10:31:22.854]                 NAMES <- toupper(added)
[10:31:22.854]                 for (kk in seq_along(NAMES)) {
[10:31:22.854]                   name <- added[[kk]]
[10:31:22.854]                   NAME <- NAMES[[kk]]
[10:31:22.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.854]                     next
[10:31:22.854]                   args[[name]] <- ""
[10:31:22.854]                 }
[10:31:22.854]                 NAMES <- toupper(removed)
[10:31:22.854]                 for (kk in seq_along(NAMES)) {
[10:31:22.854]                   name <- removed[[kk]]
[10:31:22.854]                   NAME <- NAMES[[kk]]
[10:31:22.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.854]                     next
[10:31:22.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.854]                 }
[10:31:22.854]                 if (length(args) > 0) 
[10:31:22.854]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.854]             }
[10:31:22.854]             else {
[10:31:22.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.854]             }
[10:31:22.854]             {
[10:31:22.854]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.854]                   0L) {
[10:31:22.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.854]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.854]                   base::options(opts)
[10:31:22.854]                 }
[10:31:22.854]                 {
[10:31:22.854]                   {
[10:31:22.854]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:22.854]                     NULL
[10:31:22.854]                   }
[10:31:22.854]                   options(future.plan = NULL)
[10:31:22.854]                   if (is.na(NA_character_)) 
[10:31:22.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.854]                     .init = FALSE)
[10:31:22.854]                 }
[10:31:22.854]             }
[10:31:22.854]         }
[10:31:22.854]     })
[10:31:22.854]     if (TRUE) {
[10:31:22.854]         base::sink(type = "output", split = FALSE)
[10:31:22.854]         if (TRUE) {
[10:31:22.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.854]         }
[10:31:22.854]         else {
[10:31:22.854]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.854]         }
[10:31:22.854]         base::close(...future.stdout)
[10:31:22.854]         ...future.stdout <- NULL
[10:31:22.854]     }
[10:31:22.854]     ...future.result$conditions <- ...future.conditions
[10:31:22.854]     ...future.result$finished <- base::Sys.time()
[10:31:22.854]     ...future.result
[10:31:22.854] }
[10:31:22.857] assign_globals() ...
[10:31:22.857] List of 11
[10:31:22.857]  $ ...future.FUN            :function (x, ...)  
[10:31:22.857]  $ x_FUN                    :function (x)  
[10:31:22.857]  $ times                    : int 1
[10:31:22.857]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.857]  $ stop_if_not              :function (...)  
[10:31:22.857]  $ dim                      : NULL
[10:31:22.857]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:22.857]  $ future.call.arguments    : list()
[10:31:22.857]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.857]  $ ...future.elements_ii    :List of 5
[10:31:22.857]   ..$ : int 1
[10:31:22.857]   ..$ : int 2
[10:31:22.857]   ..$ : int 3
[10:31:22.857]   ..$ : int 4
[10:31:22.857]   ..$ : int 5
[10:31:22.857]  $ ...future.seeds_ii       : NULL
[10:31:22.857]  $ ...future.globals.maxSize: NULL
[10:31:22.857]  - attr(*, "where")=List of 11
[10:31:22.857]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.857]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.857]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.857]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.857]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.857]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.857]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.857]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.857]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.857]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.857]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.857]  - attr(*, "resolved")= logi FALSE
[10:31:22.857]  - attr(*, "total_size")= num 94336
[10:31:22.857]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.857]  - attr(*, "already-done")= logi TRUE
[10:31:22.866] - copied ‘...future.FUN’ to environment
[10:31:22.866] - copied ‘x_FUN’ to environment
[10:31:22.866] - copied ‘times’ to environment
[10:31:22.866] - copied ‘stopf’ to environment
[10:31:22.866] - copied ‘stop_if_not’ to environment
[10:31:22.867] - copied ‘dim’ to environment
[10:31:22.867] - copied ‘valid_types’ to environment
[10:31:22.867] - copied ‘future.call.arguments’ to environment
[10:31:22.867] - copied ‘...future.elements_ii’ to environment
[10:31:22.867] - copied ‘...future.seeds_ii’ to environment
[10:31:22.867] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.867] assign_globals() ... done
[10:31:22.867] requestCore(): workers = 2
[10:31:22.870] MulticoreFuture started
[10:31:22.870] - Launch lazy future ... done
[10:31:22.870] run() for ‘MulticoreFuture’ ... done
[10:31:22.870] Created future:
[10:31:22.871] plan(): Setting new future strategy stack:
[10:31:22.871] List of future strategies:
[10:31:22.871] 1. sequential:
[10:31:22.871]    - args: function (..., envir = parent.frame())
[10:31:22.871]    - tweaked: FALSE
[10:31:22.871]    - call: NULL
[10:31:22.872] plan(): nbrOfWorkers() = 1
[10:31:22.874] plan(): Setting new future strategy stack:
[10:31:22.874] List of future strategies:
[10:31:22.874] 1. multicore:
[10:31:22.874]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:22.874]    - tweaked: FALSE
[10:31:22.874]    - call: plan(strategy)
[10:31:22.880] plan(): nbrOfWorkers() = 2
[10:31:22.871] MulticoreFuture:
[10:31:22.871] Label: ‘future_vapply-1’
[10:31:22.871] Expression:
[10:31:22.871] {
[10:31:22.871]     do.call(function(...) {
[10:31:22.871]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.871]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.871]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.871]             on.exit(options(oopts), add = TRUE)
[10:31:22.871]         }
[10:31:22.871]         {
[10:31:22.871]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.871]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.871]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.871]             })
[10:31:22.871]         }
[10:31:22.871]     }, args = future.call.arguments)
[10:31:22.871] }
[10:31:22.871] Lazy evaluation: FALSE
[10:31:22.871] Asynchronous evaluation: TRUE
[10:31:22.871] Local evaluation: TRUE
[10:31:22.871] Environment: R_GlobalEnv
[10:31:22.871] Capture standard output: TRUE
[10:31:22.871] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.871] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.871] Packages: 1 packages (‘future.apply’)
[10:31:22.871] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.871] Resolved: TRUE
[10:31:22.871] Value: <not collected>
[10:31:22.871] Conditions captured: <none>
[10:31:22.871] Early signaling: FALSE
[10:31:22.871] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.871] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.881] Chunk #1 of 2 ... DONE
[10:31:22.881] Chunk #2 of 2 ...
[10:31:22.881]  - Finding globals in 'X' for chunk #2 ...
[10:31:22.882] getGlobalsAndPackages() ...
[10:31:22.882] Searching for globals...
[10:31:22.882] 
[10:31:22.882] Searching for globals ... DONE
[10:31:22.882] - globals: [0] <none>
[10:31:22.883] getGlobalsAndPackages() ... DONE
[10:31:22.883]    + additional globals found: [n=0] 
[10:31:22.883]    + additional namespaces needed: [n=0] 
[10:31:22.883]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:22.883]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:22.883]  - seeds: <none>
[10:31:22.883]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.884] getGlobalsAndPackages() ...
[10:31:22.884] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.884] Resolving globals: FALSE
[10:31:22.884] Tweak future expression to call with '...' arguments ...
[10:31:22.884] {
[10:31:22.884]     do.call(function(...) {
[10:31:22.884]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.884]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.884]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.884]             on.exit(options(oopts), add = TRUE)
[10:31:22.884]         }
[10:31:22.884]         {
[10:31:22.884]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.884]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.884]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.884]             })
[10:31:22.884]         }
[10:31:22.884]     }, args = future.call.arguments)
[10:31:22.884] }
[10:31:22.885] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.890] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.891] - packages: [1] ‘future.apply’
[10:31:22.891] getGlobalsAndPackages() ... DONE
[10:31:22.892] run() for ‘Future’ ...
[10:31:22.892] - state: ‘created’
[10:31:22.893] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:22.899] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.899] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:22.900]   - Field: ‘label’
[10:31:22.900]   - Field: ‘local’
[10:31:22.900]   - Field: ‘owner’
[10:31:22.900]   - Field: ‘envir’
[10:31:22.901]   - Field: ‘workers’
[10:31:22.901]   - Field: ‘packages’
[10:31:22.901]   - Field: ‘gc’
[10:31:22.901]   - Field: ‘job’
[10:31:22.902]   - Field: ‘conditions’
[10:31:22.902]   - Field: ‘expr’
[10:31:22.902]   - Field: ‘uuid’
[10:31:22.902]   - Field: ‘seed’
[10:31:22.902]   - Field: ‘version’
[10:31:22.902]   - Field: ‘result’
[10:31:22.903]   - Field: ‘asynchronous’
[10:31:22.903]   - Field: ‘calls’
[10:31:22.903]   - Field: ‘globals’
[10:31:22.903]   - Field: ‘stdout’
[10:31:22.903]   - Field: ‘earlySignal’
[10:31:22.903]   - Field: ‘lazy’
[10:31:22.903]   - Field: ‘state’
[10:31:22.904] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:22.904] - Launch lazy future ...
[10:31:22.904] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.904] Packages needed by future strategies (n = 0): <none>
[10:31:22.906] {
[10:31:22.906]     {
[10:31:22.906]         {
[10:31:22.906]             ...future.startTime <- base::Sys.time()
[10:31:22.906]             {
[10:31:22.906]                 {
[10:31:22.906]                   {
[10:31:22.906]                     {
[10:31:22.906]                       {
[10:31:22.906]                         base::local({
[10:31:22.906]                           has_future <- base::requireNamespace("future", 
[10:31:22.906]                             quietly = TRUE)
[10:31:22.906]                           if (has_future) {
[10:31:22.906]                             ns <- base::getNamespace("future")
[10:31:22.906]                             version <- ns[[".package"]][["version"]]
[10:31:22.906]                             if (is.null(version)) 
[10:31:22.906]                               version <- utils::packageVersion("future")
[10:31:22.906]                           }
[10:31:22.906]                           else {
[10:31:22.906]                             version <- NULL
[10:31:22.906]                           }
[10:31:22.906]                           if (!has_future || version < "1.8.0") {
[10:31:22.906]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.906]                               "", base::R.version$version.string), 
[10:31:22.906]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:22.906]                                 base::R.version$platform, 8 * 
[10:31:22.906]                                   base::.Machine$sizeof.pointer), 
[10:31:22.906]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.906]                                 "release", "version")], collapse = " "), 
[10:31:22.906]                               hostname = base::Sys.info()[["nodename"]])
[10:31:22.906]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.906]                               info)
[10:31:22.906]                             info <- base::paste(info, collapse = "; ")
[10:31:22.906]                             if (!has_future) {
[10:31:22.906]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.906]                                 info)
[10:31:22.906]                             }
[10:31:22.906]                             else {
[10:31:22.906]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.906]                                 info, version)
[10:31:22.906]                             }
[10:31:22.906]                             base::stop(msg)
[10:31:22.906]                           }
[10:31:22.906]                         })
[10:31:22.906]                       }
[10:31:22.906]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:22.906]                       base::options(mc.cores = 1L)
[10:31:22.906]                     }
[10:31:22.906]                     base::local({
[10:31:22.906]                       for (pkg in "future.apply") {
[10:31:22.906]                         base::loadNamespace(pkg)
[10:31:22.906]                         base::library(pkg, character.only = TRUE)
[10:31:22.906]                       }
[10:31:22.906]                     })
[10:31:22.906]                   }
[10:31:22.906]                   ...future.strategy.old <- future::plan("list")
[10:31:22.906]                   options(future.plan = NULL)
[10:31:22.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.906]                 }
[10:31:22.906]                 ...future.workdir <- getwd()
[10:31:22.906]             }
[10:31:22.906]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.906]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.906]         }
[10:31:22.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.906]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:22.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.906]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.906]             base::names(...future.oldOptions))
[10:31:22.906]     }
[10:31:22.906]     if (FALSE) {
[10:31:22.906]     }
[10:31:22.906]     else {
[10:31:22.906]         if (TRUE) {
[10:31:22.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.906]                 open = "w")
[10:31:22.906]         }
[10:31:22.906]         else {
[10:31:22.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.906]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.906]         }
[10:31:22.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.906]             base::sink(type = "output", split = FALSE)
[10:31:22.906]             base::close(...future.stdout)
[10:31:22.906]         }, add = TRUE)
[10:31:22.906]     }
[10:31:22.906]     ...future.frame <- base::sys.nframe()
[10:31:22.906]     ...future.conditions <- base::list()
[10:31:22.906]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.906]     if (FALSE) {
[10:31:22.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.906]     }
[10:31:22.906]     ...future.result <- base::tryCatch({
[10:31:22.906]         base::withCallingHandlers({
[10:31:22.906]             ...future.value <- base::withVisible(base::local({
[10:31:22.906]                 withCallingHandlers({
[10:31:22.906]                   {
[10:31:22.906]                     do.call(function(...) {
[10:31:22.906]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.906]                       if (!identical(...future.globals.maxSize.org, 
[10:31:22.906]                         ...future.globals.maxSize)) {
[10:31:22.906]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.906]                         on.exit(options(oopts), add = TRUE)
[10:31:22.906]                       }
[10:31:22.906]                       {
[10:31:22.906]                         lapply(seq_along(...future.elements_ii), 
[10:31:22.906]                           FUN = function(jj) {
[10:31:22.906]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.906]                             ...future.FUN(...future.X_jj, ...)
[10:31:22.906]                           })
[10:31:22.906]                       }
[10:31:22.906]                     }, args = future.call.arguments)
[10:31:22.906]                   }
[10:31:22.906]                 }, immediateCondition = function(cond) {
[10:31:22.906]                   save_rds <- function (object, pathname, ...) 
[10:31:22.906]                   {
[10:31:22.906]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:22.906]                     if (file_test("-f", pathname_tmp)) {
[10:31:22.906]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.906]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:22.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.906]                         fi_tmp[["mtime"]])
[10:31:22.906]                     }
[10:31:22.906]                     tryCatch({
[10:31:22.906]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:22.906]                     }, error = function(ex) {
[10:31:22.906]                       msg <- conditionMessage(ex)
[10:31:22.906]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.906]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:22.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.906]                         fi_tmp[["mtime"]], msg)
[10:31:22.906]                       ex$message <- msg
[10:31:22.906]                       stop(ex)
[10:31:22.906]                     })
[10:31:22.906]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:22.906]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:22.906]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:22.906]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.906]                       fi <- file.info(pathname)
[10:31:22.906]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:22.906]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.906]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:22.906]                         fi[["size"]], fi[["mtime"]])
[10:31:22.906]                       stop(msg)
[10:31:22.906]                     }
[10:31:22.906]                     invisible(pathname)
[10:31:22.906]                   }
[10:31:22.906]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:22.906]                     rootPath = tempdir()) 
[10:31:22.906]                   {
[10:31:22.906]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:22.906]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:22.906]                       tmpdir = path, fileext = ".rds")
[10:31:22.906]                     save_rds(obj, file)
[10:31:22.906]                   }
[10:31:22.906]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:22.906]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.906]                   {
[10:31:22.906]                     inherits <- base::inherits
[10:31:22.906]                     invokeRestart <- base::invokeRestart
[10:31:22.906]                     is.null <- base::is.null
[10:31:22.906]                     muffled <- FALSE
[10:31:22.906]                     if (inherits(cond, "message")) {
[10:31:22.906]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:22.906]                       if (muffled) 
[10:31:22.906]                         invokeRestart("muffleMessage")
[10:31:22.906]                     }
[10:31:22.906]                     else if (inherits(cond, "warning")) {
[10:31:22.906]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:22.906]                       if (muffled) 
[10:31:22.906]                         invokeRestart("muffleWarning")
[10:31:22.906]                     }
[10:31:22.906]                     else if (inherits(cond, "condition")) {
[10:31:22.906]                       if (!is.null(pattern)) {
[10:31:22.906]                         computeRestarts <- base::computeRestarts
[10:31:22.906]                         grepl <- base::grepl
[10:31:22.906]                         restarts <- computeRestarts(cond)
[10:31:22.906]                         for (restart in restarts) {
[10:31:22.906]                           name <- restart$name
[10:31:22.906]                           if (is.null(name)) 
[10:31:22.906]                             next
[10:31:22.906]                           if (!grepl(pattern, name)) 
[10:31:22.906]                             next
[10:31:22.906]                           invokeRestart(restart)
[10:31:22.906]                           muffled <- TRUE
[10:31:22.906]                           break
[10:31:22.906]                         }
[10:31:22.906]                       }
[10:31:22.906]                     }
[10:31:22.906]                     invisible(muffled)
[10:31:22.906]                   }
[10:31:22.906]                   muffleCondition(cond)
[10:31:22.906]                 })
[10:31:22.906]             }))
[10:31:22.906]             future::FutureResult(value = ...future.value$value, 
[10:31:22.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.906]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.906]                     ...future.globalenv.names))
[10:31:22.906]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.906]         }, condition = base::local({
[10:31:22.906]             c <- base::c
[10:31:22.906]             inherits <- base::inherits
[10:31:22.906]             invokeRestart <- base::invokeRestart
[10:31:22.906]             length <- base::length
[10:31:22.906]             list <- base::list
[10:31:22.906]             seq.int <- base::seq.int
[10:31:22.906]             signalCondition <- base::signalCondition
[10:31:22.906]             sys.calls <- base::sys.calls
[10:31:22.906]             `[[` <- base::`[[`
[10:31:22.906]             `+` <- base::`+`
[10:31:22.906]             `<<-` <- base::`<<-`
[10:31:22.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.906]                   3L)]
[10:31:22.906]             }
[10:31:22.906]             function(cond) {
[10:31:22.906]                 is_error <- inherits(cond, "error")
[10:31:22.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.906]                   NULL)
[10:31:22.906]                 if (is_error) {
[10:31:22.906]                   sessionInformation <- function() {
[10:31:22.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.906]                       search = base::search(), system = base::Sys.info())
[10:31:22.906]                   }
[10:31:22.906]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.906]                     cond$call), session = sessionInformation(), 
[10:31:22.906]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.906]                   signalCondition(cond)
[10:31:22.906]                 }
[10:31:22.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.906]                 "immediateCondition"))) {
[10:31:22.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.906]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.906]                   if (TRUE && !signal) {
[10:31:22.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.906]                     {
[10:31:22.906]                       inherits <- base::inherits
[10:31:22.906]                       invokeRestart <- base::invokeRestart
[10:31:22.906]                       is.null <- base::is.null
[10:31:22.906]                       muffled <- FALSE
[10:31:22.906]                       if (inherits(cond, "message")) {
[10:31:22.906]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.906]                         if (muffled) 
[10:31:22.906]                           invokeRestart("muffleMessage")
[10:31:22.906]                       }
[10:31:22.906]                       else if (inherits(cond, "warning")) {
[10:31:22.906]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.906]                         if (muffled) 
[10:31:22.906]                           invokeRestart("muffleWarning")
[10:31:22.906]                       }
[10:31:22.906]                       else if (inherits(cond, "condition")) {
[10:31:22.906]                         if (!is.null(pattern)) {
[10:31:22.906]                           computeRestarts <- base::computeRestarts
[10:31:22.906]                           grepl <- base::grepl
[10:31:22.906]                           restarts <- computeRestarts(cond)
[10:31:22.906]                           for (restart in restarts) {
[10:31:22.906]                             name <- restart$name
[10:31:22.906]                             if (is.null(name)) 
[10:31:22.906]                               next
[10:31:22.906]                             if (!grepl(pattern, name)) 
[10:31:22.906]                               next
[10:31:22.906]                             invokeRestart(restart)
[10:31:22.906]                             muffled <- TRUE
[10:31:22.906]                             break
[10:31:22.906]                           }
[10:31:22.906]                         }
[10:31:22.906]                       }
[10:31:22.906]                       invisible(muffled)
[10:31:22.906]                     }
[10:31:22.906]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.906]                   }
[10:31:22.906]                 }
[10:31:22.906]                 else {
[10:31:22.906]                   if (TRUE) {
[10:31:22.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.906]                     {
[10:31:22.906]                       inherits <- base::inherits
[10:31:22.906]                       invokeRestart <- base::invokeRestart
[10:31:22.906]                       is.null <- base::is.null
[10:31:22.906]                       muffled <- FALSE
[10:31:22.906]                       if (inherits(cond, "message")) {
[10:31:22.906]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.906]                         if (muffled) 
[10:31:22.906]                           invokeRestart("muffleMessage")
[10:31:22.906]                       }
[10:31:22.906]                       else if (inherits(cond, "warning")) {
[10:31:22.906]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.906]                         if (muffled) 
[10:31:22.906]                           invokeRestart("muffleWarning")
[10:31:22.906]                       }
[10:31:22.906]                       else if (inherits(cond, "condition")) {
[10:31:22.906]                         if (!is.null(pattern)) {
[10:31:22.906]                           computeRestarts <- base::computeRestarts
[10:31:22.906]                           grepl <- base::grepl
[10:31:22.906]                           restarts <- computeRestarts(cond)
[10:31:22.906]                           for (restart in restarts) {
[10:31:22.906]                             name <- restart$name
[10:31:22.906]                             if (is.null(name)) 
[10:31:22.906]                               next
[10:31:22.906]                             if (!grepl(pattern, name)) 
[10:31:22.906]                               next
[10:31:22.906]                             invokeRestart(restart)
[10:31:22.906]                             muffled <- TRUE
[10:31:22.906]                             break
[10:31:22.906]                           }
[10:31:22.906]                         }
[10:31:22.906]                       }
[10:31:22.906]                       invisible(muffled)
[10:31:22.906]                     }
[10:31:22.906]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.906]                   }
[10:31:22.906]                 }
[10:31:22.906]             }
[10:31:22.906]         }))
[10:31:22.906]     }, error = function(ex) {
[10:31:22.906]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.906]                 ...future.rng), started = ...future.startTime, 
[10:31:22.906]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.906]             version = "1.8"), class = "FutureResult")
[10:31:22.906]     }, finally = {
[10:31:22.906]         if (!identical(...future.workdir, getwd())) 
[10:31:22.906]             setwd(...future.workdir)
[10:31:22.906]         {
[10:31:22.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.906]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.906]             }
[10:31:22.906]             base::options(...future.oldOptions)
[10:31:22.906]             if (.Platform$OS.type == "windows") {
[10:31:22.906]                 old_names <- names(...future.oldEnvVars)
[10:31:22.906]                 envs <- base::Sys.getenv()
[10:31:22.906]                 names <- names(envs)
[10:31:22.906]                 common <- intersect(names, old_names)
[10:31:22.906]                 added <- setdiff(names, old_names)
[10:31:22.906]                 removed <- setdiff(old_names, names)
[10:31:22.906]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.906]                   envs[common]]
[10:31:22.906]                 NAMES <- toupper(changed)
[10:31:22.906]                 args <- list()
[10:31:22.906]                 for (kk in seq_along(NAMES)) {
[10:31:22.906]                   name <- changed[[kk]]
[10:31:22.906]                   NAME <- NAMES[[kk]]
[10:31:22.906]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.906]                     next
[10:31:22.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.906]                 }
[10:31:22.906]                 NAMES <- toupper(added)
[10:31:22.906]                 for (kk in seq_along(NAMES)) {
[10:31:22.906]                   name <- added[[kk]]
[10:31:22.906]                   NAME <- NAMES[[kk]]
[10:31:22.906]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.906]                     next
[10:31:22.906]                   args[[name]] <- ""
[10:31:22.906]                 }
[10:31:22.906]                 NAMES <- toupper(removed)
[10:31:22.906]                 for (kk in seq_along(NAMES)) {
[10:31:22.906]                   name <- removed[[kk]]
[10:31:22.906]                   NAME <- NAMES[[kk]]
[10:31:22.906]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.906]                     next
[10:31:22.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.906]                 }
[10:31:22.906]                 if (length(args) > 0) 
[10:31:22.906]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.906]             }
[10:31:22.906]             else {
[10:31:22.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.906]             }
[10:31:22.906]             {
[10:31:22.906]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.906]                   0L) {
[10:31:22.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.906]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.906]                   base::options(opts)
[10:31:22.906]                 }
[10:31:22.906]                 {
[10:31:22.906]                   {
[10:31:22.906]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:22.906]                     NULL
[10:31:22.906]                   }
[10:31:22.906]                   options(future.plan = NULL)
[10:31:22.906]                   if (is.na(NA_character_)) 
[10:31:22.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.906]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.906]                     .init = FALSE)
[10:31:22.906]                 }
[10:31:22.906]             }
[10:31:22.906]         }
[10:31:22.906]     })
[10:31:22.906]     if (TRUE) {
[10:31:22.906]         base::sink(type = "output", split = FALSE)
[10:31:22.906]         if (TRUE) {
[10:31:22.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.906]         }
[10:31:22.906]         else {
[10:31:22.906]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.906]         }
[10:31:22.906]         base::close(...future.stdout)
[10:31:22.906]         ...future.stdout <- NULL
[10:31:22.906]     }
[10:31:22.906]     ...future.result$conditions <- ...future.conditions
[10:31:22.906]     ...future.result$finished <- base::Sys.time()
[10:31:22.906]     ...future.result
[10:31:22.906] }
[10:31:22.908] assign_globals() ...
[10:31:22.909] List of 11
[10:31:22.909]  $ ...future.FUN            :function (x, ...)  
[10:31:22.909]  $ x_FUN                    :function (x)  
[10:31:22.909]  $ times                    : int 1
[10:31:22.909]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.909]  $ stop_if_not              :function (...)  
[10:31:22.909]  $ dim                      : NULL
[10:31:22.909]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:22.909]  $ future.call.arguments    : list()
[10:31:22.909]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.909]  $ ...future.elements_ii    :List of 5
[10:31:22.909]   ..$ : int 6
[10:31:22.909]   ..$ : int 7
[10:31:22.909]   ..$ : int 8
[10:31:22.909]   ..$ : int 9
[10:31:22.909]   ..$ : int 10
[10:31:22.909]  $ ...future.seeds_ii       : NULL
[10:31:22.909]  $ ...future.globals.maxSize: NULL
[10:31:22.909]  - attr(*, "where")=List of 11
[10:31:22.909]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:22.909]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:22.909]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:22.909]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:22.909]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:22.909]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:22.909]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:22.909]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:22.909]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:22.909]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:22.909]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:22.909]  - attr(*, "resolved")= logi FALSE
[10:31:22.909]  - attr(*, "total_size")= num 94336
[10:31:22.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.909]  - attr(*, "already-done")= logi TRUE
[10:31:22.920] - copied ‘...future.FUN’ to environment
[10:31:22.920] - copied ‘x_FUN’ to environment
[10:31:22.920] - copied ‘times’ to environment
[10:31:22.920] - copied ‘stopf’ to environment
[10:31:22.920] - copied ‘stop_if_not’ to environment
[10:31:22.920] - copied ‘dim’ to environment
[10:31:22.920] - copied ‘valid_types’ to environment
[10:31:22.921] - copied ‘future.call.arguments’ to environment
[10:31:22.921] - copied ‘...future.elements_ii’ to environment
[10:31:22.921] - copied ‘...future.seeds_ii’ to environment
[10:31:22.921] - copied ‘...future.globals.maxSize’ to environment
[10:31:22.921] assign_globals() ... done
[10:31:22.921] requestCore(): workers = 2
[10:31:22.924] MulticoreFuture started
[10:31:22.924] - Launch lazy future ... done
[10:31:22.924] run() for ‘MulticoreFuture’ ... done
[10:31:22.924] Created future:
[10:31:22.925] plan(): Setting new future strategy stack:
[10:31:22.925] List of future strategies:
[10:31:22.925] 1. sequential:
[10:31:22.925]    - args: function (..., envir = parent.frame())
[10:31:22.925]    - tweaked: FALSE
[10:31:22.925]    - call: NULL
[10:31:22.926] plan(): nbrOfWorkers() = 1
[10:31:22.928] plan(): Setting new future strategy stack:
[10:31:22.933] List of future strategies:
[10:31:22.933] 1. multicore:
[10:31:22.933]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:22.933]    - tweaked: FALSE
[10:31:22.933]    - call: plan(strategy)
[10:31:22.925] MulticoreFuture:
[10:31:22.925] Label: ‘future_vapply-2’
[10:31:22.925] Expression:
[10:31:22.925] {
[10:31:22.925]     do.call(function(...) {
[10:31:22.925]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.925]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.925]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.925]             on.exit(options(oopts), add = TRUE)
[10:31:22.925]         }
[10:31:22.925]         {
[10:31:22.925]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.925]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.925]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.925]             })
[10:31:22.925]         }
[10:31:22.925]     }, args = future.call.arguments)
[10:31:22.925] }
[10:31:22.925] Lazy evaluation: FALSE
[10:31:22.925] Asynchronous evaluation: TRUE
[10:31:22.925] Local evaluation: TRUE
[10:31:22.925] Environment: R_GlobalEnv
[10:31:22.925] Capture standard output: TRUE
[10:31:22.925] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:22.925] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:22.925] Packages: 1 packages (‘future.apply’)
[10:31:22.925] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:22.925] Resolved: FALSE
[10:31:22.925] Value: <not collected>
[10:31:22.925] Conditions captured: <none>
[10:31:22.925] Early signaling: FALSE
[10:31:22.925] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:22.925] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.940] Chunk #2 of 2 ... DONE
[10:31:22.940] plan(): nbrOfWorkers() = 2
[10:31:22.941] Launching 2 futures (chunks) ... DONE
[10:31:22.941] Resolving 2 futures (chunks) ...
[10:31:22.941] resolve() on list ...
[10:31:22.942]  recursive: 0
[10:31:22.942]  length: 2
[10:31:22.942] 
[10:31:22.942] Future #1
[10:31:22.943] result() for MulticoreFuture ...
[10:31:22.944] result() for MulticoreFuture ...
[10:31:22.944] result() for MulticoreFuture ... done
[10:31:22.944] result() for MulticoreFuture ... done
[10:31:22.945] result() for MulticoreFuture ...
[10:31:22.945] result() for MulticoreFuture ... done
[10:31:22.946] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:22.946] - nx: 2
[10:31:22.946] - relay: TRUE
[10:31:22.947] - stdout: TRUE
[10:31:22.947] - signal: TRUE
[10:31:22.947] - resignal: FALSE
[10:31:22.947] - force: TRUE
[10:31:22.948] - relayed: [n=2] FALSE, FALSE
[10:31:22.948] - queued futures: [n=2] FALSE, FALSE
[10:31:22.948]  - until=1
[10:31:22.949]  - relaying element #1
[10:31:22.949] result() for MulticoreFuture ...
[10:31:22.949] result() for MulticoreFuture ... done
[10:31:22.949] result() for MulticoreFuture ...
[10:31:22.950] result() for MulticoreFuture ... done
[10:31:22.950] result() for MulticoreFuture ...
[10:31:22.950] result() for MulticoreFuture ... done
[10:31:22.950] result() for MulticoreFuture ...
[10:31:22.951] result() for MulticoreFuture ... done
[10:31:22.951] - relayed: [n=2] TRUE, FALSE
[10:31:22.951] - queued futures: [n=2] TRUE, FALSE
[10:31:22.951] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:22.951]  length: 1 (resolved future 1)
[10:31:22.951] Future #2
[10:31:22.952] result() for MulticoreFuture ...
[10:31:22.952] result() for MulticoreFuture ...
[10:31:22.953] result() for MulticoreFuture ... done
[10:31:22.953] result() for MulticoreFuture ... done
[10:31:22.953] result() for MulticoreFuture ...
[10:31:22.953] result() for MulticoreFuture ... done
[10:31:22.953] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:22.953] - nx: 2
[10:31:22.954] - relay: TRUE
[10:31:22.954] - stdout: TRUE
[10:31:22.954] - signal: TRUE
[10:31:22.954] - resignal: FALSE
[10:31:22.954] - force: TRUE
[10:31:22.954] - relayed: [n=2] TRUE, FALSE
[10:31:22.954] - queued futures: [n=2] TRUE, FALSE
[10:31:22.954]  - until=2
[10:31:22.955]  - relaying element #2
[10:31:22.955] result() for MulticoreFuture ...
[10:31:22.955] result() for MulticoreFuture ... done
[10:31:22.955] result() for MulticoreFuture ...
[10:31:22.955] result() for MulticoreFuture ... done
[10:31:22.955] result() for MulticoreFuture ...
[10:31:22.955] result() for MulticoreFuture ... done
[10:31:22.955] result() for MulticoreFuture ...
[10:31:22.956] result() for MulticoreFuture ... done
[10:31:22.956] - relayed: [n=2] TRUE, TRUE
[10:31:22.956] - queued futures: [n=2] TRUE, TRUE
[10:31:22.956] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:22.956]  length: 0 (resolved future 2)
[10:31:22.956] Relaying remaining futures
[10:31:22.956] signalConditionsASAP(NULL, pos=0) ...
[10:31:22.956] - nx: 2
[10:31:22.956] - relay: TRUE
[10:31:22.957] - stdout: TRUE
[10:31:22.957] - signal: TRUE
[10:31:22.957] - resignal: FALSE
[10:31:22.957] - force: TRUE
[10:31:22.957] - relayed: [n=2] TRUE, TRUE
[10:31:22.957] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:22.957] - relayed: [n=2] TRUE, TRUE
[10:31:22.957] - queued futures: [n=2] TRUE, TRUE
[10:31:22.957] signalConditionsASAP(NULL, pos=0) ... done
[10:31:22.958] resolve() on list ... DONE
[10:31:22.958] result() for MulticoreFuture ...
[10:31:22.958] result() for MulticoreFuture ... done
[10:31:22.958] result() for MulticoreFuture ...
[10:31:22.958] result() for MulticoreFuture ... done
[10:31:22.958] result() for MulticoreFuture ...
[10:31:22.958] result() for MulticoreFuture ... done
[10:31:22.958] result() for MulticoreFuture ...
[10:31:22.958] result() for MulticoreFuture ... done
[10:31:22.959]  - Number of value chunks collected: 2
[10:31:22.959] Resolving 2 futures (chunks) ... DONE
[10:31:22.959] Reducing values from 2 chunks ...
[10:31:22.959]  - Number of values collected after concatenation: 10
[10:31:22.959]  - Number of values expected: 10
[10:31:22.959] Reducing values from 2 chunks ... DONE
[10:31:22.959] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[10:31:22.960] future_lapply() ...
[10:31:22.966] Number of chunks: 2
[10:31:22.966] getGlobalsAndPackagesXApply() ...
[10:31:22.966]  - future.globals: TRUE
[10:31:22.967] getGlobalsAndPackages() ...
[10:31:22.967] Searching for globals...
[10:31:22.971] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[10:31:22.973] Searching for globals ... DONE
[10:31:22.973] Resolving globals: FALSE
[10:31:22.974] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[10:31:22.974] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:22.975] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.975] - packages: [1] ‘future.apply’
[10:31:22.975] getGlobalsAndPackages() ... DONE
[10:31:22.975]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:22.975]  - needed namespaces: [n=1] ‘future.apply’
[10:31:22.975] Finding globals ... DONE
[10:31:22.975]  - use_args: TRUE
[10:31:22.976]  - Getting '...' globals ...
[10:31:22.976] resolve() on list ...
[10:31:22.976]  recursive: 0
[10:31:22.976]  length: 1
[10:31:22.976]  elements: ‘...’
[10:31:22.976]  length: 0 (resolved future 1)
[10:31:22.976] resolve() on list ... DONE
[10:31:22.977]    - '...' content: [n=0] 
[10:31:22.977] List of 1
[10:31:22.977]  $ ...: list()
[10:31:22.977]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.977]  - attr(*, "where")=List of 1
[10:31:22.977]   ..$ ...:<environment: 0x55de8526e708> 
[10:31:22.977]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.977]  - attr(*, "resolved")= logi TRUE
[10:31:22.977]  - attr(*, "total_size")= num NA
[10:31:22.979]  - Getting '...' globals ... DONE
[10:31:22.980] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:22.980] List of 8
[10:31:22.980]  $ ...future.FUN:function (x, ...)  
[10:31:22.980]  $ x_FUN        :function (x)  
[10:31:22.980]  $ times        : int 2
[10:31:22.980]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:22.980]  $ stop_if_not  :function (...)  
[10:31:22.980]  $ dim          : NULL
[10:31:22.980]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:22.980]  $ ...          : list()
[10:31:22.980]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:22.980]  - attr(*, "where")=List of 8
[10:31:22.980]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:22.980]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:22.980]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:22.980]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:22.980]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:22.980]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:22.980]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:22.980]   ..$ ...          :<environment: 0x55de8526e708> 
[10:31:22.980]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:22.980]  - attr(*, "resolved")= logi FALSE
[10:31:22.980]  - attr(*, "total_size")= num 96456
[10:31:22.985] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:22.985] getGlobalsAndPackagesXApply() ... DONE
[10:31:22.986] Number of futures (= number of chunks): 2
[10:31:22.986] Launching 2 futures (chunks) ...
[10:31:22.986] Chunk #1 of 2 ...
[10:31:22.986]  - Finding globals in 'X' for chunk #1 ...
[10:31:22.986] getGlobalsAndPackages() ...
[10:31:22.986] Searching for globals...
[10:31:22.986] 
[10:31:22.987] Searching for globals ... DONE
[10:31:22.987] - globals: [0] <none>
[10:31:22.987] getGlobalsAndPackages() ... DONE
[10:31:22.987]    + additional globals found: [n=0] 
[10:31:22.987]    + additional namespaces needed: [n=0] 
[10:31:22.987]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:22.987]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:22.987]  - seeds: <none>
[10:31:22.987]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.987] getGlobalsAndPackages() ...
[10:31:22.987] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.988] Resolving globals: FALSE
[10:31:22.988] Tweak future expression to call with '...' arguments ...
[10:31:22.988] {
[10:31:22.988]     do.call(function(...) {
[10:31:22.988]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.988]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:22.988]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.988]             on.exit(options(oopts), add = TRUE)
[10:31:22.988]         }
[10:31:22.988]         {
[10:31:22.988]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:22.988]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.988]                 ...future.FUN(...future.X_jj, ...)
[10:31:22.988]             })
[10:31:22.988]         }
[10:31:22.988]     }, args = future.call.arguments)
[10:31:22.988] }
[10:31:22.988] Tweak future expression to call with '...' arguments ... DONE
[10:31:22.989] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:22.989] - packages: [1] ‘future.apply’
[10:31:22.989] getGlobalsAndPackages() ... DONE
[10:31:22.989] run() for ‘Future’ ...
[10:31:22.989] - state: ‘created’
[10:31:22.990] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:22.994] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:22.994] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:22.994]   - Field: ‘label’
[10:31:22.994]   - Field: ‘local’
[10:31:22.994]   - Field: ‘owner’
[10:31:22.994]   - Field: ‘envir’
[10:31:22.994]   - Field: ‘workers’
[10:31:22.994]   - Field: ‘packages’
[10:31:22.994]   - Field: ‘gc’
[10:31:22.995]   - Field: ‘job’
[10:31:22.995]   - Field: ‘conditions’
[10:31:22.997]   - Field: ‘expr’
[10:31:22.997]   - Field: ‘uuid’
[10:31:22.997]   - Field: ‘seed’
[10:31:22.997]   - Field: ‘version’
[10:31:22.997]   - Field: ‘result’
[10:31:22.997]   - Field: ‘asynchronous’
[10:31:22.997]   - Field: ‘calls’
[10:31:22.997]   - Field: ‘globals’
[10:31:22.998]   - Field: ‘stdout’
[10:31:22.998]   - Field: ‘earlySignal’
[10:31:22.998]   - Field: ‘lazy’
[10:31:22.998]   - Field: ‘state’
[10:31:22.998] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:22.998] - Launch lazy future ...
[10:31:22.999] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:22.999] Packages needed by future strategies (n = 0): <none>
[10:31:22.999] {
[10:31:22.999]     {
[10:31:22.999]         {
[10:31:22.999]             ...future.startTime <- base::Sys.time()
[10:31:22.999]             {
[10:31:22.999]                 {
[10:31:22.999]                   {
[10:31:22.999]                     {
[10:31:22.999]                       {
[10:31:22.999]                         base::local({
[10:31:22.999]                           has_future <- base::requireNamespace("future", 
[10:31:22.999]                             quietly = TRUE)
[10:31:22.999]                           if (has_future) {
[10:31:22.999]                             ns <- base::getNamespace("future")
[10:31:22.999]                             version <- ns[[".package"]][["version"]]
[10:31:22.999]                             if (is.null(version)) 
[10:31:22.999]                               version <- utils::packageVersion("future")
[10:31:22.999]                           }
[10:31:22.999]                           else {
[10:31:22.999]                             version <- NULL
[10:31:22.999]                           }
[10:31:22.999]                           if (!has_future || version < "1.8.0") {
[10:31:22.999]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:22.999]                               "", base::R.version$version.string), 
[10:31:22.999]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:22.999]                                 base::R.version$platform, 8 * 
[10:31:22.999]                                   base::.Machine$sizeof.pointer), 
[10:31:22.999]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:22.999]                                 "release", "version")], collapse = " "), 
[10:31:22.999]                               hostname = base::Sys.info()[["nodename"]])
[10:31:22.999]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:22.999]                               info)
[10:31:22.999]                             info <- base::paste(info, collapse = "; ")
[10:31:22.999]                             if (!has_future) {
[10:31:22.999]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:22.999]                                 info)
[10:31:22.999]                             }
[10:31:22.999]                             else {
[10:31:22.999]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:22.999]                                 info, version)
[10:31:22.999]                             }
[10:31:22.999]                             base::stop(msg)
[10:31:22.999]                           }
[10:31:22.999]                         })
[10:31:22.999]                       }
[10:31:22.999]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:22.999]                       base::options(mc.cores = 1L)
[10:31:22.999]                     }
[10:31:22.999]                     base::local({
[10:31:22.999]                       for (pkg in "future.apply") {
[10:31:22.999]                         base::loadNamespace(pkg)
[10:31:22.999]                         base::library(pkg, character.only = TRUE)
[10:31:22.999]                       }
[10:31:22.999]                     })
[10:31:22.999]                   }
[10:31:22.999]                   ...future.strategy.old <- future::plan("list")
[10:31:22.999]                   options(future.plan = NULL)
[10:31:22.999]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.999]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:22.999]                 }
[10:31:22.999]                 ...future.workdir <- getwd()
[10:31:22.999]             }
[10:31:22.999]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:22.999]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:22.999]         }
[10:31:22.999]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:22.999]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:22.999]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:22.999]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:22.999]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:22.999]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:22.999]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:22.999]             base::names(...future.oldOptions))
[10:31:22.999]     }
[10:31:22.999]     if (FALSE) {
[10:31:22.999]     }
[10:31:22.999]     else {
[10:31:22.999]         if (TRUE) {
[10:31:22.999]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:22.999]                 open = "w")
[10:31:22.999]         }
[10:31:22.999]         else {
[10:31:22.999]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:22.999]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:22.999]         }
[10:31:22.999]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:22.999]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:22.999]             base::sink(type = "output", split = FALSE)
[10:31:22.999]             base::close(...future.stdout)
[10:31:22.999]         }, add = TRUE)
[10:31:22.999]     }
[10:31:22.999]     ...future.frame <- base::sys.nframe()
[10:31:22.999]     ...future.conditions <- base::list()
[10:31:22.999]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:22.999]     if (FALSE) {
[10:31:22.999]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:22.999]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:22.999]     }
[10:31:22.999]     ...future.result <- base::tryCatch({
[10:31:22.999]         base::withCallingHandlers({
[10:31:22.999]             ...future.value <- base::withVisible(base::local({
[10:31:22.999]                 withCallingHandlers({
[10:31:22.999]                   {
[10:31:22.999]                     do.call(function(...) {
[10:31:22.999]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:22.999]                       if (!identical(...future.globals.maxSize.org, 
[10:31:22.999]                         ...future.globals.maxSize)) {
[10:31:22.999]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:22.999]                         on.exit(options(oopts), add = TRUE)
[10:31:22.999]                       }
[10:31:22.999]                       {
[10:31:22.999]                         lapply(seq_along(...future.elements_ii), 
[10:31:22.999]                           FUN = function(jj) {
[10:31:22.999]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:22.999]                             ...future.FUN(...future.X_jj, ...)
[10:31:22.999]                           })
[10:31:22.999]                       }
[10:31:22.999]                     }, args = future.call.arguments)
[10:31:22.999]                   }
[10:31:22.999]                 }, immediateCondition = function(cond) {
[10:31:22.999]                   save_rds <- function (object, pathname, ...) 
[10:31:22.999]                   {
[10:31:22.999]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:22.999]                     if (file_test("-f", pathname_tmp)) {
[10:31:22.999]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.999]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:22.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.999]                         fi_tmp[["mtime"]])
[10:31:22.999]                     }
[10:31:22.999]                     tryCatch({
[10:31:22.999]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:22.999]                     }, error = function(ex) {
[10:31:22.999]                       msg <- conditionMessage(ex)
[10:31:22.999]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.999]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:22.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.999]                         fi_tmp[["mtime"]], msg)
[10:31:22.999]                       ex$message <- msg
[10:31:22.999]                       stop(ex)
[10:31:22.999]                     })
[10:31:22.999]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:22.999]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:22.999]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:22.999]                       fi_tmp <- file.info(pathname_tmp)
[10:31:22.999]                       fi <- file.info(pathname)
[10:31:22.999]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:22.999]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:22.999]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:22.999]                         fi[["size"]], fi[["mtime"]])
[10:31:22.999]                       stop(msg)
[10:31:22.999]                     }
[10:31:22.999]                     invisible(pathname)
[10:31:22.999]                   }
[10:31:22.999]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:22.999]                     rootPath = tempdir()) 
[10:31:22.999]                   {
[10:31:22.999]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:22.999]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:22.999]                       tmpdir = path, fileext = ".rds")
[10:31:22.999]                     save_rds(obj, file)
[10:31:22.999]                   }
[10:31:22.999]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:22.999]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.999]                   {
[10:31:22.999]                     inherits <- base::inherits
[10:31:22.999]                     invokeRestart <- base::invokeRestart
[10:31:22.999]                     is.null <- base::is.null
[10:31:22.999]                     muffled <- FALSE
[10:31:22.999]                     if (inherits(cond, "message")) {
[10:31:22.999]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:22.999]                       if (muffled) 
[10:31:22.999]                         invokeRestart("muffleMessage")
[10:31:22.999]                     }
[10:31:22.999]                     else if (inherits(cond, "warning")) {
[10:31:22.999]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:22.999]                       if (muffled) 
[10:31:22.999]                         invokeRestart("muffleWarning")
[10:31:22.999]                     }
[10:31:22.999]                     else if (inherits(cond, "condition")) {
[10:31:22.999]                       if (!is.null(pattern)) {
[10:31:22.999]                         computeRestarts <- base::computeRestarts
[10:31:22.999]                         grepl <- base::grepl
[10:31:22.999]                         restarts <- computeRestarts(cond)
[10:31:22.999]                         for (restart in restarts) {
[10:31:22.999]                           name <- restart$name
[10:31:22.999]                           if (is.null(name)) 
[10:31:22.999]                             next
[10:31:22.999]                           if (!grepl(pattern, name)) 
[10:31:22.999]                             next
[10:31:22.999]                           invokeRestart(restart)
[10:31:22.999]                           muffled <- TRUE
[10:31:22.999]                           break
[10:31:22.999]                         }
[10:31:22.999]                       }
[10:31:22.999]                     }
[10:31:22.999]                     invisible(muffled)
[10:31:22.999]                   }
[10:31:22.999]                   muffleCondition(cond)
[10:31:22.999]                 })
[10:31:22.999]             }))
[10:31:22.999]             future::FutureResult(value = ...future.value$value, 
[10:31:22.999]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.999]                   ...future.rng), globalenv = if (FALSE) 
[10:31:22.999]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:22.999]                     ...future.globalenv.names))
[10:31:22.999]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:22.999]         }, condition = base::local({
[10:31:22.999]             c <- base::c
[10:31:22.999]             inherits <- base::inherits
[10:31:22.999]             invokeRestart <- base::invokeRestart
[10:31:22.999]             length <- base::length
[10:31:22.999]             list <- base::list
[10:31:22.999]             seq.int <- base::seq.int
[10:31:22.999]             signalCondition <- base::signalCondition
[10:31:22.999]             sys.calls <- base::sys.calls
[10:31:22.999]             `[[` <- base::`[[`
[10:31:22.999]             `+` <- base::`+`
[10:31:22.999]             `<<-` <- base::`<<-`
[10:31:22.999]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:22.999]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:22.999]                   3L)]
[10:31:22.999]             }
[10:31:22.999]             function(cond) {
[10:31:22.999]                 is_error <- inherits(cond, "error")
[10:31:22.999]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:22.999]                   NULL)
[10:31:22.999]                 if (is_error) {
[10:31:22.999]                   sessionInformation <- function() {
[10:31:22.999]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:22.999]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:22.999]                       search = base::search(), system = base::Sys.info())
[10:31:22.999]                   }
[10:31:22.999]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.999]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:22.999]                     cond$call), session = sessionInformation(), 
[10:31:22.999]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:22.999]                   signalCondition(cond)
[10:31:22.999]                 }
[10:31:22.999]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:22.999]                 "immediateCondition"))) {
[10:31:22.999]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:22.999]                   ...future.conditions[[length(...future.conditions) + 
[10:31:22.999]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:22.999]                   if (TRUE && !signal) {
[10:31:22.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.999]                     {
[10:31:22.999]                       inherits <- base::inherits
[10:31:22.999]                       invokeRestart <- base::invokeRestart
[10:31:22.999]                       is.null <- base::is.null
[10:31:22.999]                       muffled <- FALSE
[10:31:22.999]                       if (inherits(cond, "message")) {
[10:31:22.999]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.999]                         if (muffled) 
[10:31:22.999]                           invokeRestart("muffleMessage")
[10:31:22.999]                       }
[10:31:22.999]                       else if (inherits(cond, "warning")) {
[10:31:22.999]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.999]                         if (muffled) 
[10:31:22.999]                           invokeRestart("muffleWarning")
[10:31:22.999]                       }
[10:31:22.999]                       else if (inherits(cond, "condition")) {
[10:31:22.999]                         if (!is.null(pattern)) {
[10:31:22.999]                           computeRestarts <- base::computeRestarts
[10:31:22.999]                           grepl <- base::grepl
[10:31:22.999]                           restarts <- computeRestarts(cond)
[10:31:22.999]                           for (restart in restarts) {
[10:31:22.999]                             name <- restart$name
[10:31:22.999]                             if (is.null(name)) 
[10:31:22.999]                               next
[10:31:22.999]                             if (!grepl(pattern, name)) 
[10:31:22.999]                               next
[10:31:22.999]                             invokeRestart(restart)
[10:31:22.999]                             muffled <- TRUE
[10:31:22.999]                             break
[10:31:22.999]                           }
[10:31:22.999]                         }
[10:31:22.999]                       }
[10:31:22.999]                       invisible(muffled)
[10:31:22.999]                     }
[10:31:22.999]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.999]                   }
[10:31:22.999]                 }
[10:31:22.999]                 else {
[10:31:22.999]                   if (TRUE) {
[10:31:22.999]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:22.999]                     {
[10:31:22.999]                       inherits <- base::inherits
[10:31:22.999]                       invokeRestart <- base::invokeRestart
[10:31:22.999]                       is.null <- base::is.null
[10:31:22.999]                       muffled <- FALSE
[10:31:22.999]                       if (inherits(cond, "message")) {
[10:31:22.999]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:22.999]                         if (muffled) 
[10:31:22.999]                           invokeRestart("muffleMessage")
[10:31:22.999]                       }
[10:31:22.999]                       else if (inherits(cond, "warning")) {
[10:31:22.999]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:22.999]                         if (muffled) 
[10:31:22.999]                           invokeRestart("muffleWarning")
[10:31:22.999]                       }
[10:31:22.999]                       else if (inherits(cond, "condition")) {
[10:31:22.999]                         if (!is.null(pattern)) {
[10:31:22.999]                           computeRestarts <- base::computeRestarts
[10:31:22.999]                           grepl <- base::grepl
[10:31:22.999]                           restarts <- computeRestarts(cond)
[10:31:22.999]                           for (restart in restarts) {
[10:31:22.999]                             name <- restart$name
[10:31:22.999]                             if (is.null(name)) 
[10:31:22.999]                               next
[10:31:22.999]                             if (!grepl(pattern, name)) 
[10:31:22.999]                               next
[10:31:22.999]                             invokeRestart(restart)
[10:31:22.999]                             muffled <- TRUE
[10:31:22.999]                             break
[10:31:22.999]                           }
[10:31:22.999]                         }
[10:31:22.999]                       }
[10:31:22.999]                       invisible(muffled)
[10:31:22.999]                     }
[10:31:22.999]                     muffleCondition(cond, pattern = "^muffle")
[10:31:22.999]                   }
[10:31:22.999]                 }
[10:31:22.999]             }
[10:31:22.999]         }))
[10:31:22.999]     }, error = function(ex) {
[10:31:22.999]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:22.999]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:22.999]                 ...future.rng), started = ...future.startTime, 
[10:31:22.999]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:22.999]             version = "1.8"), class = "FutureResult")
[10:31:22.999]     }, finally = {
[10:31:22.999]         if (!identical(...future.workdir, getwd())) 
[10:31:22.999]             setwd(...future.workdir)
[10:31:22.999]         {
[10:31:22.999]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:22.999]                 ...future.oldOptions$nwarnings <- NULL
[10:31:22.999]             }
[10:31:22.999]             base::options(...future.oldOptions)
[10:31:22.999]             if (.Platform$OS.type == "windows") {
[10:31:22.999]                 old_names <- names(...future.oldEnvVars)
[10:31:22.999]                 envs <- base::Sys.getenv()
[10:31:22.999]                 names <- names(envs)
[10:31:22.999]                 common <- intersect(names, old_names)
[10:31:22.999]                 added <- setdiff(names, old_names)
[10:31:22.999]                 removed <- setdiff(old_names, names)
[10:31:22.999]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:22.999]                   envs[common]]
[10:31:22.999]                 NAMES <- toupper(changed)
[10:31:22.999]                 args <- list()
[10:31:22.999]                 for (kk in seq_along(NAMES)) {
[10:31:22.999]                   name <- changed[[kk]]
[10:31:22.999]                   NAME <- NAMES[[kk]]
[10:31:22.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.999]                     next
[10:31:22.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.999]                 }
[10:31:22.999]                 NAMES <- toupper(added)
[10:31:22.999]                 for (kk in seq_along(NAMES)) {
[10:31:22.999]                   name <- added[[kk]]
[10:31:22.999]                   NAME <- NAMES[[kk]]
[10:31:22.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.999]                     next
[10:31:22.999]                   args[[name]] <- ""
[10:31:22.999]                 }
[10:31:22.999]                 NAMES <- toupper(removed)
[10:31:22.999]                 for (kk in seq_along(NAMES)) {
[10:31:22.999]                   name <- removed[[kk]]
[10:31:22.999]                   NAME <- NAMES[[kk]]
[10:31:22.999]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:22.999]                     next
[10:31:22.999]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:22.999]                 }
[10:31:22.999]                 if (length(args) > 0) 
[10:31:22.999]                   base::do.call(base::Sys.setenv, args = args)
[10:31:22.999]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:22.999]             }
[10:31:22.999]             else {
[10:31:22.999]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:22.999]             }
[10:31:22.999]             {
[10:31:22.999]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:22.999]                   0L) {
[10:31:22.999]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:22.999]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:22.999]                   base::options(opts)
[10:31:22.999]                 }
[10:31:22.999]                 {
[10:31:22.999]                   {
[10:31:22.999]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:22.999]                     NULL
[10:31:22.999]                   }
[10:31:22.999]                   options(future.plan = NULL)
[10:31:22.999]                   if (is.na(NA_character_)) 
[10:31:22.999]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:22.999]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:22.999]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:22.999]                     .init = FALSE)
[10:31:22.999]                 }
[10:31:22.999]             }
[10:31:22.999]         }
[10:31:22.999]     })
[10:31:22.999]     if (TRUE) {
[10:31:22.999]         base::sink(type = "output", split = FALSE)
[10:31:22.999]         if (TRUE) {
[10:31:22.999]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:22.999]         }
[10:31:22.999]         else {
[10:31:22.999]             ...future.result["stdout"] <- base::list(NULL)
[10:31:22.999]         }
[10:31:22.999]         base::close(...future.stdout)
[10:31:22.999]         ...future.stdout <- NULL
[10:31:22.999]     }
[10:31:22.999]     ...future.result$conditions <- ...future.conditions
[10:31:22.999]     ...future.result$finished <- base::Sys.time()
[10:31:22.999]     ...future.result
[10:31:22.999] }
[10:31:23.002] assign_globals() ...
[10:31:23.002] List of 11
[10:31:23.002]  $ ...future.FUN            :function (x, ...)  
[10:31:23.002]  $ x_FUN                    :function (x)  
[10:31:23.002]  $ times                    : int 2
[10:31:23.002]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.002]  $ stop_if_not              :function (...)  
[10:31:23.002]  $ dim                      : NULL
[10:31:23.002]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:23.002]  $ future.call.arguments    : list()
[10:31:23.002]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.002]  $ ...future.elements_ii    :List of 5
[10:31:23.002]   ..$ : int 1
[10:31:23.002]   ..$ : int 2
[10:31:23.002]   ..$ : int 3
[10:31:23.002]   ..$ : int 4
[10:31:23.002]   ..$ : int 5
[10:31:23.002]  $ ...future.seeds_ii       : NULL
[10:31:23.002]  $ ...future.globals.maxSize: NULL
[10:31:23.002]  - attr(*, "where")=List of 11
[10:31:23.002]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.002]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:23.002]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:23.002]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:23.002]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:23.002]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:23.002]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:23.002]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.002]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.002]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.002]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.002]  - attr(*, "resolved")= logi FALSE
[10:31:23.002]  - attr(*, "total_size")= num 96456
[10:31:23.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.002]  - attr(*, "already-done")= logi TRUE
[10:31:23.011] - copied ‘...future.FUN’ to environment
[10:31:23.011] - reassign environment for ‘x_FUN’
[10:31:23.011] - copied ‘x_FUN’ to environment
[10:31:23.011] - copied ‘times’ to environment
[10:31:23.011] - copied ‘stopf’ to environment
[10:31:23.011] - copied ‘stop_if_not’ to environment
[10:31:23.012] - copied ‘dim’ to environment
[10:31:23.012] - copied ‘valid_types’ to environment
[10:31:23.012] - copied ‘future.call.arguments’ to environment
[10:31:23.012] - copied ‘...future.elements_ii’ to environment
[10:31:23.012] - copied ‘...future.seeds_ii’ to environment
[10:31:23.012] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.012] assign_globals() ... done
[10:31:23.012] requestCore(): workers = 2
[10:31:23.015] MulticoreFuture started
[10:31:23.015] - Launch lazy future ... done
[10:31:23.015] run() for ‘MulticoreFuture’ ... done
[10:31:23.015] Created future:
[10:31:23.016] plan(): Setting new future strategy stack:
[10:31:23.016] List of future strategies:
[10:31:23.016] 1. sequential:
[10:31:23.016]    - args: function (..., envir = parent.frame())
[10:31:23.016]    - tweaked: FALSE
[10:31:23.016]    - call: NULL
[10:31:23.017] plan(): nbrOfWorkers() = 1
[10:31:23.019] plan(): Setting new future strategy stack:
[10:31:23.020] List of future strategies:
[10:31:23.020] 1. multicore:
[10:31:23.020]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.020]    - tweaked: FALSE
[10:31:23.020]    - call: plan(strategy)
[10:31:23.025] plan(): nbrOfWorkers() = 2
[10:31:23.016] MulticoreFuture:
[10:31:23.016] Label: ‘future_vapply-1’
[10:31:23.016] Expression:
[10:31:23.016] {
[10:31:23.016]     do.call(function(...) {
[10:31:23.016]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.016]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.016]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.016]             on.exit(options(oopts), add = TRUE)
[10:31:23.016]         }
[10:31:23.016]         {
[10:31:23.016]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.016]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.016]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.016]             })
[10:31:23.016]         }
[10:31:23.016]     }, args = future.call.arguments)
[10:31:23.016] }
[10:31:23.016] Lazy evaluation: FALSE
[10:31:23.016] Asynchronous evaluation: TRUE
[10:31:23.016] Local evaluation: TRUE
[10:31:23.016] Environment: R_GlobalEnv
[10:31:23.016] Capture standard output: TRUE
[10:31:23.016] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.016] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:23.016] Packages: 1 packages (‘future.apply’)
[10:31:23.016] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.016] Resolved: TRUE
[10:31:23.016] Value: <not collected>
[10:31:23.016] Conditions captured: <none>
[10:31:23.016] Early signaling: FALSE
[10:31:23.016] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.016] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.026] Chunk #1 of 2 ... DONE
[10:31:23.026] Chunk #2 of 2 ...
[10:31:23.026]  - Finding globals in 'X' for chunk #2 ...
[10:31:23.026] getGlobalsAndPackages() ...
[10:31:23.027] Searching for globals...
[10:31:23.027] 
[10:31:23.027] Searching for globals ... DONE
[10:31:23.027] - globals: [0] <none>
[10:31:23.027] getGlobalsAndPackages() ... DONE
[10:31:23.028]    + additional globals found: [n=0] 
[10:31:23.028]    + additional namespaces needed: [n=0] 
[10:31:23.028]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:23.028]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.028]  - seeds: <none>
[10:31:23.028]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.028] getGlobalsAndPackages() ...
[10:31:23.029] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.029] Resolving globals: FALSE
[10:31:23.029] Tweak future expression to call with '...' arguments ...
[10:31:23.029] {
[10:31:23.029]     do.call(function(...) {
[10:31:23.029]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.029]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.029]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.029]             on.exit(options(oopts), add = TRUE)
[10:31:23.029]         }
[10:31:23.029]         {
[10:31:23.029]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.029]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.029]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.029]             })
[10:31:23.029]         }
[10:31:23.029]     }, args = future.call.arguments)
[10:31:23.029] }
[10:31:23.030] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.031] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.031] - packages: [1] ‘future.apply’
[10:31:23.031] getGlobalsAndPackages() ... DONE
[10:31:23.035] run() for ‘Future’ ...
[10:31:23.035] - state: ‘created’
[10:31:23.036] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.043] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.043] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.044]   - Field: ‘label’
[10:31:23.044]   - Field: ‘local’
[10:31:23.044]   - Field: ‘owner’
[10:31:23.044]   - Field: ‘envir’
[10:31:23.045]   - Field: ‘workers’
[10:31:23.045]   - Field: ‘packages’
[10:31:23.045]   - Field: ‘gc’
[10:31:23.045]   - Field: ‘job’
[10:31:23.046]   - Field: ‘conditions’
[10:31:23.046]   - Field: ‘expr’
[10:31:23.046]   - Field: ‘uuid’
[10:31:23.046]   - Field: ‘seed’
[10:31:23.046]   - Field: ‘version’
[10:31:23.047]   - Field: ‘result’
[10:31:23.047]   - Field: ‘asynchronous’
[10:31:23.047]   - Field: ‘calls’
[10:31:23.047]   - Field: ‘globals’
[10:31:23.047]   - Field: ‘stdout’
[10:31:23.048]   - Field: ‘earlySignal’
[10:31:23.048]   - Field: ‘lazy’
[10:31:23.048]   - Field: ‘state’
[10:31:23.048] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.048] - Launch lazy future ...
[10:31:23.049] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:23.049] Packages needed by future strategies (n = 0): <none>
[10:31:23.050] {
[10:31:23.050]     {
[10:31:23.050]         {
[10:31:23.050]             ...future.startTime <- base::Sys.time()
[10:31:23.050]             {
[10:31:23.050]                 {
[10:31:23.050]                   {
[10:31:23.050]                     {
[10:31:23.050]                       {
[10:31:23.050]                         base::local({
[10:31:23.050]                           has_future <- base::requireNamespace("future", 
[10:31:23.050]                             quietly = TRUE)
[10:31:23.050]                           if (has_future) {
[10:31:23.050]                             ns <- base::getNamespace("future")
[10:31:23.050]                             version <- ns[[".package"]][["version"]]
[10:31:23.050]                             if (is.null(version)) 
[10:31:23.050]                               version <- utils::packageVersion("future")
[10:31:23.050]                           }
[10:31:23.050]                           else {
[10:31:23.050]                             version <- NULL
[10:31:23.050]                           }
[10:31:23.050]                           if (!has_future || version < "1.8.0") {
[10:31:23.050]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.050]                               "", base::R.version$version.string), 
[10:31:23.050]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.050]                                 base::R.version$platform, 8 * 
[10:31:23.050]                                   base::.Machine$sizeof.pointer), 
[10:31:23.050]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.050]                                 "release", "version")], collapse = " "), 
[10:31:23.050]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.050]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.050]                               info)
[10:31:23.050]                             info <- base::paste(info, collapse = "; ")
[10:31:23.050]                             if (!has_future) {
[10:31:23.050]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.050]                                 info)
[10:31:23.050]                             }
[10:31:23.050]                             else {
[10:31:23.050]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.050]                                 info, version)
[10:31:23.050]                             }
[10:31:23.050]                             base::stop(msg)
[10:31:23.050]                           }
[10:31:23.050]                         })
[10:31:23.050]                       }
[10:31:23.050]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.050]                       base::options(mc.cores = 1L)
[10:31:23.050]                     }
[10:31:23.050]                     base::local({
[10:31:23.050]                       for (pkg in "future.apply") {
[10:31:23.050]                         base::loadNamespace(pkg)
[10:31:23.050]                         base::library(pkg, character.only = TRUE)
[10:31:23.050]                       }
[10:31:23.050]                     })
[10:31:23.050]                   }
[10:31:23.050]                   ...future.strategy.old <- future::plan("list")
[10:31:23.050]                   options(future.plan = NULL)
[10:31:23.050]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.050]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.050]                 }
[10:31:23.050]                 ...future.workdir <- getwd()
[10:31:23.050]             }
[10:31:23.050]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.050]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.050]         }
[10:31:23.050]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.050]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.050]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.050]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.050]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.050]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.050]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.050]             base::names(...future.oldOptions))
[10:31:23.050]     }
[10:31:23.050]     if (FALSE) {
[10:31:23.050]     }
[10:31:23.050]     else {
[10:31:23.050]         if (TRUE) {
[10:31:23.050]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.050]                 open = "w")
[10:31:23.050]         }
[10:31:23.050]         else {
[10:31:23.050]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.050]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.050]         }
[10:31:23.050]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.050]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.050]             base::sink(type = "output", split = FALSE)
[10:31:23.050]             base::close(...future.stdout)
[10:31:23.050]         }, add = TRUE)
[10:31:23.050]     }
[10:31:23.050]     ...future.frame <- base::sys.nframe()
[10:31:23.050]     ...future.conditions <- base::list()
[10:31:23.050]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.050]     if (FALSE) {
[10:31:23.050]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.050]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.050]     }
[10:31:23.050]     ...future.result <- base::tryCatch({
[10:31:23.050]         base::withCallingHandlers({
[10:31:23.050]             ...future.value <- base::withVisible(base::local({
[10:31:23.050]                 withCallingHandlers({
[10:31:23.050]                   {
[10:31:23.050]                     do.call(function(...) {
[10:31:23.050]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.050]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.050]                         ...future.globals.maxSize)) {
[10:31:23.050]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.050]                         on.exit(options(oopts), add = TRUE)
[10:31:23.050]                       }
[10:31:23.050]                       {
[10:31:23.050]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.050]                           FUN = function(jj) {
[10:31:23.050]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.050]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.050]                           })
[10:31:23.050]                       }
[10:31:23.050]                     }, args = future.call.arguments)
[10:31:23.050]                   }
[10:31:23.050]                 }, immediateCondition = function(cond) {
[10:31:23.050]                   save_rds <- function (object, pathname, ...) 
[10:31:23.050]                   {
[10:31:23.050]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.050]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.050]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.050]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.050]                         fi_tmp[["mtime"]])
[10:31:23.050]                     }
[10:31:23.050]                     tryCatch({
[10:31:23.050]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.050]                     }, error = function(ex) {
[10:31:23.050]                       msg <- conditionMessage(ex)
[10:31:23.050]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.050]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.050]                         fi_tmp[["mtime"]], msg)
[10:31:23.050]                       ex$message <- msg
[10:31:23.050]                       stop(ex)
[10:31:23.050]                     })
[10:31:23.050]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.050]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.050]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.050]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.050]                       fi <- file.info(pathname)
[10:31:23.050]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.050]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.050]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.050]                         fi[["size"]], fi[["mtime"]])
[10:31:23.050]                       stop(msg)
[10:31:23.050]                     }
[10:31:23.050]                     invisible(pathname)
[10:31:23.050]                   }
[10:31:23.050]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.050]                     rootPath = tempdir()) 
[10:31:23.050]                   {
[10:31:23.050]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.050]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.050]                       tmpdir = path, fileext = ".rds")
[10:31:23.050]                     save_rds(obj, file)
[10:31:23.050]                   }
[10:31:23.050]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.050]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.050]                   {
[10:31:23.050]                     inherits <- base::inherits
[10:31:23.050]                     invokeRestart <- base::invokeRestart
[10:31:23.050]                     is.null <- base::is.null
[10:31:23.050]                     muffled <- FALSE
[10:31:23.050]                     if (inherits(cond, "message")) {
[10:31:23.050]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.050]                       if (muffled) 
[10:31:23.050]                         invokeRestart("muffleMessage")
[10:31:23.050]                     }
[10:31:23.050]                     else if (inherits(cond, "warning")) {
[10:31:23.050]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.050]                       if (muffled) 
[10:31:23.050]                         invokeRestart("muffleWarning")
[10:31:23.050]                     }
[10:31:23.050]                     else if (inherits(cond, "condition")) {
[10:31:23.050]                       if (!is.null(pattern)) {
[10:31:23.050]                         computeRestarts <- base::computeRestarts
[10:31:23.050]                         grepl <- base::grepl
[10:31:23.050]                         restarts <- computeRestarts(cond)
[10:31:23.050]                         for (restart in restarts) {
[10:31:23.050]                           name <- restart$name
[10:31:23.050]                           if (is.null(name)) 
[10:31:23.050]                             next
[10:31:23.050]                           if (!grepl(pattern, name)) 
[10:31:23.050]                             next
[10:31:23.050]                           invokeRestart(restart)
[10:31:23.050]                           muffled <- TRUE
[10:31:23.050]                           break
[10:31:23.050]                         }
[10:31:23.050]                       }
[10:31:23.050]                     }
[10:31:23.050]                     invisible(muffled)
[10:31:23.050]                   }
[10:31:23.050]                   muffleCondition(cond)
[10:31:23.050]                 })
[10:31:23.050]             }))
[10:31:23.050]             future::FutureResult(value = ...future.value$value, 
[10:31:23.050]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.050]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.050]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.050]                     ...future.globalenv.names))
[10:31:23.050]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.050]         }, condition = base::local({
[10:31:23.050]             c <- base::c
[10:31:23.050]             inherits <- base::inherits
[10:31:23.050]             invokeRestart <- base::invokeRestart
[10:31:23.050]             length <- base::length
[10:31:23.050]             list <- base::list
[10:31:23.050]             seq.int <- base::seq.int
[10:31:23.050]             signalCondition <- base::signalCondition
[10:31:23.050]             sys.calls <- base::sys.calls
[10:31:23.050]             `[[` <- base::`[[`
[10:31:23.050]             `+` <- base::`+`
[10:31:23.050]             `<<-` <- base::`<<-`
[10:31:23.050]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.050]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.050]                   3L)]
[10:31:23.050]             }
[10:31:23.050]             function(cond) {
[10:31:23.050]                 is_error <- inherits(cond, "error")
[10:31:23.050]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.050]                   NULL)
[10:31:23.050]                 if (is_error) {
[10:31:23.050]                   sessionInformation <- function() {
[10:31:23.050]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.050]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.050]                       search = base::search(), system = base::Sys.info())
[10:31:23.050]                   }
[10:31:23.050]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.050]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.050]                     cond$call), session = sessionInformation(), 
[10:31:23.050]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.050]                   signalCondition(cond)
[10:31:23.050]                 }
[10:31:23.050]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.050]                 "immediateCondition"))) {
[10:31:23.050]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.050]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.050]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.050]                   if (TRUE && !signal) {
[10:31:23.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.050]                     {
[10:31:23.050]                       inherits <- base::inherits
[10:31:23.050]                       invokeRestart <- base::invokeRestart
[10:31:23.050]                       is.null <- base::is.null
[10:31:23.050]                       muffled <- FALSE
[10:31:23.050]                       if (inherits(cond, "message")) {
[10:31:23.050]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.050]                         if (muffled) 
[10:31:23.050]                           invokeRestart("muffleMessage")
[10:31:23.050]                       }
[10:31:23.050]                       else if (inherits(cond, "warning")) {
[10:31:23.050]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.050]                         if (muffled) 
[10:31:23.050]                           invokeRestart("muffleWarning")
[10:31:23.050]                       }
[10:31:23.050]                       else if (inherits(cond, "condition")) {
[10:31:23.050]                         if (!is.null(pattern)) {
[10:31:23.050]                           computeRestarts <- base::computeRestarts
[10:31:23.050]                           grepl <- base::grepl
[10:31:23.050]                           restarts <- computeRestarts(cond)
[10:31:23.050]                           for (restart in restarts) {
[10:31:23.050]                             name <- restart$name
[10:31:23.050]                             if (is.null(name)) 
[10:31:23.050]                               next
[10:31:23.050]                             if (!grepl(pattern, name)) 
[10:31:23.050]                               next
[10:31:23.050]                             invokeRestart(restart)
[10:31:23.050]                             muffled <- TRUE
[10:31:23.050]                             break
[10:31:23.050]                           }
[10:31:23.050]                         }
[10:31:23.050]                       }
[10:31:23.050]                       invisible(muffled)
[10:31:23.050]                     }
[10:31:23.050]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.050]                   }
[10:31:23.050]                 }
[10:31:23.050]                 else {
[10:31:23.050]                   if (TRUE) {
[10:31:23.050]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.050]                     {
[10:31:23.050]                       inherits <- base::inherits
[10:31:23.050]                       invokeRestart <- base::invokeRestart
[10:31:23.050]                       is.null <- base::is.null
[10:31:23.050]                       muffled <- FALSE
[10:31:23.050]                       if (inherits(cond, "message")) {
[10:31:23.050]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.050]                         if (muffled) 
[10:31:23.050]                           invokeRestart("muffleMessage")
[10:31:23.050]                       }
[10:31:23.050]                       else if (inherits(cond, "warning")) {
[10:31:23.050]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.050]                         if (muffled) 
[10:31:23.050]                           invokeRestart("muffleWarning")
[10:31:23.050]                       }
[10:31:23.050]                       else if (inherits(cond, "condition")) {
[10:31:23.050]                         if (!is.null(pattern)) {
[10:31:23.050]                           computeRestarts <- base::computeRestarts
[10:31:23.050]                           grepl <- base::grepl
[10:31:23.050]                           restarts <- computeRestarts(cond)
[10:31:23.050]                           for (restart in restarts) {
[10:31:23.050]                             name <- restart$name
[10:31:23.050]                             if (is.null(name)) 
[10:31:23.050]                               next
[10:31:23.050]                             if (!grepl(pattern, name)) 
[10:31:23.050]                               next
[10:31:23.050]                             invokeRestart(restart)
[10:31:23.050]                             muffled <- TRUE
[10:31:23.050]                             break
[10:31:23.050]                           }
[10:31:23.050]                         }
[10:31:23.050]                       }
[10:31:23.050]                       invisible(muffled)
[10:31:23.050]                     }
[10:31:23.050]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.050]                   }
[10:31:23.050]                 }
[10:31:23.050]             }
[10:31:23.050]         }))
[10:31:23.050]     }, error = function(ex) {
[10:31:23.050]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.050]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.050]                 ...future.rng), started = ...future.startTime, 
[10:31:23.050]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.050]             version = "1.8"), class = "FutureResult")
[10:31:23.050]     }, finally = {
[10:31:23.050]         if (!identical(...future.workdir, getwd())) 
[10:31:23.050]             setwd(...future.workdir)
[10:31:23.050]         {
[10:31:23.050]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.050]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.050]             }
[10:31:23.050]             base::options(...future.oldOptions)
[10:31:23.050]             if (.Platform$OS.type == "windows") {
[10:31:23.050]                 old_names <- names(...future.oldEnvVars)
[10:31:23.050]                 envs <- base::Sys.getenv()
[10:31:23.050]                 names <- names(envs)
[10:31:23.050]                 common <- intersect(names, old_names)
[10:31:23.050]                 added <- setdiff(names, old_names)
[10:31:23.050]                 removed <- setdiff(old_names, names)
[10:31:23.050]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.050]                   envs[common]]
[10:31:23.050]                 NAMES <- toupper(changed)
[10:31:23.050]                 args <- list()
[10:31:23.050]                 for (kk in seq_along(NAMES)) {
[10:31:23.050]                   name <- changed[[kk]]
[10:31:23.050]                   NAME <- NAMES[[kk]]
[10:31:23.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.050]                     next
[10:31:23.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.050]                 }
[10:31:23.050]                 NAMES <- toupper(added)
[10:31:23.050]                 for (kk in seq_along(NAMES)) {
[10:31:23.050]                   name <- added[[kk]]
[10:31:23.050]                   NAME <- NAMES[[kk]]
[10:31:23.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.050]                     next
[10:31:23.050]                   args[[name]] <- ""
[10:31:23.050]                 }
[10:31:23.050]                 NAMES <- toupper(removed)
[10:31:23.050]                 for (kk in seq_along(NAMES)) {
[10:31:23.050]                   name <- removed[[kk]]
[10:31:23.050]                   NAME <- NAMES[[kk]]
[10:31:23.050]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.050]                     next
[10:31:23.050]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.050]                 }
[10:31:23.050]                 if (length(args) > 0) 
[10:31:23.050]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.050]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.050]             }
[10:31:23.050]             else {
[10:31:23.050]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.050]             }
[10:31:23.050]             {
[10:31:23.050]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.050]                   0L) {
[10:31:23.050]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.050]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.050]                   base::options(opts)
[10:31:23.050]                 }
[10:31:23.050]                 {
[10:31:23.050]                   {
[10:31:23.050]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.050]                     NULL
[10:31:23.050]                   }
[10:31:23.050]                   options(future.plan = NULL)
[10:31:23.050]                   if (is.na(NA_character_)) 
[10:31:23.050]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.050]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.050]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.050]                     .init = FALSE)
[10:31:23.050]                 }
[10:31:23.050]             }
[10:31:23.050]         }
[10:31:23.050]     })
[10:31:23.050]     if (TRUE) {
[10:31:23.050]         base::sink(type = "output", split = FALSE)
[10:31:23.050]         if (TRUE) {
[10:31:23.050]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.050]         }
[10:31:23.050]         else {
[10:31:23.050]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.050]         }
[10:31:23.050]         base::close(...future.stdout)
[10:31:23.050]         ...future.stdout <- NULL
[10:31:23.050]     }
[10:31:23.050]     ...future.result$conditions <- ...future.conditions
[10:31:23.050]     ...future.result$finished <- base::Sys.time()
[10:31:23.050]     ...future.result
[10:31:23.050] }
[10:31:23.053] assign_globals() ...
[10:31:23.053] List of 11
[10:31:23.053]  $ ...future.FUN            :function (x, ...)  
[10:31:23.053]  $ x_FUN                    :function (x)  
[10:31:23.053]  $ times                    : int 2
[10:31:23.053]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.053]  $ stop_if_not              :function (...)  
[10:31:23.053]  $ dim                      : NULL
[10:31:23.053]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:23.053]  $ future.call.arguments    : list()
[10:31:23.053]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.053]  $ ...future.elements_ii    :List of 5
[10:31:23.053]   ..$ : int 6
[10:31:23.053]   ..$ : int 7
[10:31:23.053]   ..$ : int 8
[10:31:23.053]   ..$ : int 9
[10:31:23.053]   ..$ : int 10
[10:31:23.053]  $ ...future.seeds_ii       : NULL
[10:31:23.053]  $ ...future.globals.maxSize: NULL
[10:31:23.053]  - attr(*, "where")=List of 11
[10:31:23.053]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.053]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:23.053]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:23.053]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:23.053]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:23.053]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:23.053]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:23.053]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.053]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.053]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.053]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.053]  - attr(*, "resolved")= logi FALSE
[10:31:23.053]  - attr(*, "total_size")= num 96456
[10:31:23.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.053]  - attr(*, "already-done")= logi TRUE
[10:31:23.064] - copied ‘...future.FUN’ to environment
[10:31:23.064] - reassign environment for ‘x_FUN’
[10:31:23.065] - copied ‘x_FUN’ to environment
[10:31:23.065] - copied ‘times’ to environment
[10:31:23.065] - copied ‘stopf’ to environment
[10:31:23.065] - copied ‘stop_if_not’ to environment
[10:31:23.065] - copied ‘dim’ to environment
[10:31:23.065] - copied ‘valid_types’ to environment
[10:31:23.065] - copied ‘future.call.arguments’ to environment
[10:31:23.065] - copied ‘...future.elements_ii’ to environment
[10:31:23.065] - copied ‘...future.seeds_ii’ to environment
[10:31:23.066] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.066] assign_globals() ... done
[10:31:23.066] requestCore(): workers = 2
[10:31:23.068] MulticoreFuture started
[10:31:23.068] - Launch lazy future ... done
[10:31:23.069] run() for ‘MulticoreFuture’ ... done
[10:31:23.069] Created future:
[10:31:23.070] plan(): Setting new future strategy stack:
[10:31:23.070] List of future strategies:
[10:31:23.070] 1. sequential:
[10:31:23.070]    - args: function (..., envir = parent.frame())
[10:31:23.070]    - tweaked: FALSE
[10:31:23.070]    - call: NULL
[10:31:23.071] plan(): nbrOfWorkers() = 1
[10:31:23.073] plan(): Setting new future strategy stack:
[10:31:23.073] List of future strategies:
[10:31:23.073] 1. multicore:
[10:31:23.073]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.073]    - tweaked: FALSE
[10:31:23.073]    - call: plan(strategy)
[10:31:23.069] MulticoreFuture:
[10:31:23.069] Label: ‘future_vapply-2’
[10:31:23.069] Expression:
[10:31:23.069] {
[10:31:23.069]     do.call(function(...) {
[10:31:23.069]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.069]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.069]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.069]             on.exit(options(oopts), add = TRUE)
[10:31:23.069]         }
[10:31:23.069]         {
[10:31:23.069]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.069]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.069]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.069]             })
[10:31:23.069]         }
[10:31:23.069]     }, args = future.call.arguments)
[10:31:23.069] }
[10:31:23.069] Lazy evaluation: FALSE
[10:31:23.069] Asynchronous evaluation: TRUE
[10:31:23.069] Local evaluation: TRUE
[10:31:23.069] Environment: R_GlobalEnv
[10:31:23.069] Capture standard output: TRUE
[10:31:23.069] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.069] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:23.069] Packages: 1 packages (‘future.apply’)
[10:31:23.069] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.069] Resolved: FALSE
[10:31:23.069] Value: <not collected>
[10:31:23.069] Conditions captured: <none>
[10:31:23.069] Early signaling: FALSE
[10:31:23.069] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.069] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.085] plan(): nbrOfWorkers() = 2
[10:31:23.082] Chunk #2 of 2 ... DONE
[10:31:23.086] Launching 2 futures (chunks) ... DONE
[10:31:23.086] Resolving 2 futures (chunks) ...
[10:31:23.087] resolve() on list ...
[10:31:23.087]  recursive: 0
[10:31:23.087]  length: 2
[10:31:23.087] 
[10:31:23.088] Future #1
[10:31:23.088] result() for MulticoreFuture ...
[10:31:23.089] result() for MulticoreFuture ...
[10:31:23.090] result() for MulticoreFuture ... done
[10:31:23.090] result() for MulticoreFuture ... done
[10:31:23.090] result() for MulticoreFuture ...
[10:31:23.091] result() for MulticoreFuture ... done
[10:31:23.091] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:23.091] - nx: 2
[10:31:23.092] - relay: TRUE
[10:31:23.092] - stdout: TRUE
[10:31:23.092] - signal: TRUE
[10:31:23.092] - resignal: FALSE
[10:31:23.093] - force: TRUE
[10:31:23.093] - relayed: [n=2] FALSE, FALSE
[10:31:23.093] - queued futures: [n=2] FALSE, FALSE
[10:31:23.094]  - until=1
[10:31:23.094]  - relaying element #1
[10:31:23.094] result() for MulticoreFuture ...
[10:31:23.095] result() for MulticoreFuture ... done
[10:31:23.095] result() for MulticoreFuture ...
[10:31:23.095] result() for MulticoreFuture ... done
[10:31:23.096] result() for MulticoreFuture ...
[10:31:23.096] result() for MulticoreFuture ... done
[10:31:23.096] result() for MulticoreFuture ...
[10:31:23.096] result() for MulticoreFuture ... done
[10:31:23.096] - relayed: [n=2] TRUE, FALSE
[10:31:23.097] - queued futures: [n=2] TRUE, FALSE
[10:31:23.097] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:23.097]  length: 1 (resolved future 1)
[10:31:23.097] Future #2
[10:31:23.097] result() for MulticoreFuture ...
[10:31:23.098] result() for MulticoreFuture ...
[10:31:23.098] result() for MulticoreFuture ... done
[10:31:23.099] result() for MulticoreFuture ... done
[10:31:23.099] result() for MulticoreFuture ...
[10:31:23.099] result() for MulticoreFuture ... done
[10:31:23.099] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:23.099] - nx: 2
[10:31:23.100] - relay: TRUE
[10:31:23.100] - stdout: TRUE
[10:31:23.100] - signal: TRUE
[10:31:23.100] - resignal: FALSE
[10:31:23.100] - force: TRUE
[10:31:23.100] - relayed: [n=2] TRUE, FALSE
[10:31:23.101] - queued futures: [n=2] TRUE, FALSE
[10:31:23.101]  - until=2
[10:31:23.101]  - relaying element #2
[10:31:23.101] result() for MulticoreFuture ...
[10:31:23.101] result() for MulticoreFuture ... done
[10:31:23.102] result() for MulticoreFuture ...
[10:31:23.102] result() for MulticoreFuture ... done
[10:31:23.102] result() for MulticoreFuture ...
[10:31:23.102] result() for MulticoreFuture ... done
[10:31:23.102] result() for MulticoreFuture ...
[10:31:23.102] result() for MulticoreFuture ... done
[10:31:23.102] - relayed: [n=2] TRUE, TRUE
[10:31:23.102] - queued futures: [n=2] TRUE, TRUE
[10:31:23.103] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:23.103]  length: 0 (resolved future 2)
[10:31:23.103] Relaying remaining futures
[10:31:23.103] signalConditionsASAP(NULL, pos=0) ...
[10:31:23.103] - nx: 2
[10:31:23.103] - relay: TRUE
[10:31:23.103] - stdout: TRUE
[10:31:23.103] - signal: TRUE
[10:31:23.103] - resignal: FALSE
[10:31:23.104] - force: TRUE
[10:31:23.104] - relayed: [n=2] TRUE, TRUE
[10:31:23.104] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:23.104] - relayed: [n=2] TRUE, TRUE
[10:31:23.104] - queued futures: [n=2] TRUE, TRUE
[10:31:23.104] signalConditionsASAP(NULL, pos=0) ... done
[10:31:23.104] resolve() on list ... DONE
[10:31:23.104] result() for MulticoreFuture ...
[10:31:23.104] result() for MulticoreFuture ... done
[10:31:23.105] result() for MulticoreFuture ...
[10:31:23.105] result() for MulticoreFuture ... done
[10:31:23.105] result() for MulticoreFuture ...
[10:31:23.105] result() for MulticoreFuture ... done
[10:31:23.105] result() for MulticoreFuture ...
[10:31:23.105] result() for MulticoreFuture ... done
[10:31:23.105]  - Number of value chunks collected: 2
[10:31:23.105] Resolving 2 futures (chunks) ... DONE
[10:31:23.106] Reducing values from 2 chunks ...
[10:31:23.106]  - Number of values collected after concatenation: 10
[10:31:23.106]  - Number of values expected: 10
[10:31:23.106] Reducing values from 2 chunks ... DONE
[10:31:23.106] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:31:23.107] future_lapply() ...
[10:31:23.113] Number of chunks: 2
[10:31:23.113] getGlobalsAndPackagesXApply() ...
[10:31:23.113]  - future.globals: TRUE
[10:31:23.114] getGlobalsAndPackages() ...
[10:31:23.114] Searching for globals...
[10:31:23.119] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:31:23.120] Searching for globals ... DONE
[10:31:23.120] Resolving globals: FALSE
[10:31:23.121] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[10:31:23.121] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:23.122] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:23.122] - packages: [1] ‘future.apply’
[10:31:23.122] getGlobalsAndPackages() ... DONE
[10:31:23.122]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:23.122]  - needed namespaces: [n=1] ‘future.apply’
[10:31:23.122] Finding globals ... DONE
[10:31:23.122]  - use_args: TRUE
[10:31:23.122]  - Getting '...' globals ...
[10:31:23.123] resolve() on list ...
[10:31:23.123]  recursive: 0
[10:31:23.123]  length: 1
[10:31:23.123]  elements: ‘...’
[10:31:23.123]  length: 0 (resolved future 1)
[10:31:23.123] resolve() on list ... DONE
[10:31:23.124]    - '...' content: [n=0] 
[10:31:23.124] List of 1
[10:31:23.124]  $ ...: list()
[10:31:23.124]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.124]  - attr(*, "where")=List of 1
[10:31:23.124]   ..$ ...:<environment: 0x55de856a2f88> 
[10:31:23.124]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.124]  - attr(*, "resolved")= logi TRUE
[10:31:23.124]  - attr(*, "total_size")= num NA
[10:31:23.126]  - Getting '...' globals ... DONE
[10:31:23.126] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:23.127] List of 8
[10:31:23.127]  $ ...future.FUN:function (x, ...)  
[10:31:23.127]  $ x_FUN        :function (x)  
[10:31:23.127]  $ times        : int 4
[10:31:23.127]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.127]  $ stop_if_not  :function (...)  
[10:31:23.127]  $ dim          : int [1:2] 2 2
[10:31:23.127]  $ valid_types  : chr [1:2] "logical" "integer"
[10:31:23.127]  $ ...          : list()
[10:31:23.127]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.127]  - attr(*, "where")=List of 8
[10:31:23.127]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:23.127]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:23.127]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:23.127]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:23.127]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:23.127]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:23.127]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:23.127]   ..$ ...          :<environment: 0x55de856a2f88> 
[10:31:23.127]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.127]  - attr(*, "resolved")= logi FALSE
[10:31:23.127]  - attr(*, "total_size")= num 97232
[10:31:23.132] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:23.132] getGlobalsAndPackagesXApply() ... DONE
[10:31:23.132] Number of futures (= number of chunks): 2
[10:31:23.133] Launching 2 futures (chunks) ...
[10:31:23.133] Chunk #1 of 2 ...
[10:31:23.133]  - Finding globals in 'X' for chunk #1 ...
[10:31:23.133] getGlobalsAndPackages() ...
[10:31:23.133] Searching for globals...
[10:31:23.133] 
[10:31:23.133] Searching for globals ... DONE
[10:31:23.133] - globals: [0] <none>
[10:31:23.134] getGlobalsAndPackages() ... DONE
[10:31:23.134]    + additional globals found: [n=0] 
[10:31:23.134]    + additional namespaces needed: [n=0] 
[10:31:23.134]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:23.134]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.134]  - seeds: <none>
[10:31:23.134]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.134] getGlobalsAndPackages() ...
[10:31:23.134] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.134] Resolving globals: FALSE
[10:31:23.135] Tweak future expression to call with '...' arguments ...
[10:31:23.135] {
[10:31:23.135]     do.call(function(...) {
[10:31:23.135]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.135]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.135]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.135]             on.exit(options(oopts), add = TRUE)
[10:31:23.135]         }
[10:31:23.135]         {
[10:31:23.135]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.135]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.135]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.135]             })
[10:31:23.135]         }
[10:31:23.135]     }, args = future.call.arguments)
[10:31:23.135] }
[10:31:23.135] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.135] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.136] - packages: [1] ‘future.apply’
[10:31:23.136] getGlobalsAndPackages() ... DONE
[10:31:23.136] run() for ‘Future’ ...
[10:31:23.136] - state: ‘created’
[10:31:23.136] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.140] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.140] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.140]   - Field: ‘label’
[10:31:23.142]   - Field: ‘local’
[10:31:23.142]   - Field: ‘owner’
[10:31:23.142]   - Field: ‘envir’
[10:31:23.143]   - Field: ‘workers’
[10:31:23.143]   - Field: ‘packages’
[10:31:23.143]   - Field: ‘gc’
[10:31:23.143]   - Field: ‘job’
[10:31:23.143]   - Field: ‘conditions’
[10:31:23.143]   - Field: ‘expr’
[10:31:23.143]   - Field: ‘uuid’
[10:31:23.143]   - Field: ‘seed’
[10:31:23.143]   - Field: ‘version’
[10:31:23.144]   - Field: ‘result’
[10:31:23.144]   - Field: ‘asynchronous’
[10:31:23.144]   - Field: ‘calls’
[10:31:23.144]   - Field: ‘globals’
[10:31:23.144]   - Field: ‘stdout’
[10:31:23.144]   - Field: ‘earlySignal’
[10:31:23.144]   - Field: ‘lazy’
[10:31:23.144]   - Field: ‘state’
[10:31:23.145] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.145] - Launch lazy future ...
[10:31:23.145] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:23.145] Packages needed by future strategies (n = 0): <none>
[10:31:23.146] {
[10:31:23.146]     {
[10:31:23.146]         {
[10:31:23.146]             ...future.startTime <- base::Sys.time()
[10:31:23.146]             {
[10:31:23.146]                 {
[10:31:23.146]                   {
[10:31:23.146]                     {
[10:31:23.146]                       {
[10:31:23.146]                         base::local({
[10:31:23.146]                           has_future <- base::requireNamespace("future", 
[10:31:23.146]                             quietly = TRUE)
[10:31:23.146]                           if (has_future) {
[10:31:23.146]                             ns <- base::getNamespace("future")
[10:31:23.146]                             version <- ns[[".package"]][["version"]]
[10:31:23.146]                             if (is.null(version)) 
[10:31:23.146]                               version <- utils::packageVersion("future")
[10:31:23.146]                           }
[10:31:23.146]                           else {
[10:31:23.146]                             version <- NULL
[10:31:23.146]                           }
[10:31:23.146]                           if (!has_future || version < "1.8.0") {
[10:31:23.146]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.146]                               "", base::R.version$version.string), 
[10:31:23.146]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.146]                                 base::R.version$platform, 8 * 
[10:31:23.146]                                   base::.Machine$sizeof.pointer), 
[10:31:23.146]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.146]                                 "release", "version")], collapse = " "), 
[10:31:23.146]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.146]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.146]                               info)
[10:31:23.146]                             info <- base::paste(info, collapse = "; ")
[10:31:23.146]                             if (!has_future) {
[10:31:23.146]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.146]                                 info)
[10:31:23.146]                             }
[10:31:23.146]                             else {
[10:31:23.146]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.146]                                 info, version)
[10:31:23.146]                             }
[10:31:23.146]                             base::stop(msg)
[10:31:23.146]                           }
[10:31:23.146]                         })
[10:31:23.146]                       }
[10:31:23.146]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.146]                       base::options(mc.cores = 1L)
[10:31:23.146]                     }
[10:31:23.146]                     base::local({
[10:31:23.146]                       for (pkg in "future.apply") {
[10:31:23.146]                         base::loadNamespace(pkg)
[10:31:23.146]                         base::library(pkg, character.only = TRUE)
[10:31:23.146]                       }
[10:31:23.146]                     })
[10:31:23.146]                   }
[10:31:23.146]                   ...future.strategy.old <- future::plan("list")
[10:31:23.146]                   options(future.plan = NULL)
[10:31:23.146]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.146]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.146]                 }
[10:31:23.146]                 ...future.workdir <- getwd()
[10:31:23.146]             }
[10:31:23.146]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.146]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.146]         }
[10:31:23.146]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.146]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.146]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.146]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.146]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.146]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.146]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.146]             base::names(...future.oldOptions))
[10:31:23.146]     }
[10:31:23.146]     if (FALSE) {
[10:31:23.146]     }
[10:31:23.146]     else {
[10:31:23.146]         if (TRUE) {
[10:31:23.146]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.146]                 open = "w")
[10:31:23.146]         }
[10:31:23.146]         else {
[10:31:23.146]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.146]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.146]         }
[10:31:23.146]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.146]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.146]             base::sink(type = "output", split = FALSE)
[10:31:23.146]             base::close(...future.stdout)
[10:31:23.146]         }, add = TRUE)
[10:31:23.146]     }
[10:31:23.146]     ...future.frame <- base::sys.nframe()
[10:31:23.146]     ...future.conditions <- base::list()
[10:31:23.146]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.146]     if (FALSE) {
[10:31:23.146]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.146]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.146]     }
[10:31:23.146]     ...future.result <- base::tryCatch({
[10:31:23.146]         base::withCallingHandlers({
[10:31:23.146]             ...future.value <- base::withVisible(base::local({
[10:31:23.146]                 withCallingHandlers({
[10:31:23.146]                   {
[10:31:23.146]                     do.call(function(...) {
[10:31:23.146]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.146]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.146]                         ...future.globals.maxSize)) {
[10:31:23.146]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.146]                         on.exit(options(oopts), add = TRUE)
[10:31:23.146]                       }
[10:31:23.146]                       {
[10:31:23.146]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.146]                           FUN = function(jj) {
[10:31:23.146]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.146]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.146]                           })
[10:31:23.146]                       }
[10:31:23.146]                     }, args = future.call.arguments)
[10:31:23.146]                   }
[10:31:23.146]                 }, immediateCondition = function(cond) {
[10:31:23.146]                   save_rds <- function (object, pathname, ...) 
[10:31:23.146]                   {
[10:31:23.146]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.146]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.146]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.146]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.146]                         fi_tmp[["mtime"]])
[10:31:23.146]                     }
[10:31:23.146]                     tryCatch({
[10:31:23.146]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.146]                     }, error = function(ex) {
[10:31:23.146]                       msg <- conditionMessage(ex)
[10:31:23.146]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.146]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.146]                         fi_tmp[["mtime"]], msg)
[10:31:23.146]                       ex$message <- msg
[10:31:23.146]                       stop(ex)
[10:31:23.146]                     })
[10:31:23.146]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.146]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.146]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.146]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.146]                       fi <- file.info(pathname)
[10:31:23.146]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.146]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.146]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.146]                         fi[["size"]], fi[["mtime"]])
[10:31:23.146]                       stop(msg)
[10:31:23.146]                     }
[10:31:23.146]                     invisible(pathname)
[10:31:23.146]                   }
[10:31:23.146]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.146]                     rootPath = tempdir()) 
[10:31:23.146]                   {
[10:31:23.146]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.146]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.146]                       tmpdir = path, fileext = ".rds")
[10:31:23.146]                     save_rds(obj, file)
[10:31:23.146]                   }
[10:31:23.146]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.146]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.146]                   {
[10:31:23.146]                     inherits <- base::inherits
[10:31:23.146]                     invokeRestart <- base::invokeRestart
[10:31:23.146]                     is.null <- base::is.null
[10:31:23.146]                     muffled <- FALSE
[10:31:23.146]                     if (inherits(cond, "message")) {
[10:31:23.146]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.146]                       if (muffled) 
[10:31:23.146]                         invokeRestart("muffleMessage")
[10:31:23.146]                     }
[10:31:23.146]                     else if (inherits(cond, "warning")) {
[10:31:23.146]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.146]                       if (muffled) 
[10:31:23.146]                         invokeRestart("muffleWarning")
[10:31:23.146]                     }
[10:31:23.146]                     else if (inherits(cond, "condition")) {
[10:31:23.146]                       if (!is.null(pattern)) {
[10:31:23.146]                         computeRestarts <- base::computeRestarts
[10:31:23.146]                         grepl <- base::grepl
[10:31:23.146]                         restarts <- computeRestarts(cond)
[10:31:23.146]                         for (restart in restarts) {
[10:31:23.146]                           name <- restart$name
[10:31:23.146]                           if (is.null(name)) 
[10:31:23.146]                             next
[10:31:23.146]                           if (!grepl(pattern, name)) 
[10:31:23.146]                             next
[10:31:23.146]                           invokeRestart(restart)
[10:31:23.146]                           muffled <- TRUE
[10:31:23.146]                           break
[10:31:23.146]                         }
[10:31:23.146]                       }
[10:31:23.146]                     }
[10:31:23.146]                     invisible(muffled)
[10:31:23.146]                   }
[10:31:23.146]                   muffleCondition(cond)
[10:31:23.146]                 })
[10:31:23.146]             }))
[10:31:23.146]             future::FutureResult(value = ...future.value$value, 
[10:31:23.146]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.146]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.146]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.146]                     ...future.globalenv.names))
[10:31:23.146]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.146]         }, condition = base::local({
[10:31:23.146]             c <- base::c
[10:31:23.146]             inherits <- base::inherits
[10:31:23.146]             invokeRestart <- base::invokeRestart
[10:31:23.146]             length <- base::length
[10:31:23.146]             list <- base::list
[10:31:23.146]             seq.int <- base::seq.int
[10:31:23.146]             signalCondition <- base::signalCondition
[10:31:23.146]             sys.calls <- base::sys.calls
[10:31:23.146]             `[[` <- base::`[[`
[10:31:23.146]             `+` <- base::`+`
[10:31:23.146]             `<<-` <- base::`<<-`
[10:31:23.146]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.146]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.146]                   3L)]
[10:31:23.146]             }
[10:31:23.146]             function(cond) {
[10:31:23.146]                 is_error <- inherits(cond, "error")
[10:31:23.146]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.146]                   NULL)
[10:31:23.146]                 if (is_error) {
[10:31:23.146]                   sessionInformation <- function() {
[10:31:23.146]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.146]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.146]                       search = base::search(), system = base::Sys.info())
[10:31:23.146]                   }
[10:31:23.146]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.146]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.146]                     cond$call), session = sessionInformation(), 
[10:31:23.146]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.146]                   signalCondition(cond)
[10:31:23.146]                 }
[10:31:23.146]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.146]                 "immediateCondition"))) {
[10:31:23.146]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.146]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.146]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.146]                   if (TRUE && !signal) {
[10:31:23.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.146]                     {
[10:31:23.146]                       inherits <- base::inherits
[10:31:23.146]                       invokeRestart <- base::invokeRestart
[10:31:23.146]                       is.null <- base::is.null
[10:31:23.146]                       muffled <- FALSE
[10:31:23.146]                       if (inherits(cond, "message")) {
[10:31:23.146]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.146]                         if (muffled) 
[10:31:23.146]                           invokeRestart("muffleMessage")
[10:31:23.146]                       }
[10:31:23.146]                       else if (inherits(cond, "warning")) {
[10:31:23.146]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.146]                         if (muffled) 
[10:31:23.146]                           invokeRestart("muffleWarning")
[10:31:23.146]                       }
[10:31:23.146]                       else if (inherits(cond, "condition")) {
[10:31:23.146]                         if (!is.null(pattern)) {
[10:31:23.146]                           computeRestarts <- base::computeRestarts
[10:31:23.146]                           grepl <- base::grepl
[10:31:23.146]                           restarts <- computeRestarts(cond)
[10:31:23.146]                           for (restart in restarts) {
[10:31:23.146]                             name <- restart$name
[10:31:23.146]                             if (is.null(name)) 
[10:31:23.146]                               next
[10:31:23.146]                             if (!grepl(pattern, name)) 
[10:31:23.146]                               next
[10:31:23.146]                             invokeRestart(restart)
[10:31:23.146]                             muffled <- TRUE
[10:31:23.146]                             break
[10:31:23.146]                           }
[10:31:23.146]                         }
[10:31:23.146]                       }
[10:31:23.146]                       invisible(muffled)
[10:31:23.146]                     }
[10:31:23.146]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.146]                   }
[10:31:23.146]                 }
[10:31:23.146]                 else {
[10:31:23.146]                   if (TRUE) {
[10:31:23.146]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.146]                     {
[10:31:23.146]                       inherits <- base::inherits
[10:31:23.146]                       invokeRestart <- base::invokeRestart
[10:31:23.146]                       is.null <- base::is.null
[10:31:23.146]                       muffled <- FALSE
[10:31:23.146]                       if (inherits(cond, "message")) {
[10:31:23.146]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.146]                         if (muffled) 
[10:31:23.146]                           invokeRestart("muffleMessage")
[10:31:23.146]                       }
[10:31:23.146]                       else if (inherits(cond, "warning")) {
[10:31:23.146]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.146]                         if (muffled) 
[10:31:23.146]                           invokeRestart("muffleWarning")
[10:31:23.146]                       }
[10:31:23.146]                       else if (inherits(cond, "condition")) {
[10:31:23.146]                         if (!is.null(pattern)) {
[10:31:23.146]                           computeRestarts <- base::computeRestarts
[10:31:23.146]                           grepl <- base::grepl
[10:31:23.146]                           restarts <- computeRestarts(cond)
[10:31:23.146]                           for (restart in restarts) {
[10:31:23.146]                             name <- restart$name
[10:31:23.146]                             if (is.null(name)) 
[10:31:23.146]                               next
[10:31:23.146]                             if (!grepl(pattern, name)) 
[10:31:23.146]                               next
[10:31:23.146]                             invokeRestart(restart)
[10:31:23.146]                             muffled <- TRUE
[10:31:23.146]                             break
[10:31:23.146]                           }
[10:31:23.146]                         }
[10:31:23.146]                       }
[10:31:23.146]                       invisible(muffled)
[10:31:23.146]                     }
[10:31:23.146]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.146]                   }
[10:31:23.146]                 }
[10:31:23.146]             }
[10:31:23.146]         }))
[10:31:23.146]     }, error = function(ex) {
[10:31:23.146]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.146]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.146]                 ...future.rng), started = ...future.startTime, 
[10:31:23.146]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.146]             version = "1.8"), class = "FutureResult")
[10:31:23.146]     }, finally = {
[10:31:23.146]         if (!identical(...future.workdir, getwd())) 
[10:31:23.146]             setwd(...future.workdir)
[10:31:23.146]         {
[10:31:23.146]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.146]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.146]             }
[10:31:23.146]             base::options(...future.oldOptions)
[10:31:23.146]             if (.Platform$OS.type == "windows") {
[10:31:23.146]                 old_names <- names(...future.oldEnvVars)
[10:31:23.146]                 envs <- base::Sys.getenv()
[10:31:23.146]                 names <- names(envs)
[10:31:23.146]                 common <- intersect(names, old_names)
[10:31:23.146]                 added <- setdiff(names, old_names)
[10:31:23.146]                 removed <- setdiff(old_names, names)
[10:31:23.146]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.146]                   envs[common]]
[10:31:23.146]                 NAMES <- toupper(changed)
[10:31:23.146]                 args <- list()
[10:31:23.146]                 for (kk in seq_along(NAMES)) {
[10:31:23.146]                   name <- changed[[kk]]
[10:31:23.146]                   NAME <- NAMES[[kk]]
[10:31:23.146]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.146]                     next
[10:31:23.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.146]                 }
[10:31:23.146]                 NAMES <- toupper(added)
[10:31:23.146]                 for (kk in seq_along(NAMES)) {
[10:31:23.146]                   name <- added[[kk]]
[10:31:23.146]                   NAME <- NAMES[[kk]]
[10:31:23.146]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.146]                     next
[10:31:23.146]                   args[[name]] <- ""
[10:31:23.146]                 }
[10:31:23.146]                 NAMES <- toupper(removed)
[10:31:23.146]                 for (kk in seq_along(NAMES)) {
[10:31:23.146]                   name <- removed[[kk]]
[10:31:23.146]                   NAME <- NAMES[[kk]]
[10:31:23.146]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.146]                     next
[10:31:23.146]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.146]                 }
[10:31:23.146]                 if (length(args) > 0) 
[10:31:23.146]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.146]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.146]             }
[10:31:23.146]             else {
[10:31:23.146]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.146]             }
[10:31:23.146]             {
[10:31:23.146]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.146]                   0L) {
[10:31:23.146]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.146]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.146]                   base::options(opts)
[10:31:23.146]                 }
[10:31:23.146]                 {
[10:31:23.146]                   {
[10:31:23.146]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.146]                     NULL
[10:31:23.146]                   }
[10:31:23.146]                   options(future.plan = NULL)
[10:31:23.146]                   if (is.na(NA_character_)) 
[10:31:23.146]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.146]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.146]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.146]                     .init = FALSE)
[10:31:23.146]                 }
[10:31:23.146]             }
[10:31:23.146]         }
[10:31:23.146]     })
[10:31:23.146]     if (TRUE) {
[10:31:23.146]         base::sink(type = "output", split = FALSE)
[10:31:23.146]         if (TRUE) {
[10:31:23.146]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.146]         }
[10:31:23.146]         else {
[10:31:23.146]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.146]         }
[10:31:23.146]         base::close(...future.stdout)
[10:31:23.146]         ...future.stdout <- NULL
[10:31:23.146]     }
[10:31:23.146]     ...future.result$conditions <- ...future.conditions
[10:31:23.146]     ...future.result$finished <- base::Sys.time()
[10:31:23.146]     ...future.result
[10:31:23.146] }
[10:31:23.149] assign_globals() ...
[10:31:23.149] List of 11
[10:31:23.149]  $ ...future.FUN            :function (x, ...)  
[10:31:23.149]  $ x_FUN                    :function (x)  
[10:31:23.149]  $ times                    : int 4
[10:31:23.149]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.149]  $ stop_if_not              :function (...)  
[10:31:23.149]  $ dim                      : int [1:2] 2 2
[10:31:23.149]  $ valid_types              : chr [1:2] "logical" "integer"
[10:31:23.149]  $ future.call.arguments    : list()
[10:31:23.149]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.149]  $ ...future.elements_ii    :List of 5
[10:31:23.149]   ..$ : int 1
[10:31:23.149]   ..$ : int 2
[10:31:23.149]   ..$ : int 3
[10:31:23.149]   ..$ : int 4
[10:31:23.149]   ..$ : int 5
[10:31:23.149]  $ ...future.seeds_ii       : NULL
[10:31:23.149]  $ ...future.globals.maxSize: NULL
[10:31:23.149]  - attr(*, "where")=List of 11
[10:31:23.149]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.149]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:23.149]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:23.149]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:23.149]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:23.149]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:23.149]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:23.149]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.149]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.149]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.149]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.149]  - attr(*, "resolved")= logi FALSE
[10:31:23.149]  - attr(*, "total_size")= num 97232
[10:31:23.149]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.149]  - attr(*, "already-done")= logi TRUE
[10:31:23.158] - copied ‘...future.FUN’ to environment
[10:31:23.158] - reassign environment for ‘x_FUN’
[10:31:23.158] - copied ‘x_FUN’ to environment
[10:31:23.158] - copied ‘times’ to environment
[10:31:23.158] - copied ‘stopf’ to environment
[10:31:23.158] - copied ‘stop_if_not’ to environment
[10:31:23.158] - copied ‘dim’ to environment
[10:31:23.159] - copied ‘valid_types’ to environment
[10:31:23.159] - copied ‘future.call.arguments’ to environment
[10:31:23.159] - copied ‘...future.elements_ii’ to environment
[10:31:23.159] - copied ‘...future.seeds_ii’ to environment
[10:31:23.159] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.159] assign_globals() ... done
[10:31:23.159] requestCore(): workers = 2
[10:31:23.161] MulticoreFuture started
[10:31:23.162] - Launch lazy future ... done
[10:31:23.162] run() for ‘MulticoreFuture’ ... done
[10:31:23.162] Created future:
[10:31:23.163] plan(): Setting new future strategy stack:
[10:31:23.163] List of future strategies:
[10:31:23.163] 1. sequential:
[10:31:23.163]    - args: function (..., envir = parent.frame())
[10:31:23.163]    - tweaked: FALSE
[10:31:23.163]    - call: NULL
[10:31:23.164] plan(): nbrOfWorkers() = 1
[10:31:23.166] plan(): Setting new future strategy stack:
[10:31:23.166] List of future strategies:
[10:31:23.166] 1. multicore:
[10:31:23.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.166]    - tweaked: FALSE
[10:31:23.166]    - call: plan(strategy)
[10:31:23.171] plan(): nbrOfWorkers() = 2
[10:31:23.162] MulticoreFuture:
[10:31:23.162] Label: ‘future_vapply-1’
[10:31:23.162] Expression:
[10:31:23.162] {
[10:31:23.162]     do.call(function(...) {
[10:31:23.162]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.162]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.162]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.162]             on.exit(options(oopts), add = TRUE)
[10:31:23.162]         }
[10:31:23.162]         {
[10:31:23.162]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.162]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.162]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.162]             })
[10:31:23.162]         }
[10:31:23.162]     }, args = future.call.arguments)
[10:31:23.162] }
[10:31:23.162] Lazy evaluation: FALSE
[10:31:23.162] Asynchronous evaluation: TRUE
[10:31:23.162] Local evaluation: TRUE
[10:31:23.162] Environment: R_GlobalEnv
[10:31:23.162] Capture standard output: TRUE
[10:31:23.162] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.162] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:23.162] Packages: 1 packages (‘future.apply’)
[10:31:23.162] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.162] Resolved: TRUE
[10:31:23.162] Value: <not collected>
[10:31:23.162] Conditions captured: <none>
[10:31:23.162] Early signaling: FALSE
[10:31:23.162] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.162] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.173] Chunk #1 of 2 ... DONE
[10:31:23.173] Chunk #2 of 2 ...
[10:31:23.173]  - Finding globals in 'X' for chunk #2 ...
[10:31:23.173] getGlobalsAndPackages() ...
[10:31:23.173] Searching for globals...
[10:31:23.174] 
[10:31:23.174] Searching for globals ... DONE
[10:31:23.174] - globals: [0] <none>
[10:31:23.174] getGlobalsAndPackages() ... DONE
[10:31:23.174]    + additional globals found: [n=0] 
[10:31:23.175]    + additional namespaces needed: [n=0] 
[10:31:23.175]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:23.175]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.175]  - seeds: <none>
[10:31:23.175]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.175] getGlobalsAndPackages() ...
[10:31:23.185] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.185] Resolving globals: FALSE
[10:31:23.185] Tweak future expression to call with '...' arguments ...
[10:31:23.185] {
[10:31:23.185]     do.call(function(...) {
[10:31:23.185]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.185]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.185]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.185]             on.exit(options(oopts), add = TRUE)
[10:31:23.185]         }
[10:31:23.185]         {
[10:31:23.185]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.185]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.185]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.185]             })
[10:31:23.185]         }
[10:31:23.185]     }, args = future.call.arguments)
[10:31:23.185] }
[10:31:23.185] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.186] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.186] - packages: [1] ‘future.apply’
[10:31:23.187] getGlobalsAndPackages() ... DONE
[10:31:23.187] run() for ‘Future’ ...
[10:31:23.187] - state: ‘created’
[10:31:23.188] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.193] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.193] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.194]   - Field: ‘label’
[10:31:23.194]   - Field: ‘local’
[10:31:23.194]   - Field: ‘owner’
[10:31:23.194]   - Field: ‘envir’
[10:31:23.195]   - Field: ‘workers’
[10:31:23.195]   - Field: ‘packages’
[10:31:23.195]   - Field: ‘gc’
[10:31:23.195]   - Field: ‘job’
[10:31:23.195]   - Field: ‘conditions’
[10:31:23.196]   - Field: ‘expr’
[10:31:23.196]   - Field: ‘uuid’
[10:31:23.196]   - Field: ‘seed’
[10:31:23.196]   - Field: ‘version’
[10:31:23.196]   - Field: ‘result’
[10:31:23.196]   - Field: ‘asynchronous’
[10:31:23.197]   - Field: ‘calls’
[10:31:23.197]   - Field: ‘globals’
[10:31:23.197]   - Field: ‘stdout’
[10:31:23.197]   - Field: ‘earlySignal’
[10:31:23.197]   - Field: ‘lazy’
[10:31:23.197]   - Field: ‘state’
[10:31:23.198] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.198] - Launch lazy future ...
[10:31:23.198] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:23.198] Packages needed by future strategies (n = 0): <none>
[10:31:23.199] {
[10:31:23.199]     {
[10:31:23.199]         {
[10:31:23.199]             ...future.startTime <- base::Sys.time()
[10:31:23.199]             {
[10:31:23.199]                 {
[10:31:23.199]                   {
[10:31:23.199]                     {
[10:31:23.199]                       {
[10:31:23.199]                         base::local({
[10:31:23.199]                           has_future <- base::requireNamespace("future", 
[10:31:23.199]                             quietly = TRUE)
[10:31:23.199]                           if (has_future) {
[10:31:23.199]                             ns <- base::getNamespace("future")
[10:31:23.199]                             version <- ns[[".package"]][["version"]]
[10:31:23.199]                             if (is.null(version)) 
[10:31:23.199]                               version <- utils::packageVersion("future")
[10:31:23.199]                           }
[10:31:23.199]                           else {
[10:31:23.199]                             version <- NULL
[10:31:23.199]                           }
[10:31:23.199]                           if (!has_future || version < "1.8.0") {
[10:31:23.199]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.199]                               "", base::R.version$version.string), 
[10:31:23.199]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.199]                                 base::R.version$platform, 8 * 
[10:31:23.199]                                   base::.Machine$sizeof.pointer), 
[10:31:23.199]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.199]                                 "release", "version")], collapse = " "), 
[10:31:23.199]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.199]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.199]                               info)
[10:31:23.199]                             info <- base::paste(info, collapse = "; ")
[10:31:23.199]                             if (!has_future) {
[10:31:23.199]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.199]                                 info)
[10:31:23.199]                             }
[10:31:23.199]                             else {
[10:31:23.199]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.199]                                 info, version)
[10:31:23.199]                             }
[10:31:23.199]                             base::stop(msg)
[10:31:23.199]                           }
[10:31:23.199]                         })
[10:31:23.199]                       }
[10:31:23.199]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.199]                       base::options(mc.cores = 1L)
[10:31:23.199]                     }
[10:31:23.199]                     base::local({
[10:31:23.199]                       for (pkg in "future.apply") {
[10:31:23.199]                         base::loadNamespace(pkg)
[10:31:23.199]                         base::library(pkg, character.only = TRUE)
[10:31:23.199]                       }
[10:31:23.199]                     })
[10:31:23.199]                   }
[10:31:23.199]                   ...future.strategy.old <- future::plan("list")
[10:31:23.199]                   options(future.plan = NULL)
[10:31:23.199]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.199]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.199]                 }
[10:31:23.199]                 ...future.workdir <- getwd()
[10:31:23.199]             }
[10:31:23.199]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.199]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.199]         }
[10:31:23.199]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.199]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.199]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.199]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.199]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.199]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.199]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.199]             base::names(...future.oldOptions))
[10:31:23.199]     }
[10:31:23.199]     if (FALSE) {
[10:31:23.199]     }
[10:31:23.199]     else {
[10:31:23.199]         if (TRUE) {
[10:31:23.199]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.199]                 open = "w")
[10:31:23.199]         }
[10:31:23.199]         else {
[10:31:23.199]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.199]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.199]         }
[10:31:23.199]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.199]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.199]             base::sink(type = "output", split = FALSE)
[10:31:23.199]             base::close(...future.stdout)
[10:31:23.199]         }, add = TRUE)
[10:31:23.199]     }
[10:31:23.199]     ...future.frame <- base::sys.nframe()
[10:31:23.199]     ...future.conditions <- base::list()
[10:31:23.199]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.199]     if (FALSE) {
[10:31:23.199]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.199]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.199]     }
[10:31:23.199]     ...future.result <- base::tryCatch({
[10:31:23.199]         base::withCallingHandlers({
[10:31:23.199]             ...future.value <- base::withVisible(base::local({
[10:31:23.199]                 withCallingHandlers({
[10:31:23.199]                   {
[10:31:23.199]                     do.call(function(...) {
[10:31:23.199]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.199]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.199]                         ...future.globals.maxSize)) {
[10:31:23.199]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.199]                         on.exit(options(oopts), add = TRUE)
[10:31:23.199]                       }
[10:31:23.199]                       {
[10:31:23.199]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.199]                           FUN = function(jj) {
[10:31:23.199]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.199]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.199]                           })
[10:31:23.199]                       }
[10:31:23.199]                     }, args = future.call.arguments)
[10:31:23.199]                   }
[10:31:23.199]                 }, immediateCondition = function(cond) {
[10:31:23.199]                   save_rds <- function (object, pathname, ...) 
[10:31:23.199]                   {
[10:31:23.199]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.199]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.199]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.199]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.199]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.199]                         fi_tmp[["mtime"]])
[10:31:23.199]                     }
[10:31:23.199]                     tryCatch({
[10:31:23.199]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.199]                     }, error = function(ex) {
[10:31:23.199]                       msg <- conditionMessage(ex)
[10:31:23.199]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.199]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.199]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.199]                         fi_tmp[["mtime"]], msg)
[10:31:23.199]                       ex$message <- msg
[10:31:23.199]                       stop(ex)
[10:31:23.199]                     })
[10:31:23.199]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.199]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.199]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.199]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.199]                       fi <- file.info(pathname)
[10:31:23.199]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.199]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.199]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.199]                         fi[["size"]], fi[["mtime"]])
[10:31:23.199]                       stop(msg)
[10:31:23.199]                     }
[10:31:23.199]                     invisible(pathname)
[10:31:23.199]                   }
[10:31:23.199]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.199]                     rootPath = tempdir()) 
[10:31:23.199]                   {
[10:31:23.199]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.199]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.199]                       tmpdir = path, fileext = ".rds")
[10:31:23.199]                     save_rds(obj, file)
[10:31:23.199]                   }
[10:31:23.199]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.199]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.199]                   {
[10:31:23.199]                     inherits <- base::inherits
[10:31:23.199]                     invokeRestart <- base::invokeRestart
[10:31:23.199]                     is.null <- base::is.null
[10:31:23.199]                     muffled <- FALSE
[10:31:23.199]                     if (inherits(cond, "message")) {
[10:31:23.199]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.199]                       if (muffled) 
[10:31:23.199]                         invokeRestart("muffleMessage")
[10:31:23.199]                     }
[10:31:23.199]                     else if (inherits(cond, "warning")) {
[10:31:23.199]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.199]                       if (muffled) 
[10:31:23.199]                         invokeRestart("muffleWarning")
[10:31:23.199]                     }
[10:31:23.199]                     else if (inherits(cond, "condition")) {
[10:31:23.199]                       if (!is.null(pattern)) {
[10:31:23.199]                         computeRestarts <- base::computeRestarts
[10:31:23.199]                         grepl <- base::grepl
[10:31:23.199]                         restarts <- computeRestarts(cond)
[10:31:23.199]                         for (restart in restarts) {
[10:31:23.199]                           name <- restart$name
[10:31:23.199]                           if (is.null(name)) 
[10:31:23.199]                             next
[10:31:23.199]                           if (!grepl(pattern, name)) 
[10:31:23.199]                             next
[10:31:23.199]                           invokeRestart(restart)
[10:31:23.199]                           muffled <- TRUE
[10:31:23.199]                           break
[10:31:23.199]                         }
[10:31:23.199]                       }
[10:31:23.199]                     }
[10:31:23.199]                     invisible(muffled)
[10:31:23.199]                   }
[10:31:23.199]                   muffleCondition(cond)
[10:31:23.199]                 })
[10:31:23.199]             }))
[10:31:23.199]             future::FutureResult(value = ...future.value$value, 
[10:31:23.199]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.199]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.199]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.199]                     ...future.globalenv.names))
[10:31:23.199]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.199]         }, condition = base::local({
[10:31:23.199]             c <- base::c
[10:31:23.199]             inherits <- base::inherits
[10:31:23.199]             invokeRestart <- base::invokeRestart
[10:31:23.199]             length <- base::length
[10:31:23.199]             list <- base::list
[10:31:23.199]             seq.int <- base::seq.int
[10:31:23.199]             signalCondition <- base::signalCondition
[10:31:23.199]             sys.calls <- base::sys.calls
[10:31:23.199]             `[[` <- base::`[[`
[10:31:23.199]             `+` <- base::`+`
[10:31:23.199]             `<<-` <- base::`<<-`
[10:31:23.199]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.199]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.199]                   3L)]
[10:31:23.199]             }
[10:31:23.199]             function(cond) {
[10:31:23.199]                 is_error <- inherits(cond, "error")
[10:31:23.199]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.199]                   NULL)
[10:31:23.199]                 if (is_error) {
[10:31:23.199]                   sessionInformation <- function() {
[10:31:23.199]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.199]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.199]                       search = base::search(), system = base::Sys.info())
[10:31:23.199]                   }
[10:31:23.199]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.199]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.199]                     cond$call), session = sessionInformation(), 
[10:31:23.199]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.199]                   signalCondition(cond)
[10:31:23.199]                 }
[10:31:23.199]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.199]                 "immediateCondition"))) {
[10:31:23.199]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.199]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.199]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.199]                   if (TRUE && !signal) {
[10:31:23.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.199]                     {
[10:31:23.199]                       inherits <- base::inherits
[10:31:23.199]                       invokeRestart <- base::invokeRestart
[10:31:23.199]                       is.null <- base::is.null
[10:31:23.199]                       muffled <- FALSE
[10:31:23.199]                       if (inherits(cond, "message")) {
[10:31:23.199]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.199]                         if (muffled) 
[10:31:23.199]                           invokeRestart("muffleMessage")
[10:31:23.199]                       }
[10:31:23.199]                       else if (inherits(cond, "warning")) {
[10:31:23.199]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.199]                         if (muffled) 
[10:31:23.199]                           invokeRestart("muffleWarning")
[10:31:23.199]                       }
[10:31:23.199]                       else if (inherits(cond, "condition")) {
[10:31:23.199]                         if (!is.null(pattern)) {
[10:31:23.199]                           computeRestarts <- base::computeRestarts
[10:31:23.199]                           grepl <- base::grepl
[10:31:23.199]                           restarts <- computeRestarts(cond)
[10:31:23.199]                           for (restart in restarts) {
[10:31:23.199]                             name <- restart$name
[10:31:23.199]                             if (is.null(name)) 
[10:31:23.199]                               next
[10:31:23.199]                             if (!grepl(pattern, name)) 
[10:31:23.199]                               next
[10:31:23.199]                             invokeRestart(restart)
[10:31:23.199]                             muffled <- TRUE
[10:31:23.199]                             break
[10:31:23.199]                           }
[10:31:23.199]                         }
[10:31:23.199]                       }
[10:31:23.199]                       invisible(muffled)
[10:31:23.199]                     }
[10:31:23.199]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.199]                   }
[10:31:23.199]                 }
[10:31:23.199]                 else {
[10:31:23.199]                   if (TRUE) {
[10:31:23.199]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.199]                     {
[10:31:23.199]                       inherits <- base::inherits
[10:31:23.199]                       invokeRestart <- base::invokeRestart
[10:31:23.199]                       is.null <- base::is.null
[10:31:23.199]                       muffled <- FALSE
[10:31:23.199]                       if (inherits(cond, "message")) {
[10:31:23.199]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.199]                         if (muffled) 
[10:31:23.199]                           invokeRestart("muffleMessage")
[10:31:23.199]                       }
[10:31:23.199]                       else if (inherits(cond, "warning")) {
[10:31:23.199]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.199]                         if (muffled) 
[10:31:23.199]                           invokeRestart("muffleWarning")
[10:31:23.199]                       }
[10:31:23.199]                       else if (inherits(cond, "condition")) {
[10:31:23.199]                         if (!is.null(pattern)) {
[10:31:23.199]                           computeRestarts <- base::computeRestarts
[10:31:23.199]                           grepl <- base::grepl
[10:31:23.199]                           restarts <- computeRestarts(cond)
[10:31:23.199]                           for (restart in restarts) {
[10:31:23.199]                             name <- restart$name
[10:31:23.199]                             if (is.null(name)) 
[10:31:23.199]                               next
[10:31:23.199]                             if (!grepl(pattern, name)) 
[10:31:23.199]                               next
[10:31:23.199]                             invokeRestart(restart)
[10:31:23.199]                             muffled <- TRUE
[10:31:23.199]                             break
[10:31:23.199]                           }
[10:31:23.199]                         }
[10:31:23.199]                       }
[10:31:23.199]                       invisible(muffled)
[10:31:23.199]                     }
[10:31:23.199]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.199]                   }
[10:31:23.199]                 }
[10:31:23.199]             }
[10:31:23.199]         }))
[10:31:23.199]     }, error = function(ex) {
[10:31:23.199]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.199]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.199]                 ...future.rng), started = ...future.startTime, 
[10:31:23.199]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.199]             version = "1.8"), class = "FutureResult")
[10:31:23.199]     }, finally = {
[10:31:23.199]         if (!identical(...future.workdir, getwd())) 
[10:31:23.199]             setwd(...future.workdir)
[10:31:23.199]         {
[10:31:23.199]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.199]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.199]             }
[10:31:23.199]             base::options(...future.oldOptions)
[10:31:23.199]             if (.Platform$OS.type == "windows") {
[10:31:23.199]                 old_names <- names(...future.oldEnvVars)
[10:31:23.199]                 envs <- base::Sys.getenv()
[10:31:23.199]                 names <- names(envs)
[10:31:23.199]                 common <- intersect(names, old_names)
[10:31:23.199]                 added <- setdiff(names, old_names)
[10:31:23.199]                 removed <- setdiff(old_names, names)
[10:31:23.199]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.199]                   envs[common]]
[10:31:23.199]                 NAMES <- toupper(changed)
[10:31:23.199]                 args <- list()
[10:31:23.199]                 for (kk in seq_along(NAMES)) {
[10:31:23.199]                   name <- changed[[kk]]
[10:31:23.199]                   NAME <- NAMES[[kk]]
[10:31:23.199]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.199]                     next
[10:31:23.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.199]                 }
[10:31:23.199]                 NAMES <- toupper(added)
[10:31:23.199]                 for (kk in seq_along(NAMES)) {
[10:31:23.199]                   name <- added[[kk]]
[10:31:23.199]                   NAME <- NAMES[[kk]]
[10:31:23.199]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.199]                     next
[10:31:23.199]                   args[[name]] <- ""
[10:31:23.199]                 }
[10:31:23.199]                 NAMES <- toupper(removed)
[10:31:23.199]                 for (kk in seq_along(NAMES)) {
[10:31:23.199]                   name <- removed[[kk]]
[10:31:23.199]                   NAME <- NAMES[[kk]]
[10:31:23.199]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.199]                     next
[10:31:23.199]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.199]                 }
[10:31:23.199]                 if (length(args) > 0) 
[10:31:23.199]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.199]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.199]             }
[10:31:23.199]             else {
[10:31:23.199]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.199]             }
[10:31:23.199]             {
[10:31:23.199]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.199]                   0L) {
[10:31:23.199]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.199]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.199]                   base::options(opts)
[10:31:23.199]                 }
[10:31:23.199]                 {
[10:31:23.199]                   {
[10:31:23.199]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.199]                     NULL
[10:31:23.199]                   }
[10:31:23.199]                   options(future.plan = NULL)
[10:31:23.199]                   if (is.na(NA_character_)) 
[10:31:23.199]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.199]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.199]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.199]                     .init = FALSE)
[10:31:23.199]                 }
[10:31:23.199]             }
[10:31:23.199]         }
[10:31:23.199]     })
[10:31:23.199]     if (TRUE) {
[10:31:23.199]         base::sink(type = "output", split = FALSE)
[10:31:23.199]         if (TRUE) {
[10:31:23.199]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.199]         }
[10:31:23.199]         else {
[10:31:23.199]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.199]         }
[10:31:23.199]         base::close(...future.stdout)
[10:31:23.199]         ...future.stdout <- NULL
[10:31:23.199]     }
[10:31:23.199]     ...future.result$conditions <- ...future.conditions
[10:31:23.199]     ...future.result$finished <- base::Sys.time()
[10:31:23.199]     ...future.result
[10:31:23.199] }
[10:31:23.202] assign_globals() ...
[10:31:23.202] List of 11
[10:31:23.202]  $ ...future.FUN            :function (x, ...)  
[10:31:23.202]  $ x_FUN                    :function (x)  
[10:31:23.202]  $ times                    : int 4
[10:31:23.202]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.202]  $ stop_if_not              :function (...)  
[10:31:23.202]  $ dim                      : int [1:2] 2 2
[10:31:23.202]  $ valid_types              : chr [1:2] "logical" "integer"
[10:31:23.202]  $ future.call.arguments    : list()
[10:31:23.202]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.202]  $ ...future.elements_ii    :List of 5
[10:31:23.202]   ..$ : int 6
[10:31:23.202]   ..$ : int 7
[10:31:23.202]   ..$ : int 8
[10:31:23.202]   ..$ : int 9
[10:31:23.202]   ..$ : int 10
[10:31:23.202]  $ ...future.seeds_ii       : NULL
[10:31:23.202]  $ ...future.globals.maxSize: NULL
[10:31:23.202]  - attr(*, "where")=List of 11
[10:31:23.202]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.202]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:23.202]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:23.202]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:23.202]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:23.202]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:23.202]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:23.202]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.202]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.202]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.202]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.202]  - attr(*, "resolved")= logi FALSE
[10:31:23.202]  - attr(*, "total_size")= num 97232
[10:31:23.202]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.202]  - attr(*, "already-done")= logi TRUE
[10:31:23.213] - copied ‘...future.FUN’ to environment
[10:31:23.213] - reassign environment for ‘x_FUN’
[10:31:23.213] - copied ‘x_FUN’ to environment
[10:31:23.213] - copied ‘times’ to environment
[10:31:23.214] - copied ‘stopf’ to environment
[10:31:23.214] - copied ‘stop_if_not’ to environment
[10:31:23.214] - copied ‘dim’ to environment
[10:31:23.214] - copied ‘valid_types’ to environment
[10:31:23.214] - copied ‘future.call.arguments’ to environment
[10:31:23.214] - copied ‘...future.elements_ii’ to environment
[10:31:23.214] - copied ‘...future.seeds_ii’ to environment
[10:31:23.214] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.214] assign_globals() ... done
[10:31:23.214] requestCore(): workers = 2
[10:31:23.217] MulticoreFuture started
[10:31:23.217] - Launch lazy future ... done
[10:31:23.217] run() for ‘MulticoreFuture’ ... done
[10:31:23.218] Created future:
[10:31:23.218] plan(): Setting new future strategy stack:
[10:31:23.219] List of future strategies:
[10:31:23.219] 1. sequential:
[10:31:23.219]    - args: function (..., envir = parent.frame())
[10:31:23.219]    - tweaked: FALSE
[10:31:23.219]    - call: NULL
[10:31:23.219] plan(): nbrOfWorkers() = 1
[10:31:23.226] plan(): Setting new future strategy stack:
[10:31:23.227] List of future strategies:
[10:31:23.227] 1. multicore:
[10:31:23.227]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.227]    - tweaked: FALSE
[10:31:23.227]    - call: plan(strategy)
[10:31:23.218] MulticoreFuture:
[10:31:23.218] Label: ‘future_vapply-2’
[10:31:23.218] Expression:
[10:31:23.218] {
[10:31:23.218]     do.call(function(...) {
[10:31:23.218]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.218]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.218]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.218]             on.exit(options(oopts), add = TRUE)
[10:31:23.218]         }
[10:31:23.218]         {
[10:31:23.218]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.218]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.218]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.218]             })
[10:31:23.218]         }
[10:31:23.218]     }, args = future.call.arguments)
[10:31:23.218] }
[10:31:23.218] Lazy evaluation: FALSE
[10:31:23.218] Asynchronous evaluation: TRUE
[10:31:23.218] Local evaluation: TRUE
[10:31:23.218] Environment: R_GlobalEnv
[10:31:23.218] Capture standard output: TRUE
[10:31:23.218] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.218] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:23.218] Packages: 1 packages (‘future.apply’)
[10:31:23.218] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.218] Resolved: FALSE
[10:31:23.218] Value: <not collected>
[10:31:23.218] Conditions captured: <none>
[10:31:23.218] Early signaling: FALSE
[10:31:23.218] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.218] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.234] Chunk #2 of 2 ... DONE
[10:31:23.234] plan(): nbrOfWorkers() = 2
[10:31:23.234] Launching 2 futures (chunks) ... DONE
[10:31:23.235] Resolving 2 futures (chunks) ...
[10:31:23.235] resolve() on list ...
[10:31:23.235]  recursive: 0
[10:31:23.235]  length: 2
[10:31:23.236] 
[10:31:23.236] Future #1
[10:31:23.236] result() for MulticoreFuture ...
[10:31:23.237] result() for MulticoreFuture ...
[10:31:23.238] result() for MulticoreFuture ... done
[10:31:23.238] result() for MulticoreFuture ... done
[10:31:23.238] result() for MulticoreFuture ...
[10:31:23.238] result() for MulticoreFuture ... done
[10:31:23.239] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:23.239] - nx: 2
[10:31:23.239] - relay: TRUE
[10:31:23.239] - stdout: TRUE
[10:31:23.240] - signal: TRUE
[10:31:23.240] - resignal: FALSE
[10:31:23.240] - force: TRUE
[10:31:23.240] - relayed: [n=2] FALSE, FALSE
[10:31:23.241] - queued futures: [n=2] FALSE, FALSE
[10:31:23.241]  - until=1
[10:31:23.241]  - relaying element #1
[10:31:23.241] result() for MulticoreFuture ...
[10:31:23.241] result() for MulticoreFuture ... done
[10:31:23.242] result() for MulticoreFuture ...
[10:31:23.242] result() for MulticoreFuture ... done
[10:31:23.242] result() for MulticoreFuture ...
[10:31:23.243] result() for MulticoreFuture ... done
[10:31:23.243] result() for MulticoreFuture ...
[10:31:23.243] result() for MulticoreFuture ... done
[10:31:23.243] - relayed: [n=2] TRUE, FALSE
[10:31:23.243] - queued futures: [n=2] TRUE, FALSE
[10:31:23.244] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:23.244]  length: 1 (resolved future 1)
[10:31:23.244] Future #2
[10:31:23.245] result() for MulticoreFuture ...
[10:31:23.246] result() for MulticoreFuture ...
[10:31:23.246] result() for MulticoreFuture ... done
[10:31:23.246] result() for MulticoreFuture ... done
[10:31:23.246] result() for MulticoreFuture ...
[10:31:23.246] result() for MulticoreFuture ... done
[10:31:23.247] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:23.247] - nx: 2
[10:31:23.247] - relay: TRUE
[10:31:23.247] - stdout: TRUE
[10:31:23.247] - signal: TRUE
[10:31:23.247] - resignal: FALSE
[10:31:23.247] - force: TRUE
[10:31:23.247] - relayed: [n=2] TRUE, FALSE
[10:31:23.247] - queued futures: [n=2] TRUE, FALSE
[10:31:23.248]  - until=2
[10:31:23.248]  - relaying element #2
[10:31:23.248] result() for MulticoreFuture ...
[10:31:23.248] result() for MulticoreFuture ... done
[10:31:23.248] result() for MulticoreFuture ...
[10:31:23.248] result() for MulticoreFuture ... done
[10:31:23.248] result() for MulticoreFuture ...
[10:31:23.249] result() for MulticoreFuture ... done
[10:31:23.249] result() for MulticoreFuture ...
[10:31:23.249] result() for MulticoreFuture ... done
[10:31:23.249] - relayed: [n=2] TRUE, TRUE
[10:31:23.249] - queued futures: [n=2] TRUE, TRUE
[10:31:23.249] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:23.249]  length: 0 (resolved future 2)
[10:31:23.249] Relaying remaining futures
[10:31:23.250] signalConditionsASAP(NULL, pos=0) ...
[10:31:23.250] - nx: 2
[10:31:23.250] - relay: TRUE
[10:31:23.250] - stdout: TRUE
[10:31:23.250] - signal: TRUE
[10:31:23.250] - resignal: FALSE
[10:31:23.250] - force: TRUE
[10:31:23.250] - relayed: [n=2] TRUE, TRUE
[10:31:23.250] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:23.250] - relayed: [n=2] TRUE, TRUE
[10:31:23.251] - queued futures: [n=2] TRUE, TRUE
[10:31:23.251] signalConditionsASAP(NULL, pos=0) ... done
[10:31:23.251] resolve() on list ... DONE
[10:31:23.251] result() for MulticoreFuture ...
[10:31:23.251] result() for MulticoreFuture ... done
[10:31:23.251] result() for MulticoreFuture ...
[10:31:23.251] result() for MulticoreFuture ... done
[10:31:23.251] result() for MulticoreFuture ...
[10:31:23.251] result() for MulticoreFuture ... done
[10:31:23.252] result() for MulticoreFuture ...
[10:31:23.252] result() for MulticoreFuture ... done
[10:31:23.252]  - Number of value chunks collected: 2
[10:31:23.252] Resolving 2 futures (chunks) ... DONE
[10:31:23.252] Reducing values from 2 chunks ...
[10:31:23.252]  - Number of values collected after concatenation: 10
[10:31:23.252]  - Number of values expected: 10
[10:31:23.252] Reducing values from 2 chunks ... DONE
[10:31:23.252] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:31:23.254] future_lapply() ...
[10:31:23.260] Number of chunks: 2
[10:31:23.260] getGlobalsAndPackagesXApply() ...
[10:31:23.261]  - future.globals: TRUE
[10:31:23.261] getGlobalsAndPackages() ...
[10:31:23.261] Searching for globals...
[10:31:23.264] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:31:23.265] Searching for globals ... DONE
[10:31:23.265] Resolving globals: FALSE
[10:31:23.268] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[10:31:23.268] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:23.268] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:23.269] - packages: [1] ‘future.apply’
[10:31:23.269] getGlobalsAndPackages() ... DONE
[10:31:23.269]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:23.269]  - needed namespaces: [n=1] ‘future.apply’
[10:31:23.269] Finding globals ... DONE
[10:31:23.269]  - use_args: TRUE
[10:31:23.270]  - Getting '...' globals ...
[10:31:23.270] resolve() on list ...
[10:31:23.270]  recursive: 0
[10:31:23.270]  length: 1
[10:31:23.270]  elements: ‘...’
[10:31:23.271]  length: 0 (resolved future 1)
[10:31:23.271] resolve() on list ... DONE
[10:31:23.271]    - '...' content: [n=0] 
[10:31:23.271] List of 1
[10:31:23.271]  $ ...: list()
[10:31:23.271]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.271]  - attr(*, "where")=List of 1
[10:31:23.271]   ..$ ...:<environment: 0x55de83ba5a20> 
[10:31:23.271]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.271]  - attr(*, "resolved")= logi TRUE
[10:31:23.271]  - attr(*, "total_size")= num NA
[10:31:23.274]  - Getting '...' globals ... DONE
[10:31:23.274] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:23.274] List of 8
[10:31:23.274]  $ ...future.FUN:function (x, ...)  
[10:31:23.274]  $ x_FUN        :function (x)  
[10:31:23.274]  $ times        : int 4
[10:31:23.274]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.274]  $ stop_if_not  :function (...)  
[10:31:23.274]  $ dim          : int [1:2] 2 2
[10:31:23.274]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:23.274]  $ ...          : list()
[10:31:23.274]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.274]  - attr(*, "where")=List of 8
[10:31:23.274]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:23.274]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:23.274]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:23.274]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:23.274]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:23.274]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:23.274]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:23.274]   ..$ ...          :<environment: 0x55de83ba5a20> 
[10:31:23.274]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.274]  - attr(*, "resolved")= logi FALSE
[10:31:23.274]  - attr(*, "total_size")= num 97304
[10:31:23.280] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:23.280] getGlobalsAndPackagesXApply() ... DONE
[10:31:23.280] Number of futures (= number of chunks): 2
[10:31:23.280] Launching 2 futures (chunks) ...
[10:31:23.281] Chunk #1 of 2 ...
[10:31:23.281]  - Finding globals in 'X' for chunk #1 ...
[10:31:23.281] getGlobalsAndPackages() ...
[10:31:23.281] Searching for globals...
[10:31:23.281] 
[10:31:23.281] Searching for globals ... DONE
[10:31:23.281] - globals: [0] <none>
[10:31:23.282] getGlobalsAndPackages() ... DONE
[10:31:23.282]    + additional globals found: [n=0] 
[10:31:23.282]    + additional namespaces needed: [n=0] 
[10:31:23.282]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:23.282]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.282]  - seeds: <none>
[10:31:23.282]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.282] getGlobalsAndPackages() ...
[10:31:23.282] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.282] Resolving globals: FALSE
[10:31:23.283] Tweak future expression to call with '...' arguments ...
[10:31:23.283] {
[10:31:23.283]     do.call(function(...) {
[10:31:23.283]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.283]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.283]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.283]             on.exit(options(oopts), add = TRUE)
[10:31:23.283]         }
[10:31:23.283]         {
[10:31:23.283]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.283]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.283]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.283]             })
[10:31:23.283]         }
[10:31:23.283]     }, args = future.call.arguments)
[10:31:23.283] }
[10:31:23.283] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.283] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.284] - packages: [1] ‘future.apply’
[10:31:23.284] getGlobalsAndPackages() ... DONE
[10:31:23.284] run() for ‘Future’ ...
[10:31:23.284] - state: ‘created’
[10:31:23.284] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.289]   - Field: ‘label’
[10:31:23.289]   - Field: ‘local’
[10:31:23.289]   - Field: ‘owner’
[10:31:23.289]   - Field: ‘envir’
[10:31:23.289]   - Field: ‘workers’
[10:31:23.289]   - Field: ‘packages’
[10:31:23.289]   - Field: ‘gc’
[10:31:23.289]   - Field: ‘job’
[10:31:23.289]   - Field: ‘conditions’
[10:31:23.289]   - Field: ‘expr’
[10:31:23.290]   - Field: ‘uuid’
[10:31:23.290]   - Field: ‘seed’
[10:31:23.290]   - Field: ‘version’
[10:31:23.290]   - Field: ‘result’
[10:31:23.290]   - Field: ‘asynchronous’
[10:31:23.290]   - Field: ‘calls’
[10:31:23.290]   - Field: ‘globals’
[10:31:23.290]   - Field: ‘stdout’
[10:31:23.290]   - Field: ‘earlySignal’
[10:31:23.290]   - Field: ‘lazy’
[10:31:23.290]   - Field: ‘state’
[10:31:23.291] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.291] - Launch lazy future ...
[10:31:23.293] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:23.293] Packages needed by future strategies (n = 0): <none>
[10:31:23.294] {
[10:31:23.294]     {
[10:31:23.294]         {
[10:31:23.294]             ...future.startTime <- base::Sys.time()
[10:31:23.294]             {
[10:31:23.294]                 {
[10:31:23.294]                   {
[10:31:23.294]                     {
[10:31:23.294]                       {
[10:31:23.294]                         base::local({
[10:31:23.294]                           has_future <- base::requireNamespace("future", 
[10:31:23.294]                             quietly = TRUE)
[10:31:23.294]                           if (has_future) {
[10:31:23.294]                             ns <- base::getNamespace("future")
[10:31:23.294]                             version <- ns[[".package"]][["version"]]
[10:31:23.294]                             if (is.null(version)) 
[10:31:23.294]                               version <- utils::packageVersion("future")
[10:31:23.294]                           }
[10:31:23.294]                           else {
[10:31:23.294]                             version <- NULL
[10:31:23.294]                           }
[10:31:23.294]                           if (!has_future || version < "1.8.0") {
[10:31:23.294]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.294]                               "", base::R.version$version.string), 
[10:31:23.294]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.294]                                 base::R.version$platform, 8 * 
[10:31:23.294]                                   base::.Machine$sizeof.pointer), 
[10:31:23.294]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.294]                                 "release", "version")], collapse = " "), 
[10:31:23.294]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.294]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.294]                               info)
[10:31:23.294]                             info <- base::paste(info, collapse = "; ")
[10:31:23.294]                             if (!has_future) {
[10:31:23.294]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.294]                                 info)
[10:31:23.294]                             }
[10:31:23.294]                             else {
[10:31:23.294]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.294]                                 info, version)
[10:31:23.294]                             }
[10:31:23.294]                             base::stop(msg)
[10:31:23.294]                           }
[10:31:23.294]                         })
[10:31:23.294]                       }
[10:31:23.294]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.294]                       base::options(mc.cores = 1L)
[10:31:23.294]                     }
[10:31:23.294]                     base::local({
[10:31:23.294]                       for (pkg in "future.apply") {
[10:31:23.294]                         base::loadNamespace(pkg)
[10:31:23.294]                         base::library(pkg, character.only = TRUE)
[10:31:23.294]                       }
[10:31:23.294]                     })
[10:31:23.294]                   }
[10:31:23.294]                   ...future.strategy.old <- future::plan("list")
[10:31:23.294]                   options(future.plan = NULL)
[10:31:23.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.294]                 }
[10:31:23.294]                 ...future.workdir <- getwd()
[10:31:23.294]             }
[10:31:23.294]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.294]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.294]         }
[10:31:23.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.294]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.294]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.294]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.294]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.294]             base::names(...future.oldOptions))
[10:31:23.294]     }
[10:31:23.294]     if (FALSE) {
[10:31:23.294]     }
[10:31:23.294]     else {
[10:31:23.294]         if (TRUE) {
[10:31:23.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.294]                 open = "w")
[10:31:23.294]         }
[10:31:23.294]         else {
[10:31:23.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.294]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.294]         }
[10:31:23.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.294]             base::sink(type = "output", split = FALSE)
[10:31:23.294]             base::close(...future.stdout)
[10:31:23.294]         }, add = TRUE)
[10:31:23.294]     }
[10:31:23.294]     ...future.frame <- base::sys.nframe()
[10:31:23.294]     ...future.conditions <- base::list()
[10:31:23.294]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.294]     if (FALSE) {
[10:31:23.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.294]     }
[10:31:23.294]     ...future.result <- base::tryCatch({
[10:31:23.294]         base::withCallingHandlers({
[10:31:23.294]             ...future.value <- base::withVisible(base::local({
[10:31:23.294]                 withCallingHandlers({
[10:31:23.294]                   {
[10:31:23.294]                     do.call(function(...) {
[10:31:23.294]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.294]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.294]                         ...future.globals.maxSize)) {
[10:31:23.294]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.294]                         on.exit(options(oopts), add = TRUE)
[10:31:23.294]                       }
[10:31:23.294]                       {
[10:31:23.294]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.294]                           FUN = function(jj) {
[10:31:23.294]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.294]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.294]                           })
[10:31:23.294]                       }
[10:31:23.294]                     }, args = future.call.arguments)
[10:31:23.294]                   }
[10:31:23.294]                 }, immediateCondition = function(cond) {
[10:31:23.294]                   save_rds <- function (object, pathname, ...) 
[10:31:23.294]                   {
[10:31:23.294]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.294]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.294]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.294]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.294]                         fi_tmp[["mtime"]])
[10:31:23.294]                     }
[10:31:23.294]                     tryCatch({
[10:31:23.294]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.294]                     }, error = function(ex) {
[10:31:23.294]                       msg <- conditionMessage(ex)
[10:31:23.294]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.294]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.294]                         fi_tmp[["mtime"]], msg)
[10:31:23.294]                       ex$message <- msg
[10:31:23.294]                       stop(ex)
[10:31:23.294]                     })
[10:31:23.294]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.294]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.294]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.294]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.294]                       fi <- file.info(pathname)
[10:31:23.294]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.294]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.294]                         fi[["size"]], fi[["mtime"]])
[10:31:23.294]                       stop(msg)
[10:31:23.294]                     }
[10:31:23.294]                     invisible(pathname)
[10:31:23.294]                   }
[10:31:23.294]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.294]                     rootPath = tempdir()) 
[10:31:23.294]                   {
[10:31:23.294]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.294]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.294]                       tmpdir = path, fileext = ".rds")
[10:31:23.294]                     save_rds(obj, file)
[10:31:23.294]                   }
[10:31:23.294]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.294]                   {
[10:31:23.294]                     inherits <- base::inherits
[10:31:23.294]                     invokeRestart <- base::invokeRestart
[10:31:23.294]                     is.null <- base::is.null
[10:31:23.294]                     muffled <- FALSE
[10:31:23.294]                     if (inherits(cond, "message")) {
[10:31:23.294]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.294]                       if (muffled) 
[10:31:23.294]                         invokeRestart("muffleMessage")
[10:31:23.294]                     }
[10:31:23.294]                     else if (inherits(cond, "warning")) {
[10:31:23.294]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.294]                       if (muffled) 
[10:31:23.294]                         invokeRestart("muffleWarning")
[10:31:23.294]                     }
[10:31:23.294]                     else if (inherits(cond, "condition")) {
[10:31:23.294]                       if (!is.null(pattern)) {
[10:31:23.294]                         computeRestarts <- base::computeRestarts
[10:31:23.294]                         grepl <- base::grepl
[10:31:23.294]                         restarts <- computeRestarts(cond)
[10:31:23.294]                         for (restart in restarts) {
[10:31:23.294]                           name <- restart$name
[10:31:23.294]                           if (is.null(name)) 
[10:31:23.294]                             next
[10:31:23.294]                           if (!grepl(pattern, name)) 
[10:31:23.294]                             next
[10:31:23.294]                           invokeRestart(restart)
[10:31:23.294]                           muffled <- TRUE
[10:31:23.294]                           break
[10:31:23.294]                         }
[10:31:23.294]                       }
[10:31:23.294]                     }
[10:31:23.294]                     invisible(muffled)
[10:31:23.294]                   }
[10:31:23.294]                   muffleCondition(cond)
[10:31:23.294]                 })
[10:31:23.294]             }))
[10:31:23.294]             future::FutureResult(value = ...future.value$value, 
[10:31:23.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.294]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.294]                     ...future.globalenv.names))
[10:31:23.294]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.294]         }, condition = base::local({
[10:31:23.294]             c <- base::c
[10:31:23.294]             inherits <- base::inherits
[10:31:23.294]             invokeRestart <- base::invokeRestart
[10:31:23.294]             length <- base::length
[10:31:23.294]             list <- base::list
[10:31:23.294]             seq.int <- base::seq.int
[10:31:23.294]             signalCondition <- base::signalCondition
[10:31:23.294]             sys.calls <- base::sys.calls
[10:31:23.294]             `[[` <- base::`[[`
[10:31:23.294]             `+` <- base::`+`
[10:31:23.294]             `<<-` <- base::`<<-`
[10:31:23.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.294]                   3L)]
[10:31:23.294]             }
[10:31:23.294]             function(cond) {
[10:31:23.294]                 is_error <- inherits(cond, "error")
[10:31:23.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.294]                   NULL)
[10:31:23.294]                 if (is_error) {
[10:31:23.294]                   sessionInformation <- function() {
[10:31:23.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.294]                       search = base::search(), system = base::Sys.info())
[10:31:23.294]                   }
[10:31:23.294]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.294]                     cond$call), session = sessionInformation(), 
[10:31:23.294]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.294]                   signalCondition(cond)
[10:31:23.294]                 }
[10:31:23.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.294]                 "immediateCondition"))) {
[10:31:23.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.294]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.294]                   if (TRUE && !signal) {
[10:31:23.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.294]                     {
[10:31:23.294]                       inherits <- base::inherits
[10:31:23.294]                       invokeRestart <- base::invokeRestart
[10:31:23.294]                       is.null <- base::is.null
[10:31:23.294]                       muffled <- FALSE
[10:31:23.294]                       if (inherits(cond, "message")) {
[10:31:23.294]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.294]                         if (muffled) 
[10:31:23.294]                           invokeRestart("muffleMessage")
[10:31:23.294]                       }
[10:31:23.294]                       else if (inherits(cond, "warning")) {
[10:31:23.294]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.294]                         if (muffled) 
[10:31:23.294]                           invokeRestart("muffleWarning")
[10:31:23.294]                       }
[10:31:23.294]                       else if (inherits(cond, "condition")) {
[10:31:23.294]                         if (!is.null(pattern)) {
[10:31:23.294]                           computeRestarts <- base::computeRestarts
[10:31:23.294]                           grepl <- base::grepl
[10:31:23.294]                           restarts <- computeRestarts(cond)
[10:31:23.294]                           for (restart in restarts) {
[10:31:23.294]                             name <- restart$name
[10:31:23.294]                             if (is.null(name)) 
[10:31:23.294]                               next
[10:31:23.294]                             if (!grepl(pattern, name)) 
[10:31:23.294]                               next
[10:31:23.294]                             invokeRestart(restart)
[10:31:23.294]                             muffled <- TRUE
[10:31:23.294]                             break
[10:31:23.294]                           }
[10:31:23.294]                         }
[10:31:23.294]                       }
[10:31:23.294]                       invisible(muffled)
[10:31:23.294]                     }
[10:31:23.294]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.294]                   }
[10:31:23.294]                 }
[10:31:23.294]                 else {
[10:31:23.294]                   if (TRUE) {
[10:31:23.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.294]                     {
[10:31:23.294]                       inherits <- base::inherits
[10:31:23.294]                       invokeRestart <- base::invokeRestart
[10:31:23.294]                       is.null <- base::is.null
[10:31:23.294]                       muffled <- FALSE
[10:31:23.294]                       if (inherits(cond, "message")) {
[10:31:23.294]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.294]                         if (muffled) 
[10:31:23.294]                           invokeRestart("muffleMessage")
[10:31:23.294]                       }
[10:31:23.294]                       else if (inherits(cond, "warning")) {
[10:31:23.294]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.294]                         if (muffled) 
[10:31:23.294]                           invokeRestart("muffleWarning")
[10:31:23.294]                       }
[10:31:23.294]                       else if (inherits(cond, "condition")) {
[10:31:23.294]                         if (!is.null(pattern)) {
[10:31:23.294]                           computeRestarts <- base::computeRestarts
[10:31:23.294]                           grepl <- base::grepl
[10:31:23.294]                           restarts <- computeRestarts(cond)
[10:31:23.294]                           for (restart in restarts) {
[10:31:23.294]                             name <- restart$name
[10:31:23.294]                             if (is.null(name)) 
[10:31:23.294]                               next
[10:31:23.294]                             if (!grepl(pattern, name)) 
[10:31:23.294]                               next
[10:31:23.294]                             invokeRestart(restart)
[10:31:23.294]                             muffled <- TRUE
[10:31:23.294]                             break
[10:31:23.294]                           }
[10:31:23.294]                         }
[10:31:23.294]                       }
[10:31:23.294]                       invisible(muffled)
[10:31:23.294]                     }
[10:31:23.294]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.294]                   }
[10:31:23.294]                 }
[10:31:23.294]             }
[10:31:23.294]         }))
[10:31:23.294]     }, error = function(ex) {
[10:31:23.294]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.294]                 ...future.rng), started = ...future.startTime, 
[10:31:23.294]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.294]             version = "1.8"), class = "FutureResult")
[10:31:23.294]     }, finally = {
[10:31:23.294]         if (!identical(...future.workdir, getwd())) 
[10:31:23.294]             setwd(...future.workdir)
[10:31:23.294]         {
[10:31:23.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.294]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.294]             }
[10:31:23.294]             base::options(...future.oldOptions)
[10:31:23.294]             if (.Platform$OS.type == "windows") {
[10:31:23.294]                 old_names <- names(...future.oldEnvVars)
[10:31:23.294]                 envs <- base::Sys.getenv()
[10:31:23.294]                 names <- names(envs)
[10:31:23.294]                 common <- intersect(names, old_names)
[10:31:23.294]                 added <- setdiff(names, old_names)
[10:31:23.294]                 removed <- setdiff(old_names, names)
[10:31:23.294]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.294]                   envs[common]]
[10:31:23.294]                 NAMES <- toupper(changed)
[10:31:23.294]                 args <- list()
[10:31:23.294]                 for (kk in seq_along(NAMES)) {
[10:31:23.294]                   name <- changed[[kk]]
[10:31:23.294]                   NAME <- NAMES[[kk]]
[10:31:23.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.294]                     next
[10:31:23.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.294]                 }
[10:31:23.294]                 NAMES <- toupper(added)
[10:31:23.294]                 for (kk in seq_along(NAMES)) {
[10:31:23.294]                   name <- added[[kk]]
[10:31:23.294]                   NAME <- NAMES[[kk]]
[10:31:23.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.294]                     next
[10:31:23.294]                   args[[name]] <- ""
[10:31:23.294]                 }
[10:31:23.294]                 NAMES <- toupper(removed)
[10:31:23.294]                 for (kk in seq_along(NAMES)) {
[10:31:23.294]                   name <- removed[[kk]]
[10:31:23.294]                   NAME <- NAMES[[kk]]
[10:31:23.294]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.294]                     next
[10:31:23.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.294]                 }
[10:31:23.294]                 if (length(args) > 0) 
[10:31:23.294]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.294]             }
[10:31:23.294]             else {
[10:31:23.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.294]             }
[10:31:23.294]             {
[10:31:23.294]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.294]                   0L) {
[10:31:23.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.294]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.294]                   base::options(opts)
[10:31:23.294]                 }
[10:31:23.294]                 {
[10:31:23.294]                   {
[10:31:23.294]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.294]                     NULL
[10:31:23.294]                   }
[10:31:23.294]                   options(future.plan = NULL)
[10:31:23.294]                   if (is.na(NA_character_)) 
[10:31:23.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.294]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.294]                     .init = FALSE)
[10:31:23.294]                 }
[10:31:23.294]             }
[10:31:23.294]         }
[10:31:23.294]     })
[10:31:23.294]     if (TRUE) {
[10:31:23.294]         base::sink(type = "output", split = FALSE)
[10:31:23.294]         if (TRUE) {
[10:31:23.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.294]         }
[10:31:23.294]         else {
[10:31:23.294]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.294]         }
[10:31:23.294]         base::close(...future.stdout)
[10:31:23.294]         ...future.stdout <- NULL
[10:31:23.294]     }
[10:31:23.294]     ...future.result$conditions <- ...future.conditions
[10:31:23.294]     ...future.result$finished <- base::Sys.time()
[10:31:23.294]     ...future.result
[10:31:23.294] }
[10:31:23.296] assign_globals() ...
[10:31:23.296] List of 11
[10:31:23.296]  $ ...future.FUN            :function (x, ...)  
[10:31:23.296]  $ x_FUN                    :function (x)  
[10:31:23.296]  $ times                    : int 4
[10:31:23.296]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.296]  $ stop_if_not              :function (...)  
[10:31:23.296]  $ dim                      : int [1:2] 2 2
[10:31:23.296]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:23.296]  $ future.call.arguments    : list()
[10:31:23.296]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.296]  $ ...future.elements_ii    :List of 5
[10:31:23.296]   ..$ : int 1
[10:31:23.296]   ..$ : int 2
[10:31:23.296]   ..$ : int 3
[10:31:23.296]   ..$ : int 4
[10:31:23.296]   ..$ : int 5
[10:31:23.296]  $ ...future.seeds_ii       : NULL
[10:31:23.296]  $ ...future.globals.maxSize: NULL
[10:31:23.296]  - attr(*, "where")=List of 11
[10:31:23.296]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.296]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:23.296]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:23.296]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:23.296]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:23.296]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:23.296]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:23.296]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.296]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.296]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.296]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.296]  - attr(*, "resolved")= logi FALSE
[10:31:23.296]  - attr(*, "total_size")= num 97304
[10:31:23.296]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.296]  - attr(*, "already-done")= logi TRUE
[10:31:23.306] - copied ‘...future.FUN’ to environment
[10:31:23.307] - reassign environment for ‘x_FUN’
[10:31:23.307] - copied ‘x_FUN’ to environment
[10:31:23.307] - copied ‘times’ to environment
[10:31:23.307] - copied ‘stopf’ to environment
[10:31:23.307] - copied ‘stop_if_not’ to environment
[10:31:23.307] - copied ‘dim’ to environment
[10:31:23.307] - copied ‘valid_types’ to environment
[10:31:23.307] - copied ‘future.call.arguments’ to environment
[10:31:23.307] - copied ‘...future.elements_ii’ to environment
[10:31:23.307] - copied ‘...future.seeds_ii’ to environment
[10:31:23.308] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.308] assign_globals() ... done
[10:31:23.308] requestCore(): workers = 2
[10:31:23.310] MulticoreFuture started
[10:31:23.310] - Launch lazy future ... done
[10:31:23.311] run() for ‘MulticoreFuture’ ... done
[10:31:23.311] Created future:
[10:31:23.312] plan(): Setting new future strategy stack:
[10:31:23.312] List of future strategies:
[10:31:23.312] 1. sequential:
[10:31:23.312]    - args: function (..., envir = parent.frame())
[10:31:23.312]    - tweaked: FALSE
[10:31:23.312]    - call: NULL
[10:31:23.313] plan(): nbrOfWorkers() = 1
[10:31:23.315] plan(): Setting new future strategy stack:
[10:31:23.315] List of future strategies:
[10:31:23.315] 1. multicore:
[10:31:23.315]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.315]    - tweaked: FALSE
[10:31:23.315]    - call: plan(strategy)
[10:31:23.320] plan(): nbrOfWorkers() = 2
[10:31:23.311] MulticoreFuture:
[10:31:23.311] Label: ‘future_vapply-1’
[10:31:23.311] Expression:
[10:31:23.311] {
[10:31:23.311]     do.call(function(...) {
[10:31:23.311]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.311]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.311]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.311]             on.exit(options(oopts), add = TRUE)
[10:31:23.311]         }
[10:31:23.311]         {
[10:31:23.311]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.311]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.311]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.311]             })
[10:31:23.311]         }
[10:31:23.311]     }, args = future.call.arguments)
[10:31:23.311] }
[10:31:23.311] Lazy evaluation: FALSE
[10:31:23.311] Asynchronous evaluation: TRUE
[10:31:23.311] Local evaluation: TRUE
[10:31:23.311] Environment: R_GlobalEnv
[10:31:23.311] Capture standard output: TRUE
[10:31:23.311] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.311] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:23.311] Packages: 1 packages (‘future.apply’)
[10:31:23.311] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.311] Resolved: TRUE
[10:31:23.311] Value: <not collected>
[10:31:23.311] Conditions captured: <none>
[10:31:23.311] Early signaling: FALSE
[10:31:23.311] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.311] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.322] Chunk #1 of 2 ... DONE
[10:31:23.322] Chunk #2 of 2 ...
[10:31:23.322]  - Finding globals in 'X' for chunk #2 ...
[10:31:23.322] getGlobalsAndPackages() ...
[10:31:23.322] Searching for globals...
[10:31:23.323] 
[10:31:23.323] Searching for globals ... DONE
[10:31:23.323] - globals: [0] <none>
[10:31:23.323] getGlobalsAndPackages() ... DONE
[10:31:23.323]    + additional globals found: [n=0] 
[10:31:23.323]    + additional namespaces needed: [n=0] 
[10:31:23.324]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:23.324]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.324]  - seeds: <none>
[10:31:23.324]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.324] getGlobalsAndPackages() ...
[10:31:23.324] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.325] Resolving globals: FALSE
[10:31:23.325] Tweak future expression to call with '...' arguments ...
[10:31:23.325] {
[10:31:23.325]     do.call(function(...) {
[10:31:23.325]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.325]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.325]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.325]             on.exit(options(oopts), add = TRUE)
[10:31:23.325]         }
[10:31:23.325]         {
[10:31:23.325]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.325]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.325]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.325]             })
[10:31:23.325]         }
[10:31:23.325]     }, args = future.call.arguments)
[10:31:23.325] }
[10:31:23.325] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.326] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.327] - packages: [1] ‘future.apply’
[10:31:23.327] getGlobalsAndPackages() ... DONE
[10:31:23.327] run() for ‘Future’ ...
[10:31:23.327] - state: ‘created’
[10:31:23.328] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.332] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.333]   - Field: ‘label’
[10:31:23.333]   - Field: ‘local’
[10:31:23.333]   - Field: ‘owner’
[10:31:23.337]   - Field: ‘envir’
[10:31:23.337]   - Field: ‘workers’
[10:31:23.337]   - Field: ‘packages’
[10:31:23.338]   - Field: ‘gc’
[10:31:23.338]   - Field: ‘job’
[10:31:23.338]   - Field: ‘conditions’
[10:31:23.339]   - Field: ‘expr’
[10:31:23.339]   - Field: ‘uuid’
[10:31:23.339]   - Field: ‘seed’
[10:31:23.339]   - Field: ‘version’
[10:31:23.340]   - Field: ‘result’
[10:31:23.340]   - Field: ‘asynchronous’
[10:31:23.340]   - Field: ‘calls’
[10:31:23.340]   - Field: ‘globals’
[10:31:23.341]   - Field: ‘stdout’
[10:31:23.341]   - Field: ‘earlySignal’
[10:31:23.341]   - Field: ‘lazy’
[10:31:23.341]   - Field: ‘state’
[10:31:23.342] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.342] - Launch lazy future ...
[10:31:23.342] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:23.343] Packages needed by future strategies (n = 0): <none>
[10:31:23.344] {
[10:31:23.344]     {
[10:31:23.344]         {
[10:31:23.344]             ...future.startTime <- base::Sys.time()
[10:31:23.344]             {
[10:31:23.344]                 {
[10:31:23.344]                   {
[10:31:23.344]                     {
[10:31:23.344]                       {
[10:31:23.344]                         base::local({
[10:31:23.344]                           has_future <- base::requireNamespace("future", 
[10:31:23.344]                             quietly = TRUE)
[10:31:23.344]                           if (has_future) {
[10:31:23.344]                             ns <- base::getNamespace("future")
[10:31:23.344]                             version <- ns[[".package"]][["version"]]
[10:31:23.344]                             if (is.null(version)) 
[10:31:23.344]                               version <- utils::packageVersion("future")
[10:31:23.344]                           }
[10:31:23.344]                           else {
[10:31:23.344]                             version <- NULL
[10:31:23.344]                           }
[10:31:23.344]                           if (!has_future || version < "1.8.0") {
[10:31:23.344]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.344]                               "", base::R.version$version.string), 
[10:31:23.344]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.344]                                 base::R.version$platform, 8 * 
[10:31:23.344]                                   base::.Machine$sizeof.pointer), 
[10:31:23.344]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.344]                                 "release", "version")], collapse = " "), 
[10:31:23.344]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.344]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.344]                               info)
[10:31:23.344]                             info <- base::paste(info, collapse = "; ")
[10:31:23.344]                             if (!has_future) {
[10:31:23.344]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.344]                                 info)
[10:31:23.344]                             }
[10:31:23.344]                             else {
[10:31:23.344]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.344]                                 info, version)
[10:31:23.344]                             }
[10:31:23.344]                             base::stop(msg)
[10:31:23.344]                           }
[10:31:23.344]                         })
[10:31:23.344]                       }
[10:31:23.344]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.344]                       base::options(mc.cores = 1L)
[10:31:23.344]                     }
[10:31:23.344]                     base::local({
[10:31:23.344]                       for (pkg in "future.apply") {
[10:31:23.344]                         base::loadNamespace(pkg)
[10:31:23.344]                         base::library(pkg, character.only = TRUE)
[10:31:23.344]                       }
[10:31:23.344]                     })
[10:31:23.344]                   }
[10:31:23.344]                   ...future.strategy.old <- future::plan("list")
[10:31:23.344]                   options(future.plan = NULL)
[10:31:23.344]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.344]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.344]                 }
[10:31:23.344]                 ...future.workdir <- getwd()
[10:31:23.344]             }
[10:31:23.344]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.344]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.344]         }
[10:31:23.344]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.344]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.344]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.344]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.344]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.344]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.344]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.344]             base::names(...future.oldOptions))
[10:31:23.344]     }
[10:31:23.344]     if (FALSE) {
[10:31:23.344]     }
[10:31:23.344]     else {
[10:31:23.344]         if (TRUE) {
[10:31:23.344]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.344]                 open = "w")
[10:31:23.344]         }
[10:31:23.344]         else {
[10:31:23.344]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.344]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.344]         }
[10:31:23.344]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.344]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.344]             base::sink(type = "output", split = FALSE)
[10:31:23.344]             base::close(...future.stdout)
[10:31:23.344]         }, add = TRUE)
[10:31:23.344]     }
[10:31:23.344]     ...future.frame <- base::sys.nframe()
[10:31:23.344]     ...future.conditions <- base::list()
[10:31:23.344]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.344]     if (FALSE) {
[10:31:23.344]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.344]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.344]     }
[10:31:23.344]     ...future.result <- base::tryCatch({
[10:31:23.344]         base::withCallingHandlers({
[10:31:23.344]             ...future.value <- base::withVisible(base::local({
[10:31:23.344]                 withCallingHandlers({
[10:31:23.344]                   {
[10:31:23.344]                     do.call(function(...) {
[10:31:23.344]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.344]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.344]                         ...future.globals.maxSize)) {
[10:31:23.344]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.344]                         on.exit(options(oopts), add = TRUE)
[10:31:23.344]                       }
[10:31:23.344]                       {
[10:31:23.344]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.344]                           FUN = function(jj) {
[10:31:23.344]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.344]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.344]                           })
[10:31:23.344]                       }
[10:31:23.344]                     }, args = future.call.arguments)
[10:31:23.344]                   }
[10:31:23.344]                 }, immediateCondition = function(cond) {
[10:31:23.344]                   save_rds <- function (object, pathname, ...) 
[10:31:23.344]                   {
[10:31:23.344]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.344]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.344]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.344]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.344]                         fi_tmp[["mtime"]])
[10:31:23.344]                     }
[10:31:23.344]                     tryCatch({
[10:31:23.344]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.344]                     }, error = function(ex) {
[10:31:23.344]                       msg <- conditionMessage(ex)
[10:31:23.344]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.344]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.344]                         fi_tmp[["mtime"]], msg)
[10:31:23.344]                       ex$message <- msg
[10:31:23.344]                       stop(ex)
[10:31:23.344]                     })
[10:31:23.344]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.344]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.344]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.344]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.344]                       fi <- file.info(pathname)
[10:31:23.344]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.344]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.344]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.344]                         fi[["size"]], fi[["mtime"]])
[10:31:23.344]                       stop(msg)
[10:31:23.344]                     }
[10:31:23.344]                     invisible(pathname)
[10:31:23.344]                   }
[10:31:23.344]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.344]                     rootPath = tempdir()) 
[10:31:23.344]                   {
[10:31:23.344]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.344]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.344]                       tmpdir = path, fileext = ".rds")
[10:31:23.344]                     save_rds(obj, file)
[10:31:23.344]                   }
[10:31:23.344]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.344]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.344]                   {
[10:31:23.344]                     inherits <- base::inherits
[10:31:23.344]                     invokeRestart <- base::invokeRestart
[10:31:23.344]                     is.null <- base::is.null
[10:31:23.344]                     muffled <- FALSE
[10:31:23.344]                     if (inherits(cond, "message")) {
[10:31:23.344]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.344]                       if (muffled) 
[10:31:23.344]                         invokeRestart("muffleMessage")
[10:31:23.344]                     }
[10:31:23.344]                     else if (inherits(cond, "warning")) {
[10:31:23.344]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.344]                       if (muffled) 
[10:31:23.344]                         invokeRestart("muffleWarning")
[10:31:23.344]                     }
[10:31:23.344]                     else if (inherits(cond, "condition")) {
[10:31:23.344]                       if (!is.null(pattern)) {
[10:31:23.344]                         computeRestarts <- base::computeRestarts
[10:31:23.344]                         grepl <- base::grepl
[10:31:23.344]                         restarts <- computeRestarts(cond)
[10:31:23.344]                         for (restart in restarts) {
[10:31:23.344]                           name <- restart$name
[10:31:23.344]                           if (is.null(name)) 
[10:31:23.344]                             next
[10:31:23.344]                           if (!grepl(pattern, name)) 
[10:31:23.344]                             next
[10:31:23.344]                           invokeRestart(restart)
[10:31:23.344]                           muffled <- TRUE
[10:31:23.344]                           break
[10:31:23.344]                         }
[10:31:23.344]                       }
[10:31:23.344]                     }
[10:31:23.344]                     invisible(muffled)
[10:31:23.344]                   }
[10:31:23.344]                   muffleCondition(cond)
[10:31:23.344]                 })
[10:31:23.344]             }))
[10:31:23.344]             future::FutureResult(value = ...future.value$value, 
[10:31:23.344]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.344]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.344]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.344]                     ...future.globalenv.names))
[10:31:23.344]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.344]         }, condition = base::local({
[10:31:23.344]             c <- base::c
[10:31:23.344]             inherits <- base::inherits
[10:31:23.344]             invokeRestart <- base::invokeRestart
[10:31:23.344]             length <- base::length
[10:31:23.344]             list <- base::list
[10:31:23.344]             seq.int <- base::seq.int
[10:31:23.344]             signalCondition <- base::signalCondition
[10:31:23.344]             sys.calls <- base::sys.calls
[10:31:23.344]             `[[` <- base::`[[`
[10:31:23.344]             `+` <- base::`+`
[10:31:23.344]             `<<-` <- base::`<<-`
[10:31:23.344]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.344]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.344]                   3L)]
[10:31:23.344]             }
[10:31:23.344]             function(cond) {
[10:31:23.344]                 is_error <- inherits(cond, "error")
[10:31:23.344]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.344]                   NULL)
[10:31:23.344]                 if (is_error) {
[10:31:23.344]                   sessionInformation <- function() {
[10:31:23.344]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.344]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.344]                       search = base::search(), system = base::Sys.info())
[10:31:23.344]                   }
[10:31:23.344]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.344]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.344]                     cond$call), session = sessionInformation(), 
[10:31:23.344]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.344]                   signalCondition(cond)
[10:31:23.344]                 }
[10:31:23.344]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.344]                 "immediateCondition"))) {
[10:31:23.344]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.344]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.344]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.344]                   if (TRUE && !signal) {
[10:31:23.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.344]                     {
[10:31:23.344]                       inherits <- base::inherits
[10:31:23.344]                       invokeRestart <- base::invokeRestart
[10:31:23.344]                       is.null <- base::is.null
[10:31:23.344]                       muffled <- FALSE
[10:31:23.344]                       if (inherits(cond, "message")) {
[10:31:23.344]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.344]                         if (muffled) 
[10:31:23.344]                           invokeRestart("muffleMessage")
[10:31:23.344]                       }
[10:31:23.344]                       else if (inherits(cond, "warning")) {
[10:31:23.344]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.344]                         if (muffled) 
[10:31:23.344]                           invokeRestart("muffleWarning")
[10:31:23.344]                       }
[10:31:23.344]                       else if (inherits(cond, "condition")) {
[10:31:23.344]                         if (!is.null(pattern)) {
[10:31:23.344]                           computeRestarts <- base::computeRestarts
[10:31:23.344]                           grepl <- base::grepl
[10:31:23.344]                           restarts <- computeRestarts(cond)
[10:31:23.344]                           for (restart in restarts) {
[10:31:23.344]                             name <- restart$name
[10:31:23.344]                             if (is.null(name)) 
[10:31:23.344]                               next
[10:31:23.344]                             if (!grepl(pattern, name)) 
[10:31:23.344]                               next
[10:31:23.344]                             invokeRestart(restart)
[10:31:23.344]                             muffled <- TRUE
[10:31:23.344]                             break
[10:31:23.344]                           }
[10:31:23.344]                         }
[10:31:23.344]                       }
[10:31:23.344]                       invisible(muffled)
[10:31:23.344]                     }
[10:31:23.344]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.344]                   }
[10:31:23.344]                 }
[10:31:23.344]                 else {
[10:31:23.344]                   if (TRUE) {
[10:31:23.344]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.344]                     {
[10:31:23.344]                       inherits <- base::inherits
[10:31:23.344]                       invokeRestart <- base::invokeRestart
[10:31:23.344]                       is.null <- base::is.null
[10:31:23.344]                       muffled <- FALSE
[10:31:23.344]                       if (inherits(cond, "message")) {
[10:31:23.344]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.344]                         if (muffled) 
[10:31:23.344]                           invokeRestart("muffleMessage")
[10:31:23.344]                       }
[10:31:23.344]                       else if (inherits(cond, "warning")) {
[10:31:23.344]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.344]                         if (muffled) 
[10:31:23.344]                           invokeRestart("muffleWarning")
[10:31:23.344]                       }
[10:31:23.344]                       else if (inherits(cond, "condition")) {
[10:31:23.344]                         if (!is.null(pattern)) {
[10:31:23.344]                           computeRestarts <- base::computeRestarts
[10:31:23.344]                           grepl <- base::grepl
[10:31:23.344]                           restarts <- computeRestarts(cond)
[10:31:23.344]                           for (restart in restarts) {
[10:31:23.344]                             name <- restart$name
[10:31:23.344]                             if (is.null(name)) 
[10:31:23.344]                               next
[10:31:23.344]                             if (!grepl(pattern, name)) 
[10:31:23.344]                               next
[10:31:23.344]                             invokeRestart(restart)
[10:31:23.344]                             muffled <- TRUE
[10:31:23.344]                             break
[10:31:23.344]                           }
[10:31:23.344]                         }
[10:31:23.344]                       }
[10:31:23.344]                       invisible(muffled)
[10:31:23.344]                     }
[10:31:23.344]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.344]                   }
[10:31:23.344]                 }
[10:31:23.344]             }
[10:31:23.344]         }))
[10:31:23.344]     }, error = function(ex) {
[10:31:23.344]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.344]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.344]                 ...future.rng), started = ...future.startTime, 
[10:31:23.344]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.344]             version = "1.8"), class = "FutureResult")
[10:31:23.344]     }, finally = {
[10:31:23.344]         if (!identical(...future.workdir, getwd())) 
[10:31:23.344]             setwd(...future.workdir)
[10:31:23.344]         {
[10:31:23.344]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.344]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.344]             }
[10:31:23.344]             base::options(...future.oldOptions)
[10:31:23.344]             if (.Platform$OS.type == "windows") {
[10:31:23.344]                 old_names <- names(...future.oldEnvVars)
[10:31:23.344]                 envs <- base::Sys.getenv()
[10:31:23.344]                 names <- names(envs)
[10:31:23.344]                 common <- intersect(names, old_names)
[10:31:23.344]                 added <- setdiff(names, old_names)
[10:31:23.344]                 removed <- setdiff(old_names, names)
[10:31:23.344]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.344]                   envs[common]]
[10:31:23.344]                 NAMES <- toupper(changed)
[10:31:23.344]                 args <- list()
[10:31:23.344]                 for (kk in seq_along(NAMES)) {
[10:31:23.344]                   name <- changed[[kk]]
[10:31:23.344]                   NAME <- NAMES[[kk]]
[10:31:23.344]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.344]                     next
[10:31:23.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.344]                 }
[10:31:23.344]                 NAMES <- toupper(added)
[10:31:23.344]                 for (kk in seq_along(NAMES)) {
[10:31:23.344]                   name <- added[[kk]]
[10:31:23.344]                   NAME <- NAMES[[kk]]
[10:31:23.344]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.344]                     next
[10:31:23.344]                   args[[name]] <- ""
[10:31:23.344]                 }
[10:31:23.344]                 NAMES <- toupper(removed)
[10:31:23.344]                 for (kk in seq_along(NAMES)) {
[10:31:23.344]                   name <- removed[[kk]]
[10:31:23.344]                   NAME <- NAMES[[kk]]
[10:31:23.344]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.344]                     next
[10:31:23.344]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.344]                 }
[10:31:23.344]                 if (length(args) > 0) 
[10:31:23.344]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.344]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.344]             }
[10:31:23.344]             else {
[10:31:23.344]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.344]             }
[10:31:23.344]             {
[10:31:23.344]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.344]                   0L) {
[10:31:23.344]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.344]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.344]                   base::options(opts)
[10:31:23.344]                 }
[10:31:23.344]                 {
[10:31:23.344]                   {
[10:31:23.344]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.344]                     NULL
[10:31:23.344]                   }
[10:31:23.344]                   options(future.plan = NULL)
[10:31:23.344]                   if (is.na(NA_character_)) 
[10:31:23.344]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.344]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.344]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.344]                     .init = FALSE)
[10:31:23.344]                 }
[10:31:23.344]             }
[10:31:23.344]         }
[10:31:23.344]     })
[10:31:23.344]     if (TRUE) {
[10:31:23.344]         base::sink(type = "output", split = FALSE)
[10:31:23.344]         if (TRUE) {
[10:31:23.344]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.344]         }
[10:31:23.344]         else {
[10:31:23.344]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.344]         }
[10:31:23.344]         base::close(...future.stdout)
[10:31:23.344]         ...future.stdout <- NULL
[10:31:23.344]     }
[10:31:23.344]     ...future.result$conditions <- ...future.conditions
[10:31:23.344]     ...future.result$finished <- base::Sys.time()
[10:31:23.344]     ...future.result
[10:31:23.344] }
[10:31:23.347] assign_globals() ...
[10:31:23.347] List of 11
[10:31:23.347]  $ ...future.FUN            :function (x, ...)  
[10:31:23.347]  $ x_FUN                    :function (x)  
[10:31:23.347]  $ times                    : int 4
[10:31:23.347]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.347]  $ stop_if_not              :function (...)  
[10:31:23.347]  $ dim                      : int [1:2] 2 2
[10:31:23.347]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:23.347]  $ future.call.arguments    : list()
[10:31:23.347]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.347]  $ ...future.elements_ii    :List of 5
[10:31:23.347]   ..$ : int 6
[10:31:23.347]   ..$ : int 7
[10:31:23.347]   ..$ : int 8
[10:31:23.347]   ..$ : int 9
[10:31:23.347]   ..$ : int 10
[10:31:23.347]  $ ...future.seeds_ii       : NULL
[10:31:23.347]  $ ...future.globals.maxSize: NULL
[10:31:23.347]  - attr(*, "where")=List of 11
[10:31:23.347]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.347]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:23.347]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:23.347]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:23.347]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:23.347]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:23.347]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:23.347]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.347]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.347]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.347]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.347]  - attr(*, "resolved")= logi FALSE
[10:31:23.347]  - attr(*, "total_size")= num 97304
[10:31:23.347]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.347]  - attr(*, "already-done")= logi TRUE
[10:31:23.361] - copied ‘...future.FUN’ to environment
[10:31:23.361] - reassign environment for ‘x_FUN’
[10:31:23.361] - copied ‘x_FUN’ to environment
[10:31:23.361] - copied ‘times’ to environment
[10:31:23.361] - copied ‘stopf’ to environment
[10:31:23.361] - copied ‘stop_if_not’ to environment
[10:31:23.361] - copied ‘dim’ to environment
[10:31:23.361] - copied ‘valid_types’ to environment
[10:31:23.361] - copied ‘future.call.arguments’ to environment
[10:31:23.362] - copied ‘...future.elements_ii’ to environment
[10:31:23.362] - copied ‘...future.seeds_ii’ to environment
[10:31:23.362] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.362] assign_globals() ... done
[10:31:23.362] requestCore(): workers = 2
[10:31:23.364] MulticoreFuture started
[10:31:23.365] - Launch lazy future ... done
[10:31:23.365] run() for ‘MulticoreFuture’ ... done
[10:31:23.365] Created future:
[10:31:23.366] plan(): Setting new future strategy stack:
[10:31:23.366] List of future strategies:
[10:31:23.366] 1. sequential:
[10:31:23.366]    - args: function (..., envir = parent.frame())
[10:31:23.366]    - tweaked: FALSE
[10:31:23.366]    - call: NULL
[10:31:23.367] plan(): nbrOfWorkers() = 1
[10:31:23.369] plan(): Setting new future strategy stack:
[10:31:23.370] List of future strategies:
[10:31:23.370] 1. multicore:
[10:31:23.370]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.370]    - tweaked: FALSE
[10:31:23.370]    - call: plan(strategy)
[10:31:23.375] plan(): nbrOfWorkers() = 2
[10:31:23.366] MulticoreFuture:
[10:31:23.366] Label: ‘future_vapply-2’
[10:31:23.366] Expression:
[10:31:23.366] {
[10:31:23.366]     do.call(function(...) {
[10:31:23.366]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.366]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.366]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.366]             on.exit(options(oopts), add = TRUE)
[10:31:23.366]         }
[10:31:23.366]         {
[10:31:23.366]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.366]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.366]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.366]             })
[10:31:23.366]         }
[10:31:23.366]     }, args = future.call.arguments)
[10:31:23.366] }
[10:31:23.366] Lazy evaluation: FALSE
[10:31:23.366] Asynchronous evaluation: TRUE
[10:31:23.366] Local evaluation: TRUE
[10:31:23.366] Environment: R_GlobalEnv
[10:31:23.366] Capture standard output: TRUE
[10:31:23.366] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.366] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:23.366] Packages: 1 packages (‘future.apply’)
[10:31:23.366] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.366] Resolved: TRUE
[10:31:23.366] Value: <not collected>
[10:31:23.366] Conditions captured: <none>
[10:31:23.366] Early signaling: FALSE
[10:31:23.366] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.366] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.376] Chunk #2 of 2 ... DONE
[10:31:23.376] Launching 2 futures (chunks) ... DONE
[10:31:23.376] Resolving 2 futures (chunks) ...
[10:31:23.376] resolve() on list ...
[10:31:23.377]  recursive: 0
[10:31:23.377]  length: 2
[10:31:23.377] 
[10:31:23.377] Future #1
[10:31:23.377] result() for MulticoreFuture ...
[10:31:23.378] result() for MulticoreFuture ...
[10:31:23.378] result() for MulticoreFuture ... done
[10:31:23.378] result() for MulticoreFuture ... done
[10:31:23.379] result() for MulticoreFuture ...
[10:31:23.379] result() for MulticoreFuture ... done
[10:31:23.379] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:23.379] - nx: 2
[10:31:23.379] - relay: TRUE
[10:31:23.379] - stdout: TRUE
[10:31:23.379] - signal: TRUE
[10:31:23.380] - resignal: FALSE
[10:31:23.380] - force: TRUE
[10:31:23.380] - relayed: [n=2] FALSE, FALSE
[10:31:23.380] - queued futures: [n=2] FALSE, FALSE
[10:31:23.380]  - until=1
[10:31:23.380]  - relaying element #1
[10:31:23.380] result() for MulticoreFuture ...
[10:31:23.381] result() for MulticoreFuture ... done
[10:31:23.384] result() for MulticoreFuture ...
[10:31:23.384] result() for MulticoreFuture ... done
[10:31:23.385] result() for MulticoreFuture ...
[10:31:23.385] result() for MulticoreFuture ... done
[10:31:23.386] result() for MulticoreFuture ...
[10:31:23.386] result() for MulticoreFuture ... done
[10:31:23.386] - relayed: [n=2] TRUE, FALSE
[10:31:23.387] - queued futures: [n=2] TRUE, FALSE
[10:31:23.387] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:23.387]  length: 1 (resolved future 1)
[10:31:23.388] Future #2
[10:31:23.388] result() for MulticoreFuture ...
[10:31:23.389] result() for MulticoreFuture ...
[10:31:23.389] result() for MulticoreFuture ... done
[10:31:23.390] result() for MulticoreFuture ... done
[10:31:23.390] result() for MulticoreFuture ...
[10:31:23.390] result() for MulticoreFuture ... done
[10:31:23.390] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:23.391] - nx: 2
[10:31:23.391] - relay: TRUE
[10:31:23.391] - stdout: TRUE
[10:31:23.391] - signal: TRUE
[10:31:23.391] - resignal: FALSE
[10:31:23.391] - force: TRUE
[10:31:23.392] - relayed: [n=2] TRUE, FALSE
[10:31:23.392] - queued futures: [n=2] TRUE, FALSE
[10:31:23.392]  - until=2
[10:31:23.392]  - relaying element #2
[10:31:23.392] result() for MulticoreFuture ...
[10:31:23.392] result() for MulticoreFuture ... done
[10:31:23.392] result() for MulticoreFuture ...
[10:31:23.393] result() for MulticoreFuture ... done
[10:31:23.393] result() for MulticoreFuture ...
[10:31:23.393] result() for MulticoreFuture ... done
[10:31:23.393] result() for MulticoreFuture ...
[10:31:23.393] result() for MulticoreFuture ... done
[10:31:23.393] - relayed: [n=2] TRUE, TRUE
[10:31:23.394] - queued futures: [n=2] TRUE, TRUE
[10:31:23.394] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:23.394]  length: 0 (resolved future 2)
[10:31:23.394] Relaying remaining futures
[10:31:23.394] signalConditionsASAP(NULL, pos=0) ...
[10:31:23.394] - nx: 2
[10:31:23.394] - relay: TRUE
[10:31:23.395] - stdout: TRUE
[10:31:23.395] - signal: TRUE
[10:31:23.395] - resignal: FALSE
[10:31:23.395] - force: TRUE
[10:31:23.395] - relayed: [n=2] TRUE, TRUE
[10:31:23.395] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:23.395] - relayed: [n=2] TRUE, TRUE
[10:31:23.395] - queued futures: [n=2] TRUE, TRUE
[10:31:23.395] signalConditionsASAP(NULL, pos=0) ... done
[10:31:23.396] resolve() on list ... DONE
[10:31:23.396] result() for MulticoreFuture ...
[10:31:23.396] result() for MulticoreFuture ... done
[10:31:23.396] result() for MulticoreFuture ...
[10:31:23.396] result() for MulticoreFuture ... done
[10:31:23.396] result() for MulticoreFuture ...
[10:31:23.396] result() for MulticoreFuture ... done
[10:31:23.396] result() for MulticoreFuture ...
[10:31:23.397] result() for MulticoreFuture ... done
[10:31:23.397]  - Number of value chunks collected: 2
[10:31:23.397] Resolving 2 futures (chunks) ... DONE
[10:31:23.397] Reducing values from 2 chunks ...
[10:31:23.397]  - Number of values collected after concatenation: 10
[10:31:23.397]  - Number of values expected: 10
[10:31:23.397] Reducing values from 2 chunks ... DONE
[10:31:23.398] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[10:31:23.400] future_lapply() ...
[10:31:23.406] Number of chunks: 2
[10:31:23.406] getGlobalsAndPackagesXApply() ...
[10:31:23.407]  - future.globals: TRUE
[10:31:23.407] getGlobalsAndPackages() ...
[10:31:23.407] Searching for globals...
[10:31:23.411] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[10:31:23.411] Searching for globals ... DONE
[10:31:23.411] Resolving globals: FALSE
[10:31:23.412] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[10:31:23.412] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:23.413] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:23.413] - packages: [1] ‘future.apply’
[10:31:23.413] getGlobalsAndPackages() ... DONE
[10:31:23.415]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:23.415]  - needed namespaces: [n=1] ‘future.apply’
[10:31:23.415] Finding globals ... DONE
[10:31:23.415]  - use_args: TRUE
[10:31:23.416]  - Getting '...' globals ...
[10:31:23.416] resolve() on list ...
[10:31:23.416]  recursive: 0
[10:31:23.416]  length: 1
[10:31:23.416]  elements: ‘...’
[10:31:23.417]  length: 0 (resolved future 1)
[10:31:23.417] resolve() on list ... DONE
[10:31:23.417]    - '...' content: [n=0] 
[10:31:23.417] List of 1
[10:31:23.417]  $ ...: list()
[10:31:23.417]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.417]  - attr(*, "where")=List of 1
[10:31:23.417]   ..$ ...:<environment: 0x55de845d2e50> 
[10:31:23.417]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.417]  - attr(*, "resolved")= logi TRUE
[10:31:23.417]  - attr(*, "total_size")= num NA
[10:31:23.420]  - Getting '...' globals ... DONE
[10:31:23.420] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:23.420] List of 8
[10:31:23.420]  $ ...future.FUN:function (x, ...)  
[10:31:23.420]  $ x_FUN        :function (x)  
[10:31:23.420]  $ times        : int 4
[10:31:23.420]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.420]  $ stop_if_not  :function (...)  
[10:31:23.420]  $ dim          : int [1:2] 2 2
[10:31:23.420]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:23.420]  $ ...          : list()
[10:31:23.420]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.420]  - attr(*, "where")=List of 8
[10:31:23.420]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:23.420]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:23.420]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:23.420]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:23.420]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:23.420]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:23.420]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:23.420]   ..$ ...          :<environment: 0x55de845d2e50> 
[10:31:23.420]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.420]  - attr(*, "resolved")= logi FALSE
[10:31:23.420]  - attr(*, "total_size")= num 105552
[10:31:23.426] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:23.426] getGlobalsAndPackagesXApply() ... DONE
[10:31:23.427] Number of futures (= number of chunks): 2
[10:31:23.427] Launching 2 futures (chunks) ...
[10:31:23.427] Chunk #1 of 2 ...
[10:31:23.427]  - Finding globals in 'X' for chunk #1 ...
[10:31:23.427] getGlobalsAndPackages() ...
[10:31:23.427] Searching for globals...
[10:31:23.427] 
[10:31:23.428] Searching for globals ... DONE
[10:31:23.428] - globals: [0] <none>
[10:31:23.428] getGlobalsAndPackages() ... DONE
[10:31:23.428]    + additional globals found: [n=0] 
[10:31:23.428]    + additional namespaces needed: [n=0] 
[10:31:23.428]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:23.428]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.428]  - seeds: <none>
[10:31:23.428]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.428] getGlobalsAndPackages() ...
[10:31:23.429] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.429] Resolving globals: FALSE
[10:31:23.429] Tweak future expression to call with '...' arguments ...
[10:31:23.429] {
[10:31:23.429]     do.call(function(...) {
[10:31:23.429]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.429]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.429]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.429]             on.exit(options(oopts), add = TRUE)
[10:31:23.429]         }
[10:31:23.429]         {
[10:31:23.429]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.429]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.429]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.429]             })
[10:31:23.429]         }
[10:31:23.429]     }, args = future.call.arguments)
[10:31:23.429] }
[10:31:23.429] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.430] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.430] - packages: [1] ‘future.apply’
[10:31:23.430] getGlobalsAndPackages() ... DONE
[10:31:23.430] run() for ‘Future’ ...
[10:31:23.430] - state: ‘created’
[10:31:23.431] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.435] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.435] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.435]   - Field: ‘label’
[10:31:23.435]   - Field: ‘local’
[10:31:23.435]   - Field: ‘owner’
[10:31:23.436]   - Field: ‘envir’
[10:31:23.436]   - Field: ‘workers’
[10:31:23.436]   - Field: ‘packages’
[10:31:23.436]   - Field: ‘gc’
[10:31:23.436]   - Field: ‘job’
[10:31:23.436]   - Field: ‘conditions’
[10:31:23.436]   - Field: ‘expr’
[10:31:23.436]   - Field: ‘uuid’
[10:31:23.436]   - Field: ‘seed’
[10:31:23.437]   - Field: ‘version’
[10:31:23.437]   - Field: ‘result’
[10:31:23.437]   - Field: ‘asynchronous’
[10:31:23.437]   - Field: ‘calls’
[10:31:23.437]   - Field: ‘globals’
[10:31:23.437]   - Field: ‘stdout’
[10:31:23.437]   - Field: ‘earlySignal’
[10:31:23.437]   - Field: ‘lazy’
[10:31:23.437]   - Field: ‘state’
[10:31:23.437] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.438] - Launch lazy future ...
[10:31:23.438] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:23.438] Packages needed by future strategies (n = 0): <none>
[10:31:23.441] {
[10:31:23.441]     {
[10:31:23.441]         {
[10:31:23.441]             ...future.startTime <- base::Sys.time()
[10:31:23.441]             {
[10:31:23.441]                 {
[10:31:23.441]                   {
[10:31:23.441]                     {
[10:31:23.441]                       {
[10:31:23.441]                         base::local({
[10:31:23.441]                           has_future <- base::requireNamespace("future", 
[10:31:23.441]                             quietly = TRUE)
[10:31:23.441]                           if (has_future) {
[10:31:23.441]                             ns <- base::getNamespace("future")
[10:31:23.441]                             version <- ns[[".package"]][["version"]]
[10:31:23.441]                             if (is.null(version)) 
[10:31:23.441]                               version <- utils::packageVersion("future")
[10:31:23.441]                           }
[10:31:23.441]                           else {
[10:31:23.441]                             version <- NULL
[10:31:23.441]                           }
[10:31:23.441]                           if (!has_future || version < "1.8.0") {
[10:31:23.441]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.441]                               "", base::R.version$version.string), 
[10:31:23.441]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.441]                                 base::R.version$platform, 8 * 
[10:31:23.441]                                   base::.Machine$sizeof.pointer), 
[10:31:23.441]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.441]                                 "release", "version")], collapse = " "), 
[10:31:23.441]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.441]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.441]                               info)
[10:31:23.441]                             info <- base::paste(info, collapse = "; ")
[10:31:23.441]                             if (!has_future) {
[10:31:23.441]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.441]                                 info)
[10:31:23.441]                             }
[10:31:23.441]                             else {
[10:31:23.441]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.441]                                 info, version)
[10:31:23.441]                             }
[10:31:23.441]                             base::stop(msg)
[10:31:23.441]                           }
[10:31:23.441]                         })
[10:31:23.441]                       }
[10:31:23.441]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.441]                       base::options(mc.cores = 1L)
[10:31:23.441]                     }
[10:31:23.441]                     base::local({
[10:31:23.441]                       for (pkg in "future.apply") {
[10:31:23.441]                         base::loadNamespace(pkg)
[10:31:23.441]                         base::library(pkg, character.only = TRUE)
[10:31:23.441]                       }
[10:31:23.441]                     })
[10:31:23.441]                   }
[10:31:23.441]                   ...future.strategy.old <- future::plan("list")
[10:31:23.441]                   options(future.plan = NULL)
[10:31:23.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.441]                 }
[10:31:23.441]                 ...future.workdir <- getwd()
[10:31:23.441]             }
[10:31:23.441]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.441]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.441]         }
[10:31:23.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.441]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.441]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.441]             base::names(...future.oldOptions))
[10:31:23.441]     }
[10:31:23.441]     if (FALSE) {
[10:31:23.441]     }
[10:31:23.441]     else {
[10:31:23.441]         if (TRUE) {
[10:31:23.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.441]                 open = "w")
[10:31:23.441]         }
[10:31:23.441]         else {
[10:31:23.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.441]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.441]         }
[10:31:23.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.441]             base::sink(type = "output", split = FALSE)
[10:31:23.441]             base::close(...future.stdout)
[10:31:23.441]         }, add = TRUE)
[10:31:23.441]     }
[10:31:23.441]     ...future.frame <- base::sys.nframe()
[10:31:23.441]     ...future.conditions <- base::list()
[10:31:23.441]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.441]     if (FALSE) {
[10:31:23.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.441]     }
[10:31:23.441]     ...future.result <- base::tryCatch({
[10:31:23.441]         base::withCallingHandlers({
[10:31:23.441]             ...future.value <- base::withVisible(base::local({
[10:31:23.441]                 withCallingHandlers({
[10:31:23.441]                   {
[10:31:23.441]                     do.call(function(...) {
[10:31:23.441]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.441]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.441]                         ...future.globals.maxSize)) {
[10:31:23.441]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.441]                         on.exit(options(oopts), add = TRUE)
[10:31:23.441]                       }
[10:31:23.441]                       {
[10:31:23.441]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.441]                           FUN = function(jj) {
[10:31:23.441]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.441]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.441]                           })
[10:31:23.441]                       }
[10:31:23.441]                     }, args = future.call.arguments)
[10:31:23.441]                   }
[10:31:23.441]                 }, immediateCondition = function(cond) {
[10:31:23.441]                   save_rds <- function (object, pathname, ...) 
[10:31:23.441]                   {
[10:31:23.441]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.441]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.441]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.441]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.441]                         fi_tmp[["mtime"]])
[10:31:23.441]                     }
[10:31:23.441]                     tryCatch({
[10:31:23.441]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.441]                     }, error = function(ex) {
[10:31:23.441]                       msg <- conditionMessage(ex)
[10:31:23.441]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.441]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.441]                         fi_tmp[["mtime"]], msg)
[10:31:23.441]                       ex$message <- msg
[10:31:23.441]                       stop(ex)
[10:31:23.441]                     })
[10:31:23.441]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.441]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.441]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.441]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.441]                       fi <- file.info(pathname)
[10:31:23.441]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.441]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.441]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.441]                         fi[["size"]], fi[["mtime"]])
[10:31:23.441]                       stop(msg)
[10:31:23.441]                     }
[10:31:23.441]                     invisible(pathname)
[10:31:23.441]                   }
[10:31:23.441]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.441]                     rootPath = tempdir()) 
[10:31:23.441]                   {
[10:31:23.441]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.441]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.441]                       tmpdir = path, fileext = ".rds")
[10:31:23.441]                     save_rds(obj, file)
[10:31:23.441]                   }
[10:31:23.441]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.441]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.441]                   {
[10:31:23.441]                     inherits <- base::inherits
[10:31:23.441]                     invokeRestart <- base::invokeRestart
[10:31:23.441]                     is.null <- base::is.null
[10:31:23.441]                     muffled <- FALSE
[10:31:23.441]                     if (inherits(cond, "message")) {
[10:31:23.441]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.441]                       if (muffled) 
[10:31:23.441]                         invokeRestart("muffleMessage")
[10:31:23.441]                     }
[10:31:23.441]                     else if (inherits(cond, "warning")) {
[10:31:23.441]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.441]                       if (muffled) 
[10:31:23.441]                         invokeRestart("muffleWarning")
[10:31:23.441]                     }
[10:31:23.441]                     else if (inherits(cond, "condition")) {
[10:31:23.441]                       if (!is.null(pattern)) {
[10:31:23.441]                         computeRestarts <- base::computeRestarts
[10:31:23.441]                         grepl <- base::grepl
[10:31:23.441]                         restarts <- computeRestarts(cond)
[10:31:23.441]                         for (restart in restarts) {
[10:31:23.441]                           name <- restart$name
[10:31:23.441]                           if (is.null(name)) 
[10:31:23.441]                             next
[10:31:23.441]                           if (!grepl(pattern, name)) 
[10:31:23.441]                             next
[10:31:23.441]                           invokeRestart(restart)
[10:31:23.441]                           muffled <- TRUE
[10:31:23.441]                           break
[10:31:23.441]                         }
[10:31:23.441]                       }
[10:31:23.441]                     }
[10:31:23.441]                     invisible(muffled)
[10:31:23.441]                   }
[10:31:23.441]                   muffleCondition(cond)
[10:31:23.441]                 })
[10:31:23.441]             }))
[10:31:23.441]             future::FutureResult(value = ...future.value$value, 
[10:31:23.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.441]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.441]                     ...future.globalenv.names))
[10:31:23.441]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.441]         }, condition = base::local({
[10:31:23.441]             c <- base::c
[10:31:23.441]             inherits <- base::inherits
[10:31:23.441]             invokeRestart <- base::invokeRestart
[10:31:23.441]             length <- base::length
[10:31:23.441]             list <- base::list
[10:31:23.441]             seq.int <- base::seq.int
[10:31:23.441]             signalCondition <- base::signalCondition
[10:31:23.441]             sys.calls <- base::sys.calls
[10:31:23.441]             `[[` <- base::`[[`
[10:31:23.441]             `+` <- base::`+`
[10:31:23.441]             `<<-` <- base::`<<-`
[10:31:23.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.441]                   3L)]
[10:31:23.441]             }
[10:31:23.441]             function(cond) {
[10:31:23.441]                 is_error <- inherits(cond, "error")
[10:31:23.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.441]                   NULL)
[10:31:23.441]                 if (is_error) {
[10:31:23.441]                   sessionInformation <- function() {
[10:31:23.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.441]                       search = base::search(), system = base::Sys.info())
[10:31:23.441]                   }
[10:31:23.441]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.441]                     cond$call), session = sessionInformation(), 
[10:31:23.441]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.441]                   signalCondition(cond)
[10:31:23.441]                 }
[10:31:23.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.441]                 "immediateCondition"))) {
[10:31:23.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.441]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.441]                   if (TRUE && !signal) {
[10:31:23.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.441]                     {
[10:31:23.441]                       inherits <- base::inherits
[10:31:23.441]                       invokeRestart <- base::invokeRestart
[10:31:23.441]                       is.null <- base::is.null
[10:31:23.441]                       muffled <- FALSE
[10:31:23.441]                       if (inherits(cond, "message")) {
[10:31:23.441]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.441]                         if (muffled) 
[10:31:23.441]                           invokeRestart("muffleMessage")
[10:31:23.441]                       }
[10:31:23.441]                       else if (inherits(cond, "warning")) {
[10:31:23.441]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.441]                         if (muffled) 
[10:31:23.441]                           invokeRestart("muffleWarning")
[10:31:23.441]                       }
[10:31:23.441]                       else if (inherits(cond, "condition")) {
[10:31:23.441]                         if (!is.null(pattern)) {
[10:31:23.441]                           computeRestarts <- base::computeRestarts
[10:31:23.441]                           grepl <- base::grepl
[10:31:23.441]                           restarts <- computeRestarts(cond)
[10:31:23.441]                           for (restart in restarts) {
[10:31:23.441]                             name <- restart$name
[10:31:23.441]                             if (is.null(name)) 
[10:31:23.441]                               next
[10:31:23.441]                             if (!grepl(pattern, name)) 
[10:31:23.441]                               next
[10:31:23.441]                             invokeRestart(restart)
[10:31:23.441]                             muffled <- TRUE
[10:31:23.441]                             break
[10:31:23.441]                           }
[10:31:23.441]                         }
[10:31:23.441]                       }
[10:31:23.441]                       invisible(muffled)
[10:31:23.441]                     }
[10:31:23.441]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.441]                   }
[10:31:23.441]                 }
[10:31:23.441]                 else {
[10:31:23.441]                   if (TRUE) {
[10:31:23.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.441]                     {
[10:31:23.441]                       inherits <- base::inherits
[10:31:23.441]                       invokeRestart <- base::invokeRestart
[10:31:23.441]                       is.null <- base::is.null
[10:31:23.441]                       muffled <- FALSE
[10:31:23.441]                       if (inherits(cond, "message")) {
[10:31:23.441]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.441]                         if (muffled) 
[10:31:23.441]                           invokeRestart("muffleMessage")
[10:31:23.441]                       }
[10:31:23.441]                       else if (inherits(cond, "warning")) {
[10:31:23.441]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.441]                         if (muffled) 
[10:31:23.441]                           invokeRestart("muffleWarning")
[10:31:23.441]                       }
[10:31:23.441]                       else if (inherits(cond, "condition")) {
[10:31:23.441]                         if (!is.null(pattern)) {
[10:31:23.441]                           computeRestarts <- base::computeRestarts
[10:31:23.441]                           grepl <- base::grepl
[10:31:23.441]                           restarts <- computeRestarts(cond)
[10:31:23.441]                           for (restart in restarts) {
[10:31:23.441]                             name <- restart$name
[10:31:23.441]                             if (is.null(name)) 
[10:31:23.441]                               next
[10:31:23.441]                             if (!grepl(pattern, name)) 
[10:31:23.441]                               next
[10:31:23.441]                             invokeRestart(restart)
[10:31:23.441]                             muffled <- TRUE
[10:31:23.441]                             break
[10:31:23.441]                           }
[10:31:23.441]                         }
[10:31:23.441]                       }
[10:31:23.441]                       invisible(muffled)
[10:31:23.441]                     }
[10:31:23.441]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.441]                   }
[10:31:23.441]                 }
[10:31:23.441]             }
[10:31:23.441]         }))
[10:31:23.441]     }, error = function(ex) {
[10:31:23.441]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.441]                 ...future.rng), started = ...future.startTime, 
[10:31:23.441]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.441]             version = "1.8"), class = "FutureResult")
[10:31:23.441]     }, finally = {
[10:31:23.441]         if (!identical(...future.workdir, getwd())) 
[10:31:23.441]             setwd(...future.workdir)
[10:31:23.441]         {
[10:31:23.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.441]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.441]             }
[10:31:23.441]             base::options(...future.oldOptions)
[10:31:23.441]             if (.Platform$OS.type == "windows") {
[10:31:23.441]                 old_names <- names(...future.oldEnvVars)
[10:31:23.441]                 envs <- base::Sys.getenv()
[10:31:23.441]                 names <- names(envs)
[10:31:23.441]                 common <- intersect(names, old_names)
[10:31:23.441]                 added <- setdiff(names, old_names)
[10:31:23.441]                 removed <- setdiff(old_names, names)
[10:31:23.441]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.441]                   envs[common]]
[10:31:23.441]                 NAMES <- toupper(changed)
[10:31:23.441]                 args <- list()
[10:31:23.441]                 for (kk in seq_along(NAMES)) {
[10:31:23.441]                   name <- changed[[kk]]
[10:31:23.441]                   NAME <- NAMES[[kk]]
[10:31:23.441]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.441]                     next
[10:31:23.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.441]                 }
[10:31:23.441]                 NAMES <- toupper(added)
[10:31:23.441]                 for (kk in seq_along(NAMES)) {
[10:31:23.441]                   name <- added[[kk]]
[10:31:23.441]                   NAME <- NAMES[[kk]]
[10:31:23.441]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.441]                     next
[10:31:23.441]                   args[[name]] <- ""
[10:31:23.441]                 }
[10:31:23.441]                 NAMES <- toupper(removed)
[10:31:23.441]                 for (kk in seq_along(NAMES)) {
[10:31:23.441]                   name <- removed[[kk]]
[10:31:23.441]                   NAME <- NAMES[[kk]]
[10:31:23.441]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.441]                     next
[10:31:23.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.441]                 }
[10:31:23.441]                 if (length(args) > 0) 
[10:31:23.441]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.441]             }
[10:31:23.441]             else {
[10:31:23.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.441]             }
[10:31:23.441]             {
[10:31:23.441]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.441]                   0L) {
[10:31:23.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.441]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.441]                   base::options(opts)
[10:31:23.441]                 }
[10:31:23.441]                 {
[10:31:23.441]                   {
[10:31:23.441]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.441]                     NULL
[10:31:23.441]                   }
[10:31:23.441]                   options(future.plan = NULL)
[10:31:23.441]                   if (is.na(NA_character_)) 
[10:31:23.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.441]                     .init = FALSE)
[10:31:23.441]                 }
[10:31:23.441]             }
[10:31:23.441]         }
[10:31:23.441]     })
[10:31:23.441]     if (TRUE) {
[10:31:23.441]         base::sink(type = "output", split = FALSE)
[10:31:23.441]         if (TRUE) {
[10:31:23.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.441]         }
[10:31:23.441]         else {
[10:31:23.441]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.441]         }
[10:31:23.441]         base::close(...future.stdout)
[10:31:23.441]         ...future.stdout <- NULL
[10:31:23.441]     }
[10:31:23.441]     ...future.result$conditions <- ...future.conditions
[10:31:23.441]     ...future.result$finished <- base::Sys.time()
[10:31:23.441]     ...future.result
[10:31:23.441] }
[10:31:23.443] assign_globals() ...
[10:31:23.443] List of 11
[10:31:23.443]  $ ...future.FUN            :function (x, ...)  
[10:31:23.443]  $ x_FUN                    :function (x)  
[10:31:23.443]  $ times                    : int 4
[10:31:23.443]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.443]  $ stop_if_not              :function (...)  
[10:31:23.443]  $ dim                      : int [1:2] 2 2
[10:31:23.443]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:23.443]  $ future.call.arguments    : list()
[10:31:23.443]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.443]  $ ...future.elements_ii    :List of 5
[10:31:23.443]   ..$ : int 1
[10:31:23.443]   ..$ : int 2
[10:31:23.443]   ..$ : int 3
[10:31:23.443]   ..$ : int 4
[10:31:23.443]   ..$ : int 5
[10:31:23.443]  $ ...future.seeds_ii       : NULL
[10:31:23.443]  $ ...future.globals.maxSize: NULL
[10:31:23.443]  - attr(*, "where")=List of 11
[10:31:23.443]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.443]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:23.443]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:23.443]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:23.443]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:23.443]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:23.443]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:23.443]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.443]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.443]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.443]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.443]  - attr(*, "resolved")= logi FALSE
[10:31:23.443]  - attr(*, "total_size")= num 105552
[10:31:23.443]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.443]  - attr(*, "already-done")= logi TRUE
[10:31:23.453] - copied ‘...future.FUN’ to environment
[10:31:23.454] - reassign environment for ‘x_FUN’
[10:31:23.454] - copied ‘x_FUN’ to environment
[10:31:23.454] - copied ‘times’ to environment
[10:31:23.454] - copied ‘stopf’ to environment
[10:31:23.454] - copied ‘stop_if_not’ to environment
[10:31:23.454] - copied ‘dim’ to environment
[10:31:23.454] - copied ‘valid_types’ to environment
[10:31:23.454] - copied ‘future.call.arguments’ to environment
[10:31:23.454] - copied ‘...future.elements_ii’ to environment
[10:31:23.455] - copied ‘...future.seeds_ii’ to environment
[10:31:23.455] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.455] assign_globals() ... done
[10:31:23.455] requestCore(): workers = 2
[10:31:23.457] MulticoreFuture started
[10:31:23.458] - Launch lazy future ... done
[10:31:23.458] run() for ‘MulticoreFuture’ ... done
[10:31:23.458] Created future:
[10:31:23.459] plan(): Setting new future strategy stack:
[10:31:23.459] List of future strategies:
[10:31:23.459] 1. sequential:
[10:31:23.459]    - args: function (..., envir = parent.frame())
[10:31:23.459]    - tweaked: FALSE
[10:31:23.459]    - call: NULL
[10:31:23.460] plan(): nbrOfWorkers() = 1
[10:31:23.462] plan(): Setting new future strategy stack:
[10:31:23.462] List of future strategies:
[10:31:23.462] 1. multicore:
[10:31:23.462]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.462]    - tweaked: FALSE
[10:31:23.462]    - call: plan(strategy)
[10:31:23.468] plan(): nbrOfWorkers() = 2
[10:31:23.458] MulticoreFuture:
[10:31:23.458] Label: ‘future_vapply-1’
[10:31:23.458] Expression:
[10:31:23.458] {
[10:31:23.458]     do.call(function(...) {
[10:31:23.458]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.458]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.458]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.458]             on.exit(options(oopts), add = TRUE)
[10:31:23.458]         }
[10:31:23.458]         {
[10:31:23.458]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.458]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.458]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.458]             })
[10:31:23.458]         }
[10:31:23.458]     }, args = future.call.arguments)
[10:31:23.458] }
[10:31:23.458] Lazy evaluation: FALSE
[10:31:23.458] Asynchronous evaluation: TRUE
[10:31:23.458] Local evaluation: TRUE
[10:31:23.458] Environment: R_GlobalEnv
[10:31:23.458] Capture standard output: TRUE
[10:31:23.458] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.458] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:23.458] Packages: 1 packages (‘future.apply’)
[10:31:23.458] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.458] Resolved: TRUE
[10:31:23.458] Value: <not collected>
[10:31:23.458] Conditions captured: <none>
[10:31:23.458] Early signaling: FALSE
[10:31:23.458] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.458] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.470] Chunk #1 of 2 ... DONE
[10:31:23.470] Chunk #2 of 2 ...
[10:31:23.470]  - Finding globals in 'X' for chunk #2 ...
[10:31:23.470] getGlobalsAndPackages() ...
[10:31:23.470] Searching for globals...
[10:31:23.471] 
[10:31:23.471] Searching for globals ... DONE
[10:31:23.471] - globals: [0] <none>
[10:31:23.471] getGlobalsAndPackages() ... DONE
[10:31:23.471]    + additional globals found: [n=0] 
[10:31:23.471]    + additional namespaces needed: [n=0] 
[10:31:23.472]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:23.472]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.472]  - seeds: <none>
[10:31:23.472]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.472] getGlobalsAndPackages() ...
[10:31:23.472] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.472] Resolving globals: FALSE
[10:31:23.473] Tweak future expression to call with '...' arguments ...
[10:31:23.473] {
[10:31:23.473]     do.call(function(...) {
[10:31:23.473]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.473]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.473]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.473]             on.exit(options(oopts), add = TRUE)
[10:31:23.473]         }
[10:31:23.473]         {
[10:31:23.473]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.473]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.473]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.473]             })
[10:31:23.473]         }
[10:31:23.473]     }, args = future.call.arguments)
[10:31:23.473] }
[10:31:23.473] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.474] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.474] - packages: [1] ‘future.apply’
[10:31:23.475] getGlobalsAndPackages() ... DONE
[10:31:23.475] run() for ‘Future’ ...
[10:31:23.475] - state: ‘created’
[10:31:23.475] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.480] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.480] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.480]   - Field: ‘label’
[10:31:23.481]   - Field: ‘local’
[10:31:23.481]   - Field: ‘owner’
[10:31:23.481]   - Field: ‘envir’
[10:31:23.481]   - Field: ‘workers’
[10:31:23.484]   - Field: ‘packages’
[10:31:23.485]   - Field: ‘gc’
[10:31:23.485]   - Field: ‘job’
[10:31:23.485]   - Field: ‘conditions’
[10:31:23.486]   - Field: ‘expr’
[10:31:23.486]   - Field: ‘uuid’
[10:31:23.486]   - Field: ‘seed’
[10:31:23.487]   - Field: ‘version’
[10:31:23.487]   - Field: ‘result’
[10:31:23.487]   - Field: ‘asynchronous’
[10:31:23.487]   - Field: ‘calls’
[10:31:23.488]   - Field: ‘globals’
[10:31:23.488]   - Field: ‘stdout’
[10:31:23.488]   - Field: ‘earlySignal’
[10:31:23.488]   - Field: ‘lazy’
[10:31:23.489]   - Field: ‘state’
[10:31:23.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.489] - Launch lazy future ...
[10:31:23.490] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:23.490] Packages needed by future strategies (n = 0): <none>
[10:31:23.491] {
[10:31:23.491]     {
[10:31:23.491]         {
[10:31:23.491]             ...future.startTime <- base::Sys.time()
[10:31:23.491]             {
[10:31:23.491]                 {
[10:31:23.491]                   {
[10:31:23.491]                     {
[10:31:23.491]                       {
[10:31:23.491]                         base::local({
[10:31:23.491]                           has_future <- base::requireNamespace("future", 
[10:31:23.491]                             quietly = TRUE)
[10:31:23.491]                           if (has_future) {
[10:31:23.491]                             ns <- base::getNamespace("future")
[10:31:23.491]                             version <- ns[[".package"]][["version"]]
[10:31:23.491]                             if (is.null(version)) 
[10:31:23.491]                               version <- utils::packageVersion("future")
[10:31:23.491]                           }
[10:31:23.491]                           else {
[10:31:23.491]                             version <- NULL
[10:31:23.491]                           }
[10:31:23.491]                           if (!has_future || version < "1.8.0") {
[10:31:23.491]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.491]                               "", base::R.version$version.string), 
[10:31:23.491]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.491]                                 base::R.version$platform, 8 * 
[10:31:23.491]                                   base::.Machine$sizeof.pointer), 
[10:31:23.491]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.491]                                 "release", "version")], collapse = " "), 
[10:31:23.491]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.491]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.491]                               info)
[10:31:23.491]                             info <- base::paste(info, collapse = "; ")
[10:31:23.491]                             if (!has_future) {
[10:31:23.491]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.491]                                 info)
[10:31:23.491]                             }
[10:31:23.491]                             else {
[10:31:23.491]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.491]                                 info, version)
[10:31:23.491]                             }
[10:31:23.491]                             base::stop(msg)
[10:31:23.491]                           }
[10:31:23.491]                         })
[10:31:23.491]                       }
[10:31:23.491]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.491]                       base::options(mc.cores = 1L)
[10:31:23.491]                     }
[10:31:23.491]                     base::local({
[10:31:23.491]                       for (pkg in "future.apply") {
[10:31:23.491]                         base::loadNamespace(pkg)
[10:31:23.491]                         base::library(pkg, character.only = TRUE)
[10:31:23.491]                       }
[10:31:23.491]                     })
[10:31:23.491]                   }
[10:31:23.491]                   ...future.strategy.old <- future::plan("list")
[10:31:23.491]                   options(future.plan = NULL)
[10:31:23.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.491]                 }
[10:31:23.491]                 ...future.workdir <- getwd()
[10:31:23.491]             }
[10:31:23.491]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.491]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.491]         }
[10:31:23.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.491]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.491]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.491]             base::names(...future.oldOptions))
[10:31:23.491]     }
[10:31:23.491]     if (FALSE) {
[10:31:23.491]     }
[10:31:23.491]     else {
[10:31:23.491]         if (TRUE) {
[10:31:23.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.491]                 open = "w")
[10:31:23.491]         }
[10:31:23.491]         else {
[10:31:23.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.491]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.491]         }
[10:31:23.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.491]             base::sink(type = "output", split = FALSE)
[10:31:23.491]             base::close(...future.stdout)
[10:31:23.491]         }, add = TRUE)
[10:31:23.491]     }
[10:31:23.491]     ...future.frame <- base::sys.nframe()
[10:31:23.491]     ...future.conditions <- base::list()
[10:31:23.491]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.491]     if (FALSE) {
[10:31:23.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.491]     }
[10:31:23.491]     ...future.result <- base::tryCatch({
[10:31:23.491]         base::withCallingHandlers({
[10:31:23.491]             ...future.value <- base::withVisible(base::local({
[10:31:23.491]                 withCallingHandlers({
[10:31:23.491]                   {
[10:31:23.491]                     do.call(function(...) {
[10:31:23.491]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.491]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.491]                         ...future.globals.maxSize)) {
[10:31:23.491]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.491]                         on.exit(options(oopts), add = TRUE)
[10:31:23.491]                       }
[10:31:23.491]                       {
[10:31:23.491]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.491]                           FUN = function(jj) {
[10:31:23.491]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.491]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.491]                           })
[10:31:23.491]                       }
[10:31:23.491]                     }, args = future.call.arguments)
[10:31:23.491]                   }
[10:31:23.491]                 }, immediateCondition = function(cond) {
[10:31:23.491]                   save_rds <- function (object, pathname, ...) 
[10:31:23.491]                   {
[10:31:23.491]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.491]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.491]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.491]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.491]                         fi_tmp[["mtime"]])
[10:31:23.491]                     }
[10:31:23.491]                     tryCatch({
[10:31:23.491]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.491]                     }, error = function(ex) {
[10:31:23.491]                       msg <- conditionMessage(ex)
[10:31:23.491]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.491]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.491]                         fi_tmp[["mtime"]], msg)
[10:31:23.491]                       ex$message <- msg
[10:31:23.491]                       stop(ex)
[10:31:23.491]                     })
[10:31:23.491]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.491]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.491]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.491]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.491]                       fi <- file.info(pathname)
[10:31:23.491]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.491]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.491]                         fi[["size"]], fi[["mtime"]])
[10:31:23.491]                       stop(msg)
[10:31:23.491]                     }
[10:31:23.491]                     invisible(pathname)
[10:31:23.491]                   }
[10:31:23.491]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.491]                     rootPath = tempdir()) 
[10:31:23.491]                   {
[10:31:23.491]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.491]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.491]                       tmpdir = path, fileext = ".rds")
[10:31:23.491]                     save_rds(obj, file)
[10:31:23.491]                   }
[10:31:23.491]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.491]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.491]                   {
[10:31:23.491]                     inherits <- base::inherits
[10:31:23.491]                     invokeRestart <- base::invokeRestart
[10:31:23.491]                     is.null <- base::is.null
[10:31:23.491]                     muffled <- FALSE
[10:31:23.491]                     if (inherits(cond, "message")) {
[10:31:23.491]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.491]                       if (muffled) 
[10:31:23.491]                         invokeRestart("muffleMessage")
[10:31:23.491]                     }
[10:31:23.491]                     else if (inherits(cond, "warning")) {
[10:31:23.491]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.491]                       if (muffled) 
[10:31:23.491]                         invokeRestart("muffleWarning")
[10:31:23.491]                     }
[10:31:23.491]                     else if (inherits(cond, "condition")) {
[10:31:23.491]                       if (!is.null(pattern)) {
[10:31:23.491]                         computeRestarts <- base::computeRestarts
[10:31:23.491]                         grepl <- base::grepl
[10:31:23.491]                         restarts <- computeRestarts(cond)
[10:31:23.491]                         for (restart in restarts) {
[10:31:23.491]                           name <- restart$name
[10:31:23.491]                           if (is.null(name)) 
[10:31:23.491]                             next
[10:31:23.491]                           if (!grepl(pattern, name)) 
[10:31:23.491]                             next
[10:31:23.491]                           invokeRestart(restart)
[10:31:23.491]                           muffled <- TRUE
[10:31:23.491]                           break
[10:31:23.491]                         }
[10:31:23.491]                       }
[10:31:23.491]                     }
[10:31:23.491]                     invisible(muffled)
[10:31:23.491]                   }
[10:31:23.491]                   muffleCondition(cond)
[10:31:23.491]                 })
[10:31:23.491]             }))
[10:31:23.491]             future::FutureResult(value = ...future.value$value, 
[10:31:23.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.491]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.491]                     ...future.globalenv.names))
[10:31:23.491]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.491]         }, condition = base::local({
[10:31:23.491]             c <- base::c
[10:31:23.491]             inherits <- base::inherits
[10:31:23.491]             invokeRestart <- base::invokeRestart
[10:31:23.491]             length <- base::length
[10:31:23.491]             list <- base::list
[10:31:23.491]             seq.int <- base::seq.int
[10:31:23.491]             signalCondition <- base::signalCondition
[10:31:23.491]             sys.calls <- base::sys.calls
[10:31:23.491]             `[[` <- base::`[[`
[10:31:23.491]             `+` <- base::`+`
[10:31:23.491]             `<<-` <- base::`<<-`
[10:31:23.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.491]                   3L)]
[10:31:23.491]             }
[10:31:23.491]             function(cond) {
[10:31:23.491]                 is_error <- inherits(cond, "error")
[10:31:23.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.491]                   NULL)
[10:31:23.491]                 if (is_error) {
[10:31:23.491]                   sessionInformation <- function() {
[10:31:23.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.491]                       search = base::search(), system = base::Sys.info())
[10:31:23.491]                   }
[10:31:23.491]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.491]                     cond$call), session = sessionInformation(), 
[10:31:23.491]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.491]                   signalCondition(cond)
[10:31:23.491]                 }
[10:31:23.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.491]                 "immediateCondition"))) {
[10:31:23.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.491]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.491]                   if (TRUE && !signal) {
[10:31:23.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.491]                     {
[10:31:23.491]                       inherits <- base::inherits
[10:31:23.491]                       invokeRestart <- base::invokeRestart
[10:31:23.491]                       is.null <- base::is.null
[10:31:23.491]                       muffled <- FALSE
[10:31:23.491]                       if (inherits(cond, "message")) {
[10:31:23.491]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.491]                         if (muffled) 
[10:31:23.491]                           invokeRestart("muffleMessage")
[10:31:23.491]                       }
[10:31:23.491]                       else if (inherits(cond, "warning")) {
[10:31:23.491]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.491]                         if (muffled) 
[10:31:23.491]                           invokeRestart("muffleWarning")
[10:31:23.491]                       }
[10:31:23.491]                       else if (inherits(cond, "condition")) {
[10:31:23.491]                         if (!is.null(pattern)) {
[10:31:23.491]                           computeRestarts <- base::computeRestarts
[10:31:23.491]                           grepl <- base::grepl
[10:31:23.491]                           restarts <- computeRestarts(cond)
[10:31:23.491]                           for (restart in restarts) {
[10:31:23.491]                             name <- restart$name
[10:31:23.491]                             if (is.null(name)) 
[10:31:23.491]                               next
[10:31:23.491]                             if (!grepl(pattern, name)) 
[10:31:23.491]                               next
[10:31:23.491]                             invokeRestart(restart)
[10:31:23.491]                             muffled <- TRUE
[10:31:23.491]                             break
[10:31:23.491]                           }
[10:31:23.491]                         }
[10:31:23.491]                       }
[10:31:23.491]                       invisible(muffled)
[10:31:23.491]                     }
[10:31:23.491]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.491]                   }
[10:31:23.491]                 }
[10:31:23.491]                 else {
[10:31:23.491]                   if (TRUE) {
[10:31:23.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.491]                     {
[10:31:23.491]                       inherits <- base::inherits
[10:31:23.491]                       invokeRestart <- base::invokeRestart
[10:31:23.491]                       is.null <- base::is.null
[10:31:23.491]                       muffled <- FALSE
[10:31:23.491]                       if (inherits(cond, "message")) {
[10:31:23.491]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.491]                         if (muffled) 
[10:31:23.491]                           invokeRestart("muffleMessage")
[10:31:23.491]                       }
[10:31:23.491]                       else if (inherits(cond, "warning")) {
[10:31:23.491]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.491]                         if (muffled) 
[10:31:23.491]                           invokeRestart("muffleWarning")
[10:31:23.491]                       }
[10:31:23.491]                       else if (inherits(cond, "condition")) {
[10:31:23.491]                         if (!is.null(pattern)) {
[10:31:23.491]                           computeRestarts <- base::computeRestarts
[10:31:23.491]                           grepl <- base::grepl
[10:31:23.491]                           restarts <- computeRestarts(cond)
[10:31:23.491]                           for (restart in restarts) {
[10:31:23.491]                             name <- restart$name
[10:31:23.491]                             if (is.null(name)) 
[10:31:23.491]                               next
[10:31:23.491]                             if (!grepl(pattern, name)) 
[10:31:23.491]                               next
[10:31:23.491]                             invokeRestart(restart)
[10:31:23.491]                             muffled <- TRUE
[10:31:23.491]                             break
[10:31:23.491]                           }
[10:31:23.491]                         }
[10:31:23.491]                       }
[10:31:23.491]                       invisible(muffled)
[10:31:23.491]                     }
[10:31:23.491]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.491]                   }
[10:31:23.491]                 }
[10:31:23.491]             }
[10:31:23.491]         }))
[10:31:23.491]     }, error = function(ex) {
[10:31:23.491]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.491]                 ...future.rng), started = ...future.startTime, 
[10:31:23.491]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.491]             version = "1.8"), class = "FutureResult")
[10:31:23.491]     }, finally = {
[10:31:23.491]         if (!identical(...future.workdir, getwd())) 
[10:31:23.491]             setwd(...future.workdir)
[10:31:23.491]         {
[10:31:23.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.491]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.491]             }
[10:31:23.491]             base::options(...future.oldOptions)
[10:31:23.491]             if (.Platform$OS.type == "windows") {
[10:31:23.491]                 old_names <- names(...future.oldEnvVars)
[10:31:23.491]                 envs <- base::Sys.getenv()
[10:31:23.491]                 names <- names(envs)
[10:31:23.491]                 common <- intersect(names, old_names)
[10:31:23.491]                 added <- setdiff(names, old_names)
[10:31:23.491]                 removed <- setdiff(old_names, names)
[10:31:23.491]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.491]                   envs[common]]
[10:31:23.491]                 NAMES <- toupper(changed)
[10:31:23.491]                 args <- list()
[10:31:23.491]                 for (kk in seq_along(NAMES)) {
[10:31:23.491]                   name <- changed[[kk]]
[10:31:23.491]                   NAME <- NAMES[[kk]]
[10:31:23.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.491]                     next
[10:31:23.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.491]                 }
[10:31:23.491]                 NAMES <- toupper(added)
[10:31:23.491]                 for (kk in seq_along(NAMES)) {
[10:31:23.491]                   name <- added[[kk]]
[10:31:23.491]                   NAME <- NAMES[[kk]]
[10:31:23.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.491]                     next
[10:31:23.491]                   args[[name]] <- ""
[10:31:23.491]                 }
[10:31:23.491]                 NAMES <- toupper(removed)
[10:31:23.491]                 for (kk in seq_along(NAMES)) {
[10:31:23.491]                   name <- removed[[kk]]
[10:31:23.491]                   NAME <- NAMES[[kk]]
[10:31:23.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.491]                     next
[10:31:23.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.491]                 }
[10:31:23.491]                 if (length(args) > 0) 
[10:31:23.491]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.491]             }
[10:31:23.491]             else {
[10:31:23.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.491]             }
[10:31:23.491]             {
[10:31:23.491]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.491]                   0L) {
[10:31:23.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.491]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.491]                   base::options(opts)
[10:31:23.491]                 }
[10:31:23.491]                 {
[10:31:23.491]                   {
[10:31:23.491]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.491]                     NULL
[10:31:23.491]                   }
[10:31:23.491]                   options(future.plan = NULL)
[10:31:23.491]                   if (is.na(NA_character_)) 
[10:31:23.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.491]                     .init = FALSE)
[10:31:23.491]                 }
[10:31:23.491]             }
[10:31:23.491]         }
[10:31:23.491]     })
[10:31:23.491]     if (TRUE) {
[10:31:23.491]         base::sink(type = "output", split = FALSE)
[10:31:23.491]         if (TRUE) {
[10:31:23.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.491]         }
[10:31:23.491]         else {
[10:31:23.491]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.491]         }
[10:31:23.491]         base::close(...future.stdout)
[10:31:23.491]         ...future.stdout <- NULL
[10:31:23.491]     }
[10:31:23.491]     ...future.result$conditions <- ...future.conditions
[10:31:23.491]     ...future.result$finished <- base::Sys.time()
[10:31:23.491]     ...future.result
[10:31:23.491] }
[10:31:23.494] assign_globals() ...
[10:31:23.494] List of 11
[10:31:23.494]  $ ...future.FUN            :function (x, ...)  
[10:31:23.494]  $ x_FUN                    :function (x)  
[10:31:23.494]  $ times                    : int 4
[10:31:23.494]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.494]  $ stop_if_not              :function (...)  
[10:31:23.494]  $ dim                      : int [1:2] 2 2
[10:31:23.494]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:23.494]  $ future.call.arguments    : list()
[10:31:23.494]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.494]  $ ...future.elements_ii    :List of 5
[10:31:23.494]   ..$ : int 6
[10:31:23.494]   ..$ : int 7
[10:31:23.494]   ..$ : int 8
[10:31:23.494]   ..$ : int 9
[10:31:23.494]   ..$ : int 10
[10:31:23.494]  $ ...future.seeds_ii       : NULL
[10:31:23.494]  $ ...future.globals.maxSize: NULL
[10:31:23.494]  - attr(*, "where")=List of 11
[10:31:23.494]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.494]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:23.494]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:23.494]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:23.494]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:23.494]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:23.494]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:23.494]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.494]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.494]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.494]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.494]  - attr(*, "resolved")= logi FALSE
[10:31:23.494]  - attr(*, "total_size")= num 105552
[10:31:23.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.494]  - attr(*, "already-done")= logi TRUE
[10:31:23.508] - copied ‘...future.FUN’ to environment
[10:31:23.508] - reassign environment for ‘x_FUN’
[10:31:23.508] - copied ‘x_FUN’ to environment
[10:31:23.508] - copied ‘times’ to environment
[10:31:23.508] - copied ‘stopf’ to environment
[10:31:23.508] - copied ‘stop_if_not’ to environment
[10:31:23.508] - copied ‘dim’ to environment
[10:31:23.509] - copied ‘valid_types’ to environment
[10:31:23.509] - copied ‘future.call.arguments’ to environment
[10:31:23.509] - copied ‘...future.elements_ii’ to environment
[10:31:23.509] - copied ‘...future.seeds_ii’ to environment
[10:31:23.509] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.509] assign_globals() ... done
[10:31:23.509] requestCore(): workers = 2
[10:31:23.512] MulticoreFuture started
[10:31:23.512] - Launch lazy future ... done
[10:31:23.512] run() for ‘MulticoreFuture’ ... done
[10:31:23.512] Created future:
[10:31:23.513] plan(): Setting new future strategy stack:
[10:31:23.514] List of future strategies:
[10:31:23.514] 1. sequential:
[10:31:23.514]    - args: function (..., envir = parent.frame())
[10:31:23.514]    - tweaked: FALSE
[10:31:23.514]    - call: NULL
[10:31:23.514] plan(): nbrOfWorkers() = 1
[10:31:23.516] plan(): Setting new future strategy stack:
[10:31:23.517] List of future strategies:
[10:31:23.517] 1. multicore:
[10:31:23.517]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.517]    - tweaked: FALSE
[10:31:23.517]    - call: plan(strategy)
[10:31:23.522] plan(): nbrOfWorkers() = 2
[10:31:23.513] MulticoreFuture:
[10:31:23.513] Label: ‘future_vapply-2’
[10:31:23.513] Expression:
[10:31:23.513] {
[10:31:23.513]     do.call(function(...) {
[10:31:23.513]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.513]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.513]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.513]             on.exit(options(oopts), add = TRUE)
[10:31:23.513]         }
[10:31:23.513]         {
[10:31:23.513]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.513]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.513]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.513]             })
[10:31:23.513]         }
[10:31:23.513]     }, args = future.call.arguments)
[10:31:23.513] }
[10:31:23.513] Lazy evaluation: FALSE
[10:31:23.513] Asynchronous evaluation: TRUE
[10:31:23.513] Local evaluation: TRUE
[10:31:23.513] Environment: R_GlobalEnv
[10:31:23.513] Capture standard output: TRUE
[10:31:23.513] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.513] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:23.513] Packages: 1 packages (‘future.apply’)
[10:31:23.513] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.513] Resolved: TRUE
[10:31:23.513] Value: <not collected>
[10:31:23.513] Conditions captured: <none>
[10:31:23.513] Early signaling: FALSE
[10:31:23.513] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.513] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.523] Chunk #2 of 2 ... DONE
[10:31:23.523] Launching 2 futures (chunks) ... DONE
[10:31:23.523] Resolving 2 futures (chunks) ...
[10:31:23.524] resolve() on list ...
[10:31:23.524]  recursive: 0
[10:31:23.524]  length: 2
[10:31:23.524] 
[10:31:23.524] Future #1
[10:31:23.525] result() for MulticoreFuture ...
[10:31:23.526] result() for MulticoreFuture ...
[10:31:23.526] result() for MulticoreFuture ... done
[10:31:23.526] result() for MulticoreFuture ... done
[10:31:23.526] result() for MulticoreFuture ...
[10:31:23.526] result() for MulticoreFuture ... done
[10:31:23.527] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:23.527] - nx: 2
[10:31:23.527] - relay: TRUE
[10:31:23.527] - stdout: TRUE
[10:31:23.527] - signal: TRUE
[10:31:23.527] - resignal: FALSE
[10:31:23.528] - force: TRUE
[10:31:23.528] - relayed: [n=2] FALSE, FALSE
[10:31:23.528] - queued futures: [n=2] FALSE, FALSE
[10:31:23.528]  - until=1
[10:31:23.528]  - relaying element #1
[10:31:23.532] result() for MulticoreFuture ...
[10:31:23.533] result() for MulticoreFuture ... done
[10:31:23.533] result() for MulticoreFuture ...
[10:31:23.534] result() for MulticoreFuture ... done
[10:31:23.534] result() for MulticoreFuture ...
[10:31:23.534] result() for MulticoreFuture ... done
[10:31:23.535] result() for MulticoreFuture ...
[10:31:23.535] result() for MulticoreFuture ... done
[10:31:23.535] - relayed: [n=2] TRUE, FALSE
[10:31:23.536] - queued futures: [n=2] TRUE, FALSE
[10:31:23.536] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:23.536]  length: 1 (resolved future 1)
[10:31:23.537] Future #2
[10:31:23.537] result() for MulticoreFuture ...
[10:31:23.538] result() for MulticoreFuture ...
[10:31:23.539] result() for MulticoreFuture ... done
[10:31:23.539] result() for MulticoreFuture ... done
[10:31:23.539] result() for MulticoreFuture ...
[10:31:23.539] result() for MulticoreFuture ... done
[10:31:23.539] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:23.540] - nx: 2
[10:31:23.540] - relay: TRUE
[10:31:23.540] - stdout: TRUE
[10:31:23.540] - signal: TRUE
[10:31:23.540] - resignal: FALSE
[10:31:23.540] - force: TRUE
[10:31:23.541] - relayed: [n=2] TRUE, FALSE
[10:31:23.541] - queued futures: [n=2] TRUE, FALSE
[10:31:23.541]  - until=2
[10:31:23.541]  - relaying element #2
[10:31:23.541] result() for MulticoreFuture ...
[10:31:23.541] result() for MulticoreFuture ... done
[10:31:23.542] result() for MulticoreFuture ...
[10:31:23.542] result() for MulticoreFuture ... done
[10:31:23.542] result() for MulticoreFuture ...
[10:31:23.542] result() for MulticoreFuture ... done
[10:31:23.542] result() for MulticoreFuture ...
[10:31:23.542] result() for MulticoreFuture ... done
[10:31:23.542] - relayed: [n=2] TRUE, TRUE
[10:31:23.543] - queued futures: [n=2] TRUE, TRUE
[10:31:23.543] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:23.543]  length: 0 (resolved future 2)
[10:31:23.543] Relaying remaining futures
[10:31:23.543] signalConditionsASAP(NULL, pos=0) ...
[10:31:23.543] - nx: 2
[10:31:23.543] - relay: TRUE
[10:31:23.544] - stdout: TRUE
[10:31:23.544] - signal: TRUE
[10:31:23.544] - resignal: FALSE
[10:31:23.544] - force: TRUE
[10:31:23.544] - relayed: [n=2] TRUE, TRUE
[10:31:23.544] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:23.544] - relayed: [n=2] TRUE, TRUE
[10:31:23.544] - queued futures: [n=2] TRUE, TRUE
[10:31:23.544] signalConditionsASAP(NULL, pos=0) ... done
[10:31:23.545] resolve() on list ... DONE
[10:31:23.545] result() for MulticoreFuture ...
[10:31:23.545] result() for MulticoreFuture ... done
[10:31:23.545] result() for MulticoreFuture ...
[10:31:23.545] result() for MulticoreFuture ... done
[10:31:23.545] result() for MulticoreFuture ...
[10:31:23.545] result() for MulticoreFuture ... done
[10:31:23.546] result() for MulticoreFuture ...
[10:31:23.546] result() for MulticoreFuture ... done
[10:31:23.546]  - Number of value chunks collected: 2
[10:31:23.546] Resolving 2 futures (chunks) ... DONE
[10:31:23.546] Reducing values from 2 chunks ...
[10:31:23.546]  - Number of values collected after concatenation: 10
[10:31:23.546]  - Number of values expected: 10
[10:31:23.546] Reducing values from 2 chunks ... DONE
[10:31:23.547] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[10:31:23.549] future_lapply() ...
[10:31:23.555] Number of chunks: 2
[10:31:23.556] getGlobalsAndPackagesXApply() ...
[10:31:23.556]  - future.globals: TRUE
[10:31:23.556] getGlobalsAndPackages() ...
[10:31:23.556] Searching for globals...
[10:31:23.560] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[10:31:23.560] Searching for globals ... DONE
[10:31:23.560] Resolving globals: FALSE
[10:31:23.561] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[10:31:23.561] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:23.564] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:23.564] - packages: [2] ‘stats’, ‘future.apply’
[10:31:23.564] getGlobalsAndPackages() ... DONE
[10:31:23.564]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:23.564]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:31:23.564] Finding globals ... DONE
[10:31:23.564]  - use_args: TRUE
[10:31:23.565]  - Getting '...' globals ...
[10:31:23.565] resolve() on list ...
[10:31:23.565]  recursive: 0
[10:31:23.565]  length: 1
[10:31:23.565]  elements: ‘...’
[10:31:23.566]  length: 0 (resolved future 1)
[10:31:23.566] resolve() on list ... DONE
[10:31:23.566]    - '...' content: [n=0] 
[10:31:23.566] List of 1
[10:31:23.566]  $ ...: list()
[10:31:23.566]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.566]  - attr(*, "where")=List of 1
[10:31:23.566]   ..$ ...:<environment: 0x55de843c2758> 
[10:31:23.566]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.566]  - attr(*, "resolved")= logi TRUE
[10:31:23.566]  - attr(*, "total_size")= num NA
[10:31:23.569]  - Getting '...' globals ... DONE
[10:31:23.569] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:23.569] List of 8
[10:31:23.569]  $ ...future.FUN:function (x, ...)  
[10:31:23.569]  $ x_FUN        :function (x, ...)  
[10:31:23.569]  $ times        : int 5
[10:31:23.569]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.569]  $ stop_if_not  :function (...)  
[10:31:23.569]  $ dim          : NULL
[10:31:23.569]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:23.569]  $ ...          : list()
[10:31:23.569]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.569]  - attr(*, "where")=List of 8
[10:31:23.569]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:23.569]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:23.569]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:23.569]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:23.569]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:23.569]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:23.569]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:23.569]   ..$ ...          :<environment: 0x55de843c2758> 
[10:31:23.569]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.569]  - attr(*, "resolved")= logi FALSE
[10:31:23.569]  - attr(*, "total_size")= num 95528
[10:31:23.575] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:31:23.575] getGlobalsAndPackagesXApply() ... DONE
[10:31:23.575] Number of futures (= number of chunks): 2
[10:31:23.575] Launching 2 futures (chunks) ...
[10:31:23.576] Chunk #1 of 2 ...
[10:31:23.576]  - Finding globals in 'X' for chunk #1 ...
[10:31:23.576] getGlobalsAndPackages() ...
[10:31:23.576] Searching for globals...
[10:31:23.576] 
[10:31:23.576] Searching for globals ... DONE
[10:31:23.576] - globals: [0] <none>
[10:31:23.576] getGlobalsAndPackages() ... DONE
[10:31:23.576]    + additional globals found: [n=0] 
[10:31:23.577]    + additional namespaces needed: [n=0] 
[10:31:23.577]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:23.577]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.577]  - seeds: <none>
[10:31:23.577]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.577] getGlobalsAndPackages() ...
[10:31:23.577] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.577] Resolving globals: FALSE
[10:31:23.577] Tweak future expression to call with '...' arguments ...
[10:31:23.578] {
[10:31:23.578]     do.call(function(...) {
[10:31:23.578]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.578]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.578]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.578]             on.exit(options(oopts), add = TRUE)
[10:31:23.578]         }
[10:31:23.578]         {
[10:31:23.578]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.578]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.578]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.578]             })
[10:31:23.578]         }
[10:31:23.578]     }, args = future.call.arguments)
[10:31:23.578] }
[10:31:23.578] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.578] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.579] - packages: [2] ‘stats’, ‘future.apply’
[10:31:23.579] getGlobalsAndPackages() ... DONE
[10:31:23.579] run() for ‘Future’ ...
[10:31:23.579] - state: ‘created’
[10:31:23.579] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.583] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.584] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.584]   - Field: ‘label’
[10:31:23.584]   - Field: ‘local’
[10:31:23.584]   - Field: ‘owner’
[10:31:23.584]   - Field: ‘envir’
[10:31:23.584]   - Field: ‘workers’
[10:31:23.584]   - Field: ‘packages’
[10:31:23.585]   - Field: ‘gc’
[10:31:23.585]   - Field: ‘job’
[10:31:23.585]   - Field: ‘conditions’
[10:31:23.585]   - Field: ‘expr’
[10:31:23.585]   - Field: ‘uuid’
[10:31:23.585]   - Field: ‘seed’
[10:31:23.585]   - Field: ‘version’
[10:31:23.585]   - Field: ‘result’
[10:31:23.585]   - Field: ‘asynchronous’
[10:31:23.586]   - Field: ‘calls’
[10:31:23.586]   - Field: ‘globals’
[10:31:23.586]   - Field: ‘stdout’
[10:31:23.586]   - Field: ‘earlySignal’
[10:31:23.586]   - Field: ‘lazy’
[10:31:23.586]   - Field: ‘state’
[10:31:23.586] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.588] - Launch lazy future ...
[10:31:23.589] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:31:23.589] Packages needed by future strategies (n = 0): <none>
[10:31:23.590] {
[10:31:23.590]     {
[10:31:23.590]         {
[10:31:23.590]             ...future.startTime <- base::Sys.time()
[10:31:23.590]             {
[10:31:23.590]                 {
[10:31:23.590]                   {
[10:31:23.590]                     {
[10:31:23.590]                       {
[10:31:23.590]                         base::local({
[10:31:23.590]                           has_future <- base::requireNamespace("future", 
[10:31:23.590]                             quietly = TRUE)
[10:31:23.590]                           if (has_future) {
[10:31:23.590]                             ns <- base::getNamespace("future")
[10:31:23.590]                             version <- ns[[".package"]][["version"]]
[10:31:23.590]                             if (is.null(version)) 
[10:31:23.590]                               version <- utils::packageVersion("future")
[10:31:23.590]                           }
[10:31:23.590]                           else {
[10:31:23.590]                             version <- NULL
[10:31:23.590]                           }
[10:31:23.590]                           if (!has_future || version < "1.8.0") {
[10:31:23.590]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.590]                               "", base::R.version$version.string), 
[10:31:23.590]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.590]                                 base::R.version$platform, 8 * 
[10:31:23.590]                                   base::.Machine$sizeof.pointer), 
[10:31:23.590]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.590]                                 "release", "version")], collapse = " "), 
[10:31:23.590]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.590]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.590]                               info)
[10:31:23.590]                             info <- base::paste(info, collapse = "; ")
[10:31:23.590]                             if (!has_future) {
[10:31:23.590]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.590]                                 info)
[10:31:23.590]                             }
[10:31:23.590]                             else {
[10:31:23.590]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.590]                                 info, version)
[10:31:23.590]                             }
[10:31:23.590]                             base::stop(msg)
[10:31:23.590]                           }
[10:31:23.590]                         })
[10:31:23.590]                       }
[10:31:23.590]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.590]                       base::options(mc.cores = 1L)
[10:31:23.590]                     }
[10:31:23.590]                     base::local({
[10:31:23.590]                       for (pkg in c("stats", "future.apply")) {
[10:31:23.590]                         base::loadNamespace(pkg)
[10:31:23.590]                         base::library(pkg, character.only = TRUE)
[10:31:23.590]                       }
[10:31:23.590]                     })
[10:31:23.590]                   }
[10:31:23.590]                   ...future.strategy.old <- future::plan("list")
[10:31:23.590]                   options(future.plan = NULL)
[10:31:23.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.590]                 }
[10:31:23.590]                 ...future.workdir <- getwd()
[10:31:23.590]             }
[10:31:23.590]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.590]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.590]         }
[10:31:23.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.590]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.590]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.590]             base::names(...future.oldOptions))
[10:31:23.590]     }
[10:31:23.590]     if (FALSE) {
[10:31:23.590]     }
[10:31:23.590]     else {
[10:31:23.590]         if (TRUE) {
[10:31:23.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.590]                 open = "w")
[10:31:23.590]         }
[10:31:23.590]         else {
[10:31:23.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.590]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.590]         }
[10:31:23.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.590]             base::sink(type = "output", split = FALSE)
[10:31:23.590]             base::close(...future.stdout)
[10:31:23.590]         }, add = TRUE)
[10:31:23.590]     }
[10:31:23.590]     ...future.frame <- base::sys.nframe()
[10:31:23.590]     ...future.conditions <- base::list()
[10:31:23.590]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.590]     if (FALSE) {
[10:31:23.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.590]     }
[10:31:23.590]     ...future.result <- base::tryCatch({
[10:31:23.590]         base::withCallingHandlers({
[10:31:23.590]             ...future.value <- base::withVisible(base::local({
[10:31:23.590]                 withCallingHandlers({
[10:31:23.590]                   {
[10:31:23.590]                     do.call(function(...) {
[10:31:23.590]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.590]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.590]                         ...future.globals.maxSize)) {
[10:31:23.590]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.590]                         on.exit(options(oopts), add = TRUE)
[10:31:23.590]                       }
[10:31:23.590]                       {
[10:31:23.590]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.590]                           FUN = function(jj) {
[10:31:23.590]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.590]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.590]                           })
[10:31:23.590]                       }
[10:31:23.590]                     }, args = future.call.arguments)
[10:31:23.590]                   }
[10:31:23.590]                 }, immediateCondition = function(cond) {
[10:31:23.590]                   save_rds <- function (object, pathname, ...) 
[10:31:23.590]                   {
[10:31:23.590]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.590]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.590]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.590]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.590]                         fi_tmp[["mtime"]])
[10:31:23.590]                     }
[10:31:23.590]                     tryCatch({
[10:31:23.590]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.590]                     }, error = function(ex) {
[10:31:23.590]                       msg <- conditionMessage(ex)
[10:31:23.590]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.590]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.590]                         fi_tmp[["mtime"]], msg)
[10:31:23.590]                       ex$message <- msg
[10:31:23.590]                       stop(ex)
[10:31:23.590]                     })
[10:31:23.590]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.590]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.590]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.590]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.590]                       fi <- file.info(pathname)
[10:31:23.590]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.590]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.590]                         fi[["size"]], fi[["mtime"]])
[10:31:23.590]                       stop(msg)
[10:31:23.590]                     }
[10:31:23.590]                     invisible(pathname)
[10:31:23.590]                   }
[10:31:23.590]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.590]                     rootPath = tempdir()) 
[10:31:23.590]                   {
[10:31:23.590]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.590]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.590]                       tmpdir = path, fileext = ".rds")
[10:31:23.590]                     save_rds(obj, file)
[10:31:23.590]                   }
[10:31:23.590]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.590]                   {
[10:31:23.590]                     inherits <- base::inherits
[10:31:23.590]                     invokeRestart <- base::invokeRestart
[10:31:23.590]                     is.null <- base::is.null
[10:31:23.590]                     muffled <- FALSE
[10:31:23.590]                     if (inherits(cond, "message")) {
[10:31:23.590]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.590]                       if (muffled) 
[10:31:23.590]                         invokeRestart("muffleMessage")
[10:31:23.590]                     }
[10:31:23.590]                     else if (inherits(cond, "warning")) {
[10:31:23.590]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.590]                       if (muffled) 
[10:31:23.590]                         invokeRestart("muffleWarning")
[10:31:23.590]                     }
[10:31:23.590]                     else if (inherits(cond, "condition")) {
[10:31:23.590]                       if (!is.null(pattern)) {
[10:31:23.590]                         computeRestarts <- base::computeRestarts
[10:31:23.590]                         grepl <- base::grepl
[10:31:23.590]                         restarts <- computeRestarts(cond)
[10:31:23.590]                         for (restart in restarts) {
[10:31:23.590]                           name <- restart$name
[10:31:23.590]                           if (is.null(name)) 
[10:31:23.590]                             next
[10:31:23.590]                           if (!grepl(pattern, name)) 
[10:31:23.590]                             next
[10:31:23.590]                           invokeRestart(restart)
[10:31:23.590]                           muffled <- TRUE
[10:31:23.590]                           break
[10:31:23.590]                         }
[10:31:23.590]                       }
[10:31:23.590]                     }
[10:31:23.590]                     invisible(muffled)
[10:31:23.590]                   }
[10:31:23.590]                   muffleCondition(cond)
[10:31:23.590]                 })
[10:31:23.590]             }))
[10:31:23.590]             future::FutureResult(value = ...future.value$value, 
[10:31:23.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.590]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.590]                     ...future.globalenv.names))
[10:31:23.590]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.590]         }, condition = base::local({
[10:31:23.590]             c <- base::c
[10:31:23.590]             inherits <- base::inherits
[10:31:23.590]             invokeRestart <- base::invokeRestart
[10:31:23.590]             length <- base::length
[10:31:23.590]             list <- base::list
[10:31:23.590]             seq.int <- base::seq.int
[10:31:23.590]             signalCondition <- base::signalCondition
[10:31:23.590]             sys.calls <- base::sys.calls
[10:31:23.590]             `[[` <- base::`[[`
[10:31:23.590]             `+` <- base::`+`
[10:31:23.590]             `<<-` <- base::`<<-`
[10:31:23.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.590]                   3L)]
[10:31:23.590]             }
[10:31:23.590]             function(cond) {
[10:31:23.590]                 is_error <- inherits(cond, "error")
[10:31:23.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.590]                   NULL)
[10:31:23.590]                 if (is_error) {
[10:31:23.590]                   sessionInformation <- function() {
[10:31:23.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.590]                       search = base::search(), system = base::Sys.info())
[10:31:23.590]                   }
[10:31:23.590]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.590]                     cond$call), session = sessionInformation(), 
[10:31:23.590]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.590]                   signalCondition(cond)
[10:31:23.590]                 }
[10:31:23.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.590]                 "immediateCondition"))) {
[10:31:23.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.590]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.590]                   if (TRUE && !signal) {
[10:31:23.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.590]                     {
[10:31:23.590]                       inherits <- base::inherits
[10:31:23.590]                       invokeRestart <- base::invokeRestart
[10:31:23.590]                       is.null <- base::is.null
[10:31:23.590]                       muffled <- FALSE
[10:31:23.590]                       if (inherits(cond, "message")) {
[10:31:23.590]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.590]                         if (muffled) 
[10:31:23.590]                           invokeRestart("muffleMessage")
[10:31:23.590]                       }
[10:31:23.590]                       else if (inherits(cond, "warning")) {
[10:31:23.590]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.590]                         if (muffled) 
[10:31:23.590]                           invokeRestart("muffleWarning")
[10:31:23.590]                       }
[10:31:23.590]                       else if (inherits(cond, "condition")) {
[10:31:23.590]                         if (!is.null(pattern)) {
[10:31:23.590]                           computeRestarts <- base::computeRestarts
[10:31:23.590]                           grepl <- base::grepl
[10:31:23.590]                           restarts <- computeRestarts(cond)
[10:31:23.590]                           for (restart in restarts) {
[10:31:23.590]                             name <- restart$name
[10:31:23.590]                             if (is.null(name)) 
[10:31:23.590]                               next
[10:31:23.590]                             if (!grepl(pattern, name)) 
[10:31:23.590]                               next
[10:31:23.590]                             invokeRestart(restart)
[10:31:23.590]                             muffled <- TRUE
[10:31:23.590]                             break
[10:31:23.590]                           }
[10:31:23.590]                         }
[10:31:23.590]                       }
[10:31:23.590]                       invisible(muffled)
[10:31:23.590]                     }
[10:31:23.590]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.590]                   }
[10:31:23.590]                 }
[10:31:23.590]                 else {
[10:31:23.590]                   if (TRUE) {
[10:31:23.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.590]                     {
[10:31:23.590]                       inherits <- base::inherits
[10:31:23.590]                       invokeRestart <- base::invokeRestart
[10:31:23.590]                       is.null <- base::is.null
[10:31:23.590]                       muffled <- FALSE
[10:31:23.590]                       if (inherits(cond, "message")) {
[10:31:23.590]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.590]                         if (muffled) 
[10:31:23.590]                           invokeRestart("muffleMessage")
[10:31:23.590]                       }
[10:31:23.590]                       else if (inherits(cond, "warning")) {
[10:31:23.590]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.590]                         if (muffled) 
[10:31:23.590]                           invokeRestart("muffleWarning")
[10:31:23.590]                       }
[10:31:23.590]                       else if (inherits(cond, "condition")) {
[10:31:23.590]                         if (!is.null(pattern)) {
[10:31:23.590]                           computeRestarts <- base::computeRestarts
[10:31:23.590]                           grepl <- base::grepl
[10:31:23.590]                           restarts <- computeRestarts(cond)
[10:31:23.590]                           for (restart in restarts) {
[10:31:23.590]                             name <- restart$name
[10:31:23.590]                             if (is.null(name)) 
[10:31:23.590]                               next
[10:31:23.590]                             if (!grepl(pattern, name)) 
[10:31:23.590]                               next
[10:31:23.590]                             invokeRestart(restart)
[10:31:23.590]                             muffled <- TRUE
[10:31:23.590]                             break
[10:31:23.590]                           }
[10:31:23.590]                         }
[10:31:23.590]                       }
[10:31:23.590]                       invisible(muffled)
[10:31:23.590]                     }
[10:31:23.590]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.590]                   }
[10:31:23.590]                 }
[10:31:23.590]             }
[10:31:23.590]         }))
[10:31:23.590]     }, error = function(ex) {
[10:31:23.590]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.590]                 ...future.rng), started = ...future.startTime, 
[10:31:23.590]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.590]             version = "1.8"), class = "FutureResult")
[10:31:23.590]     }, finally = {
[10:31:23.590]         if (!identical(...future.workdir, getwd())) 
[10:31:23.590]             setwd(...future.workdir)
[10:31:23.590]         {
[10:31:23.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.590]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.590]             }
[10:31:23.590]             base::options(...future.oldOptions)
[10:31:23.590]             if (.Platform$OS.type == "windows") {
[10:31:23.590]                 old_names <- names(...future.oldEnvVars)
[10:31:23.590]                 envs <- base::Sys.getenv()
[10:31:23.590]                 names <- names(envs)
[10:31:23.590]                 common <- intersect(names, old_names)
[10:31:23.590]                 added <- setdiff(names, old_names)
[10:31:23.590]                 removed <- setdiff(old_names, names)
[10:31:23.590]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.590]                   envs[common]]
[10:31:23.590]                 NAMES <- toupper(changed)
[10:31:23.590]                 args <- list()
[10:31:23.590]                 for (kk in seq_along(NAMES)) {
[10:31:23.590]                   name <- changed[[kk]]
[10:31:23.590]                   NAME <- NAMES[[kk]]
[10:31:23.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.590]                     next
[10:31:23.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.590]                 }
[10:31:23.590]                 NAMES <- toupper(added)
[10:31:23.590]                 for (kk in seq_along(NAMES)) {
[10:31:23.590]                   name <- added[[kk]]
[10:31:23.590]                   NAME <- NAMES[[kk]]
[10:31:23.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.590]                     next
[10:31:23.590]                   args[[name]] <- ""
[10:31:23.590]                 }
[10:31:23.590]                 NAMES <- toupper(removed)
[10:31:23.590]                 for (kk in seq_along(NAMES)) {
[10:31:23.590]                   name <- removed[[kk]]
[10:31:23.590]                   NAME <- NAMES[[kk]]
[10:31:23.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.590]                     next
[10:31:23.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.590]                 }
[10:31:23.590]                 if (length(args) > 0) 
[10:31:23.590]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.590]             }
[10:31:23.590]             else {
[10:31:23.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.590]             }
[10:31:23.590]             {
[10:31:23.590]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.590]                   0L) {
[10:31:23.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.590]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.590]                   base::options(opts)
[10:31:23.590]                 }
[10:31:23.590]                 {
[10:31:23.590]                   {
[10:31:23.590]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.590]                     NULL
[10:31:23.590]                   }
[10:31:23.590]                   options(future.plan = NULL)
[10:31:23.590]                   if (is.na(NA_character_)) 
[10:31:23.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.590]                     .init = FALSE)
[10:31:23.590]                 }
[10:31:23.590]             }
[10:31:23.590]         }
[10:31:23.590]     })
[10:31:23.590]     if (TRUE) {
[10:31:23.590]         base::sink(type = "output", split = FALSE)
[10:31:23.590]         if (TRUE) {
[10:31:23.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.590]         }
[10:31:23.590]         else {
[10:31:23.590]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.590]         }
[10:31:23.590]         base::close(...future.stdout)
[10:31:23.590]         ...future.stdout <- NULL
[10:31:23.590]     }
[10:31:23.590]     ...future.result$conditions <- ...future.conditions
[10:31:23.590]     ...future.result$finished <- base::Sys.time()
[10:31:23.590]     ...future.result
[10:31:23.590] }
[10:31:23.592] assign_globals() ...
[10:31:23.592] List of 11
[10:31:23.592]  $ ...future.FUN            :function (x, ...)  
[10:31:23.592]  $ x_FUN                    :function (x, ...)  
[10:31:23.592]  $ times                    : int 5
[10:31:23.592]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.592]  $ stop_if_not              :function (...)  
[10:31:23.592]  $ dim                      : NULL
[10:31:23.592]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:23.592]  $ future.call.arguments    : list()
[10:31:23.592]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.592]  $ ...future.elements_ii    :List of 1
[10:31:23.592]   ..$ a: int [1:10] 1 2 3 4 5 6 7 8 9 10
[10:31:23.592]  $ ...future.seeds_ii       : NULL
[10:31:23.592]  $ ...future.globals.maxSize: NULL
[10:31:23.592]  - attr(*, "where")=List of 11
[10:31:23.592]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.592]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:23.592]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:23.592]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:23.592]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:23.592]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:23.592]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:23.592]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.592]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.592]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.592]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.592]  - attr(*, "resolved")= logi FALSE
[10:31:23.592]  - attr(*, "total_size")= num 95528
[10:31:23.592]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.592]  - attr(*, "already-done")= logi TRUE
[10:31:23.601] - copied ‘...future.FUN’ to environment
[10:31:23.601] - copied ‘x_FUN’ to environment
[10:31:23.601] - copied ‘times’ to environment
[10:31:23.601] - copied ‘stopf’ to environment
[10:31:23.601] - copied ‘stop_if_not’ to environment
[10:31:23.601] - copied ‘dim’ to environment
[10:31:23.602] - copied ‘valid_types’ to environment
[10:31:23.602] - copied ‘future.call.arguments’ to environment
[10:31:23.602] - copied ‘...future.elements_ii’ to environment
[10:31:23.602] - copied ‘...future.seeds_ii’ to environment
[10:31:23.602] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.602] assign_globals() ... done
[10:31:23.602] requestCore(): workers = 2
[10:31:23.604] MulticoreFuture started
[10:31:23.605] - Launch lazy future ... done
[10:31:23.605] run() for ‘MulticoreFuture’ ... done
[10:31:23.605] Created future:
[10:31:23.606] plan(): Setting new future strategy stack:
[10:31:23.607] List of future strategies:
[10:31:23.607] 1. sequential:
[10:31:23.607]    - args: function (..., envir = parent.frame())
[10:31:23.607]    - tweaked: FALSE
[10:31:23.607]    - call: NULL
[10:31:23.607] plan(): nbrOfWorkers() = 1
[10:31:23.610] plan(): Setting new future strategy stack:
[10:31:23.610] List of future strategies:
[10:31:23.610] 1. multicore:
[10:31:23.610]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.610]    - tweaked: FALSE
[10:31:23.610]    - call: plan(strategy)
[10:31:23.616] plan(): nbrOfWorkers() = 2
[10:31:23.606] MulticoreFuture:
[10:31:23.606] Label: ‘future_vapply-1’
[10:31:23.606] Expression:
[10:31:23.606] {
[10:31:23.606]     do.call(function(...) {
[10:31:23.606]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.606]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.606]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.606]             on.exit(options(oopts), add = TRUE)
[10:31:23.606]         }
[10:31:23.606]         {
[10:31:23.606]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.606]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.606]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.606]             })
[10:31:23.606]         }
[10:31:23.606]     }, args = future.call.arguments)
[10:31:23.606] }
[10:31:23.606] Lazy evaluation: FALSE
[10:31:23.606] Asynchronous evaluation: TRUE
[10:31:23.606] Local evaluation: TRUE
[10:31:23.606] Environment: R_GlobalEnv
[10:31:23.606] Capture standard output: TRUE
[10:31:23.606] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.606] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:23.606] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:31:23.606] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.606] Resolved: TRUE
[10:31:23.606] Value: <not collected>
[10:31:23.606] Conditions captured: <none>
[10:31:23.606] Early signaling: FALSE
[10:31:23.606] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.606] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.617] Chunk #1 of 2 ... DONE
[10:31:23.617] Chunk #2 of 2 ...
[10:31:23.617]  - Finding globals in 'X' for chunk #2 ...
[10:31:23.617] getGlobalsAndPackages() ...
[10:31:23.618] Searching for globals...
[10:31:23.618] 
[10:31:23.618] Searching for globals ... DONE
[10:31:23.618] - globals: [0] <none>
[10:31:23.618] getGlobalsAndPackages() ... DONE
[10:31:23.619]    + additional globals found: [n=0] 
[10:31:23.619]    + additional namespaces needed: [n=0] 
[10:31:23.619]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:23.619]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.619]  - seeds: <none>
[10:31:23.619]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.619] getGlobalsAndPackages() ...
[10:31:23.620] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.620] Resolving globals: FALSE
[10:31:23.620] Tweak future expression to call with '...' arguments ...
[10:31:23.620] {
[10:31:23.620]     do.call(function(...) {
[10:31:23.620]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.620]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.620]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.620]             on.exit(options(oopts), add = TRUE)
[10:31:23.620]         }
[10:31:23.620]         {
[10:31:23.620]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.620]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.620]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.620]             })
[10:31:23.620]         }
[10:31:23.620]     }, args = future.call.arguments)
[10:31:23.620] }
[10:31:23.621] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.622] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.622] - packages: [2] ‘stats’, ‘future.apply’
[10:31:23.622] getGlobalsAndPackages() ... DONE
[10:31:23.622] run() for ‘Future’ ...
[10:31:23.623] - state: ‘created’
[10:31:23.623] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.628] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.628] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.628]   - Field: ‘label’
[10:31:23.628]   - Field: ‘local’
[10:31:23.628]   - Field: ‘owner’
[10:31:23.628]   - Field: ‘envir’
[10:31:23.629]   - Field: ‘workers’
[10:31:23.629]   - Field: ‘packages’
[10:31:23.629]   - Field: ‘gc’
[10:31:23.629]   - Field: ‘job’
[10:31:23.629]   - Field: ‘conditions’
[10:31:23.632]   - Field: ‘expr’
[10:31:23.633]   - Field: ‘uuid’
[10:31:23.633]   - Field: ‘seed’
[10:31:23.633]   - Field: ‘version’
[10:31:23.634]   - Field: ‘result’
[10:31:23.634]   - Field: ‘asynchronous’
[10:31:23.634]   - Field: ‘calls’
[10:31:23.634]   - Field: ‘globals’
[10:31:23.635]   - Field: ‘stdout’
[10:31:23.635]   - Field: ‘earlySignal’
[10:31:23.635]   - Field: ‘lazy’
[10:31:23.635]   - Field: ‘state’
[10:31:23.636] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.636] - Launch lazy future ...
[10:31:23.637] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:31:23.637] Packages needed by future strategies (n = 0): <none>
[10:31:23.638] {
[10:31:23.638]     {
[10:31:23.638]         {
[10:31:23.638]             ...future.startTime <- base::Sys.time()
[10:31:23.638]             {
[10:31:23.638]                 {
[10:31:23.638]                   {
[10:31:23.638]                     {
[10:31:23.638]                       {
[10:31:23.638]                         base::local({
[10:31:23.638]                           has_future <- base::requireNamespace("future", 
[10:31:23.638]                             quietly = TRUE)
[10:31:23.638]                           if (has_future) {
[10:31:23.638]                             ns <- base::getNamespace("future")
[10:31:23.638]                             version <- ns[[".package"]][["version"]]
[10:31:23.638]                             if (is.null(version)) 
[10:31:23.638]                               version <- utils::packageVersion("future")
[10:31:23.638]                           }
[10:31:23.638]                           else {
[10:31:23.638]                             version <- NULL
[10:31:23.638]                           }
[10:31:23.638]                           if (!has_future || version < "1.8.0") {
[10:31:23.638]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.638]                               "", base::R.version$version.string), 
[10:31:23.638]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.638]                                 base::R.version$platform, 8 * 
[10:31:23.638]                                   base::.Machine$sizeof.pointer), 
[10:31:23.638]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.638]                                 "release", "version")], collapse = " "), 
[10:31:23.638]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.638]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.638]                               info)
[10:31:23.638]                             info <- base::paste(info, collapse = "; ")
[10:31:23.638]                             if (!has_future) {
[10:31:23.638]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.638]                                 info)
[10:31:23.638]                             }
[10:31:23.638]                             else {
[10:31:23.638]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.638]                                 info, version)
[10:31:23.638]                             }
[10:31:23.638]                             base::stop(msg)
[10:31:23.638]                           }
[10:31:23.638]                         })
[10:31:23.638]                       }
[10:31:23.638]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.638]                       base::options(mc.cores = 1L)
[10:31:23.638]                     }
[10:31:23.638]                     base::local({
[10:31:23.638]                       for (pkg in c("stats", "future.apply")) {
[10:31:23.638]                         base::loadNamespace(pkg)
[10:31:23.638]                         base::library(pkg, character.only = TRUE)
[10:31:23.638]                       }
[10:31:23.638]                     })
[10:31:23.638]                   }
[10:31:23.638]                   ...future.strategy.old <- future::plan("list")
[10:31:23.638]                   options(future.plan = NULL)
[10:31:23.638]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.638]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.638]                 }
[10:31:23.638]                 ...future.workdir <- getwd()
[10:31:23.638]             }
[10:31:23.638]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.638]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.638]         }
[10:31:23.638]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.638]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.638]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.638]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.638]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.638]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.638]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.638]             base::names(...future.oldOptions))
[10:31:23.638]     }
[10:31:23.638]     if (FALSE) {
[10:31:23.638]     }
[10:31:23.638]     else {
[10:31:23.638]         if (TRUE) {
[10:31:23.638]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.638]                 open = "w")
[10:31:23.638]         }
[10:31:23.638]         else {
[10:31:23.638]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.638]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.638]         }
[10:31:23.638]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.638]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.638]             base::sink(type = "output", split = FALSE)
[10:31:23.638]             base::close(...future.stdout)
[10:31:23.638]         }, add = TRUE)
[10:31:23.638]     }
[10:31:23.638]     ...future.frame <- base::sys.nframe()
[10:31:23.638]     ...future.conditions <- base::list()
[10:31:23.638]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.638]     if (FALSE) {
[10:31:23.638]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.638]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.638]     }
[10:31:23.638]     ...future.result <- base::tryCatch({
[10:31:23.638]         base::withCallingHandlers({
[10:31:23.638]             ...future.value <- base::withVisible(base::local({
[10:31:23.638]                 withCallingHandlers({
[10:31:23.638]                   {
[10:31:23.638]                     do.call(function(...) {
[10:31:23.638]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.638]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.638]                         ...future.globals.maxSize)) {
[10:31:23.638]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.638]                         on.exit(options(oopts), add = TRUE)
[10:31:23.638]                       }
[10:31:23.638]                       {
[10:31:23.638]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.638]                           FUN = function(jj) {
[10:31:23.638]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.638]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.638]                           })
[10:31:23.638]                       }
[10:31:23.638]                     }, args = future.call.arguments)
[10:31:23.638]                   }
[10:31:23.638]                 }, immediateCondition = function(cond) {
[10:31:23.638]                   save_rds <- function (object, pathname, ...) 
[10:31:23.638]                   {
[10:31:23.638]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.638]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.638]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.638]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.638]                         fi_tmp[["mtime"]])
[10:31:23.638]                     }
[10:31:23.638]                     tryCatch({
[10:31:23.638]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.638]                     }, error = function(ex) {
[10:31:23.638]                       msg <- conditionMessage(ex)
[10:31:23.638]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.638]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.638]                         fi_tmp[["mtime"]], msg)
[10:31:23.638]                       ex$message <- msg
[10:31:23.638]                       stop(ex)
[10:31:23.638]                     })
[10:31:23.638]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.638]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.638]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.638]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.638]                       fi <- file.info(pathname)
[10:31:23.638]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.638]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.638]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.638]                         fi[["size"]], fi[["mtime"]])
[10:31:23.638]                       stop(msg)
[10:31:23.638]                     }
[10:31:23.638]                     invisible(pathname)
[10:31:23.638]                   }
[10:31:23.638]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.638]                     rootPath = tempdir()) 
[10:31:23.638]                   {
[10:31:23.638]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.638]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.638]                       tmpdir = path, fileext = ".rds")
[10:31:23.638]                     save_rds(obj, file)
[10:31:23.638]                   }
[10:31:23.638]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.638]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.638]                   {
[10:31:23.638]                     inherits <- base::inherits
[10:31:23.638]                     invokeRestart <- base::invokeRestart
[10:31:23.638]                     is.null <- base::is.null
[10:31:23.638]                     muffled <- FALSE
[10:31:23.638]                     if (inherits(cond, "message")) {
[10:31:23.638]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.638]                       if (muffled) 
[10:31:23.638]                         invokeRestart("muffleMessage")
[10:31:23.638]                     }
[10:31:23.638]                     else if (inherits(cond, "warning")) {
[10:31:23.638]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.638]                       if (muffled) 
[10:31:23.638]                         invokeRestart("muffleWarning")
[10:31:23.638]                     }
[10:31:23.638]                     else if (inherits(cond, "condition")) {
[10:31:23.638]                       if (!is.null(pattern)) {
[10:31:23.638]                         computeRestarts <- base::computeRestarts
[10:31:23.638]                         grepl <- base::grepl
[10:31:23.638]                         restarts <- computeRestarts(cond)
[10:31:23.638]                         for (restart in restarts) {
[10:31:23.638]                           name <- restart$name
[10:31:23.638]                           if (is.null(name)) 
[10:31:23.638]                             next
[10:31:23.638]                           if (!grepl(pattern, name)) 
[10:31:23.638]                             next
[10:31:23.638]                           invokeRestart(restart)
[10:31:23.638]                           muffled <- TRUE
[10:31:23.638]                           break
[10:31:23.638]                         }
[10:31:23.638]                       }
[10:31:23.638]                     }
[10:31:23.638]                     invisible(muffled)
[10:31:23.638]                   }
[10:31:23.638]                   muffleCondition(cond)
[10:31:23.638]                 })
[10:31:23.638]             }))
[10:31:23.638]             future::FutureResult(value = ...future.value$value, 
[10:31:23.638]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.638]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.638]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.638]                     ...future.globalenv.names))
[10:31:23.638]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.638]         }, condition = base::local({
[10:31:23.638]             c <- base::c
[10:31:23.638]             inherits <- base::inherits
[10:31:23.638]             invokeRestart <- base::invokeRestart
[10:31:23.638]             length <- base::length
[10:31:23.638]             list <- base::list
[10:31:23.638]             seq.int <- base::seq.int
[10:31:23.638]             signalCondition <- base::signalCondition
[10:31:23.638]             sys.calls <- base::sys.calls
[10:31:23.638]             `[[` <- base::`[[`
[10:31:23.638]             `+` <- base::`+`
[10:31:23.638]             `<<-` <- base::`<<-`
[10:31:23.638]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.638]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.638]                   3L)]
[10:31:23.638]             }
[10:31:23.638]             function(cond) {
[10:31:23.638]                 is_error <- inherits(cond, "error")
[10:31:23.638]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.638]                   NULL)
[10:31:23.638]                 if (is_error) {
[10:31:23.638]                   sessionInformation <- function() {
[10:31:23.638]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.638]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.638]                       search = base::search(), system = base::Sys.info())
[10:31:23.638]                   }
[10:31:23.638]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.638]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.638]                     cond$call), session = sessionInformation(), 
[10:31:23.638]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.638]                   signalCondition(cond)
[10:31:23.638]                 }
[10:31:23.638]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.638]                 "immediateCondition"))) {
[10:31:23.638]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.638]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.638]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.638]                   if (TRUE && !signal) {
[10:31:23.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.638]                     {
[10:31:23.638]                       inherits <- base::inherits
[10:31:23.638]                       invokeRestart <- base::invokeRestart
[10:31:23.638]                       is.null <- base::is.null
[10:31:23.638]                       muffled <- FALSE
[10:31:23.638]                       if (inherits(cond, "message")) {
[10:31:23.638]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.638]                         if (muffled) 
[10:31:23.638]                           invokeRestart("muffleMessage")
[10:31:23.638]                       }
[10:31:23.638]                       else if (inherits(cond, "warning")) {
[10:31:23.638]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.638]                         if (muffled) 
[10:31:23.638]                           invokeRestart("muffleWarning")
[10:31:23.638]                       }
[10:31:23.638]                       else if (inherits(cond, "condition")) {
[10:31:23.638]                         if (!is.null(pattern)) {
[10:31:23.638]                           computeRestarts <- base::computeRestarts
[10:31:23.638]                           grepl <- base::grepl
[10:31:23.638]                           restarts <- computeRestarts(cond)
[10:31:23.638]                           for (restart in restarts) {
[10:31:23.638]                             name <- restart$name
[10:31:23.638]                             if (is.null(name)) 
[10:31:23.638]                               next
[10:31:23.638]                             if (!grepl(pattern, name)) 
[10:31:23.638]                               next
[10:31:23.638]                             invokeRestart(restart)
[10:31:23.638]                             muffled <- TRUE
[10:31:23.638]                             break
[10:31:23.638]                           }
[10:31:23.638]                         }
[10:31:23.638]                       }
[10:31:23.638]                       invisible(muffled)
[10:31:23.638]                     }
[10:31:23.638]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.638]                   }
[10:31:23.638]                 }
[10:31:23.638]                 else {
[10:31:23.638]                   if (TRUE) {
[10:31:23.638]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.638]                     {
[10:31:23.638]                       inherits <- base::inherits
[10:31:23.638]                       invokeRestart <- base::invokeRestart
[10:31:23.638]                       is.null <- base::is.null
[10:31:23.638]                       muffled <- FALSE
[10:31:23.638]                       if (inherits(cond, "message")) {
[10:31:23.638]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.638]                         if (muffled) 
[10:31:23.638]                           invokeRestart("muffleMessage")
[10:31:23.638]                       }
[10:31:23.638]                       else if (inherits(cond, "warning")) {
[10:31:23.638]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.638]                         if (muffled) 
[10:31:23.638]                           invokeRestart("muffleWarning")
[10:31:23.638]                       }
[10:31:23.638]                       else if (inherits(cond, "condition")) {
[10:31:23.638]                         if (!is.null(pattern)) {
[10:31:23.638]                           computeRestarts <- base::computeRestarts
[10:31:23.638]                           grepl <- base::grepl
[10:31:23.638]                           restarts <- computeRestarts(cond)
[10:31:23.638]                           for (restart in restarts) {
[10:31:23.638]                             name <- restart$name
[10:31:23.638]                             if (is.null(name)) 
[10:31:23.638]                               next
[10:31:23.638]                             if (!grepl(pattern, name)) 
[10:31:23.638]                               next
[10:31:23.638]                             invokeRestart(restart)
[10:31:23.638]                             muffled <- TRUE
[10:31:23.638]                             break
[10:31:23.638]                           }
[10:31:23.638]                         }
[10:31:23.638]                       }
[10:31:23.638]                       invisible(muffled)
[10:31:23.638]                     }
[10:31:23.638]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.638]                   }
[10:31:23.638]                 }
[10:31:23.638]             }
[10:31:23.638]         }))
[10:31:23.638]     }, error = function(ex) {
[10:31:23.638]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.638]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.638]                 ...future.rng), started = ...future.startTime, 
[10:31:23.638]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.638]             version = "1.8"), class = "FutureResult")
[10:31:23.638]     }, finally = {
[10:31:23.638]         if (!identical(...future.workdir, getwd())) 
[10:31:23.638]             setwd(...future.workdir)
[10:31:23.638]         {
[10:31:23.638]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.638]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.638]             }
[10:31:23.638]             base::options(...future.oldOptions)
[10:31:23.638]             if (.Platform$OS.type == "windows") {
[10:31:23.638]                 old_names <- names(...future.oldEnvVars)
[10:31:23.638]                 envs <- base::Sys.getenv()
[10:31:23.638]                 names <- names(envs)
[10:31:23.638]                 common <- intersect(names, old_names)
[10:31:23.638]                 added <- setdiff(names, old_names)
[10:31:23.638]                 removed <- setdiff(old_names, names)
[10:31:23.638]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.638]                   envs[common]]
[10:31:23.638]                 NAMES <- toupper(changed)
[10:31:23.638]                 args <- list()
[10:31:23.638]                 for (kk in seq_along(NAMES)) {
[10:31:23.638]                   name <- changed[[kk]]
[10:31:23.638]                   NAME <- NAMES[[kk]]
[10:31:23.638]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.638]                     next
[10:31:23.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.638]                 }
[10:31:23.638]                 NAMES <- toupper(added)
[10:31:23.638]                 for (kk in seq_along(NAMES)) {
[10:31:23.638]                   name <- added[[kk]]
[10:31:23.638]                   NAME <- NAMES[[kk]]
[10:31:23.638]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.638]                     next
[10:31:23.638]                   args[[name]] <- ""
[10:31:23.638]                 }
[10:31:23.638]                 NAMES <- toupper(removed)
[10:31:23.638]                 for (kk in seq_along(NAMES)) {
[10:31:23.638]                   name <- removed[[kk]]
[10:31:23.638]                   NAME <- NAMES[[kk]]
[10:31:23.638]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.638]                     next
[10:31:23.638]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.638]                 }
[10:31:23.638]                 if (length(args) > 0) 
[10:31:23.638]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.638]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.638]             }
[10:31:23.638]             else {
[10:31:23.638]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.638]             }
[10:31:23.638]             {
[10:31:23.638]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.638]                   0L) {
[10:31:23.638]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.638]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.638]                   base::options(opts)
[10:31:23.638]                 }
[10:31:23.638]                 {
[10:31:23.638]                   {
[10:31:23.638]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.638]                     NULL
[10:31:23.638]                   }
[10:31:23.638]                   options(future.plan = NULL)
[10:31:23.638]                   if (is.na(NA_character_)) 
[10:31:23.638]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.638]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.638]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.638]                     .init = FALSE)
[10:31:23.638]                 }
[10:31:23.638]             }
[10:31:23.638]         }
[10:31:23.638]     })
[10:31:23.638]     if (TRUE) {
[10:31:23.638]         base::sink(type = "output", split = FALSE)
[10:31:23.638]         if (TRUE) {
[10:31:23.638]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.638]         }
[10:31:23.638]         else {
[10:31:23.638]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.638]         }
[10:31:23.638]         base::close(...future.stdout)
[10:31:23.638]         ...future.stdout <- NULL
[10:31:23.638]     }
[10:31:23.638]     ...future.result$conditions <- ...future.conditions
[10:31:23.638]     ...future.result$finished <- base::Sys.time()
[10:31:23.638]     ...future.result
[10:31:23.638] }
[10:31:23.641] assign_globals() ...
[10:31:23.642] List of 11
[10:31:23.642]  $ ...future.FUN            :function (x, ...)  
[10:31:23.642]  $ x_FUN                    :function (x, ...)  
[10:31:23.642]  $ times                    : int 5
[10:31:23.642]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.642]  $ stop_if_not              :function (...)  
[10:31:23.642]  $ dim                      : NULL
[10:31:23.642]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:23.642]  $ future.call.arguments    : list()
[10:31:23.642]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.642]  $ ...future.elements_ii    :List of 2
[10:31:23.642]   ..$ beta : num [1:7] 0.0498 0.1353 0.3679 1 2.7183 ...
[10:31:23.642]   ..$ logic: logi [1:4] TRUE FALSE FALSE TRUE
[10:31:23.642]  $ ...future.seeds_ii       : NULL
[10:31:23.642]  $ ...future.globals.maxSize: NULL
[10:31:23.642]  - attr(*, "where")=List of 11
[10:31:23.642]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.642]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:23.642]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:23.642]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:23.642]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:23.642]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:23.642]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:23.642]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.642]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.642]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.642]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.642]  - attr(*, "resolved")= logi FALSE
[10:31:23.642]  - attr(*, "total_size")= num 95528
[10:31:23.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.642]  - attr(*, "already-done")= logi TRUE
[10:31:23.654] - copied ‘...future.FUN’ to environment
[10:31:23.654] - copied ‘x_FUN’ to environment
[10:31:23.655] - copied ‘times’ to environment
[10:31:23.655] - copied ‘stopf’ to environment
[10:31:23.655] - copied ‘stop_if_not’ to environment
[10:31:23.655] - copied ‘dim’ to environment
[10:31:23.655] - copied ‘valid_types’ to environment
[10:31:23.655] - copied ‘future.call.arguments’ to environment
[10:31:23.655] - copied ‘...future.elements_ii’ to environment
[10:31:23.655] - copied ‘...future.seeds_ii’ to environment
[10:31:23.655] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.655] assign_globals() ... done
[10:31:23.656] requestCore(): workers = 2
[10:31:23.658] MulticoreFuture started
[10:31:23.658] - Launch lazy future ... done
[10:31:23.659] run() for ‘MulticoreFuture’ ... done
[10:31:23.659] Created future:
[10:31:23.660] plan(): Setting new future strategy stack:
[10:31:23.660] List of future strategies:
[10:31:23.660] 1. sequential:
[10:31:23.660]    - args: function (..., envir = parent.frame())
[10:31:23.660]    - tweaked: FALSE
[10:31:23.660]    - call: NULL
[10:31:23.661] plan(): nbrOfWorkers() = 1
[10:31:23.664] plan(): Setting new future strategy stack:
[10:31:23.664] List of future strategies:
[10:31:23.664] 1. multicore:
[10:31:23.664]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.664]    - tweaked: FALSE
[10:31:23.664]    - call: plan(strategy)
[10:31:23.669] plan(): nbrOfWorkers() = 2
[10:31:23.659] MulticoreFuture:
[10:31:23.659] Label: ‘future_vapply-2’
[10:31:23.659] Expression:
[10:31:23.659] {
[10:31:23.659]     do.call(function(...) {
[10:31:23.659]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.659]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.659]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.659]             on.exit(options(oopts), add = TRUE)
[10:31:23.659]         }
[10:31:23.659]         {
[10:31:23.659]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.659]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.659]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.659]             })
[10:31:23.659]         }
[10:31:23.659]     }, args = future.call.arguments)
[10:31:23.659] }
[10:31:23.659] Lazy evaluation: FALSE
[10:31:23.659] Asynchronous evaluation: TRUE
[10:31:23.659] Local evaluation: TRUE
[10:31:23.659] Environment: R_GlobalEnv
[10:31:23.659] Capture standard output: TRUE
[10:31:23.659] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.659] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:23.659] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:31:23.659] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.659] Resolved: TRUE
[10:31:23.659] Value: <not collected>
[10:31:23.659] Conditions captured: <none>
[10:31:23.659] Early signaling: FALSE
[10:31:23.659] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.659] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.670] Chunk #2 of 2 ... DONE
[10:31:23.671] Launching 2 futures (chunks) ... DONE
[10:31:23.671] Resolving 2 futures (chunks) ...
[10:31:23.671] resolve() on list ...
[10:31:23.671]  recursive: 0
[10:31:23.671]  length: 2
[10:31:23.671] 
[10:31:23.672] Future #1
[10:31:23.672] result() for MulticoreFuture ...
[10:31:23.673] result() for MulticoreFuture ...
[10:31:23.673] result() for MulticoreFuture ... done
[10:31:23.673] result() for MulticoreFuture ... done
[10:31:23.673] result() for MulticoreFuture ...
[10:31:23.673] result() for MulticoreFuture ... done
[10:31:23.673] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:23.674] - nx: 2
[10:31:23.674] - relay: TRUE
[10:31:23.674] - stdout: TRUE
[10:31:23.674] - signal: TRUE
[10:31:23.674] - resignal: FALSE
[10:31:23.674] - force: TRUE
[10:31:23.674] - relayed: [n=2] FALSE, FALSE
[10:31:23.674] - queued futures: [n=2] FALSE, FALSE
[10:31:23.675]  - until=1
[10:31:23.675]  - relaying element #1
[10:31:23.675] result() for MulticoreFuture ...
[10:31:23.675] result() for MulticoreFuture ... done
[10:31:23.675] result() for MulticoreFuture ...
[10:31:23.675] result() for MulticoreFuture ... done
[10:31:23.676] result() for MulticoreFuture ...
[10:31:23.676] result() for MulticoreFuture ... done
[10:31:23.676] result() for MulticoreFuture ...
[10:31:23.676] result() for MulticoreFuture ... done
[10:31:23.676] - relayed: [n=2] TRUE, FALSE
[10:31:23.676] - queued futures: [n=2] TRUE, FALSE
[10:31:23.676] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:23.680]  length: 1 (resolved future 1)
[10:31:23.681] Future #2
[10:31:23.681] result() for MulticoreFuture ...
[10:31:23.682] result() for MulticoreFuture ...
[10:31:23.683] result() for MulticoreFuture ... done
[10:31:23.683] result() for MulticoreFuture ... done
[10:31:23.684] result() for MulticoreFuture ...
[10:31:23.684] result() for MulticoreFuture ... done
[10:31:23.684] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:23.684] - nx: 2
[10:31:23.685] - relay: TRUE
[10:31:23.685] - stdout: TRUE
[10:31:23.685] - signal: TRUE
[10:31:23.685] - resignal: FALSE
[10:31:23.685] - force: TRUE
[10:31:23.686] - relayed: [n=2] TRUE, FALSE
[10:31:23.686] - queued futures: [n=2] TRUE, FALSE
[10:31:23.686]  - until=2
[10:31:23.686]  - relaying element #2
[10:31:23.686] result() for MulticoreFuture ...
[10:31:23.686] result() for MulticoreFuture ... done
[10:31:23.687] result() for MulticoreFuture ...
[10:31:23.687] result() for MulticoreFuture ... done
[10:31:23.687] result() for MulticoreFuture ...
[10:31:23.687] result() for MulticoreFuture ... done
[10:31:23.687] result() for MulticoreFuture ...
[10:31:23.687] result() for MulticoreFuture ... done
[10:31:23.688] - relayed: [n=2] TRUE, TRUE
[10:31:23.688] - queued futures: [n=2] TRUE, TRUE
[10:31:23.688] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:23.688]  length: 0 (resolved future 2)
[10:31:23.688] Relaying remaining futures
[10:31:23.688] signalConditionsASAP(NULL, pos=0) ...
[10:31:23.688] - nx: 2
[10:31:23.689] - relay: TRUE
[10:31:23.689] - stdout: TRUE
[10:31:23.689] - signal: TRUE
[10:31:23.689] - resignal: FALSE
[10:31:23.689] - force: TRUE
[10:31:23.689] - relayed: [n=2] TRUE, TRUE
[10:31:23.689] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:23.690] - relayed: [n=2] TRUE, TRUE
[10:31:23.690] - queued futures: [n=2] TRUE, TRUE
[10:31:23.690] signalConditionsASAP(NULL, pos=0) ... done
[10:31:23.690] resolve() on list ... DONE
[10:31:23.690] result() for MulticoreFuture ...
[10:31:23.690] result() for MulticoreFuture ... done
[10:31:23.690] result() for MulticoreFuture ...
[10:31:23.691] result() for MulticoreFuture ... done
[10:31:23.691] result() for MulticoreFuture ...
[10:31:23.691] result() for MulticoreFuture ... done
[10:31:23.691] result() for MulticoreFuture ...
[10:31:23.691] result() for MulticoreFuture ... done
[10:31:23.691]  - Number of value chunks collected: 2
[10:31:23.691] Resolving 2 futures (chunks) ... DONE
[10:31:23.691] Reducing values from 2 chunks ...
[10:31:23.692]  - Number of values collected after concatenation: 3
[10:31:23.692]  - Number of values expected: 3
[10:31:23.692] Reducing values from 2 chunks ... DONE
[10:31:23.692] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[10:31:23.694] future_lapply() ...
[10:31:23.703] Number of chunks: 2
[10:31:23.703] getGlobalsAndPackagesXApply() ...
[10:31:23.703]  - future.globals: TRUE
[10:31:23.703] getGlobalsAndPackages() ...
[10:31:23.703] Searching for globals...
[10:31:23.711] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:31:23.711] Searching for globals ... DONE
[10:31:23.711] Resolving globals: FALSE
[10:31:23.712] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[10:31:23.713] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[10:31:23.713] - globals: [1] ‘FUN’
[10:31:23.713] - packages: [1] ‘stats’
[10:31:23.713] getGlobalsAndPackages() ... DONE
[10:31:23.713]  - globals found/used: [n=1] ‘FUN’
[10:31:23.713]  - needed namespaces: [n=1] ‘stats’
[10:31:23.714] Finding globals ... DONE
[10:31:23.714]  - use_args: TRUE
[10:31:23.714]  - Getting '...' globals ...
[10:31:23.714] resolve() on list ...
[10:31:23.714]  recursive: 0
[10:31:23.714]  length: 1
[10:31:23.715]  elements: ‘...’
[10:31:23.715]  length: 0 (resolved future 1)
[10:31:23.715] resolve() on list ... DONE
[10:31:23.715]    - '...' content: [n=0] 
[10:31:23.715] List of 1
[10:31:23.715]  $ ...: list()
[10:31:23.715]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.715]  - attr(*, "where")=List of 1
[10:31:23.715]   ..$ ...:<environment: 0x55de840e34d8> 
[10:31:23.715]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.715]  - attr(*, "resolved")= logi TRUE
[10:31:23.715]  - attr(*, "total_size")= num NA
[10:31:23.718]  - Getting '...' globals ... DONE
[10:31:23.718] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:23.718] List of 2
[10:31:23.718]  $ ...future.FUN:function (x, na.rm = TRUE)  
[10:31:23.718]  $ ...          : list()
[10:31:23.718]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.718]  - attr(*, "where")=List of 2
[10:31:23.718]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:23.718]   ..$ ...          :<environment: 0x55de840e34d8> 
[10:31:23.718]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.718]  - attr(*, "resolved")= logi FALSE
[10:31:23.718]  - attr(*, "total_size")= num 46960
[10:31:23.721] Packages to be attached in all futures: [n=1] ‘stats’
[10:31:23.721] getGlobalsAndPackagesXApply() ... DONE
[10:31:23.721] Number of futures (= number of chunks): 2
[10:31:23.721] Launching 2 futures (chunks) ...
[10:31:23.721] Chunk #1 of 2 ...
[10:31:23.721]  - Finding globals in 'X' for chunk #1 ...
[10:31:23.722] getGlobalsAndPackages() ...
[10:31:23.722] Searching for globals...
[10:31:23.722] 
[10:31:23.722] Searching for globals ... DONE
[10:31:23.722] - globals: [0] <none>
[10:31:23.722] getGlobalsAndPackages() ... DONE
[10:31:23.722]    + additional globals found: [n=0] 
[10:31:23.722]    + additional namespaces needed: [n=0] 
[10:31:23.723]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:23.723]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.723]  - seeds: <none>
[10:31:23.723]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.723] getGlobalsAndPackages() ...
[10:31:23.723] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.723] Resolving globals: FALSE
[10:31:23.723] Tweak future expression to call with '...' arguments ...
[10:31:23.723] {
[10:31:23.723]     do.call(function(...) {
[10:31:23.723]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.723]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.723]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.723]             on.exit(options(oopts), add = TRUE)
[10:31:23.723]         }
[10:31:23.723]         {
[10:31:23.723]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.723]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.723]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.723]             })
[10:31:23.723]         }
[10:31:23.723]     }, args = future.call.arguments)
[10:31:23.723] }
[10:31:23.724] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.724] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.724] - packages: [1] ‘stats’
[10:31:23.724] getGlobalsAndPackages() ... DONE
[10:31:23.725] run() for ‘Future’ ...
[10:31:23.725] - state: ‘created’
[10:31:23.725] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.729] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.729] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.729]   - Field: ‘label’
[10:31:23.729]   - Field: ‘local’
[10:31:23.729]   - Field: ‘owner’
[10:31:23.729]   - Field: ‘envir’
[10:31:23.729]   - Field: ‘workers’
[10:31:23.730]   - Field: ‘packages’
[10:31:23.730]   - Field: ‘gc’
[10:31:23.730]   - Field: ‘job’
[10:31:23.730]   - Field: ‘conditions’
[10:31:23.730]   - Field: ‘expr’
[10:31:23.730]   - Field: ‘uuid’
[10:31:23.730]   - Field: ‘seed’
[10:31:23.730]   - Field: ‘version’
[10:31:23.730]   - Field: ‘result’
[10:31:23.730]   - Field: ‘asynchronous’
[10:31:23.730]   - Field: ‘calls’
[10:31:23.731]   - Field: ‘globals’
[10:31:23.731]   - Field: ‘stdout’
[10:31:23.733]   - Field: ‘earlySignal’
[10:31:23.733]   - Field: ‘lazy’
[10:31:23.733]   - Field: ‘state’
[10:31:23.734] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.734] - Launch lazy future ...
[10:31:23.734] Packages needed by the future expression (n = 1): ‘stats’
[10:31:23.734] Packages needed by future strategies (n = 0): <none>
[10:31:23.735] {
[10:31:23.735]     {
[10:31:23.735]         {
[10:31:23.735]             ...future.startTime <- base::Sys.time()
[10:31:23.735]             {
[10:31:23.735]                 {
[10:31:23.735]                   {
[10:31:23.735]                     {
[10:31:23.735]                       {
[10:31:23.735]                         base::local({
[10:31:23.735]                           has_future <- base::requireNamespace("future", 
[10:31:23.735]                             quietly = TRUE)
[10:31:23.735]                           if (has_future) {
[10:31:23.735]                             ns <- base::getNamespace("future")
[10:31:23.735]                             version <- ns[[".package"]][["version"]]
[10:31:23.735]                             if (is.null(version)) 
[10:31:23.735]                               version <- utils::packageVersion("future")
[10:31:23.735]                           }
[10:31:23.735]                           else {
[10:31:23.735]                             version <- NULL
[10:31:23.735]                           }
[10:31:23.735]                           if (!has_future || version < "1.8.0") {
[10:31:23.735]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.735]                               "", base::R.version$version.string), 
[10:31:23.735]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.735]                                 base::R.version$platform, 8 * 
[10:31:23.735]                                   base::.Machine$sizeof.pointer), 
[10:31:23.735]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.735]                                 "release", "version")], collapse = " "), 
[10:31:23.735]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.735]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.735]                               info)
[10:31:23.735]                             info <- base::paste(info, collapse = "; ")
[10:31:23.735]                             if (!has_future) {
[10:31:23.735]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.735]                                 info)
[10:31:23.735]                             }
[10:31:23.735]                             else {
[10:31:23.735]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.735]                                 info, version)
[10:31:23.735]                             }
[10:31:23.735]                             base::stop(msg)
[10:31:23.735]                           }
[10:31:23.735]                         })
[10:31:23.735]                       }
[10:31:23.735]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.735]                       base::options(mc.cores = 1L)
[10:31:23.735]                     }
[10:31:23.735]                     base::local({
[10:31:23.735]                       for (pkg in "stats") {
[10:31:23.735]                         base::loadNamespace(pkg)
[10:31:23.735]                         base::library(pkg, character.only = TRUE)
[10:31:23.735]                       }
[10:31:23.735]                     })
[10:31:23.735]                   }
[10:31:23.735]                   ...future.strategy.old <- future::plan("list")
[10:31:23.735]                   options(future.plan = NULL)
[10:31:23.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.735]                 }
[10:31:23.735]                 ...future.workdir <- getwd()
[10:31:23.735]             }
[10:31:23.735]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.735]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.735]         }
[10:31:23.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.735]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.735]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.735]             base::names(...future.oldOptions))
[10:31:23.735]     }
[10:31:23.735]     if (FALSE) {
[10:31:23.735]     }
[10:31:23.735]     else {
[10:31:23.735]         if (TRUE) {
[10:31:23.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.735]                 open = "w")
[10:31:23.735]         }
[10:31:23.735]         else {
[10:31:23.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.735]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.735]         }
[10:31:23.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.735]             base::sink(type = "output", split = FALSE)
[10:31:23.735]             base::close(...future.stdout)
[10:31:23.735]         }, add = TRUE)
[10:31:23.735]     }
[10:31:23.735]     ...future.frame <- base::sys.nframe()
[10:31:23.735]     ...future.conditions <- base::list()
[10:31:23.735]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.735]     if (FALSE) {
[10:31:23.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.735]     }
[10:31:23.735]     ...future.result <- base::tryCatch({
[10:31:23.735]         base::withCallingHandlers({
[10:31:23.735]             ...future.value <- base::withVisible(base::local({
[10:31:23.735]                 withCallingHandlers({
[10:31:23.735]                   {
[10:31:23.735]                     do.call(function(...) {
[10:31:23.735]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.735]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.735]                         ...future.globals.maxSize)) {
[10:31:23.735]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.735]                         on.exit(options(oopts), add = TRUE)
[10:31:23.735]                       }
[10:31:23.735]                       {
[10:31:23.735]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.735]                           FUN = function(jj) {
[10:31:23.735]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.735]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.735]                           })
[10:31:23.735]                       }
[10:31:23.735]                     }, args = future.call.arguments)
[10:31:23.735]                   }
[10:31:23.735]                 }, immediateCondition = function(cond) {
[10:31:23.735]                   save_rds <- function (object, pathname, ...) 
[10:31:23.735]                   {
[10:31:23.735]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.735]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.735]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.735]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.735]                         fi_tmp[["mtime"]])
[10:31:23.735]                     }
[10:31:23.735]                     tryCatch({
[10:31:23.735]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.735]                     }, error = function(ex) {
[10:31:23.735]                       msg <- conditionMessage(ex)
[10:31:23.735]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.735]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.735]                         fi_tmp[["mtime"]], msg)
[10:31:23.735]                       ex$message <- msg
[10:31:23.735]                       stop(ex)
[10:31:23.735]                     })
[10:31:23.735]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.735]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.735]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.735]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.735]                       fi <- file.info(pathname)
[10:31:23.735]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.735]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.735]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.735]                         fi[["size"]], fi[["mtime"]])
[10:31:23.735]                       stop(msg)
[10:31:23.735]                     }
[10:31:23.735]                     invisible(pathname)
[10:31:23.735]                   }
[10:31:23.735]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.735]                     rootPath = tempdir()) 
[10:31:23.735]                   {
[10:31:23.735]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.735]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.735]                       tmpdir = path, fileext = ".rds")
[10:31:23.735]                     save_rds(obj, file)
[10:31:23.735]                   }
[10:31:23.735]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.735]                   {
[10:31:23.735]                     inherits <- base::inherits
[10:31:23.735]                     invokeRestart <- base::invokeRestart
[10:31:23.735]                     is.null <- base::is.null
[10:31:23.735]                     muffled <- FALSE
[10:31:23.735]                     if (inherits(cond, "message")) {
[10:31:23.735]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.735]                       if (muffled) 
[10:31:23.735]                         invokeRestart("muffleMessage")
[10:31:23.735]                     }
[10:31:23.735]                     else if (inherits(cond, "warning")) {
[10:31:23.735]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.735]                       if (muffled) 
[10:31:23.735]                         invokeRestart("muffleWarning")
[10:31:23.735]                     }
[10:31:23.735]                     else if (inherits(cond, "condition")) {
[10:31:23.735]                       if (!is.null(pattern)) {
[10:31:23.735]                         computeRestarts <- base::computeRestarts
[10:31:23.735]                         grepl <- base::grepl
[10:31:23.735]                         restarts <- computeRestarts(cond)
[10:31:23.735]                         for (restart in restarts) {
[10:31:23.735]                           name <- restart$name
[10:31:23.735]                           if (is.null(name)) 
[10:31:23.735]                             next
[10:31:23.735]                           if (!grepl(pattern, name)) 
[10:31:23.735]                             next
[10:31:23.735]                           invokeRestart(restart)
[10:31:23.735]                           muffled <- TRUE
[10:31:23.735]                           break
[10:31:23.735]                         }
[10:31:23.735]                       }
[10:31:23.735]                     }
[10:31:23.735]                     invisible(muffled)
[10:31:23.735]                   }
[10:31:23.735]                   muffleCondition(cond)
[10:31:23.735]                 })
[10:31:23.735]             }))
[10:31:23.735]             future::FutureResult(value = ...future.value$value, 
[10:31:23.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.735]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.735]                     ...future.globalenv.names))
[10:31:23.735]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.735]         }, condition = base::local({
[10:31:23.735]             c <- base::c
[10:31:23.735]             inherits <- base::inherits
[10:31:23.735]             invokeRestart <- base::invokeRestart
[10:31:23.735]             length <- base::length
[10:31:23.735]             list <- base::list
[10:31:23.735]             seq.int <- base::seq.int
[10:31:23.735]             signalCondition <- base::signalCondition
[10:31:23.735]             sys.calls <- base::sys.calls
[10:31:23.735]             `[[` <- base::`[[`
[10:31:23.735]             `+` <- base::`+`
[10:31:23.735]             `<<-` <- base::`<<-`
[10:31:23.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.735]                   3L)]
[10:31:23.735]             }
[10:31:23.735]             function(cond) {
[10:31:23.735]                 is_error <- inherits(cond, "error")
[10:31:23.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.735]                   NULL)
[10:31:23.735]                 if (is_error) {
[10:31:23.735]                   sessionInformation <- function() {
[10:31:23.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.735]                       search = base::search(), system = base::Sys.info())
[10:31:23.735]                   }
[10:31:23.735]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.735]                     cond$call), session = sessionInformation(), 
[10:31:23.735]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.735]                   signalCondition(cond)
[10:31:23.735]                 }
[10:31:23.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.735]                 "immediateCondition"))) {
[10:31:23.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.735]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.735]                   if (TRUE && !signal) {
[10:31:23.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.735]                     {
[10:31:23.735]                       inherits <- base::inherits
[10:31:23.735]                       invokeRestart <- base::invokeRestart
[10:31:23.735]                       is.null <- base::is.null
[10:31:23.735]                       muffled <- FALSE
[10:31:23.735]                       if (inherits(cond, "message")) {
[10:31:23.735]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.735]                         if (muffled) 
[10:31:23.735]                           invokeRestart("muffleMessage")
[10:31:23.735]                       }
[10:31:23.735]                       else if (inherits(cond, "warning")) {
[10:31:23.735]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.735]                         if (muffled) 
[10:31:23.735]                           invokeRestart("muffleWarning")
[10:31:23.735]                       }
[10:31:23.735]                       else if (inherits(cond, "condition")) {
[10:31:23.735]                         if (!is.null(pattern)) {
[10:31:23.735]                           computeRestarts <- base::computeRestarts
[10:31:23.735]                           grepl <- base::grepl
[10:31:23.735]                           restarts <- computeRestarts(cond)
[10:31:23.735]                           for (restart in restarts) {
[10:31:23.735]                             name <- restart$name
[10:31:23.735]                             if (is.null(name)) 
[10:31:23.735]                               next
[10:31:23.735]                             if (!grepl(pattern, name)) 
[10:31:23.735]                               next
[10:31:23.735]                             invokeRestart(restart)
[10:31:23.735]                             muffled <- TRUE
[10:31:23.735]                             break
[10:31:23.735]                           }
[10:31:23.735]                         }
[10:31:23.735]                       }
[10:31:23.735]                       invisible(muffled)
[10:31:23.735]                     }
[10:31:23.735]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.735]                   }
[10:31:23.735]                 }
[10:31:23.735]                 else {
[10:31:23.735]                   if (TRUE) {
[10:31:23.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.735]                     {
[10:31:23.735]                       inherits <- base::inherits
[10:31:23.735]                       invokeRestart <- base::invokeRestart
[10:31:23.735]                       is.null <- base::is.null
[10:31:23.735]                       muffled <- FALSE
[10:31:23.735]                       if (inherits(cond, "message")) {
[10:31:23.735]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.735]                         if (muffled) 
[10:31:23.735]                           invokeRestart("muffleMessage")
[10:31:23.735]                       }
[10:31:23.735]                       else if (inherits(cond, "warning")) {
[10:31:23.735]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.735]                         if (muffled) 
[10:31:23.735]                           invokeRestart("muffleWarning")
[10:31:23.735]                       }
[10:31:23.735]                       else if (inherits(cond, "condition")) {
[10:31:23.735]                         if (!is.null(pattern)) {
[10:31:23.735]                           computeRestarts <- base::computeRestarts
[10:31:23.735]                           grepl <- base::grepl
[10:31:23.735]                           restarts <- computeRestarts(cond)
[10:31:23.735]                           for (restart in restarts) {
[10:31:23.735]                             name <- restart$name
[10:31:23.735]                             if (is.null(name)) 
[10:31:23.735]                               next
[10:31:23.735]                             if (!grepl(pattern, name)) 
[10:31:23.735]                               next
[10:31:23.735]                             invokeRestart(restart)
[10:31:23.735]                             muffled <- TRUE
[10:31:23.735]                             break
[10:31:23.735]                           }
[10:31:23.735]                         }
[10:31:23.735]                       }
[10:31:23.735]                       invisible(muffled)
[10:31:23.735]                     }
[10:31:23.735]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.735]                   }
[10:31:23.735]                 }
[10:31:23.735]             }
[10:31:23.735]         }))
[10:31:23.735]     }, error = function(ex) {
[10:31:23.735]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.735]                 ...future.rng), started = ...future.startTime, 
[10:31:23.735]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.735]             version = "1.8"), class = "FutureResult")
[10:31:23.735]     }, finally = {
[10:31:23.735]         if (!identical(...future.workdir, getwd())) 
[10:31:23.735]             setwd(...future.workdir)
[10:31:23.735]         {
[10:31:23.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.735]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.735]             }
[10:31:23.735]             base::options(...future.oldOptions)
[10:31:23.735]             if (.Platform$OS.type == "windows") {
[10:31:23.735]                 old_names <- names(...future.oldEnvVars)
[10:31:23.735]                 envs <- base::Sys.getenv()
[10:31:23.735]                 names <- names(envs)
[10:31:23.735]                 common <- intersect(names, old_names)
[10:31:23.735]                 added <- setdiff(names, old_names)
[10:31:23.735]                 removed <- setdiff(old_names, names)
[10:31:23.735]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.735]                   envs[common]]
[10:31:23.735]                 NAMES <- toupper(changed)
[10:31:23.735]                 args <- list()
[10:31:23.735]                 for (kk in seq_along(NAMES)) {
[10:31:23.735]                   name <- changed[[kk]]
[10:31:23.735]                   NAME <- NAMES[[kk]]
[10:31:23.735]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.735]                     next
[10:31:23.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.735]                 }
[10:31:23.735]                 NAMES <- toupper(added)
[10:31:23.735]                 for (kk in seq_along(NAMES)) {
[10:31:23.735]                   name <- added[[kk]]
[10:31:23.735]                   NAME <- NAMES[[kk]]
[10:31:23.735]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.735]                     next
[10:31:23.735]                   args[[name]] <- ""
[10:31:23.735]                 }
[10:31:23.735]                 NAMES <- toupper(removed)
[10:31:23.735]                 for (kk in seq_along(NAMES)) {
[10:31:23.735]                   name <- removed[[kk]]
[10:31:23.735]                   NAME <- NAMES[[kk]]
[10:31:23.735]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.735]                     next
[10:31:23.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.735]                 }
[10:31:23.735]                 if (length(args) > 0) 
[10:31:23.735]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.735]             }
[10:31:23.735]             else {
[10:31:23.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.735]             }
[10:31:23.735]             {
[10:31:23.735]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.735]                   0L) {
[10:31:23.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.735]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.735]                   base::options(opts)
[10:31:23.735]                 }
[10:31:23.735]                 {
[10:31:23.735]                   {
[10:31:23.735]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.735]                     NULL
[10:31:23.735]                   }
[10:31:23.735]                   options(future.plan = NULL)
[10:31:23.735]                   if (is.na(NA_character_)) 
[10:31:23.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.735]                     .init = FALSE)
[10:31:23.735]                 }
[10:31:23.735]             }
[10:31:23.735]         }
[10:31:23.735]     })
[10:31:23.735]     if (TRUE) {
[10:31:23.735]         base::sink(type = "output", split = FALSE)
[10:31:23.735]         if (TRUE) {
[10:31:23.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.735]         }
[10:31:23.735]         else {
[10:31:23.735]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.735]         }
[10:31:23.735]         base::close(...future.stdout)
[10:31:23.735]         ...future.stdout <- NULL
[10:31:23.735]     }
[10:31:23.735]     ...future.result$conditions <- ...future.conditions
[10:31:23.735]     ...future.result$finished <- base::Sys.time()
[10:31:23.735]     ...future.result
[10:31:23.735] }
[10:31:23.737] assign_globals() ...
[10:31:23.738] List of 5
[10:31:23.738]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[10:31:23.738]  $ future.call.arguments    : list()
[10:31:23.738]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.738]  $ ...future.elements_ii    :List of 4
[10:31:23.738]   ..$ : int [1:3] 1 2 3
[10:31:23.738]   ..$ : int [1:4] 1 2 3 4
[10:31:23.738]   ..$ : int [1:5] 1 2 3 4 5
[10:31:23.738]   ..$ : int [1:6] 1 2 3 4 5 6
[10:31:23.738]  $ ...future.seeds_ii       : NULL
[10:31:23.738]  $ ...future.globals.maxSize: NULL
[10:31:23.738]  - attr(*, "where")=List of 5
[10:31:23.738]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.738]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.738]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.738]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.738]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.738]  - attr(*, "resolved")= logi FALSE
[10:31:23.738]  - attr(*, "total_size")= num 46960
[10:31:23.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.738]  - attr(*, "already-done")= logi TRUE
[10:31:23.744] - copied ‘...future.FUN’ to environment
[10:31:23.744] - copied ‘future.call.arguments’ to environment
[10:31:23.744] - copied ‘...future.elements_ii’ to environment
[10:31:23.745] - copied ‘...future.seeds_ii’ to environment
[10:31:23.745] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.745] assign_globals() ... done
[10:31:23.745] requestCore(): workers = 2
[10:31:23.747] MulticoreFuture started
[10:31:23.748] - Launch lazy future ... done
[10:31:23.748] run() for ‘MulticoreFuture’ ... done
[10:31:23.748] Created future:
[10:31:23.749] plan(): Setting new future strategy stack:
[10:31:23.749] List of future strategies:
[10:31:23.749] 1. sequential:
[10:31:23.749]    - args: function (..., envir = parent.frame())
[10:31:23.749]    - tweaked: FALSE
[10:31:23.749]    - call: NULL
[10:31:23.750] plan(): nbrOfWorkers() = 1
[10:31:23.752] plan(): Setting new future strategy stack:
[10:31:23.752] List of future strategies:
[10:31:23.752] 1. multicore:
[10:31:23.752]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.752]    - tweaked: FALSE
[10:31:23.752]    - call: plan(strategy)
[10:31:23.758] plan(): nbrOfWorkers() = 2
[10:31:23.748] MulticoreFuture:
[10:31:23.748] Label: ‘future_sapply-1’
[10:31:23.748] Expression:
[10:31:23.748] {
[10:31:23.748]     do.call(function(...) {
[10:31:23.748]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.748]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.748]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.748]             on.exit(options(oopts), add = TRUE)
[10:31:23.748]         }
[10:31:23.748]         {
[10:31:23.748]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.748]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.748]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.748]             })
[10:31:23.748]         }
[10:31:23.748]     }, args = future.call.arguments)
[10:31:23.748] }
[10:31:23.748] Lazy evaluation: FALSE
[10:31:23.748] Asynchronous evaluation: TRUE
[10:31:23.748] Local evaluation: TRUE
[10:31:23.748] Environment: R_GlobalEnv
[10:31:23.748] Capture standard output: TRUE
[10:31:23.748] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.748] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:23.748] Packages: 1 packages (‘stats’)
[10:31:23.748] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.748] Resolved: TRUE
[10:31:23.748] Value: <not collected>
[10:31:23.748] Conditions captured: <none>
[10:31:23.748] Early signaling: FALSE
[10:31:23.748] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.748] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.759] Chunk #1 of 2 ... DONE
[10:31:23.759] Chunk #2 of 2 ...
[10:31:23.759]  - Finding globals in 'X' for chunk #2 ...
[10:31:23.759] getGlobalsAndPackages() ...
[10:31:23.760] Searching for globals...
[10:31:23.760] 
[10:31:23.760] Searching for globals ... DONE
[10:31:23.760] - globals: [0] <none>
[10:31:23.760] getGlobalsAndPackages() ... DONE
[10:31:23.761]    + additional globals found: [n=0] 
[10:31:23.761]    + additional namespaces needed: [n=0] 
[10:31:23.761]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:23.761]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.761]  - seeds: <none>
[10:31:23.761]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.762] getGlobalsAndPackages() ...
[10:31:23.762] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.762] Resolving globals: FALSE
[10:31:23.762] Tweak future expression to call with '...' arguments ...
[10:31:23.762] {
[10:31:23.762]     do.call(function(...) {
[10:31:23.762]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.762]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.762]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.762]             on.exit(options(oopts), add = TRUE)
[10:31:23.762]         }
[10:31:23.762]         {
[10:31:23.762]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.762]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.762]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.762]             })
[10:31:23.762]         }
[10:31:23.762]     }, args = future.call.arguments)
[10:31:23.762] }
[10:31:23.763] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.763] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.764] - packages: [1] ‘stats’
[10:31:23.764] getGlobalsAndPackages() ... DONE
[10:31:23.764] run() for ‘Future’ ...
[10:31:23.764] - state: ‘created’
[10:31:23.765] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.769] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.770]   - Field: ‘label’
[10:31:23.770]   - Field: ‘local’
[10:31:23.770]   - Field: ‘owner’
[10:31:23.770]   - Field: ‘envir’
[10:31:23.770]   - Field: ‘workers’
[10:31:23.770]   - Field: ‘packages’
[10:31:23.770]   - Field: ‘gc’
[10:31:23.771]   - Field: ‘job’
[10:31:23.771]   - Field: ‘conditions’
[10:31:23.771]   - Field: ‘expr’
[10:31:23.771]   - Field: ‘uuid’
[10:31:23.771]   - Field: ‘seed’
[10:31:23.771]   - Field: ‘version’
[10:31:23.771]   - Field: ‘result’
[10:31:23.772]   - Field: ‘asynchronous’
[10:31:23.772]   - Field: ‘calls’
[10:31:23.772]   - Field: ‘globals’
[10:31:23.772]   - Field: ‘stdout’
[10:31:23.772]   - Field: ‘earlySignal’
[10:31:23.772]   - Field: ‘lazy’
[10:31:23.772]   - Field: ‘state’
[10:31:23.772] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.773] - Launch lazy future ...
[10:31:23.773] Packages needed by the future expression (n = 1): ‘stats’
[10:31:23.773] Packages needed by future strategies (n = 0): <none>
[10:31:23.774] {
[10:31:23.774]     {
[10:31:23.774]         {
[10:31:23.774]             ...future.startTime <- base::Sys.time()
[10:31:23.774]             {
[10:31:23.774]                 {
[10:31:23.774]                   {
[10:31:23.774]                     {
[10:31:23.774]                       {
[10:31:23.774]                         base::local({
[10:31:23.774]                           has_future <- base::requireNamespace("future", 
[10:31:23.774]                             quietly = TRUE)
[10:31:23.774]                           if (has_future) {
[10:31:23.774]                             ns <- base::getNamespace("future")
[10:31:23.774]                             version <- ns[[".package"]][["version"]]
[10:31:23.774]                             if (is.null(version)) 
[10:31:23.774]                               version <- utils::packageVersion("future")
[10:31:23.774]                           }
[10:31:23.774]                           else {
[10:31:23.774]                             version <- NULL
[10:31:23.774]                           }
[10:31:23.774]                           if (!has_future || version < "1.8.0") {
[10:31:23.774]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.774]                               "", base::R.version$version.string), 
[10:31:23.774]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.774]                                 base::R.version$platform, 8 * 
[10:31:23.774]                                   base::.Machine$sizeof.pointer), 
[10:31:23.774]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.774]                                 "release", "version")], collapse = " "), 
[10:31:23.774]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.774]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.774]                               info)
[10:31:23.774]                             info <- base::paste(info, collapse = "; ")
[10:31:23.774]                             if (!has_future) {
[10:31:23.774]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.774]                                 info)
[10:31:23.774]                             }
[10:31:23.774]                             else {
[10:31:23.774]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.774]                                 info, version)
[10:31:23.774]                             }
[10:31:23.774]                             base::stop(msg)
[10:31:23.774]                           }
[10:31:23.774]                         })
[10:31:23.774]                       }
[10:31:23.774]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.774]                       base::options(mc.cores = 1L)
[10:31:23.774]                     }
[10:31:23.774]                     base::local({
[10:31:23.774]                       for (pkg in "stats") {
[10:31:23.774]                         base::loadNamespace(pkg)
[10:31:23.774]                         base::library(pkg, character.only = TRUE)
[10:31:23.774]                       }
[10:31:23.774]                     })
[10:31:23.774]                   }
[10:31:23.774]                   ...future.strategy.old <- future::plan("list")
[10:31:23.774]                   options(future.plan = NULL)
[10:31:23.774]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.774]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.774]                 }
[10:31:23.774]                 ...future.workdir <- getwd()
[10:31:23.774]             }
[10:31:23.774]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.774]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.774]         }
[10:31:23.774]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.774]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.774]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.774]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.774]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.774]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.774]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.774]             base::names(...future.oldOptions))
[10:31:23.774]     }
[10:31:23.774]     if (FALSE) {
[10:31:23.774]     }
[10:31:23.774]     else {
[10:31:23.774]         if (TRUE) {
[10:31:23.774]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.774]                 open = "w")
[10:31:23.774]         }
[10:31:23.774]         else {
[10:31:23.774]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.774]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.774]         }
[10:31:23.774]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.774]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.774]             base::sink(type = "output", split = FALSE)
[10:31:23.774]             base::close(...future.stdout)
[10:31:23.774]         }, add = TRUE)
[10:31:23.774]     }
[10:31:23.774]     ...future.frame <- base::sys.nframe()
[10:31:23.774]     ...future.conditions <- base::list()
[10:31:23.774]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.774]     if (FALSE) {
[10:31:23.774]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.774]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.774]     }
[10:31:23.774]     ...future.result <- base::tryCatch({
[10:31:23.774]         base::withCallingHandlers({
[10:31:23.774]             ...future.value <- base::withVisible(base::local({
[10:31:23.774]                 withCallingHandlers({
[10:31:23.774]                   {
[10:31:23.774]                     do.call(function(...) {
[10:31:23.774]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.774]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.774]                         ...future.globals.maxSize)) {
[10:31:23.774]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.774]                         on.exit(options(oopts), add = TRUE)
[10:31:23.774]                       }
[10:31:23.774]                       {
[10:31:23.774]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.774]                           FUN = function(jj) {
[10:31:23.774]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.774]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.774]                           })
[10:31:23.774]                       }
[10:31:23.774]                     }, args = future.call.arguments)
[10:31:23.774]                   }
[10:31:23.774]                 }, immediateCondition = function(cond) {
[10:31:23.774]                   save_rds <- function (object, pathname, ...) 
[10:31:23.774]                   {
[10:31:23.774]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.774]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.774]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.774]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.774]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.774]                         fi_tmp[["mtime"]])
[10:31:23.774]                     }
[10:31:23.774]                     tryCatch({
[10:31:23.774]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.774]                     }, error = function(ex) {
[10:31:23.774]                       msg <- conditionMessage(ex)
[10:31:23.774]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.774]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.774]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.774]                         fi_tmp[["mtime"]], msg)
[10:31:23.774]                       ex$message <- msg
[10:31:23.774]                       stop(ex)
[10:31:23.774]                     })
[10:31:23.774]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.774]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.774]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.774]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.774]                       fi <- file.info(pathname)
[10:31:23.774]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.774]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.774]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.774]                         fi[["size"]], fi[["mtime"]])
[10:31:23.774]                       stop(msg)
[10:31:23.774]                     }
[10:31:23.774]                     invisible(pathname)
[10:31:23.774]                   }
[10:31:23.774]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.774]                     rootPath = tempdir()) 
[10:31:23.774]                   {
[10:31:23.774]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.774]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.774]                       tmpdir = path, fileext = ".rds")
[10:31:23.774]                     save_rds(obj, file)
[10:31:23.774]                   }
[10:31:23.774]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.774]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.774]                   {
[10:31:23.774]                     inherits <- base::inherits
[10:31:23.774]                     invokeRestart <- base::invokeRestart
[10:31:23.774]                     is.null <- base::is.null
[10:31:23.774]                     muffled <- FALSE
[10:31:23.774]                     if (inherits(cond, "message")) {
[10:31:23.774]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.774]                       if (muffled) 
[10:31:23.774]                         invokeRestart("muffleMessage")
[10:31:23.774]                     }
[10:31:23.774]                     else if (inherits(cond, "warning")) {
[10:31:23.774]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.774]                       if (muffled) 
[10:31:23.774]                         invokeRestart("muffleWarning")
[10:31:23.774]                     }
[10:31:23.774]                     else if (inherits(cond, "condition")) {
[10:31:23.774]                       if (!is.null(pattern)) {
[10:31:23.774]                         computeRestarts <- base::computeRestarts
[10:31:23.774]                         grepl <- base::grepl
[10:31:23.774]                         restarts <- computeRestarts(cond)
[10:31:23.774]                         for (restart in restarts) {
[10:31:23.774]                           name <- restart$name
[10:31:23.774]                           if (is.null(name)) 
[10:31:23.774]                             next
[10:31:23.774]                           if (!grepl(pattern, name)) 
[10:31:23.774]                             next
[10:31:23.774]                           invokeRestart(restart)
[10:31:23.774]                           muffled <- TRUE
[10:31:23.774]                           break
[10:31:23.774]                         }
[10:31:23.774]                       }
[10:31:23.774]                     }
[10:31:23.774]                     invisible(muffled)
[10:31:23.774]                   }
[10:31:23.774]                   muffleCondition(cond)
[10:31:23.774]                 })
[10:31:23.774]             }))
[10:31:23.774]             future::FutureResult(value = ...future.value$value, 
[10:31:23.774]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.774]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.774]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.774]                     ...future.globalenv.names))
[10:31:23.774]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.774]         }, condition = base::local({
[10:31:23.774]             c <- base::c
[10:31:23.774]             inherits <- base::inherits
[10:31:23.774]             invokeRestart <- base::invokeRestart
[10:31:23.774]             length <- base::length
[10:31:23.774]             list <- base::list
[10:31:23.774]             seq.int <- base::seq.int
[10:31:23.774]             signalCondition <- base::signalCondition
[10:31:23.774]             sys.calls <- base::sys.calls
[10:31:23.774]             `[[` <- base::`[[`
[10:31:23.774]             `+` <- base::`+`
[10:31:23.774]             `<<-` <- base::`<<-`
[10:31:23.774]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.774]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.774]                   3L)]
[10:31:23.774]             }
[10:31:23.774]             function(cond) {
[10:31:23.774]                 is_error <- inherits(cond, "error")
[10:31:23.774]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.774]                   NULL)
[10:31:23.774]                 if (is_error) {
[10:31:23.774]                   sessionInformation <- function() {
[10:31:23.774]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.774]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.774]                       search = base::search(), system = base::Sys.info())
[10:31:23.774]                   }
[10:31:23.774]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.774]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.774]                     cond$call), session = sessionInformation(), 
[10:31:23.774]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.774]                   signalCondition(cond)
[10:31:23.774]                 }
[10:31:23.774]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.774]                 "immediateCondition"))) {
[10:31:23.774]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.774]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.774]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.774]                   if (TRUE && !signal) {
[10:31:23.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.774]                     {
[10:31:23.774]                       inherits <- base::inherits
[10:31:23.774]                       invokeRestart <- base::invokeRestart
[10:31:23.774]                       is.null <- base::is.null
[10:31:23.774]                       muffled <- FALSE
[10:31:23.774]                       if (inherits(cond, "message")) {
[10:31:23.774]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.774]                         if (muffled) 
[10:31:23.774]                           invokeRestart("muffleMessage")
[10:31:23.774]                       }
[10:31:23.774]                       else if (inherits(cond, "warning")) {
[10:31:23.774]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.774]                         if (muffled) 
[10:31:23.774]                           invokeRestart("muffleWarning")
[10:31:23.774]                       }
[10:31:23.774]                       else if (inherits(cond, "condition")) {
[10:31:23.774]                         if (!is.null(pattern)) {
[10:31:23.774]                           computeRestarts <- base::computeRestarts
[10:31:23.774]                           grepl <- base::grepl
[10:31:23.774]                           restarts <- computeRestarts(cond)
[10:31:23.774]                           for (restart in restarts) {
[10:31:23.774]                             name <- restart$name
[10:31:23.774]                             if (is.null(name)) 
[10:31:23.774]                               next
[10:31:23.774]                             if (!grepl(pattern, name)) 
[10:31:23.774]                               next
[10:31:23.774]                             invokeRestart(restart)
[10:31:23.774]                             muffled <- TRUE
[10:31:23.774]                             break
[10:31:23.774]                           }
[10:31:23.774]                         }
[10:31:23.774]                       }
[10:31:23.774]                       invisible(muffled)
[10:31:23.774]                     }
[10:31:23.774]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.774]                   }
[10:31:23.774]                 }
[10:31:23.774]                 else {
[10:31:23.774]                   if (TRUE) {
[10:31:23.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.774]                     {
[10:31:23.774]                       inherits <- base::inherits
[10:31:23.774]                       invokeRestart <- base::invokeRestart
[10:31:23.774]                       is.null <- base::is.null
[10:31:23.774]                       muffled <- FALSE
[10:31:23.774]                       if (inherits(cond, "message")) {
[10:31:23.774]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.774]                         if (muffled) 
[10:31:23.774]                           invokeRestart("muffleMessage")
[10:31:23.774]                       }
[10:31:23.774]                       else if (inherits(cond, "warning")) {
[10:31:23.774]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.774]                         if (muffled) 
[10:31:23.774]                           invokeRestart("muffleWarning")
[10:31:23.774]                       }
[10:31:23.774]                       else if (inherits(cond, "condition")) {
[10:31:23.774]                         if (!is.null(pattern)) {
[10:31:23.774]                           computeRestarts <- base::computeRestarts
[10:31:23.774]                           grepl <- base::grepl
[10:31:23.774]                           restarts <- computeRestarts(cond)
[10:31:23.774]                           for (restart in restarts) {
[10:31:23.774]                             name <- restart$name
[10:31:23.774]                             if (is.null(name)) 
[10:31:23.774]                               next
[10:31:23.774]                             if (!grepl(pattern, name)) 
[10:31:23.774]                               next
[10:31:23.774]                             invokeRestart(restart)
[10:31:23.774]                             muffled <- TRUE
[10:31:23.774]                             break
[10:31:23.774]                           }
[10:31:23.774]                         }
[10:31:23.774]                       }
[10:31:23.774]                       invisible(muffled)
[10:31:23.774]                     }
[10:31:23.774]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.774]                   }
[10:31:23.774]                 }
[10:31:23.774]             }
[10:31:23.774]         }))
[10:31:23.774]     }, error = function(ex) {
[10:31:23.774]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.774]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.774]                 ...future.rng), started = ...future.startTime, 
[10:31:23.774]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.774]             version = "1.8"), class = "FutureResult")
[10:31:23.774]     }, finally = {
[10:31:23.774]         if (!identical(...future.workdir, getwd())) 
[10:31:23.774]             setwd(...future.workdir)
[10:31:23.774]         {
[10:31:23.774]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.774]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.774]             }
[10:31:23.774]             base::options(...future.oldOptions)
[10:31:23.774]             if (.Platform$OS.type == "windows") {
[10:31:23.774]                 old_names <- names(...future.oldEnvVars)
[10:31:23.774]                 envs <- base::Sys.getenv()
[10:31:23.774]                 names <- names(envs)
[10:31:23.774]                 common <- intersect(names, old_names)
[10:31:23.774]                 added <- setdiff(names, old_names)
[10:31:23.774]                 removed <- setdiff(old_names, names)
[10:31:23.774]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.774]                   envs[common]]
[10:31:23.774]                 NAMES <- toupper(changed)
[10:31:23.774]                 args <- list()
[10:31:23.774]                 for (kk in seq_along(NAMES)) {
[10:31:23.774]                   name <- changed[[kk]]
[10:31:23.774]                   NAME <- NAMES[[kk]]
[10:31:23.774]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.774]                     next
[10:31:23.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.774]                 }
[10:31:23.774]                 NAMES <- toupper(added)
[10:31:23.774]                 for (kk in seq_along(NAMES)) {
[10:31:23.774]                   name <- added[[kk]]
[10:31:23.774]                   NAME <- NAMES[[kk]]
[10:31:23.774]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.774]                     next
[10:31:23.774]                   args[[name]] <- ""
[10:31:23.774]                 }
[10:31:23.774]                 NAMES <- toupper(removed)
[10:31:23.774]                 for (kk in seq_along(NAMES)) {
[10:31:23.774]                   name <- removed[[kk]]
[10:31:23.774]                   NAME <- NAMES[[kk]]
[10:31:23.774]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.774]                     next
[10:31:23.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.774]                 }
[10:31:23.774]                 if (length(args) > 0) 
[10:31:23.774]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.774]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.774]             }
[10:31:23.774]             else {
[10:31:23.774]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.774]             }
[10:31:23.774]             {
[10:31:23.774]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.774]                   0L) {
[10:31:23.774]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.774]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.774]                   base::options(opts)
[10:31:23.774]                 }
[10:31:23.774]                 {
[10:31:23.774]                   {
[10:31:23.774]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.774]                     NULL
[10:31:23.774]                   }
[10:31:23.774]                   options(future.plan = NULL)
[10:31:23.774]                   if (is.na(NA_character_)) 
[10:31:23.774]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.774]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.774]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.774]                     .init = FALSE)
[10:31:23.774]                 }
[10:31:23.774]             }
[10:31:23.774]         }
[10:31:23.774]     })
[10:31:23.774]     if (TRUE) {
[10:31:23.774]         base::sink(type = "output", split = FALSE)
[10:31:23.774]         if (TRUE) {
[10:31:23.774]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.774]         }
[10:31:23.774]         else {
[10:31:23.774]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.774]         }
[10:31:23.774]         base::close(...future.stdout)
[10:31:23.774]         ...future.stdout <- NULL
[10:31:23.774]     }
[10:31:23.774]     ...future.result$conditions <- ...future.conditions
[10:31:23.774]     ...future.result$finished <- base::Sys.time()
[10:31:23.774]     ...future.result
[10:31:23.774] }
[10:31:23.780] assign_globals() ...
[10:31:23.780] List of 5
[10:31:23.780]  $ ...future.FUN            :function (x, na.rm = TRUE)  
[10:31:23.780]  $ future.call.arguments    : list()
[10:31:23.780]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.780]  $ ...future.elements_ii    :List of 3
[10:31:23.780]   ..$ : int [1:7] 1 2 3 4 5 6 7
[10:31:23.780]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[10:31:23.780]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[10:31:23.780]  $ ...future.seeds_ii       : NULL
[10:31:23.780]  $ ...future.globals.maxSize: NULL
[10:31:23.780]  - attr(*, "where")=List of 5
[10:31:23.780]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.780]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.780]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.780]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.780]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.780]  - attr(*, "resolved")= logi FALSE
[10:31:23.780]  - attr(*, "total_size")= num 46960
[10:31:23.780]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.780]  - attr(*, "already-done")= logi TRUE
[10:31:23.791] - copied ‘...future.FUN’ to environment
[10:31:23.791] - copied ‘future.call.arguments’ to environment
[10:31:23.791] - copied ‘...future.elements_ii’ to environment
[10:31:23.791] - copied ‘...future.seeds_ii’ to environment
[10:31:23.791] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.791] assign_globals() ... done
[10:31:23.792] requestCore(): workers = 2
[10:31:23.794] MulticoreFuture started
[10:31:23.794] - Launch lazy future ... done
[10:31:23.795] run() for ‘MulticoreFuture’ ... done
[10:31:23.795] Created future:
[10:31:23.795] plan(): Setting new future strategy stack:
[10:31:23.796] List of future strategies:
[10:31:23.796] 1. sequential:
[10:31:23.796]    - args: function (..., envir = parent.frame())
[10:31:23.796]    - tweaked: FALSE
[10:31:23.796]    - call: NULL
[10:31:23.797] plan(): nbrOfWorkers() = 1
[10:31:23.799] plan(): Setting new future strategy stack:
[10:31:23.799] List of future strategies:
[10:31:23.799] 1. multicore:
[10:31:23.799]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.799]    - tweaked: FALSE
[10:31:23.799]    - call: plan(strategy)
[10:31:23.805] plan(): nbrOfWorkers() = 2
[10:31:23.795] MulticoreFuture:
[10:31:23.795] Label: ‘future_sapply-2’
[10:31:23.795] Expression:
[10:31:23.795] {
[10:31:23.795]     do.call(function(...) {
[10:31:23.795]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.795]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.795]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.795]             on.exit(options(oopts), add = TRUE)
[10:31:23.795]         }
[10:31:23.795]         {
[10:31:23.795]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.795]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.795]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.795]             })
[10:31:23.795]         }
[10:31:23.795]     }, args = future.call.arguments)
[10:31:23.795] }
[10:31:23.795] Lazy evaluation: FALSE
[10:31:23.795] Asynchronous evaluation: TRUE
[10:31:23.795] Local evaluation: TRUE
[10:31:23.795] Environment: R_GlobalEnv
[10:31:23.795] Capture standard output: TRUE
[10:31:23.795] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.795] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:23.795] Packages: 1 packages (‘stats’)
[10:31:23.795] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.795] Resolved: TRUE
[10:31:23.795] Value: <not collected>
[10:31:23.795] Conditions captured: <none>
[10:31:23.795] Early signaling: FALSE
[10:31:23.795] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.795] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.806] Chunk #2 of 2 ... DONE
[10:31:23.806] Launching 2 futures (chunks) ... DONE
[10:31:23.806] Resolving 2 futures (chunks) ...
[10:31:23.807] resolve() on list ...
[10:31:23.807]  recursive: 0
[10:31:23.807]  length: 2
[10:31:23.807] 
[10:31:23.807] Future #1
[10:31:23.808] result() for MulticoreFuture ...
[10:31:23.808] result() for MulticoreFuture ...
[10:31:23.809] result() for MulticoreFuture ... done
[10:31:23.809] result() for MulticoreFuture ... done
[10:31:23.809] result() for MulticoreFuture ...
[10:31:23.809] result() for MulticoreFuture ... done
[10:31:23.809] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:23.809] - nx: 2
[10:31:23.810] - relay: TRUE
[10:31:23.810] - stdout: TRUE
[10:31:23.810] - signal: TRUE
[10:31:23.810] - resignal: FALSE
[10:31:23.810] - force: TRUE
[10:31:23.810] - relayed: [n=2] FALSE, FALSE
[10:31:23.811] - queued futures: [n=2] FALSE, FALSE
[10:31:23.811]  - until=1
[10:31:23.811]  - relaying element #1
[10:31:23.811] result() for MulticoreFuture ...
[10:31:23.811] result() for MulticoreFuture ... done
[10:31:23.811] result() for MulticoreFuture ...
[10:31:23.812] result() for MulticoreFuture ... done
[10:31:23.812] result() for MulticoreFuture ...
[10:31:23.812] result() for MulticoreFuture ... done
[10:31:23.812] result() for MulticoreFuture ...
[10:31:23.812] result() for MulticoreFuture ... done
[10:31:23.813] - relayed: [n=2] TRUE, FALSE
[10:31:23.813] - queued futures: [n=2] TRUE, FALSE
[10:31:23.813] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:23.813]  length: 1 (resolved future 1)
[10:31:23.813] Future #2
[10:31:23.814] result() for MulticoreFuture ...
[10:31:23.814] result() for MulticoreFuture ...
[10:31:23.814] result() for MulticoreFuture ... done
[10:31:23.815] result() for MulticoreFuture ... done
[10:31:23.815] result() for MulticoreFuture ...
[10:31:23.815] result() for MulticoreFuture ... done
[10:31:23.815] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:23.815] - nx: 2
[10:31:23.815] - relay: TRUE
[10:31:23.816] - stdout: TRUE
[10:31:23.816] - signal: TRUE
[10:31:23.816] - resignal: FALSE
[10:31:23.816] - force: TRUE
[10:31:23.816] - relayed: [n=2] TRUE, FALSE
[10:31:23.816] - queued futures: [n=2] TRUE, FALSE
[10:31:23.816]  - until=2
[10:31:23.816]  - relaying element #2
[10:31:23.816] result() for MulticoreFuture ...
[10:31:23.817] result() for MulticoreFuture ... done
[10:31:23.817] result() for MulticoreFuture ...
[10:31:23.817] result() for MulticoreFuture ... done
[10:31:23.817] result() for MulticoreFuture ...
[10:31:23.817] result() for MulticoreFuture ... done
[10:31:23.817] result() for MulticoreFuture ...
[10:31:23.817] result() for MulticoreFuture ... done
[10:31:23.818] - relayed: [n=2] TRUE, TRUE
[10:31:23.818] - queued futures: [n=2] TRUE, TRUE
[10:31:23.818] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:23.818]  length: 0 (resolved future 2)
[10:31:23.818] Relaying remaining futures
[10:31:23.818] signalConditionsASAP(NULL, pos=0) ...
[10:31:23.818] - nx: 2
[10:31:23.818] - relay: TRUE
[10:31:23.818] - stdout: TRUE
[10:31:23.819] - signal: TRUE
[10:31:23.819] - resignal: FALSE
[10:31:23.819] - force: TRUE
[10:31:23.819] - relayed: [n=2] TRUE, TRUE
[10:31:23.819] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:23.819] - relayed: [n=2] TRUE, TRUE
[10:31:23.819] - queued futures: [n=2] TRUE, TRUE
[10:31:23.819] signalConditionsASAP(NULL, pos=0) ... done
[10:31:23.819] resolve() on list ... DONE
[10:31:23.820] result() for MulticoreFuture ...
[10:31:23.820] result() for MulticoreFuture ... done
[10:31:23.820] result() for MulticoreFuture ...
[10:31:23.820] result() for MulticoreFuture ... done
[10:31:23.820] result() for MulticoreFuture ...
[10:31:23.820] result() for MulticoreFuture ... done
[10:31:23.820] result() for MulticoreFuture ...
[10:31:23.820] result() for MulticoreFuture ... done
[10:31:23.821]  - Number of value chunks collected: 2
[10:31:23.823] Resolving 2 futures (chunks) ... DONE
[10:31:23.823] Reducing values from 2 chunks ...
[10:31:23.824]  - Number of values collected after concatenation: 7
[10:31:23.824]  - Number of values expected: 7
[10:31:23.824] Reducing values from 2 chunks ... DONE
[10:31:23.824] future_lapply() ... DONE
[10:31:23.825] future_lapply() ...
[10:31:23.832] Number of chunks: 2
[10:31:23.832] getGlobalsAndPackagesXApply() ...
[10:31:23.832]  - future.globals: TRUE
[10:31:23.832] getGlobalsAndPackages() ...
[10:31:23.833] Searching for globals...
[10:31:23.840] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:31:23.840] Searching for globals ... DONE
[10:31:23.841] Resolving globals: FALSE
[10:31:23.842] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[10:31:23.842] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[10:31:23.842] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:23.843] - packages: [2] ‘stats’, ‘future.apply’
[10:31:23.843] getGlobalsAndPackages() ... DONE
[10:31:23.843]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:23.843]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:31:23.843] Finding globals ... DONE
[10:31:23.843]  - use_args: TRUE
[10:31:23.843]  - Getting '...' globals ...
[10:31:23.843] resolve() on list ...
[10:31:23.844]  recursive: 0
[10:31:23.844]  length: 1
[10:31:23.844]  elements: ‘...’
[10:31:23.844]  length: 0 (resolved future 1)
[10:31:23.844] resolve() on list ... DONE
[10:31:23.844]    - '...' content: [n=0] 
[10:31:23.844] List of 1
[10:31:23.844]  $ ...: list()
[10:31:23.844]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.844]  - attr(*, "where")=List of 1
[10:31:23.844]   ..$ ...:<environment: 0x55de83b33c40> 
[10:31:23.844]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.844]  - attr(*, "resolved")= logi TRUE
[10:31:23.844]  - attr(*, "total_size")= num NA
[10:31:23.849]  - Getting '...' globals ... DONE
[10:31:23.849] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:23.850] List of 8
[10:31:23.850]  $ ...future.FUN:function (x, ...)  
[10:31:23.850]  $ x_FUN        :function (x, na.rm = TRUE)  
[10:31:23.850]  $ times        : int 5
[10:31:23.850]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.850]  $ stop_if_not  :function (...)  
[10:31:23.850]  $ dim          : NULL
[10:31:23.850]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:23.850]  $ ...          : list()
[10:31:23.850]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.850]  - attr(*, "where")=List of 8
[10:31:23.850]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:23.850]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:23.850]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:23.850]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:23.850]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:23.850]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:23.850]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:23.850]   ..$ ...          :<environment: 0x55de83b33c40> 
[10:31:23.850]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.850]  - attr(*, "resolved")= logi FALSE
[10:31:23.850]  - attr(*, "total_size")= num 141240
[10:31:23.855] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:31:23.855] getGlobalsAndPackagesXApply() ... DONE
[10:31:23.856] Number of futures (= number of chunks): 2
[10:31:23.856] Launching 2 futures (chunks) ...
[10:31:23.856] Chunk #1 of 2 ...
[10:31:23.856]  - Finding globals in 'X' for chunk #1 ...
[10:31:23.856] getGlobalsAndPackages() ...
[10:31:23.856] Searching for globals...
[10:31:23.856] 
[10:31:23.856] Searching for globals ... DONE
[10:31:23.857] - globals: [0] <none>
[10:31:23.857] getGlobalsAndPackages() ... DONE
[10:31:23.857]    + additional globals found: [n=0] 
[10:31:23.857]    + additional namespaces needed: [n=0] 
[10:31:23.857]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:23.857]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.857]  - seeds: <none>
[10:31:23.857]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.857] getGlobalsAndPackages() ...
[10:31:23.857] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.858] Resolving globals: FALSE
[10:31:23.858] Tweak future expression to call with '...' arguments ...
[10:31:23.858] {
[10:31:23.858]     do.call(function(...) {
[10:31:23.858]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.858]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.858]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.858]             on.exit(options(oopts), add = TRUE)
[10:31:23.858]         }
[10:31:23.858]         {
[10:31:23.858]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.858]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.858]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.858]             })
[10:31:23.858]         }
[10:31:23.858]     }, args = future.call.arguments)
[10:31:23.858] }
[10:31:23.858] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.859] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.859] - packages: [2] ‘stats’, ‘future.apply’
[10:31:23.859] getGlobalsAndPackages() ... DONE
[10:31:23.859] run() for ‘Future’ ...
[10:31:23.859] - state: ‘created’
[10:31:23.859] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.863] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.864]   - Field: ‘label’
[10:31:23.864]   - Field: ‘local’
[10:31:23.864]   - Field: ‘owner’
[10:31:23.864]   - Field: ‘envir’
[10:31:23.864]   - Field: ‘workers’
[10:31:23.864]   - Field: ‘packages’
[10:31:23.864]   - Field: ‘gc’
[10:31:23.864]   - Field: ‘job’
[10:31:23.864]   - Field: ‘conditions’
[10:31:23.865]   - Field: ‘expr’
[10:31:23.865]   - Field: ‘uuid’
[10:31:23.865]   - Field: ‘seed’
[10:31:23.865]   - Field: ‘version’
[10:31:23.865]   - Field: ‘result’
[10:31:23.865]   - Field: ‘asynchronous’
[10:31:23.865]   - Field: ‘calls’
[10:31:23.865]   - Field: ‘globals’
[10:31:23.865]   - Field: ‘stdout’
[10:31:23.865]   - Field: ‘earlySignal’
[10:31:23.866]   - Field: ‘lazy’
[10:31:23.866]   - Field: ‘state’
[10:31:23.866] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.866] - Launch lazy future ...
[10:31:23.866] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:31:23.866] Packages needed by future strategies (n = 0): <none>
[10:31:23.867] {
[10:31:23.867]     {
[10:31:23.867]         {
[10:31:23.867]             ...future.startTime <- base::Sys.time()
[10:31:23.867]             {
[10:31:23.867]                 {
[10:31:23.867]                   {
[10:31:23.867]                     {
[10:31:23.867]                       {
[10:31:23.867]                         base::local({
[10:31:23.867]                           has_future <- base::requireNamespace("future", 
[10:31:23.867]                             quietly = TRUE)
[10:31:23.867]                           if (has_future) {
[10:31:23.867]                             ns <- base::getNamespace("future")
[10:31:23.867]                             version <- ns[[".package"]][["version"]]
[10:31:23.867]                             if (is.null(version)) 
[10:31:23.867]                               version <- utils::packageVersion("future")
[10:31:23.867]                           }
[10:31:23.867]                           else {
[10:31:23.867]                             version <- NULL
[10:31:23.867]                           }
[10:31:23.867]                           if (!has_future || version < "1.8.0") {
[10:31:23.867]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.867]                               "", base::R.version$version.string), 
[10:31:23.867]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.867]                                 base::R.version$platform, 8 * 
[10:31:23.867]                                   base::.Machine$sizeof.pointer), 
[10:31:23.867]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.867]                                 "release", "version")], collapse = " "), 
[10:31:23.867]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.867]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.867]                               info)
[10:31:23.867]                             info <- base::paste(info, collapse = "; ")
[10:31:23.867]                             if (!has_future) {
[10:31:23.867]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.867]                                 info)
[10:31:23.867]                             }
[10:31:23.867]                             else {
[10:31:23.867]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.867]                                 info, version)
[10:31:23.867]                             }
[10:31:23.867]                             base::stop(msg)
[10:31:23.867]                           }
[10:31:23.867]                         })
[10:31:23.867]                       }
[10:31:23.867]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.867]                       base::options(mc.cores = 1L)
[10:31:23.867]                     }
[10:31:23.867]                     base::local({
[10:31:23.867]                       for (pkg in c("stats", "future.apply")) {
[10:31:23.867]                         base::loadNamespace(pkg)
[10:31:23.867]                         base::library(pkg, character.only = TRUE)
[10:31:23.867]                       }
[10:31:23.867]                     })
[10:31:23.867]                   }
[10:31:23.867]                   ...future.strategy.old <- future::plan("list")
[10:31:23.867]                   options(future.plan = NULL)
[10:31:23.867]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.867]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.867]                 }
[10:31:23.867]                 ...future.workdir <- getwd()
[10:31:23.867]             }
[10:31:23.867]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.867]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.867]         }
[10:31:23.867]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.867]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.867]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.867]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.867]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.867]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.867]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.867]             base::names(...future.oldOptions))
[10:31:23.867]     }
[10:31:23.867]     if (FALSE) {
[10:31:23.867]     }
[10:31:23.867]     else {
[10:31:23.867]         if (TRUE) {
[10:31:23.867]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.867]                 open = "w")
[10:31:23.867]         }
[10:31:23.867]         else {
[10:31:23.867]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.867]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.867]         }
[10:31:23.867]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.867]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.867]             base::sink(type = "output", split = FALSE)
[10:31:23.867]             base::close(...future.stdout)
[10:31:23.867]         }, add = TRUE)
[10:31:23.867]     }
[10:31:23.867]     ...future.frame <- base::sys.nframe()
[10:31:23.867]     ...future.conditions <- base::list()
[10:31:23.867]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.867]     if (FALSE) {
[10:31:23.867]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.867]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.867]     }
[10:31:23.867]     ...future.result <- base::tryCatch({
[10:31:23.867]         base::withCallingHandlers({
[10:31:23.867]             ...future.value <- base::withVisible(base::local({
[10:31:23.867]                 withCallingHandlers({
[10:31:23.867]                   {
[10:31:23.867]                     do.call(function(...) {
[10:31:23.867]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.867]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.867]                         ...future.globals.maxSize)) {
[10:31:23.867]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.867]                         on.exit(options(oopts), add = TRUE)
[10:31:23.867]                       }
[10:31:23.867]                       {
[10:31:23.867]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.867]                           FUN = function(jj) {
[10:31:23.867]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.867]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.867]                           })
[10:31:23.867]                       }
[10:31:23.867]                     }, args = future.call.arguments)
[10:31:23.867]                   }
[10:31:23.867]                 }, immediateCondition = function(cond) {
[10:31:23.867]                   save_rds <- function (object, pathname, ...) 
[10:31:23.867]                   {
[10:31:23.867]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.867]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.867]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.867]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.867]                         fi_tmp[["mtime"]])
[10:31:23.867]                     }
[10:31:23.867]                     tryCatch({
[10:31:23.867]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.867]                     }, error = function(ex) {
[10:31:23.867]                       msg <- conditionMessage(ex)
[10:31:23.867]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.867]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.867]                         fi_tmp[["mtime"]], msg)
[10:31:23.867]                       ex$message <- msg
[10:31:23.867]                       stop(ex)
[10:31:23.867]                     })
[10:31:23.867]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.867]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.867]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.867]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.867]                       fi <- file.info(pathname)
[10:31:23.867]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.867]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.867]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.867]                         fi[["size"]], fi[["mtime"]])
[10:31:23.867]                       stop(msg)
[10:31:23.867]                     }
[10:31:23.867]                     invisible(pathname)
[10:31:23.867]                   }
[10:31:23.867]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.867]                     rootPath = tempdir()) 
[10:31:23.867]                   {
[10:31:23.867]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.867]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.867]                       tmpdir = path, fileext = ".rds")
[10:31:23.867]                     save_rds(obj, file)
[10:31:23.867]                   }
[10:31:23.867]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.867]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.867]                   {
[10:31:23.867]                     inherits <- base::inherits
[10:31:23.867]                     invokeRestart <- base::invokeRestart
[10:31:23.867]                     is.null <- base::is.null
[10:31:23.867]                     muffled <- FALSE
[10:31:23.867]                     if (inherits(cond, "message")) {
[10:31:23.867]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.867]                       if (muffled) 
[10:31:23.867]                         invokeRestart("muffleMessage")
[10:31:23.867]                     }
[10:31:23.867]                     else if (inherits(cond, "warning")) {
[10:31:23.867]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.867]                       if (muffled) 
[10:31:23.867]                         invokeRestart("muffleWarning")
[10:31:23.867]                     }
[10:31:23.867]                     else if (inherits(cond, "condition")) {
[10:31:23.867]                       if (!is.null(pattern)) {
[10:31:23.867]                         computeRestarts <- base::computeRestarts
[10:31:23.867]                         grepl <- base::grepl
[10:31:23.867]                         restarts <- computeRestarts(cond)
[10:31:23.867]                         for (restart in restarts) {
[10:31:23.867]                           name <- restart$name
[10:31:23.867]                           if (is.null(name)) 
[10:31:23.867]                             next
[10:31:23.867]                           if (!grepl(pattern, name)) 
[10:31:23.867]                             next
[10:31:23.867]                           invokeRestart(restart)
[10:31:23.867]                           muffled <- TRUE
[10:31:23.867]                           break
[10:31:23.867]                         }
[10:31:23.867]                       }
[10:31:23.867]                     }
[10:31:23.867]                     invisible(muffled)
[10:31:23.867]                   }
[10:31:23.867]                   muffleCondition(cond)
[10:31:23.867]                 })
[10:31:23.867]             }))
[10:31:23.867]             future::FutureResult(value = ...future.value$value, 
[10:31:23.867]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.867]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.867]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.867]                     ...future.globalenv.names))
[10:31:23.867]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.867]         }, condition = base::local({
[10:31:23.867]             c <- base::c
[10:31:23.867]             inherits <- base::inherits
[10:31:23.867]             invokeRestart <- base::invokeRestart
[10:31:23.867]             length <- base::length
[10:31:23.867]             list <- base::list
[10:31:23.867]             seq.int <- base::seq.int
[10:31:23.867]             signalCondition <- base::signalCondition
[10:31:23.867]             sys.calls <- base::sys.calls
[10:31:23.867]             `[[` <- base::`[[`
[10:31:23.867]             `+` <- base::`+`
[10:31:23.867]             `<<-` <- base::`<<-`
[10:31:23.867]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.867]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.867]                   3L)]
[10:31:23.867]             }
[10:31:23.867]             function(cond) {
[10:31:23.867]                 is_error <- inherits(cond, "error")
[10:31:23.867]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.867]                   NULL)
[10:31:23.867]                 if (is_error) {
[10:31:23.867]                   sessionInformation <- function() {
[10:31:23.867]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.867]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.867]                       search = base::search(), system = base::Sys.info())
[10:31:23.867]                   }
[10:31:23.867]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.867]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.867]                     cond$call), session = sessionInformation(), 
[10:31:23.867]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.867]                   signalCondition(cond)
[10:31:23.867]                 }
[10:31:23.867]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.867]                 "immediateCondition"))) {
[10:31:23.867]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.867]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.867]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.867]                   if (TRUE && !signal) {
[10:31:23.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.867]                     {
[10:31:23.867]                       inherits <- base::inherits
[10:31:23.867]                       invokeRestart <- base::invokeRestart
[10:31:23.867]                       is.null <- base::is.null
[10:31:23.867]                       muffled <- FALSE
[10:31:23.867]                       if (inherits(cond, "message")) {
[10:31:23.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.867]                         if (muffled) 
[10:31:23.867]                           invokeRestart("muffleMessage")
[10:31:23.867]                       }
[10:31:23.867]                       else if (inherits(cond, "warning")) {
[10:31:23.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.867]                         if (muffled) 
[10:31:23.867]                           invokeRestart("muffleWarning")
[10:31:23.867]                       }
[10:31:23.867]                       else if (inherits(cond, "condition")) {
[10:31:23.867]                         if (!is.null(pattern)) {
[10:31:23.867]                           computeRestarts <- base::computeRestarts
[10:31:23.867]                           grepl <- base::grepl
[10:31:23.867]                           restarts <- computeRestarts(cond)
[10:31:23.867]                           for (restart in restarts) {
[10:31:23.867]                             name <- restart$name
[10:31:23.867]                             if (is.null(name)) 
[10:31:23.867]                               next
[10:31:23.867]                             if (!grepl(pattern, name)) 
[10:31:23.867]                               next
[10:31:23.867]                             invokeRestart(restart)
[10:31:23.867]                             muffled <- TRUE
[10:31:23.867]                             break
[10:31:23.867]                           }
[10:31:23.867]                         }
[10:31:23.867]                       }
[10:31:23.867]                       invisible(muffled)
[10:31:23.867]                     }
[10:31:23.867]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.867]                   }
[10:31:23.867]                 }
[10:31:23.867]                 else {
[10:31:23.867]                   if (TRUE) {
[10:31:23.867]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.867]                     {
[10:31:23.867]                       inherits <- base::inherits
[10:31:23.867]                       invokeRestart <- base::invokeRestart
[10:31:23.867]                       is.null <- base::is.null
[10:31:23.867]                       muffled <- FALSE
[10:31:23.867]                       if (inherits(cond, "message")) {
[10:31:23.867]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.867]                         if (muffled) 
[10:31:23.867]                           invokeRestart("muffleMessage")
[10:31:23.867]                       }
[10:31:23.867]                       else if (inherits(cond, "warning")) {
[10:31:23.867]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.867]                         if (muffled) 
[10:31:23.867]                           invokeRestart("muffleWarning")
[10:31:23.867]                       }
[10:31:23.867]                       else if (inherits(cond, "condition")) {
[10:31:23.867]                         if (!is.null(pattern)) {
[10:31:23.867]                           computeRestarts <- base::computeRestarts
[10:31:23.867]                           grepl <- base::grepl
[10:31:23.867]                           restarts <- computeRestarts(cond)
[10:31:23.867]                           for (restart in restarts) {
[10:31:23.867]                             name <- restart$name
[10:31:23.867]                             if (is.null(name)) 
[10:31:23.867]                               next
[10:31:23.867]                             if (!grepl(pattern, name)) 
[10:31:23.867]                               next
[10:31:23.867]                             invokeRestart(restart)
[10:31:23.867]                             muffled <- TRUE
[10:31:23.867]                             break
[10:31:23.867]                           }
[10:31:23.867]                         }
[10:31:23.867]                       }
[10:31:23.867]                       invisible(muffled)
[10:31:23.867]                     }
[10:31:23.867]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.867]                   }
[10:31:23.867]                 }
[10:31:23.867]             }
[10:31:23.867]         }))
[10:31:23.867]     }, error = function(ex) {
[10:31:23.867]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.867]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.867]                 ...future.rng), started = ...future.startTime, 
[10:31:23.867]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.867]             version = "1.8"), class = "FutureResult")
[10:31:23.867]     }, finally = {
[10:31:23.867]         if (!identical(...future.workdir, getwd())) 
[10:31:23.867]             setwd(...future.workdir)
[10:31:23.867]         {
[10:31:23.867]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.867]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.867]             }
[10:31:23.867]             base::options(...future.oldOptions)
[10:31:23.867]             if (.Platform$OS.type == "windows") {
[10:31:23.867]                 old_names <- names(...future.oldEnvVars)
[10:31:23.867]                 envs <- base::Sys.getenv()
[10:31:23.867]                 names <- names(envs)
[10:31:23.867]                 common <- intersect(names, old_names)
[10:31:23.867]                 added <- setdiff(names, old_names)
[10:31:23.867]                 removed <- setdiff(old_names, names)
[10:31:23.867]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.867]                   envs[common]]
[10:31:23.867]                 NAMES <- toupper(changed)
[10:31:23.867]                 args <- list()
[10:31:23.867]                 for (kk in seq_along(NAMES)) {
[10:31:23.867]                   name <- changed[[kk]]
[10:31:23.867]                   NAME <- NAMES[[kk]]
[10:31:23.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.867]                     next
[10:31:23.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.867]                 }
[10:31:23.867]                 NAMES <- toupper(added)
[10:31:23.867]                 for (kk in seq_along(NAMES)) {
[10:31:23.867]                   name <- added[[kk]]
[10:31:23.867]                   NAME <- NAMES[[kk]]
[10:31:23.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.867]                     next
[10:31:23.867]                   args[[name]] <- ""
[10:31:23.867]                 }
[10:31:23.867]                 NAMES <- toupper(removed)
[10:31:23.867]                 for (kk in seq_along(NAMES)) {
[10:31:23.867]                   name <- removed[[kk]]
[10:31:23.867]                   NAME <- NAMES[[kk]]
[10:31:23.867]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.867]                     next
[10:31:23.867]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.867]                 }
[10:31:23.867]                 if (length(args) > 0) 
[10:31:23.867]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.867]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.867]             }
[10:31:23.867]             else {
[10:31:23.867]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.867]             }
[10:31:23.867]             {
[10:31:23.867]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.867]                   0L) {
[10:31:23.867]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.867]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.867]                   base::options(opts)
[10:31:23.867]                 }
[10:31:23.867]                 {
[10:31:23.867]                   {
[10:31:23.867]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.867]                     NULL
[10:31:23.867]                   }
[10:31:23.867]                   options(future.plan = NULL)
[10:31:23.867]                   if (is.na(NA_character_)) 
[10:31:23.867]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.867]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.867]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.867]                     .init = FALSE)
[10:31:23.867]                 }
[10:31:23.867]             }
[10:31:23.867]         }
[10:31:23.867]     })
[10:31:23.867]     if (TRUE) {
[10:31:23.867]         base::sink(type = "output", split = FALSE)
[10:31:23.867]         if (TRUE) {
[10:31:23.867]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.867]         }
[10:31:23.867]         else {
[10:31:23.867]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.867]         }
[10:31:23.867]         base::close(...future.stdout)
[10:31:23.867]         ...future.stdout <- NULL
[10:31:23.867]     }
[10:31:23.867]     ...future.result$conditions <- ...future.conditions
[10:31:23.867]     ...future.result$finished <- base::Sys.time()
[10:31:23.867]     ...future.result
[10:31:23.867] }
[10:31:23.870] assign_globals() ...
[10:31:23.870] List of 11
[10:31:23.870]  $ ...future.FUN            :function (x, ...)  
[10:31:23.870]  $ x_FUN                    :function (x, na.rm = TRUE)  
[10:31:23.870]  $ times                    : int 5
[10:31:23.870]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.870]  $ stop_if_not              :function (...)  
[10:31:23.870]  $ dim                      : NULL
[10:31:23.870]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:23.870]  $ future.call.arguments    : list()
[10:31:23.870]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.870]  $ ...future.elements_ii    :List of 4
[10:31:23.870]   ..$ : int [1:3] 1 2 3
[10:31:23.870]   ..$ : int [1:4] 1 2 3 4
[10:31:23.870]   ..$ : int [1:5] 1 2 3 4 5
[10:31:23.870]   ..$ : int [1:6] 1 2 3 4 5 6
[10:31:23.870]  $ ...future.seeds_ii       : NULL
[10:31:23.870]  $ ...future.globals.maxSize: NULL
[10:31:23.870]  - attr(*, "where")=List of 11
[10:31:23.870]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.870]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:23.870]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:23.870]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:23.870]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:23.870]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:23.870]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:23.870]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.870]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.870]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.870]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.870]  - attr(*, "resolved")= logi FALSE
[10:31:23.870]  - attr(*, "total_size")= num 141240
[10:31:23.870]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.870]  - attr(*, "already-done")= logi TRUE
[10:31:23.881] - copied ‘...future.FUN’ to environment
[10:31:23.882] - copied ‘x_FUN’ to environment
[10:31:23.882] - copied ‘times’ to environment
[10:31:23.882] - copied ‘stopf’ to environment
[10:31:23.882] - copied ‘stop_if_not’ to environment
[10:31:23.882] - copied ‘dim’ to environment
[10:31:23.882] - copied ‘valid_types’ to environment
[10:31:23.882] - copied ‘future.call.arguments’ to environment
[10:31:23.882] - copied ‘...future.elements_ii’ to environment
[10:31:23.882] - copied ‘...future.seeds_ii’ to environment
[10:31:23.883] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.883] assign_globals() ... done
[10:31:23.883] requestCore(): workers = 2
[10:31:23.885] MulticoreFuture started
[10:31:23.885] - Launch lazy future ... done
[10:31:23.886] run() for ‘MulticoreFuture’ ... done
[10:31:23.886] Created future:
[10:31:23.887] plan(): Setting new future strategy stack:
[10:31:23.887] List of future strategies:
[10:31:23.887] 1. sequential:
[10:31:23.887]    - args: function (..., envir = parent.frame())
[10:31:23.887]    - tweaked: FALSE
[10:31:23.887]    - call: NULL
[10:31:23.888] plan(): nbrOfWorkers() = 1
[10:31:23.890] plan(): Setting new future strategy stack:
[10:31:23.890] List of future strategies:
[10:31:23.890] 1. multicore:
[10:31:23.890]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.890]    - tweaked: FALSE
[10:31:23.890]    - call: plan(strategy)
[10:31:23.896] plan(): nbrOfWorkers() = 2
[10:31:23.886] MulticoreFuture:
[10:31:23.886] Label: ‘future_vapply-1’
[10:31:23.886] Expression:
[10:31:23.886] {
[10:31:23.886]     do.call(function(...) {
[10:31:23.886]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.886]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.886]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.886]             on.exit(options(oopts), add = TRUE)
[10:31:23.886]         }
[10:31:23.886]         {
[10:31:23.886]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.886]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.886]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.886]             })
[10:31:23.886]         }
[10:31:23.886]     }, args = future.call.arguments)
[10:31:23.886] }
[10:31:23.886] Lazy evaluation: FALSE
[10:31:23.886] Asynchronous evaluation: TRUE
[10:31:23.886] Local evaluation: TRUE
[10:31:23.886] Environment: R_GlobalEnv
[10:31:23.886] Capture standard output: TRUE
[10:31:23.886] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.886] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:23.886] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:31:23.886] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.886] Resolved: TRUE
[10:31:23.886] Value: <not collected>
[10:31:23.886] Conditions captured: <none>
[10:31:23.886] Early signaling: FALSE
[10:31:23.886] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.886] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.897] Chunk #1 of 2 ... DONE
[10:31:23.897] Chunk #2 of 2 ...
[10:31:23.897]  - Finding globals in 'X' for chunk #2 ...
[10:31:23.897] getGlobalsAndPackages() ...
[10:31:23.897] Searching for globals...
[10:31:23.898] 
[10:31:23.898] Searching for globals ... DONE
[10:31:23.898] - globals: [0] <none>
[10:31:23.898] getGlobalsAndPackages() ... DONE
[10:31:23.899]    + additional globals found: [n=0] 
[10:31:23.899]    + additional namespaces needed: [n=0] 
[10:31:23.899]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:23.899]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.899]  - seeds: <none>
[10:31:23.899]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.899] getGlobalsAndPackages() ...
[10:31:23.900] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.900] Resolving globals: FALSE
[10:31:23.900] Tweak future expression to call with '...' arguments ...
[10:31:23.900] {
[10:31:23.900]     do.call(function(...) {
[10:31:23.900]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.900]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.900]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.900]             on.exit(options(oopts), add = TRUE)
[10:31:23.900]         }
[10:31:23.900]         {
[10:31:23.900]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.900]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.900]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.900]             })
[10:31:23.900]         }
[10:31:23.900]     }, args = future.call.arguments)
[10:31:23.900] }
[10:31:23.901] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.901] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.902] - packages: [2] ‘stats’, ‘future.apply’
[10:31:23.902] getGlobalsAndPackages() ... DONE
[10:31:23.902] run() for ‘Future’ ...
[10:31:23.903] - state: ‘created’
[10:31:23.903] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:23.907] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.908] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:23.908]   - Field: ‘label’
[10:31:23.908]   - Field: ‘local’
[10:31:23.908]   - Field: ‘owner’
[10:31:23.911]   - Field: ‘envir’
[10:31:23.911]   - Field: ‘workers’
[10:31:23.912]   - Field: ‘packages’
[10:31:23.912]   - Field: ‘gc’
[10:31:23.912]   - Field: ‘job’
[10:31:23.912]   - Field: ‘conditions’
[10:31:23.913]   - Field: ‘expr’
[10:31:23.913]   - Field: ‘uuid’
[10:31:23.913]   - Field: ‘seed’
[10:31:23.914]   - Field: ‘version’
[10:31:23.914]   - Field: ‘result’
[10:31:23.914]   - Field: ‘asynchronous’
[10:31:23.914]   - Field: ‘calls’
[10:31:23.915]   - Field: ‘globals’
[10:31:23.915]   - Field: ‘stdout’
[10:31:23.915]   - Field: ‘earlySignal’
[10:31:23.915]   - Field: ‘lazy’
[10:31:23.916]   - Field: ‘state’
[10:31:23.916] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:23.916] - Launch lazy future ...
[10:31:23.917] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:31:23.917] Packages needed by future strategies (n = 0): <none>
[10:31:23.918] {
[10:31:23.918]     {
[10:31:23.918]         {
[10:31:23.918]             ...future.startTime <- base::Sys.time()
[10:31:23.918]             {
[10:31:23.918]                 {
[10:31:23.918]                   {
[10:31:23.918]                     {
[10:31:23.918]                       {
[10:31:23.918]                         base::local({
[10:31:23.918]                           has_future <- base::requireNamespace("future", 
[10:31:23.918]                             quietly = TRUE)
[10:31:23.918]                           if (has_future) {
[10:31:23.918]                             ns <- base::getNamespace("future")
[10:31:23.918]                             version <- ns[[".package"]][["version"]]
[10:31:23.918]                             if (is.null(version)) 
[10:31:23.918]                               version <- utils::packageVersion("future")
[10:31:23.918]                           }
[10:31:23.918]                           else {
[10:31:23.918]                             version <- NULL
[10:31:23.918]                           }
[10:31:23.918]                           if (!has_future || version < "1.8.0") {
[10:31:23.918]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:23.918]                               "", base::R.version$version.string), 
[10:31:23.918]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:23.918]                                 base::R.version$platform, 8 * 
[10:31:23.918]                                   base::.Machine$sizeof.pointer), 
[10:31:23.918]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:23.918]                                 "release", "version")], collapse = " "), 
[10:31:23.918]                               hostname = base::Sys.info()[["nodename"]])
[10:31:23.918]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:23.918]                               info)
[10:31:23.918]                             info <- base::paste(info, collapse = "; ")
[10:31:23.918]                             if (!has_future) {
[10:31:23.918]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:23.918]                                 info)
[10:31:23.918]                             }
[10:31:23.918]                             else {
[10:31:23.918]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:23.918]                                 info, version)
[10:31:23.918]                             }
[10:31:23.918]                             base::stop(msg)
[10:31:23.918]                           }
[10:31:23.918]                         })
[10:31:23.918]                       }
[10:31:23.918]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:23.918]                       base::options(mc.cores = 1L)
[10:31:23.918]                     }
[10:31:23.918]                     base::local({
[10:31:23.918]                       for (pkg in c("stats", "future.apply")) {
[10:31:23.918]                         base::loadNamespace(pkg)
[10:31:23.918]                         base::library(pkg, character.only = TRUE)
[10:31:23.918]                       }
[10:31:23.918]                     })
[10:31:23.918]                   }
[10:31:23.918]                   ...future.strategy.old <- future::plan("list")
[10:31:23.918]                   options(future.plan = NULL)
[10:31:23.918]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.918]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:23.918]                 }
[10:31:23.918]                 ...future.workdir <- getwd()
[10:31:23.918]             }
[10:31:23.918]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:23.918]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:23.918]         }
[10:31:23.918]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:23.918]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:23.918]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:23.918]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:23.918]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:23.918]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:23.918]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:23.918]             base::names(...future.oldOptions))
[10:31:23.918]     }
[10:31:23.918]     if (FALSE) {
[10:31:23.918]     }
[10:31:23.918]     else {
[10:31:23.918]         if (TRUE) {
[10:31:23.918]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:23.918]                 open = "w")
[10:31:23.918]         }
[10:31:23.918]         else {
[10:31:23.918]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:23.918]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:23.918]         }
[10:31:23.918]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:23.918]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:23.918]             base::sink(type = "output", split = FALSE)
[10:31:23.918]             base::close(...future.stdout)
[10:31:23.918]         }, add = TRUE)
[10:31:23.918]     }
[10:31:23.918]     ...future.frame <- base::sys.nframe()
[10:31:23.918]     ...future.conditions <- base::list()
[10:31:23.918]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:23.918]     if (FALSE) {
[10:31:23.918]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:23.918]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:23.918]     }
[10:31:23.918]     ...future.result <- base::tryCatch({
[10:31:23.918]         base::withCallingHandlers({
[10:31:23.918]             ...future.value <- base::withVisible(base::local({
[10:31:23.918]                 withCallingHandlers({
[10:31:23.918]                   {
[10:31:23.918]                     do.call(function(...) {
[10:31:23.918]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.918]                       if (!identical(...future.globals.maxSize.org, 
[10:31:23.918]                         ...future.globals.maxSize)) {
[10:31:23.918]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.918]                         on.exit(options(oopts), add = TRUE)
[10:31:23.918]                       }
[10:31:23.918]                       {
[10:31:23.918]                         lapply(seq_along(...future.elements_ii), 
[10:31:23.918]                           FUN = function(jj) {
[10:31:23.918]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.918]                             ...future.FUN(...future.X_jj, ...)
[10:31:23.918]                           })
[10:31:23.918]                       }
[10:31:23.918]                     }, args = future.call.arguments)
[10:31:23.918]                   }
[10:31:23.918]                 }, immediateCondition = function(cond) {
[10:31:23.918]                   save_rds <- function (object, pathname, ...) 
[10:31:23.918]                   {
[10:31:23.918]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:23.918]                     if (file_test("-f", pathname_tmp)) {
[10:31:23.918]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.918]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:23.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.918]                         fi_tmp[["mtime"]])
[10:31:23.918]                     }
[10:31:23.918]                     tryCatch({
[10:31:23.918]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:23.918]                     }, error = function(ex) {
[10:31:23.918]                       msg <- conditionMessage(ex)
[10:31:23.918]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.918]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:23.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.918]                         fi_tmp[["mtime"]], msg)
[10:31:23.918]                       ex$message <- msg
[10:31:23.918]                       stop(ex)
[10:31:23.918]                     })
[10:31:23.918]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:23.918]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:23.918]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:23.918]                       fi_tmp <- file.info(pathname_tmp)
[10:31:23.918]                       fi <- file.info(pathname)
[10:31:23.918]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:23.918]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:23.918]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:23.918]                         fi[["size"]], fi[["mtime"]])
[10:31:23.918]                       stop(msg)
[10:31:23.918]                     }
[10:31:23.918]                     invisible(pathname)
[10:31:23.918]                   }
[10:31:23.918]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:23.918]                     rootPath = tempdir()) 
[10:31:23.918]                   {
[10:31:23.918]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:23.918]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:23.918]                       tmpdir = path, fileext = ".rds")
[10:31:23.918]                     save_rds(obj, file)
[10:31:23.918]                   }
[10:31:23.918]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:23.918]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.918]                   {
[10:31:23.918]                     inherits <- base::inherits
[10:31:23.918]                     invokeRestart <- base::invokeRestart
[10:31:23.918]                     is.null <- base::is.null
[10:31:23.918]                     muffled <- FALSE
[10:31:23.918]                     if (inherits(cond, "message")) {
[10:31:23.918]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:23.918]                       if (muffled) 
[10:31:23.918]                         invokeRestart("muffleMessage")
[10:31:23.918]                     }
[10:31:23.918]                     else if (inherits(cond, "warning")) {
[10:31:23.918]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:23.918]                       if (muffled) 
[10:31:23.918]                         invokeRestart("muffleWarning")
[10:31:23.918]                     }
[10:31:23.918]                     else if (inherits(cond, "condition")) {
[10:31:23.918]                       if (!is.null(pattern)) {
[10:31:23.918]                         computeRestarts <- base::computeRestarts
[10:31:23.918]                         grepl <- base::grepl
[10:31:23.918]                         restarts <- computeRestarts(cond)
[10:31:23.918]                         for (restart in restarts) {
[10:31:23.918]                           name <- restart$name
[10:31:23.918]                           if (is.null(name)) 
[10:31:23.918]                             next
[10:31:23.918]                           if (!grepl(pattern, name)) 
[10:31:23.918]                             next
[10:31:23.918]                           invokeRestart(restart)
[10:31:23.918]                           muffled <- TRUE
[10:31:23.918]                           break
[10:31:23.918]                         }
[10:31:23.918]                       }
[10:31:23.918]                     }
[10:31:23.918]                     invisible(muffled)
[10:31:23.918]                   }
[10:31:23.918]                   muffleCondition(cond)
[10:31:23.918]                 })
[10:31:23.918]             }))
[10:31:23.918]             future::FutureResult(value = ...future.value$value, 
[10:31:23.918]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.918]                   ...future.rng), globalenv = if (FALSE) 
[10:31:23.918]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:23.918]                     ...future.globalenv.names))
[10:31:23.918]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:23.918]         }, condition = base::local({
[10:31:23.918]             c <- base::c
[10:31:23.918]             inherits <- base::inherits
[10:31:23.918]             invokeRestart <- base::invokeRestart
[10:31:23.918]             length <- base::length
[10:31:23.918]             list <- base::list
[10:31:23.918]             seq.int <- base::seq.int
[10:31:23.918]             signalCondition <- base::signalCondition
[10:31:23.918]             sys.calls <- base::sys.calls
[10:31:23.918]             `[[` <- base::`[[`
[10:31:23.918]             `+` <- base::`+`
[10:31:23.918]             `<<-` <- base::`<<-`
[10:31:23.918]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:23.918]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:23.918]                   3L)]
[10:31:23.918]             }
[10:31:23.918]             function(cond) {
[10:31:23.918]                 is_error <- inherits(cond, "error")
[10:31:23.918]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:23.918]                   NULL)
[10:31:23.918]                 if (is_error) {
[10:31:23.918]                   sessionInformation <- function() {
[10:31:23.918]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:23.918]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:23.918]                       search = base::search(), system = base::Sys.info())
[10:31:23.918]                   }
[10:31:23.918]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.918]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:23.918]                     cond$call), session = sessionInformation(), 
[10:31:23.918]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:23.918]                   signalCondition(cond)
[10:31:23.918]                 }
[10:31:23.918]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:23.918]                 "immediateCondition"))) {
[10:31:23.918]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:23.918]                   ...future.conditions[[length(...future.conditions) + 
[10:31:23.918]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:23.918]                   if (TRUE && !signal) {
[10:31:23.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.918]                     {
[10:31:23.918]                       inherits <- base::inherits
[10:31:23.918]                       invokeRestart <- base::invokeRestart
[10:31:23.918]                       is.null <- base::is.null
[10:31:23.918]                       muffled <- FALSE
[10:31:23.918]                       if (inherits(cond, "message")) {
[10:31:23.918]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.918]                         if (muffled) 
[10:31:23.918]                           invokeRestart("muffleMessage")
[10:31:23.918]                       }
[10:31:23.918]                       else if (inherits(cond, "warning")) {
[10:31:23.918]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.918]                         if (muffled) 
[10:31:23.918]                           invokeRestart("muffleWarning")
[10:31:23.918]                       }
[10:31:23.918]                       else if (inherits(cond, "condition")) {
[10:31:23.918]                         if (!is.null(pattern)) {
[10:31:23.918]                           computeRestarts <- base::computeRestarts
[10:31:23.918]                           grepl <- base::grepl
[10:31:23.918]                           restarts <- computeRestarts(cond)
[10:31:23.918]                           for (restart in restarts) {
[10:31:23.918]                             name <- restart$name
[10:31:23.918]                             if (is.null(name)) 
[10:31:23.918]                               next
[10:31:23.918]                             if (!grepl(pattern, name)) 
[10:31:23.918]                               next
[10:31:23.918]                             invokeRestart(restart)
[10:31:23.918]                             muffled <- TRUE
[10:31:23.918]                             break
[10:31:23.918]                           }
[10:31:23.918]                         }
[10:31:23.918]                       }
[10:31:23.918]                       invisible(muffled)
[10:31:23.918]                     }
[10:31:23.918]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.918]                   }
[10:31:23.918]                 }
[10:31:23.918]                 else {
[10:31:23.918]                   if (TRUE) {
[10:31:23.918]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:23.918]                     {
[10:31:23.918]                       inherits <- base::inherits
[10:31:23.918]                       invokeRestart <- base::invokeRestart
[10:31:23.918]                       is.null <- base::is.null
[10:31:23.918]                       muffled <- FALSE
[10:31:23.918]                       if (inherits(cond, "message")) {
[10:31:23.918]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:23.918]                         if (muffled) 
[10:31:23.918]                           invokeRestart("muffleMessage")
[10:31:23.918]                       }
[10:31:23.918]                       else if (inherits(cond, "warning")) {
[10:31:23.918]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:23.918]                         if (muffled) 
[10:31:23.918]                           invokeRestart("muffleWarning")
[10:31:23.918]                       }
[10:31:23.918]                       else if (inherits(cond, "condition")) {
[10:31:23.918]                         if (!is.null(pattern)) {
[10:31:23.918]                           computeRestarts <- base::computeRestarts
[10:31:23.918]                           grepl <- base::grepl
[10:31:23.918]                           restarts <- computeRestarts(cond)
[10:31:23.918]                           for (restart in restarts) {
[10:31:23.918]                             name <- restart$name
[10:31:23.918]                             if (is.null(name)) 
[10:31:23.918]                               next
[10:31:23.918]                             if (!grepl(pattern, name)) 
[10:31:23.918]                               next
[10:31:23.918]                             invokeRestart(restart)
[10:31:23.918]                             muffled <- TRUE
[10:31:23.918]                             break
[10:31:23.918]                           }
[10:31:23.918]                         }
[10:31:23.918]                       }
[10:31:23.918]                       invisible(muffled)
[10:31:23.918]                     }
[10:31:23.918]                     muffleCondition(cond, pattern = "^muffle")
[10:31:23.918]                   }
[10:31:23.918]                 }
[10:31:23.918]             }
[10:31:23.918]         }))
[10:31:23.918]     }, error = function(ex) {
[10:31:23.918]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:23.918]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:23.918]                 ...future.rng), started = ...future.startTime, 
[10:31:23.918]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:23.918]             version = "1.8"), class = "FutureResult")
[10:31:23.918]     }, finally = {
[10:31:23.918]         if (!identical(...future.workdir, getwd())) 
[10:31:23.918]             setwd(...future.workdir)
[10:31:23.918]         {
[10:31:23.918]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:23.918]                 ...future.oldOptions$nwarnings <- NULL
[10:31:23.918]             }
[10:31:23.918]             base::options(...future.oldOptions)
[10:31:23.918]             if (.Platform$OS.type == "windows") {
[10:31:23.918]                 old_names <- names(...future.oldEnvVars)
[10:31:23.918]                 envs <- base::Sys.getenv()
[10:31:23.918]                 names <- names(envs)
[10:31:23.918]                 common <- intersect(names, old_names)
[10:31:23.918]                 added <- setdiff(names, old_names)
[10:31:23.918]                 removed <- setdiff(old_names, names)
[10:31:23.918]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:23.918]                   envs[common]]
[10:31:23.918]                 NAMES <- toupper(changed)
[10:31:23.918]                 args <- list()
[10:31:23.918]                 for (kk in seq_along(NAMES)) {
[10:31:23.918]                   name <- changed[[kk]]
[10:31:23.918]                   NAME <- NAMES[[kk]]
[10:31:23.918]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.918]                     next
[10:31:23.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.918]                 }
[10:31:23.918]                 NAMES <- toupper(added)
[10:31:23.918]                 for (kk in seq_along(NAMES)) {
[10:31:23.918]                   name <- added[[kk]]
[10:31:23.918]                   NAME <- NAMES[[kk]]
[10:31:23.918]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.918]                     next
[10:31:23.918]                   args[[name]] <- ""
[10:31:23.918]                 }
[10:31:23.918]                 NAMES <- toupper(removed)
[10:31:23.918]                 for (kk in seq_along(NAMES)) {
[10:31:23.918]                   name <- removed[[kk]]
[10:31:23.918]                   NAME <- NAMES[[kk]]
[10:31:23.918]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:23.918]                     next
[10:31:23.918]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:23.918]                 }
[10:31:23.918]                 if (length(args) > 0) 
[10:31:23.918]                   base::do.call(base::Sys.setenv, args = args)
[10:31:23.918]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:23.918]             }
[10:31:23.918]             else {
[10:31:23.918]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:23.918]             }
[10:31:23.918]             {
[10:31:23.918]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:23.918]                   0L) {
[10:31:23.918]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:23.918]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:23.918]                   base::options(opts)
[10:31:23.918]                 }
[10:31:23.918]                 {
[10:31:23.918]                   {
[10:31:23.918]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:23.918]                     NULL
[10:31:23.918]                   }
[10:31:23.918]                   options(future.plan = NULL)
[10:31:23.918]                   if (is.na(NA_character_)) 
[10:31:23.918]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:23.918]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:23.918]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:23.918]                     .init = FALSE)
[10:31:23.918]                 }
[10:31:23.918]             }
[10:31:23.918]         }
[10:31:23.918]     })
[10:31:23.918]     if (TRUE) {
[10:31:23.918]         base::sink(type = "output", split = FALSE)
[10:31:23.918]         if (TRUE) {
[10:31:23.918]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:23.918]         }
[10:31:23.918]         else {
[10:31:23.918]             ...future.result["stdout"] <- base::list(NULL)
[10:31:23.918]         }
[10:31:23.918]         base::close(...future.stdout)
[10:31:23.918]         ...future.stdout <- NULL
[10:31:23.918]     }
[10:31:23.918]     ...future.result$conditions <- ...future.conditions
[10:31:23.918]     ...future.result$finished <- base::Sys.time()
[10:31:23.918]     ...future.result
[10:31:23.918] }
[10:31:23.922] assign_globals() ...
[10:31:23.922] List of 11
[10:31:23.922]  $ ...future.FUN            :function (x, ...)  
[10:31:23.922]  $ x_FUN                    :function (x, na.rm = TRUE)  
[10:31:23.922]  $ times                    : int 5
[10:31:23.922]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:23.922]  $ stop_if_not              :function (...)  
[10:31:23.922]  $ dim                      : NULL
[10:31:23.922]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:23.922]  $ future.call.arguments    : list()
[10:31:23.922]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.922]  $ ...future.elements_ii    :List of 3
[10:31:23.922]   ..$ : int [1:7] 1 2 3 4 5 6 7
[10:31:23.922]   ..$ : int [1:8] 1 2 3 4 5 6 7 8
[10:31:23.922]   ..$ : int [1:9] 1 2 3 4 5 6 7 8 9
[10:31:23.922]  $ ...future.seeds_ii       : NULL
[10:31:23.922]  $ ...future.globals.maxSize: NULL
[10:31:23.922]  - attr(*, "where")=List of 11
[10:31:23.922]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:23.922]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:23.922]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:23.922]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:23.922]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:23.922]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:23.922]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:23.922]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:23.922]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:23.922]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:23.922]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:23.922]  - attr(*, "resolved")= logi FALSE
[10:31:23.922]  - attr(*, "total_size")= num 141240
[10:31:23.922]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.922]  - attr(*, "already-done")= logi TRUE
[10:31:23.934] - copied ‘...future.FUN’ to environment
[10:31:23.934] - copied ‘x_FUN’ to environment
[10:31:23.934] - copied ‘times’ to environment
[10:31:23.934] - copied ‘stopf’ to environment
[10:31:23.934] - copied ‘stop_if_not’ to environment
[10:31:23.934] - copied ‘dim’ to environment
[10:31:23.934] - copied ‘valid_types’ to environment
[10:31:23.934] - copied ‘future.call.arguments’ to environment
[10:31:23.935] - copied ‘...future.elements_ii’ to environment
[10:31:23.935] - copied ‘...future.seeds_ii’ to environment
[10:31:23.935] - copied ‘...future.globals.maxSize’ to environment
[10:31:23.935] assign_globals() ... done
[10:31:23.935] requestCore(): workers = 2
[10:31:23.937] MulticoreFuture started
[10:31:23.938] - Launch lazy future ... done
[10:31:23.938] run() for ‘MulticoreFuture’ ... done
[10:31:23.938] Created future:
[10:31:23.939] plan(): Setting new future strategy stack:
[10:31:23.939] List of future strategies:
[10:31:23.939] 1. sequential:
[10:31:23.939]    - args: function (..., envir = parent.frame())
[10:31:23.939]    - tweaked: FALSE
[10:31:23.939]    - call: NULL
[10:31:23.940] plan(): nbrOfWorkers() = 1
[10:31:23.942] plan(): Setting new future strategy stack:
[10:31:23.942] List of future strategies:
[10:31:23.942] 1. multicore:
[10:31:23.942]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:23.942]    - tweaked: FALSE
[10:31:23.942]    - call: plan(strategy)
[10:31:23.947] plan(): nbrOfWorkers() = 2
[10:31:23.938] MulticoreFuture:
[10:31:23.938] Label: ‘future_vapply-2’
[10:31:23.938] Expression:
[10:31:23.938] {
[10:31:23.938]     do.call(function(...) {
[10:31:23.938]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.938]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.938]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.938]             on.exit(options(oopts), add = TRUE)
[10:31:23.938]         }
[10:31:23.938]         {
[10:31:23.938]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.938]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.938]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.938]             })
[10:31:23.938]         }
[10:31:23.938]     }, args = future.call.arguments)
[10:31:23.938] }
[10:31:23.938] Lazy evaluation: FALSE
[10:31:23.938] Asynchronous evaluation: TRUE
[10:31:23.938] Local evaluation: TRUE
[10:31:23.938] Environment: R_GlobalEnv
[10:31:23.938] Capture standard output: TRUE
[10:31:23.938] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:23.938] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:23.938] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:31:23.938] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:23.938] Resolved: TRUE
[10:31:23.938] Value: <not collected>
[10:31:23.938] Conditions captured: <none>
[10:31:23.938] Early signaling: FALSE
[10:31:23.938] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:23.938] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:23.949] Chunk #2 of 2 ... DONE
[10:31:23.949] Launching 2 futures (chunks) ... DONE
[10:31:23.949] Resolving 2 futures (chunks) ...
[10:31:23.949] resolve() on list ...
[10:31:23.949]  recursive: 0
[10:31:23.949]  length: 2
[10:31:23.949] 
[10:31:23.950] Future #1
[10:31:23.950] result() for MulticoreFuture ...
[10:31:23.951] result() for MulticoreFuture ...
[10:31:23.951] result() for MulticoreFuture ... done
[10:31:23.951] result() for MulticoreFuture ... done
[10:31:23.951] result() for MulticoreFuture ...
[10:31:23.951] result() for MulticoreFuture ... done
[10:31:23.952] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:23.952] - nx: 2
[10:31:23.952] - relay: TRUE
[10:31:23.960] - stdout: TRUE
[10:31:23.960] - signal: TRUE
[10:31:23.961] - resignal: FALSE
[10:31:23.961] - force: TRUE
[10:31:23.961] - relayed: [n=2] FALSE, FALSE
[10:31:23.961] - queued futures: [n=2] FALSE, FALSE
[10:31:23.961]  - until=1
[10:31:23.961]  - relaying element #1
[10:31:23.961] result() for MulticoreFuture ...
[10:31:23.961] result() for MulticoreFuture ... done
[10:31:23.961] result() for MulticoreFuture ...
[10:31:23.962] result() for MulticoreFuture ... done
[10:31:23.962] result() for MulticoreFuture ...
[10:31:23.962] result() for MulticoreFuture ... done
[10:31:23.962] result() for MulticoreFuture ...
[10:31:23.963] result() for MulticoreFuture ... done
[10:31:23.963] - relayed: [n=2] TRUE, FALSE
[10:31:23.963] - queued futures: [n=2] TRUE, FALSE
[10:31:23.963] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:23.963]  length: 1 (resolved future 1)
[10:31:23.964] Future #2
[10:31:23.964] result() for MulticoreFuture ...
[10:31:23.965] result() for MulticoreFuture ...
[10:31:23.965] result() for MulticoreFuture ... done
[10:31:23.966] result() for MulticoreFuture ... done
[10:31:23.966] result() for MulticoreFuture ...
[10:31:23.966] result() for MulticoreFuture ... done
[10:31:23.966] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:23.966] - nx: 2
[10:31:23.967] - relay: TRUE
[10:31:23.967] - stdout: TRUE
[10:31:23.967] - signal: TRUE
[10:31:23.967] - resignal: FALSE
[10:31:23.967] - force: TRUE
[10:31:23.967] - relayed: [n=2] TRUE, FALSE
[10:31:23.967] - queued futures: [n=2] TRUE, FALSE
[10:31:23.968]  - until=2
[10:31:23.968]  - relaying element #2
[10:31:23.968] result() for MulticoreFuture ...
[10:31:23.968] result() for MulticoreFuture ... done
[10:31:23.968] result() for MulticoreFuture ...
[10:31:23.968] result() for MulticoreFuture ... done
[10:31:23.969] result() for MulticoreFuture ...
[10:31:23.969] result() for MulticoreFuture ... done
[10:31:23.969] result() for MulticoreFuture ...
[10:31:23.969] result() for MulticoreFuture ... done
[10:31:23.969] - relayed: [n=2] TRUE, TRUE
[10:31:23.969] - queued futures: [n=2] TRUE, TRUE
[10:31:23.969] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:23.970]  length: 0 (resolved future 2)
[10:31:23.970] Relaying remaining futures
[10:31:23.970] signalConditionsASAP(NULL, pos=0) ...
[10:31:23.970] - nx: 2
[10:31:23.970] - relay: TRUE
[10:31:23.970] - stdout: TRUE
[10:31:23.970] - signal: TRUE
[10:31:23.970] - resignal: FALSE
[10:31:23.970] - force: TRUE
[10:31:23.971] - relayed: [n=2] TRUE, TRUE
[10:31:23.971] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:23.971] - relayed: [n=2] TRUE, TRUE
[10:31:23.971] - queued futures: [n=2] TRUE, TRUE
[10:31:23.971] signalConditionsASAP(NULL, pos=0) ... done
[10:31:23.971] resolve() on list ... DONE
[10:31:23.971] result() for MulticoreFuture ...
[10:31:23.971] result() for MulticoreFuture ... done
[10:31:23.971] result() for MulticoreFuture ...
[10:31:23.972] result() for MulticoreFuture ... done
[10:31:23.972] result() for MulticoreFuture ...
[10:31:23.972] result() for MulticoreFuture ... done
[10:31:23.972] result() for MulticoreFuture ...
[10:31:23.972] result() for MulticoreFuture ... done
[10:31:23.972]  - Number of value chunks collected: 2
[10:31:23.972] Resolving 2 futures (chunks) ... DONE
[10:31:23.973] Reducing values from 2 chunks ...
[10:31:23.973]  - Number of values collected after concatenation: 7
[10:31:23.973]  - Number of values expected: 7
[10:31:23.973] Reducing values from 2 chunks ... DONE
[10:31:23.973] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[10:31:23.975] future_lapply() ...
[10:31:23.980] Number of chunks: 2
[10:31:23.980] getGlobalsAndPackagesXApply() ...
[10:31:23.980]  - future.globals: TRUE
[10:31:23.980] getGlobalsAndPackages() ...
[10:31:23.980] Searching for globals...
[10:31:23.982] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[10:31:23.982] Searching for globals ... DONE
[10:31:23.982] Resolving globals: FALSE
[10:31:23.982] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[10:31:23.983] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[10:31:23.983] - globals: [1] ‘FUN’
[10:31:23.983] 
[10:31:23.983] getGlobalsAndPackages() ... DONE
[10:31:23.983]  - globals found/used: [n=1] ‘FUN’
[10:31:23.983]  - needed namespaces: [n=0] 
[10:31:23.984] Finding globals ... DONE
[10:31:23.984]  - use_args: TRUE
[10:31:23.984]  - Getting '...' globals ...
[10:31:23.984] resolve() on list ...
[10:31:23.984]  recursive: 0
[10:31:23.984]  length: 1
[10:31:23.984]  elements: ‘...’
[10:31:23.984]  length: 0 (resolved future 1)
[10:31:23.985] resolve() on list ... DONE
[10:31:23.985]    - '...' content: [n=1] ‘y’
[10:31:23.985] List of 1
[10:31:23.985]  $ ...:List of 1
[10:31:23.985]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:23.985]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.985]  - attr(*, "where")=List of 1
[10:31:23.985]   ..$ ...:<environment: 0x55de8376d1c0> 
[10:31:23.985]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.985]  - attr(*, "resolved")= logi TRUE
[10:31:23.985]  - attr(*, "total_size")= num NA
[10:31:23.990]  - Getting '...' globals ... DONE
[10:31:23.990] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:23.990] List of 2
[10:31:23.990]  $ ...future.FUN:function (x, y)  
[10:31:23.990]  $ ...          :List of 1
[10:31:23.990]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:23.990]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:23.990]  - attr(*, "where")=List of 2
[10:31:23.990]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:23.990]   ..$ ...          :<environment: 0x55de8376d1c0> 
[10:31:23.990]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:23.990]  - attr(*, "resolved")= logi FALSE
[10:31:23.990]  - attr(*, "total_size")= num 4264
[10:31:23.994] Packages to be attached in all futures: [n=0] 
[10:31:23.994] getGlobalsAndPackagesXApply() ... DONE
[10:31:23.994] Number of futures (= number of chunks): 2
[10:31:23.995] Launching 2 futures (chunks) ...
[10:31:23.995] Chunk #1 of 2 ...
[10:31:23.995]  - Finding globals in 'X' for chunk #1 ...
[10:31:23.995] getGlobalsAndPackages() ...
[10:31:23.995] Searching for globals...
[10:31:23.995] 
[10:31:23.996] Searching for globals ... DONE
[10:31:23.996] - globals: [0] <none>
[10:31:23.996] getGlobalsAndPackages() ... DONE
[10:31:23.996]    + additional globals found: [n=0] 
[10:31:23.996]    + additional namespaces needed: [n=0] 
[10:31:23.996]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:23.996]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:23.996]  - seeds: <none>
[10:31:23.996]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.996] getGlobalsAndPackages() ...
[10:31:23.997] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.997] Resolving globals: FALSE
[10:31:23.997] Tweak future expression to call with '...' arguments ...
[10:31:23.997] {
[10:31:23.997]     do.call(function(...) {
[10:31:23.997]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:23.997]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:23.997]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:23.997]             on.exit(options(oopts), add = TRUE)
[10:31:23.997]         }
[10:31:23.997]         {
[10:31:23.997]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:23.997]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:23.997]                 ...future.FUN(...future.X_jj, ...)
[10:31:23.997]             })
[10:31:23.997]         }
[10:31:23.997]     }, args = future.call.arguments)
[10:31:23.997] }
[10:31:23.997] Tweak future expression to call with '...' arguments ... DONE
[10:31:23.998] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:23.998] 
[10:31:23.998] getGlobalsAndPackages() ... DONE
[10:31:23.998] run() for ‘Future’ ...
[10:31:23.998] - state: ‘created’
[10:31:23.998] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:24.002] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.002] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:24.002]   - Field: ‘label’
[10:31:24.003]   - Field: ‘local’
[10:31:24.003]   - Field: ‘owner’
[10:31:24.003]   - Field: ‘envir’
[10:31:24.003]   - Field: ‘workers’
[10:31:24.003]   - Field: ‘packages’
[10:31:24.003]   - Field: ‘gc’
[10:31:24.003]   - Field: ‘job’
[10:31:24.003]   - Field: ‘conditions’
[10:31:24.003]   - Field: ‘expr’
[10:31:24.003]   - Field: ‘uuid’
[10:31:24.004]   - Field: ‘seed’
[10:31:24.004]   - Field: ‘version’
[10:31:24.004]   - Field: ‘result’
[10:31:24.004]   - Field: ‘asynchronous’
[10:31:24.004]   - Field: ‘calls’
[10:31:24.004]   - Field: ‘globals’
[10:31:24.004]   - Field: ‘stdout’
[10:31:24.004]   - Field: ‘earlySignal’
[10:31:24.004]   - Field: ‘lazy’
[10:31:24.004]   - Field: ‘state’
[10:31:24.004] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:24.005] - Launch lazy future ...
[10:31:24.005] Packages needed by the future expression (n = 0): <none>
[10:31:24.005] Packages needed by future strategies (n = 0): <none>
[10:31:24.005] {
[10:31:24.005]     {
[10:31:24.005]         {
[10:31:24.005]             ...future.startTime <- base::Sys.time()
[10:31:24.005]             {
[10:31:24.005]                 {
[10:31:24.005]                   {
[10:31:24.005]                     {
[10:31:24.005]                       base::local({
[10:31:24.005]                         has_future <- base::requireNamespace("future", 
[10:31:24.005]                           quietly = TRUE)
[10:31:24.005]                         if (has_future) {
[10:31:24.005]                           ns <- base::getNamespace("future")
[10:31:24.005]                           version <- ns[[".package"]][["version"]]
[10:31:24.005]                           if (is.null(version)) 
[10:31:24.005]                             version <- utils::packageVersion("future")
[10:31:24.005]                         }
[10:31:24.005]                         else {
[10:31:24.005]                           version <- NULL
[10:31:24.005]                         }
[10:31:24.005]                         if (!has_future || version < "1.8.0") {
[10:31:24.005]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:24.005]                             "", base::R.version$version.string), 
[10:31:24.005]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:24.005]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:24.005]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:24.005]                               "release", "version")], collapse = " "), 
[10:31:24.005]                             hostname = base::Sys.info()[["nodename"]])
[10:31:24.005]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:24.005]                             info)
[10:31:24.005]                           info <- base::paste(info, collapse = "; ")
[10:31:24.005]                           if (!has_future) {
[10:31:24.005]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:24.005]                               info)
[10:31:24.005]                           }
[10:31:24.005]                           else {
[10:31:24.005]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:24.005]                               info, version)
[10:31:24.005]                           }
[10:31:24.005]                           base::stop(msg)
[10:31:24.005]                         }
[10:31:24.005]                       })
[10:31:24.005]                     }
[10:31:24.005]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:24.005]                     base::options(mc.cores = 1L)
[10:31:24.005]                   }
[10:31:24.005]                   ...future.strategy.old <- future::plan("list")
[10:31:24.005]                   options(future.plan = NULL)
[10:31:24.005]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.005]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:24.005]                 }
[10:31:24.005]                 ...future.workdir <- getwd()
[10:31:24.005]             }
[10:31:24.005]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:24.005]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:24.005]         }
[10:31:24.005]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:24.005]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:24.005]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:24.005]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:24.005]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:24.005]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:24.005]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:24.005]             base::names(...future.oldOptions))
[10:31:24.005]     }
[10:31:24.005]     if (FALSE) {
[10:31:24.005]     }
[10:31:24.005]     else {
[10:31:24.005]         if (TRUE) {
[10:31:24.005]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:24.005]                 open = "w")
[10:31:24.005]         }
[10:31:24.005]         else {
[10:31:24.005]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:24.005]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:24.005]         }
[10:31:24.005]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:24.005]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:24.005]             base::sink(type = "output", split = FALSE)
[10:31:24.005]             base::close(...future.stdout)
[10:31:24.005]         }, add = TRUE)
[10:31:24.005]     }
[10:31:24.005]     ...future.frame <- base::sys.nframe()
[10:31:24.005]     ...future.conditions <- base::list()
[10:31:24.005]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:24.005]     if (FALSE) {
[10:31:24.005]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:24.005]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:24.005]     }
[10:31:24.005]     ...future.result <- base::tryCatch({
[10:31:24.005]         base::withCallingHandlers({
[10:31:24.005]             ...future.value <- base::withVisible(base::local({
[10:31:24.005]                 withCallingHandlers({
[10:31:24.005]                   {
[10:31:24.005]                     do.call(function(...) {
[10:31:24.005]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.005]                       if (!identical(...future.globals.maxSize.org, 
[10:31:24.005]                         ...future.globals.maxSize)) {
[10:31:24.005]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.005]                         on.exit(options(oopts), add = TRUE)
[10:31:24.005]                       }
[10:31:24.005]                       {
[10:31:24.005]                         lapply(seq_along(...future.elements_ii), 
[10:31:24.005]                           FUN = function(jj) {
[10:31:24.005]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.005]                             ...future.FUN(...future.X_jj, ...)
[10:31:24.005]                           })
[10:31:24.005]                       }
[10:31:24.005]                     }, args = future.call.arguments)
[10:31:24.005]                   }
[10:31:24.005]                 }, immediateCondition = function(cond) {
[10:31:24.005]                   save_rds <- function (object, pathname, ...) 
[10:31:24.005]                   {
[10:31:24.005]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:24.005]                     if (file_test("-f", pathname_tmp)) {
[10:31:24.005]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.005]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:24.005]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.005]                         fi_tmp[["mtime"]])
[10:31:24.005]                     }
[10:31:24.005]                     tryCatch({
[10:31:24.005]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:24.005]                     }, error = function(ex) {
[10:31:24.005]                       msg <- conditionMessage(ex)
[10:31:24.005]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.005]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:24.005]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.005]                         fi_tmp[["mtime"]], msg)
[10:31:24.005]                       ex$message <- msg
[10:31:24.005]                       stop(ex)
[10:31:24.005]                     })
[10:31:24.005]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:24.005]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:24.005]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:24.005]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.005]                       fi <- file.info(pathname)
[10:31:24.005]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:24.005]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.005]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:24.005]                         fi[["size"]], fi[["mtime"]])
[10:31:24.005]                       stop(msg)
[10:31:24.005]                     }
[10:31:24.005]                     invisible(pathname)
[10:31:24.005]                   }
[10:31:24.005]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:24.005]                     rootPath = tempdir()) 
[10:31:24.005]                   {
[10:31:24.005]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:24.005]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:24.005]                       tmpdir = path, fileext = ".rds")
[10:31:24.005]                     save_rds(obj, file)
[10:31:24.005]                   }
[10:31:24.005]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:24.005]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.005]                   {
[10:31:24.005]                     inherits <- base::inherits
[10:31:24.005]                     invokeRestart <- base::invokeRestart
[10:31:24.005]                     is.null <- base::is.null
[10:31:24.005]                     muffled <- FALSE
[10:31:24.005]                     if (inherits(cond, "message")) {
[10:31:24.005]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:24.005]                       if (muffled) 
[10:31:24.005]                         invokeRestart("muffleMessage")
[10:31:24.005]                     }
[10:31:24.005]                     else if (inherits(cond, "warning")) {
[10:31:24.005]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:24.005]                       if (muffled) 
[10:31:24.005]                         invokeRestart("muffleWarning")
[10:31:24.005]                     }
[10:31:24.005]                     else if (inherits(cond, "condition")) {
[10:31:24.005]                       if (!is.null(pattern)) {
[10:31:24.005]                         computeRestarts <- base::computeRestarts
[10:31:24.005]                         grepl <- base::grepl
[10:31:24.005]                         restarts <- computeRestarts(cond)
[10:31:24.005]                         for (restart in restarts) {
[10:31:24.005]                           name <- restart$name
[10:31:24.005]                           if (is.null(name)) 
[10:31:24.005]                             next
[10:31:24.005]                           if (!grepl(pattern, name)) 
[10:31:24.005]                             next
[10:31:24.005]                           invokeRestart(restart)
[10:31:24.005]                           muffled <- TRUE
[10:31:24.005]                           break
[10:31:24.005]                         }
[10:31:24.005]                       }
[10:31:24.005]                     }
[10:31:24.005]                     invisible(muffled)
[10:31:24.005]                   }
[10:31:24.005]                   muffleCondition(cond)
[10:31:24.005]                 })
[10:31:24.005]             }))
[10:31:24.005]             future::FutureResult(value = ...future.value$value, 
[10:31:24.005]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.005]                   ...future.rng), globalenv = if (FALSE) 
[10:31:24.005]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:24.005]                     ...future.globalenv.names))
[10:31:24.005]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:24.005]         }, condition = base::local({
[10:31:24.005]             c <- base::c
[10:31:24.005]             inherits <- base::inherits
[10:31:24.005]             invokeRestart <- base::invokeRestart
[10:31:24.005]             length <- base::length
[10:31:24.005]             list <- base::list
[10:31:24.005]             seq.int <- base::seq.int
[10:31:24.005]             signalCondition <- base::signalCondition
[10:31:24.005]             sys.calls <- base::sys.calls
[10:31:24.005]             `[[` <- base::`[[`
[10:31:24.005]             `+` <- base::`+`
[10:31:24.005]             `<<-` <- base::`<<-`
[10:31:24.005]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:24.005]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:24.005]                   3L)]
[10:31:24.005]             }
[10:31:24.005]             function(cond) {
[10:31:24.005]                 is_error <- inherits(cond, "error")
[10:31:24.005]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:24.005]                   NULL)
[10:31:24.005]                 if (is_error) {
[10:31:24.005]                   sessionInformation <- function() {
[10:31:24.005]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:24.005]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:24.005]                       search = base::search(), system = base::Sys.info())
[10:31:24.005]                   }
[10:31:24.005]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.005]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:24.005]                     cond$call), session = sessionInformation(), 
[10:31:24.005]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:24.005]                   signalCondition(cond)
[10:31:24.005]                 }
[10:31:24.005]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:24.005]                 "immediateCondition"))) {
[10:31:24.005]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:24.005]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.005]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:24.005]                   if (TRUE && !signal) {
[10:31:24.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.005]                     {
[10:31:24.005]                       inherits <- base::inherits
[10:31:24.005]                       invokeRestart <- base::invokeRestart
[10:31:24.005]                       is.null <- base::is.null
[10:31:24.005]                       muffled <- FALSE
[10:31:24.005]                       if (inherits(cond, "message")) {
[10:31:24.005]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.005]                         if (muffled) 
[10:31:24.005]                           invokeRestart("muffleMessage")
[10:31:24.005]                       }
[10:31:24.005]                       else if (inherits(cond, "warning")) {
[10:31:24.005]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.005]                         if (muffled) 
[10:31:24.005]                           invokeRestart("muffleWarning")
[10:31:24.005]                       }
[10:31:24.005]                       else if (inherits(cond, "condition")) {
[10:31:24.005]                         if (!is.null(pattern)) {
[10:31:24.005]                           computeRestarts <- base::computeRestarts
[10:31:24.005]                           grepl <- base::grepl
[10:31:24.005]                           restarts <- computeRestarts(cond)
[10:31:24.005]                           for (restart in restarts) {
[10:31:24.005]                             name <- restart$name
[10:31:24.005]                             if (is.null(name)) 
[10:31:24.005]                               next
[10:31:24.005]                             if (!grepl(pattern, name)) 
[10:31:24.005]                               next
[10:31:24.005]                             invokeRestart(restart)
[10:31:24.005]                             muffled <- TRUE
[10:31:24.005]                             break
[10:31:24.005]                           }
[10:31:24.005]                         }
[10:31:24.005]                       }
[10:31:24.005]                       invisible(muffled)
[10:31:24.005]                     }
[10:31:24.005]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.005]                   }
[10:31:24.005]                 }
[10:31:24.005]                 else {
[10:31:24.005]                   if (TRUE) {
[10:31:24.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.005]                     {
[10:31:24.005]                       inherits <- base::inherits
[10:31:24.005]                       invokeRestart <- base::invokeRestart
[10:31:24.005]                       is.null <- base::is.null
[10:31:24.005]                       muffled <- FALSE
[10:31:24.005]                       if (inherits(cond, "message")) {
[10:31:24.005]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.005]                         if (muffled) 
[10:31:24.005]                           invokeRestart("muffleMessage")
[10:31:24.005]                       }
[10:31:24.005]                       else if (inherits(cond, "warning")) {
[10:31:24.005]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.005]                         if (muffled) 
[10:31:24.005]                           invokeRestart("muffleWarning")
[10:31:24.005]                       }
[10:31:24.005]                       else if (inherits(cond, "condition")) {
[10:31:24.005]                         if (!is.null(pattern)) {
[10:31:24.005]                           computeRestarts <- base::computeRestarts
[10:31:24.005]                           grepl <- base::grepl
[10:31:24.005]                           restarts <- computeRestarts(cond)
[10:31:24.005]                           for (restart in restarts) {
[10:31:24.005]                             name <- restart$name
[10:31:24.005]                             if (is.null(name)) 
[10:31:24.005]                               next
[10:31:24.005]                             if (!grepl(pattern, name)) 
[10:31:24.005]                               next
[10:31:24.005]                             invokeRestart(restart)
[10:31:24.005]                             muffled <- TRUE
[10:31:24.005]                             break
[10:31:24.005]                           }
[10:31:24.005]                         }
[10:31:24.005]                       }
[10:31:24.005]                       invisible(muffled)
[10:31:24.005]                     }
[10:31:24.005]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.005]                   }
[10:31:24.005]                 }
[10:31:24.005]             }
[10:31:24.005]         }))
[10:31:24.005]     }, error = function(ex) {
[10:31:24.005]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:24.005]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.005]                 ...future.rng), started = ...future.startTime, 
[10:31:24.005]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:24.005]             version = "1.8"), class = "FutureResult")
[10:31:24.005]     }, finally = {
[10:31:24.005]         if (!identical(...future.workdir, getwd())) 
[10:31:24.005]             setwd(...future.workdir)
[10:31:24.005]         {
[10:31:24.005]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:24.005]                 ...future.oldOptions$nwarnings <- NULL
[10:31:24.005]             }
[10:31:24.005]             base::options(...future.oldOptions)
[10:31:24.005]             if (.Platform$OS.type == "windows") {
[10:31:24.005]                 old_names <- names(...future.oldEnvVars)
[10:31:24.005]                 envs <- base::Sys.getenv()
[10:31:24.005]                 names <- names(envs)
[10:31:24.005]                 common <- intersect(names, old_names)
[10:31:24.005]                 added <- setdiff(names, old_names)
[10:31:24.005]                 removed <- setdiff(old_names, names)
[10:31:24.005]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:24.005]                   envs[common]]
[10:31:24.005]                 NAMES <- toupper(changed)
[10:31:24.005]                 args <- list()
[10:31:24.005]                 for (kk in seq_along(NAMES)) {
[10:31:24.005]                   name <- changed[[kk]]
[10:31:24.005]                   NAME <- NAMES[[kk]]
[10:31:24.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.005]                     next
[10:31:24.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.005]                 }
[10:31:24.005]                 NAMES <- toupper(added)
[10:31:24.005]                 for (kk in seq_along(NAMES)) {
[10:31:24.005]                   name <- added[[kk]]
[10:31:24.005]                   NAME <- NAMES[[kk]]
[10:31:24.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.005]                     next
[10:31:24.005]                   args[[name]] <- ""
[10:31:24.005]                 }
[10:31:24.005]                 NAMES <- toupper(removed)
[10:31:24.005]                 for (kk in seq_along(NAMES)) {
[10:31:24.005]                   name <- removed[[kk]]
[10:31:24.005]                   NAME <- NAMES[[kk]]
[10:31:24.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.005]                     next
[10:31:24.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.005]                 }
[10:31:24.005]                 if (length(args) > 0) 
[10:31:24.005]                   base::do.call(base::Sys.setenv, args = args)
[10:31:24.005]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:24.005]             }
[10:31:24.005]             else {
[10:31:24.005]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:24.005]             }
[10:31:24.005]             {
[10:31:24.005]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:24.005]                   0L) {
[10:31:24.005]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:24.005]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:24.005]                   base::options(opts)
[10:31:24.005]                 }
[10:31:24.005]                 {
[10:31:24.005]                   {
[10:31:24.005]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:24.005]                     NULL
[10:31:24.005]                   }
[10:31:24.005]                   options(future.plan = NULL)
[10:31:24.005]                   if (is.na(NA_character_)) 
[10:31:24.005]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.005]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:24.005]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:24.005]                     .init = FALSE)
[10:31:24.005]                 }
[10:31:24.005]             }
[10:31:24.005]         }
[10:31:24.005]     })
[10:31:24.005]     if (TRUE) {
[10:31:24.005]         base::sink(type = "output", split = FALSE)
[10:31:24.005]         if (TRUE) {
[10:31:24.005]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:24.005]         }
[10:31:24.005]         else {
[10:31:24.005]             ...future.result["stdout"] <- base::list(NULL)
[10:31:24.005]         }
[10:31:24.005]         base::close(...future.stdout)
[10:31:24.005]         ...future.stdout <- NULL
[10:31:24.005]     }
[10:31:24.005]     ...future.result$conditions <- ...future.conditions
[10:31:24.005]     ...future.result$finished <- base::Sys.time()
[10:31:24.005]     ...future.result
[10:31:24.005] }
[10:31:24.008] assign_globals() ...
[10:31:24.008] List of 5
[10:31:24.008]  $ ...future.FUN            :function (x, y)  
[10:31:24.008]  $ future.call.arguments    :List of 1
[10:31:24.008]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:24.008]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.008]  $ ...future.elements_ii    :List of 2
[10:31:24.008]   ..$ A: num 50
[10:31:24.008]   ..$ B: num 60
[10:31:24.008]  $ ...future.seeds_ii       : NULL
[10:31:24.008]  $ ...future.globals.maxSize: NULL
[10:31:24.008]  - attr(*, "where")=List of 5
[10:31:24.008]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:24.008]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:24.008]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:24.008]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:24.008]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:24.008]  - attr(*, "resolved")= logi FALSE
[10:31:24.008]  - attr(*, "total_size")= num 4264
[10:31:24.008]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.008]  - attr(*, "already-done")= logi TRUE
[10:31:24.013] - reassign environment for ‘...future.FUN’
[10:31:24.016] - copied ‘...future.FUN’ to environment
[10:31:24.016] - copied ‘future.call.arguments’ to environment
[10:31:24.016] - copied ‘...future.elements_ii’ to environment
[10:31:24.016] - copied ‘...future.seeds_ii’ to environment
[10:31:24.016] - copied ‘...future.globals.maxSize’ to environment
[10:31:24.016] assign_globals() ... done
[10:31:24.016] requestCore(): workers = 2
[10:31:24.019] MulticoreFuture started
[10:31:24.020] - Launch lazy future ... done
[10:31:24.020] plan(): Setting new future strategy stack:
[10:31:24.020] run() for ‘MulticoreFuture’ ... done
[10:31:24.021] Created future:
[10:31:24.021] List of future strategies:
[10:31:24.021] 1. sequential:
[10:31:24.021]    - args: function (..., envir = parent.frame())
[10:31:24.021]    - tweaked: FALSE
[10:31:24.021]    - call: NULL
[10:31:24.022] plan(): nbrOfWorkers() = 1
[10:31:24.025] plan(): Setting new future strategy stack:
[10:31:24.025] List of future strategies:
[10:31:24.025] 1. multicore:
[10:31:24.025]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:24.025]    - tweaked: FALSE
[10:31:24.025]    - call: plan(strategy)
[10:31:24.032] plan(): nbrOfWorkers() = 2
[10:31:24.021] MulticoreFuture:
[10:31:24.021] Label: ‘future_sapply-1’
[10:31:24.021] Expression:
[10:31:24.021] {
[10:31:24.021]     do.call(function(...) {
[10:31:24.021]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.021]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.021]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.021]             on.exit(options(oopts), add = TRUE)
[10:31:24.021]         }
[10:31:24.021]         {
[10:31:24.021]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.021]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.021]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.021]             })
[10:31:24.021]         }
[10:31:24.021]     }, args = future.call.arguments)
[10:31:24.021] }
[10:31:24.021] Lazy evaluation: FALSE
[10:31:24.021] Asynchronous evaluation: TRUE
[10:31:24.021] Local evaluation: TRUE
[10:31:24.021] Environment: R_GlobalEnv
[10:31:24.021] Capture standard output: TRUE
[10:31:24.021] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:24.021] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:24.021] Packages: <none>
[10:31:24.021] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:24.021] Resolved: TRUE
[10:31:24.021] Value: <not collected>
[10:31:24.021] Conditions captured: <none>
[10:31:24.021] Early signaling: FALSE
[10:31:24.021] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:24.021] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.034] Chunk #1 of 2 ... DONE
[10:31:24.034] Chunk #2 of 2 ...
[10:31:24.034]  - Finding globals in 'X' for chunk #2 ...
[10:31:24.034] getGlobalsAndPackages() ...
[10:31:24.035] Searching for globals...
[10:31:24.035] 
[10:31:24.035] Searching for globals ... DONE
[10:31:24.036] - globals: [0] <none>
[10:31:24.036] getGlobalsAndPackages() ... DONE
[10:31:24.036]    + additional globals found: [n=0] 
[10:31:24.036]    + additional namespaces needed: [n=0] 
[10:31:24.036]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:24.037]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:24.037]  - seeds: <none>
[10:31:24.037]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.037] getGlobalsAndPackages() ...
[10:31:24.038] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.038] Resolving globals: FALSE
[10:31:24.038] Tweak future expression to call with '...' arguments ...
[10:31:24.039] {
[10:31:24.039]     do.call(function(...) {
[10:31:24.039]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.039]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.039]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.039]             on.exit(options(oopts), add = TRUE)
[10:31:24.039]         }
[10:31:24.039]         {
[10:31:24.039]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.039]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.039]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.039]             })
[10:31:24.039]         }
[10:31:24.039]     }, args = future.call.arguments)
[10:31:24.039] }
[10:31:24.039] Tweak future expression to call with '...' arguments ... DONE
[10:31:24.040] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.040] 
[10:31:24.041] getGlobalsAndPackages() ... DONE
[10:31:24.041] run() for ‘Future’ ...
[10:31:24.041] - state: ‘created’
[10:31:24.042] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:24.046] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.047] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:24.047]   - Field: ‘label’
[10:31:24.047]   - Field: ‘local’
[10:31:24.047]   - Field: ‘owner’
[10:31:24.048]   - Field: ‘envir’
[10:31:24.048]   - Field: ‘workers’
[10:31:24.048]   - Field: ‘packages’
[10:31:24.048]   - Field: ‘gc’
[10:31:24.048]   - Field: ‘job’
[10:31:24.048]   - Field: ‘conditions’
[10:31:24.049]   - Field: ‘expr’
[10:31:24.049]   - Field: ‘uuid’
[10:31:24.049]   - Field: ‘seed’
[10:31:24.049]   - Field: ‘version’
[10:31:24.049]   - Field: ‘result’
[10:31:24.049]   - Field: ‘asynchronous’
[10:31:24.050]   - Field: ‘calls’
[10:31:24.050]   - Field: ‘globals’
[10:31:24.050]   - Field: ‘stdout’
[10:31:24.050]   - Field: ‘earlySignal’
[10:31:24.050]   - Field: ‘lazy’
[10:31:24.050]   - Field: ‘state’
[10:31:24.050] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:24.050] - Launch lazy future ...
[10:31:24.051] Packages needed by the future expression (n = 0): <none>
[10:31:24.051] Packages needed by future strategies (n = 0): <none>
[10:31:24.052] {
[10:31:24.052]     {
[10:31:24.052]         {
[10:31:24.052]             ...future.startTime <- base::Sys.time()
[10:31:24.052]             {
[10:31:24.052]                 {
[10:31:24.052]                   {
[10:31:24.052]                     {
[10:31:24.052]                       base::local({
[10:31:24.052]                         has_future <- base::requireNamespace("future", 
[10:31:24.052]                           quietly = TRUE)
[10:31:24.052]                         if (has_future) {
[10:31:24.052]                           ns <- base::getNamespace("future")
[10:31:24.052]                           version <- ns[[".package"]][["version"]]
[10:31:24.052]                           if (is.null(version)) 
[10:31:24.052]                             version <- utils::packageVersion("future")
[10:31:24.052]                         }
[10:31:24.052]                         else {
[10:31:24.052]                           version <- NULL
[10:31:24.052]                         }
[10:31:24.052]                         if (!has_future || version < "1.8.0") {
[10:31:24.052]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:24.052]                             "", base::R.version$version.string), 
[10:31:24.052]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:24.052]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:24.052]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:24.052]                               "release", "version")], collapse = " "), 
[10:31:24.052]                             hostname = base::Sys.info()[["nodename"]])
[10:31:24.052]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:24.052]                             info)
[10:31:24.052]                           info <- base::paste(info, collapse = "; ")
[10:31:24.052]                           if (!has_future) {
[10:31:24.052]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:24.052]                               info)
[10:31:24.052]                           }
[10:31:24.052]                           else {
[10:31:24.052]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:24.052]                               info, version)
[10:31:24.052]                           }
[10:31:24.052]                           base::stop(msg)
[10:31:24.052]                         }
[10:31:24.052]                       })
[10:31:24.052]                     }
[10:31:24.052]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:24.052]                     base::options(mc.cores = 1L)
[10:31:24.052]                   }
[10:31:24.052]                   ...future.strategy.old <- future::plan("list")
[10:31:24.052]                   options(future.plan = NULL)
[10:31:24.052]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.052]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:24.052]                 }
[10:31:24.052]                 ...future.workdir <- getwd()
[10:31:24.052]             }
[10:31:24.052]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:24.052]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:24.052]         }
[10:31:24.052]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:24.052]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:24.052]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:24.052]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:24.052]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:24.052]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:24.052]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:24.052]             base::names(...future.oldOptions))
[10:31:24.052]     }
[10:31:24.052]     if (FALSE) {
[10:31:24.052]     }
[10:31:24.052]     else {
[10:31:24.052]         if (TRUE) {
[10:31:24.052]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:24.052]                 open = "w")
[10:31:24.052]         }
[10:31:24.052]         else {
[10:31:24.052]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:24.052]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:24.052]         }
[10:31:24.052]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:24.052]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:24.052]             base::sink(type = "output", split = FALSE)
[10:31:24.052]             base::close(...future.stdout)
[10:31:24.052]         }, add = TRUE)
[10:31:24.052]     }
[10:31:24.052]     ...future.frame <- base::sys.nframe()
[10:31:24.052]     ...future.conditions <- base::list()
[10:31:24.052]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:24.052]     if (FALSE) {
[10:31:24.052]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:24.052]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:24.052]     }
[10:31:24.052]     ...future.result <- base::tryCatch({
[10:31:24.052]         base::withCallingHandlers({
[10:31:24.052]             ...future.value <- base::withVisible(base::local({
[10:31:24.052]                 withCallingHandlers({
[10:31:24.052]                   {
[10:31:24.052]                     do.call(function(...) {
[10:31:24.052]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.052]                       if (!identical(...future.globals.maxSize.org, 
[10:31:24.052]                         ...future.globals.maxSize)) {
[10:31:24.052]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.052]                         on.exit(options(oopts), add = TRUE)
[10:31:24.052]                       }
[10:31:24.052]                       {
[10:31:24.052]                         lapply(seq_along(...future.elements_ii), 
[10:31:24.052]                           FUN = function(jj) {
[10:31:24.052]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.052]                             ...future.FUN(...future.X_jj, ...)
[10:31:24.052]                           })
[10:31:24.052]                       }
[10:31:24.052]                     }, args = future.call.arguments)
[10:31:24.052]                   }
[10:31:24.052]                 }, immediateCondition = function(cond) {
[10:31:24.052]                   save_rds <- function (object, pathname, ...) 
[10:31:24.052]                   {
[10:31:24.052]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:24.052]                     if (file_test("-f", pathname_tmp)) {
[10:31:24.052]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.052]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:24.052]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.052]                         fi_tmp[["mtime"]])
[10:31:24.052]                     }
[10:31:24.052]                     tryCatch({
[10:31:24.052]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:24.052]                     }, error = function(ex) {
[10:31:24.052]                       msg <- conditionMessage(ex)
[10:31:24.052]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.052]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:24.052]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.052]                         fi_tmp[["mtime"]], msg)
[10:31:24.052]                       ex$message <- msg
[10:31:24.052]                       stop(ex)
[10:31:24.052]                     })
[10:31:24.052]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:24.052]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:24.052]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:24.052]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.052]                       fi <- file.info(pathname)
[10:31:24.052]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:24.052]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.052]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:24.052]                         fi[["size"]], fi[["mtime"]])
[10:31:24.052]                       stop(msg)
[10:31:24.052]                     }
[10:31:24.052]                     invisible(pathname)
[10:31:24.052]                   }
[10:31:24.052]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:24.052]                     rootPath = tempdir()) 
[10:31:24.052]                   {
[10:31:24.052]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:24.052]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:24.052]                       tmpdir = path, fileext = ".rds")
[10:31:24.052]                     save_rds(obj, file)
[10:31:24.052]                   }
[10:31:24.052]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:24.052]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.052]                   {
[10:31:24.052]                     inherits <- base::inherits
[10:31:24.052]                     invokeRestart <- base::invokeRestart
[10:31:24.052]                     is.null <- base::is.null
[10:31:24.052]                     muffled <- FALSE
[10:31:24.052]                     if (inherits(cond, "message")) {
[10:31:24.052]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:24.052]                       if (muffled) 
[10:31:24.052]                         invokeRestart("muffleMessage")
[10:31:24.052]                     }
[10:31:24.052]                     else if (inherits(cond, "warning")) {
[10:31:24.052]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:24.052]                       if (muffled) 
[10:31:24.052]                         invokeRestart("muffleWarning")
[10:31:24.052]                     }
[10:31:24.052]                     else if (inherits(cond, "condition")) {
[10:31:24.052]                       if (!is.null(pattern)) {
[10:31:24.052]                         computeRestarts <- base::computeRestarts
[10:31:24.052]                         grepl <- base::grepl
[10:31:24.052]                         restarts <- computeRestarts(cond)
[10:31:24.052]                         for (restart in restarts) {
[10:31:24.052]                           name <- restart$name
[10:31:24.052]                           if (is.null(name)) 
[10:31:24.052]                             next
[10:31:24.052]                           if (!grepl(pattern, name)) 
[10:31:24.052]                             next
[10:31:24.052]                           invokeRestart(restart)
[10:31:24.052]                           muffled <- TRUE
[10:31:24.052]                           break
[10:31:24.052]                         }
[10:31:24.052]                       }
[10:31:24.052]                     }
[10:31:24.052]                     invisible(muffled)
[10:31:24.052]                   }
[10:31:24.052]                   muffleCondition(cond)
[10:31:24.052]                 })
[10:31:24.052]             }))
[10:31:24.052]             future::FutureResult(value = ...future.value$value, 
[10:31:24.052]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.052]                   ...future.rng), globalenv = if (FALSE) 
[10:31:24.052]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:24.052]                     ...future.globalenv.names))
[10:31:24.052]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:24.052]         }, condition = base::local({
[10:31:24.052]             c <- base::c
[10:31:24.052]             inherits <- base::inherits
[10:31:24.052]             invokeRestart <- base::invokeRestart
[10:31:24.052]             length <- base::length
[10:31:24.052]             list <- base::list
[10:31:24.052]             seq.int <- base::seq.int
[10:31:24.052]             signalCondition <- base::signalCondition
[10:31:24.052]             sys.calls <- base::sys.calls
[10:31:24.052]             `[[` <- base::`[[`
[10:31:24.052]             `+` <- base::`+`
[10:31:24.052]             `<<-` <- base::`<<-`
[10:31:24.052]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:24.052]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:24.052]                   3L)]
[10:31:24.052]             }
[10:31:24.052]             function(cond) {
[10:31:24.052]                 is_error <- inherits(cond, "error")
[10:31:24.052]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:24.052]                   NULL)
[10:31:24.052]                 if (is_error) {
[10:31:24.052]                   sessionInformation <- function() {
[10:31:24.052]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:24.052]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:24.052]                       search = base::search(), system = base::Sys.info())
[10:31:24.052]                   }
[10:31:24.052]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.052]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:24.052]                     cond$call), session = sessionInformation(), 
[10:31:24.052]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:24.052]                   signalCondition(cond)
[10:31:24.052]                 }
[10:31:24.052]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:24.052]                 "immediateCondition"))) {
[10:31:24.052]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:24.052]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.052]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:24.052]                   if (TRUE && !signal) {
[10:31:24.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.052]                     {
[10:31:24.052]                       inherits <- base::inherits
[10:31:24.052]                       invokeRestart <- base::invokeRestart
[10:31:24.052]                       is.null <- base::is.null
[10:31:24.052]                       muffled <- FALSE
[10:31:24.052]                       if (inherits(cond, "message")) {
[10:31:24.052]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.052]                         if (muffled) 
[10:31:24.052]                           invokeRestart("muffleMessage")
[10:31:24.052]                       }
[10:31:24.052]                       else if (inherits(cond, "warning")) {
[10:31:24.052]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.052]                         if (muffled) 
[10:31:24.052]                           invokeRestart("muffleWarning")
[10:31:24.052]                       }
[10:31:24.052]                       else if (inherits(cond, "condition")) {
[10:31:24.052]                         if (!is.null(pattern)) {
[10:31:24.052]                           computeRestarts <- base::computeRestarts
[10:31:24.052]                           grepl <- base::grepl
[10:31:24.052]                           restarts <- computeRestarts(cond)
[10:31:24.052]                           for (restart in restarts) {
[10:31:24.052]                             name <- restart$name
[10:31:24.052]                             if (is.null(name)) 
[10:31:24.052]                               next
[10:31:24.052]                             if (!grepl(pattern, name)) 
[10:31:24.052]                               next
[10:31:24.052]                             invokeRestart(restart)
[10:31:24.052]                             muffled <- TRUE
[10:31:24.052]                             break
[10:31:24.052]                           }
[10:31:24.052]                         }
[10:31:24.052]                       }
[10:31:24.052]                       invisible(muffled)
[10:31:24.052]                     }
[10:31:24.052]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.052]                   }
[10:31:24.052]                 }
[10:31:24.052]                 else {
[10:31:24.052]                   if (TRUE) {
[10:31:24.052]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.052]                     {
[10:31:24.052]                       inherits <- base::inherits
[10:31:24.052]                       invokeRestart <- base::invokeRestart
[10:31:24.052]                       is.null <- base::is.null
[10:31:24.052]                       muffled <- FALSE
[10:31:24.052]                       if (inherits(cond, "message")) {
[10:31:24.052]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.052]                         if (muffled) 
[10:31:24.052]                           invokeRestart("muffleMessage")
[10:31:24.052]                       }
[10:31:24.052]                       else if (inherits(cond, "warning")) {
[10:31:24.052]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.052]                         if (muffled) 
[10:31:24.052]                           invokeRestart("muffleWarning")
[10:31:24.052]                       }
[10:31:24.052]                       else if (inherits(cond, "condition")) {
[10:31:24.052]                         if (!is.null(pattern)) {
[10:31:24.052]                           computeRestarts <- base::computeRestarts
[10:31:24.052]                           grepl <- base::grepl
[10:31:24.052]                           restarts <- computeRestarts(cond)
[10:31:24.052]                           for (restart in restarts) {
[10:31:24.052]                             name <- restart$name
[10:31:24.052]                             if (is.null(name)) 
[10:31:24.052]                               next
[10:31:24.052]                             if (!grepl(pattern, name)) 
[10:31:24.052]                               next
[10:31:24.052]                             invokeRestart(restart)
[10:31:24.052]                             muffled <- TRUE
[10:31:24.052]                             break
[10:31:24.052]                           }
[10:31:24.052]                         }
[10:31:24.052]                       }
[10:31:24.052]                       invisible(muffled)
[10:31:24.052]                     }
[10:31:24.052]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.052]                   }
[10:31:24.052]                 }
[10:31:24.052]             }
[10:31:24.052]         }))
[10:31:24.052]     }, error = function(ex) {
[10:31:24.052]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:24.052]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.052]                 ...future.rng), started = ...future.startTime, 
[10:31:24.052]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:24.052]             version = "1.8"), class = "FutureResult")
[10:31:24.052]     }, finally = {
[10:31:24.052]         if (!identical(...future.workdir, getwd())) 
[10:31:24.052]             setwd(...future.workdir)
[10:31:24.052]         {
[10:31:24.052]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:24.052]                 ...future.oldOptions$nwarnings <- NULL
[10:31:24.052]             }
[10:31:24.052]             base::options(...future.oldOptions)
[10:31:24.052]             if (.Platform$OS.type == "windows") {
[10:31:24.052]                 old_names <- names(...future.oldEnvVars)
[10:31:24.052]                 envs <- base::Sys.getenv()
[10:31:24.052]                 names <- names(envs)
[10:31:24.052]                 common <- intersect(names, old_names)
[10:31:24.052]                 added <- setdiff(names, old_names)
[10:31:24.052]                 removed <- setdiff(old_names, names)
[10:31:24.052]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:24.052]                   envs[common]]
[10:31:24.052]                 NAMES <- toupper(changed)
[10:31:24.052]                 args <- list()
[10:31:24.052]                 for (kk in seq_along(NAMES)) {
[10:31:24.052]                   name <- changed[[kk]]
[10:31:24.052]                   NAME <- NAMES[[kk]]
[10:31:24.052]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.052]                     next
[10:31:24.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.052]                 }
[10:31:24.052]                 NAMES <- toupper(added)
[10:31:24.052]                 for (kk in seq_along(NAMES)) {
[10:31:24.052]                   name <- added[[kk]]
[10:31:24.052]                   NAME <- NAMES[[kk]]
[10:31:24.052]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.052]                     next
[10:31:24.052]                   args[[name]] <- ""
[10:31:24.052]                 }
[10:31:24.052]                 NAMES <- toupper(removed)
[10:31:24.052]                 for (kk in seq_along(NAMES)) {
[10:31:24.052]                   name <- removed[[kk]]
[10:31:24.052]                   NAME <- NAMES[[kk]]
[10:31:24.052]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.052]                     next
[10:31:24.052]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.052]                 }
[10:31:24.052]                 if (length(args) > 0) 
[10:31:24.052]                   base::do.call(base::Sys.setenv, args = args)
[10:31:24.052]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:24.052]             }
[10:31:24.052]             else {
[10:31:24.052]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:24.052]             }
[10:31:24.052]             {
[10:31:24.052]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:24.052]                   0L) {
[10:31:24.052]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:24.052]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:24.052]                   base::options(opts)
[10:31:24.052]                 }
[10:31:24.052]                 {
[10:31:24.052]                   {
[10:31:24.052]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:24.052]                     NULL
[10:31:24.052]                   }
[10:31:24.052]                   options(future.plan = NULL)
[10:31:24.052]                   if (is.na(NA_character_)) 
[10:31:24.052]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.052]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:24.052]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:24.052]                     .init = FALSE)
[10:31:24.052]                 }
[10:31:24.052]             }
[10:31:24.052]         }
[10:31:24.052]     })
[10:31:24.052]     if (TRUE) {
[10:31:24.052]         base::sink(type = "output", split = FALSE)
[10:31:24.052]         if (TRUE) {
[10:31:24.052]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:24.052]         }
[10:31:24.052]         else {
[10:31:24.052]             ...future.result["stdout"] <- base::list(NULL)
[10:31:24.052]         }
[10:31:24.052]         base::close(...future.stdout)
[10:31:24.052]         ...future.stdout <- NULL
[10:31:24.052]     }
[10:31:24.052]     ...future.result$conditions <- ...future.conditions
[10:31:24.052]     ...future.result$finished <- base::Sys.time()
[10:31:24.052]     ...future.result
[10:31:24.052] }
[10:31:24.055] assign_globals() ...
[10:31:24.055] List of 5
[10:31:24.055]  $ ...future.FUN            :function (x, y)  
[10:31:24.055]  $ future.call.arguments    :List of 1
[10:31:24.055]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:24.055]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.055]  $ ...future.elements_ii    :List of 2
[10:31:24.055]   ..$ C: num 70
[10:31:24.055]   ..$ D: num 80
[10:31:24.055]  $ ...future.seeds_ii       : NULL
[10:31:24.055]  $ ...future.globals.maxSize: NULL
[10:31:24.055]  - attr(*, "where")=List of 5
[10:31:24.055]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:24.055]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:24.055]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:24.055]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:24.055]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:24.055]  - attr(*, "resolved")= logi FALSE
[10:31:24.055]  - attr(*, "total_size")= num 4264
[10:31:24.055]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.055]  - attr(*, "already-done")= logi TRUE
[10:31:24.062] - reassign environment for ‘...future.FUN’
[10:31:24.062] - copied ‘...future.FUN’ to environment
[10:31:24.062] - copied ‘future.call.arguments’ to environment
[10:31:24.062] - copied ‘...future.elements_ii’ to environment
[10:31:24.062] - copied ‘...future.seeds_ii’ to environment
[10:31:24.063] - copied ‘...future.globals.maxSize’ to environment
[10:31:24.063] assign_globals() ... done
[10:31:24.063] requestCore(): workers = 2
[10:31:24.065] MulticoreFuture started
[10:31:24.066] - Launch lazy future ... done
[10:31:24.066] run() for ‘MulticoreFuture’ ... done
[10:31:24.066] Created future:
[10:31:24.066] plan(): Setting new future strategy stack:
[10:31:24.067] List of future strategies:
[10:31:24.067] 1. sequential:
[10:31:24.067]    - args: function (..., envir = parent.frame())
[10:31:24.067]    - tweaked: FALSE
[10:31:24.067]    - call: NULL
[10:31:24.067] plan(): nbrOfWorkers() = 1
[10:31:24.073] plan(): Setting new future strategy stack:
[10:31:24.073] List of future strategies:
[10:31:24.073] 1. multicore:
[10:31:24.073]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:24.073]    - tweaked: FALSE
[10:31:24.073]    - call: plan(strategy)
[10:31:24.080] plan(): nbrOfWorkers() = 2
[10:31:24.066] MulticoreFuture:
[10:31:24.066] Label: ‘future_sapply-2’
[10:31:24.066] Expression:
[10:31:24.066] {
[10:31:24.066]     do.call(function(...) {
[10:31:24.066]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.066]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.066]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.066]             on.exit(options(oopts), add = TRUE)
[10:31:24.066]         }
[10:31:24.066]         {
[10:31:24.066]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.066]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.066]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.066]             })
[10:31:24.066]         }
[10:31:24.066]     }, args = future.call.arguments)
[10:31:24.066] }
[10:31:24.066] Lazy evaluation: FALSE
[10:31:24.066] Asynchronous evaluation: TRUE
[10:31:24.066] Local evaluation: TRUE
[10:31:24.066] Environment: R_GlobalEnv
[10:31:24.066] Capture standard output: TRUE
[10:31:24.066] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:24.066] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:24.066] Packages: <none>
[10:31:24.066] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:24.066] Resolved: TRUE
[10:31:24.066] Value: <not collected>
[10:31:24.066] Conditions captured: <none>
[10:31:24.066] Early signaling: FALSE
[10:31:24.066] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:24.066] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.082] Chunk #2 of 2 ... DONE
[10:31:24.082] Launching 2 futures (chunks) ... DONE
[10:31:24.082] Resolving 2 futures (chunks) ...
[10:31:24.083] resolve() on list ...
[10:31:24.083]  recursive: 0
[10:31:24.083]  length: 2
[10:31:24.083] 
[10:31:24.084] Future #1
[10:31:24.084] result() for MulticoreFuture ...
[10:31:24.085] result() for MulticoreFuture ...
[10:31:24.085] result() for MulticoreFuture ... done
[10:31:24.086] result() for MulticoreFuture ... done
[10:31:24.086] result() for MulticoreFuture ...
[10:31:24.086] result() for MulticoreFuture ... done
[10:31:24.086] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:24.087] - nx: 2
[10:31:24.087] - relay: TRUE
[10:31:24.087] - stdout: TRUE
[10:31:24.087] - signal: TRUE
[10:31:24.088] - resignal: FALSE
[10:31:24.088] - force: TRUE
[10:31:24.088] - relayed: [n=2] FALSE, FALSE
[10:31:24.088] - queued futures: [n=2] FALSE, FALSE
[10:31:24.089]  - until=1
[10:31:24.089]  - relaying element #1
[10:31:24.089] result() for MulticoreFuture ...
[10:31:24.089] result() for MulticoreFuture ... done
[10:31:24.090] result() for MulticoreFuture ...
[10:31:24.090] result() for MulticoreFuture ... done
[10:31:24.090] result() for MulticoreFuture ...
[10:31:24.090] result() for MulticoreFuture ... done
[10:31:24.091] result() for MulticoreFuture ...
[10:31:24.091] result() for MulticoreFuture ... done
[10:31:24.091] - relayed: [n=2] TRUE, FALSE
[10:31:24.091] - queued futures: [n=2] TRUE, FALSE
[10:31:24.091] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:24.092]  length: 1 (resolved future 1)
[10:31:24.092] Future #2
[10:31:24.092] result() for MulticoreFuture ...
[10:31:24.093] result() for MulticoreFuture ...
[10:31:24.093] result() for MulticoreFuture ... done
[10:31:24.094] result() for MulticoreFuture ... done
[10:31:24.094] result() for MulticoreFuture ...
[10:31:24.094] result() for MulticoreFuture ... done
[10:31:24.094] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:24.094] - nx: 2
[10:31:24.095] - relay: TRUE
[10:31:24.095] - stdout: TRUE
[10:31:24.095] - signal: TRUE
[10:31:24.095] - resignal: FALSE
[10:31:24.095] - force: TRUE
[10:31:24.095] - relayed: [n=2] TRUE, FALSE
[10:31:24.095] - queued futures: [n=2] TRUE, FALSE
[10:31:24.095]  - until=2
[10:31:24.096]  - relaying element #2
[10:31:24.096] result() for MulticoreFuture ...
[10:31:24.096] result() for MulticoreFuture ... done
[10:31:24.096] result() for MulticoreFuture ...
[10:31:24.096] result() for MulticoreFuture ... done
[10:31:24.096] result() for MulticoreFuture ...
[10:31:24.096] result() for MulticoreFuture ... done
[10:31:24.096] result() for MulticoreFuture ...
[10:31:24.097] result() for MulticoreFuture ... done
[10:31:24.097] - relayed: [n=2] TRUE, TRUE
[10:31:24.097] - queued futures: [n=2] TRUE, TRUE
[10:31:24.097] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:24.097]  length: 0 (resolved future 2)
[10:31:24.097] Relaying remaining futures
[10:31:24.098] signalConditionsASAP(NULL, pos=0) ...
[10:31:24.098] - nx: 2
[10:31:24.098] - relay: TRUE
[10:31:24.098] - stdout: TRUE
[10:31:24.098] - signal: TRUE
[10:31:24.098] - resignal: FALSE
[10:31:24.098] - force: TRUE
[10:31:24.098] - relayed: [n=2] TRUE, TRUE
[10:31:24.098] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:24.099] - relayed: [n=2] TRUE, TRUE
[10:31:24.099] - queued futures: [n=2] TRUE, TRUE
[10:31:24.099] signalConditionsASAP(NULL, pos=0) ... done
[10:31:24.099] resolve() on list ... DONE
[10:31:24.099] result() for MulticoreFuture ...
[10:31:24.099] result() for MulticoreFuture ... done
[10:31:24.099] result() for MulticoreFuture ...
[10:31:24.099] result() for MulticoreFuture ... done
[10:31:24.099] result() for MulticoreFuture ...
[10:31:24.099] result() for MulticoreFuture ... done
[10:31:24.100] result() for MulticoreFuture ...
[10:31:24.100] result() for MulticoreFuture ... done
[10:31:24.100]  - Number of value chunks collected: 2
[10:31:24.100] Resolving 2 futures (chunks) ... DONE
[10:31:24.100] Reducing values from 2 chunks ...
[10:31:24.100]  - Number of values collected after concatenation: 4
[10:31:24.100]  - Number of values expected: 4
[10:31:24.100] Reducing values from 2 chunks ... DONE
[10:31:24.101] future_lapply() ... DONE
[10:31:24.101] future_lapply() ...
[10:31:24.107] Number of chunks: 2
[10:31:24.107] getGlobalsAndPackagesXApply() ...
[10:31:24.107]  - future.globals: TRUE
[10:31:24.107] getGlobalsAndPackages() ...
[10:31:24.108] Searching for globals...
[10:31:24.114] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[10:31:24.114] Searching for globals ... DONE
[10:31:24.114] Resolving globals: FALSE
[10:31:24.115] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[10:31:24.115] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:24.116] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:24.116] - packages: [1] ‘future.apply’
[10:31:24.116] getGlobalsAndPackages() ... DONE
[10:31:24.116]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:24.116]  - needed namespaces: [n=1] ‘future.apply’
[10:31:24.116] Finding globals ... DONE
[10:31:24.116]  - use_args: TRUE
[10:31:24.116]  - Getting '...' globals ...
[10:31:24.117] resolve() on list ...
[10:31:24.117]  recursive: 0
[10:31:24.117]  length: 1
[10:31:24.117]  elements: ‘...’
[10:31:24.117]  length: 0 (resolved future 1)
[10:31:24.117] resolve() on list ... DONE
[10:31:24.118]    - '...' content: [n=1] ‘y’
[10:31:24.118] List of 1
[10:31:24.118]  $ ...:List of 1
[10:31:24.118]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:24.118]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.118]  - attr(*, "where")=List of 1
[10:31:24.118]   ..$ ...:<environment: 0x55de837d16f8> 
[10:31:24.118]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.118]  - attr(*, "resolved")= logi TRUE
[10:31:24.118]  - attr(*, "total_size")= num NA
[10:31:24.121]  - Getting '...' globals ... DONE
[10:31:24.121] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:24.121] List of 8
[10:31:24.121]  $ ...future.FUN:function (x, ...)  
[10:31:24.121]  $ x_FUN        :function (x, y)  
[10:31:24.121]  $ times        : int 15
[10:31:24.121]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:24.121]  $ stop_if_not  :function (...)  
[10:31:24.121]  $ dim          : int [1:2] 3 5
[10:31:24.121]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:24.121]  $ ...          :List of 1
[10:31:24.121]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:24.121]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.121]  - attr(*, "where")=List of 8
[10:31:24.121]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:24.121]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:24.121]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:24.121]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:24.121]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:24.121]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:24.121]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:24.121]   ..$ ...          :<environment: 0x55de837d16f8> 
[10:31:24.121]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.121]  - attr(*, "resolved")= logi FALSE
[10:31:24.121]  - attr(*, "total_size")= num 98600
[10:31:24.127] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:24.128] getGlobalsAndPackagesXApply() ... DONE
[10:31:24.128] Number of futures (= number of chunks): 2
[10:31:24.128] Launching 2 futures (chunks) ...
[10:31:24.128] Chunk #1 of 2 ...
[10:31:24.128]  - Finding globals in 'X' for chunk #1 ...
[10:31:24.128] getGlobalsAndPackages() ...
[10:31:24.128] Searching for globals...
[10:31:24.129] 
[10:31:24.129] Searching for globals ... DONE
[10:31:24.129] - globals: [0] <none>
[10:31:24.129] getGlobalsAndPackages() ... DONE
[10:31:24.129]    + additional globals found: [n=0] 
[10:31:24.129]    + additional namespaces needed: [n=0] 
[10:31:24.129]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:24.129]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:24.129]  - seeds: <none>
[10:31:24.129]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.130] getGlobalsAndPackages() ...
[10:31:24.130] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.130] Resolving globals: FALSE
[10:31:24.130] Tweak future expression to call with '...' arguments ...
[10:31:24.130] {
[10:31:24.130]     do.call(function(...) {
[10:31:24.130]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.130]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.130]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.130]             on.exit(options(oopts), add = TRUE)
[10:31:24.130]         }
[10:31:24.130]         {
[10:31:24.130]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.130]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.130]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.130]             })
[10:31:24.130]         }
[10:31:24.130]     }, args = future.call.arguments)
[10:31:24.130] }
[10:31:24.130] Tweak future expression to call with '...' arguments ... DONE
[10:31:24.131] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.131] - packages: [1] ‘future.apply’
[10:31:24.131] getGlobalsAndPackages() ... DONE
[10:31:24.131] run() for ‘Future’ ...
[10:31:24.131] - state: ‘created’
[10:31:24.132] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:24.137] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.137] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:24.137]   - Field: ‘label’
[10:31:24.138]   - Field: ‘local’
[10:31:24.138]   - Field: ‘owner’
[10:31:24.138]   - Field: ‘envir’
[10:31:24.138]   - Field: ‘workers’
[10:31:24.138]   - Field: ‘packages’
[10:31:24.138]   - Field: ‘gc’
[10:31:24.138]   - Field: ‘job’
[10:31:24.138]   - Field: ‘conditions’
[10:31:24.138]   - Field: ‘expr’
[10:31:24.138]   - Field: ‘uuid’
[10:31:24.139]   - Field: ‘seed’
[10:31:24.139]   - Field: ‘version’
[10:31:24.139]   - Field: ‘result’
[10:31:24.139]   - Field: ‘asynchronous’
[10:31:24.139]   - Field: ‘calls’
[10:31:24.139]   - Field: ‘globals’
[10:31:24.139]   - Field: ‘stdout’
[10:31:24.139]   - Field: ‘earlySignal’
[10:31:24.139]   - Field: ‘lazy’
[10:31:24.139]   - Field: ‘state’
[10:31:24.140] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:24.140] - Launch lazy future ...
[10:31:24.140] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:24.140] Packages needed by future strategies (n = 0): <none>
[10:31:24.141] {
[10:31:24.141]     {
[10:31:24.141]         {
[10:31:24.141]             ...future.startTime <- base::Sys.time()
[10:31:24.141]             {
[10:31:24.141]                 {
[10:31:24.141]                   {
[10:31:24.141]                     {
[10:31:24.141]                       {
[10:31:24.141]                         base::local({
[10:31:24.141]                           has_future <- base::requireNamespace("future", 
[10:31:24.141]                             quietly = TRUE)
[10:31:24.141]                           if (has_future) {
[10:31:24.141]                             ns <- base::getNamespace("future")
[10:31:24.141]                             version <- ns[[".package"]][["version"]]
[10:31:24.141]                             if (is.null(version)) 
[10:31:24.141]                               version <- utils::packageVersion("future")
[10:31:24.141]                           }
[10:31:24.141]                           else {
[10:31:24.141]                             version <- NULL
[10:31:24.141]                           }
[10:31:24.141]                           if (!has_future || version < "1.8.0") {
[10:31:24.141]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:24.141]                               "", base::R.version$version.string), 
[10:31:24.141]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:24.141]                                 base::R.version$platform, 8 * 
[10:31:24.141]                                   base::.Machine$sizeof.pointer), 
[10:31:24.141]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:24.141]                                 "release", "version")], collapse = " "), 
[10:31:24.141]                               hostname = base::Sys.info()[["nodename"]])
[10:31:24.141]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:24.141]                               info)
[10:31:24.141]                             info <- base::paste(info, collapse = "; ")
[10:31:24.141]                             if (!has_future) {
[10:31:24.141]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:24.141]                                 info)
[10:31:24.141]                             }
[10:31:24.141]                             else {
[10:31:24.141]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:24.141]                                 info, version)
[10:31:24.141]                             }
[10:31:24.141]                             base::stop(msg)
[10:31:24.141]                           }
[10:31:24.141]                         })
[10:31:24.141]                       }
[10:31:24.141]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:24.141]                       base::options(mc.cores = 1L)
[10:31:24.141]                     }
[10:31:24.141]                     base::local({
[10:31:24.141]                       for (pkg in "future.apply") {
[10:31:24.141]                         base::loadNamespace(pkg)
[10:31:24.141]                         base::library(pkg, character.only = TRUE)
[10:31:24.141]                       }
[10:31:24.141]                     })
[10:31:24.141]                   }
[10:31:24.141]                   ...future.strategy.old <- future::plan("list")
[10:31:24.141]                   options(future.plan = NULL)
[10:31:24.141]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.141]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:24.141]                 }
[10:31:24.141]                 ...future.workdir <- getwd()
[10:31:24.141]             }
[10:31:24.141]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:24.141]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:24.141]         }
[10:31:24.141]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:24.141]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:24.141]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:24.141]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:24.141]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:24.141]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:24.141]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:24.141]             base::names(...future.oldOptions))
[10:31:24.141]     }
[10:31:24.141]     if (FALSE) {
[10:31:24.141]     }
[10:31:24.141]     else {
[10:31:24.141]         if (TRUE) {
[10:31:24.141]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:24.141]                 open = "w")
[10:31:24.141]         }
[10:31:24.141]         else {
[10:31:24.141]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:24.141]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:24.141]         }
[10:31:24.141]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:24.141]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:24.141]             base::sink(type = "output", split = FALSE)
[10:31:24.141]             base::close(...future.stdout)
[10:31:24.141]         }, add = TRUE)
[10:31:24.141]     }
[10:31:24.141]     ...future.frame <- base::sys.nframe()
[10:31:24.141]     ...future.conditions <- base::list()
[10:31:24.141]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:24.141]     if (FALSE) {
[10:31:24.141]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:24.141]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:24.141]     }
[10:31:24.141]     ...future.result <- base::tryCatch({
[10:31:24.141]         base::withCallingHandlers({
[10:31:24.141]             ...future.value <- base::withVisible(base::local({
[10:31:24.141]                 withCallingHandlers({
[10:31:24.141]                   {
[10:31:24.141]                     do.call(function(...) {
[10:31:24.141]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.141]                       if (!identical(...future.globals.maxSize.org, 
[10:31:24.141]                         ...future.globals.maxSize)) {
[10:31:24.141]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.141]                         on.exit(options(oopts), add = TRUE)
[10:31:24.141]                       }
[10:31:24.141]                       {
[10:31:24.141]                         lapply(seq_along(...future.elements_ii), 
[10:31:24.141]                           FUN = function(jj) {
[10:31:24.141]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.141]                             ...future.FUN(...future.X_jj, ...)
[10:31:24.141]                           })
[10:31:24.141]                       }
[10:31:24.141]                     }, args = future.call.arguments)
[10:31:24.141]                   }
[10:31:24.141]                 }, immediateCondition = function(cond) {
[10:31:24.141]                   save_rds <- function (object, pathname, ...) 
[10:31:24.141]                   {
[10:31:24.141]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:24.141]                     if (file_test("-f", pathname_tmp)) {
[10:31:24.141]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.141]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:24.141]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.141]                         fi_tmp[["mtime"]])
[10:31:24.141]                     }
[10:31:24.141]                     tryCatch({
[10:31:24.141]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:24.141]                     }, error = function(ex) {
[10:31:24.141]                       msg <- conditionMessage(ex)
[10:31:24.141]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.141]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:24.141]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.141]                         fi_tmp[["mtime"]], msg)
[10:31:24.141]                       ex$message <- msg
[10:31:24.141]                       stop(ex)
[10:31:24.141]                     })
[10:31:24.141]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:24.141]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:24.141]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:24.141]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.141]                       fi <- file.info(pathname)
[10:31:24.141]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:24.141]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.141]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:24.141]                         fi[["size"]], fi[["mtime"]])
[10:31:24.141]                       stop(msg)
[10:31:24.141]                     }
[10:31:24.141]                     invisible(pathname)
[10:31:24.141]                   }
[10:31:24.141]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:24.141]                     rootPath = tempdir()) 
[10:31:24.141]                   {
[10:31:24.141]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:24.141]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:24.141]                       tmpdir = path, fileext = ".rds")
[10:31:24.141]                     save_rds(obj, file)
[10:31:24.141]                   }
[10:31:24.141]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:24.141]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.141]                   {
[10:31:24.141]                     inherits <- base::inherits
[10:31:24.141]                     invokeRestart <- base::invokeRestart
[10:31:24.141]                     is.null <- base::is.null
[10:31:24.141]                     muffled <- FALSE
[10:31:24.141]                     if (inherits(cond, "message")) {
[10:31:24.141]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:24.141]                       if (muffled) 
[10:31:24.141]                         invokeRestart("muffleMessage")
[10:31:24.141]                     }
[10:31:24.141]                     else if (inherits(cond, "warning")) {
[10:31:24.141]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:24.141]                       if (muffled) 
[10:31:24.141]                         invokeRestart("muffleWarning")
[10:31:24.141]                     }
[10:31:24.141]                     else if (inherits(cond, "condition")) {
[10:31:24.141]                       if (!is.null(pattern)) {
[10:31:24.141]                         computeRestarts <- base::computeRestarts
[10:31:24.141]                         grepl <- base::grepl
[10:31:24.141]                         restarts <- computeRestarts(cond)
[10:31:24.141]                         for (restart in restarts) {
[10:31:24.141]                           name <- restart$name
[10:31:24.141]                           if (is.null(name)) 
[10:31:24.141]                             next
[10:31:24.141]                           if (!grepl(pattern, name)) 
[10:31:24.141]                             next
[10:31:24.141]                           invokeRestart(restart)
[10:31:24.141]                           muffled <- TRUE
[10:31:24.141]                           break
[10:31:24.141]                         }
[10:31:24.141]                       }
[10:31:24.141]                     }
[10:31:24.141]                     invisible(muffled)
[10:31:24.141]                   }
[10:31:24.141]                   muffleCondition(cond)
[10:31:24.141]                 })
[10:31:24.141]             }))
[10:31:24.141]             future::FutureResult(value = ...future.value$value, 
[10:31:24.141]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.141]                   ...future.rng), globalenv = if (FALSE) 
[10:31:24.141]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:24.141]                     ...future.globalenv.names))
[10:31:24.141]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:24.141]         }, condition = base::local({
[10:31:24.141]             c <- base::c
[10:31:24.141]             inherits <- base::inherits
[10:31:24.141]             invokeRestart <- base::invokeRestart
[10:31:24.141]             length <- base::length
[10:31:24.141]             list <- base::list
[10:31:24.141]             seq.int <- base::seq.int
[10:31:24.141]             signalCondition <- base::signalCondition
[10:31:24.141]             sys.calls <- base::sys.calls
[10:31:24.141]             `[[` <- base::`[[`
[10:31:24.141]             `+` <- base::`+`
[10:31:24.141]             `<<-` <- base::`<<-`
[10:31:24.141]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:24.141]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:24.141]                   3L)]
[10:31:24.141]             }
[10:31:24.141]             function(cond) {
[10:31:24.141]                 is_error <- inherits(cond, "error")
[10:31:24.141]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:24.141]                   NULL)
[10:31:24.141]                 if (is_error) {
[10:31:24.141]                   sessionInformation <- function() {
[10:31:24.141]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:24.141]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:24.141]                       search = base::search(), system = base::Sys.info())
[10:31:24.141]                   }
[10:31:24.141]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.141]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:24.141]                     cond$call), session = sessionInformation(), 
[10:31:24.141]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:24.141]                   signalCondition(cond)
[10:31:24.141]                 }
[10:31:24.141]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:24.141]                 "immediateCondition"))) {
[10:31:24.141]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:24.141]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.141]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:24.141]                   if (TRUE && !signal) {
[10:31:24.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.141]                     {
[10:31:24.141]                       inherits <- base::inherits
[10:31:24.141]                       invokeRestart <- base::invokeRestart
[10:31:24.141]                       is.null <- base::is.null
[10:31:24.141]                       muffled <- FALSE
[10:31:24.141]                       if (inherits(cond, "message")) {
[10:31:24.141]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.141]                         if (muffled) 
[10:31:24.141]                           invokeRestart("muffleMessage")
[10:31:24.141]                       }
[10:31:24.141]                       else if (inherits(cond, "warning")) {
[10:31:24.141]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.141]                         if (muffled) 
[10:31:24.141]                           invokeRestart("muffleWarning")
[10:31:24.141]                       }
[10:31:24.141]                       else if (inherits(cond, "condition")) {
[10:31:24.141]                         if (!is.null(pattern)) {
[10:31:24.141]                           computeRestarts <- base::computeRestarts
[10:31:24.141]                           grepl <- base::grepl
[10:31:24.141]                           restarts <- computeRestarts(cond)
[10:31:24.141]                           for (restart in restarts) {
[10:31:24.141]                             name <- restart$name
[10:31:24.141]                             if (is.null(name)) 
[10:31:24.141]                               next
[10:31:24.141]                             if (!grepl(pattern, name)) 
[10:31:24.141]                               next
[10:31:24.141]                             invokeRestart(restart)
[10:31:24.141]                             muffled <- TRUE
[10:31:24.141]                             break
[10:31:24.141]                           }
[10:31:24.141]                         }
[10:31:24.141]                       }
[10:31:24.141]                       invisible(muffled)
[10:31:24.141]                     }
[10:31:24.141]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.141]                   }
[10:31:24.141]                 }
[10:31:24.141]                 else {
[10:31:24.141]                   if (TRUE) {
[10:31:24.141]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.141]                     {
[10:31:24.141]                       inherits <- base::inherits
[10:31:24.141]                       invokeRestart <- base::invokeRestart
[10:31:24.141]                       is.null <- base::is.null
[10:31:24.141]                       muffled <- FALSE
[10:31:24.141]                       if (inherits(cond, "message")) {
[10:31:24.141]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.141]                         if (muffled) 
[10:31:24.141]                           invokeRestart("muffleMessage")
[10:31:24.141]                       }
[10:31:24.141]                       else if (inherits(cond, "warning")) {
[10:31:24.141]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.141]                         if (muffled) 
[10:31:24.141]                           invokeRestart("muffleWarning")
[10:31:24.141]                       }
[10:31:24.141]                       else if (inherits(cond, "condition")) {
[10:31:24.141]                         if (!is.null(pattern)) {
[10:31:24.141]                           computeRestarts <- base::computeRestarts
[10:31:24.141]                           grepl <- base::grepl
[10:31:24.141]                           restarts <- computeRestarts(cond)
[10:31:24.141]                           for (restart in restarts) {
[10:31:24.141]                             name <- restart$name
[10:31:24.141]                             if (is.null(name)) 
[10:31:24.141]                               next
[10:31:24.141]                             if (!grepl(pattern, name)) 
[10:31:24.141]                               next
[10:31:24.141]                             invokeRestart(restart)
[10:31:24.141]                             muffled <- TRUE
[10:31:24.141]                             break
[10:31:24.141]                           }
[10:31:24.141]                         }
[10:31:24.141]                       }
[10:31:24.141]                       invisible(muffled)
[10:31:24.141]                     }
[10:31:24.141]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.141]                   }
[10:31:24.141]                 }
[10:31:24.141]             }
[10:31:24.141]         }))
[10:31:24.141]     }, error = function(ex) {
[10:31:24.141]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:24.141]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.141]                 ...future.rng), started = ...future.startTime, 
[10:31:24.141]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:24.141]             version = "1.8"), class = "FutureResult")
[10:31:24.141]     }, finally = {
[10:31:24.141]         if (!identical(...future.workdir, getwd())) 
[10:31:24.141]             setwd(...future.workdir)
[10:31:24.141]         {
[10:31:24.141]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:24.141]                 ...future.oldOptions$nwarnings <- NULL
[10:31:24.141]             }
[10:31:24.141]             base::options(...future.oldOptions)
[10:31:24.141]             if (.Platform$OS.type == "windows") {
[10:31:24.141]                 old_names <- names(...future.oldEnvVars)
[10:31:24.141]                 envs <- base::Sys.getenv()
[10:31:24.141]                 names <- names(envs)
[10:31:24.141]                 common <- intersect(names, old_names)
[10:31:24.141]                 added <- setdiff(names, old_names)
[10:31:24.141]                 removed <- setdiff(old_names, names)
[10:31:24.141]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:24.141]                   envs[common]]
[10:31:24.141]                 NAMES <- toupper(changed)
[10:31:24.141]                 args <- list()
[10:31:24.141]                 for (kk in seq_along(NAMES)) {
[10:31:24.141]                   name <- changed[[kk]]
[10:31:24.141]                   NAME <- NAMES[[kk]]
[10:31:24.141]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.141]                     next
[10:31:24.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.141]                 }
[10:31:24.141]                 NAMES <- toupper(added)
[10:31:24.141]                 for (kk in seq_along(NAMES)) {
[10:31:24.141]                   name <- added[[kk]]
[10:31:24.141]                   NAME <- NAMES[[kk]]
[10:31:24.141]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.141]                     next
[10:31:24.141]                   args[[name]] <- ""
[10:31:24.141]                 }
[10:31:24.141]                 NAMES <- toupper(removed)
[10:31:24.141]                 for (kk in seq_along(NAMES)) {
[10:31:24.141]                   name <- removed[[kk]]
[10:31:24.141]                   NAME <- NAMES[[kk]]
[10:31:24.141]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.141]                     next
[10:31:24.141]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.141]                 }
[10:31:24.141]                 if (length(args) > 0) 
[10:31:24.141]                   base::do.call(base::Sys.setenv, args = args)
[10:31:24.141]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:24.141]             }
[10:31:24.141]             else {
[10:31:24.141]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:24.141]             }
[10:31:24.141]             {
[10:31:24.141]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:24.141]                   0L) {
[10:31:24.141]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:24.141]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:24.141]                   base::options(opts)
[10:31:24.141]                 }
[10:31:24.141]                 {
[10:31:24.141]                   {
[10:31:24.141]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:24.141]                     NULL
[10:31:24.141]                   }
[10:31:24.141]                   options(future.plan = NULL)
[10:31:24.141]                   if (is.na(NA_character_)) 
[10:31:24.141]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.141]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:24.141]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:24.141]                     .init = FALSE)
[10:31:24.141]                 }
[10:31:24.141]             }
[10:31:24.141]         }
[10:31:24.141]     })
[10:31:24.141]     if (TRUE) {
[10:31:24.141]         base::sink(type = "output", split = FALSE)
[10:31:24.141]         if (TRUE) {
[10:31:24.141]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:24.141]         }
[10:31:24.141]         else {
[10:31:24.141]             ...future.result["stdout"] <- base::list(NULL)
[10:31:24.141]         }
[10:31:24.141]         base::close(...future.stdout)
[10:31:24.141]         ...future.stdout <- NULL
[10:31:24.141]     }
[10:31:24.141]     ...future.result$conditions <- ...future.conditions
[10:31:24.141]     ...future.result$finished <- base::Sys.time()
[10:31:24.141]     ...future.result
[10:31:24.141] }
[10:31:24.143] assign_globals() ...
[10:31:24.143] List of 11
[10:31:24.143]  $ ...future.FUN            :function (x, ...)  
[10:31:24.143]  $ x_FUN                    :function (x, y)  
[10:31:24.143]  $ times                    : int 15
[10:31:24.143]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:24.143]  $ stop_if_not              :function (...)  
[10:31:24.143]  $ dim                      : int [1:2] 3 5
[10:31:24.143]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:24.143]  $ future.call.arguments    :List of 1
[10:31:24.143]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:24.143]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.143]  $ ...future.elements_ii    :List of 2
[10:31:24.143]   ..$ A: num 50
[10:31:24.143]   ..$ B: num 60
[10:31:24.143]  $ ...future.seeds_ii       : NULL
[10:31:24.143]  $ ...future.globals.maxSize: NULL
[10:31:24.143]  - attr(*, "where")=List of 11
[10:31:24.143]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:24.143]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:24.143]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:24.143]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:24.143]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:24.143]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:24.143]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:24.143]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:24.143]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:24.143]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:24.143]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:24.143]  - attr(*, "resolved")= logi FALSE
[10:31:24.143]  - attr(*, "total_size")= num 98600
[10:31:24.143]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.143]  - attr(*, "already-done")= logi TRUE
[10:31:24.152] - copied ‘...future.FUN’ to environment
[10:31:24.152] - reassign environment for ‘x_FUN’
[10:31:24.152] - copied ‘x_FUN’ to environment
[10:31:24.152] - copied ‘times’ to environment
[10:31:24.152] - copied ‘stopf’ to environment
[10:31:24.152] - copied ‘stop_if_not’ to environment
[10:31:24.152] - copied ‘dim’ to environment
[10:31:24.153] - copied ‘valid_types’ to environment
[10:31:24.153] - copied ‘future.call.arguments’ to environment
[10:31:24.153] - copied ‘...future.elements_ii’ to environment
[10:31:24.153] - copied ‘...future.seeds_ii’ to environment
[10:31:24.153] - copied ‘...future.globals.maxSize’ to environment
[10:31:24.153] assign_globals() ... done
[10:31:24.153] requestCore(): workers = 2
[10:31:24.156] MulticoreFuture started
[10:31:24.156] - Launch lazy future ... done
[10:31:24.156] run() for ‘MulticoreFuture’ ... done
[10:31:24.156] Created future:
[10:31:24.157] plan(): Setting new future strategy stack:
[10:31:24.158] List of future strategies:
[10:31:24.158] 1. sequential:
[10:31:24.158]    - args: function (..., envir = parent.frame())
[10:31:24.158]    - tweaked: FALSE
[10:31:24.158]    - call: NULL
[10:31:24.158] plan(): nbrOfWorkers() = 1
[10:31:24.161] plan(): Setting new future strategy stack:
[10:31:24.161] List of future strategies:
[10:31:24.161] 1. multicore:
[10:31:24.161]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:24.161]    - tweaked: FALSE
[10:31:24.161]    - call: plan(strategy)
[10:31:24.157] MulticoreFuture:
[10:31:24.157] Label: ‘future_vapply-1’
[10:31:24.157] Expression:
[10:31:24.157] {
[10:31:24.157]     do.call(function(...) {
[10:31:24.157]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.157]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.157]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.157]             on.exit(options(oopts), add = TRUE)
[10:31:24.157]         }
[10:31:24.157]         {
[10:31:24.157]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.157]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.157]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.157]             })
[10:31:24.157]         }
[10:31:24.157]     }, args = future.call.arguments)
[10:31:24.157] }
[10:31:24.157] Lazy evaluation: FALSE
[10:31:24.157] Asynchronous evaluation: TRUE
[10:31:24.157] Local evaluation: TRUE
[10:31:24.157] Environment: R_GlobalEnv
[10:31:24.157] Capture standard output: TRUE
[10:31:24.157] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:24.157] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:24.157] Packages: 1 packages (‘future.apply’)
[10:31:24.157] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:24.157] Resolved: FALSE
[10:31:24.157] Value: <not collected>
[10:31:24.157] Conditions captured: <none>
[10:31:24.157] Early signaling: FALSE
[10:31:24.157] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:24.157] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.170] Chunk #1 of 2 ... DONE
[10:31:24.171] Chunk #2 of 2 ...
[10:31:24.171]  - Finding globals in 'X' for chunk #2 ...
[10:31:24.171] getGlobalsAndPackages() ...
[10:31:24.171] Searching for globals...
[10:31:24.172] 
[10:31:24.172] Searching for globals ... DONE
[10:31:24.172] plan(): nbrOfWorkers() = 2
[10:31:24.172] - globals: [0] <none>
[10:31:24.172] getGlobalsAndPackages() ... DONE
[10:31:24.175]    + additional globals found: [n=0] 
[10:31:24.175]    + additional namespaces needed: [n=0] 
[10:31:24.175]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:24.175]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:24.176]  - seeds: <none>
[10:31:24.176]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.176] getGlobalsAndPackages() ...
[10:31:24.176] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.177] Resolving globals: FALSE
[10:31:24.177] Tweak future expression to call with '...' arguments ...
[10:31:24.178] {
[10:31:24.178]     do.call(function(...) {
[10:31:24.178]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.178]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.178]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.178]             on.exit(options(oopts), add = TRUE)
[10:31:24.178]         }
[10:31:24.178]         {
[10:31:24.178]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.178]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.178]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.178]             })
[10:31:24.178]         }
[10:31:24.178]     }, args = future.call.arguments)
[10:31:24.178] }
[10:31:24.178] Tweak future expression to call with '...' arguments ... DONE
[10:31:24.179] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.180] - packages: [1] ‘future.apply’
[10:31:24.180] getGlobalsAndPackages() ... DONE
[10:31:24.181] run() for ‘Future’ ...
[10:31:24.181] - state: ‘created’
[10:31:24.181] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:24.187] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.187] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:24.187]   - Field: ‘label’
[10:31:24.187]   - Field: ‘local’
[10:31:24.188]   - Field: ‘owner’
[10:31:24.188]   - Field: ‘envir’
[10:31:24.188]   - Field: ‘workers’
[10:31:24.188]   - Field: ‘packages’
[10:31:24.189]   - Field: ‘gc’
[10:31:24.189]   - Field: ‘job’
[10:31:24.189]   - Field: ‘conditions’
[10:31:24.189]   - Field: ‘expr’
[10:31:24.190]   - Field: ‘uuid’
[10:31:24.190]   - Field: ‘seed’
[10:31:24.190]   - Field: ‘version’
[10:31:24.190]   - Field: ‘result’
[10:31:24.190]   - Field: ‘asynchronous’
[10:31:24.190]   - Field: ‘calls’
[10:31:24.191]   - Field: ‘globals’
[10:31:24.191]   - Field: ‘stdout’
[10:31:24.191]   - Field: ‘earlySignal’
[10:31:24.191]   - Field: ‘lazy’
[10:31:24.191]   - Field: ‘state’
[10:31:24.191] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:24.192] - Launch lazy future ...
[10:31:24.192] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:24.192] Packages needed by future strategies (n = 0): <none>
[10:31:24.193] {
[10:31:24.193]     {
[10:31:24.193]         {
[10:31:24.193]             ...future.startTime <- base::Sys.time()
[10:31:24.193]             {
[10:31:24.193]                 {
[10:31:24.193]                   {
[10:31:24.193]                     {
[10:31:24.193]                       {
[10:31:24.193]                         base::local({
[10:31:24.193]                           has_future <- base::requireNamespace("future", 
[10:31:24.193]                             quietly = TRUE)
[10:31:24.193]                           if (has_future) {
[10:31:24.193]                             ns <- base::getNamespace("future")
[10:31:24.193]                             version <- ns[[".package"]][["version"]]
[10:31:24.193]                             if (is.null(version)) 
[10:31:24.193]                               version <- utils::packageVersion("future")
[10:31:24.193]                           }
[10:31:24.193]                           else {
[10:31:24.193]                             version <- NULL
[10:31:24.193]                           }
[10:31:24.193]                           if (!has_future || version < "1.8.0") {
[10:31:24.193]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:24.193]                               "", base::R.version$version.string), 
[10:31:24.193]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:24.193]                                 base::R.version$platform, 8 * 
[10:31:24.193]                                   base::.Machine$sizeof.pointer), 
[10:31:24.193]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:24.193]                                 "release", "version")], collapse = " "), 
[10:31:24.193]                               hostname = base::Sys.info()[["nodename"]])
[10:31:24.193]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:24.193]                               info)
[10:31:24.193]                             info <- base::paste(info, collapse = "; ")
[10:31:24.193]                             if (!has_future) {
[10:31:24.193]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:24.193]                                 info)
[10:31:24.193]                             }
[10:31:24.193]                             else {
[10:31:24.193]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:24.193]                                 info, version)
[10:31:24.193]                             }
[10:31:24.193]                             base::stop(msg)
[10:31:24.193]                           }
[10:31:24.193]                         })
[10:31:24.193]                       }
[10:31:24.193]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:24.193]                       base::options(mc.cores = 1L)
[10:31:24.193]                     }
[10:31:24.193]                     base::local({
[10:31:24.193]                       for (pkg in "future.apply") {
[10:31:24.193]                         base::loadNamespace(pkg)
[10:31:24.193]                         base::library(pkg, character.only = TRUE)
[10:31:24.193]                       }
[10:31:24.193]                     })
[10:31:24.193]                   }
[10:31:24.193]                   ...future.strategy.old <- future::plan("list")
[10:31:24.193]                   options(future.plan = NULL)
[10:31:24.193]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.193]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:24.193]                 }
[10:31:24.193]                 ...future.workdir <- getwd()
[10:31:24.193]             }
[10:31:24.193]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:24.193]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:24.193]         }
[10:31:24.193]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:24.193]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:24.193]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:24.193]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:24.193]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:24.193]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:24.193]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:24.193]             base::names(...future.oldOptions))
[10:31:24.193]     }
[10:31:24.193]     if (FALSE) {
[10:31:24.193]     }
[10:31:24.193]     else {
[10:31:24.193]         if (TRUE) {
[10:31:24.193]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:24.193]                 open = "w")
[10:31:24.193]         }
[10:31:24.193]         else {
[10:31:24.193]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:24.193]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:24.193]         }
[10:31:24.193]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:24.193]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:24.193]             base::sink(type = "output", split = FALSE)
[10:31:24.193]             base::close(...future.stdout)
[10:31:24.193]         }, add = TRUE)
[10:31:24.193]     }
[10:31:24.193]     ...future.frame <- base::sys.nframe()
[10:31:24.193]     ...future.conditions <- base::list()
[10:31:24.193]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:24.193]     if (FALSE) {
[10:31:24.193]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:24.193]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:24.193]     }
[10:31:24.193]     ...future.result <- base::tryCatch({
[10:31:24.193]         base::withCallingHandlers({
[10:31:24.193]             ...future.value <- base::withVisible(base::local({
[10:31:24.193]                 withCallingHandlers({
[10:31:24.193]                   {
[10:31:24.193]                     do.call(function(...) {
[10:31:24.193]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.193]                       if (!identical(...future.globals.maxSize.org, 
[10:31:24.193]                         ...future.globals.maxSize)) {
[10:31:24.193]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.193]                         on.exit(options(oopts), add = TRUE)
[10:31:24.193]                       }
[10:31:24.193]                       {
[10:31:24.193]                         lapply(seq_along(...future.elements_ii), 
[10:31:24.193]                           FUN = function(jj) {
[10:31:24.193]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.193]                             ...future.FUN(...future.X_jj, ...)
[10:31:24.193]                           })
[10:31:24.193]                       }
[10:31:24.193]                     }, args = future.call.arguments)
[10:31:24.193]                   }
[10:31:24.193]                 }, immediateCondition = function(cond) {
[10:31:24.193]                   save_rds <- function (object, pathname, ...) 
[10:31:24.193]                   {
[10:31:24.193]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:24.193]                     if (file_test("-f", pathname_tmp)) {
[10:31:24.193]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.193]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:24.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.193]                         fi_tmp[["mtime"]])
[10:31:24.193]                     }
[10:31:24.193]                     tryCatch({
[10:31:24.193]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:24.193]                     }, error = function(ex) {
[10:31:24.193]                       msg <- conditionMessage(ex)
[10:31:24.193]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.193]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:24.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.193]                         fi_tmp[["mtime"]], msg)
[10:31:24.193]                       ex$message <- msg
[10:31:24.193]                       stop(ex)
[10:31:24.193]                     })
[10:31:24.193]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:24.193]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:24.193]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:24.193]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.193]                       fi <- file.info(pathname)
[10:31:24.193]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:24.193]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.193]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:24.193]                         fi[["size"]], fi[["mtime"]])
[10:31:24.193]                       stop(msg)
[10:31:24.193]                     }
[10:31:24.193]                     invisible(pathname)
[10:31:24.193]                   }
[10:31:24.193]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:24.193]                     rootPath = tempdir()) 
[10:31:24.193]                   {
[10:31:24.193]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:24.193]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:24.193]                       tmpdir = path, fileext = ".rds")
[10:31:24.193]                     save_rds(obj, file)
[10:31:24.193]                   }
[10:31:24.193]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:24.193]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.193]                   {
[10:31:24.193]                     inherits <- base::inherits
[10:31:24.193]                     invokeRestart <- base::invokeRestart
[10:31:24.193]                     is.null <- base::is.null
[10:31:24.193]                     muffled <- FALSE
[10:31:24.193]                     if (inherits(cond, "message")) {
[10:31:24.193]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:24.193]                       if (muffled) 
[10:31:24.193]                         invokeRestart("muffleMessage")
[10:31:24.193]                     }
[10:31:24.193]                     else if (inherits(cond, "warning")) {
[10:31:24.193]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:24.193]                       if (muffled) 
[10:31:24.193]                         invokeRestart("muffleWarning")
[10:31:24.193]                     }
[10:31:24.193]                     else if (inherits(cond, "condition")) {
[10:31:24.193]                       if (!is.null(pattern)) {
[10:31:24.193]                         computeRestarts <- base::computeRestarts
[10:31:24.193]                         grepl <- base::grepl
[10:31:24.193]                         restarts <- computeRestarts(cond)
[10:31:24.193]                         for (restart in restarts) {
[10:31:24.193]                           name <- restart$name
[10:31:24.193]                           if (is.null(name)) 
[10:31:24.193]                             next
[10:31:24.193]                           if (!grepl(pattern, name)) 
[10:31:24.193]                             next
[10:31:24.193]                           invokeRestart(restart)
[10:31:24.193]                           muffled <- TRUE
[10:31:24.193]                           break
[10:31:24.193]                         }
[10:31:24.193]                       }
[10:31:24.193]                     }
[10:31:24.193]                     invisible(muffled)
[10:31:24.193]                   }
[10:31:24.193]                   muffleCondition(cond)
[10:31:24.193]                 })
[10:31:24.193]             }))
[10:31:24.193]             future::FutureResult(value = ...future.value$value, 
[10:31:24.193]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.193]                   ...future.rng), globalenv = if (FALSE) 
[10:31:24.193]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:24.193]                     ...future.globalenv.names))
[10:31:24.193]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:24.193]         }, condition = base::local({
[10:31:24.193]             c <- base::c
[10:31:24.193]             inherits <- base::inherits
[10:31:24.193]             invokeRestart <- base::invokeRestart
[10:31:24.193]             length <- base::length
[10:31:24.193]             list <- base::list
[10:31:24.193]             seq.int <- base::seq.int
[10:31:24.193]             signalCondition <- base::signalCondition
[10:31:24.193]             sys.calls <- base::sys.calls
[10:31:24.193]             `[[` <- base::`[[`
[10:31:24.193]             `+` <- base::`+`
[10:31:24.193]             `<<-` <- base::`<<-`
[10:31:24.193]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:24.193]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:24.193]                   3L)]
[10:31:24.193]             }
[10:31:24.193]             function(cond) {
[10:31:24.193]                 is_error <- inherits(cond, "error")
[10:31:24.193]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:24.193]                   NULL)
[10:31:24.193]                 if (is_error) {
[10:31:24.193]                   sessionInformation <- function() {
[10:31:24.193]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:24.193]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:24.193]                       search = base::search(), system = base::Sys.info())
[10:31:24.193]                   }
[10:31:24.193]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.193]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:24.193]                     cond$call), session = sessionInformation(), 
[10:31:24.193]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:24.193]                   signalCondition(cond)
[10:31:24.193]                 }
[10:31:24.193]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:24.193]                 "immediateCondition"))) {
[10:31:24.193]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:24.193]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.193]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:24.193]                   if (TRUE && !signal) {
[10:31:24.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.193]                     {
[10:31:24.193]                       inherits <- base::inherits
[10:31:24.193]                       invokeRestart <- base::invokeRestart
[10:31:24.193]                       is.null <- base::is.null
[10:31:24.193]                       muffled <- FALSE
[10:31:24.193]                       if (inherits(cond, "message")) {
[10:31:24.193]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.193]                         if (muffled) 
[10:31:24.193]                           invokeRestart("muffleMessage")
[10:31:24.193]                       }
[10:31:24.193]                       else if (inherits(cond, "warning")) {
[10:31:24.193]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.193]                         if (muffled) 
[10:31:24.193]                           invokeRestart("muffleWarning")
[10:31:24.193]                       }
[10:31:24.193]                       else if (inherits(cond, "condition")) {
[10:31:24.193]                         if (!is.null(pattern)) {
[10:31:24.193]                           computeRestarts <- base::computeRestarts
[10:31:24.193]                           grepl <- base::grepl
[10:31:24.193]                           restarts <- computeRestarts(cond)
[10:31:24.193]                           for (restart in restarts) {
[10:31:24.193]                             name <- restart$name
[10:31:24.193]                             if (is.null(name)) 
[10:31:24.193]                               next
[10:31:24.193]                             if (!grepl(pattern, name)) 
[10:31:24.193]                               next
[10:31:24.193]                             invokeRestart(restart)
[10:31:24.193]                             muffled <- TRUE
[10:31:24.193]                             break
[10:31:24.193]                           }
[10:31:24.193]                         }
[10:31:24.193]                       }
[10:31:24.193]                       invisible(muffled)
[10:31:24.193]                     }
[10:31:24.193]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.193]                   }
[10:31:24.193]                 }
[10:31:24.193]                 else {
[10:31:24.193]                   if (TRUE) {
[10:31:24.193]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.193]                     {
[10:31:24.193]                       inherits <- base::inherits
[10:31:24.193]                       invokeRestart <- base::invokeRestart
[10:31:24.193]                       is.null <- base::is.null
[10:31:24.193]                       muffled <- FALSE
[10:31:24.193]                       if (inherits(cond, "message")) {
[10:31:24.193]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.193]                         if (muffled) 
[10:31:24.193]                           invokeRestart("muffleMessage")
[10:31:24.193]                       }
[10:31:24.193]                       else if (inherits(cond, "warning")) {
[10:31:24.193]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.193]                         if (muffled) 
[10:31:24.193]                           invokeRestart("muffleWarning")
[10:31:24.193]                       }
[10:31:24.193]                       else if (inherits(cond, "condition")) {
[10:31:24.193]                         if (!is.null(pattern)) {
[10:31:24.193]                           computeRestarts <- base::computeRestarts
[10:31:24.193]                           grepl <- base::grepl
[10:31:24.193]                           restarts <- computeRestarts(cond)
[10:31:24.193]                           for (restart in restarts) {
[10:31:24.193]                             name <- restart$name
[10:31:24.193]                             if (is.null(name)) 
[10:31:24.193]                               next
[10:31:24.193]                             if (!grepl(pattern, name)) 
[10:31:24.193]                               next
[10:31:24.193]                             invokeRestart(restart)
[10:31:24.193]                             muffled <- TRUE
[10:31:24.193]                             break
[10:31:24.193]                           }
[10:31:24.193]                         }
[10:31:24.193]                       }
[10:31:24.193]                       invisible(muffled)
[10:31:24.193]                     }
[10:31:24.193]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.193]                   }
[10:31:24.193]                 }
[10:31:24.193]             }
[10:31:24.193]         }))
[10:31:24.193]     }, error = function(ex) {
[10:31:24.193]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:24.193]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.193]                 ...future.rng), started = ...future.startTime, 
[10:31:24.193]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:24.193]             version = "1.8"), class = "FutureResult")
[10:31:24.193]     }, finally = {
[10:31:24.193]         if (!identical(...future.workdir, getwd())) 
[10:31:24.193]             setwd(...future.workdir)
[10:31:24.193]         {
[10:31:24.193]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:24.193]                 ...future.oldOptions$nwarnings <- NULL
[10:31:24.193]             }
[10:31:24.193]             base::options(...future.oldOptions)
[10:31:24.193]             if (.Platform$OS.type == "windows") {
[10:31:24.193]                 old_names <- names(...future.oldEnvVars)
[10:31:24.193]                 envs <- base::Sys.getenv()
[10:31:24.193]                 names <- names(envs)
[10:31:24.193]                 common <- intersect(names, old_names)
[10:31:24.193]                 added <- setdiff(names, old_names)
[10:31:24.193]                 removed <- setdiff(old_names, names)
[10:31:24.193]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:24.193]                   envs[common]]
[10:31:24.193]                 NAMES <- toupper(changed)
[10:31:24.193]                 args <- list()
[10:31:24.193]                 for (kk in seq_along(NAMES)) {
[10:31:24.193]                   name <- changed[[kk]]
[10:31:24.193]                   NAME <- NAMES[[kk]]
[10:31:24.193]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.193]                     next
[10:31:24.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.193]                 }
[10:31:24.193]                 NAMES <- toupper(added)
[10:31:24.193]                 for (kk in seq_along(NAMES)) {
[10:31:24.193]                   name <- added[[kk]]
[10:31:24.193]                   NAME <- NAMES[[kk]]
[10:31:24.193]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.193]                     next
[10:31:24.193]                   args[[name]] <- ""
[10:31:24.193]                 }
[10:31:24.193]                 NAMES <- toupper(removed)
[10:31:24.193]                 for (kk in seq_along(NAMES)) {
[10:31:24.193]                   name <- removed[[kk]]
[10:31:24.193]                   NAME <- NAMES[[kk]]
[10:31:24.193]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.193]                     next
[10:31:24.193]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.193]                 }
[10:31:24.193]                 if (length(args) > 0) 
[10:31:24.193]                   base::do.call(base::Sys.setenv, args = args)
[10:31:24.193]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:24.193]             }
[10:31:24.193]             else {
[10:31:24.193]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:24.193]             }
[10:31:24.193]             {
[10:31:24.193]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:24.193]                   0L) {
[10:31:24.193]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:24.193]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:24.193]                   base::options(opts)
[10:31:24.193]                 }
[10:31:24.193]                 {
[10:31:24.193]                   {
[10:31:24.193]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:24.193]                     NULL
[10:31:24.193]                   }
[10:31:24.193]                   options(future.plan = NULL)
[10:31:24.193]                   if (is.na(NA_character_)) 
[10:31:24.193]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.193]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:24.193]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:24.193]                     .init = FALSE)
[10:31:24.193]                 }
[10:31:24.193]             }
[10:31:24.193]         }
[10:31:24.193]     })
[10:31:24.193]     if (TRUE) {
[10:31:24.193]         base::sink(type = "output", split = FALSE)
[10:31:24.193]         if (TRUE) {
[10:31:24.193]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:24.193]         }
[10:31:24.193]         else {
[10:31:24.193]             ...future.result["stdout"] <- base::list(NULL)
[10:31:24.193]         }
[10:31:24.193]         base::close(...future.stdout)
[10:31:24.193]         ...future.stdout <- NULL
[10:31:24.193]     }
[10:31:24.193]     ...future.result$conditions <- ...future.conditions
[10:31:24.193]     ...future.result$finished <- base::Sys.time()
[10:31:24.193]     ...future.result
[10:31:24.193] }
[10:31:24.196] assign_globals() ...
[10:31:24.196] List of 11
[10:31:24.196]  $ ...future.FUN            :function (x, ...)  
[10:31:24.196]  $ x_FUN                    :function (x, y)  
[10:31:24.196]  $ times                    : int 15
[10:31:24.196]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:24.196]  $ stop_if_not              :function (...)  
[10:31:24.196]  $ dim                      : int [1:2] 3 5
[10:31:24.196]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:24.196]  $ future.call.arguments    :List of 1
[10:31:24.196]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:24.196]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.196]  $ ...future.elements_ii    :List of 2
[10:31:24.196]   ..$ C: num 70
[10:31:24.196]   ..$ D: num 80
[10:31:24.196]  $ ...future.seeds_ii       : NULL
[10:31:24.196]  $ ...future.globals.maxSize: NULL
[10:31:24.196]  - attr(*, "where")=List of 11
[10:31:24.196]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:24.196]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:24.196]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:24.196]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:24.196]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:24.196]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:24.196]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:24.196]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:24.196]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:24.196]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:24.196]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:24.196]  - attr(*, "resolved")= logi FALSE
[10:31:24.196]  - attr(*, "total_size")= num 98600
[10:31:24.196]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.196]  - attr(*, "already-done")= logi TRUE
[10:31:24.207] - copied ‘...future.FUN’ to environment
[10:31:24.207] - reassign environment for ‘x_FUN’
[10:31:24.207] - copied ‘x_FUN’ to environment
[10:31:24.207] - copied ‘times’ to environment
[10:31:24.207] - copied ‘stopf’ to environment
[10:31:24.207] - copied ‘stop_if_not’ to environment
[10:31:24.207] - copied ‘dim’ to environment
[10:31:24.207] - copied ‘valid_types’ to environment
[10:31:24.208] - copied ‘future.call.arguments’ to environment
[10:31:24.208] - copied ‘...future.elements_ii’ to environment
[10:31:24.208] - copied ‘...future.seeds_ii’ to environment
[10:31:24.208] - copied ‘...future.globals.maxSize’ to environment
[10:31:24.210] assign_globals() ... done
[10:31:24.210] requestCore(): workers = 2
[10:31:24.213] MulticoreFuture started
[10:31:24.214] - Launch lazy future ... done
[10:31:24.214] run() for ‘MulticoreFuture’ ... done
[10:31:24.215] Created future:
[10:31:24.215] plan(): Setting new future strategy stack:
[10:31:24.216] List of future strategies:
[10:31:24.216] 1. sequential:
[10:31:24.216]    - args: function (..., envir = parent.frame())
[10:31:24.216]    - tweaked: FALSE
[10:31:24.216]    - call: NULL
[10:31:24.217] plan(): nbrOfWorkers() = 1
[10:31:24.220] plan(): Setting new future strategy stack:
[10:31:24.220] List of future strategies:
[10:31:24.220] 1. multicore:
[10:31:24.220]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:24.220]    - tweaked: FALSE
[10:31:24.220]    - call: plan(strategy)
[10:31:24.227] plan(): nbrOfWorkers() = 2
[10:31:24.215] MulticoreFuture:
[10:31:24.215] Label: ‘future_vapply-2’
[10:31:24.215] Expression:
[10:31:24.215] {
[10:31:24.215]     do.call(function(...) {
[10:31:24.215]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.215]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.215]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.215]             on.exit(options(oopts), add = TRUE)
[10:31:24.215]         }
[10:31:24.215]         {
[10:31:24.215]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.215]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.215]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.215]             })
[10:31:24.215]         }
[10:31:24.215]     }, args = future.call.arguments)
[10:31:24.215] }
[10:31:24.215] Lazy evaluation: FALSE
[10:31:24.215] Asynchronous evaluation: TRUE
[10:31:24.215] Local evaluation: TRUE
[10:31:24.215] Environment: R_GlobalEnv
[10:31:24.215] Capture standard output: TRUE
[10:31:24.215] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:24.215] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:24.215] Packages: 1 packages (‘future.apply’)
[10:31:24.215] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:24.215] Resolved: TRUE
[10:31:24.215] Value: <not collected>
[10:31:24.215] Conditions captured: <none>
[10:31:24.215] Early signaling: FALSE
[10:31:24.215] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:24.215] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.228] Chunk #2 of 2 ... DONE
[10:31:24.228] Launching 2 futures (chunks) ... DONE
[10:31:24.228] Resolving 2 futures (chunks) ...
[10:31:24.229] resolve() on list ...
[10:31:24.229]  recursive: 0
[10:31:24.229]  length: 2
[10:31:24.229] 
[10:31:24.230] Future #1
[10:31:24.230] result() for MulticoreFuture ...
[10:31:24.231] result() for MulticoreFuture ...
[10:31:24.231] result() for MulticoreFuture ... done
[10:31:24.231] result() for MulticoreFuture ... done
[10:31:24.232] result() for MulticoreFuture ...
[10:31:24.232] result() for MulticoreFuture ... done
[10:31:24.232] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:24.232] - nx: 2
[10:31:24.233] - relay: TRUE
[10:31:24.233] - stdout: TRUE
[10:31:24.233] - signal: TRUE
[10:31:24.233] - resignal: FALSE
[10:31:24.234] - force: TRUE
[10:31:24.234] - relayed: [n=2] FALSE, FALSE
[10:31:24.234] - queued futures: [n=2] FALSE, FALSE
[10:31:24.234]  - until=1
[10:31:24.235]  - relaying element #1
[10:31:24.235] result() for MulticoreFuture ...
[10:31:24.235] result() for MulticoreFuture ... done
[10:31:24.235] result() for MulticoreFuture ...
[10:31:24.235] result() for MulticoreFuture ... done
[10:31:24.236] result() for MulticoreFuture ...
[10:31:24.236] result() for MulticoreFuture ... done
[10:31:24.236] result() for MulticoreFuture ...
[10:31:24.236] result() for MulticoreFuture ... done
[10:31:24.237] - relayed: [n=2] TRUE, FALSE
[10:31:24.237] - queued futures: [n=2] TRUE, FALSE
[10:31:24.237] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:24.237]  length: 1 (resolved future 1)
[10:31:24.238] Future #2
[10:31:24.238] result() for MulticoreFuture ...
[10:31:24.239] result() for MulticoreFuture ...
[10:31:24.239] result() for MulticoreFuture ... done
[10:31:24.239] result() for MulticoreFuture ... done
[10:31:24.239] result() for MulticoreFuture ...
[10:31:24.240] result() for MulticoreFuture ... done
[10:31:24.240] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:24.240] - nx: 2
[10:31:24.241] - relay: TRUE
[10:31:24.241] - stdout: TRUE
[10:31:24.241] - signal: TRUE
[10:31:24.241] - resignal: FALSE
[10:31:24.241] - force: TRUE
[10:31:24.241] - relayed: [n=2] TRUE, FALSE
[10:31:24.241] - queued futures: [n=2] TRUE, FALSE
[10:31:24.241]  - until=2
[10:31:24.242]  - relaying element #2
[10:31:24.242] result() for MulticoreFuture ...
[10:31:24.242] result() for MulticoreFuture ... done
[10:31:24.242] result() for MulticoreFuture ...
[10:31:24.242] result() for MulticoreFuture ... done
[10:31:24.242] result() for MulticoreFuture ...
[10:31:24.242] result() for MulticoreFuture ... done
[10:31:24.243] result() for MulticoreFuture ...
[10:31:24.243] result() for MulticoreFuture ... done
[10:31:24.243] - relayed: [n=2] TRUE, TRUE
[10:31:24.243] - queued futures: [n=2] TRUE, TRUE
[10:31:24.243] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:24.243]  length: 0 (resolved future 2)
[10:31:24.243] Relaying remaining futures
[10:31:24.243] signalConditionsASAP(NULL, pos=0) ...
[10:31:24.244] - nx: 2
[10:31:24.244] - relay: TRUE
[10:31:24.244] - stdout: TRUE
[10:31:24.244] - signal: TRUE
[10:31:24.244] - resignal: FALSE
[10:31:24.244] - force: TRUE
[10:31:24.244] - relayed: [n=2] TRUE, TRUE
[10:31:24.244] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:24.244] - relayed: [n=2] TRUE, TRUE
[10:31:24.245] - queued futures: [n=2] TRUE, TRUE
[10:31:24.245] signalConditionsASAP(NULL, pos=0) ... done
[10:31:24.245] resolve() on list ... DONE
[10:31:24.245] result() for MulticoreFuture ...
[10:31:24.245] result() for MulticoreFuture ... done
[10:31:24.245] result() for MulticoreFuture ...
[10:31:24.245] result() for MulticoreFuture ... done
[10:31:24.245] result() for MulticoreFuture ...
[10:31:24.245] result() for MulticoreFuture ... done
[10:31:24.246] result() for MulticoreFuture ...
[10:31:24.246] result() for MulticoreFuture ... done
[10:31:24.246]  - Number of value chunks collected: 2
[10:31:24.246] Resolving 2 futures (chunks) ... DONE
[10:31:24.246] Reducing values from 2 chunks ...
[10:31:24.246]  - Number of values collected after concatenation: 4
[10:31:24.246]  - Number of values expected: 4
[10:31:24.246] Reducing values from 2 chunks ... DONE
[10:31:24.246] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[10:31:24.249] future_lapply() ...
[10:31:24.255] Number of chunks: 2
[10:31:24.255] getGlobalsAndPackagesXApply() ...
[10:31:24.256]  - future.globals: TRUE
[10:31:24.256] getGlobalsAndPackages() ...
[10:31:24.256] Searching for globals...
[10:31:24.262] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:24.262] Searching for globals ... DONE
[10:31:24.262] Resolving globals: FALSE
[10:31:24.263] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[10:31:24.264] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:24.264] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:24.264] - packages: [1] ‘future.apply’
[10:31:24.264] getGlobalsAndPackages() ... DONE
[10:31:24.264]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:24.265]  - needed namespaces: [n=1] ‘future.apply’
[10:31:24.265] Finding globals ... DONE
[10:31:24.265]  - use_args: TRUE
[10:31:24.265]  - Getting '...' globals ...
[10:31:24.265] resolve() on list ...
[10:31:24.266]  recursive: 0
[10:31:24.266]  length: 1
[10:31:24.266]  elements: ‘...’
[10:31:24.266]  length: 0 (resolved future 1)
[10:31:24.266] resolve() on list ... DONE
[10:31:24.266]    - '...' content: [n=0] 
[10:31:24.266] List of 1
[10:31:24.266]  $ ...: list()
[10:31:24.266]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.266]  - attr(*, "where")=List of 1
[10:31:24.266]   ..$ ...:<environment: 0x55de8571cb28> 
[10:31:24.266]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.266]  - attr(*, "resolved")= logi TRUE
[10:31:24.266]  - attr(*, "total_size")= num NA
[10:31:24.269]  - Getting '...' globals ... DONE
[10:31:24.269] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:24.269] List of 8
[10:31:24.269]  $ ...future.FUN:function (x, ...)  
[10:31:24.269]  $ x_FUN        :function (x)  
[10:31:24.269]  $ times        : int 1
[10:31:24.269]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:24.269]  $ stop_if_not  :function (...)  
[10:31:24.269]  $ dim          : NULL
[10:31:24.269]  $ valid_types  : chr "logical"
[10:31:24.269]  $ ...          : list()
[10:31:24.269]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.269]  - attr(*, "where")=List of 8
[10:31:24.269]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:24.269]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:24.269]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:24.269]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:24.269]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:24.269]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:24.269]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:24.269]   ..$ ...          :<environment: 0x55de8571cb28> 
[10:31:24.269]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.269]  - attr(*, "resolved")= logi FALSE
[10:31:24.269]  - attr(*, "total_size")= num 94200
[10:31:24.275] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:24.275] getGlobalsAndPackagesXApply() ... DONE
[10:31:24.275] Number of futures (= number of chunks): 2
[10:31:24.275] Launching 2 futures (chunks) ...
[10:31:24.275] Chunk #1 of 2 ...
[10:31:24.275]  - Finding globals in 'X' for chunk #1 ...
[10:31:24.276] getGlobalsAndPackages() ...
[10:31:24.276] Searching for globals...
[10:31:24.276] 
[10:31:24.276] Searching for globals ... DONE
[10:31:24.276] - globals: [0] <none>
[10:31:24.276] getGlobalsAndPackages() ... DONE
[10:31:24.276]    + additional globals found: [n=0] 
[10:31:24.276]    + additional namespaces needed: [n=0] 
[10:31:24.277]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:24.277]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:24.277]  - seeds: <none>
[10:31:24.277]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.277] getGlobalsAndPackages() ...
[10:31:24.277] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.277] Resolving globals: FALSE
[10:31:24.277] Tweak future expression to call with '...' arguments ...
[10:31:24.280] {
[10:31:24.280]     do.call(function(...) {
[10:31:24.280]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.280]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.280]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.280]             on.exit(options(oopts), add = TRUE)
[10:31:24.280]         }
[10:31:24.280]         {
[10:31:24.280]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.280]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.280]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.280]             })
[10:31:24.280]         }
[10:31:24.280]     }, args = future.call.arguments)
[10:31:24.280] }
[10:31:24.280] Tweak future expression to call with '...' arguments ... DONE
[10:31:24.281] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.281] - packages: [1] ‘future.apply’
[10:31:24.281] getGlobalsAndPackages() ... DONE
[10:31:24.281] run() for ‘Future’ ...
[10:31:24.282] - state: ‘created’
[10:31:24.282] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:24.286] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.286] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:24.286]   - Field: ‘label’
[10:31:24.287]   - Field: ‘local’
[10:31:24.287]   - Field: ‘owner’
[10:31:24.287]   - Field: ‘envir’
[10:31:24.287]   - Field: ‘workers’
[10:31:24.287]   - Field: ‘packages’
[10:31:24.287]   - Field: ‘gc’
[10:31:24.287]   - Field: ‘job’
[10:31:24.287]   - Field: ‘conditions’
[10:31:24.288]   - Field: ‘expr’
[10:31:24.288]   - Field: ‘uuid’
[10:31:24.288]   - Field: ‘seed’
[10:31:24.288]   - Field: ‘version’
[10:31:24.288]   - Field: ‘result’
[10:31:24.288]   - Field: ‘asynchronous’
[10:31:24.288]   - Field: ‘calls’
[10:31:24.288]   - Field: ‘globals’
[10:31:24.288]   - Field: ‘stdout’
[10:31:24.289]   - Field: ‘earlySignal’
[10:31:24.289]   - Field: ‘lazy’
[10:31:24.289]   - Field: ‘state’
[10:31:24.289] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:24.289] - Launch lazy future ...
[10:31:24.289] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:24.290] Packages needed by future strategies (n = 0): <none>
[10:31:24.290] {
[10:31:24.290]     {
[10:31:24.290]         {
[10:31:24.290]             ...future.startTime <- base::Sys.time()
[10:31:24.290]             {
[10:31:24.290]                 {
[10:31:24.290]                   {
[10:31:24.290]                     {
[10:31:24.290]                       {
[10:31:24.290]                         base::local({
[10:31:24.290]                           has_future <- base::requireNamespace("future", 
[10:31:24.290]                             quietly = TRUE)
[10:31:24.290]                           if (has_future) {
[10:31:24.290]                             ns <- base::getNamespace("future")
[10:31:24.290]                             version <- ns[[".package"]][["version"]]
[10:31:24.290]                             if (is.null(version)) 
[10:31:24.290]                               version <- utils::packageVersion("future")
[10:31:24.290]                           }
[10:31:24.290]                           else {
[10:31:24.290]                             version <- NULL
[10:31:24.290]                           }
[10:31:24.290]                           if (!has_future || version < "1.8.0") {
[10:31:24.290]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:24.290]                               "", base::R.version$version.string), 
[10:31:24.290]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:24.290]                                 base::R.version$platform, 8 * 
[10:31:24.290]                                   base::.Machine$sizeof.pointer), 
[10:31:24.290]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:24.290]                                 "release", "version")], collapse = " "), 
[10:31:24.290]                               hostname = base::Sys.info()[["nodename"]])
[10:31:24.290]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:24.290]                               info)
[10:31:24.290]                             info <- base::paste(info, collapse = "; ")
[10:31:24.290]                             if (!has_future) {
[10:31:24.290]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:24.290]                                 info)
[10:31:24.290]                             }
[10:31:24.290]                             else {
[10:31:24.290]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:24.290]                                 info, version)
[10:31:24.290]                             }
[10:31:24.290]                             base::stop(msg)
[10:31:24.290]                           }
[10:31:24.290]                         })
[10:31:24.290]                       }
[10:31:24.290]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:24.290]                       base::options(mc.cores = 1L)
[10:31:24.290]                     }
[10:31:24.290]                     base::local({
[10:31:24.290]                       for (pkg in "future.apply") {
[10:31:24.290]                         base::loadNamespace(pkg)
[10:31:24.290]                         base::library(pkg, character.only = TRUE)
[10:31:24.290]                       }
[10:31:24.290]                     })
[10:31:24.290]                   }
[10:31:24.290]                   ...future.strategy.old <- future::plan("list")
[10:31:24.290]                   options(future.plan = NULL)
[10:31:24.290]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.290]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:24.290]                 }
[10:31:24.290]                 ...future.workdir <- getwd()
[10:31:24.290]             }
[10:31:24.290]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:24.290]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:24.290]         }
[10:31:24.290]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:24.290]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:24.290]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:24.290]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:24.290]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:24.290]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:24.290]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:24.290]             base::names(...future.oldOptions))
[10:31:24.290]     }
[10:31:24.290]     if (FALSE) {
[10:31:24.290]     }
[10:31:24.290]     else {
[10:31:24.290]         if (TRUE) {
[10:31:24.290]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:24.290]                 open = "w")
[10:31:24.290]         }
[10:31:24.290]         else {
[10:31:24.290]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:24.290]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:24.290]         }
[10:31:24.290]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:24.290]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:24.290]             base::sink(type = "output", split = FALSE)
[10:31:24.290]             base::close(...future.stdout)
[10:31:24.290]         }, add = TRUE)
[10:31:24.290]     }
[10:31:24.290]     ...future.frame <- base::sys.nframe()
[10:31:24.290]     ...future.conditions <- base::list()
[10:31:24.290]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:24.290]     if (FALSE) {
[10:31:24.290]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:24.290]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:24.290]     }
[10:31:24.290]     ...future.result <- base::tryCatch({
[10:31:24.290]         base::withCallingHandlers({
[10:31:24.290]             ...future.value <- base::withVisible(base::local({
[10:31:24.290]                 withCallingHandlers({
[10:31:24.290]                   {
[10:31:24.290]                     do.call(function(...) {
[10:31:24.290]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.290]                       if (!identical(...future.globals.maxSize.org, 
[10:31:24.290]                         ...future.globals.maxSize)) {
[10:31:24.290]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.290]                         on.exit(options(oopts), add = TRUE)
[10:31:24.290]                       }
[10:31:24.290]                       {
[10:31:24.290]                         lapply(seq_along(...future.elements_ii), 
[10:31:24.290]                           FUN = function(jj) {
[10:31:24.290]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.290]                             ...future.FUN(...future.X_jj, ...)
[10:31:24.290]                           })
[10:31:24.290]                       }
[10:31:24.290]                     }, args = future.call.arguments)
[10:31:24.290]                   }
[10:31:24.290]                 }, immediateCondition = function(cond) {
[10:31:24.290]                   save_rds <- function (object, pathname, ...) 
[10:31:24.290]                   {
[10:31:24.290]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:24.290]                     if (file_test("-f", pathname_tmp)) {
[10:31:24.290]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.290]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:24.290]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.290]                         fi_tmp[["mtime"]])
[10:31:24.290]                     }
[10:31:24.290]                     tryCatch({
[10:31:24.290]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:24.290]                     }, error = function(ex) {
[10:31:24.290]                       msg <- conditionMessage(ex)
[10:31:24.290]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.290]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:24.290]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.290]                         fi_tmp[["mtime"]], msg)
[10:31:24.290]                       ex$message <- msg
[10:31:24.290]                       stop(ex)
[10:31:24.290]                     })
[10:31:24.290]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:24.290]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:24.290]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:24.290]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.290]                       fi <- file.info(pathname)
[10:31:24.290]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:24.290]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.290]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:24.290]                         fi[["size"]], fi[["mtime"]])
[10:31:24.290]                       stop(msg)
[10:31:24.290]                     }
[10:31:24.290]                     invisible(pathname)
[10:31:24.290]                   }
[10:31:24.290]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:24.290]                     rootPath = tempdir()) 
[10:31:24.290]                   {
[10:31:24.290]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:24.290]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:24.290]                       tmpdir = path, fileext = ".rds")
[10:31:24.290]                     save_rds(obj, file)
[10:31:24.290]                   }
[10:31:24.290]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:24.290]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.290]                   {
[10:31:24.290]                     inherits <- base::inherits
[10:31:24.290]                     invokeRestart <- base::invokeRestart
[10:31:24.290]                     is.null <- base::is.null
[10:31:24.290]                     muffled <- FALSE
[10:31:24.290]                     if (inherits(cond, "message")) {
[10:31:24.290]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:24.290]                       if (muffled) 
[10:31:24.290]                         invokeRestart("muffleMessage")
[10:31:24.290]                     }
[10:31:24.290]                     else if (inherits(cond, "warning")) {
[10:31:24.290]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:24.290]                       if (muffled) 
[10:31:24.290]                         invokeRestart("muffleWarning")
[10:31:24.290]                     }
[10:31:24.290]                     else if (inherits(cond, "condition")) {
[10:31:24.290]                       if (!is.null(pattern)) {
[10:31:24.290]                         computeRestarts <- base::computeRestarts
[10:31:24.290]                         grepl <- base::grepl
[10:31:24.290]                         restarts <- computeRestarts(cond)
[10:31:24.290]                         for (restart in restarts) {
[10:31:24.290]                           name <- restart$name
[10:31:24.290]                           if (is.null(name)) 
[10:31:24.290]                             next
[10:31:24.290]                           if (!grepl(pattern, name)) 
[10:31:24.290]                             next
[10:31:24.290]                           invokeRestart(restart)
[10:31:24.290]                           muffled <- TRUE
[10:31:24.290]                           break
[10:31:24.290]                         }
[10:31:24.290]                       }
[10:31:24.290]                     }
[10:31:24.290]                     invisible(muffled)
[10:31:24.290]                   }
[10:31:24.290]                   muffleCondition(cond)
[10:31:24.290]                 })
[10:31:24.290]             }))
[10:31:24.290]             future::FutureResult(value = ...future.value$value, 
[10:31:24.290]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.290]                   ...future.rng), globalenv = if (FALSE) 
[10:31:24.290]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:24.290]                     ...future.globalenv.names))
[10:31:24.290]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:24.290]         }, condition = base::local({
[10:31:24.290]             c <- base::c
[10:31:24.290]             inherits <- base::inherits
[10:31:24.290]             invokeRestart <- base::invokeRestart
[10:31:24.290]             length <- base::length
[10:31:24.290]             list <- base::list
[10:31:24.290]             seq.int <- base::seq.int
[10:31:24.290]             signalCondition <- base::signalCondition
[10:31:24.290]             sys.calls <- base::sys.calls
[10:31:24.290]             `[[` <- base::`[[`
[10:31:24.290]             `+` <- base::`+`
[10:31:24.290]             `<<-` <- base::`<<-`
[10:31:24.290]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:24.290]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:24.290]                   3L)]
[10:31:24.290]             }
[10:31:24.290]             function(cond) {
[10:31:24.290]                 is_error <- inherits(cond, "error")
[10:31:24.290]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:24.290]                   NULL)
[10:31:24.290]                 if (is_error) {
[10:31:24.290]                   sessionInformation <- function() {
[10:31:24.290]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:24.290]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:24.290]                       search = base::search(), system = base::Sys.info())
[10:31:24.290]                   }
[10:31:24.290]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.290]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:24.290]                     cond$call), session = sessionInformation(), 
[10:31:24.290]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:24.290]                   signalCondition(cond)
[10:31:24.290]                 }
[10:31:24.290]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:24.290]                 "immediateCondition"))) {
[10:31:24.290]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:24.290]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.290]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:24.290]                   if (TRUE && !signal) {
[10:31:24.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.290]                     {
[10:31:24.290]                       inherits <- base::inherits
[10:31:24.290]                       invokeRestart <- base::invokeRestart
[10:31:24.290]                       is.null <- base::is.null
[10:31:24.290]                       muffled <- FALSE
[10:31:24.290]                       if (inherits(cond, "message")) {
[10:31:24.290]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.290]                         if (muffled) 
[10:31:24.290]                           invokeRestart("muffleMessage")
[10:31:24.290]                       }
[10:31:24.290]                       else if (inherits(cond, "warning")) {
[10:31:24.290]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.290]                         if (muffled) 
[10:31:24.290]                           invokeRestart("muffleWarning")
[10:31:24.290]                       }
[10:31:24.290]                       else if (inherits(cond, "condition")) {
[10:31:24.290]                         if (!is.null(pattern)) {
[10:31:24.290]                           computeRestarts <- base::computeRestarts
[10:31:24.290]                           grepl <- base::grepl
[10:31:24.290]                           restarts <- computeRestarts(cond)
[10:31:24.290]                           for (restart in restarts) {
[10:31:24.290]                             name <- restart$name
[10:31:24.290]                             if (is.null(name)) 
[10:31:24.290]                               next
[10:31:24.290]                             if (!grepl(pattern, name)) 
[10:31:24.290]                               next
[10:31:24.290]                             invokeRestart(restart)
[10:31:24.290]                             muffled <- TRUE
[10:31:24.290]                             break
[10:31:24.290]                           }
[10:31:24.290]                         }
[10:31:24.290]                       }
[10:31:24.290]                       invisible(muffled)
[10:31:24.290]                     }
[10:31:24.290]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.290]                   }
[10:31:24.290]                 }
[10:31:24.290]                 else {
[10:31:24.290]                   if (TRUE) {
[10:31:24.290]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.290]                     {
[10:31:24.290]                       inherits <- base::inherits
[10:31:24.290]                       invokeRestart <- base::invokeRestart
[10:31:24.290]                       is.null <- base::is.null
[10:31:24.290]                       muffled <- FALSE
[10:31:24.290]                       if (inherits(cond, "message")) {
[10:31:24.290]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.290]                         if (muffled) 
[10:31:24.290]                           invokeRestart("muffleMessage")
[10:31:24.290]                       }
[10:31:24.290]                       else if (inherits(cond, "warning")) {
[10:31:24.290]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.290]                         if (muffled) 
[10:31:24.290]                           invokeRestart("muffleWarning")
[10:31:24.290]                       }
[10:31:24.290]                       else if (inherits(cond, "condition")) {
[10:31:24.290]                         if (!is.null(pattern)) {
[10:31:24.290]                           computeRestarts <- base::computeRestarts
[10:31:24.290]                           grepl <- base::grepl
[10:31:24.290]                           restarts <- computeRestarts(cond)
[10:31:24.290]                           for (restart in restarts) {
[10:31:24.290]                             name <- restart$name
[10:31:24.290]                             if (is.null(name)) 
[10:31:24.290]                               next
[10:31:24.290]                             if (!grepl(pattern, name)) 
[10:31:24.290]                               next
[10:31:24.290]                             invokeRestart(restart)
[10:31:24.290]                             muffled <- TRUE
[10:31:24.290]                             break
[10:31:24.290]                           }
[10:31:24.290]                         }
[10:31:24.290]                       }
[10:31:24.290]                       invisible(muffled)
[10:31:24.290]                     }
[10:31:24.290]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.290]                   }
[10:31:24.290]                 }
[10:31:24.290]             }
[10:31:24.290]         }))
[10:31:24.290]     }, error = function(ex) {
[10:31:24.290]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:24.290]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.290]                 ...future.rng), started = ...future.startTime, 
[10:31:24.290]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:24.290]             version = "1.8"), class = "FutureResult")
[10:31:24.290]     }, finally = {
[10:31:24.290]         if (!identical(...future.workdir, getwd())) 
[10:31:24.290]             setwd(...future.workdir)
[10:31:24.290]         {
[10:31:24.290]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:24.290]                 ...future.oldOptions$nwarnings <- NULL
[10:31:24.290]             }
[10:31:24.290]             base::options(...future.oldOptions)
[10:31:24.290]             if (.Platform$OS.type == "windows") {
[10:31:24.290]                 old_names <- names(...future.oldEnvVars)
[10:31:24.290]                 envs <- base::Sys.getenv()
[10:31:24.290]                 names <- names(envs)
[10:31:24.290]                 common <- intersect(names, old_names)
[10:31:24.290]                 added <- setdiff(names, old_names)
[10:31:24.290]                 removed <- setdiff(old_names, names)
[10:31:24.290]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:24.290]                   envs[common]]
[10:31:24.290]                 NAMES <- toupper(changed)
[10:31:24.290]                 args <- list()
[10:31:24.290]                 for (kk in seq_along(NAMES)) {
[10:31:24.290]                   name <- changed[[kk]]
[10:31:24.290]                   NAME <- NAMES[[kk]]
[10:31:24.290]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.290]                     next
[10:31:24.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.290]                 }
[10:31:24.290]                 NAMES <- toupper(added)
[10:31:24.290]                 for (kk in seq_along(NAMES)) {
[10:31:24.290]                   name <- added[[kk]]
[10:31:24.290]                   NAME <- NAMES[[kk]]
[10:31:24.290]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.290]                     next
[10:31:24.290]                   args[[name]] <- ""
[10:31:24.290]                 }
[10:31:24.290]                 NAMES <- toupper(removed)
[10:31:24.290]                 for (kk in seq_along(NAMES)) {
[10:31:24.290]                   name <- removed[[kk]]
[10:31:24.290]                   NAME <- NAMES[[kk]]
[10:31:24.290]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.290]                     next
[10:31:24.290]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.290]                 }
[10:31:24.290]                 if (length(args) > 0) 
[10:31:24.290]                   base::do.call(base::Sys.setenv, args = args)
[10:31:24.290]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:24.290]             }
[10:31:24.290]             else {
[10:31:24.290]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:24.290]             }
[10:31:24.290]             {
[10:31:24.290]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:24.290]                   0L) {
[10:31:24.290]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:24.290]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:24.290]                   base::options(opts)
[10:31:24.290]                 }
[10:31:24.290]                 {
[10:31:24.290]                   {
[10:31:24.290]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:24.290]                     NULL
[10:31:24.290]                   }
[10:31:24.290]                   options(future.plan = NULL)
[10:31:24.290]                   if (is.na(NA_character_)) 
[10:31:24.290]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.290]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:24.290]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:24.290]                     .init = FALSE)
[10:31:24.290]                 }
[10:31:24.290]             }
[10:31:24.290]         }
[10:31:24.290]     })
[10:31:24.290]     if (TRUE) {
[10:31:24.290]         base::sink(type = "output", split = FALSE)
[10:31:24.290]         if (TRUE) {
[10:31:24.290]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:24.290]         }
[10:31:24.290]         else {
[10:31:24.290]             ...future.result["stdout"] <- base::list(NULL)
[10:31:24.290]         }
[10:31:24.290]         base::close(...future.stdout)
[10:31:24.290]         ...future.stdout <- NULL
[10:31:24.290]     }
[10:31:24.290]     ...future.result$conditions <- ...future.conditions
[10:31:24.290]     ...future.result$finished <- base::Sys.time()
[10:31:24.290]     ...future.result
[10:31:24.290] }
[10:31:24.293] assign_globals() ...
[10:31:24.293] List of 11
[10:31:24.293]  $ ...future.FUN            :function (x, ...)  
[10:31:24.293]  $ x_FUN                    :function (x)  
[10:31:24.293]  $ times                    : int 1
[10:31:24.293]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:24.293]  $ stop_if_not              :function (...)  
[10:31:24.293]  $ dim                      : NULL
[10:31:24.293]  $ valid_types              : chr "logical"
[10:31:24.293]  $ future.call.arguments    : list()
[10:31:24.293]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.293]  $ ...future.elements_ii    :List of 6
[10:31:24.293]   ..$ mpg : num [1:32] 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
[10:31:24.293]   ..$ cyl : num [1:32] 6 6 4 6 8 6 8 4 4 6 ...
[10:31:24.293]   ..$ disp: num [1:32] 160 160 108 258 360 ...
[10:31:24.293]   ..$ hp  : num [1:32] 110 110 93 110 175 105 245 62 95 123 ...
[10:31:24.293]   ..$ drat: num [1:32] 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
[10:31:24.293]   ..$ wt  : num [1:32] 2.62 2.88 2.32 3.21 3.44 ...
[10:31:24.293]  $ ...future.seeds_ii       : NULL
[10:31:24.293]  $ ...future.globals.maxSize: NULL
[10:31:24.293]  - attr(*, "where")=List of 11
[10:31:24.293]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:24.293]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:24.293]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:24.293]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:24.293]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:24.293]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:24.293]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:24.293]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:24.293]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:24.293]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:24.293]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:24.293]  - attr(*, "resolved")= logi FALSE
[10:31:24.293]  - attr(*, "total_size")= num 94200
[10:31:24.293]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.293]  - attr(*, "already-done")= logi TRUE
[10:31:24.303] - copied ‘...future.FUN’ to environment
[10:31:24.303] - copied ‘x_FUN’ to environment
[10:31:24.303] - copied ‘times’ to environment
[10:31:24.303] - copied ‘stopf’ to environment
[10:31:24.303] - copied ‘stop_if_not’ to environment
[10:31:24.303] - copied ‘dim’ to environment
[10:31:24.303] - copied ‘valid_types’ to environment
[10:31:24.303] - copied ‘future.call.arguments’ to environment
[10:31:24.303] - copied ‘...future.elements_ii’ to environment
[10:31:24.303] - copied ‘...future.seeds_ii’ to environment
[10:31:24.306] - copied ‘...future.globals.maxSize’ to environment
[10:31:24.306] assign_globals() ... done
[10:31:24.306] requestCore(): workers = 2
[10:31:24.309] MulticoreFuture started
[10:31:24.310] - Launch lazy future ... done
[10:31:24.310] run() for ‘MulticoreFuture’ ... done
[10:31:24.311] Created future:
[10:31:24.311] plan(): Setting new future strategy stack:
[10:31:24.311] List of future strategies:
[10:31:24.311] 1. sequential:
[10:31:24.311]    - args: function (..., envir = parent.frame())
[10:31:24.311]    - tweaked: FALSE
[10:31:24.311]    - call: NULL
[10:31:24.313] plan(): nbrOfWorkers() = 1
[10:31:24.316] plan(): Setting new future strategy stack:
[10:31:24.316] List of future strategies:
[10:31:24.316] 1. multicore:
[10:31:24.316]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:24.316]    - tweaked: FALSE
[10:31:24.316]    - call: plan(strategy)
[10:31:24.323] plan(): nbrOfWorkers() = 2
[10:31:24.311] MulticoreFuture:
[10:31:24.311] Label: ‘future_vapply-1’
[10:31:24.311] Expression:
[10:31:24.311] {
[10:31:24.311]     do.call(function(...) {
[10:31:24.311]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.311]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.311]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.311]             on.exit(options(oopts), add = TRUE)
[10:31:24.311]         }
[10:31:24.311]         {
[10:31:24.311]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.311]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.311]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.311]             })
[10:31:24.311]         }
[10:31:24.311]     }, args = future.call.arguments)
[10:31:24.311] }
[10:31:24.311] Lazy evaluation: FALSE
[10:31:24.311] Asynchronous evaluation: TRUE
[10:31:24.311] Local evaluation: TRUE
[10:31:24.311] Environment: R_GlobalEnv
[10:31:24.311] Capture standard output: TRUE
[10:31:24.311] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:24.311] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:24.311] Packages: 1 packages (‘future.apply’)
[10:31:24.311] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:24.311] Resolved: TRUE
[10:31:24.311] Value: <not collected>
[10:31:24.311] Conditions captured: <none>
[10:31:24.311] Early signaling: FALSE
[10:31:24.311] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:24.311] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.324] Chunk #1 of 2 ... DONE
[10:31:24.325] Chunk #2 of 2 ...
[10:31:24.325]  - Finding globals in 'X' for chunk #2 ...
[10:31:24.325] getGlobalsAndPackages() ...
[10:31:24.325] Searching for globals...
[10:31:24.326] 
[10:31:24.326] Searching for globals ... DONE
[10:31:24.326] - globals: [0] <none>
[10:31:24.327] getGlobalsAndPackages() ... DONE
[10:31:24.327]    + additional globals found: [n=0] 
[10:31:24.327]    + additional namespaces needed: [n=0] 
[10:31:24.327]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:24.327]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:24.327]  - seeds: <none>
[10:31:24.328]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.328] getGlobalsAndPackages() ...
[10:31:24.328] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.328] Resolving globals: FALSE
[10:31:24.329] Tweak future expression to call with '...' arguments ...
[10:31:24.329] {
[10:31:24.329]     do.call(function(...) {
[10:31:24.329]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.329]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.329]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.329]             on.exit(options(oopts), add = TRUE)
[10:31:24.329]         }
[10:31:24.329]         {
[10:31:24.329]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.329]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.329]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.329]             })
[10:31:24.329]         }
[10:31:24.329]     }, args = future.call.arguments)
[10:31:24.329] }
[10:31:24.330] Tweak future expression to call with '...' arguments ... DONE
[10:31:24.331] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.331] - packages: [1] ‘future.apply’
[10:31:24.331] getGlobalsAndPackages() ... DONE
[10:31:24.332] run() for ‘Future’ ...
[10:31:24.332] - state: ‘created’
[10:31:24.333] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:24.338] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.338] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:24.339]   - Field: ‘label’
[10:31:24.339]   - Field: ‘local’
[10:31:24.339]   - Field: ‘owner’
[10:31:24.339]   - Field: ‘envir’
[10:31:24.339]   - Field: ‘workers’
[10:31:24.339]   - Field: ‘packages’
[10:31:24.340]   - Field: ‘gc’
[10:31:24.340]   - Field: ‘job’
[10:31:24.340]   - Field: ‘conditions’
[10:31:24.340]   - Field: ‘expr’
[10:31:24.340]   - Field: ‘uuid’
[10:31:24.340]   - Field: ‘seed’
[10:31:24.340]   - Field: ‘version’
[10:31:24.341]   - Field: ‘result’
[10:31:24.341]   - Field: ‘asynchronous’
[10:31:24.341]   - Field: ‘calls’
[10:31:24.341]   - Field: ‘globals’
[10:31:24.341]   - Field: ‘stdout’
[10:31:24.341]   - Field: ‘earlySignal’
[10:31:24.341]   - Field: ‘lazy’
[10:31:24.342]   - Field: ‘state’
[10:31:24.342] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:24.342] - Launch lazy future ...
[10:31:24.342] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:24.342] Packages needed by future strategies (n = 0): <none>
[10:31:24.343] {
[10:31:24.343]     {
[10:31:24.343]         {
[10:31:24.343]             ...future.startTime <- base::Sys.time()
[10:31:24.343]             {
[10:31:24.343]                 {
[10:31:24.343]                   {
[10:31:24.343]                     {
[10:31:24.343]                       {
[10:31:24.343]                         base::local({
[10:31:24.343]                           has_future <- base::requireNamespace("future", 
[10:31:24.343]                             quietly = TRUE)
[10:31:24.343]                           if (has_future) {
[10:31:24.343]                             ns <- base::getNamespace("future")
[10:31:24.343]                             version <- ns[[".package"]][["version"]]
[10:31:24.343]                             if (is.null(version)) 
[10:31:24.343]                               version <- utils::packageVersion("future")
[10:31:24.343]                           }
[10:31:24.343]                           else {
[10:31:24.343]                             version <- NULL
[10:31:24.343]                           }
[10:31:24.343]                           if (!has_future || version < "1.8.0") {
[10:31:24.343]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:24.343]                               "", base::R.version$version.string), 
[10:31:24.343]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:24.343]                                 base::R.version$platform, 8 * 
[10:31:24.343]                                   base::.Machine$sizeof.pointer), 
[10:31:24.343]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:24.343]                                 "release", "version")], collapse = " "), 
[10:31:24.343]                               hostname = base::Sys.info()[["nodename"]])
[10:31:24.343]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:24.343]                               info)
[10:31:24.343]                             info <- base::paste(info, collapse = "; ")
[10:31:24.343]                             if (!has_future) {
[10:31:24.343]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:24.343]                                 info)
[10:31:24.343]                             }
[10:31:24.343]                             else {
[10:31:24.343]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:24.343]                                 info, version)
[10:31:24.343]                             }
[10:31:24.343]                             base::stop(msg)
[10:31:24.343]                           }
[10:31:24.343]                         })
[10:31:24.343]                       }
[10:31:24.343]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:24.343]                       base::options(mc.cores = 1L)
[10:31:24.343]                     }
[10:31:24.343]                     base::local({
[10:31:24.343]                       for (pkg in "future.apply") {
[10:31:24.343]                         base::loadNamespace(pkg)
[10:31:24.343]                         base::library(pkg, character.only = TRUE)
[10:31:24.343]                       }
[10:31:24.343]                     })
[10:31:24.343]                   }
[10:31:24.343]                   ...future.strategy.old <- future::plan("list")
[10:31:24.343]                   options(future.plan = NULL)
[10:31:24.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:24.343]                 }
[10:31:24.343]                 ...future.workdir <- getwd()
[10:31:24.343]             }
[10:31:24.343]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:24.343]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:24.343]         }
[10:31:24.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:24.343]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:24.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:24.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:24.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:24.343]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:24.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:24.343]             base::names(...future.oldOptions))
[10:31:24.343]     }
[10:31:24.343]     if (FALSE) {
[10:31:24.343]     }
[10:31:24.343]     else {
[10:31:24.343]         if (TRUE) {
[10:31:24.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:24.343]                 open = "w")
[10:31:24.343]         }
[10:31:24.343]         else {
[10:31:24.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:24.343]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:24.343]         }
[10:31:24.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:24.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:24.343]             base::sink(type = "output", split = FALSE)
[10:31:24.343]             base::close(...future.stdout)
[10:31:24.343]         }, add = TRUE)
[10:31:24.343]     }
[10:31:24.343]     ...future.frame <- base::sys.nframe()
[10:31:24.343]     ...future.conditions <- base::list()
[10:31:24.343]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:24.343]     if (FALSE) {
[10:31:24.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:24.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:24.343]     }
[10:31:24.343]     ...future.result <- base::tryCatch({
[10:31:24.343]         base::withCallingHandlers({
[10:31:24.343]             ...future.value <- base::withVisible(base::local({
[10:31:24.343]                 withCallingHandlers({
[10:31:24.343]                   {
[10:31:24.343]                     do.call(function(...) {
[10:31:24.343]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.343]                       if (!identical(...future.globals.maxSize.org, 
[10:31:24.343]                         ...future.globals.maxSize)) {
[10:31:24.343]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.343]                         on.exit(options(oopts), add = TRUE)
[10:31:24.343]                       }
[10:31:24.343]                       {
[10:31:24.343]                         lapply(seq_along(...future.elements_ii), 
[10:31:24.343]                           FUN = function(jj) {
[10:31:24.343]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.343]                             ...future.FUN(...future.X_jj, ...)
[10:31:24.343]                           })
[10:31:24.343]                       }
[10:31:24.343]                     }, args = future.call.arguments)
[10:31:24.343]                   }
[10:31:24.343]                 }, immediateCondition = function(cond) {
[10:31:24.343]                   save_rds <- function (object, pathname, ...) 
[10:31:24.343]                   {
[10:31:24.343]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:24.343]                     if (file_test("-f", pathname_tmp)) {
[10:31:24.343]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.343]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:24.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.343]                         fi_tmp[["mtime"]])
[10:31:24.343]                     }
[10:31:24.343]                     tryCatch({
[10:31:24.343]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:24.343]                     }, error = function(ex) {
[10:31:24.343]                       msg <- conditionMessage(ex)
[10:31:24.343]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.343]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:24.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.343]                         fi_tmp[["mtime"]], msg)
[10:31:24.343]                       ex$message <- msg
[10:31:24.343]                       stop(ex)
[10:31:24.343]                     })
[10:31:24.343]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:24.343]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:24.343]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:24.343]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.343]                       fi <- file.info(pathname)
[10:31:24.343]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:24.343]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.343]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:24.343]                         fi[["size"]], fi[["mtime"]])
[10:31:24.343]                       stop(msg)
[10:31:24.343]                     }
[10:31:24.343]                     invisible(pathname)
[10:31:24.343]                   }
[10:31:24.343]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:24.343]                     rootPath = tempdir()) 
[10:31:24.343]                   {
[10:31:24.343]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:24.343]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:24.343]                       tmpdir = path, fileext = ".rds")
[10:31:24.343]                     save_rds(obj, file)
[10:31:24.343]                   }
[10:31:24.343]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:24.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.343]                   {
[10:31:24.343]                     inherits <- base::inherits
[10:31:24.343]                     invokeRestart <- base::invokeRestart
[10:31:24.343]                     is.null <- base::is.null
[10:31:24.343]                     muffled <- FALSE
[10:31:24.343]                     if (inherits(cond, "message")) {
[10:31:24.343]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:24.343]                       if (muffled) 
[10:31:24.343]                         invokeRestart("muffleMessage")
[10:31:24.343]                     }
[10:31:24.343]                     else if (inherits(cond, "warning")) {
[10:31:24.343]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:24.343]                       if (muffled) 
[10:31:24.343]                         invokeRestart("muffleWarning")
[10:31:24.343]                     }
[10:31:24.343]                     else if (inherits(cond, "condition")) {
[10:31:24.343]                       if (!is.null(pattern)) {
[10:31:24.343]                         computeRestarts <- base::computeRestarts
[10:31:24.343]                         grepl <- base::grepl
[10:31:24.343]                         restarts <- computeRestarts(cond)
[10:31:24.343]                         for (restart in restarts) {
[10:31:24.343]                           name <- restart$name
[10:31:24.343]                           if (is.null(name)) 
[10:31:24.343]                             next
[10:31:24.343]                           if (!grepl(pattern, name)) 
[10:31:24.343]                             next
[10:31:24.343]                           invokeRestart(restart)
[10:31:24.343]                           muffled <- TRUE
[10:31:24.343]                           break
[10:31:24.343]                         }
[10:31:24.343]                       }
[10:31:24.343]                     }
[10:31:24.343]                     invisible(muffled)
[10:31:24.343]                   }
[10:31:24.343]                   muffleCondition(cond)
[10:31:24.343]                 })
[10:31:24.343]             }))
[10:31:24.343]             future::FutureResult(value = ...future.value$value, 
[10:31:24.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.343]                   ...future.rng), globalenv = if (FALSE) 
[10:31:24.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:24.343]                     ...future.globalenv.names))
[10:31:24.343]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:24.343]         }, condition = base::local({
[10:31:24.343]             c <- base::c
[10:31:24.343]             inherits <- base::inherits
[10:31:24.343]             invokeRestart <- base::invokeRestart
[10:31:24.343]             length <- base::length
[10:31:24.343]             list <- base::list
[10:31:24.343]             seq.int <- base::seq.int
[10:31:24.343]             signalCondition <- base::signalCondition
[10:31:24.343]             sys.calls <- base::sys.calls
[10:31:24.343]             `[[` <- base::`[[`
[10:31:24.343]             `+` <- base::`+`
[10:31:24.343]             `<<-` <- base::`<<-`
[10:31:24.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:24.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:24.343]                   3L)]
[10:31:24.343]             }
[10:31:24.343]             function(cond) {
[10:31:24.343]                 is_error <- inherits(cond, "error")
[10:31:24.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:24.343]                   NULL)
[10:31:24.343]                 if (is_error) {
[10:31:24.343]                   sessionInformation <- function() {
[10:31:24.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:24.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:24.343]                       search = base::search(), system = base::Sys.info())
[10:31:24.343]                   }
[10:31:24.343]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:24.343]                     cond$call), session = sessionInformation(), 
[10:31:24.343]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:24.343]                   signalCondition(cond)
[10:31:24.343]                 }
[10:31:24.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:24.343]                 "immediateCondition"))) {
[10:31:24.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:24.343]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:24.343]                   if (TRUE && !signal) {
[10:31:24.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.343]                     {
[10:31:24.343]                       inherits <- base::inherits
[10:31:24.343]                       invokeRestart <- base::invokeRestart
[10:31:24.343]                       is.null <- base::is.null
[10:31:24.343]                       muffled <- FALSE
[10:31:24.343]                       if (inherits(cond, "message")) {
[10:31:24.343]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.343]                         if (muffled) 
[10:31:24.343]                           invokeRestart("muffleMessage")
[10:31:24.343]                       }
[10:31:24.343]                       else if (inherits(cond, "warning")) {
[10:31:24.343]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.343]                         if (muffled) 
[10:31:24.343]                           invokeRestart("muffleWarning")
[10:31:24.343]                       }
[10:31:24.343]                       else if (inherits(cond, "condition")) {
[10:31:24.343]                         if (!is.null(pattern)) {
[10:31:24.343]                           computeRestarts <- base::computeRestarts
[10:31:24.343]                           grepl <- base::grepl
[10:31:24.343]                           restarts <- computeRestarts(cond)
[10:31:24.343]                           for (restart in restarts) {
[10:31:24.343]                             name <- restart$name
[10:31:24.343]                             if (is.null(name)) 
[10:31:24.343]                               next
[10:31:24.343]                             if (!grepl(pattern, name)) 
[10:31:24.343]                               next
[10:31:24.343]                             invokeRestart(restart)
[10:31:24.343]                             muffled <- TRUE
[10:31:24.343]                             break
[10:31:24.343]                           }
[10:31:24.343]                         }
[10:31:24.343]                       }
[10:31:24.343]                       invisible(muffled)
[10:31:24.343]                     }
[10:31:24.343]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.343]                   }
[10:31:24.343]                 }
[10:31:24.343]                 else {
[10:31:24.343]                   if (TRUE) {
[10:31:24.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.343]                     {
[10:31:24.343]                       inherits <- base::inherits
[10:31:24.343]                       invokeRestart <- base::invokeRestart
[10:31:24.343]                       is.null <- base::is.null
[10:31:24.343]                       muffled <- FALSE
[10:31:24.343]                       if (inherits(cond, "message")) {
[10:31:24.343]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.343]                         if (muffled) 
[10:31:24.343]                           invokeRestart("muffleMessage")
[10:31:24.343]                       }
[10:31:24.343]                       else if (inherits(cond, "warning")) {
[10:31:24.343]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.343]                         if (muffled) 
[10:31:24.343]                           invokeRestart("muffleWarning")
[10:31:24.343]                       }
[10:31:24.343]                       else if (inherits(cond, "condition")) {
[10:31:24.343]                         if (!is.null(pattern)) {
[10:31:24.343]                           computeRestarts <- base::computeRestarts
[10:31:24.343]                           grepl <- base::grepl
[10:31:24.343]                           restarts <- computeRestarts(cond)
[10:31:24.343]                           for (restart in restarts) {
[10:31:24.343]                             name <- restart$name
[10:31:24.343]                             if (is.null(name)) 
[10:31:24.343]                               next
[10:31:24.343]                             if (!grepl(pattern, name)) 
[10:31:24.343]                               next
[10:31:24.343]                             invokeRestart(restart)
[10:31:24.343]                             muffled <- TRUE
[10:31:24.343]                             break
[10:31:24.343]                           }
[10:31:24.343]                         }
[10:31:24.343]                       }
[10:31:24.343]                       invisible(muffled)
[10:31:24.343]                     }
[10:31:24.343]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.343]                   }
[10:31:24.343]                 }
[10:31:24.343]             }
[10:31:24.343]         }))
[10:31:24.343]     }, error = function(ex) {
[10:31:24.343]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:24.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.343]                 ...future.rng), started = ...future.startTime, 
[10:31:24.343]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:24.343]             version = "1.8"), class = "FutureResult")
[10:31:24.343]     }, finally = {
[10:31:24.343]         if (!identical(...future.workdir, getwd())) 
[10:31:24.343]             setwd(...future.workdir)
[10:31:24.343]         {
[10:31:24.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:24.343]                 ...future.oldOptions$nwarnings <- NULL
[10:31:24.343]             }
[10:31:24.343]             base::options(...future.oldOptions)
[10:31:24.343]             if (.Platform$OS.type == "windows") {
[10:31:24.343]                 old_names <- names(...future.oldEnvVars)
[10:31:24.343]                 envs <- base::Sys.getenv()
[10:31:24.343]                 names <- names(envs)
[10:31:24.343]                 common <- intersect(names, old_names)
[10:31:24.343]                 added <- setdiff(names, old_names)
[10:31:24.343]                 removed <- setdiff(old_names, names)
[10:31:24.343]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:24.343]                   envs[common]]
[10:31:24.343]                 NAMES <- toupper(changed)
[10:31:24.343]                 args <- list()
[10:31:24.343]                 for (kk in seq_along(NAMES)) {
[10:31:24.343]                   name <- changed[[kk]]
[10:31:24.343]                   NAME <- NAMES[[kk]]
[10:31:24.343]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.343]                     next
[10:31:24.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.343]                 }
[10:31:24.343]                 NAMES <- toupper(added)
[10:31:24.343]                 for (kk in seq_along(NAMES)) {
[10:31:24.343]                   name <- added[[kk]]
[10:31:24.343]                   NAME <- NAMES[[kk]]
[10:31:24.343]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.343]                     next
[10:31:24.343]                   args[[name]] <- ""
[10:31:24.343]                 }
[10:31:24.343]                 NAMES <- toupper(removed)
[10:31:24.343]                 for (kk in seq_along(NAMES)) {
[10:31:24.343]                   name <- removed[[kk]]
[10:31:24.343]                   NAME <- NAMES[[kk]]
[10:31:24.343]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.343]                     next
[10:31:24.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.343]                 }
[10:31:24.343]                 if (length(args) > 0) 
[10:31:24.343]                   base::do.call(base::Sys.setenv, args = args)
[10:31:24.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:24.343]             }
[10:31:24.343]             else {
[10:31:24.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:24.343]             }
[10:31:24.343]             {
[10:31:24.343]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:24.343]                   0L) {
[10:31:24.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:24.343]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:24.343]                   base::options(opts)
[10:31:24.343]                 }
[10:31:24.343]                 {
[10:31:24.343]                   {
[10:31:24.343]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:24.343]                     NULL
[10:31:24.343]                   }
[10:31:24.343]                   options(future.plan = NULL)
[10:31:24.343]                   if (is.na(NA_character_)) 
[10:31:24.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:24.343]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:24.343]                     .init = FALSE)
[10:31:24.343]                 }
[10:31:24.343]             }
[10:31:24.343]         }
[10:31:24.343]     })
[10:31:24.343]     if (TRUE) {
[10:31:24.343]         base::sink(type = "output", split = FALSE)
[10:31:24.343]         if (TRUE) {
[10:31:24.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:24.343]         }
[10:31:24.343]         else {
[10:31:24.343]             ...future.result["stdout"] <- base::list(NULL)
[10:31:24.343]         }
[10:31:24.343]         base::close(...future.stdout)
[10:31:24.343]         ...future.stdout <- NULL
[10:31:24.343]     }
[10:31:24.343]     ...future.result$conditions <- ...future.conditions
[10:31:24.343]     ...future.result$finished <- base::Sys.time()
[10:31:24.343]     ...future.result
[10:31:24.343] }
[10:31:24.347] assign_globals() ...
[10:31:24.347] List of 11
[10:31:24.347]  $ ...future.FUN            :function (x, ...)  
[10:31:24.347]  $ x_FUN                    :function (x)  
[10:31:24.347]  $ times                    : int 1
[10:31:24.347]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:24.347]  $ stop_if_not              :function (...)  
[10:31:24.347]  $ dim                      : NULL
[10:31:24.347]  $ valid_types              : chr "logical"
[10:31:24.347]  $ future.call.arguments    : list()
[10:31:24.347]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.347]  $ ...future.elements_ii    :List of 5
[10:31:24.347]   ..$ qsec: num [1:32] 16.5 17 18.6 19.4 17 ...
[10:31:24.347]   ..$ vs  : num [1:32] 0 0 1 1 0 1 0 1 1 1 ...
[10:31:24.347]   ..$ am  : num [1:32] 1 1 1 0 0 0 0 0 0 0 ...
[10:31:24.347]   ..$ gear: num [1:32] 4 4 4 3 3 3 3 4 4 4 ...
[10:31:24.347]   ..$ carb: num [1:32] 4 4 1 1 2 1 4 2 2 4 ...
[10:31:24.347]  $ ...future.seeds_ii       : NULL
[10:31:24.347]  $ ...future.globals.maxSize: NULL
[10:31:24.347]  - attr(*, "where")=List of 11
[10:31:24.347]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:24.347]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:24.347]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:24.347]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:24.347]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:24.347]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:24.347]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:24.347]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:24.347]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:24.347]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:24.347]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:24.347]  - attr(*, "resolved")= logi FALSE
[10:31:24.347]  - attr(*, "total_size")= num 94200
[10:31:24.347]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.347]  - attr(*, "already-done")= logi TRUE
[10:31:24.360] - copied ‘...future.FUN’ to environment
[10:31:24.361] - copied ‘x_FUN’ to environment
[10:31:24.361] - copied ‘times’ to environment
[10:31:24.361] - copied ‘stopf’ to environment
[10:31:24.361] - copied ‘stop_if_not’ to environment
[10:31:24.361] - copied ‘dim’ to environment
[10:31:24.361] - copied ‘valid_types’ to environment
[10:31:24.362] - copied ‘future.call.arguments’ to environment
[10:31:24.362] - copied ‘...future.elements_ii’ to environment
[10:31:24.362] - copied ‘...future.seeds_ii’ to environment
[10:31:24.362] - copied ‘...future.globals.maxSize’ to environment
[10:31:24.362] assign_globals() ... done
[10:31:24.362] requestCore(): workers = 2
[10:31:24.365] MulticoreFuture started
[10:31:24.365] - Launch lazy future ... done
[10:31:24.366] run() for ‘MulticoreFuture’ ... done
[10:31:24.366] Created future:
[10:31:24.367] plan(): Setting new future strategy stack:
[10:31:24.367] List of future strategies:
[10:31:24.367] 1. sequential:
[10:31:24.367]    - args: function (..., envir = parent.frame())
[10:31:24.367]    - tweaked: FALSE
[10:31:24.367]    - call: NULL
[10:31:24.368] plan(): nbrOfWorkers() = 1
[10:31:24.371] plan(): Setting new future strategy stack:
[10:31:24.372] List of future strategies:
[10:31:24.372] 1. multicore:
[10:31:24.372]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:24.372]    - tweaked: FALSE
[10:31:24.372]    - call: plan(strategy)
[10:31:24.377] plan(): nbrOfWorkers() = 2
[10:31:24.367] MulticoreFuture:
[10:31:24.367] Label: ‘future_vapply-2’
[10:31:24.367] Expression:
[10:31:24.367] {
[10:31:24.367]     do.call(function(...) {
[10:31:24.367]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.367]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.367]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.367]             on.exit(options(oopts), add = TRUE)
[10:31:24.367]         }
[10:31:24.367]         {
[10:31:24.367]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.367]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.367]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.367]             })
[10:31:24.367]         }
[10:31:24.367]     }, args = future.call.arguments)
[10:31:24.367] }
[10:31:24.367] Lazy evaluation: FALSE
[10:31:24.367] Asynchronous evaluation: TRUE
[10:31:24.367] Local evaluation: TRUE
[10:31:24.367] Environment: R_GlobalEnv
[10:31:24.367] Capture standard output: TRUE
[10:31:24.367] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:24.367] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:24.367] Packages: 1 packages (‘future.apply’)
[10:31:24.367] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:24.367] Resolved: TRUE
[10:31:24.367] Value: <not collected>
[10:31:24.367] Conditions captured: <none>
[10:31:24.367] Early signaling: FALSE
[10:31:24.367] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:24.367] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.378] Chunk #2 of 2 ... DONE
[10:31:24.378] Launching 2 futures (chunks) ... DONE
[10:31:24.379] Resolving 2 futures (chunks) ...
[10:31:24.379] resolve() on list ...
[10:31:24.379]  recursive: 0
[10:31:24.379]  length: 2
[10:31:24.379] 
[10:31:24.380] Future #1
[10:31:24.380] result() for MulticoreFuture ...
[10:31:24.381] result() for MulticoreFuture ...
[10:31:24.381] result() for MulticoreFuture ... done
[10:31:24.381] result() for MulticoreFuture ... done
[10:31:24.381] result() for MulticoreFuture ...
[10:31:24.381] result() for MulticoreFuture ... done
[10:31:24.382] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:24.382] - nx: 2
[10:31:24.382] - relay: TRUE
[10:31:24.382] - stdout: TRUE
[10:31:24.383] - signal: TRUE
[10:31:24.383] - resignal: FALSE
[10:31:24.383] - force: TRUE
[10:31:24.383] - relayed: [n=2] FALSE, FALSE
[10:31:24.383] - queued futures: [n=2] FALSE, FALSE
[10:31:24.383]  - until=1
[10:31:24.384]  - relaying element #1
[10:31:24.384] result() for MulticoreFuture ...
[10:31:24.384] result() for MulticoreFuture ... done
[10:31:24.384] result() for MulticoreFuture ...
[10:31:24.384] result() for MulticoreFuture ... done
[10:31:24.385] result() for MulticoreFuture ...
[10:31:24.385] result() for MulticoreFuture ... done
[10:31:24.385] result() for MulticoreFuture ...
[10:31:24.385] result() for MulticoreFuture ... done
[10:31:24.385] - relayed: [n=2] TRUE, FALSE
[10:31:24.385] - queued futures: [n=2] TRUE, FALSE
[10:31:24.385] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:24.386]  length: 1 (resolved future 1)
[10:31:24.386] Future #2
[10:31:24.386] result() for MulticoreFuture ...
[10:31:24.387] result() for MulticoreFuture ...
[10:31:24.387] result() for MulticoreFuture ... done
[10:31:24.387] result() for MulticoreFuture ... done
[10:31:24.387] result() for MulticoreFuture ...
[10:31:24.387] result() for MulticoreFuture ... done
[10:31:24.388] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:24.388] - nx: 2
[10:31:24.388] - relay: TRUE
[10:31:24.388] - stdout: TRUE
[10:31:24.388] - signal: TRUE
[10:31:24.388] - resignal: FALSE
[10:31:24.388] - force: TRUE
[10:31:24.388] - relayed: [n=2] TRUE, FALSE
[10:31:24.389] - queued futures: [n=2] TRUE, FALSE
[10:31:24.389]  - until=2
[10:31:24.389]  - relaying element #2
[10:31:24.389] result() for MulticoreFuture ...
[10:31:24.389] result() for MulticoreFuture ... done
[10:31:24.389] result() for MulticoreFuture ...
[10:31:24.389] result() for MulticoreFuture ... done
[10:31:24.390] result() for MulticoreFuture ...
[10:31:24.390] result() for MulticoreFuture ... done
[10:31:24.390] result() for MulticoreFuture ...
[10:31:24.390] result() for MulticoreFuture ... done
[10:31:24.390] - relayed: [n=2] TRUE, TRUE
[10:31:24.390] - queued futures: [n=2] TRUE, TRUE
[10:31:24.390] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:24.390]  length: 0 (resolved future 2)
[10:31:24.390] Relaying remaining futures
[10:31:24.391] signalConditionsASAP(NULL, pos=0) ...
[10:31:24.391] - nx: 2
[10:31:24.391] - relay: TRUE
[10:31:24.391] - stdout: TRUE
[10:31:24.391] - signal: TRUE
[10:31:24.391] - resignal: FALSE
[10:31:24.391] - force: TRUE
[10:31:24.391] - relayed: [n=2] TRUE, TRUE
[10:31:24.391] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:24.392] - relayed: [n=2] TRUE, TRUE
[10:31:24.392] - queued futures: [n=2] TRUE, TRUE
[10:31:24.392] signalConditionsASAP(NULL, pos=0) ... done
[10:31:24.392] resolve() on list ... DONE
[10:31:24.392] result() for MulticoreFuture ...
[10:31:24.392] result() for MulticoreFuture ... done
[10:31:24.392] result() for MulticoreFuture ...
[10:31:24.392] result() for MulticoreFuture ... done
[10:31:24.393] result() for MulticoreFuture ...
[10:31:24.393] result() for MulticoreFuture ... done
[10:31:24.393] result() for MulticoreFuture ...
[10:31:24.393] result() for MulticoreFuture ... done
[10:31:24.393]  - Number of value chunks collected: 2
[10:31:24.393] Resolving 2 futures (chunks) ... DONE
[10:31:24.393] Reducing values from 2 chunks ...
[10:31:24.393]  - Number of values collected after concatenation: 11
[10:31:24.393]  - Number of values expected: 11
[10:31:24.394] Reducing values from 2 chunks ... DONE
[10:31:24.394] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[10:31:24.395] future_lapply() ...
[10:31:24.404] Number of chunks: 2
[10:31:24.405] getGlobalsAndPackagesXApply() ...
[10:31:24.405]  - future.globals: TRUE
[10:31:24.405] getGlobalsAndPackages() ...
[10:31:24.405] Searching for globals...
[10:31:24.409] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:24.409] Searching for globals ... DONE
[10:31:24.410] Resolving globals: FALSE
[10:31:24.410] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[10:31:24.411] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:24.411] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:24.411] - packages: [1] ‘future.apply’
[10:31:24.411] getGlobalsAndPackages() ... DONE
[10:31:24.411]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:24.411]  - needed namespaces: [n=1] ‘future.apply’
[10:31:24.412] Finding globals ... DONE
[10:31:24.412]  - use_args: TRUE
[10:31:24.412]  - Getting '...' globals ...
[10:31:24.412] resolve() on list ...
[10:31:24.412]  recursive: 0
[10:31:24.412]  length: 1
[10:31:24.412]  elements: ‘...’
[10:31:24.413]  length: 0 (resolved future 1)
[10:31:24.413] resolve() on list ... DONE
[10:31:24.413]    - '...' content: [n=0] 
[10:31:24.413] List of 1
[10:31:24.413]  $ ...: list()
[10:31:24.413]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.413]  - attr(*, "where")=List of 1
[10:31:24.413]   ..$ ...:<environment: 0x55de85a541d8> 
[10:31:24.413]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.413]  - attr(*, "resolved")= logi TRUE
[10:31:24.413]  - attr(*, "total_size")= num NA
[10:31:24.416]  - Getting '...' globals ... DONE
[10:31:24.416] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:24.416] List of 8
[10:31:24.416]  $ ...future.FUN:function (x, ...)  
[10:31:24.416]  $ x_FUN        :function (x)  
[10:31:24.416]  $ times        : int 1
[10:31:24.416]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:24.416]  $ stop_if_not  :function (...)  
[10:31:24.416]  $ dim          : NULL
[10:31:24.416]  $ valid_types  : chr [1:2] "logical" "integer"
[10:31:24.416]  $ ...          : list()
[10:31:24.416]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.416]  - attr(*, "where")=List of 8
[10:31:24.416]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:24.416]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:24.416]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:24.416]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:24.416]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:24.416]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:24.416]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:24.416]   ..$ ...          :<environment: 0x55de85a541d8> 
[10:31:24.416]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.416]  - attr(*, "resolved")= logi FALSE
[10:31:24.416]  - attr(*, "total_size")= num 94264
[10:31:24.424] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:24.424] getGlobalsAndPackagesXApply() ... DONE
[10:31:24.425] Number of futures (= number of chunks): 2
[10:31:24.425] Launching 2 futures (chunks) ...
[10:31:24.425] Chunk #1 of 2 ...
[10:31:24.425]  - Finding globals in 'X' for chunk #1 ...
[10:31:24.425] getGlobalsAndPackages() ...
[10:31:24.425] Searching for globals...
[10:31:24.426] 
[10:31:24.426] Searching for globals ... DONE
[10:31:24.426] - globals: [0] <none>
[10:31:24.426] getGlobalsAndPackages() ... DONE
[10:31:24.426]    + additional globals found: [n=0] 
[10:31:24.426]    + additional namespaces needed: [n=0] 
[10:31:24.426]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:24.427]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:24.427]  - seeds: <none>
[10:31:24.427]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.427] getGlobalsAndPackages() ...
[10:31:24.427] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.427] Resolving globals: FALSE
[10:31:24.427] Tweak future expression to call with '...' arguments ...
[10:31:24.428] {
[10:31:24.428]     do.call(function(...) {
[10:31:24.428]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.428]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.428]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.428]             on.exit(options(oopts), add = TRUE)
[10:31:24.428]         }
[10:31:24.428]         {
[10:31:24.428]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.428]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.428]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.428]             })
[10:31:24.428]         }
[10:31:24.428]     }, args = future.call.arguments)
[10:31:24.428] }
[10:31:24.428] Tweak future expression to call with '...' arguments ... DONE
[10:31:24.428] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.429] - packages: [1] ‘future.apply’
[10:31:24.429] getGlobalsAndPackages() ... DONE
[10:31:24.429] run() for ‘Future’ ...
[10:31:24.429] - state: ‘created’
[10:31:24.430] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:24.433] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.434] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:24.434]   - Field: ‘label’
[10:31:24.434]   - Field: ‘local’
[10:31:24.434]   - Field: ‘owner’
[10:31:24.434]   - Field: ‘envir’
[10:31:24.434]   - Field: ‘workers’
[10:31:24.434]   - Field: ‘packages’
[10:31:24.434]   - Field: ‘gc’
[10:31:24.434]   - Field: ‘job’
[10:31:24.434]   - Field: ‘conditions’
[10:31:24.435]   - Field: ‘expr’
[10:31:24.435]   - Field: ‘uuid’
[10:31:24.435]   - Field: ‘seed’
[10:31:24.435]   - Field: ‘version’
[10:31:24.435]   - Field: ‘result’
[10:31:24.435]   - Field: ‘asynchronous’
[10:31:24.435]   - Field: ‘calls’
[10:31:24.435]   - Field: ‘globals’
[10:31:24.435]   - Field: ‘stdout’
[10:31:24.435]   - Field: ‘earlySignal’
[10:31:24.436]   - Field: ‘lazy’
[10:31:24.436]   - Field: ‘state’
[10:31:24.436] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:24.436] - Launch lazy future ...
[10:31:24.436] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:24.436] Packages needed by future strategies (n = 0): <none>
[10:31:24.437] {
[10:31:24.437]     {
[10:31:24.437]         {
[10:31:24.437]             ...future.startTime <- base::Sys.time()
[10:31:24.437]             {
[10:31:24.437]                 {
[10:31:24.437]                   {
[10:31:24.437]                     {
[10:31:24.437]                       {
[10:31:24.437]                         base::local({
[10:31:24.437]                           has_future <- base::requireNamespace("future", 
[10:31:24.437]                             quietly = TRUE)
[10:31:24.437]                           if (has_future) {
[10:31:24.437]                             ns <- base::getNamespace("future")
[10:31:24.437]                             version <- ns[[".package"]][["version"]]
[10:31:24.437]                             if (is.null(version)) 
[10:31:24.437]                               version <- utils::packageVersion("future")
[10:31:24.437]                           }
[10:31:24.437]                           else {
[10:31:24.437]                             version <- NULL
[10:31:24.437]                           }
[10:31:24.437]                           if (!has_future || version < "1.8.0") {
[10:31:24.437]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:24.437]                               "", base::R.version$version.string), 
[10:31:24.437]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:24.437]                                 base::R.version$platform, 8 * 
[10:31:24.437]                                   base::.Machine$sizeof.pointer), 
[10:31:24.437]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:24.437]                                 "release", "version")], collapse = " "), 
[10:31:24.437]                               hostname = base::Sys.info()[["nodename"]])
[10:31:24.437]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:24.437]                               info)
[10:31:24.437]                             info <- base::paste(info, collapse = "; ")
[10:31:24.437]                             if (!has_future) {
[10:31:24.437]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:24.437]                                 info)
[10:31:24.437]                             }
[10:31:24.437]                             else {
[10:31:24.437]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:24.437]                                 info, version)
[10:31:24.437]                             }
[10:31:24.437]                             base::stop(msg)
[10:31:24.437]                           }
[10:31:24.437]                         })
[10:31:24.437]                       }
[10:31:24.437]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:24.437]                       base::options(mc.cores = 1L)
[10:31:24.437]                     }
[10:31:24.437]                     base::local({
[10:31:24.437]                       for (pkg in "future.apply") {
[10:31:24.437]                         base::loadNamespace(pkg)
[10:31:24.437]                         base::library(pkg, character.only = TRUE)
[10:31:24.437]                       }
[10:31:24.437]                     })
[10:31:24.437]                   }
[10:31:24.437]                   ...future.strategy.old <- future::plan("list")
[10:31:24.437]                   options(future.plan = NULL)
[10:31:24.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:24.437]                 }
[10:31:24.437]                 ...future.workdir <- getwd()
[10:31:24.437]             }
[10:31:24.437]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:24.437]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:24.437]         }
[10:31:24.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:24.437]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:24.437]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:24.437]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:24.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:24.437]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:24.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:24.437]             base::names(...future.oldOptions))
[10:31:24.437]     }
[10:31:24.437]     if (FALSE) {
[10:31:24.437]     }
[10:31:24.437]     else {
[10:31:24.437]         if (TRUE) {
[10:31:24.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:24.437]                 open = "w")
[10:31:24.437]         }
[10:31:24.437]         else {
[10:31:24.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:24.437]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:24.437]         }
[10:31:24.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:24.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:24.437]             base::sink(type = "output", split = FALSE)
[10:31:24.437]             base::close(...future.stdout)
[10:31:24.437]         }, add = TRUE)
[10:31:24.437]     }
[10:31:24.437]     ...future.frame <- base::sys.nframe()
[10:31:24.437]     ...future.conditions <- base::list()
[10:31:24.437]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:24.437]     if (FALSE) {
[10:31:24.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:24.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:24.437]     }
[10:31:24.437]     ...future.result <- base::tryCatch({
[10:31:24.437]         base::withCallingHandlers({
[10:31:24.437]             ...future.value <- base::withVisible(base::local({
[10:31:24.437]                 withCallingHandlers({
[10:31:24.437]                   {
[10:31:24.437]                     do.call(function(...) {
[10:31:24.437]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.437]                       if (!identical(...future.globals.maxSize.org, 
[10:31:24.437]                         ...future.globals.maxSize)) {
[10:31:24.437]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.437]                         on.exit(options(oopts), add = TRUE)
[10:31:24.437]                       }
[10:31:24.437]                       {
[10:31:24.437]                         lapply(seq_along(...future.elements_ii), 
[10:31:24.437]                           FUN = function(jj) {
[10:31:24.437]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.437]                             ...future.FUN(...future.X_jj, ...)
[10:31:24.437]                           })
[10:31:24.437]                       }
[10:31:24.437]                     }, args = future.call.arguments)
[10:31:24.437]                   }
[10:31:24.437]                 }, immediateCondition = function(cond) {
[10:31:24.437]                   save_rds <- function (object, pathname, ...) 
[10:31:24.437]                   {
[10:31:24.437]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:24.437]                     if (file_test("-f", pathname_tmp)) {
[10:31:24.437]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.437]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:24.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.437]                         fi_tmp[["mtime"]])
[10:31:24.437]                     }
[10:31:24.437]                     tryCatch({
[10:31:24.437]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:24.437]                     }, error = function(ex) {
[10:31:24.437]                       msg <- conditionMessage(ex)
[10:31:24.437]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.437]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:24.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.437]                         fi_tmp[["mtime"]], msg)
[10:31:24.437]                       ex$message <- msg
[10:31:24.437]                       stop(ex)
[10:31:24.437]                     })
[10:31:24.437]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:24.437]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:24.437]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:24.437]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.437]                       fi <- file.info(pathname)
[10:31:24.437]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:24.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.437]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:24.437]                         fi[["size"]], fi[["mtime"]])
[10:31:24.437]                       stop(msg)
[10:31:24.437]                     }
[10:31:24.437]                     invisible(pathname)
[10:31:24.437]                   }
[10:31:24.437]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:24.437]                     rootPath = tempdir()) 
[10:31:24.437]                   {
[10:31:24.437]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:24.437]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:24.437]                       tmpdir = path, fileext = ".rds")
[10:31:24.437]                     save_rds(obj, file)
[10:31:24.437]                   }
[10:31:24.437]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:24.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.437]                   {
[10:31:24.437]                     inherits <- base::inherits
[10:31:24.437]                     invokeRestart <- base::invokeRestart
[10:31:24.437]                     is.null <- base::is.null
[10:31:24.437]                     muffled <- FALSE
[10:31:24.437]                     if (inherits(cond, "message")) {
[10:31:24.437]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:24.437]                       if (muffled) 
[10:31:24.437]                         invokeRestart("muffleMessage")
[10:31:24.437]                     }
[10:31:24.437]                     else if (inherits(cond, "warning")) {
[10:31:24.437]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:24.437]                       if (muffled) 
[10:31:24.437]                         invokeRestart("muffleWarning")
[10:31:24.437]                     }
[10:31:24.437]                     else if (inherits(cond, "condition")) {
[10:31:24.437]                       if (!is.null(pattern)) {
[10:31:24.437]                         computeRestarts <- base::computeRestarts
[10:31:24.437]                         grepl <- base::grepl
[10:31:24.437]                         restarts <- computeRestarts(cond)
[10:31:24.437]                         for (restart in restarts) {
[10:31:24.437]                           name <- restart$name
[10:31:24.437]                           if (is.null(name)) 
[10:31:24.437]                             next
[10:31:24.437]                           if (!grepl(pattern, name)) 
[10:31:24.437]                             next
[10:31:24.437]                           invokeRestart(restart)
[10:31:24.437]                           muffled <- TRUE
[10:31:24.437]                           break
[10:31:24.437]                         }
[10:31:24.437]                       }
[10:31:24.437]                     }
[10:31:24.437]                     invisible(muffled)
[10:31:24.437]                   }
[10:31:24.437]                   muffleCondition(cond)
[10:31:24.437]                 })
[10:31:24.437]             }))
[10:31:24.437]             future::FutureResult(value = ...future.value$value, 
[10:31:24.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.437]                   ...future.rng), globalenv = if (FALSE) 
[10:31:24.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:24.437]                     ...future.globalenv.names))
[10:31:24.437]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:24.437]         }, condition = base::local({
[10:31:24.437]             c <- base::c
[10:31:24.437]             inherits <- base::inherits
[10:31:24.437]             invokeRestart <- base::invokeRestart
[10:31:24.437]             length <- base::length
[10:31:24.437]             list <- base::list
[10:31:24.437]             seq.int <- base::seq.int
[10:31:24.437]             signalCondition <- base::signalCondition
[10:31:24.437]             sys.calls <- base::sys.calls
[10:31:24.437]             `[[` <- base::`[[`
[10:31:24.437]             `+` <- base::`+`
[10:31:24.437]             `<<-` <- base::`<<-`
[10:31:24.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:24.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:24.437]                   3L)]
[10:31:24.437]             }
[10:31:24.437]             function(cond) {
[10:31:24.437]                 is_error <- inherits(cond, "error")
[10:31:24.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:24.437]                   NULL)
[10:31:24.437]                 if (is_error) {
[10:31:24.437]                   sessionInformation <- function() {
[10:31:24.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:24.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:24.437]                       search = base::search(), system = base::Sys.info())
[10:31:24.437]                   }
[10:31:24.437]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:24.437]                     cond$call), session = sessionInformation(), 
[10:31:24.437]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:24.437]                   signalCondition(cond)
[10:31:24.437]                 }
[10:31:24.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:24.437]                 "immediateCondition"))) {
[10:31:24.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:24.437]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:24.437]                   if (TRUE && !signal) {
[10:31:24.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.437]                     {
[10:31:24.437]                       inherits <- base::inherits
[10:31:24.437]                       invokeRestart <- base::invokeRestart
[10:31:24.437]                       is.null <- base::is.null
[10:31:24.437]                       muffled <- FALSE
[10:31:24.437]                       if (inherits(cond, "message")) {
[10:31:24.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.437]                         if (muffled) 
[10:31:24.437]                           invokeRestart("muffleMessage")
[10:31:24.437]                       }
[10:31:24.437]                       else if (inherits(cond, "warning")) {
[10:31:24.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.437]                         if (muffled) 
[10:31:24.437]                           invokeRestart("muffleWarning")
[10:31:24.437]                       }
[10:31:24.437]                       else if (inherits(cond, "condition")) {
[10:31:24.437]                         if (!is.null(pattern)) {
[10:31:24.437]                           computeRestarts <- base::computeRestarts
[10:31:24.437]                           grepl <- base::grepl
[10:31:24.437]                           restarts <- computeRestarts(cond)
[10:31:24.437]                           for (restart in restarts) {
[10:31:24.437]                             name <- restart$name
[10:31:24.437]                             if (is.null(name)) 
[10:31:24.437]                               next
[10:31:24.437]                             if (!grepl(pattern, name)) 
[10:31:24.437]                               next
[10:31:24.437]                             invokeRestart(restart)
[10:31:24.437]                             muffled <- TRUE
[10:31:24.437]                             break
[10:31:24.437]                           }
[10:31:24.437]                         }
[10:31:24.437]                       }
[10:31:24.437]                       invisible(muffled)
[10:31:24.437]                     }
[10:31:24.437]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.437]                   }
[10:31:24.437]                 }
[10:31:24.437]                 else {
[10:31:24.437]                   if (TRUE) {
[10:31:24.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.437]                     {
[10:31:24.437]                       inherits <- base::inherits
[10:31:24.437]                       invokeRestart <- base::invokeRestart
[10:31:24.437]                       is.null <- base::is.null
[10:31:24.437]                       muffled <- FALSE
[10:31:24.437]                       if (inherits(cond, "message")) {
[10:31:24.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.437]                         if (muffled) 
[10:31:24.437]                           invokeRestart("muffleMessage")
[10:31:24.437]                       }
[10:31:24.437]                       else if (inherits(cond, "warning")) {
[10:31:24.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.437]                         if (muffled) 
[10:31:24.437]                           invokeRestart("muffleWarning")
[10:31:24.437]                       }
[10:31:24.437]                       else if (inherits(cond, "condition")) {
[10:31:24.437]                         if (!is.null(pattern)) {
[10:31:24.437]                           computeRestarts <- base::computeRestarts
[10:31:24.437]                           grepl <- base::grepl
[10:31:24.437]                           restarts <- computeRestarts(cond)
[10:31:24.437]                           for (restart in restarts) {
[10:31:24.437]                             name <- restart$name
[10:31:24.437]                             if (is.null(name)) 
[10:31:24.437]                               next
[10:31:24.437]                             if (!grepl(pattern, name)) 
[10:31:24.437]                               next
[10:31:24.437]                             invokeRestart(restart)
[10:31:24.437]                             muffled <- TRUE
[10:31:24.437]                             break
[10:31:24.437]                           }
[10:31:24.437]                         }
[10:31:24.437]                       }
[10:31:24.437]                       invisible(muffled)
[10:31:24.437]                     }
[10:31:24.437]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.437]                   }
[10:31:24.437]                 }
[10:31:24.437]             }
[10:31:24.437]         }))
[10:31:24.437]     }, error = function(ex) {
[10:31:24.437]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:24.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.437]                 ...future.rng), started = ...future.startTime, 
[10:31:24.437]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:24.437]             version = "1.8"), class = "FutureResult")
[10:31:24.437]     }, finally = {
[10:31:24.437]         if (!identical(...future.workdir, getwd())) 
[10:31:24.437]             setwd(...future.workdir)
[10:31:24.437]         {
[10:31:24.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:24.437]                 ...future.oldOptions$nwarnings <- NULL
[10:31:24.437]             }
[10:31:24.437]             base::options(...future.oldOptions)
[10:31:24.437]             if (.Platform$OS.type == "windows") {
[10:31:24.437]                 old_names <- names(...future.oldEnvVars)
[10:31:24.437]                 envs <- base::Sys.getenv()
[10:31:24.437]                 names <- names(envs)
[10:31:24.437]                 common <- intersect(names, old_names)
[10:31:24.437]                 added <- setdiff(names, old_names)
[10:31:24.437]                 removed <- setdiff(old_names, names)
[10:31:24.437]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:24.437]                   envs[common]]
[10:31:24.437]                 NAMES <- toupper(changed)
[10:31:24.437]                 args <- list()
[10:31:24.437]                 for (kk in seq_along(NAMES)) {
[10:31:24.437]                   name <- changed[[kk]]
[10:31:24.437]                   NAME <- NAMES[[kk]]
[10:31:24.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.437]                     next
[10:31:24.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.437]                 }
[10:31:24.437]                 NAMES <- toupper(added)
[10:31:24.437]                 for (kk in seq_along(NAMES)) {
[10:31:24.437]                   name <- added[[kk]]
[10:31:24.437]                   NAME <- NAMES[[kk]]
[10:31:24.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.437]                     next
[10:31:24.437]                   args[[name]] <- ""
[10:31:24.437]                 }
[10:31:24.437]                 NAMES <- toupper(removed)
[10:31:24.437]                 for (kk in seq_along(NAMES)) {
[10:31:24.437]                   name <- removed[[kk]]
[10:31:24.437]                   NAME <- NAMES[[kk]]
[10:31:24.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.437]                     next
[10:31:24.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.437]                 }
[10:31:24.437]                 if (length(args) > 0) 
[10:31:24.437]                   base::do.call(base::Sys.setenv, args = args)
[10:31:24.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:24.437]             }
[10:31:24.437]             else {
[10:31:24.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:24.437]             }
[10:31:24.437]             {
[10:31:24.437]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:24.437]                   0L) {
[10:31:24.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:24.437]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:24.437]                   base::options(opts)
[10:31:24.437]                 }
[10:31:24.437]                 {
[10:31:24.437]                   {
[10:31:24.437]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:24.437]                     NULL
[10:31:24.437]                   }
[10:31:24.437]                   options(future.plan = NULL)
[10:31:24.437]                   if (is.na(NA_character_)) 
[10:31:24.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:24.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:24.437]                     .init = FALSE)
[10:31:24.437]                 }
[10:31:24.437]             }
[10:31:24.437]         }
[10:31:24.437]     })
[10:31:24.437]     if (TRUE) {
[10:31:24.437]         base::sink(type = "output", split = FALSE)
[10:31:24.437]         if (TRUE) {
[10:31:24.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:24.437]         }
[10:31:24.437]         else {
[10:31:24.437]             ...future.result["stdout"] <- base::list(NULL)
[10:31:24.437]         }
[10:31:24.437]         base::close(...future.stdout)
[10:31:24.437]         ...future.stdout <- NULL
[10:31:24.437]     }
[10:31:24.437]     ...future.result$conditions <- ...future.conditions
[10:31:24.437]     ...future.result$finished <- base::Sys.time()
[10:31:24.437]     ...future.result
[10:31:24.437] }
[10:31:24.440] assign_globals() ...
[10:31:24.440] List of 11
[10:31:24.440]  $ ...future.FUN            :function (x, ...)  
[10:31:24.440]  $ x_FUN                    :function (x)  
[10:31:24.440]  $ times                    : int 1
[10:31:24.440]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:24.440]  $ stop_if_not              :function (...)  
[10:31:24.440]  $ dim                      : NULL
[10:31:24.440]  $ valid_types              : chr [1:2] "logical" "integer"
[10:31:24.440]  $ future.call.arguments    : list()
[10:31:24.440]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.440]  $ ...future.elements_ii    :List of 1
[10:31:24.440]   ..$ a: num 1
[10:31:24.440]  $ ...future.seeds_ii       : NULL
[10:31:24.440]  $ ...future.globals.maxSize: NULL
[10:31:24.440]  - attr(*, "where")=List of 11
[10:31:24.440]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:24.440]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:24.440]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:24.440]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:24.440]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:24.440]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:24.440]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:24.440]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:24.440]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:24.440]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:24.440]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:24.440]  - attr(*, "resolved")= logi FALSE
[10:31:24.440]  - attr(*, "total_size")= num 94264
[10:31:24.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.440]  - attr(*, "already-done")= logi TRUE
[10:31:24.450] - copied ‘...future.FUN’ to environment
[10:31:24.451] - copied ‘x_FUN’ to environment
[10:31:24.451] - copied ‘times’ to environment
[10:31:24.451] - copied ‘stopf’ to environment
[10:31:24.451] - copied ‘stop_if_not’ to environment
[10:31:24.451] - copied ‘dim’ to environment
[10:31:24.451] - copied ‘valid_types’ to environment
[10:31:24.451] - copied ‘future.call.arguments’ to environment
[10:31:24.451] - copied ‘...future.elements_ii’ to environment
[10:31:24.452] - copied ‘...future.seeds_ii’ to environment
[10:31:24.452] - copied ‘...future.globals.maxSize’ to environment
[10:31:24.452] assign_globals() ... done
[10:31:24.452] requestCore(): workers = 2
[10:31:24.455] MulticoreFuture started
[10:31:24.455] - Launch lazy future ... done
[10:31:24.456] run() for ‘MulticoreFuture’ ... done
[10:31:24.456] Created future:
[10:31:24.457] plan(): Setting new future strategy stack:
[10:31:24.457] List of future strategies:
[10:31:24.457] 1. sequential:
[10:31:24.457]    - args: function (..., envir = parent.frame())
[10:31:24.457]    - tweaked: FALSE
[10:31:24.457]    - call: NULL
[10:31:24.459] plan(): nbrOfWorkers() = 1
[10:31:24.461] plan(): Setting new future strategy stack:
[10:31:24.462] List of future strategies:
[10:31:24.462] 1. multicore:
[10:31:24.462]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:24.462]    - tweaked: FALSE
[10:31:24.462]    - call: plan(strategy)
[10:31:24.468] plan(): nbrOfWorkers() = 2
[10:31:24.457] MulticoreFuture:
[10:31:24.457] Label: ‘future_vapply-1’
[10:31:24.457] Expression:
[10:31:24.457] {
[10:31:24.457]     do.call(function(...) {
[10:31:24.457]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.457]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.457]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.457]             on.exit(options(oopts), add = TRUE)
[10:31:24.457]         }
[10:31:24.457]         {
[10:31:24.457]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.457]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.457]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.457]             })
[10:31:24.457]         }
[10:31:24.457]     }, args = future.call.arguments)
[10:31:24.457] }
[10:31:24.457] Lazy evaluation: FALSE
[10:31:24.457] Asynchronous evaluation: TRUE
[10:31:24.457] Local evaluation: TRUE
[10:31:24.457] Environment: R_GlobalEnv
[10:31:24.457] Capture standard output: TRUE
[10:31:24.457] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:24.457] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:24.457] Packages: 1 packages (‘future.apply’)
[10:31:24.457] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:24.457] Resolved: TRUE
[10:31:24.457] Value: <not collected>
[10:31:24.457] Conditions captured: <none>
[10:31:24.457] Early signaling: FALSE
[10:31:24.457] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:24.457] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.470] Chunk #1 of 2 ... DONE
[10:31:24.470] Chunk #2 of 2 ...
[10:31:24.470]  - Finding globals in 'X' for chunk #2 ...
[10:31:24.470] getGlobalsAndPackages() ...
[10:31:24.471] Searching for globals...
[10:31:24.471] 
[10:31:24.471] Searching for globals ... DONE
[10:31:24.471] - globals: [0] <none>
[10:31:24.472] getGlobalsAndPackages() ... DONE
[10:31:24.472]    + additional globals found: [n=0] 
[10:31:24.472]    + additional namespaces needed: [n=0] 
[10:31:24.472]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:24.472]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:24.472]  - seeds: <none>
[10:31:24.472]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.473] getGlobalsAndPackages() ...
[10:31:24.473] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.473] Resolving globals: FALSE
[10:31:24.473] Tweak future expression to call with '...' arguments ...
[10:31:24.473] {
[10:31:24.473]     do.call(function(...) {
[10:31:24.473]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.473]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.473]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.473]             on.exit(options(oopts), add = TRUE)
[10:31:24.473]         }
[10:31:24.473]         {
[10:31:24.473]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.473]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.473]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.473]             })
[10:31:24.473]         }
[10:31:24.473]     }, args = future.call.arguments)
[10:31:24.473] }
[10:31:24.474] Tweak future expression to call with '...' arguments ... DONE
[10:31:24.475] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.476] - packages: [1] ‘future.apply’
[10:31:24.476] getGlobalsAndPackages() ... DONE
[10:31:24.476] run() for ‘Future’ ...
[10:31:24.476] - state: ‘created’
[10:31:24.477] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:24.481] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.482] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:24.482]   - Field: ‘label’
[10:31:24.482]   - Field: ‘local’
[10:31:24.482]   - Field: ‘owner’
[10:31:24.482]   - Field: ‘envir’
[10:31:24.482]   - Field: ‘workers’
[10:31:24.483]   - Field: ‘packages’
[10:31:24.483]   - Field: ‘gc’
[10:31:24.483]   - Field: ‘job’
[10:31:24.483]   - Field: ‘conditions’
[10:31:24.483]   - Field: ‘expr’
[10:31:24.483]   - Field: ‘uuid’
[10:31:24.483]   - Field: ‘seed’
[10:31:24.484]   - Field: ‘version’
[10:31:24.484]   - Field: ‘result’
[10:31:24.484]   - Field: ‘asynchronous’
[10:31:24.484]   - Field: ‘calls’
[10:31:24.484]   - Field: ‘globals’
[10:31:24.484]   - Field: ‘stdout’
[10:31:24.484]   - Field: ‘earlySignal’
[10:31:24.484]   - Field: ‘lazy’
[10:31:24.485]   - Field: ‘state’
[10:31:24.485] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:24.485] - Launch lazy future ...
[10:31:24.485] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:24.486] Packages needed by future strategies (n = 0): <none>
[10:31:24.486] {
[10:31:24.486]     {
[10:31:24.486]         {
[10:31:24.486]             ...future.startTime <- base::Sys.time()
[10:31:24.486]             {
[10:31:24.486]                 {
[10:31:24.486]                   {
[10:31:24.486]                     {
[10:31:24.486]                       {
[10:31:24.486]                         base::local({
[10:31:24.486]                           has_future <- base::requireNamespace("future", 
[10:31:24.486]                             quietly = TRUE)
[10:31:24.486]                           if (has_future) {
[10:31:24.486]                             ns <- base::getNamespace("future")
[10:31:24.486]                             version <- ns[[".package"]][["version"]]
[10:31:24.486]                             if (is.null(version)) 
[10:31:24.486]                               version <- utils::packageVersion("future")
[10:31:24.486]                           }
[10:31:24.486]                           else {
[10:31:24.486]                             version <- NULL
[10:31:24.486]                           }
[10:31:24.486]                           if (!has_future || version < "1.8.0") {
[10:31:24.486]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:24.486]                               "", base::R.version$version.string), 
[10:31:24.486]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:24.486]                                 base::R.version$platform, 8 * 
[10:31:24.486]                                   base::.Machine$sizeof.pointer), 
[10:31:24.486]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:24.486]                                 "release", "version")], collapse = " "), 
[10:31:24.486]                               hostname = base::Sys.info()[["nodename"]])
[10:31:24.486]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:24.486]                               info)
[10:31:24.486]                             info <- base::paste(info, collapse = "; ")
[10:31:24.486]                             if (!has_future) {
[10:31:24.486]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:24.486]                                 info)
[10:31:24.486]                             }
[10:31:24.486]                             else {
[10:31:24.486]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:24.486]                                 info, version)
[10:31:24.486]                             }
[10:31:24.486]                             base::stop(msg)
[10:31:24.486]                           }
[10:31:24.486]                         })
[10:31:24.486]                       }
[10:31:24.486]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:24.486]                       base::options(mc.cores = 1L)
[10:31:24.486]                     }
[10:31:24.486]                     base::local({
[10:31:24.486]                       for (pkg in "future.apply") {
[10:31:24.486]                         base::loadNamespace(pkg)
[10:31:24.486]                         base::library(pkg, character.only = TRUE)
[10:31:24.486]                       }
[10:31:24.486]                     })
[10:31:24.486]                   }
[10:31:24.486]                   ...future.strategy.old <- future::plan("list")
[10:31:24.486]                   options(future.plan = NULL)
[10:31:24.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:24.486]                 }
[10:31:24.486]                 ...future.workdir <- getwd()
[10:31:24.486]             }
[10:31:24.486]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:24.486]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:24.486]         }
[10:31:24.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:24.486]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:24.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:24.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:24.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:24.486]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:24.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:24.486]             base::names(...future.oldOptions))
[10:31:24.486]     }
[10:31:24.486]     if (FALSE) {
[10:31:24.486]     }
[10:31:24.486]     else {
[10:31:24.486]         if (TRUE) {
[10:31:24.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:24.486]                 open = "w")
[10:31:24.486]         }
[10:31:24.486]         else {
[10:31:24.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:24.486]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:24.486]         }
[10:31:24.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:24.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:24.486]             base::sink(type = "output", split = FALSE)
[10:31:24.486]             base::close(...future.stdout)
[10:31:24.486]         }, add = TRUE)
[10:31:24.486]     }
[10:31:24.486]     ...future.frame <- base::sys.nframe()
[10:31:24.486]     ...future.conditions <- base::list()
[10:31:24.486]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:24.486]     if (FALSE) {
[10:31:24.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:24.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:24.486]     }
[10:31:24.486]     ...future.result <- base::tryCatch({
[10:31:24.486]         base::withCallingHandlers({
[10:31:24.486]             ...future.value <- base::withVisible(base::local({
[10:31:24.486]                 withCallingHandlers({
[10:31:24.486]                   {
[10:31:24.486]                     do.call(function(...) {
[10:31:24.486]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.486]                       if (!identical(...future.globals.maxSize.org, 
[10:31:24.486]                         ...future.globals.maxSize)) {
[10:31:24.486]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.486]                         on.exit(options(oopts), add = TRUE)
[10:31:24.486]                       }
[10:31:24.486]                       {
[10:31:24.486]                         lapply(seq_along(...future.elements_ii), 
[10:31:24.486]                           FUN = function(jj) {
[10:31:24.486]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.486]                             ...future.FUN(...future.X_jj, ...)
[10:31:24.486]                           })
[10:31:24.486]                       }
[10:31:24.486]                     }, args = future.call.arguments)
[10:31:24.486]                   }
[10:31:24.486]                 }, immediateCondition = function(cond) {
[10:31:24.486]                   save_rds <- function (object, pathname, ...) 
[10:31:24.486]                   {
[10:31:24.486]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:24.486]                     if (file_test("-f", pathname_tmp)) {
[10:31:24.486]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.486]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:24.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.486]                         fi_tmp[["mtime"]])
[10:31:24.486]                     }
[10:31:24.486]                     tryCatch({
[10:31:24.486]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:24.486]                     }, error = function(ex) {
[10:31:24.486]                       msg <- conditionMessage(ex)
[10:31:24.486]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.486]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:24.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.486]                         fi_tmp[["mtime"]], msg)
[10:31:24.486]                       ex$message <- msg
[10:31:24.486]                       stop(ex)
[10:31:24.486]                     })
[10:31:24.486]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:24.486]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:24.486]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:24.486]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.486]                       fi <- file.info(pathname)
[10:31:24.486]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:24.486]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.486]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:24.486]                         fi[["size"]], fi[["mtime"]])
[10:31:24.486]                       stop(msg)
[10:31:24.486]                     }
[10:31:24.486]                     invisible(pathname)
[10:31:24.486]                   }
[10:31:24.486]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:24.486]                     rootPath = tempdir()) 
[10:31:24.486]                   {
[10:31:24.486]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:24.486]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:24.486]                       tmpdir = path, fileext = ".rds")
[10:31:24.486]                     save_rds(obj, file)
[10:31:24.486]                   }
[10:31:24.486]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:24.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.486]                   {
[10:31:24.486]                     inherits <- base::inherits
[10:31:24.486]                     invokeRestart <- base::invokeRestart
[10:31:24.486]                     is.null <- base::is.null
[10:31:24.486]                     muffled <- FALSE
[10:31:24.486]                     if (inherits(cond, "message")) {
[10:31:24.486]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:24.486]                       if (muffled) 
[10:31:24.486]                         invokeRestart("muffleMessage")
[10:31:24.486]                     }
[10:31:24.486]                     else if (inherits(cond, "warning")) {
[10:31:24.486]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:24.486]                       if (muffled) 
[10:31:24.486]                         invokeRestart("muffleWarning")
[10:31:24.486]                     }
[10:31:24.486]                     else if (inherits(cond, "condition")) {
[10:31:24.486]                       if (!is.null(pattern)) {
[10:31:24.486]                         computeRestarts <- base::computeRestarts
[10:31:24.486]                         grepl <- base::grepl
[10:31:24.486]                         restarts <- computeRestarts(cond)
[10:31:24.486]                         for (restart in restarts) {
[10:31:24.486]                           name <- restart$name
[10:31:24.486]                           if (is.null(name)) 
[10:31:24.486]                             next
[10:31:24.486]                           if (!grepl(pattern, name)) 
[10:31:24.486]                             next
[10:31:24.486]                           invokeRestart(restart)
[10:31:24.486]                           muffled <- TRUE
[10:31:24.486]                           break
[10:31:24.486]                         }
[10:31:24.486]                       }
[10:31:24.486]                     }
[10:31:24.486]                     invisible(muffled)
[10:31:24.486]                   }
[10:31:24.486]                   muffleCondition(cond)
[10:31:24.486]                 })
[10:31:24.486]             }))
[10:31:24.486]             future::FutureResult(value = ...future.value$value, 
[10:31:24.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.486]                   ...future.rng), globalenv = if (FALSE) 
[10:31:24.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:24.486]                     ...future.globalenv.names))
[10:31:24.486]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:24.486]         }, condition = base::local({
[10:31:24.486]             c <- base::c
[10:31:24.486]             inherits <- base::inherits
[10:31:24.486]             invokeRestart <- base::invokeRestart
[10:31:24.486]             length <- base::length
[10:31:24.486]             list <- base::list
[10:31:24.486]             seq.int <- base::seq.int
[10:31:24.486]             signalCondition <- base::signalCondition
[10:31:24.486]             sys.calls <- base::sys.calls
[10:31:24.486]             `[[` <- base::`[[`
[10:31:24.486]             `+` <- base::`+`
[10:31:24.486]             `<<-` <- base::`<<-`
[10:31:24.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:24.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:24.486]                   3L)]
[10:31:24.486]             }
[10:31:24.486]             function(cond) {
[10:31:24.486]                 is_error <- inherits(cond, "error")
[10:31:24.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:24.486]                   NULL)
[10:31:24.486]                 if (is_error) {
[10:31:24.486]                   sessionInformation <- function() {
[10:31:24.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:24.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:24.486]                       search = base::search(), system = base::Sys.info())
[10:31:24.486]                   }
[10:31:24.486]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:24.486]                     cond$call), session = sessionInformation(), 
[10:31:24.486]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:24.486]                   signalCondition(cond)
[10:31:24.486]                 }
[10:31:24.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:24.486]                 "immediateCondition"))) {
[10:31:24.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:24.486]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:24.486]                   if (TRUE && !signal) {
[10:31:24.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.486]                     {
[10:31:24.486]                       inherits <- base::inherits
[10:31:24.486]                       invokeRestart <- base::invokeRestart
[10:31:24.486]                       is.null <- base::is.null
[10:31:24.486]                       muffled <- FALSE
[10:31:24.486]                       if (inherits(cond, "message")) {
[10:31:24.486]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.486]                         if (muffled) 
[10:31:24.486]                           invokeRestart("muffleMessage")
[10:31:24.486]                       }
[10:31:24.486]                       else if (inherits(cond, "warning")) {
[10:31:24.486]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.486]                         if (muffled) 
[10:31:24.486]                           invokeRestart("muffleWarning")
[10:31:24.486]                       }
[10:31:24.486]                       else if (inherits(cond, "condition")) {
[10:31:24.486]                         if (!is.null(pattern)) {
[10:31:24.486]                           computeRestarts <- base::computeRestarts
[10:31:24.486]                           grepl <- base::grepl
[10:31:24.486]                           restarts <- computeRestarts(cond)
[10:31:24.486]                           for (restart in restarts) {
[10:31:24.486]                             name <- restart$name
[10:31:24.486]                             if (is.null(name)) 
[10:31:24.486]                               next
[10:31:24.486]                             if (!grepl(pattern, name)) 
[10:31:24.486]                               next
[10:31:24.486]                             invokeRestart(restart)
[10:31:24.486]                             muffled <- TRUE
[10:31:24.486]                             break
[10:31:24.486]                           }
[10:31:24.486]                         }
[10:31:24.486]                       }
[10:31:24.486]                       invisible(muffled)
[10:31:24.486]                     }
[10:31:24.486]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.486]                   }
[10:31:24.486]                 }
[10:31:24.486]                 else {
[10:31:24.486]                   if (TRUE) {
[10:31:24.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.486]                     {
[10:31:24.486]                       inherits <- base::inherits
[10:31:24.486]                       invokeRestart <- base::invokeRestart
[10:31:24.486]                       is.null <- base::is.null
[10:31:24.486]                       muffled <- FALSE
[10:31:24.486]                       if (inherits(cond, "message")) {
[10:31:24.486]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.486]                         if (muffled) 
[10:31:24.486]                           invokeRestart("muffleMessage")
[10:31:24.486]                       }
[10:31:24.486]                       else if (inherits(cond, "warning")) {
[10:31:24.486]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.486]                         if (muffled) 
[10:31:24.486]                           invokeRestart("muffleWarning")
[10:31:24.486]                       }
[10:31:24.486]                       else if (inherits(cond, "condition")) {
[10:31:24.486]                         if (!is.null(pattern)) {
[10:31:24.486]                           computeRestarts <- base::computeRestarts
[10:31:24.486]                           grepl <- base::grepl
[10:31:24.486]                           restarts <- computeRestarts(cond)
[10:31:24.486]                           for (restart in restarts) {
[10:31:24.486]                             name <- restart$name
[10:31:24.486]                             if (is.null(name)) 
[10:31:24.486]                               next
[10:31:24.486]                             if (!grepl(pattern, name)) 
[10:31:24.486]                               next
[10:31:24.486]                             invokeRestart(restart)
[10:31:24.486]                             muffled <- TRUE
[10:31:24.486]                             break
[10:31:24.486]                           }
[10:31:24.486]                         }
[10:31:24.486]                       }
[10:31:24.486]                       invisible(muffled)
[10:31:24.486]                     }
[10:31:24.486]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.486]                   }
[10:31:24.486]                 }
[10:31:24.486]             }
[10:31:24.486]         }))
[10:31:24.486]     }, error = function(ex) {
[10:31:24.486]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:24.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.486]                 ...future.rng), started = ...future.startTime, 
[10:31:24.486]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:24.486]             version = "1.8"), class = "FutureResult")
[10:31:24.486]     }, finally = {
[10:31:24.486]         if (!identical(...future.workdir, getwd())) 
[10:31:24.486]             setwd(...future.workdir)
[10:31:24.486]         {
[10:31:24.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:24.486]                 ...future.oldOptions$nwarnings <- NULL
[10:31:24.486]             }
[10:31:24.486]             base::options(...future.oldOptions)
[10:31:24.486]             if (.Platform$OS.type == "windows") {
[10:31:24.486]                 old_names <- names(...future.oldEnvVars)
[10:31:24.486]                 envs <- base::Sys.getenv()
[10:31:24.486]                 names <- names(envs)
[10:31:24.486]                 common <- intersect(names, old_names)
[10:31:24.486]                 added <- setdiff(names, old_names)
[10:31:24.486]                 removed <- setdiff(old_names, names)
[10:31:24.486]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:24.486]                   envs[common]]
[10:31:24.486]                 NAMES <- toupper(changed)
[10:31:24.486]                 args <- list()
[10:31:24.486]                 for (kk in seq_along(NAMES)) {
[10:31:24.486]                   name <- changed[[kk]]
[10:31:24.486]                   NAME <- NAMES[[kk]]
[10:31:24.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.486]                     next
[10:31:24.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.486]                 }
[10:31:24.486]                 NAMES <- toupper(added)
[10:31:24.486]                 for (kk in seq_along(NAMES)) {
[10:31:24.486]                   name <- added[[kk]]
[10:31:24.486]                   NAME <- NAMES[[kk]]
[10:31:24.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.486]                     next
[10:31:24.486]                   args[[name]] <- ""
[10:31:24.486]                 }
[10:31:24.486]                 NAMES <- toupper(removed)
[10:31:24.486]                 for (kk in seq_along(NAMES)) {
[10:31:24.486]                   name <- removed[[kk]]
[10:31:24.486]                   NAME <- NAMES[[kk]]
[10:31:24.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.486]                     next
[10:31:24.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.486]                 }
[10:31:24.486]                 if (length(args) > 0) 
[10:31:24.486]                   base::do.call(base::Sys.setenv, args = args)
[10:31:24.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:24.486]             }
[10:31:24.486]             else {
[10:31:24.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:24.486]             }
[10:31:24.486]             {
[10:31:24.486]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:24.486]                   0L) {
[10:31:24.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:24.486]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:24.486]                   base::options(opts)
[10:31:24.486]                 }
[10:31:24.486]                 {
[10:31:24.486]                   {
[10:31:24.486]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:24.486]                     NULL
[10:31:24.486]                   }
[10:31:24.486]                   options(future.plan = NULL)
[10:31:24.486]                   if (is.na(NA_character_)) 
[10:31:24.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:24.486]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:24.486]                     .init = FALSE)
[10:31:24.486]                 }
[10:31:24.486]             }
[10:31:24.486]         }
[10:31:24.486]     })
[10:31:24.486]     if (TRUE) {
[10:31:24.486]         base::sink(type = "output", split = FALSE)
[10:31:24.486]         if (TRUE) {
[10:31:24.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:24.486]         }
[10:31:24.486]         else {
[10:31:24.486]             ...future.result["stdout"] <- base::list(NULL)
[10:31:24.486]         }
[10:31:24.486]         base::close(...future.stdout)
[10:31:24.486]         ...future.stdout <- NULL
[10:31:24.486]     }
[10:31:24.486]     ...future.result$conditions <- ...future.conditions
[10:31:24.486]     ...future.result$finished <- base::Sys.time()
[10:31:24.486]     ...future.result
[10:31:24.486] }
[10:31:24.490] assign_globals() ...
[10:31:24.490] List of 11
[10:31:24.490]  $ ...future.FUN            :function (x, ...)  
[10:31:24.490]  $ x_FUN                    :function (x)  
[10:31:24.490]  $ times                    : int 1
[10:31:24.490]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:24.490]  $ stop_if_not              :function (...)  
[10:31:24.490]  $ dim                      : NULL
[10:31:24.490]  $ valid_types              : chr [1:2] "logical" "integer"
[10:31:24.490]  $ future.call.arguments    : list()
[10:31:24.490]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.490]  $ ...future.elements_ii    :List of 2
[10:31:24.490]   ..$ b: num 2
[10:31:24.490]   ..$ c: num 3
[10:31:24.490]  $ ...future.seeds_ii       : NULL
[10:31:24.490]  $ ...future.globals.maxSize: NULL
[10:31:24.490]  - attr(*, "where")=List of 11
[10:31:24.490]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:24.490]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:24.490]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:24.490]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:24.490]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:24.490]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:24.490]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:24.490]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:24.490]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:24.490]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:24.490]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:24.490]  - attr(*, "resolved")= logi FALSE
[10:31:24.490]  - attr(*, "total_size")= num 94264
[10:31:24.490]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.490]  - attr(*, "already-done")= logi TRUE
[10:31:24.506] - copied ‘...future.FUN’ to environment
[10:31:24.506] - copied ‘x_FUN’ to environment
[10:31:24.506] - copied ‘times’ to environment
[10:31:24.506] - copied ‘stopf’ to environment
[10:31:24.507] - copied ‘stop_if_not’ to environment
[10:31:24.507] - copied ‘dim’ to environment
[10:31:24.507] - copied ‘valid_types’ to environment
[10:31:24.507] - copied ‘future.call.arguments’ to environment
[10:31:24.507] - copied ‘...future.elements_ii’ to environment
[10:31:24.507] - copied ‘...future.seeds_ii’ to environment
[10:31:24.507] - copied ‘...future.globals.maxSize’ to environment
[10:31:24.507] assign_globals() ... done
[10:31:24.508] requestCore(): workers = 2
[10:31:24.510] MulticoreFuture started
[10:31:24.511] - Launch lazy future ... done
[10:31:24.511] run() for ‘MulticoreFuture’ ... done
[10:31:24.512] Created future:
[10:31:24.512] plan(): Setting new future strategy stack:
[10:31:24.512] List of future strategies:
[10:31:24.512] 1. sequential:
[10:31:24.512]    - args: function (..., envir = parent.frame())
[10:31:24.512]    - tweaked: FALSE
[10:31:24.512]    - call: NULL
[10:31:24.513] plan(): nbrOfWorkers() = 1
[10:31:24.516] plan(): Setting new future strategy stack:
[10:31:24.516] List of future strategies:
[10:31:24.516] 1. multicore:
[10:31:24.516]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:24.516]    - tweaked: FALSE
[10:31:24.516]    - call: plan(strategy)
[10:31:24.523] plan(): nbrOfWorkers() = 2
[10:31:24.512] MulticoreFuture:
[10:31:24.512] Label: ‘future_vapply-2’
[10:31:24.512] Expression:
[10:31:24.512] {
[10:31:24.512]     do.call(function(...) {
[10:31:24.512]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.512]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.512]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.512]             on.exit(options(oopts), add = TRUE)
[10:31:24.512]         }
[10:31:24.512]         {
[10:31:24.512]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.512]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.512]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.512]             })
[10:31:24.512]         }
[10:31:24.512]     }, args = future.call.arguments)
[10:31:24.512] }
[10:31:24.512] Lazy evaluation: FALSE
[10:31:24.512] Asynchronous evaluation: TRUE
[10:31:24.512] Local evaluation: TRUE
[10:31:24.512] Environment: R_GlobalEnv
[10:31:24.512] Capture standard output: TRUE
[10:31:24.512] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:24.512] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:24.512] Packages: 1 packages (‘future.apply’)
[10:31:24.512] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:24.512] Resolved: TRUE
[10:31:24.512] Value: <not collected>
[10:31:24.512] Conditions captured: <none>
[10:31:24.512] Early signaling: FALSE
[10:31:24.512] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:24.512] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.524] Chunk #2 of 2 ... DONE
[10:31:24.524] Launching 2 futures (chunks) ... DONE
[10:31:24.524] Resolving 2 futures (chunks) ...
[10:31:24.525] resolve() on list ...
[10:31:24.525]  recursive: 0
[10:31:24.525]  length: 2
[10:31:24.525] 
[10:31:24.525] Future #1
[10:31:24.526] result() for MulticoreFuture ...
[10:31:24.527] result() for MulticoreFuture ...
[10:31:24.527] result() for MulticoreFuture ... done
[10:31:24.527] result() for MulticoreFuture ... done
[10:31:24.527] result() for MulticoreFuture ...
[10:31:24.527] result() for MulticoreFuture ... done
[10:31:24.528] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:24.528] - nx: 2
[10:31:24.528] - relay: TRUE
[10:31:24.528] - stdout: TRUE
[10:31:24.528] - signal: TRUE
[10:31:24.529] - resignal: FALSE
[10:31:24.529] - force: TRUE
[10:31:24.529] - relayed: [n=2] FALSE, FALSE
[10:31:24.529] - queued futures: [n=2] FALSE, FALSE
[10:31:24.529]  - until=1
[10:31:24.529]  - relaying element #1
[10:31:24.530] result() for MulticoreFuture ...
[10:31:24.530] result() for MulticoreFuture ... done
[10:31:24.530] result() for MulticoreFuture ...
[10:31:24.530] result() for MulticoreFuture ... done
[10:31:24.530] result() for MulticoreFuture ...
[10:31:24.530] result() for MulticoreFuture ... done
[10:31:24.531] result() for MulticoreFuture ...
[10:31:24.531] result() for MulticoreFuture ... done
[10:31:24.531] - relayed: [n=2] TRUE, FALSE
[10:31:24.531] - queued futures: [n=2] TRUE, FALSE
[10:31:24.531] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:24.531]  length: 1 (resolved future 1)
[10:31:24.532] Future #2
[10:31:24.532] result() for MulticoreFuture ...
[10:31:24.533] result() for MulticoreFuture ...
[10:31:24.533] result() for MulticoreFuture ... done
[10:31:24.533] result() for MulticoreFuture ... done
[10:31:24.533] result() for MulticoreFuture ...
[10:31:24.534] result() for MulticoreFuture ... done
[10:31:24.534] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:31:24.534] - nx: 2
[10:31:24.534] - relay: TRUE
[10:31:24.534] - stdout: TRUE
[10:31:24.534] - signal: TRUE
[10:31:24.534] - resignal: FALSE
[10:31:24.535] - force: TRUE
[10:31:24.535] - relayed: [n=2] TRUE, FALSE
[10:31:24.535] - queued futures: [n=2] TRUE, FALSE
[10:31:24.535]  - until=2
[10:31:24.535]  - relaying element #2
[10:31:24.535] result() for MulticoreFuture ...
[10:31:24.535] result() for MulticoreFuture ... done
[10:31:24.535] result() for MulticoreFuture ...
[10:31:24.536] result() for MulticoreFuture ... done
[10:31:24.536] result() for MulticoreFuture ...
[10:31:24.536] result() for MulticoreFuture ... done
[10:31:24.536] result() for MulticoreFuture ...
[10:31:24.536] result() for MulticoreFuture ... done
[10:31:24.536] - relayed: [n=2] TRUE, TRUE
[10:31:24.536] - queued futures: [n=2] TRUE, TRUE
[10:31:24.536] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:31:24.537]  length: 0 (resolved future 2)
[10:31:24.537] Relaying remaining futures
[10:31:24.537] signalConditionsASAP(NULL, pos=0) ...
[10:31:24.537] - nx: 2
[10:31:24.537] - relay: TRUE
[10:31:24.537] - stdout: TRUE
[10:31:24.537] - signal: TRUE
[10:31:24.537] - resignal: FALSE
[10:31:24.537] - force: TRUE
[10:31:24.538] - relayed: [n=2] TRUE, TRUE
[10:31:24.538] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:24.538] - relayed: [n=2] TRUE, TRUE
[10:31:24.538] - queued futures: [n=2] TRUE, TRUE
[10:31:24.538] signalConditionsASAP(NULL, pos=0) ... done
[10:31:24.538] resolve() on list ... DONE
[10:31:24.538] result() for MulticoreFuture ...
[10:31:24.538] result() for MulticoreFuture ... done
[10:31:24.539] result() for MulticoreFuture ...
[10:31:24.539] result() for MulticoreFuture ... done
[10:31:24.539] result() for MulticoreFuture ...
[10:31:24.539] result() for MulticoreFuture ... done
[10:31:24.539] result() for MulticoreFuture ...
[10:31:24.539] result() for MulticoreFuture ... done
[10:31:24.542]  - Number of value chunks collected: 2
[10:31:24.542] Resolving 2 futures (chunks) ... DONE
[10:31:24.542] Reducing values from 2 chunks ...
[10:31:24.543]  - Number of values collected after concatenation: 3
[10:31:24.543]  - Number of values expected: 3
[10:31:24.543] Reducing values from 2 chunks ... DONE
[10:31:24.543] future_lapply() ... DONE
- exceptions ...
[10:31:24.544] future_lapply() ...
[10:31:24.551] Number of chunks: 2
[10:31:24.551] getGlobalsAndPackagesXApply() ...
[10:31:24.552]  - future.globals: TRUE
[10:31:24.552] getGlobalsAndPackages() ...
[10:31:24.552] Searching for globals...
[10:31:24.557] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:24.557] Searching for globals ... DONE
[10:31:24.557] Resolving globals: FALSE
[10:31:24.558] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[10:31:24.558] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:24.558] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:24.559] - packages: [1] ‘future.apply’
[10:31:24.559] getGlobalsAndPackages() ... DONE
[10:31:24.559]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:24.559]  - needed namespaces: [n=1] ‘future.apply’
[10:31:24.559] Finding globals ... DONE
[10:31:24.559]  - use_args: TRUE
[10:31:24.559]  - Getting '...' globals ...
[10:31:24.560] resolve() on list ...
[10:31:24.560]  recursive: 0
[10:31:24.560]  length: 1
[10:31:24.560]  elements: ‘...’
[10:31:24.560]  length: 0 (resolved future 1)
[10:31:24.560] resolve() on list ... DONE
[10:31:24.560]    - '...' content: [n=0] 
[10:31:24.560] List of 1
[10:31:24.560]  $ ...: list()
[10:31:24.560]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.560]  - attr(*, "where")=List of 1
[10:31:24.560]   ..$ ...:<environment: 0x55de8459eba8> 
[10:31:24.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.560]  - attr(*, "resolved")= logi TRUE
[10:31:24.560]  - attr(*, "total_size")= num NA
[10:31:24.563]  - Getting '...' globals ... DONE
[10:31:24.563] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:24.564] List of 8
[10:31:24.564]  $ ...future.FUN:function (x, ...)  
[10:31:24.564]  $ x_FUN        :function (x)  
[10:31:24.564]  $ times        : int 2
[10:31:24.564]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:24.564]  $ stop_if_not  :function (...)  
[10:31:24.564]  $ dim          : NULL
[10:31:24.564]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:24.564]  $ ...          : list()
[10:31:24.564]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.564]  - attr(*, "where")=List of 8
[10:31:24.564]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:24.564]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:24.564]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:24.564]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:24.564]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:24.564]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:24.564]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:24.564]   ..$ ...          :<environment: 0x55de8459eba8> 
[10:31:24.564]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.564]  - attr(*, "resolved")= logi FALSE
[10:31:24.564]  - attr(*, "total_size")= num 95128
[10:31:24.572] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:24.572] getGlobalsAndPackagesXApply() ... DONE
[10:31:24.573] Number of futures (= number of chunks): 2
[10:31:24.573] Launching 2 futures (chunks) ...
[10:31:24.573] Chunk #1 of 2 ...
[10:31:24.573]  - Finding globals in 'X' for chunk #1 ...
[10:31:24.573] getGlobalsAndPackages() ...
[10:31:24.574] Searching for globals...
[10:31:24.574] 
[10:31:24.574] Searching for globals ... DONE
[10:31:24.574] - globals: [0] <none>
[10:31:24.574] getGlobalsAndPackages() ... DONE
[10:31:24.574]    + additional globals found: [n=0] 
[10:31:24.574]    + additional namespaces needed: [n=0] 
[10:31:24.575]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:24.575]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:24.575]  - seeds: <none>
[10:31:24.575]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.575] getGlobalsAndPackages() ...
[10:31:24.575] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.575] Resolving globals: FALSE
[10:31:24.575] Tweak future expression to call with '...' arguments ...
[10:31:24.576] {
[10:31:24.576]     do.call(function(...) {
[10:31:24.576]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.576]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.576]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.576]             on.exit(options(oopts), add = TRUE)
[10:31:24.576]         }
[10:31:24.576]         {
[10:31:24.576]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.576]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.576]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.576]             })
[10:31:24.576]         }
[10:31:24.576]     }, args = future.call.arguments)
[10:31:24.576] }
[10:31:24.576] Tweak future expression to call with '...' arguments ... DONE
[10:31:24.576] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.577] - packages: [1] ‘future.apply’
[10:31:24.577] getGlobalsAndPackages() ... DONE
[10:31:24.577] run() for ‘Future’ ...
[10:31:24.577] - state: ‘created’
[10:31:24.577] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:24.581] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.582] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:24.582]   - Field: ‘label’
[10:31:24.582]   - Field: ‘local’
[10:31:24.582]   - Field: ‘owner’
[10:31:24.582]   - Field: ‘envir’
[10:31:24.582]   - Field: ‘workers’
[10:31:24.582]   - Field: ‘packages’
[10:31:24.582]   - Field: ‘gc’
[10:31:24.583]   - Field: ‘job’
[10:31:24.583]   - Field: ‘conditions’
[10:31:24.583]   - Field: ‘expr’
[10:31:24.583]   - Field: ‘uuid’
[10:31:24.583]   - Field: ‘seed’
[10:31:24.583]   - Field: ‘version’
[10:31:24.583]   - Field: ‘result’
[10:31:24.583]   - Field: ‘asynchronous’
[10:31:24.583]   - Field: ‘calls’
[10:31:24.583]   - Field: ‘globals’
[10:31:24.583]   - Field: ‘stdout’
[10:31:24.584]   - Field: ‘earlySignal’
[10:31:24.584]   - Field: ‘lazy’
[10:31:24.584]   - Field: ‘state’
[10:31:24.584] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:24.584] - Launch lazy future ...
[10:31:24.584] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:24.584] Packages needed by future strategies (n = 0): <none>
[10:31:24.585] {
[10:31:24.585]     {
[10:31:24.585]         {
[10:31:24.585]             ...future.startTime <- base::Sys.time()
[10:31:24.585]             {
[10:31:24.585]                 {
[10:31:24.585]                   {
[10:31:24.585]                     {
[10:31:24.585]                       {
[10:31:24.585]                         base::local({
[10:31:24.585]                           has_future <- base::requireNamespace("future", 
[10:31:24.585]                             quietly = TRUE)
[10:31:24.585]                           if (has_future) {
[10:31:24.585]                             ns <- base::getNamespace("future")
[10:31:24.585]                             version <- ns[[".package"]][["version"]]
[10:31:24.585]                             if (is.null(version)) 
[10:31:24.585]                               version <- utils::packageVersion("future")
[10:31:24.585]                           }
[10:31:24.585]                           else {
[10:31:24.585]                             version <- NULL
[10:31:24.585]                           }
[10:31:24.585]                           if (!has_future || version < "1.8.0") {
[10:31:24.585]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:24.585]                               "", base::R.version$version.string), 
[10:31:24.585]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:24.585]                                 base::R.version$platform, 8 * 
[10:31:24.585]                                   base::.Machine$sizeof.pointer), 
[10:31:24.585]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:24.585]                                 "release", "version")], collapse = " "), 
[10:31:24.585]                               hostname = base::Sys.info()[["nodename"]])
[10:31:24.585]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:24.585]                               info)
[10:31:24.585]                             info <- base::paste(info, collapse = "; ")
[10:31:24.585]                             if (!has_future) {
[10:31:24.585]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:24.585]                                 info)
[10:31:24.585]                             }
[10:31:24.585]                             else {
[10:31:24.585]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:24.585]                                 info, version)
[10:31:24.585]                             }
[10:31:24.585]                             base::stop(msg)
[10:31:24.585]                           }
[10:31:24.585]                         })
[10:31:24.585]                       }
[10:31:24.585]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:24.585]                       base::options(mc.cores = 1L)
[10:31:24.585]                     }
[10:31:24.585]                     base::local({
[10:31:24.585]                       for (pkg in "future.apply") {
[10:31:24.585]                         base::loadNamespace(pkg)
[10:31:24.585]                         base::library(pkg, character.only = TRUE)
[10:31:24.585]                       }
[10:31:24.585]                     })
[10:31:24.585]                   }
[10:31:24.585]                   ...future.strategy.old <- future::plan("list")
[10:31:24.585]                   options(future.plan = NULL)
[10:31:24.585]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.585]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:24.585]                 }
[10:31:24.585]                 ...future.workdir <- getwd()
[10:31:24.585]             }
[10:31:24.585]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:24.585]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:24.585]         }
[10:31:24.585]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:24.585]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:24.585]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:24.585]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:24.585]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:24.585]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:24.585]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:24.585]             base::names(...future.oldOptions))
[10:31:24.585]     }
[10:31:24.585]     if (FALSE) {
[10:31:24.585]     }
[10:31:24.585]     else {
[10:31:24.585]         if (TRUE) {
[10:31:24.585]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:24.585]                 open = "w")
[10:31:24.585]         }
[10:31:24.585]         else {
[10:31:24.585]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:24.585]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:24.585]         }
[10:31:24.585]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:24.585]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:24.585]             base::sink(type = "output", split = FALSE)
[10:31:24.585]             base::close(...future.stdout)
[10:31:24.585]         }, add = TRUE)
[10:31:24.585]     }
[10:31:24.585]     ...future.frame <- base::sys.nframe()
[10:31:24.585]     ...future.conditions <- base::list()
[10:31:24.585]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:24.585]     if (FALSE) {
[10:31:24.585]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:24.585]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:24.585]     }
[10:31:24.585]     ...future.result <- base::tryCatch({
[10:31:24.585]         base::withCallingHandlers({
[10:31:24.585]             ...future.value <- base::withVisible(base::local({
[10:31:24.585]                 withCallingHandlers({
[10:31:24.585]                   {
[10:31:24.585]                     do.call(function(...) {
[10:31:24.585]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.585]                       if (!identical(...future.globals.maxSize.org, 
[10:31:24.585]                         ...future.globals.maxSize)) {
[10:31:24.585]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.585]                         on.exit(options(oopts), add = TRUE)
[10:31:24.585]                       }
[10:31:24.585]                       {
[10:31:24.585]                         lapply(seq_along(...future.elements_ii), 
[10:31:24.585]                           FUN = function(jj) {
[10:31:24.585]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.585]                             ...future.FUN(...future.X_jj, ...)
[10:31:24.585]                           })
[10:31:24.585]                       }
[10:31:24.585]                     }, args = future.call.arguments)
[10:31:24.585]                   }
[10:31:24.585]                 }, immediateCondition = function(cond) {
[10:31:24.585]                   save_rds <- function (object, pathname, ...) 
[10:31:24.585]                   {
[10:31:24.585]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:24.585]                     if (file_test("-f", pathname_tmp)) {
[10:31:24.585]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.585]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:24.585]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.585]                         fi_tmp[["mtime"]])
[10:31:24.585]                     }
[10:31:24.585]                     tryCatch({
[10:31:24.585]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:24.585]                     }, error = function(ex) {
[10:31:24.585]                       msg <- conditionMessage(ex)
[10:31:24.585]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.585]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:24.585]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.585]                         fi_tmp[["mtime"]], msg)
[10:31:24.585]                       ex$message <- msg
[10:31:24.585]                       stop(ex)
[10:31:24.585]                     })
[10:31:24.585]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:24.585]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:24.585]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:24.585]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.585]                       fi <- file.info(pathname)
[10:31:24.585]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:24.585]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.585]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:24.585]                         fi[["size"]], fi[["mtime"]])
[10:31:24.585]                       stop(msg)
[10:31:24.585]                     }
[10:31:24.585]                     invisible(pathname)
[10:31:24.585]                   }
[10:31:24.585]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:24.585]                     rootPath = tempdir()) 
[10:31:24.585]                   {
[10:31:24.585]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:24.585]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:24.585]                       tmpdir = path, fileext = ".rds")
[10:31:24.585]                     save_rds(obj, file)
[10:31:24.585]                   }
[10:31:24.585]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:24.585]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.585]                   {
[10:31:24.585]                     inherits <- base::inherits
[10:31:24.585]                     invokeRestart <- base::invokeRestart
[10:31:24.585]                     is.null <- base::is.null
[10:31:24.585]                     muffled <- FALSE
[10:31:24.585]                     if (inherits(cond, "message")) {
[10:31:24.585]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:24.585]                       if (muffled) 
[10:31:24.585]                         invokeRestart("muffleMessage")
[10:31:24.585]                     }
[10:31:24.585]                     else if (inherits(cond, "warning")) {
[10:31:24.585]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:24.585]                       if (muffled) 
[10:31:24.585]                         invokeRestart("muffleWarning")
[10:31:24.585]                     }
[10:31:24.585]                     else if (inherits(cond, "condition")) {
[10:31:24.585]                       if (!is.null(pattern)) {
[10:31:24.585]                         computeRestarts <- base::computeRestarts
[10:31:24.585]                         grepl <- base::grepl
[10:31:24.585]                         restarts <- computeRestarts(cond)
[10:31:24.585]                         for (restart in restarts) {
[10:31:24.585]                           name <- restart$name
[10:31:24.585]                           if (is.null(name)) 
[10:31:24.585]                             next
[10:31:24.585]                           if (!grepl(pattern, name)) 
[10:31:24.585]                             next
[10:31:24.585]                           invokeRestart(restart)
[10:31:24.585]                           muffled <- TRUE
[10:31:24.585]                           break
[10:31:24.585]                         }
[10:31:24.585]                       }
[10:31:24.585]                     }
[10:31:24.585]                     invisible(muffled)
[10:31:24.585]                   }
[10:31:24.585]                   muffleCondition(cond)
[10:31:24.585]                 })
[10:31:24.585]             }))
[10:31:24.585]             future::FutureResult(value = ...future.value$value, 
[10:31:24.585]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.585]                   ...future.rng), globalenv = if (FALSE) 
[10:31:24.585]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:24.585]                     ...future.globalenv.names))
[10:31:24.585]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:24.585]         }, condition = base::local({
[10:31:24.585]             c <- base::c
[10:31:24.585]             inherits <- base::inherits
[10:31:24.585]             invokeRestart <- base::invokeRestart
[10:31:24.585]             length <- base::length
[10:31:24.585]             list <- base::list
[10:31:24.585]             seq.int <- base::seq.int
[10:31:24.585]             signalCondition <- base::signalCondition
[10:31:24.585]             sys.calls <- base::sys.calls
[10:31:24.585]             `[[` <- base::`[[`
[10:31:24.585]             `+` <- base::`+`
[10:31:24.585]             `<<-` <- base::`<<-`
[10:31:24.585]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:24.585]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:24.585]                   3L)]
[10:31:24.585]             }
[10:31:24.585]             function(cond) {
[10:31:24.585]                 is_error <- inherits(cond, "error")
[10:31:24.585]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:24.585]                   NULL)
[10:31:24.585]                 if (is_error) {
[10:31:24.585]                   sessionInformation <- function() {
[10:31:24.585]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:24.585]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:24.585]                       search = base::search(), system = base::Sys.info())
[10:31:24.585]                   }
[10:31:24.585]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.585]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:24.585]                     cond$call), session = sessionInformation(), 
[10:31:24.585]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:24.585]                   signalCondition(cond)
[10:31:24.585]                 }
[10:31:24.585]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:24.585]                 "immediateCondition"))) {
[10:31:24.585]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:24.585]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.585]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:24.585]                   if (TRUE && !signal) {
[10:31:24.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.585]                     {
[10:31:24.585]                       inherits <- base::inherits
[10:31:24.585]                       invokeRestart <- base::invokeRestart
[10:31:24.585]                       is.null <- base::is.null
[10:31:24.585]                       muffled <- FALSE
[10:31:24.585]                       if (inherits(cond, "message")) {
[10:31:24.585]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.585]                         if (muffled) 
[10:31:24.585]                           invokeRestart("muffleMessage")
[10:31:24.585]                       }
[10:31:24.585]                       else if (inherits(cond, "warning")) {
[10:31:24.585]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.585]                         if (muffled) 
[10:31:24.585]                           invokeRestart("muffleWarning")
[10:31:24.585]                       }
[10:31:24.585]                       else if (inherits(cond, "condition")) {
[10:31:24.585]                         if (!is.null(pattern)) {
[10:31:24.585]                           computeRestarts <- base::computeRestarts
[10:31:24.585]                           grepl <- base::grepl
[10:31:24.585]                           restarts <- computeRestarts(cond)
[10:31:24.585]                           for (restart in restarts) {
[10:31:24.585]                             name <- restart$name
[10:31:24.585]                             if (is.null(name)) 
[10:31:24.585]                               next
[10:31:24.585]                             if (!grepl(pattern, name)) 
[10:31:24.585]                               next
[10:31:24.585]                             invokeRestart(restart)
[10:31:24.585]                             muffled <- TRUE
[10:31:24.585]                             break
[10:31:24.585]                           }
[10:31:24.585]                         }
[10:31:24.585]                       }
[10:31:24.585]                       invisible(muffled)
[10:31:24.585]                     }
[10:31:24.585]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.585]                   }
[10:31:24.585]                 }
[10:31:24.585]                 else {
[10:31:24.585]                   if (TRUE) {
[10:31:24.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.585]                     {
[10:31:24.585]                       inherits <- base::inherits
[10:31:24.585]                       invokeRestart <- base::invokeRestart
[10:31:24.585]                       is.null <- base::is.null
[10:31:24.585]                       muffled <- FALSE
[10:31:24.585]                       if (inherits(cond, "message")) {
[10:31:24.585]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.585]                         if (muffled) 
[10:31:24.585]                           invokeRestart("muffleMessage")
[10:31:24.585]                       }
[10:31:24.585]                       else if (inherits(cond, "warning")) {
[10:31:24.585]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.585]                         if (muffled) 
[10:31:24.585]                           invokeRestart("muffleWarning")
[10:31:24.585]                       }
[10:31:24.585]                       else if (inherits(cond, "condition")) {
[10:31:24.585]                         if (!is.null(pattern)) {
[10:31:24.585]                           computeRestarts <- base::computeRestarts
[10:31:24.585]                           grepl <- base::grepl
[10:31:24.585]                           restarts <- computeRestarts(cond)
[10:31:24.585]                           for (restart in restarts) {
[10:31:24.585]                             name <- restart$name
[10:31:24.585]                             if (is.null(name)) 
[10:31:24.585]                               next
[10:31:24.585]                             if (!grepl(pattern, name)) 
[10:31:24.585]                               next
[10:31:24.585]                             invokeRestart(restart)
[10:31:24.585]                             muffled <- TRUE
[10:31:24.585]                             break
[10:31:24.585]                           }
[10:31:24.585]                         }
[10:31:24.585]                       }
[10:31:24.585]                       invisible(muffled)
[10:31:24.585]                     }
[10:31:24.585]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.585]                   }
[10:31:24.585]                 }
[10:31:24.585]             }
[10:31:24.585]         }))
[10:31:24.585]     }, error = function(ex) {
[10:31:24.585]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:24.585]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.585]                 ...future.rng), started = ...future.startTime, 
[10:31:24.585]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:24.585]             version = "1.8"), class = "FutureResult")
[10:31:24.585]     }, finally = {
[10:31:24.585]         if (!identical(...future.workdir, getwd())) 
[10:31:24.585]             setwd(...future.workdir)
[10:31:24.585]         {
[10:31:24.585]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:24.585]                 ...future.oldOptions$nwarnings <- NULL
[10:31:24.585]             }
[10:31:24.585]             base::options(...future.oldOptions)
[10:31:24.585]             if (.Platform$OS.type == "windows") {
[10:31:24.585]                 old_names <- names(...future.oldEnvVars)
[10:31:24.585]                 envs <- base::Sys.getenv()
[10:31:24.585]                 names <- names(envs)
[10:31:24.585]                 common <- intersect(names, old_names)
[10:31:24.585]                 added <- setdiff(names, old_names)
[10:31:24.585]                 removed <- setdiff(old_names, names)
[10:31:24.585]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:24.585]                   envs[common]]
[10:31:24.585]                 NAMES <- toupper(changed)
[10:31:24.585]                 args <- list()
[10:31:24.585]                 for (kk in seq_along(NAMES)) {
[10:31:24.585]                   name <- changed[[kk]]
[10:31:24.585]                   NAME <- NAMES[[kk]]
[10:31:24.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.585]                     next
[10:31:24.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.585]                 }
[10:31:24.585]                 NAMES <- toupper(added)
[10:31:24.585]                 for (kk in seq_along(NAMES)) {
[10:31:24.585]                   name <- added[[kk]]
[10:31:24.585]                   NAME <- NAMES[[kk]]
[10:31:24.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.585]                     next
[10:31:24.585]                   args[[name]] <- ""
[10:31:24.585]                 }
[10:31:24.585]                 NAMES <- toupper(removed)
[10:31:24.585]                 for (kk in seq_along(NAMES)) {
[10:31:24.585]                   name <- removed[[kk]]
[10:31:24.585]                   NAME <- NAMES[[kk]]
[10:31:24.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.585]                     next
[10:31:24.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.585]                 }
[10:31:24.585]                 if (length(args) > 0) 
[10:31:24.585]                   base::do.call(base::Sys.setenv, args = args)
[10:31:24.585]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:24.585]             }
[10:31:24.585]             else {
[10:31:24.585]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:24.585]             }
[10:31:24.585]             {
[10:31:24.585]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:24.585]                   0L) {
[10:31:24.585]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:24.585]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:24.585]                   base::options(opts)
[10:31:24.585]                 }
[10:31:24.585]                 {
[10:31:24.585]                   {
[10:31:24.585]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:24.585]                     NULL
[10:31:24.585]                   }
[10:31:24.585]                   options(future.plan = NULL)
[10:31:24.585]                   if (is.na(NA_character_)) 
[10:31:24.585]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.585]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:24.585]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:24.585]                     .init = FALSE)
[10:31:24.585]                 }
[10:31:24.585]             }
[10:31:24.585]         }
[10:31:24.585]     })
[10:31:24.585]     if (TRUE) {
[10:31:24.585]         base::sink(type = "output", split = FALSE)
[10:31:24.585]         if (TRUE) {
[10:31:24.585]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:24.585]         }
[10:31:24.585]         else {
[10:31:24.585]             ...future.result["stdout"] <- base::list(NULL)
[10:31:24.585]         }
[10:31:24.585]         base::close(...future.stdout)
[10:31:24.585]         ...future.stdout <- NULL
[10:31:24.585]     }
[10:31:24.585]     ...future.result$conditions <- ...future.conditions
[10:31:24.585]     ...future.result$finished <- base::Sys.time()
[10:31:24.585]     ...future.result
[10:31:24.585] }
[10:31:24.588] assign_globals() ...
[10:31:24.588] List of 11
[10:31:24.588]  $ ...future.FUN            :function (x, ...)  
[10:31:24.588]  $ x_FUN                    :function (x)  
[10:31:24.588]  $ times                    : int 2
[10:31:24.588]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:24.588]  $ stop_if_not              :function (...)  
[10:31:24.588]  $ dim                      : NULL
[10:31:24.588]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:24.588]  $ future.call.arguments    : list()
[10:31:24.588]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.588]  $ ...future.elements_ii    :List of 1
[10:31:24.588]   ..$ : int 1
[10:31:24.588]  $ ...future.seeds_ii       : NULL
[10:31:24.588]  $ ...future.globals.maxSize: NULL
[10:31:24.588]  - attr(*, "where")=List of 11
[10:31:24.588]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:24.588]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:24.588]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:24.588]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:24.588]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:24.588]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:24.588]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:24.588]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:24.588]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:24.588]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:24.588]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:24.588]  - attr(*, "resolved")= logi FALSE
[10:31:24.588]  - attr(*, "total_size")= num 95128
[10:31:24.588]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.588]  - attr(*, "already-done")= logi TRUE
[10:31:24.599] - copied ‘...future.FUN’ to environment
[10:31:24.599] - copied ‘x_FUN’ to environment
[10:31:24.599] - copied ‘times’ to environment
[10:31:24.599] - copied ‘stopf’ to environment
[10:31:24.599] - copied ‘stop_if_not’ to environment
[10:31:24.600] - copied ‘dim’ to environment
[10:31:24.600] - copied ‘valid_types’ to environment
[10:31:24.600] - copied ‘future.call.arguments’ to environment
[10:31:24.600] - copied ‘...future.elements_ii’ to environment
[10:31:24.600] - copied ‘...future.seeds_ii’ to environment
[10:31:24.600] - copied ‘...future.globals.maxSize’ to environment
[10:31:24.600] assign_globals() ... done
[10:31:24.600] requestCore(): workers = 2
[10:31:24.603] MulticoreFuture started
[10:31:24.604] - Launch lazy future ... done
[10:31:24.604] run() for ‘MulticoreFuture’ ... done
[10:31:24.605] Created future:
[10:31:24.605] plan(): Setting new future strategy stack:
[10:31:24.606] List of future strategies:
[10:31:24.606] 1. sequential:
[10:31:24.606]    - args: function (..., envir = parent.frame())
[10:31:24.606]    - tweaked: FALSE
[10:31:24.606]    - call: NULL
[10:31:24.607] plan(): nbrOfWorkers() = 1
[10:31:24.610] plan(): Setting new future strategy stack:
[10:31:24.611] List of future strategies:
[10:31:24.611] 1. multicore:
[10:31:24.611]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:24.611]    - tweaked: FALSE
[10:31:24.611]    - call: plan(strategy)
[10:31:24.617] plan(): nbrOfWorkers() = 2
[10:31:24.605] MulticoreFuture:
[10:31:24.605] Label: ‘future_vapply-1’
[10:31:24.605] Expression:
[10:31:24.605] {
[10:31:24.605]     do.call(function(...) {
[10:31:24.605]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.605]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.605]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.605]             on.exit(options(oopts), add = TRUE)
[10:31:24.605]         }
[10:31:24.605]         {
[10:31:24.605]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.605]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.605]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.605]             })
[10:31:24.605]         }
[10:31:24.605]     }, args = future.call.arguments)
[10:31:24.605] }
[10:31:24.605] Lazy evaluation: FALSE
[10:31:24.605] Asynchronous evaluation: TRUE
[10:31:24.605] Local evaluation: TRUE
[10:31:24.605] Environment: R_GlobalEnv
[10:31:24.605] Capture standard output: TRUE
[10:31:24.605] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:24.605] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:24.605] Packages: 1 packages (‘future.apply’)
[10:31:24.605] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:24.605] Resolved: FALSE
[10:31:24.605] Value: <not collected>
[10:31:24.605] Conditions captured: <none>
[10:31:24.605] Early signaling: FALSE
[10:31:24.605] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:24.605] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.621] Chunk #1 of 2 ... DONE
[10:31:24.621] Chunk #2 of 2 ...
[10:31:24.621]  - Finding globals in 'X' for chunk #2 ...
[10:31:24.622] getGlobalsAndPackages() ...
[10:31:24.622] Searching for globals...
[10:31:24.623] 
[10:31:24.623] Searching for globals ... DONE
[10:31:24.623] - globals: [0] <none>
[10:31:24.623] getGlobalsAndPackages() ... DONE
[10:31:24.624]    + additional globals found: [n=0] 
[10:31:24.624]    + additional namespaces needed: [n=0] 
[10:31:24.624]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:24.624]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:24.624]  - seeds: <none>
[10:31:24.625]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.625] getGlobalsAndPackages() ...
[10:31:24.625] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.625] Resolving globals: FALSE
[10:31:24.626] Tweak future expression to call with '...' arguments ...
[10:31:24.626] {
[10:31:24.626]     do.call(function(...) {
[10:31:24.626]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.626]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.626]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.626]             on.exit(options(oopts), add = TRUE)
[10:31:24.626]         }
[10:31:24.626]         {
[10:31:24.626]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.626]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.626]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.626]             })
[10:31:24.626]         }
[10:31:24.626]     }, args = future.call.arguments)
[10:31:24.626] }
[10:31:24.626] Tweak future expression to call with '...' arguments ... DONE
[10:31:24.628] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:24.628] - packages: [1] ‘future.apply’
[10:31:24.628] getGlobalsAndPackages() ... DONE
[10:31:24.629] run() for ‘Future’ ...
[10:31:24.629] - state: ‘created’
[10:31:24.629] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:31:24.634] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.634] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:31:24.634]   - Field: ‘label’
[10:31:24.634]   - Field: ‘local’
[10:31:24.635]   - Field: ‘owner’
[10:31:24.635]   - Field: ‘envir’
[10:31:24.635]   - Field: ‘workers’
[10:31:24.635]   - Field: ‘packages’
[10:31:24.635]   - Field: ‘gc’
[10:31:24.635]   - Field: ‘job’
[10:31:24.635]   - Field: ‘conditions’
[10:31:24.636]   - Field: ‘expr’
[10:31:24.636]   - Field: ‘uuid’
[10:31:24.636]   - Field: ‘seed’
[10:31:24.636]   - Field: ‘version’
[10:31:24.636]   - Field: ‘result’
[10:31:24.636]   - Field: ‘asynchronous’
[10:31:24.636]   - Field: ‘calls’
[10:31:24.636]   - Field: ‘globals’
[10:31:24.637]   - Field: ‘stdout’
[10:31:24.637]   - Field: ‘earlySignal’
[10:31:24.637]   - Field: ‘lazy’
[10:31:24.637]   - Field: ‘state’
[10:31:24.637] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:31:24.637] - Launch lazy future ...
[10:31:24.638] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:24.638] Packages needed by future strategies (n = 0): <none>
[10:31:24.639] {
[10:31:24.639]     {
[10:31:24.639]         {
[10:31:24.639]             ...future.startTime <- base::Sys.time()
[10:31:24.639]             {
[10:31:24.639]                 {
[10:31:24.639]                   {
[10:31:24.639]                     {
[10:31:24.639]                       {
[10:31:24.639]                         base::local({
[10:31:24.639]                           has_future <- base::requireNamespace("future", 
[10:31:24.639]                             quietly = TRUE)
[10:31:24.639]                           if (has_future) {
[10:31:24.639]                             ns <- base::getNamespace("future")
[10:31:24.639]                             version <- ns[[".package"]][["version"]]
[10:31:24.639]                             if (is.null(version)) 
[10:31:24.639]                               version <- utils::packageVersion("future")
[10:31:24.639]                           }
[10:31:24.639]                           else {
[10:31:24.639]                             version <- NULL
[10:31:24.639]                           }
[10:31:24.639]                           if (!has_future || version < "1.8.0") {
[10:31:24.639]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:24.639]                               "", base::R.version$version.string), 
[10:31:24.639]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:24.639]                                 base::R.version$platform, 8 * 
[10:31:24.639]                                   base::.Machine$sizeof.pointer), 
[10:31:24.639]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:24.639]                                 "release", "version")], collapse = " "), 
[10:31:24.639]                               hostname = base::Sys.info()[["nodename"]])
[10:31:24.639]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:24.639]                               info)
[10:31:24.639]                             info <- base::paste(info, collapse = "; ")
[10:31:24.639]                             if (!has_future) {
[10:31:24.639]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:24.639]                                 info)
[10:31:24.639]                             }
[10:31:24.639]                             else {
[10:31:24.639]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:24.639]                                 info, version)
[10:31:24.639]                             }
[10:31:24.639]                             base::stop(msg)
[10:31:24.639]                           }
[10:31:24.639]                         })
[10:31:24.639]                       }
[10:31:24.639]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:24.639]                       base::options(mc.cores = 1L)
[10:31:24.639]                     }
[10:31:24.639]                     base::local({
[10:31:24.639]                       for (pkg in "future.apply") {
[10:31:24.639]                         base::loadNamespace(pkg)
[10:31:24.639]                         base::library(pkg, character.only = TRUE)
[10:31:24.639]                       }
[10:31:24.639]                     })
[10:31:24.639]                   }
[10:31:24.639]                   ...future.strategy.old <- future::plan("list")
[10:31:24.639]                   options(future.plan = NULL)
[10:31:24.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:24.639]                 }
[10:31:24.639]                 ...future.workdir <- getwd()
[10:31:24.639]             }
[10:31:24.639]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:24.639]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:24.639]         }
[10:31:24.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:24.639]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:24.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:24.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:24.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:24.639]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:24.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:24.639]             base::names(...future.oldOptions))
[10:31:24.639]     }
[10:31:24.639]     if (FALSE) {
[10:31:24.639]     }
[10:31:24.639]     else {
[10:31:24.639]         if (TRUE) {
[10:31:24.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:24.639]                 open = "w")
[10:31:24.639]         }
[10:31:24.639]         else {
[10:31:24.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:24.639]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:24.639]         }
[10:31:24.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:24.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:24.639]             base::sink(type = "output", split = FALSE)
[10:31:24.639]             base::close(...future.stdout)
[10:31:24.639]         }, add = TRUE)
[10:31:24.639]     }
[10:31:24.639]     ...future.frame <- base::sys.nframe()
[10:31:24.639]     ...future.conditions <- base::list()
[10:31:24.639]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:24.639]     if (FALSE) {
[10:31:24.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:24.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:24.639]     }
[10:31:24.639]     ...future.result <- base::tryCatch({
[10:31:24.639]         base::withCallingHandlers({
[10:31:24.639]             ...future.value <- base::withVisible(base::local({
[10:31:24.639]                 withCallingHandlers({
[10:31:24.639]                   {
[10:31:24.639]                     do.call(function(...) {
[10:31:24.639]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.639]                       if (!identical(...future.globals.maxSize.org, 
[10:31:24.639]                         ...future.globals.maxSize)) {
[10:31:24.639]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.639]                         on.exit(options(oopts), add = TRUE)
[10:31:24.639]                       }
[10:31:24.639]                       {
[10:31:24.639]                         lapply(seq_along(...future.elements_ii), 
[10:31:24.639]                           FUN = function(jj) {
[10:31:24.639]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.639]                             ...future.FUN(...future.X_jj, ...)
[10:31:24.639]                           })
[10:31:24.639]                       }
[10:31:24.639]                     }, args = future.call.arguments)
[10:31:24.639]                   }
[10:31:24.639]                 }, immediateCondition = function(cond) {
[10:31:24.639]                   save_rds <- function (object, pathname, ...) 
[10:31:24.639]                   {
[10:31:24.639]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:31:24.639]                     if (file_test("-f", pathname_tmp)) {
[10:31:24.639]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.639]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:31:24.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.639]                         fi_tmp[["mtime"]])
[10:31:24.639]                     }
[10:31:24.639]                     tryCatch({
[10:31:24.639]                       saveRDS(object, file = pathname_tmp, ...)
[10:31:24.639]                     }, error = function(ex) {
[10:31:24.639]                       msg <- conditionMessage(ex)
[10:31:24.639]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.639]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:31:24.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.639]                         fi_tmp[["mtime"]], msg)
[10:31:24.639]                       ex$message <- msg
[10:31:24.639]                       stop(ex)
[10:31:24.639]                     })
[10:31:24.639]                     stopifnot(file_test("-f", pathname_tmp))
[10:31:24.639]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:31:24.639]                     if (!res || file_test("-f", pathname_tmp)) {
[10:31:24.639]                       fi_tmp <- file.info(pathname_tmp)
[10:31:24.639]                       fi <- file.info(pathname)
[10:31:24.639]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:31:24.639]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:31:24.639]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:31:24.639]                         fi[["size"]], fi[["mtime"]])
[10:31:24.639]                       stop(msg)
[10:31:24.639]                     }
[10:31:24.639]                     invisible(pathname)
[10:31:24.639]                   }
[10:31:24.639]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:31:24.639]                     rootPath = tempdir()) 
[10:31:24.639]                   {
[10:31:24.639]                     obj <- list(time = Sys.time(), condition = cond)
[10:31:24.639]                     file <- tempfile(pattern = class(cond)[1], 
[10:31:24.639]                       tmpdir = path, fileext = ".rds")
[10:31:24.639]                     save_rds(obj, file)
[10:31:24.639]                   }
[10:31:24.639]                   saveImmediateCondition(cond, path = "/tmp/RtmpjkGHGl/.future/immediateConditions")
[10:31:24.639]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.639]                   {
[10:31:24.639]                     inherits <- base::inherits
[10:31:24.639]                     invokeRestart <- base::invokeRestart
[10:31:24.639]                     is.null <- base::is.null
[10:31:24.639]                     muffled <- FALSE
[10:31:24.639]                     if (inherits(cond, "message")) {
[10:31:24.639]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:24.639]                       if (muffled) 
[10:31:24.639]                         invokeRestart("muffleMessage")
[10:31:24.639]                     }
[10:31:24.639]                     else if (inherits(cond, "warning")) {
[10:31:24.639]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:24.639]                       if (muffled) 
[10:31:24.639]                         invokeRestart("muffleWarning")
[10:31:24.639]                     }
[10:31:24.639]                     else if (inherits(cond, "condition")) {
[10:31:24.639]                       if (!is.null(pattern)) {
[10:31:24.639]                         computeRestarts <- base::computeRestarts
[10:31:24.639]                         grepl <- base::grepl
[10:31:24.639]                         restarts <- computeRestarts(cond)
[10:31:24.639]                         for (restart in restarts) {
[10:31:24.639]                           name <- restart$name
[10:31:24.639]                           if (is.null(name)) 
[10:31:24.639]                             next
[10:31:24.639]                           if (!grepl(pattern, name)) 
[10:31:24.639]                             next
[10:31:24.639]                           invokeRestart(restart)
[10:31:24.639]                           muffled <- TRUE
[10:31:24.639]                           break
[10:31:24.639]                         }
[10:31:24.639]                       }
[10:31:24.639]                     }
[10:31:24.639]                     invisible(muffled)
[10:31:24.639]                   }
[10:31:24.639]                   muffleCondition(cond)
[10:31:24.639]                 })
[10:31:24.639]             }))
[10:31:24.639]             future::FutureResult(value = ...future.value$value, 
[10:31:24.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.639]                   ...future.rng), globalenv = if (FALSE) 
[10:31:24.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:24.639]                     ...future.globalenv.names))
[10:31:24.639]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:24.639]         }, condition = base::local({
[10:31:24.639]             c <- base::c
[10:31:24.639]             inherits <- base::inherits
[10:31:24.639]             invokeRestart <- base::invokeRestart
[10:31:24.639]             length <- base::length
[10:31:24.639]             list <- base::list
[10:31:24.639]             seq.int <- base::seq.int
[10:31:24.639]             signalCondition <- base::signalCondition
[10:31:24.639]             sys.calls <- base::sys.calls
[10:31:24.639]             `[[` <- base::`[[`
[10:31:24.639]             `+` <- base::`+`
[10:31:24.639]             `<<-` <- base::`<<-`
[10:31:24.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:24.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:24.639]                   3L)]
[10:31:24.639]             }
[10:31:24.639]             function(cond) {
[10:31:24.639]                 is_error <- inherits(cond, "error")
[10:31:24.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:24.639]                   NULL)
[10:31:24.639]                 if (is_error) {
[10:31:24.639]                   sessionInformation <- function() {
[10:31:24.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:24.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:24.639]                       search = base::search(), system = base::Sys.info())
[10:31:24.639]                   }
[10:31:24.639]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:24.639]                     cond$call), session = sessionInformation(), 
[10:31:24.639]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:24.639]                   signalCondition(cond)
[10:31:24.639]                 }
[10:31:24.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:24.639]                 "immediateCondition"))) {
[10:31:24.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:24.639]                   ...future.conditions[[length(...future.conditions) + 
[10:31:24.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:24.639]                   if (TRUE && !signal) {
[10:31:24.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.639]                     {
[10:31:24.639]                       inherits <- base::inherits
[10:31:24.639]                       invokeRestart <- base::invokeRestart
[10:31:24.639]                       is.null <- base::is.null
[10:31:24.639]                       muffled <- FALSE
[10:31:24.639]                       if (inherits(cond, "message")) {
[10:31:24.639]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.639]                         if (muffled) 
[10:31:24.639]                           invokeRestart("muffleMessage")
[10:31:24.639]                       }
[10:31:24.639]                       else if (inherits(cond, "warning")) {
[10:31:24.639]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.639]                         if (muffled) 
[10:31:24.639]                           invokeRestart("muffleWarning")
[10:31:24.639]                       }
[10:31:24.639]                       else if (inherits(cond, "condition")) {
[10:31:24.639]                         if (!is.null(pattern)) {
[10:31:24.639]                           computeRestarts <- base::computeRestarts
[10:31:24.639]                           grepl <- base::grepl
[10:31:24.639]                           restarts <- computeRestarts(cond)
[10:31:24.639]                           for (restart in restarts) {
[10:31:24.639]                             name <- restart$name
[10:31:24.639]                             if (is.null(name)) 
[10:31:24.639]                               next
[10:31:24.639]                             if (!grepl(pattern, name)) 
[10:31:24.639]                               next
[10:31:24.639]                             invokeRestart(restart)
[10:31:24.639]                             muffled <- TRUE
[10:31:24.639]                             break
[10:31:24.639]                           }
[10:31:24.639]                         }
[10:31:24.639]                       }
[10:31:24.639]                       invisible(muffled)
[10:31:24.639]                     }
[10:31:24.639]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.639]                   }
[10:31:24.639]                 }
[10:31:24.639]                 else {
[10:31:24.639]                   if (TRUE) {
[10:31:24.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:24.639]                     {
[10:31:24.639]                       inherits <- base::inherits
[10:31:24.639]                       invokeRestart <- base::invokeRestart
[10:31:24.639]                       is.null <- base::is.null
[10:31:24.639]                       muffled <- FALSE
[10:31:24.639]                       if (inherits(cond, "message")) {
[10:31:24.639]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:24.639]                         if (muffled) 
[10:31:24.639]                           invokeRestart("muffleMessage")
[10:31:24.639]                       }
[10:31:24.639]                       else if (inherits(cond, "warning")) {
[10:31:24.639]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:24.639]                         if (muffled) 
[10:31:24.639]                           invokeRestart("muffleWarning")
[10:31:24.639]                       }
[10:31:24.639]                       else if (inherits(cond, "condition")) {
[10:31:24.639]                         if (!is.null(pattern)) {
[10:31:24.639]                           computeRestarts <- base::computeRestarts
[10:31:24.639]                           grepl <- base::grepl
[10:31:24.639]                           restarts <- computeRestarts(cond)
[10:31:24.639]                           for (restart in restarts) {
[10:31:24.639]                             name <- restart$name
[10:31:24.639]                             if (is.null(name)) 
[10:31:24.639]                               next
[10:31:24.639]                             if (!grepl(pattern, name)) 
[10:31:24.639]                               next
[10:31:24.639]                             invokeRestart(restart)
[10:31:24.639]                             muffled <- TRUE
[10:31:24.639]                             break
[10:31:24.639]                           }
[10:31:24.639]                         }
[10:31:24.639]                       }
[10:31:24.639]                       invisible(muffled)
[10:31:24.639]                     }
[10:31:24.639]                     muffleCondition(cond, pattern = "^muffle")
[10:31:24.639]                   }
[10:31:24.639]                 }
[10:31:24.639]             }
[10:31:24.639]         }))
[10:31:24.639]     }, error = function(ex) {
[10:31:24.639]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:24.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:24.639]                 ...future.rng), started = ...future.startTime, 
[10:31:24.639]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:24.639]             version = "1.8"), class = "FutureResult")
[10:31:24.639]     }, finally = {
[10:31:24.639]         if (!identical(...future.workdir, getwd())) 
[10:31:24.639]             setwd(...future.workdir)
[10:31:24.639]         {
[10:31:24.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:24.639]                 ...future.oldOptions$nwarnings <- NULL
[10:31:24.639]             }
[10:31:24.639]             base::options(...future.oldOptions)
[10:31:24.639]             if (.Platform$OS.type == "windows") {
[10:31:24.639]                 old_names <- names(...future.oldEnvVars)
[10:31:24.639]                 envs <- base::Sys.getenv()
[10:31:24.639]                 names <- names(envs)
[10:31:24.639]                 common <- intersect(names, old_names)
[10:31:24.639]                 added <- setdiff(names, old_names)
[10:31:24.639]                 removed <- setdiff(old_names, names)
[10:31:24.639]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:24.639]                   envs[common]]
[10:31:24.639]                 NAMES <- toupper(changed)
[10:31:24.639]                 args <- list()
[10:31:24.639]                 for (kk in seq_along(NAMES)) {
[10:31:24.639]                   name <- changed[[kk]]
[10:31:24.639]                   NAME <- NAMES[[kk]]
[10:31:24.639]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.639]                     next
[10:31:24.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.639]                 }
[10:31:24.639]                 NAMES <- toupper(added)
[10:31:24.639]                 for (kk in seq_along(NAMES)) {
[10:31:24.639]                   name <- added[[kk]]
[10:31:24.639]                   NAME <- NAMES[[kk]]
[10:31:24.639]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.639]                     next
[10:31:24.639]                   args[[name]] <- ""
[10:31:24.639]                 }
[10:31:24.639]                 NAMES <- toupper(removed)
[10:31:24.639]                 for (kk in seq_along(NAMES)) {
[10:31:24.639]                   name <- removed[[kk]]
[10:31:24.639]                   NAME <- NAMES[[kk]]
[10:31:24.639]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:24.639]                     next
[10:31:24.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:24.639]                 }
[10:31:24.639]                 if (length(args) > 0) 
[10:31:24.639]                   base::do.call(base::Sys.setenv, args = args)
[10:31:24.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:24.639]             }
[10:31:24.639]             else {
[10:31:24.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:24.639]             }
[10:31:24.639]             {
[10:31:24.639]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:24.639]                   0L) {
[10:31:24.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:24.639]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:24.639]                   base::options(opts)
[10:31:24.639]                 }
[10:31:24.639]                 {
[10:31:24.639]                   {
[10:31:24.639]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:24.639]                     NULL
[10:31:24.639]                   }
[10:31:24.639]                   options(future.plan = NULL)
[10:31:24.639]                   if (is.na(NA_character_)) 
[10:31:24.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:24.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:24.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:24.639]                     .init = FALSE)
[10:31:24.639]                 }
[10:31:24.639]             }
[10:31:24.639]         }
[10:31:24.639]     })
[10:31:24.639]     if (TRUE) {
[10:31:24.639]         base::sink(type = "output", split = FALSE)
[10:31:24.639]         if (TRUE) {
[10:31:24.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:24.639]         }
[10:31:24.639]         else {
[10:31:24.639]             ...future.result["stdout"] <- base::list(NULL)
[10:31:24.639]         }
[10:31:24.639]         base::close(...future.stdout)
[10:31:24.639]         ...future.stdout <- NULL
[10:31:24.639]     }
[10:31:24.639]     ...future.result$conditions <- ...future.conditions
[10:31:24.639]     ...future.result$finished <- base::Sys.time()
[10:31:24.639]     ...future.result
[10:31:24.639] }
[10:31:24.642] assign_globals() ...
[10:31:24.642] List of 11
[10:31:24.642]  $ ...future.FUN            :function (x, ...)  
[10:31:24.642]  $ x_FUN                    :function (x)  
[10:31:24.642]  $ times                    : int 2
[10:31:24.642]  $ stopf                    :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:24.642]  $ stop_if_not              :function (...)  
[10:31:24.642]  $ dim                      : NULL
[10:31:24.642]  $ valid_types              : chr [1:3] "logical" "integer" "double"
[10:31:24.642]  $ future.call.arguments    : list()
[10:31:24.642]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:24.642]  $ ...future.elements_ii    :List of 2
[10:31:24.642]   ..$ : int 2
[10:31:24.642]   ..$ : int 3
[10:31:24.642]  $ ...future.seeds_ii       : NULL
[10:31:24.642]  $ ...future.globals.maxSize: NULL
[10:31:24.642]  - attr(*, "where")=List of 11
[10:31:24.642]   ..$ ...future.FUN            :<environment: R_EmptyEnv> 
[10:31:24.642]   ..$ x_FUN                    :<environment: R_EmptyEnv> 
[10:31:24.642]   ..$ times                    :<environment: R_EmptyEnv> 
[10:31:24.642]   ..$ stopf                    :<environment: R_EmptyEnv> 
[10:31:24.642]   ..$ stop_if_not              :<environment: R_EmptyEnv> 
[10:31:24.642]   ..$ dim                      :<environment: R_EmptyEnv> 
[10:31:24.642]   ..$ valid_types              :<environment: R_EmptyEnv> 
[10:31:24.642]   ..$ future.call.arguments    :<environment: R_EmptyEnv> 
[10:31:24.642]   ..$ ...future.elements_ii    :<environment: R_EmptyEnv> 
[10:31:24.642]   ..$ ...future.seeds_ii       :<environment: R_EmptyEnv> 
[10:31:24.642]   ..$ ...future.globals.maxSize:<environment: R_EmptyEnv> 
[10:31:24.642]  - attr(*, "resolved")= logi FALSE
[10:31:24.642]  - attr(*, "total_size")= num 95128
[10:31:24.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:24.642]  - attr(*, "already-done")= logi TRUE
[10:31:24.657] - copied ‘...future.FUN’ to environment
[10:31:24.657] - copied ‘x_FUN’ to environment
[10:31:24.657] - copied ‘times’ to environment
[10:31:24.657] - copied ‘stopf’ to environment
[10:31:24.658] - copied ‘stop_if_not’ to environment
[10:31:24.658] - copied ‘dim’ to environment
[10:31:24.658] - copied ‘valid_types’ to environment
[10:31:24.658] - copied ‘future.call.arguments’ to environment
[10:31:24.658] - copied ‘...future.elements_ii’ to environment
[10:31:24.658] - copied ‘...future.seeds_ii’ to environment
[10:31:24.658] - copied ‘...future.globals.maxSize’ to environment
[10:31:24.658] assign_globals() ... done
[10:31:24.659] requestCore(): workers = 2
[10:31:24.661] MulticoreFuture started
[10:31:24.662] - Launch lazy future ... done
[10:31:24.662] run() for ‘MulticoreFuture’ ... done
[10:31:24.662] Created future:
[10:31:24.663] plan(): Setting new future strategy stack:
[10:31:24.663] List of future strategies:
[10:31:24.663] 1. sequential:
[10:31:24.663]    - args: function (..., envir = parent.frame())
[10:31:24.663]    - tweaked: FALSE
[10:31:24.663]    - call: NULL
[10:31:24.664] plan(): nbrOfWorkers() = 1
[10:31:24.667] plan(): Setting new future strategy stack:
[10:31:24.667] List of future strategies:
[10:31:24.667] 1. multicore:
[10:31:24.667]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:31:24.667]    - tweaked: FALSE
[10:31:24.667]    - call: plan(strategy)
[10:31:24.673] plan(): nbrOfWorkers() = 2
[10:31:24.663] MulticoreFuture:
[10:31:24.663] Label: ‘future_vapply-2’
[10:31:24.663] Expression:
[10:31:24.663] {
[10:31:24.663]     do.call(function(...) {
[10:31:24.663]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:24.663]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:24.663]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:24.663]             on.exit(options(oopts), add = TRUE)
[10:31:24.663]         }
[10:31:24.663]         {
[10:31:24.663]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:24.663]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:24.663]                 ...future.FUN(...future.X_jj, ...)
[10:31:24.663]             })
[10:31:24.663]         }
[10:31:24.663]     }, args = future.call.arguments)
[10:31:24.663] }
[10:31:24.663] Lazy evaluation: FALSE
[10:31:24.663] Asynchronous evaluation: TRUE
[10:31:24.663] Local evaluation: TRUE
[10:31:24.663] Environment: R_GlobalEnv
[10:31:24.663] Capture standard output: TRUE
[10:31:24.663] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:24.663] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:24.663] Packages: 1 packages (‘future.apply’)
[10:31:24.663] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:24.663] Resolved: FALSE
[10:31:24.663] Value: <not collected>
[10:31:24.663] Conditions captured: <none>
[10:31:24.663] Early signaling: FALSE
[10:31:24.663] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:24.663] Class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:24.677] Chunk #2 of 2 ... DONE
[10:31:24.677] Launching 2 futures (chunks) ... DONE
[10:31:24.677] Resolving 2 futures (chunks) ...
[10:31:24.677] resolve() on list ...
[10:31:24.678]  recursive: 0
[10:31:24.678]  length: 2
[10:31:24.678] 
[10:31:24.679] Future #1
[10:31:24.679] result() for MulticoreFuture ...
[10:31:24.687] result() for MulticoreFuture ...
[10:31:24.687] result() for MulticoreFuture ... done
[10:31:24.688] signalConditions() ...
[10:31:24.688]  - include = ‘immediateCondition’
[10:31:24.688]  - exclude = 
[10:31:24.688]  - resignal = FALSE
[10:31:24.688]  - Number of conditions: 1
[10:31:24.688] signalConditions() ... done
[10:31:24.689] result() for MulticoreFuture ... done
[10:31:24.689] result() for MulticoreFuture ...
[10:31:24.689] result() for MulticoreFuture ... done
[10:31:24.689] signalConditions() ...
[10:31:24.689]  - include = ‘immediateCondition’
[10:31:24.689]  - exclude = 
[10:31:24.689]  - resignal = FALSE
[10:31:24.690]  - Number of conditions: 1
[10:31:24.690] signalConditions() ... done
[10:31:24.690] signalConditionsASAP(MulticoreFuture, pos=1) ...
[10:31:24.690] - nx: 2
[10:31:24.690] - relay: TRUE
[10:31:24.690] - stdout: TRUE
[10:31:24.691] - signal: TRUE
[10:31:24.691] - resignal: FALSE
[10:31:24.691] - force: TRUE
[10:31:24.694] - relayed: [n=2] FALSE, FALSE
[10:31:24.695] - queued futures: [n=2] FALSE, FALSE
[10:31:24.695]  - until=1
[10:31:24.695]  - relaying element #1
[10:31:24.696] result() for MulticoreFuture ...
[10:31:24.696] result() for MulticoreFuture ... done
[10:31:24.696] result() for MulticoreFuture ...
[10:31:24.697] result() for MulticoreFuture ... done
[10:31:24.697] signalConditions() ...
[10:31:24.697]  - include = ‘immediateCondition’
[10:31:24.697]  - exclude = 
[10:31:24.697]  - resignal = FALSE
[10:31:24.697]  - Number of conditions: 1
[10:31:24.698] signalConditions() ... done
[10:31:24.698] result() for MulticoreFuture ...
[10:31:24.698] result() for MulticoreFuture ... done
[10:31:24.699] signalConditions() ...
[10:31:24.699]  - include = ‘immediateCondition’
[10:31:24.699]  - exclude = 
[10:31:24.699]  - resignal = FALSE
[10:31:24.699]  - Number of conditions: 1
[10:31:24.700] signalConditions() ... done
[10:31:24.700] result() for MulticoreFuture ...
[10:31:24.700] result() for MulticoreFuture ... done
[10:31:24.700] signalConditions() ...
[10:31:24.700]  - include = ‘condition’
[10:31:24.700]  - exclude = ‘immediateCondition’
[10:31:24.700]  - resignal = TRUE
[10:31:24.701]  - Number of conditions: 1
[10:31:24.701]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:31:24.701] signalConditions() ... done
[10:31:24.701] - relayed: [n=2] FALSE, FALSE
[10:31:24.702] - queued futures: [n=2] TRUE, FALSE
[10:31:24.702] signalConditionsASAP(MulticoreFuture, pos=1) ... done
[10:31:24.702] plan(): Setting new future strategy stack:
[10:31:24.702] List of future strategies:
[10:31:24.702] 1. sequential:
[10:31:24.702]    - args: function (..., envir = parent.frame())
[10:31:24.702]    - tweaked: FALSE
[10:31:24.702]    - call: plan(sequential)
[10:31:24.703] plan(): nbrOfWorkers() = 1
*** strategy = ‘multicore’ ... done
*** strategy = ‘multisession’ ...
[10:31:24.704] plan(): Setting new future strategy stack:
[10:31:24.704] List of future strategies:
[10:31:24.704] 1. multisession:
[10:31:24.704]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:24.704]    - tweaked: FALSE
[10:31:24.704]    - call: plan(strategy)
[10:31:24.704] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:31:24.705] multisession:
[10:31:24.705] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:31:24.705] - tweaked: FALSE
[10:31:24.705] - call: plan(strategy)
[10:31:24.712] getGlobalsAndPackages() ...
[10:31:24.713] Not searching for globals
[10:31:24.713] - globals: [0] <none>
[10:31:24.713] getGlobalsAndPackages() ... DONE
[10:31:24.714] [local output] makeClusterPSOCK() ...
[10:31:24.790] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[10:31:24.792] [local output] Base port: 11885
[10:31:24.792] [local output] Getting setup options for 2 cluster nodes ...
[10:31:24.792] [local output]  - Node 1 of 2 ...
[10:31:24.792] [local output] localMachine=TRUE => revtunnel=FALSE

[10:31:24.793] Testing if worker's PID can be inferred: ‘'/usr/local/lib/R/bin/Rscript' -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpjkGHGl/worker.rank=1.parallelly.parent=76319.12a1f1be1d77e.pid")), silent = TRUE)' -e 'file.exists("/tmp/RtmpjkGHGl/worker.rank=1.parallelly.parent=76319.12a1f1be1d77e.pid")'’
[10:31:24.984] - Possible to infer worker's PID: TRUE
[10:31:24.984] [local output] Rscript port: 11885

[10:31:24.985] [local output]  - Node 2 of 2 ...
[10:31:24.985] [local output] localMachine=TRUE => revtunnel=FALSE

[10:31:24.986] [local output] Rscript port: 11885

[10:31:24.986] [local output] Getting setup options for 2 cluster nodes ... done
[10:31:24.986] [local output]  - Parallel setup requested for some PSOCK nodes
[10:31:24.987] [local output] Setting up PSOCK nodes in parallel
[10:31:24.987] List of 36
[10:31:24.987]  $ worker          : chr "localhost"
[10:31:24.987]   ..- attr(*, "localhost")= logi TRUE
[10:31:24.987]  $ master          : chr "localhost"
[10:31:24.987]  $ port            : int 11885
[10:31:24.987]  $ connectTimeout  : num 120
[10:31:24.987]  $ timeout         : num 2592000
[10:31:24.987]  $ rscript         : chr "'/usr/local/lib/R/bin/Rscript'"
[10:31:24.987]  $ homogeneous     : logi TRUE
[10:31:24.987]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[10:31:24.987]  $ rscript_envs    : NULL
[10:31:24.987]  $ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:31:24.987]  $ rscript_startup : NULL
[10:31:24.987]  $ rscript_sh      : chr "sh"
[10:31:24.987]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:31:24.987]  $ methods         : logi TRUE
[10:31:24.987]  $ socketOptions   : chr "no-delay"
[10:31:24.987]  $ useXDR          : logi FALSE
[10:31:24.987]  $ outfile         : chr "/dev/null"
[10:31:24.987]  $ renice          : int NA
[10:31:24.987]  $ rshcmd          : NULL
[10:31:24.987]  $ user            : chr(0) 
[10:31:24.987]  $ revtunnel       : logi FALSE
[10:31:24.987]  $ rshlogfile      : NULL
[10:31:24.987]  $ rshopts         : chr(0) 
[10:31:24.987]  $ rank            : int 1
[10:31:24.987]  $ manual          : logi FALSE
[10:31:24.987]  $ dryrun          : logi FALSE
[10:31:24.987]  $ quiet           : logi FALSE
[10:31:24.987]  $ setup_strategy  : chr "parallel"
[10:31:24.987]  $ local_cmd       : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:31:24.987]  $ pidfile         : chr "/tmp/RtmpjkGHGl/worker.rank=1.parallelly.parent=76319.12a1f1be1d77e.pid"
[10:31:24.987]  $ rshcmd_label    : NULL
[10:31:24.987]  $ rsh_call        : NULL
[10:31:24.987]  $ cmd             : chr "'/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppr"| __truncated__
[10:31:24.987]  $ localMachine    : logi TRUE
[10:31:24.987]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), 
[10:31:24.987]     master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 
[10:31:24.987]         2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 
[10:31:24.987]         30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, 
[10:31:24.987]     rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[10:31:24.987]         "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", 
[10:31:24.987]         "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", 
[10:31:24.987]         "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", 
[10:31:24.987]         FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", 
[10:31:24.987]         NULL), user = NULL, revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", 
[10:31:24.987]         NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, 
[10:31:24.987]     setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", 
[10:31:24.987]         "parallel"), action = c("launch", "options"), verbose = FALSE)  
[10:31:24.987]  $ arguments       :List of 28
[10:31:24.987]   ..$ worker          : chr "localhost"
[10:31:24.987]   ..$ master          : NULL
[10:31:24.987]   ..$ port            : int 11885
[10:31:24.987]   ..$ connectTimeout  : num 120
[10:31:24.987]   ..$ timeout         : num 2592000
[10:31:24.987]   ..$ rscript         : NULL
[10:31:24.987]   ..$ homogeneous     : NULL
[10:31:24.987]   ..$ rscript_args    : NULL
[10:31:24.987]   ..$ rscript_envs    : NULL
[10:31:24.987]   ..$ rscript_libs    : chr [1:2] "/usr/local/lib/R/site-library" "/usr/local/lib/R/library"
[10:31:24.987]   ..$ rscript_startup : NULL
[10:31:24.987]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[10:31:24.987]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[10:31:24.987]   ..$ methods         : logi TRUE
[10:31:24.987]   ..$ socketOptions   : chr "no-delay"
[10:31:24.987]   ..$ useXDR          : logi FALSE
[10:31:24.987]   ..$ outfile         : chr "/dev/null"
[10:31:24.987]   ..$ renice          : int NA
[10:31:24.987]   ..$ rshcmd          : NULL
[10:31:24.987]   ..$ user            : NULL
[10:31:24.987]   ..$ revtunnel       : logi NA
[10:31:24.987]   ..$ rshlogfile      : NULL
[10:31:24.987]   ..$ rshopts         : NULL
[10:31:24.987]   ..$ rank            : int 1
[10:31:24.987]   ..$ manual          : logi FALSE
[10:31:24.987]   ..$ dryrun          : logi FALSE
[10:31:24.987]   ..$ quiet           : logi FALSE
[10:31:24.987]   ..$ setup_strategy  : chr "parallel"
[10:31:24.987]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[10:31:25.005] [local output] System call to launch all workers:
[10:31:25.005] [local output] '/usr/local/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpjkGHGl/worker.rank=1.parallelly.parent=76319.12a1f1be1d77e.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/usr/local/lib/R/site-library","/usr/local/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11885 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[10:31:25.005] [local output] Starting PSOCK main server
[10:31:25.011] [local output] Workers launched
[10:31:25.011] [local output] Waiting for workers to connect back
[10:31:25.011]  - [local output] 0 workers out of 2 ready
[10:31:25.257]  - [local output] 0 workers out of 2 ready
[10:31:25.258]  - [local output] 1 workers out of 2 ready
[10:31:25.267]  - [local output] 1 workers out of 2 ready
[10:31:25.267]  - [local output] 2 workers out of 2 ready
[10:31:25.268] [local output] Launching of workers completed
[10:31:25.268] [local output] Collecting session information from workers
[10:31:25.269] [local output]  - Worker #1 of 2
[10:31:25.269] [local output]  - Worker #2 of 2
[10:31:25.269] [local output] makeClusterPSOCK() ... done
[10:31:25.281] Packages needed by the future expression (n = 0): <none>
[10:31:25.281] Packages needed by future strategies (n = 0): <none>
[10:31:25.282] {
[10:31:25.282]     {
[10:31:25.282]         {
[10:31:25.282]             ...future.startTime <- base::Sys.time()
[10:31:25.282]             {
[10:31:25.282]                 {
[10:31:25.282]                   {
[10:31:25.282]                     {
[10:31:25.282]                       base::local({
[10:31:25.282]                         has_future <- base::requireNamespace("future", 
[10:31:25.282]                           quietly = TRUE)
[10:31:25.282]                         if (has_future) {
[10:31:25.282]                           ns <- base::getNamespace("future")
[10:31:25.282]                           version <- ns[[".package"]][["version"]]
[10:31:25.282]                           if (is.null(version)) 
[10:31:25.282]                             version <- utils::packageVersion("future")
[10:31:25.282]                         }
[10:31:25.282]                         else {
[10:31:25.282]                           version <- NULL
[10:31:25.282]                         }
[10:31:25.282]                         if (!has_future || version < "1.8.0") {
[10:31:25.282]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:25.282]                             "", base::R.version$version.string), 
[10:31:25.282]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:25.282]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:25.282]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:25.282]                               "release", "version")], collapse = " "), 
[10:31:25.282]                             hostname = base::Sys.info()[["nodename"]])
[10:31:25.282]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:25.282]                             info)
[10:31:25.282]                           info <- base::paste(info, collapse = "; ")
[10:31:25.282]                           if (!has_future) {
[10:31:25.282]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:25.282]                               info)
[10:31:25.282]                           }
[10:31:25.282]                           else {
[10:31:25.282]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:25.282]                               info, version)
[10:31:25.282]                           }
[10:31:25.282]                           base::stop(msg)
[10:31:25.282]                         }
[10:31:25.282]                       })
[10:31:25.282]                     }
[10:31:25.282]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:25.282]                     base::options(mc.cores = 1L)
[10:31:25.282]                   }
[10:31:25.282]                   ...future.strategy.old <- future::plan("list")
[10:31:25.282]                   options(future.plan = NULL)
[10:31:25.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:25.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:25.282]                 }
[10:31:25.282]                 ...future.workdir <- getwd()
[10:31:25.282]             }
[10:31:25.282]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:25.282]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:25.282]         }
[10:31:25.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:25.282]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:31:25.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:25.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:25.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:25.282]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:25.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:25.282]             base::names(...future.oldOptions))
[10:31:25.282]     }
[10:31:25.282]     if (FALSE) {
[10:31:25.282]     }
[10:31:25.282]     else {
[10:31:25.282]         if (TRUE) {
[10:31:25.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:25.282]                 open = "w")
[10:31:25.282]         }
[10:31:25.282]         else {
[10:31:25.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:25.282]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:25.282]         }
[10:31:25.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:25.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:25.282]             base::sink(type = "output", split = FALSE)
[10:31:25.282]             base::close(...future.stdout)
[10:31:25.282]         }, add = TRUE)
[10:31:25.282]     }
[10:31:25.282]     ...future.frame <- base::sys.nframe()
[10:31:25.282]     ...future.conditions <- base::list()
[10:31:25.282]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:25.282]     if (FALSE) {
[10:31:25.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:25.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:25.282]     }
[10:31:25.282]     ...future.result <- base::tryCatch({
[10:31:25.282]         base::withCallingHandlers({
[10:31:25.282]             ...future.value <- base::withVisible(base::local({
[10:31:25.282]                 ...future.makeSendCondition <- base::local({
[10:31:25.282]                   sendCondition <- NULL
[10:31:25.282]                   function(frame = 1L) {
[10:31:25.282]                     if (is.function(sendCondition)) 
[10:31:25.282]                       return(sendCondition)
[10:31:25.282]                     ns <- getNamespace("parallel")
[10:31:25.282]                     if (exists("sendData", mode = "function", 
[10:31:25.282]                       envir = ns)) {
[10:31:25.282]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:25.282]                         envir = ns)
[10:31:25.282]                       envir <- sys.frame(frame)
[10:31:25.282]                       master <- NULL
[10:31:25.282]                       while (!identical(envir, .GlobalEnv) && 
[10:31:25.282]                         !identical(envir, emptyenv())) {
[10:31:25.282]                         if (exists("master", mode = "list", envir = envir, 
[10:31:25.282]                           inherits = FALSE)) {
[10:31:25.282]                           master <- get("master", mode = "list", 
[10:31:25.282]                             envir = envir, inherits = FALSE)
[10:31:25.282]                           if (inherits(master, c("SOCKnode", 
[10:31:25.282]                             "SOCK0node"))) {
[10:31:25.282]                             sendCondition <<- function(cond) {
[10:31:25.282]                               data <- list(type = "VALUE", value = cond, 
[10:31:25.282]                                 success = TRUE)
[10:31:25.282]                               parallel_sendData(master, data)
[10:31:25.282]                             }
[10:31:25.282]                             return(sendCondition)
[10:31:25.282]                           }
[10:31:25.282]                         }
[10:31:25.282]                         frame <- frame + 1L
[10:31:25.282]                         envir <- sys.frame(frame)
[10:31:25.282]                       }
[10:31:25.282]                     }
[10:31:25.282]                     sendCondition <<- function(cond) NULL
[10:31:25.282]                   }
[10:31:25.282]                 })
[10:31:25.282]                 withCallingHandlers({
[10:31:25.282]                   NA
[10:31:25.282]                 }, immediateCondition = function(cond) {
[10:31:25.282]                   sendCondition <- ...future.makeSendCondition()
[10:31:25.282]                   sendCondition(cond)
[10:31:25.282]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:25.282]                   {
[10:31:25.282]                     inherits <- base::inherits
[10:31:25.282]                     invokeRestart <- base::invokeRestart
[10:31:25.282]                     is.null <- base::is.null
[10:31:25.282]                     muffled <- FALSE
[10:31:25.282]                     if (inherits(cond, "message")) {
[10:31:25.282]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:25.282]                       if (muffled) 
[10:31:25.282]                         invokeRestart("muffleMessage")
[10:31:25.282]                     }
[10:31:25.282]                     else if (inherits(cond, "warning")) {
[10:31:25.282]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:25.282]                       if (muffled) 
[10:31:25.282]                         invokeRestart("muffleWarning")
[10:31:25.282]                     }
[10:31:25.282]                     else if (inherits(cond, "condition")) {
[10:31:25.282]                       if (!is.null(pattern)) {
[10:31:25.282]                         computeRestarts <- base::computeRestarts
[10:31:25.282]                         grepl <- base::grepl
[10:31:25.282]                         restarts <- computeRestarts(cond)
[10:31:25.282]                         for (restart in restarts) {
[10:31:25.282]                           name <- restart$name
[10:31:25.282]                           if (is.null(name)) 
[10:31:25.282]                             next
[10:31:25.282]                           if (!grepl(pattern, name)) 
[10:31:25.282]                             next
[10:31:25.282]                           invokeRestart(restart)
[10:31:25.282]                           muffled <- TRUE
[10:31:25.282]                           break
[10:31:25.282]                         }
[10:31:25.282]                       }
[10:31:25.282]                     }
[10:31:25.282]                     invisible(muffled)
[10:31:25.282]                   }
[10:31:25.282]                   muffleCondition(cond)
[10:31:25.282]                 })
[10:31:25.282]             }))
[10:31:25.282]             future::FutureResult(value = ...future.value$value, 
[10:31:25.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:25.282]                   ...future.rng), globalenv = if (FALSE) 
[10:31:25.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:25.282]                     ...future.globalenv.names))
[10:31:25.282]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:25.282]         }, condition = base::local({
[10:31:25.282]             c <- base::c
[10:31:25.282]             inherits <- base::inherits
[10:31:25.282]             invokeRestart <- base::invokeRestart
[10:31:25.282]             length <- base::length
[10:31:25.282]             list <- base::list
[10:31:25.282]             seq.int <- base::seq.int
[10:31:25.282]             signalCondition <- base::signalCondition
[10:31:25.282]             sys.calls <- base::sys.calls
[10:31:25.282]             `[[` <- base::`[[`
[10:31:25.282]             `+` <- base::`+`
[10:31:25.282]             `<<-` <- base::`<<-`
[10:31:25.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:25.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:25.282]                   3L)]
[10:31:25.282]             }
[10:31:25.282]             function(cond) {
[10:31:25.282]                 is_error <- inherits(cond, "error")
[10:31:25.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:25.282]                   NULL)
[10:31:25.282]                 if (is_error) {
[10:31:25.282]                   sessionInformation <- function() {
[10:31:25.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:25.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:25.282]                       search = base::search(), system = base::Sys.info())
[10:31:25.282]                   }
[10:31:25.282]                   ...future.conditions[[length(...future.conditions) + 
[10:31:25.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:25.282]                     cond$call), session = sessionInformation(), 
[10:31:25.282]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:25.282]                   signalCondition(cond)
[10:31:25.282]                 }
[10:31:25.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:25.282]                 "immediateCondition"))) {
[10:31:25.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:25.282]                   ...future.conditions[[length(...future.conditions) + 
[10:31:25.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:25.282]                   if (TRUE && !signal) {
[10:31:25.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:25.282]                     {
[10:31:25.282]                       inherits <- base::inherits
[10:31:25.282]                       invokeRestart <- base::invokeRestart
[10:31:25.282]                       is.null <- base::is.null
[10:31:25.282]                       muffled <- FALSE
[10:31:25.282]                       if (inherits(cond, "message")) {
[10:31:25.282]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:25.282]                         if (muffled) 
[10:31:25.282]                           invokeRestart("muffleMessage")
[10:31:25.282]                       }
[10:31:25.282]                       else if (inherits(cond, "warning")) {
[10:31:25.282]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:25.282]                         if (muffled) 
[10:31:25.282]                           invokeRestart("muffleWarning")
[10:31:25.282]                       }
[10:31:25.282]                       else if (inherits(cond, "condition")) {
[10:31:25.282]                         if (!is.null(pattern)) {
[10:31:25.282]                           computeRestarts <- base::computeRestarts
[10:31:25.282]                           grepl <- base::grepl
[10:31:25.282]                           restarts <- computeRestarts(cond)
[10:31:25.282]                           for (restart in restarts) {
[10:31:25.282]                             name <- restart$name
[10:31:25.282]                             if (is.null(name)) 
[10:31:25.282]                               next
[10:31:25.282]                             if (!grepl(pattern, name)) 
[10:31:25.282]                               next
[10:31:25.282]                             invokeRestart(restart)
[10:31:25.282]                             muffled <- TRUE
[10:31:25.282]                             break
[10:31:25.282]                           }
[10:31:25.282]                         }
[10:31:25.282]                       }
[10:31:25.282]                       invisible(muffled)
[10:31:25.282]                     }
[10:31:25.282]                     muffleCondition(cond, pattern = "^muffle")
[10:31:25.282]                   }
[10:31:25.282]                 }
[10:31:25.282]                 else {
[10:31:25.282]                   if (TRUE) {
[10:31:25.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:25.282]                     {
[10:31:25.282]                       inherits <- base::inherits
[10:31:25.282]                       invokeRestart <- base::invokeRestart
[10:31:25.282]                       is.null <- base::is.null
[10:31:25.282]                       muffled <- FALSE
[10:31:25.282]                       if (inherits(cond, "message")) {
[10:31:25.282]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:25.282]                         if (muffled) 
[10:31:25.282]                           invokeRestart("muffleMessage")
[10:31:25.282]                       }
[10:31:25.282]                       else if (inherits(cond, "warning")) {
[10:31:25.282]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:25.282]                         if (muffled) 
[10:31:25.282]                           invokeRestart("muffleWarning")
[10:31:25.282]                       }
[10:31:25.282]                       else if (inherits(cond, "condition")) {
[10:31:25.282]                         if (!is.null(pattern)) {
[10:31:25.282]                           computeRestarts <- base::computeRestarts
[10:31:25.282]                           grepl <- base::grepl
[10:31:25.282]                           restarts <- computeRestarts(cond)
[10:31:25.282]                           for (restart in restarts) {
[10:31:25.282]                             name <- restart$name
[10:31:25.282]                             if (is.null(name)) 
[10:31:25.282]                               next
[10:31:25.282]                             if (!grepl(pattern, name)) 
[10:31:25.282]                               next
[10:31:25.282]                             invokeRestart(restart)
[10:31:25.282]                             muffled <- TRUE
[10:31:25.282]                             break
[10:31:25.282]                           }
[10:31:25.282]                         }
[10:31:25.282]                       }
[10:31:25.282]                       invisible(muffled)
[10:31:25.282]                     }
[10:31:25.282]                     muffleCondition(cond, pattern = "^muffle")
[10:31:25.282]                   }
[10:31:25.282]                 }
[10:31:25.282]             }
[10:31:25.282]         }))
[10:31:25.282]     }, error = function(ex) {
[10:31:25.282]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:25.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:25.282]                 ...future.rng), started = ...future.startTime, 
[10:31:25.282]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:25.282]             version = "1.8"), class = "FutureResult")
[10:31:25.282]     }, finally = {
[10:31:25.282]         if (!identical(...future.workdir, getwd())) 
[10:31:25.282]             setwd(...future.workdir)
[10:31:25.282]         {
[10:31:25.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:25.282]                 ...future.oldOptions$nwarnings <- NULL
[10:31:25.282]             }
[10:31:25.282]             base::options(...future.oldOptions)
[10:31:25.282]             if (.Platform$OS.type == "windows") {
[10:31:25.282]                 old_names <- names(...future.oldEnvVars)
[10:31:25.282]                 envs <- base::Sys.getenv()
[10:31:25.282]                 names <- names(envs)
[10:31:25.282]                 common <- intersect(names, old_names)
[10:31:25.282]                 added <- setdiff(names, old_names)
[10:31:25.282]                 removed <- setdiff(old_names, names)
[10:31:25.282]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:25.282]                   envs[common]]
[10:31:25.282]                 NAMES <- toupper(changed)
[10:31:25.282]                 args <- list()
[10:31:25.282]                 for (kk in seq_along(NAMES)) {
[10:31:25.282]                   name <- changed[[kk]]
[10:31:25.282]                   NAME <- NAMES[[kk]]
[10:31:25.282]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:25.282]                     next
[10:31:25.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:25.282]                 }
[10:31:25.282]                 NAMES <- toupper(added)
[10:31:25.282]                 for (kk in seq_along(NAMES)) {
[10:31:25.282]                   name <- added[[kk]]
[10:31:25.282]                   NAME <- NAMES[[kk]]
[10:31:25.282]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:25.282]                     next
[10:31:25.282]                   args[[name]] <- ""
[10:31:25.282]                 }
[10:31:25.282]                 NAMES <- toupper(removed)
[10:31:25.282]                 for (kk in seq_along(NAMES)) {
[10:31:25.282]                   name <- removed[[kk]]
[10:31:25.282]                   NAME <- NAMES[[kk]]
[10:31:25.282]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:25.282]                     next
[10:31:25.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:25.282]                 }
[10:31:25.282]                 if (length(args) > 0) 
[10:31:25.282]                   base::do.call(base::Sys.setenv, args = args)
[10:31:25.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:25.282]             }
[10:31:25.282]             else {
[10:31:25.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:25.282]             }
[10:31:25.282]             {
[10:31:25.282]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:25.282]                   0L) {
[10:31:25.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:25.282]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:25.282]                   base::options(opts)
[10:31:25.282]                 }
[10:31:25.282]                 {
[10:31:25.282]                   {
[10:31:25.282]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:25.282]                     NULL
[10:31:25.282]                   }
[10:31:25.282]                   options(future.plan = NULL)
[10:31:25.282]                   if (is.na(NA_character_)) 
[10:31:25.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:25.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:25.282]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:25.282]                     .init = FALSE)
[10:31:25.282]                 }
[10:31:25.282]             }
[10:31:25.282]         }
[10:31:25.282]     })
[10:31:25.282]     if (TRUE) {
[10:31:25.282]         base::sink(type = "output", split = FALSE)
[10:31:25.282]         if (TRUE) {
[10:31:25.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:25.282]         }
[10:31:25.282]         else {
[10:31:25.282]             ...future.result["stdout"] <- base::list(NULL)
[10:31:25.282]         }
[10:31:25.282]         base::close(...future.stdout)
[10:31:25.282]         ...future.stdout <- NULL
[10:31:25.282]     }
[10:31:25.282]     ...future.result$conditions <- ...future.conditions
[10:31:25.282]     ...future.result$finished <- base::Sys.time()
[10:31:25.282]     ...future.result
[10:31:25.282] }
[10:31:25.336] MultisessionFuture started
[10:31:25.336] result() for ClusterFuture ...
[10:31:25.337] receiveMessageFromWorker() for ClusterFuture ...
[10:31:25.337] - Validating connection of MultisessionFuture
[10:31:25.370] - received message: FutureResult
[10:31:25.371] - Received FutureResult
[10:31:25.371] - Erased future from FutureRegistry
[10:31:25.371] result() for ClusterFuture ...
[10:31:25.371] - result already collected: FutureResult
[10:31:25.371] result() for ClusterFuture ... done
[10:31:25.371] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:25.371] result() for ClusterFuture ... done
[10:31:25.371] result() for ClusterFuture ...
[10:31:25.372] - result already collected: FutureResult
[10:31:25.372] result() for ClusterFuture ... done
[10:31:25.372] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:31:25.376] plan(): nbrOfWorkers() = 2
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 logi(0) 
 int(0) 
 int(0) 
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
[10:31:25.379] future_lapply() ...
[10:31:25.385] Number of chunks: 2
[10:31:25.385] getGlobalsAndPackagesXApply() ...
[10:31:25.385]  - future.globals: TRUE
[10:31:25.386] getGlobalsAndPackages() ...
[10:31:25.386] Searching for globals...
[10:31:25.389] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:25.390] Searching for globals ... DONE
[10:31:25.390] Resolving globals: FALSE
[10:31:25.391] The total size of the 7 globals is 92.00 KiB (94208 bytes)
[10:31:25.391] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.00 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:25.391] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:25.392] - packages: [1] ‘future.apply’
[10:31:25.392] getGlobalsAndPackages() ... DONE
[10:31:25.392]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:25.392]  - needed namespaces: [n=1] ‘future.apply’
[10:31:25.392] Finding globals ... DONE
[10:31:25.392]  - use_args: TRUE
[10:31:25.392]  - Getting '...' globals ...
[10:31:25.393] resolve() on list ...
[10:31:25.393]  recursive: 0
[10:31:25.393]  length: 1
[10:31:25.393]  elements: ‘...’
[10:31:25.393]  length: 0 (resolved future 1)
[10:31:25.393] resolve() on list ... DONE
[10:31:25.393]    - '...' content: [n=0] 
[10:31:25.394] List of 1
[10:31:25.394]  $ ...: list()
[10:31:25.394]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:25.394]  - attr(*, "where")=List of 1
[10:31:25.394]   ..$ ...:<environment: 0x55de86eb3b80> 
[10:31:25.394]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:25.394]  - attr(*, "resolved")= logi TRUE
[10:31:25.394]  - attr(*, "total_size")= num NA
[10:31:25.397]  - Getting '...' globals ... DONE
[10:31:25.397] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:25.397] List of 8
[10:31:25.397]  $ ...future.FUN:function (x, ...)  
[10:31:25.397]  $ x_FUN        :function (x)  
[10:31:25.397]  $ times        : int 1
[10:31:25.397]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:25.397]  $ stop_if_not  :function (...)  
[10:31:25.397]  $ dim          : NULL
[10:31:25.397]  $ valid_types  : chr "character"
[10:31:25.397]  $ ...          : list()
[10:31:25.397]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:25.397]  - attr(*, "where")=List of 8
[10:31:25.397]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:25.397]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:25.397]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:25.397]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:25.397]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:25.397]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:25.397]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:25.397]   ..$ ...          :<environment: 0x55de86eb3b80> 
[10:31:25.397]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:25.397]  - attr(*, "resolved")= logi FALSE
[10:31:25.397]  - attr(*, "total_size")= num 94208
[10:31:25.404] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:25.404] getGlobalsAndPackagesXApply() ... DONE
[10:31:25.404] Number of futures (= number of chunks): 2
[10:31:25.404] Launching 2 futures (chunks) ...
[10:31:25.404] Chunk #1 of 2 ...
[10:31:25.405]  - Finding globals in 'X' for chunk #1 ...
[10:31:25.405] getGlobalsAndPackages() ...
[10:31:25.405] Searching for globals...
[10:31:25.405] 
[10:31:25.405] Searching for globals ... DONE
[10:31:25.405] - globals: [0] <none>
[10:31:25.406] getGlobalsAndPackages() ... DONE
[10:31:25.406]    + additional globals found: [n=0] 
[10:31:25.406]    + additional namespaces needed: [n=0] 
[10:31:25.406]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:25.406]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:25.406]  - seeds: <none>
[10:31:25.406]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:25.406] getGlobalsAndPackages() ...
[10:31:25.406] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:25.407] Resolving globals: FALSE
[10:31:25.407] Tweak future expression to call with '...' arguments ...
[10:31:25.407] {
[10:31:25.407]     do.call(function(...) {
[10:31:25.407]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:25.407]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:25.407]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:25.407]             on.exit(options(oopts), add = TRUE)
[10:31:25.407]         }
[10:31:25.407]         {
[10:31:25.407]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:25.407]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:25.407]                 ...future.FUN(...future.X_jj, ...)
[10:31:25.407]             })
[10:31:25.407]         }
[10:31:25.407]     }, args = future.call.arguments)
[10:31:25.407] }
[10:31:25.407] Tweak future expression to call with '...' arguments ... DONE
[10:31:25.408] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:25.408] - packages: [1] ‘future.apply’
[10:31:25.408] getGlobalsAndPackages() ... DONE
[10:31:25.408] run() for ‘Future’ ...
[10:31:25.409] - state: ‘created’
[10:31:25.409] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:25.424] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:25.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:25.424]   - Field: ‘node’
[10:31:25.424]   - Field: ‘label’
[10:31:25.425]   - Field: ‘local’
[10:31:25.425]   - Field: ‘owner’
[10:31:25.425]   - Field: ‘envir’
[10:31:25.425]   - Field: ‘workers’
[10:31:25.425]   - Field: ‘packages’
[10:31:25.425]   - Field: ‘gc’
[10:31:25.425]   - Field: ‘conditions’
[10:31:25.425]   - Field: ‘persistent’
[10:31:25.425]   - Field: ‘expr’
[10:31:25.426]   - Field: ‘uuid’
[10:31:25.426]   - Field: ‘seed’
[10:31:25.426]   - Field: ‘version’
[10:31:25.426]   - Field: ‘result’
[10:31:25.426]   - Field: ‘asynchronous’
[10:31:25.426]   - Field: ‘calls’
[10:31:25.426]   - Field: ‘globals’
[10:31:25.426]   - Field: ‘stdout’
[10:31:25.426]   - Field: ‘earlySignal’
[10:31:25.427]   - Field: ‘lazy’
[10:31:25.427]   - Field: ‘state’
[10:31:25.427] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:25.427] - Launch lazy future ...
[10:31:25.427] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:25.427] Packages needed by future strategies (n = 0): <none>
[10:31:25.428] {
[10:31:25.428]     {
[10:31:25.428]         {
[10:31:25.428]             ...future.startTime <- base::Sys.time()
[10:31:25.428]             {
[10:31:25.428]                 {
[10:31:25.428]                   {
[10:31:25.428]                     {
[10:31:25.428]                       {
[10:31:25.428]                         base::local({
[10:31:25.428]                           has_future <- base::requireNamespace("future", 
[10:31:25.428]                             quietly = TRUE)
[10:31:25.428]                           if (has_future) {
[10:31:25.428]                             ns <- base::getNamespace("future")
[10:31:25.428]                             version <- ns[[".package"]][["version"]]
[10:31:25.428]                             if (is.null(version)) 
[10:31:25.428]                               version <- utils::packageVersion("future")
[10:31:25.428]                           }
[10:31:25.428]                           else {
[10:31:25.428]                             version <- NULL
[10:31:25.428]                           }
[10:31:25.428]                           if (!has_future || version < "1.8.0") {
[10:31:25.428]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:25.428]                               "", base::R.version$version.string), 
[10:31:25.428]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:25.428]                                 base::R.version$platform, 8 * 
[10:31:25.428]                                   base::.Machine$sizeof.pointer), 
[10:31:25.428]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:25.428]                                 "release", "version")], collapse = " "), 
[10:31:25.428]                               hostname = base::Sys.info()[["nodename"]])
[10:31:25.428]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:25.428]                               info)
[10:31:25.428]                             info <- base::paste(info, collapse = "; ")
[10:31:25.428]                             if (!has_future) {
[10:31:25.428]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:25.428]                                 info)
[10:31:25.428]                             }
[10:31:25.428]                             else {
[10:31:25.428]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:25.428]                                 info, version)
[10:31:25.428]                             }
[10:31:25.428]                             base::stop(msg)
[10:31:25.428]                           }
[10:31:25.428]                         })
[10:31:25.428]                       }
[10:31:25.428]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:25.428]                       base::options(mc.cores = 1L)
[10:31:25.428]                     }
[10:31:25.428]                     base::local({
[10:31:25.428]                       for (pkg in "future.apply") {
[10:31:25.428]                         base::loadNamespace(pkg)
[10:31:25.428]                         base::library(pkg, character.only = TRUE)
[10:31:25.428]                       }
[10:31:25.428]                     })
[10:31:25.428]                   }
[10:31:25.428]                   ...future.strategy.old <- future::plan("list")
[10:31:25.428]                   options(future.plan = NULL)
[10:31:25.428]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:25.428]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:25.428]                 }
[10:31:25.428]                 ...future.workdir <- getwd()
[10:31:25.428]             }
[10:31:25.428]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:25.428]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:25.428]         }
[10:31:25.428]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:25.428]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:25.428]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:25.428]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:25.428]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:25.428]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:25.428]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:25.428]             base::names(...future.oldOptions))
[10:31:25.428]     }
[10:31:25.428]     if (FALSE) {
[10:31:25.428]     }
[10:31:25.428]     else {
[10:31:25.428]         if (TRUE) {
[10:31:25.428]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:25.428]                 open = "w")
[10:31:25.428]         }
[10:31:25.428]         else {
[10:31:25.428]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:25.428]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:25.428]         }
[10:31:25.428]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:25.428]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:25.428]             base::sink(type = "output", split = FALSE)
[10:31:25.428]             base::close(...future.stdout)
[10:31:25.428]         }, add = TRUE)
[10:31:25.428]     }
[10:31:25.428]     ...future.frame <- base::sys.nframe()
[10:31:25.428]     ...future.conditions <- base::list()
[10:31:25.428]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:25.428]     if (FALSE) {
[10:31:25.428]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:25.428]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:25.428]     }
[10:31:25.428]     ...future.result <- base::tryCatch({
[10:31:25.428]         base::withCallingHandlers({
[10:31:25.428]             ...future.value <- base::withVisible(base::local({
[10:31:25.428]                 ...future.makeSendCondition <- base::local({
[10:31:25.428]                   sendCondition <- NULL
[10:31:25.428]                   function(frame = 1L) {
[10:31:25.428]                     if (is.function(sendCondition)) 
[10:31:25.428]                       return(sendCondition)
[10:31:25.428]                     ns <- getNamespace("parallel")
[10:31:25.428]                     if (exists("sendData", mode = "function", 
[10:31:25.428]                       envir = ns)) {
[10:31:25.428]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:25.428]                         envir = ns)
[10:31:25.428]                       envir <- sys.frame(frame)
[10:31:25.428]                       master <- NULL
[10:31:25.428]                       while (!identical(envir, .GlobalEnv) && 
[10:31:25.428]                         !identical(envir, emptyenv())) {
[10:31:25.428]                         if (exists("master", mode = "list", envir = envir, 
[10:31:25.428]                           inherits = FALSE)) {
[10:31:25.428]                           master <- get("master", mode = "list", 
[10:31:25.428]                             envir = envir, inherits = FALSE)
[10:31:25.428]                           if (inherits(master, c("SOCKnode", 
[10:31:25.428]                             "SOCK0node"))) {
[10:31:25.428]                             sendCondition <<- function(cond) {
[10:31:25.428]                               data <- list(type = "VALUE", value = cond, 
[10:31:25.428]                                 success = TRUE)
[10:31:25.428]                               parallel_sendData(master, data)
[10:31:25.428]                             }
[10:31:25.428]                             return(sendCondition)
[10:31:25.428]                           }
[10:31:25.428]                         }
[10:31:25.428]                         frame <- frame + 1L
[10:31:25.428]                         envir <- sys.frame(frame)
[10:31:25.428]                       }
[10:31:25.428]                     }
[10:31:25.428]                     sendCondition <<- function(cond) NULL
[10:31:25.428]                   }
[10:31:25.428]                 })
[10:31:25.428]                 withCallingHandlers({
[10:31:25.428]                   {
[10:31:25.428]                     do.call(function(...) {
[10:31:25.428]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:25.428]                       if (!identical(...future.globals.maxSize.org, 
[10:31:25.428]                         ...future.globals.maxSize)) {
[10:31:25.428]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:25.428]                         on.exit(options(oopts), add = TRUE)
[10:31:25.428]                       }
[10:31:25.428]                       {
[10:31:25.428]                         lapply(seq_along(...future.elements_ii), 
[10:31:25.428]                           FUN = function(jj) {
[10:31:25.428]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:25.428]                             ...future.FUN(...future.X_jj, ...)
[10:31:25.428]                           })
[10:31:25.428]                       }
[10:31:25.428]                     }, args = future.call.arguments)
[10:31:25.428]                   }
[10:31:25.428]                 }, immediateCondition = function(cond) {
[10:31:25.428]                   sendCondition <- ...future.makeSendCondition()
[10:31:25.428]                   sendCondition(cond)
[10:31:25.428]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:25.428]                   {
[10:31:25.428]                     inherits <- base::inherits
[10:31:25.428]                     invokeRestart <- base::invokeRestart
[10:31:25.428]                     is.null <- base::is.null
[10:31:25.428]                     muffled <- FALSE
[10:31:25.428]                     if (inherits(cond, "message")) {
[10:31:25.428]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:25.428]                       if (muffled) 
[10:31:25.428]                         invokeRestart("muffleMessage")
[10:31:25.428]                     }
[10:31:25.428]                     else if (inherits(cond, "warning")) {
[10:31:25.428]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:25.428]                       if (muffled) 
[10:31:25.428]                         invokeRestart("muffleWarning")
[10:31:25.428]                     }
[10:31:25.428]                     else if (inherits(cond, "condition")) {
[10:31:25.428]                       if (!is.null(pattern)) {
[10:31:25.428]                         computeRestarts <- base::computeRestarts
[10:31:25.428]                         grepl <- base::grepl
[10:31:25.428]                         restarts <- computeRestarts(cond)
[10:31:25.428]                         for (restart in restarts) {
[10:31:25.428]                           name <- restart$name
[10:31:25.428]                           if (is.null(name)) 
[10:31:25.428]                             next
[10:31:25.428]                           if (!grepl(pattern, name)) 
[10:31:25.428]                             next
[10:31:25.428]                           invokeRestart(restart)
[10:31:25.428]                           muffled <- TRUE
[10:31:25.428]                           break
[10:31:25.428]                         }
[10:31:25.428]                       }
[10:31:25.428]                     }
[10:31:25.428]                     invisible(muffled)
[10:31:25.428]                   }
[10:31:25.428]                   muffleCondition(cond)
[10:31:25.428]                 })
[10:31:25.428]             }))
[10:31:25.428]             future::FutureResult(value = ...future.value$value, 
[10:31:25.428]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:25.428]                   ...future.rng), globalenv = if (FALSE) 
[10:31:25.428]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:25.428]                     ...future.globalenv.names))
[10:31:25.428]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:25.428]         }, condition = base::local({
[10:31:25.428]             c <- base::c
[10:31:25.428]             inherits <- base::inherits
[10:31:25.428]             invokeRestart <- base::invokeRestart
[10:31:25.428]             length <- base::length
[10:31:25.428]             list <- base::list
[10:31:25.428]             seq.int <- base::seq.int
[10:31:25.428]             signalCondition <- base::signalCondition
[10:31:25.428]             sys.calls <- base::sys.calls
[10:31:25.428]             `[[` <- base::`[[`
[10:31:25.428]             `+` <- base::`+`
[10:31:25.428]             `<<-` <- base::`<<-`
[10:31:25.428]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:25.428]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:25.428]                   3L)]
[10:31:25.428]             }
[10:31:25.428]             function(cond) {
[10:31:25.428]                 is_error <- inherits(cond, "error")
[10:31:25.428]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:25.428]                   NULL)
[10:31:25.428]                 if (is_error) {
[10:31:25.428]                   sessionInformation <- function() {
[10:31:25.428]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:25.428]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:25.428]                       search = base::search(), system = base::Sys.info())
[10:31:25.428]                   }
[10:31:25.428]                   ...future.conditions[[length(...future.conditions) + 
[10:31:25.428]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:25.428]                     cond$call), session = sessionInformation(), 
[10:31:25.428]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:25.428]                   signalCondition(cond)
[10:31:25.428]                 }
[10:31:25.428]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:25.428]                 "immediateCondition"))) {
[10:31:25.428]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:25.428]                   ...future.conditions[[length(...future.conditions) + 
[10:31:25.428]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:25.428]                   if (TRUE && !signal) {
[10:31:25.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:25.428]                     {
[10:31:25.428]                       inherits <- base::inherits
[10:31:25.428]                       invokeRestart <- base::invokeRestart
[10:31:25.428]                       is.null <- base::is.null
[10:31:25.428]                       muffled <- FALSE
[10:31:25.428]                       if (inherits(cond, "message")) {
[10:31:25.428]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:25.428]                         if (muffled) 
[10:31:25.428]                           invokeRestart("muffleMessage")
[10:31:25.428]                       }
[10:31:25.428]                       else if (inherits(cond, "warning")) {
[10:31:25.428]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:25.428]                         if (muffled) 
[10:31:25.428]                           invokeRestart("muffleWarning")
[10:31:25.428]                       }
[10:31:25.428]                       else if (inherits(cond, "condition")) {
[10:31:25.428]                         if (!is.null(pattern)) {
[10:31:25.428]                           computeRestarts <- base::computeRestarts
[10:31:25.428]                           grepl <- base::grepl
[10:31:25.428]                           restarts <- computeRestarts(cond)
[10:31:25.428]                           for (restart in restarts) {
[10:31:25.428]                             name <- restart$name
[10:31:25.428]                             if (is.null(name)) 
[10:31:25.428]                               next
[10:31:25.428]                             if (!grepl(pattern, name)) 
[10:31:25.428]                               next
[10:31:25.428]                             invokeRestart(restart)
[10:31:25.428]                             muffled <- TRUE
[10:31:25.428]                             break
[10:31:25.428]                           }
[10:31:25.428]                         }
[10:31:25.428]                       }
[10:31:25.428]                       invisible(muffled)
[10:31:25.428]                     }
[10:31:25.428]                     muffleCondition(cond, pattern = "^muffle")
[10:31:25.428]                   }
[10:31:25.428]                 }
[10:31:25.428]                 else {
[10:31:25.428]                   if (TRUE) {
[10:31:25.428]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:25.428]                     {
[10:31:25.428]                       inherits <- base::inherits
[10:31:25.428]                       invokeRestart <- base::invokeRestart
[10:31:25.428]                       is.null <- base::is.null
[10:31:25.428]                       muffled <- FALSE
[10:31:25.428]                       if (inherits(cond, "message")) {
[10:31:25.428]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:25.428]                         if (muffled) 
[10:31:25.428]                           invokeRestart("muffleMessage")
[10:31:25.428]                       }
[10:31:25.428]                       else if (inherits(cond, "warning")) {
[10:31:25.428]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:25.428]                         if (muffled) 
[10:31:25.428]                           invokeRestart("muffleWarning")
[10:31:25.428]                       }
[10:31:25.428]                       else if (inherits(cond, "condition")) {
[10:31:25.428]                         if (!is.null(pattern)) {
[10:31:25.428]                           computeRestarts <- base::computeRestarts
[10:31:25.428]                           grepl <- base::grepl
[10:31:25.428]                           restarts <- computeRestarts(cond)
[10:31:25.428]                           for (restart in restarts) {
[10:31:25.428]                             name <- restart$name
[10:31:25.428]                             if (is.null(name)) 
[10:31:25.428]                               next
[10:31:25.428]                             if (!grepl(pattern, name)) 
[10:31:25.428]                               next
[10:31:25.428]                             invokeRestart(restart)
[10:31:25.428]                             muffled <- TRUE
[10:31:25.428]                             break
[10:31:25.428]                           }
[10:31:25.428]                         }
[10:31:25.428]                       }
[10:31:25.428]                       invisible(muffled)
[10:31:25.428]                     }
[10:31:25.428]                     muffleCondition(cond, pattern = "^muffle")
[10:31:25.428]                   }
[10:31:25.428]                 }
[10:31:25.428]             }
[10:31:25.428]         }))
[10:31:25.428]     }, error = function(ex) {
[10:31:25.428]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:25.428]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:25.428]                 ...future.rng), started = ...future.startTime, 
[10:31:25.428]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:25.428]             version = "1.8"), class = "FutureResult")
[10:31:25.428]     }, finally = {
[10:31:25.428]         if (!identical(...future.workdir, getwd())) 
[10:31:25.428]             setwd(...future.workdir)
[10:31:25.428]         {
[10:31:25.428]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:25.428]                 ...future.oldOptions$nwarnings <- NULL
[10:31:25.428]             }
[10:31:25.428]             base::options(...future.oldOptions)
[10:31:25.428]             if (.Platform$OS.type == "windows") {
[10:31:25.428]                 old_names <- names(...future.oldEnvVars)
[10:31:25.428]                 envs <- base::Sys.getenv()
[10:31:25.428]                 names <- names(envs)
[10:31:25.428]                 common <- intersect(names, old_names)
[10:31:25.428]                 added <- setdiff(names, old_names)
[10:31:25.428]                 removed <- setdiff(old_names, names)
[10:31:25.428]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:25.428]                   envs[common]]
[10:31:25.428]                 NAMES <- toupper(changed)
[10:31:25.428]                 args <- list()
[10:31:25.428]                 for (kk in seq_along(NAMES)) {
[10:31:25.428]                   name <- changed[[kk]]
[10:31:25.428]                   NAME <- NAMES[[kk]]
[10:31:25.428]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:25.428]                     next
[10:31:25.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:25.428]                 }
[10:31:25.428]                 NAMES <- toupper(added)
[10:31:25.428]                 for (kk in seq_along(NAMES)) {
[10:31:25.428]                   name <- added[[kk]]
[10:31:25.428]                   NAME <- NAMES[[kk]]
[10:31:25.428]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:25.428]                     next
[10:31:25.428]                   args[[name]] <- ""
[10:31:25.428]                 }
[10:31:25.428]                 NAMES <- toupper(removed)
[10:31:25.428]                 for (kk in seq_along(NAMES)) {
[10:31:25.428]                   name <- removed[[kk]]
[10:31:25.428]                   NAME <- NAMES[[kk]]
[10:31:25.428]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:25.428]                     next
[10:31:25.428]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:25.428]                 }
[10:31:25.428]                 if (length(args) > 0) 
[10:31:25.428]                   base::do.call(base::Sys.setenv, args = args)
[10:31:25.428]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:25.428]             }
[10:31:25.428]             else {
[10:31:25.428]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:25.428]             }
[10:31:25.428]             {
[10:31:25.428]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:25.428]                   0L) {
[10:31:25.428]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:25.428]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:25.428]                   base::options(opts)
[10:31:25.428]                 }
[10:31:25.428]                 {
[10:31:25.428]                   {
[10:31:25.428]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:25.428]                     NULL
[10:31:25.428]                   }
[10:31:25.428]                   options(future.plan = NULL)
[10:31:25.428]                   if (is.na(NA_character_)) 
[10:31:25.428]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:25.428]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:25.428]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:25.428]                     .init = FALSE)
[10:31:25.428]                 }
[10:31:25.428]             }
[10:31:25.428]         }
[10:31:25.428]     })
[10:31:25.428]     if (TRUE) {
[10:31:25.428]         base::sink(type = "output", split = FALSE)
[10:31:25.428]         if (TRUE) {
[10:31:25.428]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:25.428]         }
[10:31:25.428]         else {
[10:31:25.428]             ...future.result["stdout"] <- base::list(NULL)
[10:31:25.428]         }
[10:31:25.428]         base::close(...future.stdout)
[10:31:25.428]         ...future.stdout <- NULL
[10:31:25.428]     }
[10:31:25.428]     ...future.result$conditions <- ...future.conditions
[10:31:25.428]     ...future.result$finished <- base::Sys.time()
[10:31:25.428]     ...future.result
[10:31:25.428] }
[10:31:25.431] Exporting 11 global objects (92.00 KiB) to cluster node #1 ...
[10:31:25.431] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:25.473] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:25.474] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[10:31:25.474] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[10:31:25.474] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:25.475] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:25.475] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:25.517] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:25.517] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:25.561] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:25.561] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:25.562] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:25.562] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ...
[10:31:25.562] Exporting ‘valid_types’ (120 bytes) to cluster node #1 ... DONE
[10:31:25.563] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:25.563] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:25.563] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[10:31:25.564] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[10:31:25.564] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:25.564] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:25.564] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:25.565] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:25.565] Exporting 11 global objects (92.00 KiB) to cluster node #1 ... DONE
[10:31:25.566] MultisessionFuture started
[10:31:25.566] - Launch lazy future ... done
[10:31:25.566] run() for ‘MultisessionFuture’ ... done
[10:31:25.566] Created future:
[10:31:25.566] MultisessionFuture:
[10:31:25.566] Label: ‘future_vapply-1’
[10:31:25.566] Expression:
[10:31:25.566] {
[10:31:25.566]     do.call(function(...) {
[10:31:25.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:25.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:25.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:25.566]             on.exit(options(oopts), add = TRUE)
[10:31:25.566]         }
[10:31:25.566]         {
[10:31:25.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:25.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:25.566]                 ...future.FUN(...future.X_jj, ...)
[10:31:25.566]             })
[10:31:25.566]         }
[10:31:25.566]     }, args = future.call.arguments)
[10:31:25.566] }
[10:31:25.566] Lazy evaluation: FALSE
[10:31:25.566] Asynchronous evaluation: TRUE
[10:31:25.566] Local evaluation: TRUE
[10:31:25.566] Environment: R_GlobalEnv
[10:31:25.566] Capture standard output: TRUE
[10:31:25.566] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:25.566] Globals: 11 objects totaling 92.09 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:25.566] Packages: 1 packages (‘future.apply’)
[10:31:25.566] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:25.566] Resolved: FALSE
[10:31:25.566] Value: <not collected>
[10:31:25.566] Conditions captured: <none>
[10:31:25.566] Early signaling: FALSE
[10:31:25.566] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:25.566] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:25.579] Chunk #1 of 2 ... DONE
[10:31:25.579] Chunk #2 of 2 ...
[10:31:25.579]  - Finding globals in 'X' for chunk #2 ...
[10:31:25.579] getGlobalsAndPackages() ...
[10:31:25.579] Searching for globals...
[10:31:25.580] 
[10:31:25.580] Searching for globals ... DONE
[10:31:25.580] - globals: [0] <none>
[10:31:25.580] getGlobalsAndPackages() ... DONE
[10:31:25.580]    + additional globals found: [n=0] 
[10:31:25.580]    + additional namespaces needed: [n=0] 
[10:31:25.580]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:25.581]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:25.581]  - seeds: <none>
[10:31:25.581]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:25.581] getGlobalsAndPackages() ...
[10:31:25.581] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:25.581] Resolving globals: FALSE
[10:31:25.581] Tweak future expression to call with '...' arguments ...
[10:31:25.582] {
[10:31:25.582]     do.call(function(...) {
[10:31:25.582]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:25.582]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:25.582]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:25.582]             on.exit(options(oopts), add = TRUE)
[10:31:25.582]         }
[10:31:25.582]         {
[10:31:25.582]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:25.582]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:25.582]                 ...future.FUN(...future.X_jj, ...)
[10:31:25.582]             })
[10:31:25.582]         }
[10:31:25.582]     }, args = future.call.arguments)
[10:31:25.582] }
[10:31:25.582] Tweak future expression to call with '...' arguments ... DONE
[10:31:25.582] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:25.583] - packages: [1] ‘future.apply’
[10:31:25.583] getGlobalsAndPackages() ... DONE
[10:31:25.583] run() for ‘Future’ ...
[10:31:25.583] - state: ‘created’
[10:31:25.583] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:25.599] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:25.599] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:25.599]   - Field: ‘node’
[10:31:25.599]   - Field: ‘label’
[10:31:25.599]   - Field: ‘local’
[10:31:25.599]   - Field: ‘owner’
[10:31:25.600]   - Field: ‘envir’
[10:31:25.600]   - Field: ‘workers’
[10:31:25.600]   - Field: ‘packages’
[10:31:25.600]   - Field: ‘gc’
[10:31:25.600]   - Field: ‘conditions’
[10:31:25.600]   - Field: ‘persistent’
[10:31:25.600]   - Field: ‘expr’
[10:31:25.600]   - Field: ‘uuid’
[10:31:25.600]   - Field: ‘seed’
[10:31:25.601]   - Field: ‘version’
[10:31:25.601]   - Field: ‘result’
[10:31:25.601]   - Field: ‘asynchronous’
[10:31:25.601]   - Field: ‘calls’
[10:31:25.601]   - Field: ‘globals’
[10:31:25.601]   - Field: ‘stdout’
[10:31:25.601]   - Field: ‘earlySignal’
[10:31:25.601]   - Field: ‘lazy’
[10:31:25.602]   - Field: ‘state’
[10:31:25.602] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:25.602] - Launch lazy future ...
[10:31:25.602] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:25.602] Packages needed by future strategies (n = 0): <none>
[10:31:25.603] {
[10:31:25.603]     {
[10:31:25.603]         {
[10:31:25.603]             ...future.startTime <- base::Sys.time()
[10:31:25.603]             {
[10:31:25.603]                 {
[10:31:25.603]                   {
[10:31:25.603]                     {
[10:31:25.603]                       {
[10:31:25.603]                         base::local({
[10:31:25.603]                           has_future <- base::requireNamespace("future", 
[10:31:25.603]                             quietly = TRUE)
[10:31:25.603]                           if (has_future) {
[10:31:25.603]                             ns <- base::getNamespace("future")
[10:31:25.603]                             version <- ns[[".package"]][["version"]]
[10:31:25.603]                             if (is.null(version)) 
[10:31:25.603]                               version <- utils::packageVersion("future")
[10:31:25.603]                           }
[10:31:25.603]                           else {
[10:31:25.603]                             version <- NULL
[10:31:25.603]                           }
[10:31:25.603]                           if (!has_future || version < "1.8.0") {
[10:31:25.603]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:25.603]                               "", base::R.version$version.string), 
[10:31:25.603]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:25.603]                                 base::R.version$platform, 8 * 
[10:31:25.603]                                   base::.Machine$sizeof.pointer), 
[10:31:25.603]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:25.603]                                 "release", "version")], collapse = " "), 
[10:31:25.603]                               hostname = base::Sys.info()[["nodename"]])
[10:31:25.603]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:25.603]                               info)
[10:31:25.603]                             info <- base::paste(info, collapse = "; ")
[10:31:25.603]                             if (!has_future) {
[10:31:25.603]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:25.603]                                 info)
[10:31:25.603]                             }
[10:31:25.603]                             else {
[10:31:25.603]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:25.603]                                 info, version)
[10:31:25.603]                             }
[10:31:25.603]                             base::stop(msg)
[10:31:25.603]                           }
[10:31:25.603]                         })
[10:31:25.603]                       }
[10:31:25.603]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:25.603]                       base::options(mc.cores = 1L)
[10:31:25.603]                     }
[10:31:25.603]                     base::local({
[10:31:25.603]                       for (pkg in "future.apply") {
[10:31:25.603]                         base::loadNamespace(pkg)
[10:31:25.603]                         base::library(pkg, character.only = TRUE)
[10:31:25.603]                       }
[10:31:25.603]                     })
[10:31:25.603]                   }
[10:31:25.603]                   ...future.strategy.old <- future::plan("list")
[10:31:25.603]                   options(future.plan = NULL)
[10:31:25.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:25.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:25.603]                 }
[10:31:25.603]                 ...future.workdir <- getwd()
[10:31:25.603]             }
[10:31:25.603]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:25.603]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:25.603]         }
[10:31:25.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:25.603]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:25.603]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:25.603]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:25.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:25.603]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:25.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:25.603]             base::names(...future.oldOptions))
[10:31:25.603]     }
[10:31:25.603]     if (FALSE) {
[10:31:25.603]     }
[10:31:25.603]     else {
[10:31:25.603]         if (TRUE) {
[10:31:25.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:25.603]                 open = "w")
[10:31:25.603]         }
[10:31:25.603]         else {
[10:31:25.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:25.603]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:25.603]         }
[10:31:25.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:25.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:25.603]             base::sink(type = "output", split = FALSE)
[10:31:25.603]             base::close(...future.stdout)
[10:31:25.603]         }, add = TRUE)
[10:31:25.603]     }
[10:31:25.603]     ...future.frame <- base::sys.nframe()
[10:31:25.603]     ...future.conditions <- base::list()
[10:31:25.603]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:25.603]     if (FALSE) {
[10:31:25.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:25.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:25.603]     }
[10:31:25.603]     ...future.result <- base::tryCatch({
[10:31:25.603]         base::withCallingHandlers({
[10:31:25.603]             ...future.value <- base::withVisible(base::local({
[10:31:25.603]                 ...future.makeSendCondition <- base::local({
[10:31:25.603]                   sendCondition <- NULL
[10:31:25.603]                   function(frame = 1L) {
[10:31:25.603]                     if (is.function(sendCondition)) 
[10:31:25.603]                       return(sendCondition)
[10:31:25.603]                     ns <- getNamespace("parallel")
[10:31:25.603]                     if (exists("sendData", mode = "function", 
[10:31:25.603]                       envir = ns)) {
[10:31:25.603]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:25.603]                         envir = ns)
[10:31:25.603]                       envir <- sys.frame(frame)
[10:31:25.603]                       master <- NULL
[10:31:25.603]                       while (!identical(envir, .GlobalEnv) && 
[10:31:25.603]                         !identical(envir, emptyenv())) {
[10:31:25.603]                         if (exists("master", mode = "list", envir = envir, 
[10:31:25.603]                           inherits = FALSE)) {
[10:31:25.603]                           master <- get("master", mode = "list", 
[10:31:25.603]                             envir = envir, inherits = FALSE)
[10:31:25.603]                           if (inherits(master, c("SOCKnode", 
[10:31:25.603]                             "SOCK0node"))) {
[10:31:25.603]                             sendCondition <<- function(cond) {
[10:31:25.603]                               data <- list(type = "VALUE", value = cond, 
[10:31:25.603]                                 success = TRUE)
[10:31:25.603]                               parallel_sendData(master, data)
[10:31:25.603]                             }
[10:31:25.603]                             return(sendCondition)
[10:31:25.603]                           }
[10:31:25.603]                         }
[10:31:25.603]                         frame <- frame + 1L
[10:31:25.603]                         envir <- sys.frame(frame)
[10:31:25.603]                       }
[10:31:25.603]                     }
[10:31:25.603]                     sendCondition <<- function(cond) NULL
[10:31:25.603]                   }
[10:31:25.603]                 })
[10:31:25.603]                 withCallingHandlers({
[10:31:25.603]                   {
[10:31:25.603]                     do.call(function(...) {
[10:31:25.603]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:25.603]                       if (!identical(...future.globals.maxSize.org, 
[10:31:25.603]                         ...future.globals.maxSize)) {
[10:31:25.603]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:25.603]                         on.exit(options(oopts), add = TRUE)
[10:31:25.603]                       }
[10:31:25.603]                       {
[10:31:25.603]                         lapply(seq_along(...future.elements_ii), 
[10:31:25.603]                           FUN = function(jj) {
[10:31:25.603]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:25.603]                             ...future.FUN(...future.X_jj, ...)
[10:31:25.603]                           })
[10:31:25.603]                       }
[10:31:25.603]                     }, args = future.call.arguments)
[10:31:25.603]                   }
[10:31:25.603]                 }, immediateCondition = function(cond) {
[10:31:25.603]                   sendCondition <- ...future.makeSendCondition()
[10:31:25.603]                   sendCondition(cond)
[10:31:25.603]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:25.603]                   {
[10:31:25.603]                     inherits <- base::inherits
[10:31:25.603]                     invokeRestart <- base::invokeRestart
[10:31:25.603]                     is.null <- base::is.null
[10:31:25.603]                     muffled <- FALSE
[10:31:25.603]                     if (inherits(cond, "message")) {
[10:31:25.603]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:25.603]                       if (muffled) 
[10:31:25.603]                         invokeRestart("muffleMessage")
[10:31:25.603]                     }
[10:31:25.603]                     else if (inherits(cond, "warning")) {
[10:31:25.603]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:25.603]                       if (muffled) 
[10:31:25.603]                         invokeRestart("muffleWarning")
[10:31:25.603]                     }
[10:31:25.603]                     else if (inherits(cond, "condition")) {
[10:31:25.603]                       if (!is.null(pattern)) {
[10:31:25.603]                         computeRestarts <- base::computeRestarts
[10:31:25.603]                         grepl <- base::grepl
[10:31:25.603]                         restarts <- computeRestarts(cond)
[10:31:25.603]                         for (restart in restarts) {
[10:31:25.603]                           name <- restart$name
[10:31:25.603]                           if (is.null(name)) 
[10:31:25.603]                             next
[10:31:25.603]                           if (!grepl(pattern, name)) 
[10:31:25.603]                             next
[10:31:25.603]                           invokeRestart(restart)
[10:31:25.603]                           muffled <- TRUE
[10:31:25.603]                           break
[10:31:25.603]                         }
[10:31:25.603]                       }
[10:31:25.603]                     }
[10:31:25.603]                     invisible(muffled)
[10:31:25.603]                   }
[10:31:25.603]                   muffleCondition(cond)
[10:31:25.603]                 })
[10:31:25.603]             }))
[10:31:25.603]             future::FutureResult(value = ...future.value$value, 
[10:31:25.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:25.603]                   ...future.rng), globalenv = if (FALSE) 
[10:31:25.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:25.603]                     ...future.globalenv.names))
[10:31:25.603]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:25.603]         }, condition = base::local({
[10:31:25.603]             c <- base::c
[10:31:25.603]             inherits <- base::inherits
[10:31:25.603]             invokeRestart <- base::invokeRestart
[10:31:25.603]             length <- base::length
[10:31:25.603]             list <- base::list
[10:31:25.603]             seq.int <- base::seq.int
[10:31:25.603]             signalCondition <- base::signalCondition
[10:31:25.603]             sys.calls <- base::sys.calls
[10:31:25.603]             `[[` <- base::`[[`
[10:31:25.603]             `+` <- base::`+`
[10:31:25.603]             `<<-` <- base::`<<-`
[10:31:25.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:25.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:25.603]                   3L)]
[10:31:25.603]             }
[10:31:25.603]             function(cond) {
[10:31:25.603]                 is_error <- inherits(cond, "error")
[10:31:25.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:25.603]                   NULL)
[10:31:25.603]                 if (is_error) {
[10:31:25.603]                   sessionInformation <- function() {
[10:31:25.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:25.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:25.603]                       search = base::search(), system = base::Sys.info())
[10:31:25.603]                   }
[10:31:25.603]                   ...future.conditions[[length(...future.conditions) + 
[10:31:25.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:25.603]                     cond$call), session = sessionInformation(), 
[10:31:25.603]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:25.603]                   signalCondition(cond)
[10:31:25.603]                 }
[10:31:25.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:25.603]                 "immediateCondition"))) {
[10:31:25.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:25.603]                   ...future.conditions[[length(...future.conditions) + 
[10:31:25.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:25.603]                   if (TRUE && !signal) {
[10:31:25.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:25.603]                     {
[10:31:25.603]                       inherits <- base::inherits
[10:31:25.603]                       invokeRestart <- base::invokeRestart
[10:31:25.603]                       is.null <- base::is.null
[10:31:25.603]                       muffled <- FALSE
[10:31:25.603]                       if (inherits(cond, "message")) {
[10:31:25.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:25.603]                         if (muffled) 
[10:31:25.603]                           invokeRestart("muffleMessage")
[10:31:25.603]                       }
[10:31:25.603]                       else if (inherits(cond, "warning")) {
[10:31:25.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:25.603]                         if (muffled) 
[10:31:25.603]                           invokeRestart("muffleWarning")
[10:31:25.603]                       }
[10:31:25.603]                       else if (inherits(cond, "condition")) {
[10:31:25.603]                         if (!is.null(pattern)) {
[10:31:25.603]                           computeRestarts <- base::computeRestarts
[10:31:25.603]                           grepl <- base::grepl
[10:31:25.603]                           restarts <- computeRestarts(cond)
[10:31:25.603]                           for (restart in restarts) {
[10:31:25.603]                             name <- restart$name
[10:31:25.603]                             if (is.null(name)) 
[10:31:25.603]                               next
[10:31:25.603]                             if (!grepl(pattern, name)) 
[10:31:25.603]                               next
[10:31:25.603]                             invokeRestart(restart)
[10:31:25.603]                             muffled <- TRUE
[10:31:25.603]                             break
[10:31:25.603]                           }
[10:31:25.603]                         }
[10:31:25.603]                       }
[10:31:25.603]                       invisible(muffled)
[10:31:25.603]                     }
[10:31:25.603]                     muffleCondition(cond, pattern = "^muffle")
[10:31:25.603]                   }
[10:31:25.603]                 }
[10:31:25.603]                 else {
[10:31:25.603]                   if (TRUE) {
[10:31:25.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:25.603]                     {
[10:31:25.603]                       inherits <- base::inherits
[10:31:25.603]                       invokeRestart <- base::invokeRestart
[10:31:25.603]                       is.null <- base::is.null
[10:31:25.603]                       muffled <- FALSE
[10:31:25.603]                       if (inherits(cond, "message")) {
[10:31:25.603]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:25.603]                         if (muffled) 
[10:31:25.603]                           invokeRestart("muffleMessage")
[10:31:25.603]                       }
[10:31:25.603]                       else if (inherits(cond, "warning")) {
[10:31:25.603]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:25.603]                         if (muffled) 
[10:31:25.603]                           invokeRestart("muffleWarning")
[10:31:25.603]                       }
[10:31:25.603]                       else if (inherits(cond, "condition")) {
[10:31:25.603]                         if (!is.null(pattern)) {
[10:31:25.603]                           computeRestarts <- base::computeRestarts
[10:31:25.603]                           grepl <- base::grepl
[10:31:25.603]                           restarts <- computeRestarts(cond)
[10:31:25.603]                           for (restart in restarts) {
[10:31:25.603]                             name <- restart$name
[10:31:25.603]                             if (is.null(name)) 
[10:31:25.603]                               next
[10:31:25.603]                             if (!grepl(pattern, name)) 
[10:31:25.603]                               next
[10:31:25.603]                             invokeRestart(restart)
[10:31:25.603]                             muffled <- TRUE
[10:31:25.603]                             break
[10:31:25.603]                           }
[10:31:25.603]                         }
[10:31:25.603]                       }
[10:31:25.603]                       invisible(muffled)
[10:31:25.603]                     }
[10:31:25.603]                     muffleCondition(cond, pattern = "^muffle")
[10:31:25.603]                   }
[10:31:25.603]                 }
[10:31:25.603]             }
[10:31:25.603]         }))
[10:31:25.603]     }, error = function(ex) {
[10:31:25.603]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:25.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:25.603]                 ...future.rng), started = ...future.startTime, 
[10:31:25.603]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:25.603]             version = "1.8"), class = "FutureResult")
[10:31:25.603]     }, finally = {
[10:31:25.603]         if (!identical(...future.workdir, getwd())) 
[10:31:25.603]             setwd(...future.workdir)
[10:31:25.603]         {
[10:31:25.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:25.603]                 ...future.oldOptions$nwarnings <- NULL
[10:31:25.603]             }
[10:31:25.603]             base::options(...future.oldOptions)
[10:31:25.603]             if (.Platform$OS.type == "windows") {
[10:31:25.603]                 old_names <- names(...future.oldEnvVars)
[10:31:25.603]                 envs <- base::Sys.getenv()
[10:31:25.603]                 names <- names(envs)
[10:31:25.603]                 common <- intersect(names, old_names)
[10:31:25.603]                 added <- setdiff(names, old_names)
[10:31:25.603]                 removed <- setdiff(old_names, names)
[10:31:25.603]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:25.603]                   envs[common]]
[10:31:25.603]                 NAMES <- toupper(changed)
[10:31:25.603]                 args <- list()
[10:31:25.603]                 for (kk in seq_along(NAMES)) {
[10:31:25.603]                   name <- changed[[kk]]
[10:31:25.603]                   NAME <- NAMES[[kk]]
[10:31:25.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:25.603]                     next
[10:31:25.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:25.603]                 }
[10:31:25.603]                 NAMES <- toupper(added)
[10:31:25.603]                 for (kk in seq_along(NAMES)) {
[10:31:25.603]                   name <- added[[kk]]
[10:31:25.603]                   NAME <- NAMES[[kk]]
[10:31:25.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:25.603]                     next
[10:31:25.603]                   args[[name]] <- ""
[10:31:25.603]                 }
[10:31:25.603]                 NAMES <- toupper(removed)
[10:31:25.603]                 for (kk in seq_along(NAMES)) {
[10:31:25.603]                   name <- removed[[kk]]
[10:31:25.603]                   NAME <- NAMES[[kk]]
[10:31:25.603]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:25.603]                     next
[10:31:25.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:25.603]                 }
[10:31:25.603]                 if (length(args) > 0) 
[10:31:25.603]                   base::do.call(base::Sys.setenv, args = args)
[10:31:25.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:25.603]             }
[10:31:25.603]             else {
[10:31:25.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:25.603]             }
[10:31:25.603]             {
[10:31:25.603]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:25.603]                   0L) {
[10:31:25.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:25.603]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:25.603]                   base::options(opts)
[10:31:25.603]                 }
[10:31:25.603]                 {
[10:31:25.603]                   {
[10:31:25.603]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:25.603]                     NULL
[10:31:25.603]                   }
[10:31:25.603]                   options(future.plan = NULL)
[10:31:25.603]                   if (is.na(NA_character_)) 
[10:31:25.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:25.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:25.603]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:25.603]                     .init = FALSE)
[10:31:25.603]                 }
[10:31:25.603]             }
[10:31:25.603]         }
[10:31:25.603]     })
[10:31:25.603]     if (TRUE) {
[10:31:25.603]         base::sink(type = "output", split = FALSE)
[10:31:25.603]         if (TRUE) {
[10:31:25.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:25.603]         }
[10:31:25.603]         else {
[10:31:25.603]             ...future.result["stdout"] <- base::list(NULL)
[10:31:25.603]         }
[10:31:25.603]         base::close(...future.stdout)
[10:31:25.603]         ...future.stdout <- NULL
[10:31:25.603]     }
[10:31:25.603]     ...future.result$conditions <- ...future.conditions
[10:31:25.603]     ...future.result$finished <- base::Sys.time()
[10:31:25.603]     ...future.result
[10:31:25.603] }
[10:31:25.656] Exporting 11 global objects (92.00 KiB) to cluster node #2 ...
[10:31:25.656] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:31:25.661] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:31:25.661] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[10:31:25.661] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[10:31:25.662] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:31:25.662] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:31:25.662] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:31:25.705] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:31:25.705] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:31:25.749] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:31:25.749] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:31:25.750] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:31:25.750] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ...
[10:31:25.750] Exporting ‘valid_types’ (120 bytes) to cluster node #2 ... DONE
[10:31:25.751] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:31:25.751] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:31:25.751] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ...
[10:31:25.752] Exporting ‘...future.elements_ii’ (736 bytes) to cluster node #2 ... DONE
[10:31:25.752] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:25.752] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:25.752] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:25.755] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:25.755] Exporting 11 global objects (92.00 KiB) to cluster node #2 ... DONE
[10:31:25.756] MultisessionFuture started
[10:31:25.756] - Launch lazy future ... done
[10:31:25.756] run() for ‘MultisessionFuture’ ... done
[10:31:25.756] Created future:
[10:31:25.756] MultisessionFuture:
[10:31:25.756] Label: ‘future_vapply-2’
[10:31:25.756] Expression:
[10:31:25.756] {
[10:31:25.756]     do.call(function(...) {
[10:31:25.756]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:25.756]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:25.756]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:25.756]             on.exit(options(oopts), add = TRUE)
[10:31:25.756]         }
[10:31:25.756]         {
[10:31:25.756]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:25.756]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:25.756]                 ...future.FUN(...future.X_jj, ...)
[10:31:25.756]             })
[10:31:25.756]         }
[10:31:25.756]     }, args = future.call.arguments)
[10:31:25.756] }
[10:31:25.756] Lazy evaluation: FALSE
[10:31:25.756] Asynchronous evaluation: TRUE
[10:31:25.756] Local evaluation: TRUE
[10:31:25.756] Environment: R_GlobalEnv
[10:31:25.756] Capture standard output: TRUE
[10:31:25.756] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:25.756] Globals: 11 objects totaling 92.72 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:25.756] Packages: 1 packages (‘future.apply’)
[10:31:25.756] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:25.756] Resolved: FALSE
[10:31:25.756] Value: <not collected>
[10:31:25.756] Conditions captured: <none>
[10:31:25.756] Early signaling: FALSE
[10:31:25.756] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:25.756] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:25.768] Chunk #2 of 2 ... DONE
[10:31:25.768] Launching 2 futures (chunks) ... DONE
[10:31:25.768] Resolving 2 futures (chunks) ...
[10:31:25.768] resolve() on list ...
[10:31:25.768]  recursive: 0
[10:31:25.768]  length: 2
[10:31:25.768] 
[10:31:25.769] receiveMessageFromWorker() for ClusterFuture ...
[10:31:25.769] - Validating connection of MultisessionFuture
[10:31:25.769] - received message: FutureResult
[10:31:25.769] - Received FutureResult
[10:31:25.769] - Erased future from FutureRegistry
[10:31:25.770] result() for ClusterFuture ...
[10:31:25.770] - result already collected: FutureResult
[10:31:25.770] result() for ClusterFuture ... done
[10:31:25.770] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:25.770] Future #1
[10:31:25.770] result() for ClusterFuture ...
[10:31:25.770] - result already collected: FutureResult
[10:31:25.770] result() for ClusterFuture ... done
[10:31:25.770] result() for ClusterFuture ...
[10:31:25.770] - result already collected: FutureResult
[10:31:25.770] result() for ClusterFuture ... done
[10:31:25.770] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:25.771] - nx: 2
[10:31:25.771] - relay: TRUE
[10:31:25.771] - stdout: TRUE
[10:31:25.771] - signal: TRUE
[10:31:25.771] - resignal: FALSE
[10:31:25.771] - force: TRUE
[10:31:25.771] - relayed: [n=2] FALSE, FALSE
[10:31:25.771] - queued futures: [n=2] FALSE, FALSE
[10:31:25.771]  - until=1
[10:31:25.771]  - relaying element #1
[10:31:25.771] result() for ClusterFuture ...
[10:31:25.772] - result already collected: FutureResult
[10:31:25.772] result() for ClusterFuture ... done
[10:31:25.772] result() for ClusterFuture ...
[10:31:25.772] - result already collected: FutureResult
[10:31:25.772] result() for ClusterFuture ... done
[10:31:25.772] result() for ClusterFuture ...
[10:31:25.772] - result already collected: FutureResult
[10:31:25.772] result() for ClusterFuture ... done
[10:31:25.772] result() for ClusterFuture ...
[10:31:25.772] - result already collected: FutureResult
[10:31:25.772] result() for ClusterFuture ... done
[10:31:25.772] - relayed: [n=2] TRUE, FALSE
[10:31:25.773] - queued futures: [n=2] TRUE, FALSE
[10:31:25.773] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:25.773]  length: 1 (resolved future 1)
[10:31:25.843] receiveMessageFromWorker() for ClusterFuture ...
[10:31:25.843] - Validating connection of MultisessionFuture
[10:31:25.843] - received message: FutureResult
[10:31:25.843] - Received FutureResult
[10:31:25.843] - Erased future from FutureRegistry
[10:31:25.844] result() for ClusterFuture ...
[10:31:25.844] - result already collected: FutureResult
[10:31:25.844] result() for ClusterFuture ... done
[10:31:25.844] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:25.844] Future #2
[10:31:25.844] result() for ClusterFuture ...
[10:31:25.844] - result already collected: FutureResult
[10:31:25.844] result() for ClusterFuture ... done
[10:31:25.844] result() for ClusterFuture ...
[10:31:25.844] - result already collected: FutureResult
[10:31:25.844] result() for ClusterFuture ... done
[10:31:25.845] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:25.845] - nx: 2
[10:31:25.845] - relay: TRUE
[10:31:25.845] - stdout: TRUE
[10:31:25.845] - signal: TRUE
[10:31:25.845] - resignal: FALSE
[10:31:25.845] - force: TRUE
[10:31:25.845] - relayed: [n=2] TRUE, FALSE
[10:31:25.845] - queued futures: [n=2] TRUE, FALSE
[10:31:25.845]  - until=2
[10:31:25.846]  - relaying element #2
[10:31:25.846] result() for ClusterFuture ...
[10:31:25.846] - result already collected: FutureResult
[10:31:25.846] result() for ClusterFuture ... done
[10:31:25.846] result() for ClusterFuture ...
[10:31:25.846] - result already collected: FutureResult
[10:31:25.846] result() for ClusterFuture ... done
[10:31:25.846] result() for ClusterFuture ...
[10:31:25.846] - result already collected: FutureResult
[10:31:25.846] result() for ClusterFuture ... done
[10:31:25.846] result() for ClusterFuture ...
[10:31:25.847] - result already collected: FutureResult
[10:31:25.847] result() for ClusterFuture ... done
[10:31:25.847] - relayed: [n=2] TRUE, TRUE
[10:31:25.847] - queued futures: [n=2] TRUE, TRUE
[10:31:25.847] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:25.847]  length: 0 (resolved future 2)
[10:31:25.847] Relaying remaining futures
[10:31:25.847] signalConditionsASAP(NULL, pos=0) ...
[10:31:25.847] - nx: 2
[10:31:25.847] - relay: TRUE
[10:31:25.847] - stdout: TRUE
[10:31:25.848] - signal: TRUE
[10:31:25.848] - resignal: FALSE
[10:31:25.848] - force: TRUE
[10:31:25.848] - relayed: [n=2] TRUE, TRUE
[10:31:25.848] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:25.848] - relayed: [n=2] TRUE, TRUE
[10:31:25.848] - queued futures: [n=2] TRUE, TRUE
[10:31:25.848] signalConditionsASAP(NULL, pos=0) ... done
[10:31:25.848] resolve() on list ... DONE
[10:31:25.848] result() for ClusterFuture ...
[10:31:25.848] - result already collected: FutureResult
[10:31:25.849] result() for ClusterFuture ... done
[10:31:25.849] result() for ClusterFuture ...
[10:31:25.849] - result already collected: FutureResult
[10:31:25.849] result() for ClusterFuture ... done
[10:31:25.849] result() for ClusterFuture ...
[10:31:25.849] - result already collected: FutureResult
[10:31:25.849] result() for ClusterFuture ... done
[10:31:25.849] result() for ClusterFuture ...
[10:31:25.849] - result already collected: FutureResult
[10:31:25.850] result() for ClusterFuture ... done
[10:31:25.850]  - Number of value chunks collected: 2
[10:31:25.850] Resolving 2 futures (chunks) ... DONE
[10:31:25.850] Reducing values from 2 chunks ...
[10:31:25.850]  - Number of values collected after concatenation: 2
[10:31:25.850]  - Number of values expected: 2
[10:31:25.850] Reducing values from 2 chunks ... DONE
[10:31:25.850] future_lapply() ... DONE
 Named chr [1:2] "integer" "character"
 - attr(*, "names")= chr [1:2] "x" "y"
 num[0 , 1:10] 
[10:31:25.851] future_lapply() ...
[10:31:25.857] Number of chunks: 2
[10:31:25.857] getGlobalsAndPackagesXApply() ...
[10:31:25.857]  - future.globals: TRUE
[10:31:25.857] getGlobalsAndPackages() ...
[10:31:25.858] Searching for globals...
[10:31:25.861] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘double’
[10:31:25.861] Searching for globals ... DONE
[10:31:25.861] Resolving globals: FALSE
[10:31:25.862] The total size of the 7 globals is 93.23 KiB (95472 bytes)
[10:31:25.863] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:25.863] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:25.863] - packages: [1] ‘future.apply’
[10:31:25.863] getGlobalsAndPackages() ... DONE
[10:31:25.863]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:25.863]  - needed namespaces: [n=1] ‘future.apply’
[10:31:25.863] Finding globals ... DONE
[10:31:25.863]  - use_args: TRUE
[10:31:25.863]  - Getting '...' globals ...
[10:31:25.864] resolve() on list ...
[10:31:25.864]  recursive: 0
[10:31:25.864]  length: 1
[10:31:25.864]  elements: ‘...’
[10:31:25.864]  length: 0 (resolved future 1)
[10:31:25.864] resolve() on list ... DONE
[10:31:25.864]    - '...' content: [n=0] 
[10:31:25.864] List of 1
[10:31:25.864]  $ ...: list()
[10:31:25.864]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:25.864]  - attr(*, "where")=List of 1
[10:31:25.864]   ..$ ...:<environment: 0x55de845a7be8> 
[10:31:25.864]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:25.864]  - attr(*, "resolved")= logi TRUE
[10:31:25.864]  - attr(*, "total_size")= num NA
[10:31:25.867]  - Getting '...' globals ... DONE
[10:31:25.867] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:25.867] List of 8
[10:31:25.867]  $ ...future.FUN:function (x, ...)  
[10:31:25.867]  $ x_FUN        :function (x)  
[10:31:25.867]  $ times        : int 0
[10:31:25.867]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:25.867]  $ stop_if_not  :function (...)  
[10:31:25.867]  $ dim          : NULL
[10:31:25.867]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:25.867]  $ ...          : list()
[10:31:25.867]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:25.867]  - attr(*, "where")=List of 8
[10:31:25.867]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:25.867]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:25.867]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:25.867]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:25.867]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:25.867]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:25.867]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:25.867]   ..$ ...          :<environment: 0x55de845a7be8> 
[10:31:25.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:25.867]  - attr(*, "resolved")= logi FALSE
[10:31:25.867]  - attr(*, "total_size")= num 95472
[10:31:25.872] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:25.873] getGlobalsAndPackagesXApply() ... DONE
[10:31:25.873] Number of futures (= number of chunks): 2
[10:31:25.873] Launching 2 futures (chunks) ...
[10:31:25.873] Chunk #1 of 2 ...
[10:31:25.873]  - Finding globals in 'X' for chunk #1 ...
[10:31:25.873] getGlobalsAndPackages() ...
[10:31:25.873] Searching for globals...
[10:31:25.874] 
[10:31:25.874] Searching for globals ... DONE
[10:31:25.874] - globals: [0] <none>
[10:31:25.874] getGlobalsAndPackages() ... DONE
[10:31:25.874]    + additional globals found: [n=0] 
[10:31:25.874]    + additional namespaces needed: [n=0] 
[10:31:25.874]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:25.874]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:25.874]  - seeds: <none>
[10:31:25.874]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:25.875] getGlobalsAndPackages() ...
[10:31:25.875] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:25.875] Resolving globals: FALSE
[10:31:25.875] Tweak future expression to call with '...' arguments ...
[10:31:25.875] {
[10:31:25.875]     do.call(function(...) {
[10:31:25.875]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:25.875]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:25.875]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:25.875]             on.exit(options(oopts), add = TRUE)
[10:31:25.875]         }
[10:31:25.875]         {
[10:31:25.875]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:25.875]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:25.875]                 ...future.FUN(...future.X_jj, ...)
[10:31:25.875]             })
[10:31:25.875]         }
[10:31:25.875]     }, args = future.call.arguments)
[10:31:25.875] }
[10:31:25.875] Tweak future expression to call with '...' arguments ... DONE
[10:31:25.876] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:25.876] - packages: [1] ‘future.apply’
[10:31:25.876] getGlobalsAndPackages() ... DONE
[10:31:25.876] run() for ‘Future’ ...
[10:31:25.876] - state: ‘created’
[10:31:25.876] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:25.891] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:25.891] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:25.891]   - Field: ‘node’
[10:31:25.891]   - Field: ‘label’
[10:31:25.891]   - Field: ‘local’
[10:31:25.891]   - Field: ‘owner’
[10:31:25.891]   - Field: ‘envir’
[10:31:25.892]   - Field: ‘workers’
[10:31:25.892]   - Field: ‘packages’
[10:31:25.892]   - Field: ‘gc’
[10:31:25.892]   - Field: ‘conditions’
[10:31:25.892]   - Field: ‘persistent’
[10:31:25.892]   - Field: ‘expr’
[10:31:25.892]   - Field: ‘uuid’
[10:31:25.892]   - Field: ‘seed’
[10:31:25.892]   - Field: ‘version’
[10:31:25.892]   - Field: ‘result’
[10:31:25.892]   - Field: ‘asynchronous’
[10:31:25.893]   - Field: ‘calls’
[10:31:25.893]   - Field: ‘globals’
[10:31:25.893]   - Field: ‘stdout’
[10:31:25.893]   - Field: ‘earlySignal’
[10:31:25.893]   - Field: ‘lazy’
[10:31:25.893]   - Field: ‘state’
[10:31:25.893] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:25.893] - Launch lazy future ...
[10:31:25.894] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:25.894] Packages needed by future strategies (n = 0): <none>
[10:31:25.894] {
[10:31:25.894]     {
[10:31:25.894]         {
[10:31:25.894]             ...future.startTime <- base::Sys.time()
[10:31:25.894]             {
[10:31:25.894]                 {
[10:31:25.894]                   {
[10:31:25.894]                     {
[10:31:25.894]                       {
[10:31:25.894]                         base::local({
[10:31:25.894]                           has_future <- base::requireNamespace("future", 
[10:31:25.894]                             quietly = TRUE)
[10:31:25.894]                           if (has_future) {
[10:31:25.894]                             ns <- base::getNamespace("future")
[10:31:25.894]                             version <- ns[[".package"]][["version"]]
[10:31:25.894]                             if (is.null(version)) 
[10:31:25.894]                               version <- utils::packageVersion("future")
[10:31:25.894]                           }
[10:31:25.894]                           else {
[10:31:25.894]                             version <- NULL
[10:31:25.894]                           }
[10:31:25.894]                           if (!has_future || version < "1.8.0") {
[10:31:25.894]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:25.894]                               "", base::R.version$version.string), 
[10:31:25.894]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:25.894]                                 base::R.version$platform, 8 * 
[10:31:25.894]                                   base::.Machine$sizeof.pointer), 
[10:31:25.894]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:25.894]                                 "release", "version")], collapse = " "), 
[10:31:25.894]                               hostname = base::Sys.info()[["nodename"]])
[10:31:25.894]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:25.894]                               info)
[10:31:25.894]                             info <- base::paste(info, collapse = "; ")
[10:31:25.894]                             if (!has_future) {
[10:31:25.894]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:25.894]                                 info)
[10:31:25.894]                             }
[10:31:25.894]                             else {
[10:31:25.894]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:25.894]                                 info, version)
[10:31:25.894]                             }
[10:31:25.894]                             base::stop(msg)
[10:31:25.894]                           }
[10:31:25.894]                         })
[10:31:25.894]                       }
[10:31:25.894]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:25.894]                       base::options(mc.cores = 1L)
[10:31:25.894]                     }
[10:31:25.894]                     base::local({
[10:31:25.894]                       for (pkg in "future.apply") {
[10:31:25.894]                         base::loadNamespace(pkg)
[10:31:25.894]                         base::library(pkg, character.only = TRUE)
[10:31:25.894]                       }
[10:31:25.894]                     })
[10:31:25.894]                   }
[10:31:25.894]                   ...future.strategy.old <- future::plan("list")
[10:31:25.894]                   options(future.plan = NULL)
[10:31:25.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:25.894]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:25.894]                 }
[10:31:25.894]                 ...future.workdir <- getwd()
[10:31:25.894]             }
[10:31:25.894]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:25.894]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:25.894]         }
[10:31:25.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:25.894]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:25.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:25.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:25.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:25.894]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:25.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:25.894]             base::names(...future.oldOptions))
[10:31:25.894]     }
[10:31:25.894]     if (FALSE) {
[10:31:25.894]     }
[10:31:25.894]     else {
[10:31:25.894]         if (TRUE) {
[10:31:25.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:25.894]                 open = "w")
[10:31:25.894]         }
[10:31:25.894]         else {
[10:31:25.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:25.894]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:25.894]         }
[10:31:25.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:25.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:25.894]             base::sink(type = "output", split = FALSE)
[10:31:25.894]             base::close(...future.stdout)
[10:31:25.894]         }, add = TRUE)
[10:31:25.894]     }
[10:31:25.894]     ...future.frame <- base::sys.nframe()
[10:31:25.894]     ...future.conditions <- base::list()
[10:31:25.894]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:25.894]     if (FALSE) {
[10:31:25.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:25.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:25.894]     }
[10:31:25.894]     ...future.result <- base::tryCatch({
[10:31:25.894]         base::withCallingHandlers({
[10:31:25.894]             ...future.value <- base::withVisible(base::local({
[10:31:25.894]                 ...future.makeSendCondition <- base::local({
[10:31:25.894]                   sendCondition <- NULL
[10:31:25.894]                   function(frame = 1L) {
[10:31:25.894]                     if (is.function(sendCondition)) 
[10:31:25.894]                       return(sendCondition)
[10:31:25.894]                     ns <- getNamespace("parallel")
[10:31:25.894]                     if (exists("sendData", mode = "function", 
[10:31:25.894]                       envir = ns)) {
[10:31:25.894]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:25.894]                         envir = ns)
[10:31:25.894]                       envir <- sys.frame(frame)
[10:31:25.894]                       master <- NULL
[10:31:25.894]                       while (!identical(envir, .GlobalEnv) && 
[10:31:25.894]                         !identical(envir, emptyenv())) {
[10:31:25.894]                         if (exists("master", mode = "list", envir = envir, 
[10:31:25.894]                           inherits = FALSE)) {
[10:31:25.894]                           master <- get("master", mode = "list", 
[10:31:25.894]                             envir = envir, inherits = FALSE)
[10:31:25.894]                           if (inherits(master, c("SOCKnode", 
[10:31:25.894]                             "SOCK0node"))) {
[10:31:25.894]                             sendCondition <<- function(cond) {
[10:31:25.894]                               data <- list(type = "VALUE", value = cond, 
[10:31:25.894]                                 success = TRUE)
[10:31:25.894]                               parallel_sendData(master, data)
[10:31:25.894]                             }
[10:31:25.894]                             return(sendCondition)
[10:31:25.894]                           }
[10:31:25.894]                         }
[10:31:25.894]                         frame <- frame + 1L
[10:31:25.894]                         envir <- sys.frame(frame)
[10:31:25.894]                       }
[10:31:25.894]                     }
[10:31:25.894]                     sendCondition <<- function(cond) NULL
[10:31:25.894]                   }
[10:31:25.894]                 })
[10:31:25.894]                 withCallingHandlers({
[10:31:25.894]                   {
[10:31:25.894]                     do.call(function(...) {
[10:31:25.894]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:25.894]                       if (!identical(...future.globals.maxSize.org, 
[10:31:25.894]                         ...future.globals.maxSize)) {
[10:31:25.894]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:25.894]                         on.exit(options(oopts), add = TRUE)
[10:31:25.894]                       }
[10:31:25.894]                       {
[10:31:25.894]                         lapply(seq_along(...future.elements_ii), 
[10:31:25.894]                           FUN = function(jj) {
[10:31:25.894]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:25.894]                             ...future.FUN(...future.X_jj, ...)
[10:31:25.894]                           })
[10:31:25.894]                       }
[10:31:25.894]                     }, args = future.call.arguments)
[10:31:25.894]                   }
[10:31:25.894]                 }, immediateCondition = function(cond) {
[10:31:25.894]                   sendCondition <- ...future.makeSendCondition()
[10:31:25.894]                   sendCondition(cond)
[10:31:25.894]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:25.894]                   {
[10:31:25.894]                     inherits <- base::inherits
[10:31:25.894]                     invokeRestart <- base::invokeRestart
[10:31:25.894]                     is.null <- base::is.null
[10:31:25.894]                     muffled <- FALSE
[10:31:25.894]                     if (inherits(cond, "message")) {
[10:31:25.894]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:25.894]                       if (muffled) 
[10:31:25.894]                         invokeRestart("muffleMessage")
[10:31:25.894]                     }
[10:31:25.894]                     else if (inherits(cond, "warning")) {
[10:31:25.894]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:25.894]                       if (muffled) 
[10:31:25.894]                         invokeRestart("muffleWarning")
[10:31:25.894]                     }
[10:31:25.894]                     else if (inherits(cond, "condition")) {
[10:31:25.894]                       if (!is.null(pattern)) {
[10:31:25.894]                         computeRestarts <- base::computeRestarts
[10:31:25.894]                         grepl <- base::grepl
[10:31:25.894]                         restarts <- computeRestarts(cond)
[10:31:25.894]                         for (restart in restarts) {
[10:31:25.894]                           name <- restart$name
[10:31:25.894]                           if (is.null(name)) 
[10:31:25.894]                             next
[10:31:25.894]                           if (!grepl(pattern, name)) 
[10:31:25.894]                             next
[10:31:25.894]                           invokeRestart(restart)
[10:31:25.894]                           muffled <- TRUE
[10:31:25.894]                           break
[10:31:25.894]                         }
[10:31:25.894]                       }
[10:31:25.894]                     }
[10:31:25.894]                     invisible(muffled)
[10:31:25.894]                   }
[10:31:25.894]                   muffleCondition(cond)
[10:31:25.894]                 })
[10:31:25.894]             }))
[10:31:25.894]             future::FutureResult(value = ...future.value$value, 
[10:31:25.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:25.894]                   ...future.rng), globalenv = if (FALSE) 
[10:31:25.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:25.894]                     ...future.globalenv.names))
[10:31:25.894]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:25.894]         }, condition = base::local({
[10:31:25.894]             c <- base::c
[10:31:25.894]             inherits <- base::inherits
[10:31:25.894]             invokeRestart <- base::invokeRestart
[10:31:25.894]             length <- base::length
[10:31:25.894]             list <- base::list
[10:31:25.894]             seq.int <- base::seq.int
[10:31:25.894]             signalCondition <- base::signalCondition
[10:31:25.894]             sys.calls <- base::sys.calls
[10:31:25.894]             `[[` <- base::`[[`
[10:31:25.894]             `+` <- base::`+`
[10:31:25.894]             `<<-` <- base::`<<-`
[10:31:25.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:25.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:25.894]                   3L)]
[10:31:25.894]             }
[10:31:25.894]             function(cond) {
[10:31:25.894]                 is_error <- inherits(cond, "error")
[10:31:25.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:25.894]                   NULL)
[10:31:25.894]                 if (is_error) {
[10:31:25.894]                   sessionInformation <- function() {
[10:31:25.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:25.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:25.894]                       search = base::search(), system = base::Sys.info())
[10:31:25.894]                   }
[10:31:25.894]                   ...future.conditions[[length(...future.conditions) + 
[10:31:25.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:25.894]                     cond$call), session = sessionInformation(), 
[10:31:25.894]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:25.894]                   signalCondition(cond)
[10:31:25.894]                 }
[10:31:25.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:25.894]                 "immediateCondition"))) {
[10:31:25.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:25.894]                   ...future.conditions[[length(...future.conditions) + 
[10:31:25.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:25.894]                   if (TRUE && !signal) {
[10:31:25.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:25.894]                     {
[10:31:25.894]                       inherits <- base::inherits
[10:31:25.894]                       invokeRestart <- base::invokeRestart
[10:31:25.894]                       is.null <- base::is.null
[10:31:25.894]                       muffled <- FALSE
[10:31:25.894]                       if (inherits(cond, "message")) {
[10:31:25.894]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:25.894]                         if (muffled) 
[10:31:25.894]                           invokeRestart("muffleMessage")
[10:31:25.894]                       }
[10:31:25.894]                       else if (inherits(cond, "warning")) {
[10:31:25.894]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:25.894]                         if (muffled) 
[10:31:25.894]                           invokeRestart("muffleWarning")
[10:31:25.894]                       }
[10:31:25.894]                       else if (inherits(cond, "condition")) {
[10:31:25.894]                         if (!is.null(pattern)) {
[10:31:25.894]                           computeRestarts <- base::computeRestarts
[10:31:25.894]                           grepl <- base::grepl
[10:31:25.894]                           restarts <- computeRestarts(cond)
[10:31:25.894]                           for (restart in restarts) {
[10:31:25.894]                             name <- restart$name
[10:31:25.894]                             if (is.null(name)) 
[10:31:25.894]                               next
[10:31:25.894]                             if (!grepl(pattern, name)) 
[10:31:25.894]                               next
[10:31:25.894]                             invokeRestart(restart)
[10:31:25.894]                             muffled <- TRUE
[10:31:25.894]                             break
[10:31:25.894]                           }
[10:31:25.894]                         }
[10:31:25.894]                       }
[10:31:25.894]                       invisible(muffled)
[10:31:25.894]                     }
[10:31:25.894]                     muffleCondition(cond, pattern = "^muffle")
[10:31:25.894]                   }
[10:31:25.894]                 }
[10:31:25.894]                 else {
[10:31:25.894]                   if (TRUE) {
[10:31:25.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:25.894]                     {
[10:31:25.894]                       inherits <- base::inherits
[10:31:25.894]                       invokeRestart <- base::invokeRestart
[10:31:25.894]                       is.null <- base::is.null
[10:31:25.894]                       muffled <- FALSE
[10:31:25.894]                       if (inherits(cond, "message")) {
[10:31:25.894]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:25.894]                         if (muffled) 
[10:31:25.894]                           invokeRestart("muffleMessage")
[10:31:25.894]                       }
[10:31:25.894]                       else if (inherits(cond, "warning")) {
[10:31:25.894]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:25.894]                         if (muffled) 
[10:31:25.894]                           invokeRestart("muffleWarning")
[10:31:25.894]                       }
[10:31:25.894]                       else if (inherits(cond, "condition")) {
[10:31:25.894]                         if (!is.null(pattern)) {
[10:31:25.894]                           computeRestarts <- base::computeRestarts
[10:31:25.894]                           grepl <- base::grepl
[10:31:25.894]                           restarts <- computeRestarts(cond)
[10:31:25.894]                           for (restart in restarts) {
[10:31:25.894]                             name <- restart$name
[10:31:25.894]                             if (is.null(name)) 
[10:31:25.894]                               next
[10:31:25.894]                             if (!grepl(pattern, name)) 
[10:31:25.894]                               next
[10:31:25.894]                             invokeRestart(restart)
[10:31:25.894]                             muffled <- TRUE
[10:31:25.894]                             break
[10:31:25.894]                           }
[10:31:25.894]                         }
[10:31:25.894]                       }
[10:31:25.894]                       invisible(muffled)
[10:31:25.894]                     }
[10:31:25.894]                     muffleCondition(cond, pattern = "^muffle")
[10:31:25.894]                   }
[10:31:25.894]                 }
[10:31:25.894]             }
[10:31:25.894]         }))
[10:31:25.894]     }, error = function(ex) {
[10:31:25.894]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:25.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:25.894]                 ...future.rng), started = ...future.startTime, 
[10:31:25.894]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:25.894]             version = "1.8"), class = "FutureResult")
[10:31:25.894]     }, finally = {
[10:31:25.894]         if (!identical(...future.workdir, getwd())) 
[10:31:25.894]             setwd(...future.workdir)
[10:31:25.894]         {
[10:31:25.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:25.894]                 ...future.oldOptions$nwarnings <- NULL
[10:31:25.894]             }
[10:31:25.894]             base::options(...future.oldOptions)
[10:31:25.894]             if (.Platform$OS.type == "windows") {
[10:31:25.894]                 old_names <- names(...future.oldEnvVars)
[10:31:25.894]                 envs <- base::Sys.getenv()
[10:31:25.894]                 names <- names(envs)
[10:31:25.894]                 common <- intersect(names, old_names)
[10:31:25.894]                 added <- setdiff(names, old_names)
[10:31:25.894]                 removed <- setdiff(old_names, names)
[10:31:25.894]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:25.894]                   envs[common]]
[10:31:25.894]                 NAMES <- toupper(changed)
[10:31:25.894]                 args <- list()
[10:31:25.894]                 for (kk in seq_along(NAMES)) {
[10:31:25.894]                   name <- changed[[kk]]
[10:31:25.894]                   NAME <- NAMES[[kk]]
[10:31:25.894]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:25.894]                     next
[10:31:25.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:25.894]                 }
[10:31:25.894]                 NAMES <- toupper(added)
[10:31:25.894]                 for (kk in seq_along(NAMES)) {
[10:31:25.894]                   name <- added[[kk]]
[10:31:25.894]                   NAME <- NAMES[[kk]]
[10:31:25.894]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:25.894]                     next
[10:31:25.894]                   args[[name]] <- ""
[10:31:25.894]                 }
[10:31:25.894]                 NAMES <- toupper(removed)
[10:31:25.894]                 for (kk in seq_along(NAMES)) {
[10:31:25.894]                   name <- removed[[kk]]
[10:31:25.894]                   NAME <- NAMES[[kk]]
[10:31:25.894]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:25.894]                     next
[10:31:25.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:25.894]                 }
[10:31:25.894]                 if (length(args) > 0) 
[10:31:25.894]                   base::do.call(base::Sys.setenv, args = args)
[10:31:25.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:25.894]             }
[10:31:25.894]             else {
[10:31:25.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:25.894]             }
[10:31:25.894]             {
[10:31:25.894]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:25.894]                   0L) {
[10:31:25.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:25.894]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:25.894]                   base::options(opts)
[10:31:25.894]                 }
[10:31:25.894]                 {
[10:31:25.894]                   {
[10:31:25.894]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:25.894]                     NULL
[10:31:25.894]                   }
[10:31:25.894]                   options(future.plan = NULL)
[10:31:25.894]                   if (is.na(NA_character_)) 
[10:31:25.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:25.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:25.894]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:25.894]                     .init = FALSE)
[10:31:25.894]                 }
[10:31:25.894]             }
[10:31:25.894]         }
[10:31:25.894]     })
[10:31:25.894]     if (TRUE) {
[10:31:25.894]         base::sink(type = "output", split = FALSE)
[10:31:25.894]         if (TRUE) {
[10:31:25.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:25.894]         }
[10:31:25.894]         else {
[10:31:25.894]             ...future.result["stdout"] <- base::list(NULL)
[10:31:25.894]         }
[10:31:25.894]         base::close(...future.stdout)
[10:31:25.894]         ...future.stdout <- NULL
[10:31:25.894]     }
[10:31:25.894]     ...future.result$conditions <- ...future.conditions
[10:31:25.894]     ...future.result$finished <- base::Sys.time()
[10:31:25.894]     ...future.result
[10:31:25.894] }
[10:31:25.897] Exporting 11 global objects (93.23 KiB) to cluster node #1 ...
[10:31:25.897] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:25.941] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:25.941] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[10:31:25.942] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[10:31:25.942] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:25.942] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:25.943] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:25.985] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:25.985] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:26.029] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:26.029] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:26.030] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:26.030] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:31:26.030] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:31:26.030] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:26.031] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:26.031] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:31:26.031] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:31:26.031] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:26.032] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:26.032] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:26.032] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:26.032] Exporting 11 global objects (93.23 KiB) to cluster node #1 ... DONE
[10:31:26.033] MultisessionFuture started
[10:31:26.033] - Launch lazy future ... done
[10:31:26.033] run() for ‘MultisessionFuture’ ... done
[10:31:26.034] Created future:
[10:31:26.034] MultisessionFuture:
[10:31:26.034] Label: ‘future_vapply-1’
[10:31:26.034] Expression:
[10:31:26.034] {
[10:31:26.034]     do.call(function(...) {
[10:31:26.034]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.034]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:26.034]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.034]             on.exit(options(oopts), add = TRUE)
[10:31:26.034]         }
[10:31:26.034]         {
[10:31:26.034]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:26.034]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.034]                 ...future.FUN(...future.X_jj, ...)
[10:31:26.034]             })
[10:31:26.034]         }
[10:31:26.034]     }, args = future.call.arguments)
[10:31:26.034] }
[10:31:26.034] Lazy evaluation: FALSE
[10:31:26.034] Asynchronous evaluation: TRUE
[10:31:26.034] Local evaluation: TRUE
[10:31:26.034] Environment: R_GlobalEnv
[10:31:26.034] Capture standard output: TRUE
[10:31:26.034] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:26.034] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:26.034] Packages: 1 packages (‘future.apply’)
[10:31:26.034] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:26.034] Resolved: FALSE
[10:31:26.034] Value: <not collected>
[10:31:26.034] Conditions captured: <none>
[10:31:26.034] Early signaling: FALSE
[10:31:26.034] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:26.034] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:26.045] Chunk #1 of 2 ... DONE
[10:31:26.046] Chunk #2 of 2 ...
[10:31:26.046]  - Finding globals in 'X' for chunk #2 ...
[10:31:26.046] getGlobalsAndPackages() ...
[10:31:26.046] Searching for globals...
[10:31:26.046] 
[10:31:26.046] Searching for globals ... DONE
[10:31:26.046] - globals: [0] <none>
[10:31:26.047] getGlobalsAndPackages() ... DONE
[10:31:26.047]    + additional globals found: [n=0] 
[10:31:26.047]    + additional namespaces needed: [n=0] 
[10:31:26.047]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:26.047]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:26.047]  - seeds: <none>
[10:31:26.047]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.047] getGlobalsAndPackages() ...
[10:31:26.047] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.047] Resolving globals: FALSE
[10:31:26.048] Tweak future expression to call with '...' arguments ...
[10:31:26.048] {
[10:31:26.048]     do.call(function(...) {
[10:31:26.048]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.048]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:26.048]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.048]             on.exit(options(oopts), add = TRUE)
[10:31:26.048]         }
[10:31:26.048]         {
[10:31:26.048]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:26.048]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.048]                 ...future.FUN(...future.X_jj, ...)
[10:31:26.048]             })
[10:31:26.048]         }
[10:31:26.048]     }, args = future.call.arguments)
[10:31:26.048] }
[10:31:26.048] Tweak future expression to call with '...' arguments ... DONE
[10:31:26.048] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.049] - packages: [1] ‘future.apply’
[10:31:26.049] getGlobalsAndPackages() ... DONE
[10:31:26.049] run() for ‘Future’ ...
[10:31:26.049] - state: ‘created’
[10:31:26.049] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:26.063] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:26.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:26.064]   - Field: ‘node’
[10:31:26.064]   - Field: ‘label’
[10:31:26.064]   - Field: ‘local’
[10:31:26.064]   - Field: ‘owner’
[10:31:26.064]   - Field: ‘envir’
[10:31:26.064]   - Field: ‘workers’
[10:31:26.064]   - Field: ‘packages’
[10:31:26.064]   - Field: ‘gc’
[10:31:26.064]   - Field: ‘conditions’
[10:31:26.064]   - Field: ‘persistent’
[10:31:26.064]   - Field: ‘expr’
[10:31:26.065]   - Field: ‘uuid’
[10:31:26.065]   - Field: ‘seed’
[10:31:26.065]   - Field: ‘version’
[10:31:26.065]   - Field: ‘result’
[10:31:26.065]   - Field: ‘asynchronous’
[10:31:26.065]   - Field: ‘calls’
[10:31:26.065]   - Field: ‘globals’
[10:31:26.065]   - Field: ‘stdout’
[10:31:26.065]   - Field: ‘earlySignal’
[10:31:26.065]   - Field: ‘lazy’
[10:31:26.066]   - Field: ‘state’
[10:31:26.066] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:26.066] - Launch lazy future ...
[10:31:26.066] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:26.066] Packages needed by future strategies (n = 0): <none>
[10:31:26.067] {
[10:31:26.067]     {
[10:31:26.067]         {
[10:31:26.067]             ...future.startTime <- base::Sys.time()
[10:31:26.067]             {
[10:31:26.067]                 {
[10:31:26.067]                   {
[10:31:26.067]                     {
[10:31:26.067]                       {
[10:31:26.067]                         base::local({
[10:31:26.067]                           has_future <- base::requireNamespace("future", 
[10:31:26.067]                             quietly = TRUE)
[10:31:26.067]                           if (has_future) {
[10:31:26.067]                             ns <- base::getNamespace("future")
[10:31:26.067]                             version <- ns[[".package"]][["version"]]
[10:31:26.067]                             if (is.null(version)) 
[10:31:26.067]                               version <- utils::packageVersion("future")
[10:31:26.067]                           }
[10:31:26.067]                           else {
[10:31:26.067]                             version <- NULL
[10:31:26.067]                           }
[10:31:26.067]                           if (!has_future || version < "1.8.0") {
[10:31:26.067]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:26.067]                               "", base::R.version$version.string), 
[10:31:26.067]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:26.067]                                 base::R.version$platform, 8 * 
[10:31:26.067]                                   base::.Machine$sizeof.pointer), 
[10:31:26.067]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:26.067]                                 "release", "version")], collapse = " "), 
[10:31:26.067]                               hostname = base::Sys.info()[["nodename"]])
[10:31:26.067]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:26.067]                               info)
[10:31:26.067]                             info <- base::paste(info, collapse = "; ")
[10:31:26.067]                             if (!has_future) {
[10:31:26.067]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:26.067]                                 info)
[10:31:26.067]                             }
[10:31:26.067]                             else {
[10:31:26.067]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:26.067]                                 info, version)
[10:31:26.067]                             }
[10:31:26.067]                             base::stop(msg)
[10:31:26.067]                           }
[10:31:26.067]                         })
[10:31:26.067]                       }
[10:31:26.067]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:26.067]                       base::options(mc.cores = 1L)
[10:31:26.067]                     }
[10:31:26.067]                     base::local({
[10:31:26.067]                       for (pkg in "future.apply") {
[10:31:26.067]                         base::loadNamespace(pkg)
[10:31:26.067]                         base::library(pkg, character.only = TRUE)
[10:31:26.067]                       }
[10:31:26.067]                     })
[10:31:26.067]                   }
[10:31:26.067]                   ...future.strategy.old <- future::plan("list")
[10:31:26.067]                   options(future.plan = NULL)
[10:31:26.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:26.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:26.067]                 }
[10:31:26.067]                 ...future.workdir <- getwd()
[10:31:26.067]             }
[10:31:26.067]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:26.067]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:26.067]         }
[10:31:26.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:26.067]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:26.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:26.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:26.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:26.067]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:26.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:26.067]             base::names(...future.oldOptions))
[10:31:26.067]     }
[10:31:26.067]     if (FALSE) {
[10:31:26.067]     }
[10:31:26.067]     else {
[10:31:26.067]         if (TRUE) {
[10:31:26.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:26.067]                 open = "w")
[10:31:26.067]         }
[10:31:26.067]         else {
[10:31:26.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:26.067]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:26.067]         }
[10:31:26.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:26.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:26.067]             base::sink(type = "output", split = FALSE)
[10:31:26.067]             base::close(...future.stdout)
[10:31:26.067]         }, add = TRUE)
[10:31:26.067]     }
[10:31:26.067]     ...future.frame <- base::sys.nframe()
[10:31:26.067]     ...future.conditions <- base::list()
[10:31:26.067]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:26.067]     if (FALSE) {
[10:31:26.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:26.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:26.067]     }
[10:31:26.067]     ...future.result <- base::tryCatch({
[10:31:26.067]         base::withCallingHandlers({
[10:31:26.067]             ...future.value <- base::withVisible(base::local({
[10:31:26.067]                 ...future.makeSendCondition <- base::local({
[10:31:26.067]                   sendCondition <- NULL
[10:31:26.067]                   function(frame = 1L) {
[10:31:26.067]                     if (is.function(sendCondition)) 
[10:31:26.067]                       return(sendCondition)
[10:31:26.067]                     ns <- getNamespace("parallel")
[10:31:26.067]                     if (exists("sendData", mode = "function", 
[10:31:26.067]                       envir = ns)) {
[10:31:26.067]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:26.067]                         envir = ns)
[10:31:26.067]                       envir <- sys.frame(frame)
[10:31:26.067]                       master <- NULL
[10:31:26.067]                       while (!identical(envir, .GlobalEnv) && 
[10:31:26.067]                         !identical(envir, emptyenv())) {
[10:31:26.067]                         if (exists("master", mode = "list", envir = envir, 
[10:31:26.067]                           inherits = FALSE)) {
[10:31:26.067]                           master <- get("master", mode = "list", 
[10:31:26.067]                             envir = envir, inherits = FALSE)
[10:31:26.067]                           if (inherits(master, c("SOCKnode", 
[10:31:26.067]                             "SOCK0node"))) {
[10:31:26.067]                             sendCondition <<- function(cond) {
[10:31:26.067]                               data <- list(type = "VALUE", value = cond, 
[10:31:26.067]                                 success = TRUE)
[10:31:26.067]                               parallel_sendData(master, data)
[10:31:26.067]                             }
[10:31:26.067]                             return(sendCondition)
[10:31:26.067]                           }
[10:31:26.067]                         }
[10:31:26.067]                         frame <- frame + 1L
[10:31:26.067]                         envir <- sys.frame(frame)
[10:31:26.067]                       }
[10:31:26.067]                     }
[10:31:26.067]                     sendCondition <<- function(cond) NULL
[10:31:26.067]                   }
[10:31:26.067]                 })
[10:31:26.067]                 withCallingHandlers({
[10:31:26.067]                   {
[10:31:26.067]                     do.call(function(...) {
[10:31:26.067]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.067]                       if (!identical(...future.globals.maxSize.org, 
[10:31:26.067]                         ...future.globals.maxSize)) {
[10:31:26.067]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.067]                         on.exit(options(oopts), add = TRUE)
[10:31:26.067]                       }
[10:31:26.067]                       {
[10:31:26.067]                         lapply(seq_along(...future.elements_ii), 
[10:31:26.067]                           FUN = function(jj) {
[10:31:26.067]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.067]                             ...future.FUN(...future.X_jj, ...)
[10:31:26.067]                           })
[10:31:26.067]                       }
[10:31:26.067]                     }, args = future.call.arguments)
[10:31:26.067]                   }
[10:31:26.067]                 }, immediateCondition = function(cond) {
[10:31:26.067]                   sendCondition <- ...future.makeSendCondition()
[10:31:26.067]                   sendCondition(cond)
[10:31:26.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.067]                   {
[10:31:26.067]                     inherits <- base::inherits
[10:31:26.067]                     invokeRestart <- base::invokeRestart
[10:31:26.067]                     is.null <- base::is.null
[10:31:26.067]                     muffled <- FALSE
[10:31:26.067]                     if (inherits(cond, "message")) {
[10:31:26.067]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:26.067]                       if (muffled) 
[10:31:26.067]                         invokeRestart("muffleMessage")
[10:31:26.067]                     }
[10:31:26.067]                     else if (inherits(cond, "warning")) {
[10:31:26.067]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:26.067]                       if (muffled) 
[10:31:26.067]                         invokeRestart("muffleWarning")
[10:31:26.067]                     }
[10:31:26.067]                     else if (inherits(cond, "condition")) {
[10:31:26.067]                       if (!is.null(pattern)) {
[10:31:26.067]                         computeRestarts <- base::computeRestarts
[10:31:26.067]                         grepl <- base::grepl
[10:31:26.067]                         restarts <- computeRestarts(cond)
[10:31:26.067]                         for (restart in restarts) {
[10:31:26.067]                           name <- restart$name
[10:31:26.067]                           if (is.null(name)) 
[10:31:26.067]                             next
[10:31:26.067]                           if (!grepl(pattern, name)) 
[10:31:26.067]                             next
[10:31:26.067]                           invokeRestart(restart)
[10:31:26.067]                           muffled <- TRUE
[10:31:26.067]                           break
[10:31:26.067]                         }
[10:31:26.067]                       }
[10:31:26.067]                     }
[10:31:26.067]                     invisible(muffled)
[10:31:26.067]                   }
[10:31:26.067]                   muffleCondition(cond)
[10:31:26.067]                 })
[10:31:26.067]             }))
[10:31:26.067]             future::FutureResult(value = ...future.value$value, 
[10:31:26.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:26.067]                   ...future.rng), globalenv = if (FALSE) 
[10:31:26.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:26.067]                     ...future.globalenv.names))
[10:31:26.067]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:26.067]         }, condition = base::local({
[10:31:26.067]             c <- base::c
[10:31:26.067]             inherits <- base::inherits
[10:31:26.067]             invokeRestart <- base::invokeRestart
[10:31:26.067]             length <- base::length
[10:31:26.067]             list <- base::list
[10:31:26.067]             seq.int <- base::seq.int
[10:31:26.067]             signalCondition <- base::signalCondition
[10:31:26.067]             sys.calls <- base::sys.calls
[10:31:26.067]             `[[` <- base::`[[`
[10:31:26.067]             `+` <- base::`+`
[10:31:26.067]             `<<-` <- base::`<<-`
[10:31:26.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:26.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:26.067]                   3L)]
[10:31:26.067]             }
[10:31:26.067]             function(cond) {
[10:31:26.067]                 is_error <- inherits(cond, "error")
[10:31:26.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:26.067]                   NULL)
[10:31:26.067]                 if (is_error) {
[10:31:26.067]                   sessionInformation <- function() {
[10:31:26.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:26.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:26.067]                       search = base::search(), system = base::Sys.info())
[10:31:26.067]                   }
[10:31:26.067]                   ...future.conditions[[length(...future.conditions) + 
[10:31:26.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:26.067]                     cond$call), session = sessionInformation(), 
[10:31:26.067]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:26.067]                   signalCondition(cond)
[10:31:26.067]                 }
[10:31:26.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:26.067]                 "immediateCondition"))) {
[10:31:26.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:26.067]                   ...future.conditions[[length(...future.conditions) + 
[10:31:26.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:26.067]                   if (TRUE && !signal) {
[10:31:26.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.067]                     {
[10:31:26.067]                       inherits <- base::inherits
[10:31:26.067]                       invokeRestart <- base::invokeRestart
[10:31:26.067]                       is.null <- base::is.null
[10:31:26.067]                       muffled <- FALSE
[10:31:26.067]                       if (inherits(cond, "message")) {
[10:31:26.067]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:26.067]                         if (muffled) 
[10:31:26.067]                           invokeRestart("muffleMessage")
[10:31:26.067]                       }
[10:31:26.067]                       else if (inherits(cond, "warning")) {
[10:31:26.067]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:26.067]                         if (muffled) 
[10:31:26.067]                           invokeRestart("muffleWarning")
[10:31:26.067]                       }
[10:31:26.067]                       else if (inherits(cond, "condition")) {
[10:31:26.067]                         if (!is.null(pattern)) {
[10:31:26.067]                           computeRestarts <- base::computeRestarts
[10:31:26.067]                           grepl <- base::grepl
[10:31:26.067]                           restarts <- computeRestarts(cond)
[10:31:26.067]                           for (restart in restarts) {
[10:31:26.067]                             name <- restart$name
[10:31:26.067]                             if (is.null(name)) 
[10:31:26.067]                               next
[10:31:26.067]                             if (!grepl(pattern, name)) 
[10:31:26.067]                               next
[10:31:26.067]                             invokeRestart(restart)
[10:31:26.067]                             muffled <- TRUE
[10:31:26.067]                             break
[10:31:26.067]                           }
[10:31:26.067]                         }
[10:31:26.067]                       }
[10:31:26.067]                       invisible(muffled)
[10:31:26.067]                     }
[10:31:26.067]                     muffleCondition(cond, pattern = "^muffle")
[10:31:26.067]                   }
[10:31:26.067]                 }
[10:31:26.067]                 else {
[10:31:26.067]                   if (TRUE) {
[10:31:26.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.067]                     {
[10:31:26.067]                       inherits <- base::inherits
[10:31:26.067]                       invokeRestart <- base::invokeRestart
[10:31:26.067]                       is.null <- base::is.null
[10:31:26.067]                       muffled <- FALSE
[10:31:26.067]                       if (inherits(cond, "message")) {
[10:31:26.067]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:26.067]                         if (muffled) 
[10:31:26.067]                           invokeRestart("muffleMessage")
[10:31:26.067]                       }
[10:31:26.067]                       else if (inherits(cond, "warning")) {
[10:31:26.067]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:26.067]                         if (muffled) 
[10:31:26.067]                           invokeRestart("muffleWarning")
[10:31:26.067]                       }
[10:31:26.067]                       else if (inherits(cond, "condition")) {
[10:31:26.067]                         if (!is.null(pattern)) {
[10:31:26.067]                           computeRestarts <- base::computeRestarts
[10:31:26.067]                           grepl <- base::grepl
[10:31:26.067]                           restarts <- computeRestarts(cond)
[10:31:26.067]                           for (restart in restarts) {
[10:31:26.067]                             name <- restart$name
[10:31:26.067]                             if (is.null(name)) 
[10:31:26.067]                               next
[10:31:26.067]                             if (!grepl(pattern, name)) 
[10:31:26.067]                               next
[10:31:26.067]                             invokeRestart(restart)
[10:31:26.067]                             muffled <- TRUE
[10:31:26.067]                             break
[10:31:26.067]                           }
[10:31:26.067]                         }
[10:31:26.067]                       }
[10:31:26.067]                       invisible(muffled)
[10:31:26.067]                     }
[10:31:26.067]                     muffleCondition(cond, pattern = "^muffle")
[10:31:26.067]                   }
[10:31:26.067]                 }
[10:31:26.067]             }
[10:31:26.067]         }))
[10:31:26.067]     }, error = function(ex) {
[10:31:26.067]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:26.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:26.067]                 ...future.rng), started = ...future.startTime, 
[10:31:26.067]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:26.067]             version = "1.8"), class = "FutureResult")
[10:31:26.067]     }, finally = {
[10:31:26.067]         if (!identical(...future.workdir, getwd())) 
[10:31:26.067]             setwd(...future.workdir)
[10:31:26.067]         {
[10:31:26.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:26.067]                 ...future.oldOptions$nwarnings <- NULL
[10:31:26.067]             }
[10:31:26.067]             base::options(...future.oldOptions)
[10:31:26.067]             if (.Platform$OS.type == "windows") {
[10:31:26.067]                 old_names <- names(...future.oldEnvVars)
[10:31:26.067]                 envs <- base::Sys.getenv()
[10:31:26.067]                 names <- names(envs)
[10:31:26.067]                 common <- intersect(names, old_names)
[10:31:26.067]                 added <- setdiff(names, old_names)
[10:31:26.067]                 removed <- setdiff(old_names, names)
[10:31:26.067]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:26.067]                   envs[common]]
[10:31:26.067]                 NAMES <- toupper(changed)
[10:31:26.067]                 args <- list()
[10:31:26.067]                 for (kk in seq_along(NAMES)) {
[10:31:26.067]                   name <- changed[[kk]]
[10:31:26.067]                   NAME <- NAMES[[kk]]
[10:31:26.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.067]                     next
[10:31:26.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:26.067]                 }
[10:31:26.067]                 NAMES <- toupper(added)
[10:31:26.067]                 for (kk in seq_along(NAMES)) {
[10:31:26.067]                   name <- added[[kk]]
[10:31:26.067]                   NAME <- NAMES[[kk]]
[10:31:26.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.067]                     next
[10:31:26.067]                   args[[name]] <- ""
[10:31:26.067]                 }
[10:31:26.067]                 NAMES <- toupper(removed)
[10:31:26.067]                 for (kk in seq_along(NAMES)) {
[10:31:26.067]                   name <- removed[[kk]]
[10:31:26.067]                   NAME <- NAMES[[kk]]
[10:31:26.067]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.067]                     next
[10:31:26.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:26.067]                 }
[10:31:26.067]                 if (length(args) > 0) 
[10:31:26.067]                   base::do.call(base::Sys.setenv, args = args)
[10:31:26.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:26.067]             }
[10:31:26.067]             else {
[10:31:26.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:26.067]             }
[10:31:26.067]             {
[10:31:26.067]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:26.067]                   0L) {
[10:31:26.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:26.067]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:26.067]                   base::options(opts)
[10:31:26.067]                 }
[10:31:26.067]                 {
[10:31:26.067]                   {
[10:31:26.067]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:26.067]                     NULL
[10:31:26.067]                   }
[10:31:26.067]                   options(future.plan = NULL)
[10:31:26.067]                   if (is.na(NA_character_)) 
[10:31:26.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:26.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:26.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:26.067]                     .init = FALSE)
[10:31:26.067]                 }
[10:31:26.067]             }
[10:31:26.067]         }
[10:31:26.067]     })
[10:31:26.067]     if (TRUE) {
[10:31:26.067]         base::sink(type = "output", split = FALSE)
[10:31:26.067]         if (TRUE) {
[10:31:26.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:26.067]         }
[10:31:26.067]         else {
[10:31:26.067]             ...future.result["stdout"] <- base::list(NULL)
[10:31:26.067]         }
[10:31:26.067]         base::close(...future.stdout)
[10:31:26.067]         ...future.stdout <- NULL
[10:31:26.067]     }
[10:31:26.067]     ...future.result$conditions <- ...future.conditions
[10:31:26.067]     ...future.result$finished <- base::Sys.time()
[10:31:26.067]     ...future.result
[10:31:26.067] }
[10:31:26.070] Exporting 11 global objects (93.23 KiB) to cluster node #2 ...
[10:31:26.070] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:31:26.113] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:31:26.113] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[10:31:26.114] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[10:31:26.114] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:31:26.114] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:31:26.114] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:31:26.157] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:31:26.157] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:31:26.201] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:31:26.201] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:31:26.202] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:31:26.202] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:31:26.202] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:31:26.202] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:31:26.203] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:31:26.203] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:31:26.203] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:31:26.203] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:26.204] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:26.204] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:26.204] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:26.204] Exporting 11 global objects (93.23 KiB) to cluster node #2 ... DONE
[10:31:26.205] MultisessionFuture started
[10:31:26.205] - Launch lazy future ... done
[10:31:26.205] run() for ‘MultisessionFuture’ ... done
[10:31:26.206] Created future:
[10:31:26.206] MultisessionFuture:
[10:31:26.206] Label: ‘future_vapply-2’
[10:31:26.206] Expression:
[10:31:26.206] {
[10:31:26.206]     do.call(function(...) {
[10:31:26.206]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.206]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:26.206]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.206]             on.exit(options(oopts), add = TRUE)
[10:31:26.206]         }
[10:31:26.206]         {
[10:31:26.206]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:26.206]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.206]                 ...future.FUN(...future.X_jj, ...)
[10:31:26.206]             })
[10:31:26.206]         }
[10:31:26.206]     }, args = future.call.arguments)
[10:31:26.206] }
[10:31:26.206] Lazy evaluation: FALSE
[10:31:26.206] Asynchronous evaluation: TRUE
[10:31:26.206] Local evaluation: TRUE
[10:31:26.206] Environment: R_GlobalEnv
[10:31:26.206] Capture standard output: TRUE
[10:31:26.206] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:26.206] Globals: 11 objects totaling 93.51 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:26.206] Packages: 1 packages (‘future.apply’)
[10:31:26.206] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:26.206] Resolved: FALSE
[10:31:26.206] Value: <not collected>
[10:31:26.206] Conditions captured: <none>
[10:31:26.206] Early signaling: FALSE
[10:31:26.206] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:26.206] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:26.217] Chunk #2 of 2 ... DONE
[10:31:26.217] Launching 2 futures (chunks) ... DONE
[10:31:26.218] Resolving 2 futures (chunks) ...
[10:31:26.218] resolve() on list ...
[10:31:26.218]  recursive: 0
[10:31:26.218]  length: 2
[10:31:26.218] 
[10:31:26.218] receiveMessageFromWorker() for ClusterFuture ...
[10:31:26.218] - Validating connection of MultisessionFuture
[10:31:26.219] - received message: FutureResult
[10:31:26.219] - Received FutureResult
[10:31:26.219] - Erased future from FutureRegistry
[10:31:26.219] result() for ClusterFuture ...
[10:31:26.219] - result already collected: FutureResult
[10:31:26.219] result() for ClusterFuture ... done
[10:31:26.219] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:26.219] Future #1
[10:31:26.219] result() for ClusterFuture ...
[10:31:26.220] - result already collected: FutureResult
[10:31:26.220] result() for ClusterFuture ... done
[10:31:26.220] result() for ClusterFuture ...
[10:31:26.220] - result already collected: FutureResult
[10:31:26.220] result() for ClusterFuture ... done
[10:31:26.220] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:26.220] - nx: 2
[10:31:26.220] - relay: TRUE
[10:31:26.220] - stdout: TRUE
[10:31:26.220] - signal: TRUE
[10:31:26.220] - resignal: FALSE
[10:31:26.221] - force: TRUE
[10:31:26.221] - relayed: [n=2] FALSE, FALSE
[10:31:26.221] - queued futures: [n=2] FALSE, FALSE
[10:31:26.221]  - until=1
[10:31:26.221]  - relaying element #1
[10:31:26.221] result() for ClusterFuture ...
[10:31:26.221] - result already collected: FutureResult
[10:31:26.221] result() for ClusterFuture ... done
[10:31:26.221] result() for ClusterFuture ...
[10:31:26.221] - result already collected: FutureResult
[10:31:26.221] result() for ClusterFuture ... done
[10:31:26.222] result() for ClusterFuture ...
[10:31:26.222] - result already collected: FutureResult
[10:31:26.222] result() for ClusterFuture ... done
[10:31:26.222] result() for ClusterFuture ...
[10:31:26.222] - result already collected: FutureResult
[10:31:26.222] result() for ClusterFuture ... done
[10:31:26.222] - relayed: [n=2] TRUE, FALSE
[10:31:26.222] - queued futures: [n=2] TRUE, FALSE
[10:31:26.222] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:26.222]  length: 1 (resolved future 1)
[10:31:26.250] receiveMessageFromWorker() for ClusterFuture ...
[10:31:26.251] - Validating connection of MultisessionFuture
[10:31:26.251] - received message: FutureResult
[10:31:26.251] - Received FutureResult
[10:31:26.251] - Erased future from FutureRegistry
[10:31:26.251] result() for ClusterFuture ...
[10:31:26.251] - result already collected: FutureResult
[10:31:26.251] result() for ClusterFuture ... done
[10:31:26.251] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:26.252] Future #2
[10:31:26.252] result() for ClusterFuture ...
[10:31:26.252] - result already collected: FutureResult
[10:31:26.252] result() for ClusterFuture ... done
[10:31:26.252] result() for ClusterFuture ...
[10:31:26.252] - result already collected: FutureResult
[10:31:26.252] result() for ClusterFuture ... done
[10:31:26.252] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:26.252] - nx: 2
[10:31:26.252] - relay: TRUE
[10:31:26.252] - stdout: TRUE
[10:31:26.253] - signal: TRUE
[10:31:26.253] - resignal: FALSE
[10:31:26.253] - force: TRUE
[10:31:26.253] - relayed: [n=2] TRUE, FALSE
[10:31:26.253] - queued futures: [n=2] TRUE, FALSE
[10:31:26.253]  - until=2
[10:31:26.253]  - relaying element #2
[10:31:26.253] result() for ClusterFuture ...
[10:31:26.253] - result already collected: FutureResult
[10:31:26.253] result() for ClusterFuture ... done
[10:31:26.253] result() for ClusterFuture ...
[10:31:26.254] - result already collected: FutureResult
[10:31:26.254] result() for ClusterFuture ... done
[10:31:26.254] result() for ClusterFuture ...
[10:31:26.254] - result already collected: FutureResult
[10:31:26.254] result() for ClusterFuture ... done
[10:31:26.254] result() for ClusterFuture ...
[10:31:26.254] - result already collected: FutureResult
[10:31:26.254] result() for ClusterFuture ... done
[10:31:26.254] - relayed: [n=2] TRUE, TRUE
[10:31:26.254] - queued futures: [n=2] TRUE, TRUE
[10:31:26.254] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:26.255]  length: 0 (resolved future 2)
[10:31:26.255] Relaying remaining futures
[10:31:26.255] signalConditionsASAP(NULL, pos=0) ...
[10:31:26.255] - nx: 2
[10:31:26.255] - relay: TRUE
[10:31:26.255] - stdout: TRUE
[10:31:26.255] - signal: TRUE
[10:31:26.255] - resignal: FALSE
[10:31:26.255] - force: TRUE
[10:31:26.255] - relayed: [n=2] TRUE, TRUE
[10:31:26.255] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:26.255] - relayed: [n=2] TRUE, TRUE
[10:31:26.256] - queued futures: [n=2] TRUE, TRUE
[10:31:26.256] signalConditionsASAP(NULL, pos=0) ... done
[10:31:26.256] resolve() on list ... DONE
[10:31:26.256] result() for ClusterFuture ...
[10:31:26.256] - result already collected: FutureResult
[10:31:26.256] result() for ClusterFuture ... done
[10:31:26.256] result() for ClusterFuture ...
[10:31:26.256] - result already collected: FutureResult
[10:31:26.256] result() for ClusterFuture ... done
[10:31:26.256] result() for ClusterFuture ...
[10:31:26.256] - result already collected: FutureResult
[10:31:26.257] result() for ClusterFuture ... done
[10:31:26.257] result() for ClusterFuture ...
[10:31:26.257] - result already collected: FutureResult
[10:31:26.257] result() for ClusterFuture ... done
[10:31:26.257]  - Number of value chunks collected: 2
[10:31:26.257] Resolving 2 futures (chunks) ... DONE
[10:31:26.257] Reducing values from 2 chunks ...
[10:31:26.257]  - Number of values collected after concatenation: 10
[10:31:26.257]  - Number of values expected: 10
[10:31:26.257] Reducing values from 2 chunks ... DONE
[10:31:26.257] future_lapply() ... DONE
 num[0 , 1:10] 
 int[0 , 1:10] 
[10:31:26.258] future_lapply() ...
[10:31:26.269] Number of chunks: 2
[10:31:26.269] getGlobalsAndPackagesXApply() ...
[10:31:26.269]  - future.globals: TRUE
[10:31:26.269] getGlobalsAndPackages() ...
[10:31:26.269] Searching for globals...
[10:31:26.273] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘integer’
[10:31:26.273] Searching for globals ... DONE
[10:31:26.273] Resolving globals: FALSE
[10:31:26.274] The total size of the 7 globals is 93.16 KiB (95400 bytes)
[10:31:26.274] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.16 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:26.275] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:26.275] - packages: [1] ‘future.apply’
[10:31:26.275] getGlobalsAndPackages() ... DONE
[10:31:26.275]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:26.275]  - needed namespaces: [n=1] ‘future.apply’
[10:31:26.275] Finding globals ... DONE
[10:31:26.275]  - use_args: TRUE
[10:31:26.275]  - Getting '...' globals ...
[10:31:26.276] resolve() on list ...
[10:31:26.276]  recursive: 0
[10:31:26.276]  length: 1
[10:31:26.276]  elements: ‘...’
[10:31:26.276]  length: 0 (resolved future 1)
[10:31:26.276] resolve() on list ... DONE
[10:31:26.276]    - '...' content: [n=0] 
[10:31:26.276] List of 1
[10:31:26.276]  $ ...: list()
[10:31:26.276]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:26.276]  - attr(*, "where")=List of 1
[10:31:26.276]   ..$ ...:<environment: 0x55de8853c7b0> 
[10:31:26.276]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:26.276]  - attr(*, "resolved")= logi TRUE
[10:31:26.276]  - attr(*, "total_size")= num NA
[10:31:26.279]  - Getting '...' globals ... DONE
[10:31:26.279] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:26.279] List of 8
[10:31:26.279]  $ ...future.FUN:function (x, ...)  
[10:31:26.279]  $ x_FUN        :function (x)  
[10:31:26.279]  $ times        : int 0
[10:31:26.279]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:26.279]  $ stop_if_not  :function (...)  
[10:31:26.279]  $ dim          : NULL
[10:31:26.279]  $ valid_types  : chr [1:2] "logical" "integer"
[10:31:26.279]  $ ...          : list()
[10:31:26.279]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:26.279]  - attr(*, "where")=List of 8
[10:31:26.279]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:26.279]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:26.279]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:26.279]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:26.279]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:26.279]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:26.279]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:26.279]   ..$ ...          :<environment: 0x55de8853c7b0> 
[10:31:26.279]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:26.279]  - attr(*, "resolved")= logi FALSE
[10:31:26.279]  - attr(*, "total_size")= num 95400
[10:31:26.284] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:26.285] getGlobalsAndPackagesXApply() ... DONE
[10:31:26.285] Number of futures (= number of chunks): 2
[10:31:26.285] Launching 2 futures (chunks) ...
[10:31:26.285] Chunk #1 of 2 ...
[10:31:26.285]  - Finding globals in 'X' for chunk #1 ...
[10:31:26.285] getGlobalsAndPackages() ...
[10:31:26.285] Searching for globals...
[10:31:26.286] 
[10:31:26.286] Searching for globals ... DONE
[10:31:26.286] - globals: [0] <none>
[10:31:26.286] getGlobalsAndPackages() ... DONE
[10:31:26.286]    + additional globals found: [n=0] 
[10:31:26.286]    + additional namespaces needed: [n=0] 
[10:31:26.286]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:26.286]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:26.286]  - seeds: <none>
[10:31:26.286]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.286] getGlobalsAndPackages() ...
[10:31:26.287] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.287] Resolving globals: FALSE
[10:31:26.287] Tweak future expression to call with '...' arguments ...
[10:31:26.287] {
[10:31:26.287]     do.call(function(...) {
[10:31:26.287]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.287]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:26.287]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.287]             on.exit(options(oopts), add = TRUE)
[10:31:26.287]         }
[10:31:26.287]         {
[10:31:26.287]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:26.287]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.287]                 ...future.FUN(...future.X_jj, ...)
[10:31:26.287]             })
[10:31:26.287]         }
[10:31:26.287]     }, args = future.call.arguments)
[10:31:26.287] }
[10:31:26.287] Tweak future expression to call with '...' arguments ... DONE
[10:31:26.288] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.288] - packages: [1] ‘future.apply’
[10:31:26.288] getGlobalsAndPackages() ... DONE
[10:31:26.288] run() for ‘Future’ ...
[10:31:26.288] - state: ‘created’
[10:31:26.288] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:26.303] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:26.303] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:26.303]   - Field: ‘node’
[10:31:26.303]   - Field: ‘label’
[10:31:26.303]   - Field: ‘local’
[10:31:26.303]   - Field: ‘owner’
[10:31:26.303]   - Field: ‘envir’
[10:31:26.303]   - Field: ‘workers’
[10:31:26.303]   - Field: ‘packages’
[10:31:26.303]   - Field: ‘gc’
[10:31:26.304]   - Field: ‘conditions’
[10:31:26.304]   - Field: ‘persistent’
[10:31:26.304]   - Field: ‘expr’
[10:31:26.304]   - Field: ‘uuid’
[10:31:26.304]   - Field: ‘seed’
[10:31:26.304]   - Field: ‘version’
[10:31:26.304]   - Field: ‘result’
[10:31:26.304]   - Field: ‘asynchronous’
[10:31:26.304]   - Field: ‘calls’
[10:31:26.304]   - Field: ‘globals’
[10:31:26.305]   - Field: ‘stdout’
[10:31:26.305]   - Field: ‘earlySignal’
[10:31:26.305]   - Field: ‘lazy’
[10:31:26.305]   - Field: ‘state’
[10:31:26.305] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:26.305] - Launch lazy future ...
[10:31:26.305] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:26.305] Packages needed by future strategies (n = 0): <none>
[10:31:26.306] {
[10:31:26.306]     {
[10:31:26.306]         {
[10:31:26.306]             ...future.startTime <- base::Sys.time()
[10:31:26.306]             {
[10:31:26.306]                 {
[10:31:26.306]                   {
[10:31:26.306]                     {
[10:31:26.306]                       {
[10:31:26.306]                         base::local({
[10:31:26.306]                           has_future <- base::requireNamespace("future", 
[10:31:26.306]                             quietly = TRUE)
[10:31:26.306]                           if (has_future) {
[10:31:26.306]                             ns <- base::getNamespace("future")
[10:31:26.306]                             version <- ns[[".package"]][["version"]]
[10:31:26.306]                             if (is.null(version)) 
[10:31:26.306]                               version <- utils::packageVersion("future")
[10:31:26.306]                           }
[10:31:26.306]                           else {
[10:31:26.306]                             version <- NULL
[10:31:26.306]                           }
[10:31:26.306]                           if (!has_future || version < "1.8.0") {
[10:31:26.306]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:26.306]                               "", base::R.version$version.string), 
[10:31:26.306]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:26.306]                                 base::R.version$platform, 8 * 
[10:31:26.306]                                   base::.Machine$sizeof.pointer), 
[10:31:26.306]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:26.306]                                 "release", "version")], collapse = " "), 
[10:31:26.306]                               hostname = base::Sys.info()[["nodename"]])
[10:31:26.306]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:26.306]                               info)
[10:31:26.306]                             info <- base::paste(info, collapse = "; ")
[10:31:26.306]                             if (!has_future) {
[10:31:26.306]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:26.306]                                 info)
[10:31:26.306]                             }
[10:31:26.306]                             else {
[10:31:26.306]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:26.306]                                 info, version)
[10:31:26.306]                             }
[10:31:26.306]                             base::stop(msg)
[10:31:26.306]                           }
[10:31:26.306]                         })
[10:31:26.306]                       }
[10:31:26.306]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:26.306]                       base::options(mc.cores = 1L)
[10:31:26.306]                     }
[10:31:26.306]                     base::local({
[10:31:26.306]                       for (pkg in "future.apply") {
[10:31:26.306]                         base::loadNamespace(pkg)
[10:31:26.306]                         base::library(pkg, character.only = TRUE)
[10:31:26.306]                       }
[10:31:26.306]                     })
[10:31:26.306]                   }
[10:31:26.306]                   ...future.strategy.old <- future::plan("list")
[10:31:26.306]                   options(future.plan = NULL)
[10:31:26.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:26.306]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:26.306]                 }
[10:31:26.306]                 ...future.workdir <- getwd()
[10:31:26.306]             }
[10:31:26.306]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:26.306]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:26.306]         }
[10:31:26.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:26.306]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:26.306]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:26.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:26.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:26.306]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:26.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:26.306]             base::names(...future.oldOptions))
[10:31:26.306]     }
[10:31:26.306]     if (FALSE) {
[10:31:26.306]     }
[10:31:26.306]     else {
[10:31:26.306]         if (TRUE) {
[10:31:26.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:26.306]                 open = "w")
[10:31:26.306]         }
[10:31:26.306]         else {
[10:31:26.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:26.306]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:26.306]         }
[10:31:26.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:26.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:26.306]             base::sink(type = "output", split = FALSE)
[10:31:26.306]             base::close(...future.stdout)
[10:31:26.306]         }, add = TRUE)
[10:31:26.306]     }
[10:31:26.306]     ...future.frame <- base::sys.nframe()
[10:31:26.306]     ...future.conditions <- base::list()
[10:31:26.306]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:26.306]     if (FALSE) {
[10:31:26.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:26.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:26.306]     }
[10:31:26.306]     ...future.result <- base::tryCatch({
[10:31:26.306]         base::withCallingHandlers({
[10:31:26.306]             ...future.value <- base::withVisible(base::local({
[10:31:26.306]                 ...future.makeSendCondition <- base::local({
[10:31:26.306]                   sendCondition <- NULL
[10:31:26.306]                   function(frame = 1L) {
[10:31:26.306]                     if (is.function(sendCondition)) 
[10:31:26.306]                       return(sendCondition)
[10:31:26.306]                     ns <- getNamespace("parallel")
[10:31:26.306]                     if (exists("sendData", mode = "function", 
[10:31:26.306]                       envir = ns)) {
[10:31:26.306]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:26.306]                         envir = ns)
[10:31:26.306]                       envir <- sys.frame(frame)
[10:31:26.306]                       master <- NULL
[10:31:26.306]                       while (!identical(envir, .GlobalEnv) && 
[10:31:26.306]                         !identical(envir, emptyenv())) {
[10:31:26.306]                         if (exists("master", mode = "list", envir = envir, 
[10:31:26.306]                           inherits = FALSE)) {
[10:31:26.306]                           master <- get("master", mode = "list", 
[10:31:26.306]                             envir = envir, inherits = FALSE)
[10:31:26.306]                           if (inherits(master, c("SOCKnode", 
[10:31:26.306]                             "SOCK0node"))) {
[10:31:26.306]                             sendCondition <<- function(cond) {
[10:31:26.306]                               data <- list(type = "VALUE", value = cond, 
[10:31:26.306]                                 success = TRUE)
[10:31:26.306]                               parallel_sendData(master, data)
[10:31:26.306]                             }
[10:31:26.306]                             return(sendCondition)
[10:31:26.306]                           }
[10:31:26.306]                         }
[10:31:26.306]                         frame <- frame + 1L
[10:31:26.306]                         envir <- sys.frame(frame)
[10:31:26.306]                       }
[10:31:26.306]                     }
[10:31:26.306]                     sendCondition <<- function(cond) NULL
[10:31:26.306]                   }
[10:31:26.306]                 })
[10:31:26.306]                 withCallingHandlers({
[10:31:26.306]                   {
[10:31:26.306]                     do.call(function(...) {
[10:31:26.306]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.306]                       if (!identical(...future.globals.maxSize.org, 
[10:31:26.306]                         ...future.globals.maxSize)) {
[10:31:26.306]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.306]                         on.exit(options(oopts), add = TRUE)
[10:31:26.306]                       }
[10:31:26.306]                       {
[10:31:26.306]                         lapply(seq_along(...future.elements_ii), 
[10:31:26.306]                           FUN = function(jj) {
[10:31:26.306]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.306]                             ...future.FUN(...future.X_jj, ...)
[10:31:26.306]                           })
[10:31:26.306]                       }
[10:31:26.306]                     }, args = future.call.arguments)
[10:31:26.306]                   }
[10:31:26.306]                 }, immediateCondition = function(cond) {
[10:31:26.306]                   sendCondition <- ...future.makeSendCondition()
[10:31:26.306]                   sendCondition(cond)
[10:31:26.306]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.306]                   {
[10:31:26.306]                     inherits <- base::inherits
[10:31:26.306]                     invokeRestart <- base::invokeRestart
[10:31:26.306]                     is.null <- base::is.null
[10:31:26.306]                     muffled <- FALSE
[10:31:26.306]                     if (inherits(cond, "message")) {
[10:31:26.306]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:26.306]                       if (muffled) 
[10:31:26.306]                         invokeRestart("muffleMessage")
[10:31:26.306]                     }
[10:31:26.306]                     else if (inherits(cond, "warning")) {
[10:31:26.306]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:26.306]                       if (muffled) 
[10:31:26.306]                         invokeRestart("muffleWarning")
[10:31:26.306]                     }
[10:31:26.306]                     else if (inherits(cond, "condition")) {
[10:31:26.306]                       if (!is.null(pattern)) {
[10:31:26.306]                         computeRestarts <- base::computeRestarts
[10:31:26.306]                         grepl <- base::grepl
[10:31:26.306]                         restarts <- computeRestarts(cond)
[10:31:26.306]                         for (restart in restarts) {
[10:31:26.306]                           name <- restart$name
[10:31:26.306]                           if (is.null(name)) 
[10:31:26.306]                             next
[10:31:26.306]                           if (!grepl(pattern, name)) 
[10:31:26.306]                             next
[10:31:26.306]                           invokeRestart(restart)
[10:31:26.306]                           muffled <- TRUE
[10:31:26.306]                           break
[10:31:26.306]                         }
[10:31:26.306]                       }
[10:31:26.306]                     }
[10:31:26.306]                     invisible(muffled)
[10:31:26.306]                   }
[10:31:26.306]                   muffleCondition(cond)
[10:31:26.306]                 })
[10:31:26.306]             }))
[10:31:26.306]             future::FutureResult(value = ...future.value$value, 
[10:31:26.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:26.306]                   ...future.rng), globalenv = if (FALSE) 
[10:31:26.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:26.306]                     ...future.globalenv.names))
[10:31:26.306]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:26.306]         }, condition = base::local({
[10:31:26.306]             c <- base::c
[10:31:26.306]             inherits <- base::inherits
[10:31:26.306]             invokeRestart <- base::invokeRestart
[10:31:26.306]             length <- base::length
[10:31:26.306]             list <- base::list
[10:31:26.306]             seq.int <- base::seq.int
[10:31:26.306]             signalCondition <- base::signalCondition
[10:31:26.306]             sys.calls <- base::sys.calls
[10:31:26.306]             `[[` <- base::`[[`
[10:31:26.306]             `+` <- base::`+`
[10:31:26.306]             `<<-` <- base::`<<-`
[10:31:26.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:26.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:26.306]                   3L)]
[10:31:26.306]             }
[10:31:26.306]             function(cond) {
[10:31:26.306]                 is_error <- inherits(cond, "error")
[10:31:26.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:26.306]                   NULL)
[10:31:26.306]                 if (is_error) {
[10:31:26.306]                   sessionInformation <- function() {
[10:31:26.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:26.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:26.306]                       search = base::search(), system = base::Sys.info())
[10:31:26.306]                   }
[10:31:26.306]                   ...future.conditions[[length(...future.conditions) + 
[10:31:26.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:26.306]                     cond$call), session = sessionInformation(), 
[10:31:26.306]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:26.306]                   signalCondition(cond)
[10:31:26.306]                 }
[10:31:26.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:26.306]                 "immediateCondition"))) {
[10:31:26.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:26.306]                   ...future.conditions[[length(...future.conditions) + 
[10:31:26.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:26.306]                   if (TRUE && !signal) {
[10:31:26.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.306]                     {
[10:31:26.306]                       inherits <- base::inherits
[10:31:26.306]                       invokeRestart <- base::invokeRestart
[10:31:26.306]                       is.null <- base::is.null
[10:31:26.306]                       muffled <- FALSE
[10:31:26.306]                       if (inherits(cond, "message")) {
[10:31:26.306]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:26.306]                         if (muffled) 
[10:31:26.306]                           invokeRestart("muffleMessage")
[10:31:26.306]                       }
[10:31:26.306]                       else if (inherits(cond, "warning")) {
[10:31:26.306]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:26.306]                         if (muffled) 
[10:31:26.306]                           invokeRestart("muffleWarning")
[10:31:26.306]                       }
[10:31:26.306]                       else if (inherits(cond, "condition")) {
[10:31:26.306]                         if (!is.null(pattern)) {
[10:31:26.306]                           computeRestarts <- base::computeRestarts
[10:31:26.306]                           grepl <- base::grepl
[10:31:26.306]                           restarts <- computeRestarts(cond)
[10:31:26.306]                           for (restart in restarts) {
[10:31:26.306]                             name <- restart$name
[10:31:26.306]                             if (is.null(name)) 
[10:31:26.306]                               next
[10:31:26.306]                             if (!grepl(pattern, name)) 
[10:31:26.306]                               next
[10:31:26.306]                             invokeRestart(restart)
[10:31:26.306]                             muffled <- TRUE
[10:31:26.306]                             break
[10:31:26.306]                           }
[10:31:26.306]                         }
[10:31:26.306]                       }
[10:31:26.306]                       invisible(muffled)
[10:31:26.306]                     }
[10:31:26.306]                     muffleCondition(cond, pattern = "^muffle")
[10:31:26.306]                   }
[10:31:26.306]                 }
[10:31:26.306]                 else {
[10:31:26.306]                   if (TRUE) {
[10:31:26.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.306]                     {
[10:31:26.306]                       inherits <- base::inherits
[10:31:26.306]                       invokeRestart <- base::invokeRestart
[10:31:26.306]                       is.null <- base::is.null
[10:31:26.306]                       muffled <- FALSE
[10:31:26.306]                       if (inherits(cond, "message")) {
[10:31:26.306]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:26.306]                         if (muffled) 
[10:31:26.306]                           invokeRestart("muffleMessage")
[10:31:26.306]                       }
[10:31:26.306]                       else if (inherits(cond, "warning")) {
[10:31:26.306]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:26.306]                         if (muffled) 
[10:31:26.306]                           invokeRestart("muffleWarning")
[10:31:26.306]                       }
[10:31:26.306]                       else if (inherits(cond, "condition")) {
[10:31:26.306]                         if (!is.null(pattern)) {
[10:31:26.306]                           computeRestarts <- base::computeRestarts
[10:31:26.306]                           grepl <- base::grepl
[10:31:26.306]                           restarts <- computeRestarts(cond)
[10:31:26.306]                           for (restart in restarts) {
[10:31:26.306]                             name <- restart$name
[10:31:26.306]                             if (is.null(name)) 
[10:31:26.306]                               next
[10:31:26.306]                             if (!grepl(pattern, name)) 
[10:31:26.306]                               next
[10:31:26.306]                             invokeRestart(restart)
[10:31:26.306]                             muffled <- TRUE
[10:31:26.306]                             break
[10:31:26.306]                           }
[10:31:26.306]                         }
[10:31:26.306]                       }
[10:31:26.306]                       invisible(muffled)
[10:31:26.306]                     }
[10:31:26.306]                     muffleCondition(cond, pattern = "^muffle")
[10:31:26.306]                   }
[10:31:26.306]                 }
[10:31:26.306]             }
[10:31:26.306]         }))
[10:31:26.306]     }, error = function(ex) {
[10:31:26.306]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:26.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:26.306]                 ...future.rng), started = ...future.startTime, 
[10:31:26.306]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:26.306]             version = "1.8"), class = "FutureResult")
[10:31:26.306]     }, finally = {
[10:31:26.306]         if (!identical(...future.workdir, getwd())) 
[10:31:26.306]             setwd(...future.workdir)
[10:31:26.306]         {
[10:31:26.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:26.306]                 ...future.oldOptions$nwarnings <- NULL
[10:31:26.306]             }
[10:31:26.306]             base::options(...future.oldOptions)
[10:31:26.306]             if (.Platform$OS.type == "windows") {
[10:31:26.306]                 old_names <- names(...future.oldEnvVars)
[10:31:26.306]                 envs <- base::Sys.getenv()
[10:31:26.306]                 names <- names(envs)
[10:31:26.306]                 common <- intersect(names, old_names)
[10:31:26.306]                 added <- setdiff(names, old_names)
[10:31:26.306]                 removed <- setdiff(old_names, names)
[10:31:26.306]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:26.306]                   envs[common]]
[10:31:26.306]                 NAMES <- toupper(changed)
[10:31:26.306]                 args <- list()
[10:31:26.306]                 for (kk in seq_along(NAMES)) {
[10:31:26.306]                   name <- changed[[kk]]
[10:31:26.306]                   NAME <- NAMES[[kk]]
[10:31:26.306]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.306]                     next
[10:31:26.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:26.306]                 }
[10:31:26.306]                 NAMES <- toupper(added)
[10:31:26.306]                 for (kk in seq_along(NAMES)) {
[10:31:26.306]                   name <- added[[kk]]
[10:31:26.306]                   NAME <- NAMES[[kk]]
[10:31:26.306]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.306]                     next
[10:31:26.306]                   args[[name]] <- ""
[10:31:26.306]                 }
[10:31:26.306]                 NAMES <- toupper(removed)
[10:31:26.306]                 for (kk in seq_along(NAMES)) {
[10:31:26.306]                   name <- removed[[kk]]
[10:31:26.306]                   NAME <- NAMES[[kk]]
[10:31:26.306]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.306]                     next
[10:31:26.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:26.306]                 }
[10:31:26.306]                 if (length(args) > 0) 
[10:31:26.306]                   base::do.call(base::Sys.setenv, args = args)
[10:31:26.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:26.306]             }
[10:31:26.306]             else {
[10:31:26.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:26.306]             }
[10:31:26.306]             {
[10:31:26.306]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:26.306]                   0L) {
[10:31:26.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:26.306]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:26.306]                   base::options(opts)
[10:31:26.306]                 }
[10:31:26.306]                 {
[10:31:26.306]                   {
[10:31:26.306]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:26.306]                     NULL
[10:31:26.306]                   }
[10:31:26.306]                   options(future.plan = NULL)
[10:31:26.306]                   if (is.na(NA_character_)) 
[10:31:26.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:26.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:26.306]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:26.306]                     .init = FALSE)
[10:31:26.306]                 }
[10:31:26.306]             }
[10:31:26.306]         }
[10:31:26.306]     })
[10:31:26.306]     if (TRUE) {
[10:31:26.306]         base::sink(type = "output", split = FALSE)
[10:31:26.306]         if (TRUE) {
[10:31:26.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:26.306]         }
[10:31:26.306]         else {
[10:31:26.306]             ...future.result["stdout"] <- base::list(NULL)
[10:31:26.306]         }
[10:31:26.306]         base::close(...future.stdout)
[10:31:26.306]         ...future.stdout <- NULL
[10:31:26.306]     }
[10:31:26.306]     ...future.result$conditions <- ...future.conditions
[10:31:26.306]     ...future.result$finished <- base::Sys.time()
[10:31:26.306]     ...future.result
[10:31:26.306] }
[10:31:26.309] Exporting 11 global objects (93.16 KiB) to cluster node #1 ...
[10:31:26.309] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:26.353] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:26.353] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ...
[10:31:26.354] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #1 ... DONE
[10:31:26.354] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:26.354] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:26.354] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:26.397] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:26.397] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:26.441] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:26.441] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:26.442] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:26.442] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[10:31:26.442] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[10:31:26.443] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:26.443] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:26.443] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:31:26.444] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:31:26.444] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:26.444] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:26.444] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:26.445] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:26.445] Exporting 11 global objects (93.16 KiB) to cluster node #1 ... DONE
[10:31:26.445] MultisessionFuture started
[10:31:26.446] - Launch lazy future ... done
[10:31:26.446] run() for ‘MultisessionFuture’ ... done
[10:31:26.446] Created future:
[10:31:26.446] MultisessionFuture:
[10:31:26.446] Label: ‘future_vapply-1’
[10:31:26.446] Expression:
[10:31:26.446] {
[10:31:26.446]     do.call(function(...) {
[10:31:26.446]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.446]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:26.446]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.446]             on.exit(options(oopts), add = TRUE)
[10:31:26.446]         }
[10:31:26.446]         {
[10:31:26.446]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:26.446]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.446]                 ...future.FUN(...future.X_jj, ...)
[10:31:26.446]             })
[10:31:26.446]         }
[10:31:26.446]     }, args = future.call.arguments)
[10:31:26.446] }
[10:31:26.446] Lazy evaluation: FALSE
[10:31:26.446] Asynchronous evaluation: TRUE
[10:31:26.446] Local evaluation: TRUE
[10:31:26.446] Environment: R_GlobalEnv
[10:31:26.446] Capture standard output: TRUE
[10:31:26.446] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:26.446] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:26.446] Packages: 1 packages (‘future.apply’)
[10:31:26.446] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:26.446] Resolved: FALSE
[10:31:26.446] Value: <not collected>
[10:31:26.446] Conditions captured: <none>
[10:31:26.446] Early signaling: FALSE
[10:31:26.446] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:26.446] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:26.458] Chunk #1 of 2 ... DONE
[10:31:26.458] Chunk #2 of 2 ...
[10:31:26.458]  - Finding globals in 'X' for chunk #2 ...
[10:31:26.458] getGlobalsAndPackages() ...
[10:31:26.458] Searching for globals...
[10:31:26.459] 
[10:31:26.459] Searching for globals ... DONE
[10:31:26.459] - globals: [0] <none>
[10:31:26.459] getGlobalsAndPackages() ... DONE
[10:31:26.459]    + additional globals found: [n=0] 
[10:31:26.459]    + additional namespaces needed: [n=0] 
[10:31:26.459]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:26.459]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:26.459]  - seeds: <none>
[10:31:26.459]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.460] getGlobalsAndPackages() ...
[10:31:26.460] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.460] Resolving globals: FALSE
[10:31:26.460] Tweak future expression to call with '...' arguments ...
[10:31:26.460] {
[10:31:26.460]     do.call(function(...) {
[10:31:26.460]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.460]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:26.460]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.460]             on.exit(options(oopts), add = TRUE)
[10:31:26.460]         }
[10:31:26.460]         {
[10:31:26.460]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:26.460]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.460]                 ...future.FUN(...future.X_jj, ...)
[10:31:26.460]             })
[10:31:26.460]         }
[10:31:26.460]     }, args = future.call.arguments)
[10:31:26.460] }
[10:31:26.460] Tweak future expression to call with '...' arguments ... DONE
[10:31:26.461] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.461] - packages: [1] ‘future.apply’
[10:31:26.461] getGlobalsAndPackages() ... DONE
[10:31:26.461] run() for ‘Future’ ...
[10:31:26.461] - state: ‘created’
[10:31:26.462] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:26.476] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:26.476] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:26.476]   - Field: ‘node’
[10:31:26.476]   - Field: ‘label’
[10:31:26.476]   - Field: ‘local’
[10:31:26.477]   - Field: ‘owner’
[10:31:26.477]   - Field: ‘envir’
[10:31:26.477]   - Field: ‘workers’
[10:31:26.477]   - Field: ‘packages’
[10:31:26.477]   - Field: ‘gc’
[10:31:26.477]   - Field: ‘conditions’
[10:31:26.477]   - Field: ‘persistent’
[10:31:26.477]   - Field: ‘expr’
[10:31:26.477]   - Field: ‘uuid’
[10:31:26.478]   - Field: ‘seed’
[10:31:26.478]   - Field: ‘version’
[10:31:26.478]   - Field: ‘result’
[10:31:26.478]   - Field: ‘asynchronous’
[10:31:26.478]   - Field: ‘calls’
[10:31:26.478]   - Field: ‘globals’
[10:31:26.478]   - Field: ‘stdout’
[10:31:26.478]   - Field: ‘earlySignal’
[10:31:26.478]   - Field: ‘lazy’
[10:31:26.478]   - Field: ‘state’
[10:31:26.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:26.479] - Launch lazy future ...
[10:31:26.479] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:26.479] Packages needed by future strategies (n = 0): <none>
[10:31:26.480] {
[10:31:26.480]     {
[10:31:26.480]         {
[10:31:26.480]             ...future.startTime <- base::Sys.time()
[10:31:26.480]             {
[10:31:26.480]                 {
[10:31:26.480]                   {
[10:31:26.480]                     {
[10:31:26.480]                       {
[10:31:26.480]                         base::local({
[10:31:26.480]                           has_future <- base::requireNamespace("future", 
[10:31:26.480]                             quietly = TRUE)
[10:31:26.480]                           if (has_future) {
[10:31:26.480]                             ns <- base::getNamespace("future")
[10:31:26.480]                             version <- ns[[".package"]][["version"]]
[10:31:26.480]                             if (is.null(version)) 
[10:31:26.480]                               version <- utils::packageVersion("future")
[10:31:26.480]                           }
[10:31:26.480]                           else {
[10:31:26.480]                             version <- NULL
[10:31:26.480]                           }
[10:31:26.480]                           if (!has_future || version < "1.8.0") {
[10:31:26.480]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:26.480]                               "", base::R.version$version.string), 
[10:31:26.480]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:26.480]                                 base::R.version$platform, 8 * 
[10:31:26.480]                                   base::.Machine$sizeof.pointer), 
[10:31:26.480]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:26.480]                                 "release", "version")], collapse = " "), 
[10:31:26.480]                               hostname = base::Sys.info()[["nodename"]])
[10:31:26.480]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:26.480]                               info)
[10:31:26.480]                             info <- base::paste(info, collapse = "; ")
[10:31:26.480]                             if (!has_future) {
[10:31:26.480]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:26.480]                                 info)
[10:31:26.480]                             }
[10:31:26.480]                             else {
[10:31:26.480]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:26.480]                                 info, version)
[10:31:26.480]                             }
[10:31:26.480]                             base::stop(msg)
[10:31:26.480]                           }
[10:31:26.480]                         })
[10:31:26.480]                       }
[10:31:26.480]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:26.480]                       base::options(mc.cores = 1L)
[10:31:26.480]                     }
[10:31:26.480]                     base::local({
[10:31:26.480]                       for (pkg in "future.apply") {
[10:31:26.480]                         base::loadNamespace(pkg)
[10:31:26.480]                         base::library(pkg, character.only = TRUE)
[10:31:26.480]                       }
[10:31:26.480]                     })
[10:31:26.480]                   }
[10:31:26.480]                   ...future.strategy.old <- future::plan("list")
[10:31:26.480]                   options(future.plan = NULL)
[10:31:26.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:26.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:26.480]                 }
[10:31:26.480]                 ...future.workdir <- getwd()
[10:31:26.480]             }
[10:31:26.480]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:26.480]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:26.480]         }
[10:31:26.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:26.480]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:26.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:26.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:26.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:26.480]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:26.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:26.480]             base::names(...future.oldOptions))
[10:31:26.480]     }
[10:31:26.480]     if (FALSE) {
[10:31:26.480]     }
[10:31:26.480]     else {
[10:31:26.480]         if (TRUE) {
[10:31:26.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:26.480]                 open = "w")
[10:31:26.480]         }
[10:31:26.480]         else {
[10:31:26.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:26.480]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:26.480]         }
[10:31:26.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:26.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:26.480]             base::sink(type = "output", split = FALSE)
[10:31:26.480]             base::close(...future.stdout)
[10:31:26.480]         }, add = TRUE)
[10:31:26.480]     }
[10:31:26.480]     ...future.frame <- base::sys.nframe()
[10:31:26.480]     ...future.conditions <- base::list()
[10:31:26.480]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:26.480]     if (FALSE) {
[10:31:26.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:26.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:26.480]     }
[10:31:26.480]     ...future.result <- base::tryCatch({
[10:31:26.480]         base::withCallingHandlers({
[10:31:26.480]             ...future.value <- base::withVisible(base::local({
[10:31:26.480]                 ...future.makeSendCondition <- base::local({
[10:31:26.480]                   sendCondition <- NULL
[10:31:26.480]                   function(frame = 1L) {
[10:31:26.480]                     if (is.function(sendCondition)) 
[10:31:26.480]                       return(sendCondition)
[10:31:26.480]                     ns <- getNamespace("parallel")
[10:31:26.480]                     if (exists("sendData", mode = "function", 
[10:31:26.480]                       envir = ns)) {
[10:31:26.480]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:26.480]                         envir = ns)
[10:31:26.480]                       envir <- sys.frame(frame)
[10:31:26.480]                       master <- NULL
[10:31:26.480]                       while (!identical(envir, .GlobalEnv) && 
[10:31:26.480]                         !identical(envir, emptyenv())) {
[10:31:26.480]                         if (exists("master", mode = "list", envir = envir, 
[10:31:26.480]                           inherits = FALSE)) {
[10:31:26.480]                           master <- get("master", mode = "list", 
[10:31:26.480]                             envir = envir, inherits = FALSE)
[10:31:26.480]                           if (inherits(master, c("SOCKnode", 
[10:31:26.480]                             "SOCK0node"))) {
[10:31:26.480]                             sendCondition <<- function(cond) {
[10:31:26.480]                               data <- list(type = "VALUE", value = cond, 
[10:31:26.480]                                 success = TRUE)
[10:31:26.480]                               parallel_sendData(master, data)
[10:31:26.480]                             }
[10:31:26.480]                             return(sendCondition)
[10:31:26.480]                           }
[10:31:26.480]                         }
[10:31:26.480]                         frame <- frame + 1L
[10:31:26.480]                         envir <- sys.frame(frame)
[10:31:26.480]                       }
[10:31:26.480]                     }
[10:31:26.480]                     sendCondition <<- function(cond) NULL
[10:31:26.480]                   }
[10:31:26.480]                 })
[10:31:26.480]                 withCallingHandlers({
[10:31:26.480]                   {
[10:31:26.480]                     do.call(function(...) {
[10:31:26.480]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.480]                       if (!identical(...future.globals.maxSize.org, 
[10:31:26.480]                         ...future.globals.maxSize)) {
[10:31:26.480]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.480]                         on.exit(options(oopts), add = TRUE)
[10:31:26.480]                       }
[10:31:26.480]                       {
[10:31:26.480]                         lapply(seq_along(...future.elements_ii), 
[10:31:26.480]                           FUN = function(jj) {
[10:31:26.480]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.480]                             ...future.FUN(...future.X_jj, ...)
[10:31:26.480]                           })
[10:31:26.480]                       }
[10:31:26.480]                     }, args = future.call.arguments)
[10:31:26.480]                   }
[10:31:26.480]                 }, immediateCondition = function(cond) {
[10:31:26.480]                   sendCondition <- ...future.makeSendCondition()
[10:31:26.480]                   sendCondition(cond)
[10:31:26.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.480]                   {
[10:31:26.480]                     inherits <- base::inherits
[10:31:26.480]                     invokeRestart <- base::invokeRestart
[10:31:26.480]                     is.null <- base::is.null
[10:31:26.480]                     muffled <- FALSE
[10:31:26.480]                     if (inherits(cond, "message")) {
[10:31:26.480]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:26.480]                       if (muffled) 
[10:31:26.480]                         invokeRestart("muffleMessage")
[10:31:26.480]                     }
[10:31:26.480]                     else if (inherits(cond, "warning")) {
[10:31:26.480]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:26.480]                       if (muffled) 
[10:31:26.480]                         invokeRestart("muffleWarning")
[10:31:26.480]                     }
[10:31:26.480]                     else if (inherits(cond, "condition")) {
[10:31:26.480]                       if (!is.null(pattern)) {
[10:31:26.480]                         computeRestarts <- base::computeRestarts
[10:31:26.480]                         grepl <- base::grepl
[10:31:26.480]                         restarts <- computeRestarts(cond)
[10:31:26.480]                         for (restart in restarts) {
[10:31:26.480]                           name <- restart$name
[10:31:26.480]                           if (is.null(name)) 
[10:31:26.480]                             next
[10:31:26.480]                           if (!grepl(pattern, name)) 
[10:31:26.480]                             next
[10:31:26.480]                           invokeRestart(restart)
[10:31:26.480]                           muffled <- TRUE
[10:31:26.480]                           break
[10:31:26.480]                         }
[10:31:26.480]                       }
[10:31:26.480]                     }
[10:31:26.480]                     invisible(muffled)
[10:31:26.480]                   }
[10:31:26.480]                   muffleCondition(cond)
[10:31:26.480]                 })
[10:31:26.480]             }))
[10:31:26.480]             future::FutureResult(value = ...future.value$value, 
[10:31:26.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:26.480]                   ...future.rng), globalenv = if (FALSE) 
[10:31:26.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:26.480]                     ...future.globalenv.names))
[10:31:26.480]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:26.480]         }, condition = base::local({
[10:31:26.480]             c <- base::c
[10:31:26.480]             inherits <- base::inherits
[10:31:26.480]             invokeRestart <- base::invokeRestart
[10:31:26.480]             length <- base::length
[10:31:26.480]             list <- base::list
[10:31:26.480]             seq.int <- base::seq.int
[10:31:26.480]             signalCondition <- base::signalCondition
[10:31:26.480]             sys.calls <- base::sys.calls
[10:31:26.480]             `[[` <- base::`[[`
[10:31:26.480]             `+` <- base::`+`
[10:31:26.480]             `<<-` <- base::`<<-`
[10:31:26.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:26.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:26.480]                   3L)]
[10:31:26.480]             }
[10:31:26.480]             function(cond) {
[10:31:26.480]                 is_error <- inherits(cond, "error")
[10:31:26.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:26.480]                   NULL)
[10:31:26.480]                 if (is_error) {
[10:31:26.480]                   sessionInformation <- function() {
[10:31:26.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:26.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:26.480]                       search = base::search(), system = base::Sys.info())
[10:31:26.480]                   }
[10:31:26.480]                   ...future.conditions[[length(...future.conditions) + 
[10:31:26.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:26.480]                     cond$call), session = sessionInformation(), 
[10:31:26.480]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:26.480]                   signalCondition(cond)
[10:31:26.480]                 }
[10:31:26.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:26.480]                 "immediateCondition"))) {
[10:31:26.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:26.480]                   ...future.conditions[[length(...future.conditions) + 
[10:31:26.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:26.480]                   if (TRUE && !signal) {
[10:31:26.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.480]                     {
[10:31:26.480]                       inherits <- base::inherits
[10:31:26.480]                       invokeRestart <- base::invokeRestart
[10:31:26.480]                       is.null <- base::is.null
[10:31:26.480]                       muffled <- FALSE
[10:31:26.480]                       if (inherits(cond, "message")) {
[10:31:26.480]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:26.480]                         if (muffled) 
[10:31:26.480]                           invokeRestart("muffleMessage")
[10:31:26.480]                       }
[10:31:26.480]                       else if (inherits(cond, "warning")) {
[10:31:26.480]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:26.480]                         if (muffled) 
[10:31:26.480]                           invokeRestart("muffleWarning")
[10:31:26.480]                       }
[10:31:26.480]                       else if (inherits(cond, "condition")) {
[10:31:26.480]                         if (!is.null(pattern)) {
[10:31:26.480]                           computeRestarts <- base::computeRestarts
[10:31:26.480]                           grepl <- base::grepl
[10:31:26.480]                           restarts <- computeRestarts(cond)
[10:31:26.480]                           for (restart in restarts) {
[10:31:26.480]                             name <- restart$name
[10:31:26.480]                             if (is.null(name)) 
[10:31:26.480]                               next
[10:31:26.480]                             if (!grepl(pattern, name)) 
[10:31:26.480]                               next
[10:31:26.480]                             invokeRestart(restart)
[10:31:26.480]                             muffled <- TRUE
[10:31:26.480]                             break
[10:31:26.480]                           }
[10:31:26.480]                         }
[10:31:26.480]                       }
[10:31:26.480]                       invisible(muffled)
[10:31:26.480]                     }
[10:31:26.480]                     muffleCondition(cond, pattern = "^muffle")
[10:31:26.480]                   }
[10:31:26.480]                 }
[10:31:26.480]                 else {
[10:31:26.480]                   if (TRUE) {
[10:31:26.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.480]                     {
[10:31:26.480]                       inherits <- base::inherits
[10:31:26.480]                       invokeRestart <- base::invokeRestart
[10:31:26.480]                       is.null <- base::is.null
[10:31:26.480]                       muffled <- FALSE
[10:31:26.480]                       if (inherits(cond, "message")) {
[10:31:26.480]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:26.480]                         if (muffled) 
[10:31:26.480]                           invokeRestart("muffleMessage")
[10:31:26.480]                       }
[10:31:26.480]                       else if (inherits(cond, "warning")) {
[10:31:26.480]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:26.480]                         if (muffled) 
[10:31:26.480]                           invokeRestart("muffleWarning")
[10:31:26.480]                       }
[10:31:26.480]                       else if (inherits(cond, "condition")) {
[10:31:26.480]                         if (!is.null(pattern)) {
[10:31:26.480]                           computeRestarts <- base::computeRestarts
[10:31:26.480]                           grepl <- base::grepl
[10:31:26.480]                           restarts <- computeRestarts(cond)
[10:31:26.480]                           for (restart in restarts) {
[10:31:26.480]                             name <- restart$name
[10:31:26.480]                             if (is.null(name)) 
[10:31:26.480]                               next
[10:31:26.480]                             if (!grepl(pattern, name)) 
[10:31:26.480]                               next
[10:31:26.480]                             invokeRestart(restart)
[10:31:26.480]                             muffled <- TRUE
[10:31:26.480]                             break
[10:31:26.480]                           }
[10:31:26.480]                         }
[10:31:26.480]                       }
[10:31:26.480]                       invisible(muffled)
[10:31:26.480]                     }
[10:31:26.480]                     muffleCondition(cond, pattern = "^muffle")
[10:31:26.480]                   }
[10:31:26.480]                 }
[10:31:26.480]             }
[10:31:26.480]         }))
[10:31:26.480]     }, error = function(ex) {
[10:31:26.480]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:26.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:26.480]                 ...future.rng), started = ...future.startTime, 
[10:31:26.480]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:26.480]             version = "1.8"), class = "FutureResult")
[10:31:26.480]     }, finally = {
[10:31:26.480]         if (!identical(...future.workdir, getwd())) 
[10:31:26.480]             setwd(...future.workdir)
[10:31:26.480]         {
[10:31:26.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:26.480]                 ...future.oldOptions$nwarnings <- NULL
[10:31:26.480]             }
[10:31:26.480]             base::options(...future.oldOptions)
[10:31:26.480]             if (.Platform$OS.type == "windows") {
[10:31:26.480]                 old_names <- names(...future.oldEnvVars)
[10:31:26.480]                 envs <- base::Sys.getenv()
[10:31:26.480]                 names <- names(envs)
[10:31:26.480]                 common <- intersect(names, old_names)
[10:31:26.480]                 added <- setdiff(names, old_names)
[10:31:26.480]                 removed <- setdiff(old_names, names)
[10:31:26.480]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:26.480]                   envs[common]]
[10:31:26.480]                 NAMES <- toupper(changed)
[10:31:26.480]                 args <- list()
[10:31:26.480]                 for (kk in seq_along(NAMES)) {
[10:31:26.480]                   name <- changed[[kk]]
[10:31:26.480]                   NAME <- NAMES[[kk]]
[10:31:26.480]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.480]                     next
[10:31:26.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:26.480]                 }
[10:31:26.480]                 NAMES <- toupper(added)
[10:31:26.480]                 for (kk in seq_along(NAMES)) {
[10:31:26.480]                   name <- added[[kk]]
[10:31:26.480]                   NAME <- NAMES[[kk]]
[10:31:26.480]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.480]                     next
[10:31:26.480]                   args[[name]] <- ""
[10:31:26.480]                 }
[10:31:26.480]                 NAMES <- toupper(removed)
[10:31:26.480]                 for (kk in seq_along(NAMES)) {
[10:31:26.480]                   name <- removed[[kk]]
[10:31:26.480]                   NAME <- NAMES[[kk]]
[10:31:26.480]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.480]                     next
[10:31:26.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:26.480]                 }
[10:31:26.480]                 if (length(args) > 0) 
[10:31:26.480]                   base::do.call(base::Sys.setenv, args = args)
[10:31:26.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:26.480]             }
[10:31:26.480]             else {
[10:31:26.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:26.480]             }
[10:31:26.480]             {
[10:31:26.480]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:26.480]                   0L) {
[10:31:26.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:26.480]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:26.480]                   base::options(opts)
[10:31:26.480]                 }
[10:31:26.480]                 {
[10:31:26.480]                   {
[10:31:26.480]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:26.480]                     NULL
[10:31:26.480]                   }
[10:31:26.480]                   options(future.plan = NULL)
[10:31:26.480]                   if (is.na(NA_character_)) 
[10:31:26.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:26.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:26.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:26.480]                     .init = FALSE)
[10:31:26.480]                 }
[10:31:26.480]             }
[10:31:26.480]         }
[10:31:26.480]     })
[10:31:26.480]     if (TRUE) {
[10:31:26.480]         base::sink(type = "output", split = FALSE)
[10:31:26.480]         if (TRUE) {
[10:31:26.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:26.480]         }
[10:31:26.480]         else {
[10:31:26.480]             ...future.result["stdout"] <- base::list(NULL)
[10:31:26.480]         }
[10:31:26.480]         base::close(...future.stdout)
[10:31:26.480]         ...future.stdout <- NULL
[10:31:26.480]     }
[10:31:26.480]     ...future.result$conditions <- ...future.conditions
[10:31:26.480]     ...future.result$finished <- base::Sys.time()
[10:31:26.480]     ...future.result
[10:31:26.480] }
[10:31:26.482] Exporting 11 global objects (93.16 KiB) to cluster node #2 ...
[10:31:26.483] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:31:26.525] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:31:26.526] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ...
[10:31:26.526] Exporting ‘x_FUN’ (1.16 KiB) to cluster node #2 ... DONE
[10:31:26.526] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:31:26.527] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:31:26.527] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:31:26.569] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:31:26.569] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:31:26.613] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:31:26.614] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:31:26.614] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:31:26.614] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ...
[10:31:26.615] Exporting ‘valid_types’ (176 bytes) to cluster node #2 ... DONE
[10:31:26.615] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:31:26.615] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:31:26.615] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:31:26.616] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:31:26.616] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:26.616] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:26.616] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:26.617] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:26.617] Exporting 11 global objects (93.16 KiB) to cluster node #2 ... DONE
[10:31:26.618] MultisessionFuture started
[10:31:26.618] - Launch lazy future ... done
[10:31:26.618] run() for ‘MultisessionFuture’ ... done
[10:31:26.618] Created future:
[10:31:26.618] MultisessionFuture:
[10:31:26.618] Label: ‘future_vapply-2’
[10:31:26.618] Expression:
[10:31:26.618] {
[10:31:26.618]     do.call(function(...) {
[10:31:26.618]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.618]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:26.618]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.618]             on.exit(options(oopts), add = TRUE)
[10:31:26.618]         }
[10:31:26.618]         {
[10:31:26.618]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:26.618]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.618]                 ...future.FUN(...future.X_jj, ...)
[10:31:26.618]             })
[10:31:26.618]         }
[10:31:26.618]     }, args = future.call.arguments)
[10:31:26.618] }
[10:31:26.618] Lazy evaluation: FALSE
[10:31:26.618] Asynchronous evaluation: TRUE
[10:31:26.618] Local evaluation: TRUE
[10:31:26.618] Environment: R_GlobalEnv
[10:31:26.618] Capture standard output: TRUE
[10:31:26.618] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:26.618] Globals: 11 objects totaling 93.44 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.16 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:26.618] Packages: 1 packages (‘future.apply’)
[10:31:26.618] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:26.618] Resolved: FALSE
[10:31:26.618] Value: <not collected>
[10:31:26.618] Conditions captured: <none>
[10:31:26.618] Early signaling: FALSE
[10:31:26.618] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:26.618] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:26.630] Chunk #2 of 2 ... DONE
[10:31:26.630] Launching 2 futures (chunks) ... DONE
[10:31:26.630] Resolving 2 futures (chunks) ...
[10:31:26.630] resolve() on list ...
[10:31:26.630]  recursive: 0
[10:31:26.631]  length: 2
[10:31:26.631] 
[10:31:26.631] receiveMessageFromWorker() for ClusterFuture ...
[10:31:26.631] - Validating connection of MultisessionFuture
[10:31:26.631] - received message: FutureResult
[10:31:26.632] - Received FutureResult
[10:31:26.632] - Erased future from FutureRegistry
[10:31:26.632] result() for ClusterFuture ...
[10:31:26.632] - result already collected: FutureResult
[10:31:26.632] result() for ClusterFuture ... done
[10:31:26.632] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:26.632] Future #1
[10:31:26.632] result() for ClusterFuture ...
[10:31:26.632] - result already collected: FutureResult
[10:31:26.632] result() for ClusterFuture ... done
[10:31:26.633] result() for ClusterFuture ...
[10:31:26.633] - result already collected: FutureResult
[10:31:26.633] result() for ClusterFuture ... done
[10:31:26.633] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:26.633] - nx: 2
[10:31:26.633] - relay: TRUE
[10:31:26.633] - stdout: TRUE
[10:31:26.633] - signal: TRUE
[10:31:26.633] - resignal: FALSE
[10:31:26.633] - force: TRUE
[10:31:26.633] - relayed: [n=2] FALSE, FALSE
[10:31:26.634] - queued futures: [n=2] FALSE, FALSE
[10:31:26.634]  - until=1
[10:31:26.634]  - relaying element #1
[10:31:26.634] result() for ClusterFuture ...
[10:31:26.634] - result already collected: FutureResult
[10:31:26.634] result() for ClusterFuture ... done
[10:31:26.634] result() for ClusterFuture ...
[10:31:26.634] - result already collected: FutureResult
[10:31:26.634] result() for ClusterFuture ... done
[10:31:26.634] result() for ClusterFuture ...
[10:31:26.634] - result already collected: FutureResult
[10:31:26.635] result() for ClusterFuture ... done
[10:31:26.635] result() for ClusterFuture ...
[10:31:26.635] - result already collected: FutureResult
[10:31:26.635] result() for ClusterFuture ... done
[10:31:26.635] - relayed: [n=2] TRUE, FALSE
[10:31:26.635] - queued futures: [n=2] TRUE, FALSE
[10:31:26.635] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:26.635]  length: 1 (resolved future 1)
[10:31:26.663] receiveMessageFromWorker() for ClusterFuture ...
[10:31:26.663] - Validating connection of MultisessionFuture
[10:31:26.663] - received message: FutureResult
[10:31:26.663] - Received FutureResult
[10:31:26.663] - Erased future from FutureRegistry
[10:31:26.663] result() for ClusterFuture ...
[10:31:26.664] - result already collected: FutureResult
[10:31:26.664] result() for ClusterFuture ... done
[10:31:26.664] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:26.664] Future #2
[10:31:26.664] result() for ClusterFuture ...
[10:31:26.664] - result already collected: FutureResult
[10:31:26.664] result() for ClusterFuture ... done
[10:31:26.664] result() for ClusterFuture ...
[10:31:26.664] - result already collected: FutureResult
[10:31:26.664] result() for ClusterFuture ... done
[10:31:26.665] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:26.665] - nx: 2
[10:31:26.665] - relay: TRUE
[10:31:26.665] - stdout: TRUE
[10:31:26.665] - signal: TRUE
[10:31:26.665] - resignal: FALSE
[10:31:26.665] - force: TRUE
[10:31:26.665] - relayed: [n=2] TRUE, FALSE
[10:31:26.665] - queued futures: [n=2] TRUE, FALSE
[10:31:26.665]  - until=2
[10:31:26.665]  - relaying element #2
[10:31:26.666] result() for ClusterFuture ...
[10:31:26.666] - result already collected: FutureResult
[10:31:26.666] result() for ClusterFuture ... done
[10:31:26.666] result() for ClusterFuture ...
[10:31:26.666] - result already collected: FutureResult
[10:31:26.666] result() for ClusterFuture ... done
[10:31:26.666] result() for ClusterFuture ...
[10:31:26.666] - result already collected: FutureResult
[10:31:26.666] result() for ClusterFuture ... done
[10:31:26.666] result() for ClusterFuture ...
[10:31:26.667] - result already collected: FutureResult
[10:31:26.667] result() for ClusterFuture ... done
[10:31:26.667] - relayed: [n=2] TRUE, TRUE
[10:31:26.667] - queued futures: [n=2] TRUE, TRUE
[10:31:26.667] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:26.667]  length: 0 (resolved future 2)
[10:31:26.667] Relaying remaining futures
[10:31:26.667] signalConditionsASAP(NULL, pos=0) ...
[10:31:26.667] - nx: 2
[10:31:26.667] - relay: TRUE
[10:31:26.667] - stdout: TRUE
[10:31:26.667] - signal: TRUE
[10:31:26.668] - resignal: FALSE
[10:31:26.668] - force: TRUE
[10:31:26.668] - relayed: [n=2] TRUE, TRUE
[10:31:26.668] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:26.668] - relayed: [n=2] TRUE, TRUE
[10:31:26.668] - queued futures: [n=2] TRUE, TRUE
[10:31:26.668] signalConditionsASAP(NULL, pos=0) ... done
[10:31:26.668] resolve() on list ... DONE
[10:31:26.668] result() for ClusterFuture ...
[10:31:26.668] - result already collected: FutureResult
[10:31:26.669] result() for ClusterFuture ... done
[10:31:26.669] result() for ClusterFuture ...
[10:31:26.669] - result already collected: FutureResult
[10:31:26.669] result() for ClusterFuture ... done
[10:31:26.669] result() for ClusterFuture ...
[10:31:26.669] - result already collected: FutureResult
[10:31:26.669] result() for ClusterFuture ... done
[10:31:26.669] result() for ClusterFuture ...
[10:31:26.669] - result already collected: FutureResult
[10:31:26.669] result() for ClusterFuture ... done
[10:31:26.669]  - Number of value chunks collected: 2
[10:31:26.670] Resolving 2 futures (chunks) ... DONE
[10:31:26.670] Reducing values from 2 chunks ...
[10:31:26.670]  - Number of values collected after concatenation: 10
[10:31:26.670]  - Number of values expected: 10
[10:31:26.670] Reducing values from 2 chunks ... DONE
[10:31:26.670] future_lapply() ... DONE
 int[0 , 1:10] 
 num [1:10] 1 1.41 1.73 2 2.24 ...
[10:31:26.671] future_lapply() ...
[10:31:26.677] Number of chunks: 2
[10:31:26.677] getGlobalsAndPackagesXApply() ...
[10:31:26.677]  - future.globals: TRUE
[10:31:26.677] getGlobalsAndPackages() ...
[10:31:26.677] Searching for globals...
[10:31:26.680] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:26.680] Searching for globals ... DONE
[10:31:26.680] Resolving globals: FALSE
[10:31:26.681] The total size of the 7 globals is 92.12 KiB (94336 bytes)
[10:31:26.681] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.12 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:26.682] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:26.682] - packages: [1] ‘future.apply’
[10:31:26.682] getGlobalsAndPackages() ... DONE
[10:31:26.682]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:26.682]  - needed namespaces: [n=1] ‘future.apply’
[10:31:26.682] Finding globals ... DONE
[10:31:26.682]  - use_args: TRUE
[10:31:26.682]  - Getting '...' globals ...
[10:31:26.683] resolve() on list ...
[10:31:26.683]  recursive: 0
[10:31:26.683]  length: 1
[10:31:26.683]  elements: ‘...’
[10:31:26.683]  length: 0 (resolved future 1)
[10:31:26.683] resolve() on list ... DONE
[10:31:26.683]    - '...' content: [n=0] 
[10:31:26.683] List of 1
[10:31:26.683]  $ ...: list()
[10:31:26.683]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:26.683]  - attr(*, "where")=List of 1
[10:31:26.683]   ..$ ...:<environment: 0x55de87fa2be0> 
[10:31:26.683]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:26.683]  - attr(*, "resolved")= logi TRUE
[10:31:26.683]  - attr(*, "total_size")= num NA
[10:31:26.686]  - Getting '...' globals ... DONE
[10:31:26.686] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:26.686] List of 8
[10:31:26.686]  $ ...future.FUN:function (x, ...)  
[10:31:26.686]  $ x_FUN        :function (x)  
[10:31:26.686]  $ times        : int 1
[10:31:26.686]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:26.686]  $ stop_if_not  :function (...)  
[10:31:26.686]  $ dim          : NULL
[10:31:26.686]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:26.686]  $ ...          : list()
[10:31:26.686]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:26.686]  - attr(*, "where")=List of 8
[10:31:26.686]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:26.686]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:26.686]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:26.686]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:26.686]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:26.686]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:26.686]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:26.686]   ..$ ...          :<environment: 0x55de87fa2be0> 
[10:31:26.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:26.686]  - attr(*, "resolved")= logi FALSE
[10:31:26.686]  - attr(*, "total_size")= num 94336
[10:31:26.693] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:26.693] getGlobalsAndPackagesXApply() ... DONE
[10:31:26.694] Number of futures (= number of chunks): 2
[10:31:26.694] Launching 2 futures (chunks) ...
[10:31:26.694] Chunk #1 of 2 ...
[10:31:26.694]  - Finding globals in 'X' for chunk #1 ...
[10:31:26.694] getGlobalsAndPackages() ...
[10:31:26.694] Searching for globals...
[10:31:26.694] 
[10:31:26.695] Searching for globals ... DONE
[10:31:26.695] - globals: [0] <none>
[10:31:26.695] getGlobalsAndPackages() ... DONE
[10:31:26.695]    + additional globals found: [n=0] 
[10:31:26.695]    + additional namespaces needed: [n=0] 
[10:31:26.695]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:26.695]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:26.695]  - seeds: <none>
[10:31:26.695]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.695] getGlobalsAndPackages() ...
[10:31:26.695] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.696] Resolving globals: FALSE
[10:31:26.696] Tweak future expression to call with '...' arguments ...
[10:31:26.696] {
[10:31:26.696]     do.call(function(...) {
[10:31:26.696]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.696]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:26.696]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.696]             on.exit(options(oopts), add = TRUE)
[10:31:26.696]         }
[10:31:26.696]         {
[10:31:26.696]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:26.696]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.696]                 ...future.FUN(...future.X_jj, ...)
[10:31:26.696]             })
[10:31:26.696]         }
[10:31:26.696]     }, args = future.call.arguments)
[10:31:26.696] }
[10:31:26.696] Tweak future expression to call with '...' arguments ... DONE
[10:31:26.697] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.697] - packages: [1] ‘future.apply’
[10:31:26.697] getGlobalsAndPackages() ... DONE
[10:31:26.697] run() for ‘Future’ ...
[10:31:26.697] - state: ‘created’
[10:31:26.697] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:26.712] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:26.712] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:26.712]   - Field: ‘node’
[10:31:26.713]   - Field: ‘label’
[10:31:26.713]   - Field: ‘local’
[10:31:26.713]   - Field: ‘owner’
[10:31:26.713]   - Field: ‘envir’
[10:31:26.713]   - Field: ‘workers’
[10:31:26.713]   - Field: ‘packages’
[10:31:26.713]   - Field: ‘gc’
[10:31:26.713]   - Field: ‘conditions’
[10:31:26.713]   - Field: ‘persistent’
[10:31:26.713]   - Field: ‘expr’
[10:31:26.714]   - Field: ‘uuid’
[10:31:26.714]   - Field: ‘seed’
[10:31:26.714]   - Field: ‘version’
[10:31:26.714]   - Field: ‘result’
[10:31:26.714]   - Field: ‘asynchronous’
[10:31:26.714]   - Field: ‘calls’
[10:31:26.714]   - Field: ‘globals’
[10:31:26.714]   - Field: ‘stdout’
[10:31:26.714]   - Field: ‘earlySignal’
[10:31:26.714]   - Field: ‘lazy’
[10:31:26.714]   - Field: ‘state’
[10:31:26.715] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:26.715] - Launch lazy future ...
[10:31:26.715] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:26.715] Packages needed by future strategies (n = 0): <none>
[10:31:26.716] {
[10:31:26.716]     {
[10:31:26.716]         {
[10:31:26.716]             ...future.startTime <- base::Sys.time()
[10:31:26.716]             {
[10:31:26.716]                 {
[10:31:26.716]                   {
[10:31:26.716]                     {
[10:31:26.716]                       {
[10:31:26.716]                         base::local({
[10:31:26.716]                           has_future <- base::requireNamespace("future", 
[10:31:26.716]                             quietly = TRUE)
[10:31:26.716]                           if (has_future) {
[10:31:26.716]                             ns <- base::getNamespace("future")
[10:31:26.716]                             version <- ns[[".package"]][["version"]]
[10:31:26.716]                             if (is.null(version)) 
[10:31:26.716]                               version <- utils::packageVersion("future")
[10:31:26.716]                           }
[10:31:26.716]                           else {
[10:31:26.716]                             version <- NULL
[10:31:26.716]                           }
[10:31:26.716]                           if (!has_future || version < "1.8.0") {
[10:31:26.716]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:26.716]                               "", base::R.version$version.string), 
[10:31:26.716]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:26.716]                                 base::R.version$platform, 8 * 
[10:31:26.716]                                   base::.Machine$sizeof.pointer), 
[10:31:26.716]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:26.716]                                 "release", "version")], collapse = " "), 
[10:31:26.716]                               hostname = base::Sys.info()[["nodename"]])
[10:31:26.716]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:26.716]                               info)
[10:31:26.716]                             info <- base::paste(info, collapse = "; ")
[10:31:26.716]                             if (!has_future) {
[10:31:26.716]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:26.716]                                 info)
[10:31:26.716]                             }
[10:31:26.716]                             else {
[10:31:26.716]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:26.716]                                 info, version)
[10:31:26.716]                             }
[10:31:26.716]                             base::stop(msg)
[10:31:26.716]                           }
[10:31:26.716]                         })
[10:31:26.716]                       }
[10:31:26.716]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:26.716]                       base::options(mc.cores = 1L)
[10:31:26.716]                     }
[10:31:26.716]                     base::local({
[10:31:26.716]                       for (pkg in "future.apply") {
[10:31:26.716]                         base::loadNamespace(pkg)
[10:31:26.716]                         base::library(pkg, character.only = TRUE)
[10:31:26.716]                       }
[10:31:26.716]                     })
[10:31:26.716]                   }
[10:31:26.716]                   ...future.strategy.old <- future::plan("list")
[10:31:26.716]                   options(future.plan = NULL)
[10:31:26.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:26.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:26.716]                 }
[10:31:26.716]                 ...future.workdir <- getwd()
[10:31:26.716]             }
[10:31:26.716]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:26.716]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:26.716]         }
[10:31:26.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:26.716]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:26.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:26.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:26.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:26.716]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:26.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:26.716]             base::names(...future.oldOptions))
[10:31:26.716]     }
[10:31:26.716]     if (FALSE) {
[10:31:26.716]     }
[10:31:26.716]     else {
[10:31:26.716]         if (TRUE) {
[10:31:26.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:26.716]                 open = "w")
[10:31:26.716]         }
[10:31:26.716]         else {
[10:31:26.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:26.716]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:26.716]         }
[10:31:26.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:26.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:26.716]             base::sink(type = "output", split = FALSE)
[10:31:26.716]             base::close(...future.stdout)
[10:31:26.716]         }, add = TRUE)
[10:31:26.716]     }
[10:31:26.716]     ...future.frame <- base::sys.nframe()
[10:31:26.716]     ...future.conditions <- base::list()
[10:31:26.716]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:26.716]     if (FALSE) {
[10:31:26.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:26.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:26.716]     }
[10:31:26.716]     ...future.result <- base::tryCatch({
[10:31:26.716]         base::withCallingHandlers({
[10:31:26.716]             ...future.value <- base::withVisible(base::local({
[10:31:26.716]                 ...future.makeSendCondition <- base::local({
[10:31:26.716]                   sendCondition <- NULL
[10:31:26.716]                   function(frame = 1L) {
[10:31:26.716]                     if (is.function(sendCondition)) 
[10:31:26.716]                       return(sendCondition)
[10:31:26.716]                     ns <- getNamespace("parallel")
[10:31:26.716]                     if (exists("sendData", mode = "function", 
[10:31:26.716]                       envir = ns)) {
[10:31:26.716]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:26.716]                         envir = ns)
[10:31:26.716]                       envir <- sys.frame(frame)
[10:31:26.716]                       master <- NULL
[10:31:26.716]                       while (!identical(envir, .GlobalEnv) && 
[10:31:26.716]                         !identical(envir, emptyenv())) {
[10:31:26.716]                         if (exists("master", mode = "list", envir = envir, 
[10:31:26.716]                           inherits = FALSE)) {
[10:31:26.716]                           master <- get("master", mode = "list", 
[10:31:26.716]                             envir = envir, inherits = FALSE)
[10:31:26.716]                           if (inherits(master, c("SOCKnode", 
[10:31:26.716]                             "SOCK0node"))) {
[10:31:26.716]                             sendCondition <<- function(cond) {
[10:31:26.716]                               data <- list(type = "VALUE", value = cond, 
[10:31:26.716]                                 success = TRUE)
[10:31:26.716]                               parallel_sendData(master, data)
[10:31:26.716]                             }
[10:31:26.716]                             return(sendCondition)
[10:31:26.716]                           }
[10:31:26.716]                         }
[10:31:26.716]                         frame <- frame + 1L
[10:31:26.716]                         envir <- sys.frame(frame)
[10:31:26.716]                       }
[10:31:26.716]                     }
[10:31:26.716]                     sendCondition <<- function(cond) NULL
[10:31:26.716]                   }
[10:31:26.716]                 })
[10:31:26.716]                 withCallingHandlers({
[10:31:26.716]                   {
[10:31:26.716]                     do.call(function(...) {
[10:31:26.716]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.716]                       if (!identical(...future.globals.maxSize.org, 
[10:31:26.716]                         ...future.globals.maxSize)) {
[10:31:26.716]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.716]                         on.exit(options(oopts), add = TRUE)
[10:31:26.716]                       }
[10:31:26.716]                       {
[10:31:26.716]                         lapply(seq_along(...future.elements_ii), 
[10:31:26.716]                           FUN = function(jj) {
[10:31:26.716]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.716]                             ...future.FUN(...future.X_jj, ...)
[10:31:26.716]                           })
[10:31:26.716]                       }
[10:31:26.716]                     }, args = future.call.arguments)
[10:31:26.716]                   }
[10:31:26.716]                 }, immediateCondition = function(cond) {
[10:31:26.716]                   sendCondition <- ...future.makeSendCondition()
[10:31:26.716]                   sendCondition(cond)
[10:31:26.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.716]                   {
[10:31:26.716]                     inherits <- base::inherits
[10:31:26.716]                     invokeRestart <- base::invokeRestart
[10:31:26.716]                     is.null <- base::is.null
[10:31:26.716]                     muffled <- FALSE
[10:31:26.716]                     if (inherits(cond, "message")) {
[10:31:26.716]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:26.716]                       if (muffled) 
[10:31:26.716]                         invokeRestart("muffleMessage")
[10:31:26.716]                     }
[10:31:26.716]                     else if (inherits(cond, "warning")) {
[10:31:26.716]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:26.716]                       if (muffled) 
[10:31:26.716]                         invokeRestart("muffleWarning")
[10:31:26.716]                     }
[10:31:26.716]                     else if (inherits(cond, "condition")) {
[10:31:26.716]                       if (!is.null(pattern)) {
[10:31:26.716]                         computeRestarts <- base::computeRestarts
[10:31:26.716]                         grepl <- base::grepl
[10:31:26.716]                         restarts <- computeRestarts(cond)
[10:31:26.716]                         for (restart in restarts) {
[10:31:26.716]                           name <- restart$name
[10:31:26.716]                           if (is.null(name)) 
[10:31:26.716]                             next
[10:31:26.716]                           if (!grepl(pattern, name)) 
[10:31:26.716]                             next
[10:31:26.716]                           invokeRestart(restart)
[10:31:26.716]                           muffled <- TRUE
[10:31:26.716]                           break
[10:31:26.716]                         }
[10:31:26.716]                       }
[10:31:26.716]                     }
[10:31:26.716]                     invisible(muffled)
[10:31:26.716]                   }
[10:31:26.716]                   muffleCondition(cond)
[10:31:26.716]                 })
[10:31:26.716]             }))
[10:31:26.716]             future::FutureResult(value = ...future.value$value, 
[10:31:26.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:26.716]                   ...future.rng), globalenv = if (FALSE) 
[10:31:26.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:26.716]                     ...future.globalenv.names))
[10:31:26.716]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:26.716]         }, condition = base::local({
[10:31:26.716]             c <- base::c
[10:31:26.716]             inherits <- base::inherits
[10:31:26.716]             invokeRestart <- base::invokeRestart
[10:31:26.716]             length <- base::length
[10:31:26.716]             list <- base::list
[10:31:26.716]             seq.int <- base::seq.int
[10:31:26.716]             signalCondition <- base::signalCondition
[10:31:26.716]             sys.calls <- base::sys.calls
[10:31:26.716]             `[[` <- base::`[[`
[10:31:26.716]             `+` <- base::`+`
[10:31:26.716]             `<<-` <- base::`<<-`
[10:31:26.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:26.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:26.716]                   3L)]
[10:31:26.716]             }
[10:31:26.716]             function(cond) {
[10:31:26.716]                 is_error <- inherits(cond, "error")
[10:31:26.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:26.716]                   NULL)
[10:31:26.716]                 if (is_error) {
[10:31:26.716]                   sessionInformation <- function() {
[10:31:26.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:26.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:26.716]                       search = base::search(), system = base::Sys.info())
[10:31:26.716]                   }
[10:31:26.716]                   ...future.conditions[[length(...future.conditions) + 
[10:31:26.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:26.716]                     cond$call), session = sessionInformation(), 
[10:31:26.716]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:26.716]                   signalCondition(cond)
[10:31:26.716]                 }
[10:31:26.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:26.716]                 "immediateCondition"))) {
[10:31:26.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:26.716]                   ...future.conditions[[length(...future.conditions) + 
[10:31:26.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:26.716]                   if (TRUE && !signal) {
[10:31:26.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.716]                     {
[10:31:26.716]                       inherits <- base::inherits
[10:31:26.716]                       invokeRestart <- base::invokeRestart
[10:31:26.716]                       is.null <- base::is.null
[10:31:26.716]                       muffled <- FALSE
[10:31:26.716]                       if (inherits(cond, "message")) {
[10:31:26.716]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:26.716]                         if (muffled) 
[10:31:26.716]                           invokeRestart("muffleMessage")
[10:31:26.716]                       }
[10:31:26.716]                       else if (inherits(cond, "warning")) {
[10:31:26.716]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:26.716]                         if (muffled) 
[10:31:26.716]                           invokeRestart("muffleWarning")
[10:31:26.716]                       }
[10:31:26.716]                       else if (inherits(cond, "condition")) {
[10:31:26.716]                         if (!is.null(pattern)) {
[10:31:26.716]                           computeRestarts <- base::computeRestarts
[10:31:26.716]                           grepl <- base::grepl
[10:31:26.716]                           restarts <- computeRestarts(cond)
[10:31:26.716]                           for (restart in restarts) {
[10:31:26.716]                             name <- restart$name
[10:31:26.716]                             if (is.null(name)) 
[10:31:26.716]                               next
[10:31:26.716]                             if (!grepl(pattern, name)) 
[10:31:26.716]                               next
[10:31:26.716]                             invokeRestart(restart)
[10:31:26.716]                             muffled <- TRUE
[10:31:26.716]                             break
[10:31:26.716]                           }
[10:31:26.716]                         }
[10:31:26.716]                       }
[10:31:26.716]                       invisible(muffled)
[10:31:26.716]                     }
[10:31:26.716]                     muffleCondition(cond, pattern = "^muffle")
[10:31:26.716]                   }
[10:31:26.716]                 }
[10:31:26.716]                 else {
[10:31:26.716]                   if (TRUE) {
[10:31:26.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.716]                     {
[10:31:26.716]                       inherits <- base::inherits
[10:31:26.716]                       invokeRestart <- base::invokeRestart
[10:31:26.716]                       is.null <- base::is.null
[10:31:26.716]                       muffled <- FALSE
[10:31:26.716]                       if (inherits(cond, "message")) {
[10:31:26.716]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:26.716]                         if (muffled) 
[10:31:26.716]                           invokeRestart("muffleMessage")
[10:31:26.716]                       }
[10:31:26.716]                       else if (inherits(cond, "warning")) {
[10:31:26.716]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:26.716]                         if (muffled) 
[10:31:26.716]                           invokeRestart("muffleWarning")
[10:31:26.716]                       }
[10:31:26.716]                       else if (inherits(cond, "condition")) {
[10:31:26.716]                         if (!is.null(pattern)) {
[10:31:26.716]                           computeRestarts <- base::computeRestarts
[10:31:26.716]                           grepl <- base::grepl
[10:31:26.716]                           restarts <- computeRestarts(cond)
[10:31:26.716]                           for (restart in restarts) {
[10:31:26.716]                             name <- restart$name
[10:31:26.716]                             if (is.null(name)) 
[10:31:26.716]                               next
[10:31:26.716]                             if (!grepl(pattern, name)) 
[10:31:26.716]                               next
[10:31:26.716]                             invokeRestart(restart)
[10:31:26.716]                             muffled <- TRUE
[10:31:26.716]                             break
[10:31:26.716]                           }
[10:31:26.716]                         }
[10:31:26.716]                       }
[10:31:26.716]                       invisible(muffled)
[10:31:26.716]                     }
[10:31:26.716]                     muffleCondition(cond, pattern = "^muffle")
[10:31:26.716]                   }
[10:31:26.716]                 }
[10:31:26.716]             }
[10:31:26.716]         }))
[10:31:26.716]     }, error = function(ex) {
[10:31:26.716]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:26.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:26.716]                 ...future.rng), started = ...future.startTime, 
[10:31:26.716]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:26.716]             version = "1.8"), class = "FutureResult")
[10:31:26.716]     }, finally = {
[10:31:26.716]         if (!identical(...future.workdir, getwd())) 
[10:31:26.716]             setwd(...future.workdir)
[10:31:26.716]         {
[10:31:26.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:26.716]                 ...future.oldOptions$nwarnings <- NULL
[10:31:26.716]             }
[10:31:26.716]             base::options(...future.oldOptions)
[10:31:26.716]             if (.Platform$OS.type == "windows") {
[10:31:26.716]                 old_names <- names(...future.oldEnvVars)
[10:31:26.716]                 envs <- base::Sys.getenv()
[10:31:26.716]                 names <- names(envs)
[10:31:26.716]                 common <- intersect(names, old_names)
[10:31:26.716]                 added <- setdiff(names, old_names)
[10:31:26.716]                 removed <- setdiff(old_names, names)
[10:31:26.716]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:26.716]                   envs[common]]
[10:31:26.716]                 NAMES <- toupper(changed)
[10:31:26.716]                 args <- list()
[10:31:26.716]                 for (kk in seq_along(NAMES)) {
[10:31:26.716]                   name <- changed[[kk]]
[10:31:26.716]                   NAME <- NAMES[[kk]]
[10:31:26.716]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.716]                     next
[10:31:26.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:26.716]                 }
[10:31:26.716]                 NAMES <- toupper(added)
[10:31:26.716]                 for (kk in seq_along(NAMES)) {
[10:31:26.716]                   name <- added[[kk]]
[10:31:26.716]                   NAME <- NAMES[[kk]]
[10:31:26.716]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.716]                     next
[10:31:26.716]                   args[[name]] <- ""
[10:31:26.716]                 }
[10:31:26.716]                 NAMES <- toupper(removed)
[10:31:26.716]                 for (kk in seq_along(NAMES)) {
[10:31:26.716]                   name <- removed[[kk]]
[10:31:26.716]                   NAME <- NAMES[[kk]]
[10:31:26.716]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.716]                     next
[10:31:26.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:26.716]                 }
[10:31:26.716]                 if (length(args) > 0) 
[10:31:26.716]                   base::do.call(base::Sys.setenv, args = args)
[10:31:26.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:26.716]             }
[10:31:26.716]             else {
[10:31:26.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:26.716]             }
[10:31:26.716]             {
[10:31:26.716]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:26.716]                   0L) {
[10:31:26.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:26.716]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:26.716]                   base::options(opts)
[10:31:26.716]                 }
[10:31:26.716]                 {
[10:31:26.716]                   {
[10:31:26.716]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:26.716]                     NULL
[10:31:26.716]                   }
[10:31:26.716]                   options(future.plan = NULL)
[10:31:26.716]                   if (is.na(NA_character_)) 
[10:31:26.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:26.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:26.716]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:26.716]                     .init = FALSE)
[10:31:26.716]                 }
[10:31:26.716]             }
[10:31:26.716]         }
[10:31:26.716]     })
[10:31:26.716]     if (TRUE) {
[10:31:26.716]         base::sink(type = "output", split = FALSE)
[10:31:26.716]         if (TRUE) {
[10:31:26.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:26.716]         }
[10:31:26.716]         else {
[10:31:26.716]             ...future.result["stdout"] <- base::list(NULL)
[10:31:26.716]         }
[10:31:26.716]         base::close(...future.stdout)
[10:31:26.716]         ...future.stdout <- NULL
[10:31:26.716]     }
[10:31:26.716]     ...future.result$conditions <- ...future.conditions
[10:31:26.716]     ...future.result$finished <- base::Sys.time()
[10:31:26.716]     ...future.result
[10:31:26.716] }
[10:31:26.718] Exporting 11 global objects (92.12 KiB) to cluster node #1 ...
[10:31:26.719] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:26.761] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:26.761] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[10:31:26.762] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[10:31:26.762] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:26.762] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:26.762] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:26.805] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:26.805] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:26.849] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:26.850] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:26.850] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:26.850] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:31:26.850] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:31:26.851] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:26.851] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:26.851] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:31:26.852] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:31:26.852] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:26.852] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:26.852] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:26.853] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:26.853] Exporting 11 global objects (92.12 KiB) to cluster node #1 ... DONE
[10:31:26.854] MultisessionFuture started
[10:31:26.854] - Launch lazy future ... done
[10:31:26.854] run() for ‘MultisessionFuture’ ... done
[10:31:26.854] Created future:
[10:31:26.854] MultisessionFuture:
[10:31:26.854] Label: ‘future_vapply-1’
[10:31:26.854] Expression:
[10:31:26.854] {
[10:31:26.854]     do.call(function(...) {
[10:31:26.854]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.854]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:26.854]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.854]             on.exit(options(oopts), add = TRUE)
[10:31:26.854]         }
[10:31:26.854]         {
[10:31:26.854]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:26.854]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.854]                 ...future.FUN(...future.X_jj, ...)
[10:31:26.854]             })
[10:31:26.854]         }
[10:31:26.854]     }, args = future.call.arguments)
[10:31:26.854] }
[10:31:26.854] Lazy evaluation: FALSE
[10:31:26.854] Asynchronous evaluation: TRUE
[10:31:26.854] Local evaluation: TRUE
[10:31:26.854] Environment: R_GlobalEnv
[10:31:26.854] Capture standard output: TRUE
[10:31:26.854] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:26.854] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:26.854] Packages: 1 packages (‘future.apply’)
[10:31:26.854] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:26.854] Resolved: FALSE
[10:31:26.854] Value: <not collected>
[10:31:26.854] Conditions captured: <none>
[10:31:26.854] Early signaling: FALSE
[10:31:26.854] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:26.854] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:26.866] Chunk #1 of 2 ... DONE
[10:31:26.866] Chunk #2 of 2 ...
[10:31:26.866]  - Finding globals in 'X' for chunk #2 ...
[10:31:26.866] getGlobalsAndPackages() ...
[10:31:26.867] Searching for globals...
[10:31:26.867] 
[10:31:26.867] Searching for globals ... DONE
[10:31:26.867] - globals: [0] <none>
[10:31:26.867] getGlobalsAndPackages() ... DONE
[10:31:26.867]    + additional globals found: [n=0] 
[10:31:26.867]    + additional namespaces needed: [n=0] 
[10:31:26.868]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:26.868]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:26.868]  - seeds: <none>
[10:31:26.868]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.868] getGlobalsAndPackages() ...
[10:31:26.868] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.868] Resolving globals: FALSE
[10:31:26.868] Tweak future expression to call with '...' arguments ...
[10:31:26.868] {
[10:31:26.868]     do.call(function(...) {
[10:31:26.868]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.868]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:26.868]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.868]             on.exit(options(oopts), add = TRUE)
[10:31:26.868]         }
[10:31:26.868]         {
[10:31:26.868]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:26.868]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.868]                 ...future.FUN(...future.X_jj, ...)
[10:31:26.868]             })
[10:31:26.868]         }
[10:31:26.868]     }, args = future.call.arguments)
[10:31:26.868] }
[10:31:26.869] Tweak future expression to call with '...' arguments ... DONE
[10:31:26.869] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:26.869] - packages: [1] ‘future.apply’
[10:31:26.870] getGlobalsAndPackages() ... DONE
[10:31:26.870] run() for ‘Future’ ...
[10:31:26.870] - state: ‘created’
[10:31:26.870] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:26.884] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:26.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:26.885]   - Field: ‘node’
[10:31:26.885]   - Field: ‘label’
[10:31:26.885]   - Field: ‘local’
[10:31:26.885]   - Field: ‘owner’
[10:31:26.885]   - Field: ‘envir’
[10:31:26.885]   - Field: ‘workers’
[10:31:26.885]   - Field: ‘packages’
[10:31:26.885]   - Field: ‘gc’
[10:31:26.885]   - Field: ‘conditions’
[10:31:26.886]   - Field: ‘persistent’
[10:31:26.886]   - Field: ‘expr’
[10:31:26.886]   - Field: ‘uuid’
[10:31:26.886]   - Field: ‘seed’
[10:31:26.886]   - Field: ‘version’
[10:31:26.886]   - Field: ‘result’
[10:31:26.886]   - Field: ‘asynchronous’
[10:31:26.886]   - Field: ‘calls’
[10:31:26.886]   - Field: ‘globals’
[10:31:26.886]   - Field: ‘stdout’
[10:31:26.886]   - Field: ‘earlySignal’
[10:31:26.887]   - Field: ‘lazy’
[10:31:26.887]   - Field: ‘state’
[10:31:26.887] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:26.887] - Launch lazy future ...
[10:31:26.887] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:26.887] Packages needed by future strategies (n = 0): <none>
[10:31:26.888] {
[10:31:26.888]     {
[10:31:26.888]         {
[10:31:26.888]             ...future.startTime <- base::Sys.time()
[10:31:26.888]             {
[10:31:26.888]                 {
[10:31:26.888]                   {
[10:31:26.888]                     {
[10:31:26.888]                       {
[10:31:26.888]                         base::local({
[10:31:26.888]                           has_future <- base::requireNamespace("future", 
[10:31:26.888]                             quietly = TRUE)
[10:31:26.888]                           if (has_future) {
[10:31:26.888]                             ns <- base::getNamespace("future")
[10:31:26.888]                             version <- ns[[".package"]][["version"]]
[10:31:26.888]                             if (is.null(version)) 
[10:31:26.888]                               version <- utils::packageVersion("future")
[10:31:26.888]                           }
[10:31:26.888]                           else {
[10:31:26.888]                             version <- NULL
[10:31:26.888]                           }
[10:31:26.888]                           if (!has_future || version < "1.8.0") {
[10:31:26.888]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:26.888]                               "", base::R.version$version.string), 
[10:31:26.888]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:26.888]                                 base::R.version$platform, 8 * 
[10:31:26.888]                                   base::.Machine$sizeof.pointer), 
[10:31:26.888]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:26.888]                                 "release", "version")], collapse = " "), 
[10:31:26.888]                               hostname = base::Sys.info()[["nodename"]])
[10:31:26.888]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:26.888]                               info)
[10:31:26.888]                             info <- base::paste(info, collapse = "; ")
[10:31:26.888]                             if (!has_future) {
[10:31:26.888]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:26.888]                                 info)
[10:31:26.888]                             }
[10:31:26.888]                             else {
[10:31:26.888]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:26.888]                                 info, version)
[10:31:26.888]                             }
[10:31:26.888]                             base::stop(msg)
[10:31:26.888]                           }
[10:31:26.888]                         })
[10:31:26.888]                       }
[10:31:26.888]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:26.888]                       base::options(mc.cores = 1L)
[10:31:26.888]                     }
[10:31:26.888]                     base::local({
[10:31:26.888]                       for (pkg in "future.apply") {
[10:31:26.888]                         base::loadNamespace(pkg)
[10:31:26.888]                         base::library(pkg, character.only = TRUE)
[10:31:26.888]                       }
[10:31:26.888]                     })
[10:31:26.888]                   }
[10:31:26.888]                   ...future.strategy.old <- future::plan("list")
[10:31:26.888]                   options(future.plan = NULL)
[10:31:26.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:26.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:26.888]                 }
[10:31:26.888]                 ...future.workdir <- getwd()
[10:31:26.888]             }
[10:31:26.888]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:26.888]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:26.888]         }
[10:31:26.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:26.888]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:26.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:26.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:26.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:26.888]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:26.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:26.888]             base::names(...future.oldOptions))
[10:31:26.888]     }
[10:31:26.888]     if (FALSE) {
[10:31:26.888]     }
[10:31:26.888]     else {
[10:31:26.888]         if (TRUE) {
[10:31:26.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:26.888]                 open = "w")
[10:31:26.888]         }
[10:31:26.888]         else {
[10:31:26.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:26.888]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:26.888]         }
[10:31:26.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:26.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:26.888]             base::sink(type = "output", split = FALSE)
[10:31:26.888]             base::close(...future.stdout)
[10:31:26.888]         }, add = TRUE)
[10:31:26.888]     }
[10:31:26.888]     ...future.frame <- base::sys.nframe()
[10:31:26.888]     ...future.conditions <- base::list()
[10:31:26.888]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:26.888]     if (FALSE) {
[10:31:26.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:26.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:26.888]     }
[10:31:26.888]     ...future.result <- base::tryCatch({
[10:31:26.888]         base::withCallingHandlers({
[10:31:26.888]             ...future.value <- base::withVisible(base::local({
[10:31:26.888]                 ...future.makeSendCondition <- base::local({
[10:31:26.888]                   sendCondition <- NULL
[10:31:26.888]                   function(frame = 1L) {
[10:31:26.888]                     if (is.function(sendCondition)) 
[10:31:26.888]                       return(sendCondition)
[10:31:26.888]                     ns <- getNamespace("parallel")
[10:31:26.888]                     if (exists("sendData", mode = "function", 
[10:31:26.888]                       envir = ns)) {
[10:31:26.888]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:26.888]                         envir = ns)
[10:31:26.888]                       envir <- sys.frame(frame)
[10:31:26.888]                       master <- NULL
[10:31:26.888]                       while (!identical(envir, .GlobalEnv) && 
[10:31:26.888]                         !identical(envir, emptyenv())) {
[10:31:26.888]                         if (exists("master", mode = "list", envir = envir, 
[10:31:26.888]                           inherits = FALSE)) {
[10:31:26.888]                           master <- get("master", mode = "list", 
[10:31:26.888]                             envir = envir, inherits = FALSE)
[10:31:26.888]                           if (inherits(master, c("SOCKnode", 
[10:31:26.888]                             "SOCK0node"))) {
[10:31:26.888]                             sendCondition <<- function(cond) {
[10:31:26.888]                               data <- list(type = "VALUE", value = cond, 
[10:31:26.888]                                 success = TRUE)
[10:31:26.888]                               parallel_sendData(master, data)
[10:31:26.888]                             }
[10:31:26.888]                             return(sendCondition)
[10:31:26.888]                           }
[10:31:26.888]                         }
[10:31:26.888]                         frame <- frame + 1L
[10:31:26.888]                         envir <- sys.frame(frame)
[10:31:26.888]                       }
[10:31:26.888]                     }
[10:31:26.888]                     sendCondition <<- function(cond) NULL
[10:31:26.888]                   }
[10:31:26.888]                 })
[10:31:26.888]                 withCallingHandlers({
[10:31:26.888]                   {
[10:31:26.888]                     do.call(function(...) {
[10:31:26.888]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:26.888]                       if (!identical(...future.globals.maxSize.org, 
[10:31:26.888]                         ...future.globals.maxSize)) {
[10:31:26.888]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:26.888]                         on.exit(options(oopts), add = TRUE)
[10:31:26.888]                       }
[10:31:26.888]                       {
[10:31:26.888]                         lapply(seq_along(...future.elements_ii), 
[10:31:26.888]                           FUN = function(jj) {
[10:31:26.888]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:26.888]                             ...future.FUN(...future.X_jj, ...)
[10:31:26.888]                           })
[10:31:26.888]                       }
[10:31:26.888]                     }, args = future.call.arguments)
[10:31:26.888]                   }
[10:31:26.888]                 }, immediateCondition = function(cond) {
[10:31:26.888]                   sendCondition <- ...future.makeSendCondition()
[10:31:26.888]                   sendCondition(cond)
[10:31:26.888]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.888]                   {
[10:31:26.888]                     inherits <- base::inherits
[10:31:26.888]                     invokeRestart <- base::invokeRestart
[10:31:26.888]                     is.null <- base::is.null
[10:31:26.888]                     muffled <- FALSE
[10:31:26.888]                     if (inherits(cond, "message")) {
[10:31:26.888]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:26.888]                       if (muffled) 
[10:31:26.888]                         invokeRestart("muffleMessage")
[10:31:26.888]                     }
[10:31:26.888]                     else if (inherits(cond, "warning")) {
[10:31:26.888]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:26.888]                       if (muffled) 
[10:31:26.888]                         invokeRestart("muffleWarning")
[10:31:26.888]                     }
[10:31:26.888]                     else if (inherits(cond, "condition")) {
[10:31:26.888]                       if (!is.null(pattern)) {
[10:31:26.888]                         computeRestarts <- base::computeRestarts
[10:31:26.888]                         grepl <- base::grepl
[10:31:26.888]                         restarts <- computeRestarts(cond)
[10:31:26.888]                         for (restart in restarts) {
[10:31:26.888]                           name <- restart$name
[10:31:26.888]                           if (is.null(name)) 
[10:31:26.888]                             next
[10:31:26.888]                           if (!grepl(pattern, name)) 
[10:31:26.888]                             next
[10:31:26.888]                           invokeRestart(restart)
[10:31:26.888]                           muffled <- TRUE
[10:31:26.888]                           break
[10:31:26.888]                         }
[10:31:26.888]                       }
[10:31:26.888]                     }
[10:31:26.888]                     invisible(muffled)
[10:31:26.888]                   }
[10:31:26.888]                   muffleCondition(cond)
[10:31:26.888]                 })
[10:31:26.888]             }))
[10:31:26.888]             future::FutureResult(value = ...future.value$value, 
[10:31:26.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:26.888]                   ...future.rng), globalenv = if (FALSE) 
[10:31:26.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:26.888]                     ...future.globalenv.names))
[10:31:26.888]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:26.888]         }, condition = base::local({
[10:31:26.888]             c <- base::c
[10:31:26.888]             inherits <- base::inherits
[10:31:26.888]             invokeRestart <- base::invokeRestart
[10:31:26.888]             length <- base::length
[10:31:26.888]             list <- base::list
[10:31:26.888]             seq.int <- base::seq.int
[10:31:26.888]             signalCondition <- base::signalCondition
[10:31:26.888]             sys.calls <- base::sys.calls
[10:31:26.888]             `[[` <- base::`[[`
[10:31:26.888]             `+` <- base::`+`
[10:31:26.888]             `<<-` <- base::`<<-`
[10:31:26.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:26.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:26.888]                   3L)]
[10:31:26.888]             }
[10:31:26.888]             function(cond) {
[10:31:26.888]                 is_error <- inherits(cond, "error")
[10:31:26.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:26.888]                   NULL)
[10:31:26.888]                 if (is_error) {
[10:31:26.888]                   sessionInformation <- function() {
[10:31:26.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:26.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:26.888]                       search = base::search(), system = base::Sys.info())
[10:31:26.888]                   }
[10:31:26.888]                   ...future.conditions[[length(...future.conditions) + 
[10:31:26.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:26.888]                     cond$call), session = sessionInformation(), 
[10:31:26.888]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:26.888]                   signalCondition(cond)
[10:31:26.888]                 }
[10:31:26.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:26.888]                 "immediateCondition"))) {
[10:31:26.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:26.888]                   ...future.conditions[[length(...future.conditions) + 
[10:31:26.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:26.888]                   if (TRUE && !signal) {
[10:31:26.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.888]                     {
[10:31:26.888]                       inherits <- base::inherits
[10:31:26.888]                       invokeRestart <- base::invokeRestart
[10:31:26.888]                       is.null <- base::is.null
[10:31:26.888]                       muffled <- FALSE
[10:31:26.888]                       if (inherits(cond, "message")) {
[10:31:26.888]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:26.888]                         if (muffled) 
[10:31:26.888]                           invokeRestart("muffleMessage")
[10:31:26.888]                       }
[10:31:26.888]                       else if (inherits(cond, "warning")) {
[10:31:26.888]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:26.888]                         if (muffled) 
[10:31:26.888]                           invokeRestart("muffleWarning")
[10:31:26.888]                       }
[10:31:26.888]                       else if (inherits(cond, "condition")) {
[10:31:26.888]                         if (!is.null(pattern)) {
[10:31:26.888]                           computeRestarts <- base::computeRestarts
[10:31:26.888]                           grepl <- base::grepl
[10:31:26.888]                           restarts <- computeRestarts(cond)
[10:31:26.888]                           for (restart in restarts) {
[10:31:26.888]                             name <- restart$name
[10:31:26.888]                             if (is.null(name)) 
[10:31:26.888]                               next
[10:31:26.888]                             if (!grepl(pattern, name)) 
[10:31:26.888]                               next
[10:31:26.888]                             invokeRestart(restart)
[10:31:26.888]                             muffled <- TRUE
[10:31:26.888]                             break
[10:31:26.888]                           }
[10:31:26.888]                         }
[10:31:26.888]                       }
[10:31:26.888]                       invisible(muffled)
[10:31:26.888]                     }
[10:31:26.888]                     muffleCondition(cond, pattern = "^muffle")
[10:31:26.888]                   }
[10:31:26.888]                 }
[10:31:26.888]                 else {
[10:31:26.888]                   if (TRUE) {
[10:31:26.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:26.888]                     {
[10:31:26.888]                       inherits <- base::inherits
[10:31:26.888]                       invokeRestart <- base::invokeRestart
[10:31:26.888]                       is.null <- base::is.null
[10:31:26.888]                       muffled <- FALSE
[10:31:26.888]                       if (inherits(cond, "message")) {
[10:31:26.888]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:26.888]                         if (muffled) 
[10:31:26.888]                           invokeRestart("muffleMessage")
[10:31:26.888]                       }
[10:31:26.888]                       else if (inherits(cond, "warning")) {
[10:31:26.888]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:26.888]                         if (muffled) 
[10:31:26.888]                           invokeRestart("muffleWarning")
[10:31:26.888]                       }
[10:31:26.888]                       else if (inherits(cond, "condition")) {
[10:31:26.888]                         if (!is.null(pattern)) {
[10:31:26.888]                           computeRestarts <- base::computeRestarts
[10:31:26.888]                           grepl <- base::grepl
[10:31:26.888]                           restarts <- computeRestarts(cond)
[10:31:26.888]                           for (restart in restarts) {
[10:31:26.888]                             name <- restart$name
[10:31:26.888]                             if (is.null(name)) 
[10:31:26.888]                               next
[10:31:26.888]                             if (!grepl(pattern, name)) 
[10:31:26.888]                               next
[10:31:26.888]                             invokeRestart(restart)
[10:31:26.888]                             muffled <- TRUE
[10:31:26.888]                             break
[10:31:26.888]                           }
[10:31:26.888]                         }
[10:31:26.888]                       }
[10:31:26.888]                       invisible(muffled)
[10:31:26.888]                     }
[10:31:26.888]                     muffleCondition(cond, pattern = "^muffle")
[10:31:26.888]                   }
[10:31:26.888]                 }
[10:31:26.888]             }
[10:31:26.888]         }))
[10:31:26.888]     }, error = function(ex) {
[10:31:26.888]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:26.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:26.888]                 ...future.rng), started = ...future.startTime, 
[10:31:26.888]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:26.888]             version = "1.8"), class = "FutureResult")
[10:31:26.888]     }, finally = {
[10:31:26.888]         if (!identical(...future.workdir, getwd())) 
[10:31:26.888]             setwd(...future.workdir)
[10:31:26.888]         {
[10:31:26.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:26.888]                 ...future.oldOptions$nwarnings <- NULL
[10:31:26.888]             }
[10:31:26.888]             base::options(...future.oldOptions)
[10:31:26.888]             if (.Platform$OS.type == "windows") {
[10:31:26.888]                 old_names <- names(...future.oldEnvVars)
[10:31:26.888]                 envs <- base::Sys.getenv()
[10:31:26.888]                 names <- names(envs)
[10:31:26.888]                 common <- intersect(names, old_names)
[10:31:26.888]                 added <- setdiff(names, old_names)
[10:31:26.888]                 removed <- setdiff(old_names, names)
[10:31:26.888]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:26.888]                   envs[common]]
[10:31:26.888]                 NAMES <- toupper(changed)
[10:31:26.888]                 args <- list()
[10:31:26.888]                 for (kk in seq_along(NAMES)) {
[10:31:26.888]                   name <- changed[[kk]]
[10:31:26.888]                   NAME <- NAMES[[kk]]
[10:31:26.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.888]                     next
[10:31:26.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:26.888]                 }
[10:31:26.888]                 NAMES <- toupper(added)
[10:31:26.888]                 for (kk in seq_along(NAMES)) {
[10:31:26.888]                   name <- added[[kk]]
[10:31:26.888]                   NAME <- NAMES[[kk]]
[10:31:26.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.888]                     next
[10:31:26.888]                   args[[name]] <- ""
[10:31:26.888]                 }
[10:31:26.888]                 NAMES <- toupper(removed)
[10:31:26.888]                 for (kk in seq_along(NAMES)) {
[10:31:26.888]                   name <- removed[[kk]]
[10:31:26.888]                   NAME <- NAMES[[kk]]
[10:31:26.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:26.888]                     next
[10:31:26.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:26.888]                 }
[10:31:26.888]                 if (length(args) > 0) 
[10:31:26.888]                   base::do.call(base::Sys.setenv, args = args)
[10:31:26.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:26.888]             }
[10:31:26.888]             else {
[10:31:26.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:26.888]             }
[10:31:26.888]             {
[10:31:26.888]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:26.888]                   0L) {
[10:31:26.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:26.888]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:26.888]                   base::options(opts)
[10:31:26.888]                 }
[10:31:26.888]                 {
[10:31:26.888]                   {
[10:31:26.888]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:26.888]                     NULL
[10:31:26.888]                   }
[10:31:26.888]                   options(future.plan = NULL)
[10:31:26.888]                   if (is.na(NA_character_)) 
[10:31:26.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:26.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:26.888]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:26.888]                     .init = FALSE)
[10:31:26.888]                 }
[10:31:26.888]             }
[10:31:26.888]         }
[10:31:26.888]     })
[10:31:26.888]     if (TRUE) {
[10:31:26.888]         base::sink(type = "output", split = FALSE)
[10:31:26.888]         if (TRUE) {
[10:31:26.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:26.888]         }
[10:31:26.888]         else {
[10:31:26.888]             ...future.result["stdout"] <- base::list(NULL)
[10:31:26.888]         }
[10:31:26.888]         base::close(...future.stdout)
[10:31:26.888]         ...future.stdout <- NULL
[10:31:26.888]     }
[10:31:26.888]     ...future.result$conditions <- ...future.conditions
[10:31:26.888]     ...future.result$finished <- base::Sys.time()
[10:31:26.888]     ...future.result
[10:31:26.888] }
[10:31:26.891] Exporting 11 global objects (92.12 KiB) to cluster node #2 ...
[10:31:26.891] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:31:26.933] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:31:26.933] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ...
[10:31:26.934] Exporting ‘x_FUN’ (56 bytes) to cluster node #2 ... DONE
[10:31:26.934] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:31:26.934] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:31:26.934] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:31:26.977] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:31:26.977] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:31:27.021] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:31:27.021] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:31:27.022] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:31:27.022] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:31:27.022] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:31:27.023] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:31:27.023] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:31:27.023] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:31:27.023] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:31:27.023] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:27.024] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:27.024] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:27.024] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:27.024] Exporting 11 global objects (92.12 KiB) to cluster node #2 ... DONE
[10:31:27.025] MultisessionFuture started
[10:31:27.025] - Launch lazy future ... done
[10:31:27.025] run() for ‘MultisessionFuture’ ... done
[10:31:27.025] Created future:
[10:31:27.025] MultisessionFuture:
[10:31:27.025] Label: ‘future_vapply-2’
[10:31:27.025] Expression:
[10:31:27.025] {
[10:31:27.025]     do.call(function(...) {
[10:31:27.025]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.025]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:27.025]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.025]             on.exit(options(oopts), add = TRUE)
[10:31:27.025]         }
[10:31:27.025]         {
[10:31:27.025]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:27.025]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.025]                 ...future.FUN(...future.X_jj, ...)
[10:31:27.025]             })
[10:31:27.025]         }
[10:31:27.025]     }, args = future.call.arguments)
[10:31:27.025] }
[10:31:27.025] Lazy evaluation: FALSE
[10:31:27.025] Asynchronous evaluation: TRUE
[10:31:27.025] Local evaluation: TRUE
[10:31:27.025] Environment: R_GlobalEnv
[10:31:27.025] Capture standard output: TRUE
[10:31:27.025] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:27.025] Globals: 11 objects totaling 92.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:27.025] Packages: 1 packages (‘future.apply’)
[10:31:27.025] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:27.025] Resolved: FALSE
[10:31:27.025] Value: <not collected>
[10:31:27.025] Conditions captured: <none>
[10:31:27.025] Early signaling: FALSE
[10:31:27.025] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:27.025] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:27.037] Chunk #2 of 2 ... DONE
[10:31:27.037] Launching 2 futures (chunks) ... DONE
[10:31:27.037] Resolving 2 futures (chunks) ...
[10:31:27.037] resolve() on list ...
[10:31:27.038]  recursive: 0
[10:31:27.038]  length: 2
[10:31:27.038] 
[10:31:27.038] receiveMessageFromWorker() for ClusterFuture ...
[10:31:27.038] - Validating connection of MultisessionFuture
[10:31:27.039] - received message: FutureResult
[10:31:27.039] - Received FutureResult
[10:31:27.039] - Erased future from FutureRegistry
[10:31:27.039] result() for ClusterFuture ...
[10:31:27.039] - result already collected: FutureResult
[10:31:27.039] result() for ClusterFuture ... done
[10:31:27.039] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:27.039] Future #1
[10:31:27.039] result() for ClusterFuture ...
[10:31:27.039] - result already collected: FutureResult
[10:31:27.039] result() for ClusterFuture ... done
[10:31:27.040] result() for ClusterFuture ...
[10:31:27.040] - result already collected: FutureResult
[10:31:27.040] result() for ClusterFuture ... done
[10:31:27.040] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:27.040] - nx: 2
[10:31:27.040] - relay: TRUE
[10:31:27.040] - stdout: TRUE
[10:31:27.040] - signal: TRUE
[10:31:27.040] - resignal: FALSE
[10:31:27.040] - force: TRUE
[10:31:27.040] - relayed: [n=2] FALSE, FALSE
[10:31:27.041] - queued futures: [n=2] FALSE, FALSE
[10:31:27.041]  - until=1
[10:31:27.041]  - relaying element #1
[10:31:27.041] result() for ClusterFuture ...
[10:31:27.041] - result already collected: FutureResult
[10:31:27.041] result() for ClusterFuture ... done
[10:31:27.041] result() for ClusterFuture ...
[10:31:27.041] - result already collected: FutureResult
[10:31:27.041] result() for ClusterFuture ... done
[10:31:27.041] result() for ClusterFuture ...
[10:31:27.041] - result already collected: FutureResult
[10:31:27.042] result() for ClusterFuture ... done
[10:31:27.042] result() for ClusterFuture ...
[10:31:27.042] - result already collected: FutureResult
[10:31:27.042] result() for ClusterFuture ... done
[10:31:27.042] - relayed: [n=2] TRUE, FALSE
[10:31:27.042] - queued futures: [n=2] TRUE, FALSE
[10:31:27.042] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:27.042]  length: 1 (resolved future 1)
[10:31:27.071] receiveMessageFromWorker() for ClusterFuture ...
[10:31:27.071] - Validating connection of MultisessionFuture
[10:31:27.071] - received message: FutureResult
[10:31:27.071] - Received FutureResult
[10:31:27.071] - Erased future from FutureRegistry
[10:31:27.071] result() for ClusterFuture ...
[10:31:27.071] - result already collected: FutureResult
[10:31:27.071] result() for ClusterFuture ... done
[10:31:27.071] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:27.072] Future #2
[10:31:27.072] result() for ClusterFuture ...
[10:31:27.072] - result already collected: FutureResult
[10:31:27.072] result() for ClusterFuture ... done
[10:31:27.072] result() for ClusterFuture ...
[10:31:27.072] - result already collected: FutureResult
[10:31:27.072] result() for ClusterFuture ... done
[10:31:27.072] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:27.072] - nx: 2
[10:31:27.072] - relay: TRUE
[10:31:27.072] - stdout: TRUE
[10:31:27.072] - signal: TRUE
[10:31:27.073] - resignal: FALSE
[10:31:27.073] - force: TRUE
[10:31:27.073] - relayed: [n=2] TRUE, FALSE
[10:31:27.073] - queued futures: [n=2] TRUE, FALSE
[10:31:27.073]  - until=2
[10:31:27.073]  - relaying element #2
[10:31:27.073] result() for ClusterFuture ...
[10:31:27.073] - result already collected: FutureResult
[10:31:27.073] result() for ClusterFuture ... done
[10:31:27.073] result() for ClusterFuture ...
[10:31:27.073] - result already collected: FutureResult
[10:31:27.074] result() for ClusterFuture ... done
[10:31:27.074] result() for ClusterFuture ...
[10:31:27.074] - result already collected: FutureResult
[10:31:27.074] result() for ClusterFuture ... done
[10:31:27.074] result() for ClusterFuture ...
[10:31:27.074] - result already collected: FutureResult
[10:31:27.074] result() for ClusterFuture ... done
[10:31:27.074] - relayed: [n=2] TRUE, TRUE
[10:31:27.074] - queued futures: [n=2] TRUE, TRUE
[10:31:27.074] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:27.074]  length: 0 (resolved future 2)
[10:31:27.075] Relaying remaining futures
[10:31:27.075] signalConditionsASAP(NULL, pos=0) ...
[10:31:27.075] - nx: 2
[10:31:27.075] - relay: TRUE
[10:31:27.075] - stdout: TRUE
[10:31:27.075] - signal: TRUE
[10:31:27.075] - resignal: FALSE
[10:31:27.075] - force: TRUE
[10:31:27.075] - relayed: [n=2] TRUE, TRUE
[10:31:27.075] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:27.075] - relayed: [n=2] TRUE, TRUE
[10:31:27.076] - queued futures: [n=2] TRUE, TRUE
[10:31:27.076] signalConditionsASAP(NULL, pos=0) ... done
[10:31:27.076] resolve() on list ... DONE
[10:31:27.076] result() for ClusterFuture ...
[10:31:27.076] - result already collected: FutureResult
[10:31:27.076] result() for ClusterFuture ... done
[10:31:27.076] result() for ClusterFuture ...
[10:31:27.076] - result already collected: FutureResult
[10:31:27.076] result() for ClusterFuture ... done
[10:31:27.076] result() for ClusterFuture ...
[10:31:27.076] - result already collected: FutureResult
[10:31:27.076] result() for ClusterFuture ... done
[10:31:27.077] result() for ClusterFuture ...
[10:31:27.077] - result already collected: FutureResult
[10:31:27.077] result() for ClusterFuture ... done
[10:31:27.077]  - Number of value chunks collected: 2
[10:31:27.077] Resolving 2 futures (chunks) ... DONE
[10:31:27.077] Reducing values from 2 chunks ...
[10:31:27.077]  - Number of values collected after concatenation: 10
[10:31:27.077]  - Number of values expected: 10
[10:31:27.077] Reducing values from 2 chunks ... DONE
[10:31:27.077] future_lapply() ... DONE
 num [1:10] 1 1.41 1.73 2 2.24 ...
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
[10:31:27.078] future_lapply() ...
[10:31:27.084] Number of chunks: 2
[10:31:27.084] getGlobalsAndPackagesXApply() ...
[10:31:27.084]  - future.globals: TRUE
[10:31:27.084] getGlobalsAndPackages() ...
[10:31:27.084] Searching for globals...
[10:31:27.087] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘c’, ‘^’
[10:31:27.088] Searching for globals ... DONE
[10:31:27.088] Resolving globals: FALSE
[10:31:27.089] The total size of the 7 globals is 94.20 KiB (96456 bytes)
[10:31:27.089] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:27.089] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:27.089] - packages: [1] ‘future.apply’
[10:31:27.089] getGlobalsAndPackages() ... DONE
[10:31:27.089]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:27.090]  - needed namespaces: [n=1] ‘future.apply’
[10:31:27.090] Finding globals ... DONE
[10:31:27.090]  - use_args: TRUE
[10:31:27.090]  - Getting '...' globals ...
[10:31:27.090] resolve() on list ...
[10:31:27.090]  recursive: 0
[10:31:27.090]  length: 1
[10:31:27.090]  elements: ‘...’
[10:31:27.090]  length: 0 (resolved future 1)
[10:31:27.091] resolve() on list ... DONE
[10:31:27.091]    - '...' content: [n=0] 
[10:31:27.091] List of 1
[10:31:27.091]  $ ...: list()
[10:31:27.091]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:27.091]  - attr(*, "where")=List of 1
[10:31:27.091]   ..$ ...:<environment: 0x55de86fc8e38> 
[10:31:27.091]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:27.091]  - attr(*, "resolved")= logi TRUE
[10:31:27.091]  - attr(*, "total_size")= num NA
[10:31:27.093]  - Getting '...' globals ... DONE
[10:31:27.093] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:27.094] List of 8
[10:31:27.094]  $ ...future.FUN:function (x, ...)  
[10:31:27.094]  $ x_FUN        :function (x)  
[10:31:27.094]  $ times        : int 2
[10:31:27.094]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:27.094]  $ stop_if_not  :function (...)  
[10:31:27.094]  $ dim          : NULL
[10:31:27.094]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:27.094]  $ ...          : list()
[10:31:27.094]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:27.094]  - attr(*, "where")=List of 8
[10:31:27.094]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:27.094]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:27.094]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:27.094]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:27.094]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:27.094]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:27.094]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:27.094]   ..$ ...          :<environment: 0x55de86fc8e38> 
[10:31:27.094]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:27.094]  - attr(*, "resolved")= logi FALSE
[10:31:27.094]  - attr(*, "total_size")= num 96456
[10:31:27.099] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:27.099] getGlobalsAndPackagesXApply() ... DONE
[10:31:27.099] Number of futures (= number of chunks): 2
[10:31:27.099] Launching 2 futures (chunks) ...
[10:31:27.099] Chunk #1 of 2 ...
[10:31:27.099]  - Finding globals in 'X' for chunk #1 ...
[10:31:27.099] getGlobalsAndPackages() ...
[10:31:27.100] Searching for globals...
[10:31:27.100] 
[10:31:27.100] Searching for globals ... DONE
[10:31:27.100] - globals: [0] <none>
[10:31:27.100] getGlobalsAndPackages() ... DONE
[10:31:27.100]    + additional globals found: [n=0] 
[10:31:27.100]    + additional namespaces needed: [n=0] 
[10:31:27.100]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:27.100]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:27.101]  - seeds: <none>
[10:31:27.101]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.101] getGlobalsAndPackages() ...
[10:31:27.101] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.101] Resolving globals: FALSE
[10:31:27.101] Tweak future expression to call with '...' arguments ...
[10:31:27.101] {
[10:31:27.101]     do.call(function(...) {
[10:31:27.101]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.101]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:27.101]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.101]             on.exit(options(oopts), add = TRUE)
[10:31:27.101]         }
[10:31:27.101]         {
[10:31:27.101]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:27.101]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.101]                 ...future.FUN(...future.X_jj, ...)
[10:31:27.101]             })
[10:31:27.101]         }
[10:31:27.101]     }, args = future.call.arguments)
[10:31:27.101] }
[10:31:27.101] Tweak future expression to call with '...' arguments ... DONE
[10:31:27.102] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.102] - packages: [1] ‘future.apply’
[10:31:27.102] getGlobalsAndPackages() ... DONE
[10:31:27.103] run() for ‘Future’ ...
[10:31:27.103] - state: ‘created’
[10:31:27.103] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:27.117] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:27.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:27.117]   - Field: ‘node’
[10:31:27.117]   - Field: ‘label’
[10:31:27.117]   - Field: ‘local’
[10:31:27.117]   - Field: ‘owner’
[10:31:27.117]   - Field: ‘envir’
[10:31:27.117]   - Field: ‘workers’
[10:31:27.118]   - Field: ‘packages’
[10:31:27.118]   - Field: ‘gc’
[10:31:27.118]   - Field: ‘conditions’
[10:31:27.118]   - Field: ‘persistent’
[10:31:27.118]   - Field: ‘expr’
[10:31:27.118]   - Field: ‘uuid’
[10:31:27.118]   - Field: ‘seed’
[10:31:27.118]   - Field: ‘version’
[10:31:27.118]   - Field: ‘result’
[10:31:27.118]   - Field: ‘asynchronous’
[10:31:27.118]   - Field: ‘calls’
[10:31:27.119]   - Field: ‘globals’
[10:31:27.119]   - Field: ‘stdout’
[10:31:27.119]   - Field: ‘earlySignal’
[10:31:27.119]   - Field: ‘lazy’
[10:31:27.119]   - Field: ‘state’
[10:31:27.119] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:27.119] - Launch lazy future ...
[10:31:27.119] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:27.119] Packages needed by future strategies (n = 0): <none>
[10:31:27.120] {
[10:31:27.120]     {
[10:31:27.120]         {
[10:31:27.120]             ...future.startTime <- base::Sys.time()
[10:31:27.120]             {
[10:31:27.120]                 {
[10:31:27.120]                   {
[10:31:27.120]                     {
[10:31:27.120]                       {
[10:31:27.120]                         base::local({
[10:31:27.120]                           has_future <- base::requireNamespace("future", 
[10:31:27.120]                             quietly = TRUE)
[10:31:27.120]                           if (has_future) {
[10:31:27.120]                             ns <- base::getNamespace("future")
[10:31:27.120]                             version <- ns[[".package"]][["version"]]
[10:31:27.120]                             if (is.null(version)) 
[10:31:27.120]                               version <- utils::packageVersion("future")
[10:31:27.120]                           }
[10:31:27.120]                           else {
[10:31:27.120]                             version <- NULL
[10:31:27.120]                           }
[10:31:27.120]                           if (!has_future || version < "1.8.0") {
[10:31:27.120]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:27.120]                               "", base::R.version$version.string), 
[10:31:27.120]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:27.120]                                 base::R.version$platform, 8 * 
[10:31:27.120]                                   base::.Machine$sizeof.pointer), 
[10:31:27.120]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:27.120]                                 "release", "version")], collapse = " "), 
[10:31:27.120]                               hostname = base::Sys.info()[["nodename"]])
[10:31:27.120]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:27.120]                               info)
[10:31:27.120]                             info <- base::paste(info, collapse = "; ")
[10:31:27.120]                             if (!has_future) {
[10:31:27.120]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:27.120]                                 info)
[10:31:27.120]                             }
[10:31:27.120]                             else {
[10:31:27.120]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:27.120]                                 info, version)
[10:31:27.120]                             }
[10:31:27.120]                             base::stop(msg)
[10:31:27.120]                           }
[10:31:27.120]                         })
[10:31:27.120]                       }
[10:31:27.120]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:27.120]                       base::options(mc.cores = 1L)
[10:31:27.120]                     }
[10:31:27.120]                     base::local({
[10:31:27.120]                       for (pkg in "future.apply") {
[10:31:27.120]                         base::loadNamespace(pkg)
[10:31:27.120]                         base::library(pkg, character.only = TRUE)
[10:31:27.120]                       }
[10:31:27.120]                     })
[10:31:27.120]                   }
[10:31:27.120]                   ...future.strategy.old <- future::plan("list")
[10:31:27.120]                   options(future.plan = NULL)
[10:31:27.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:27.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:27.120]                 }
[10:31:27.120]                 ...future.workdir <- getwd()
[10:31:27.120]             }
[10:31:27.120]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:27.120]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:27.120]         }
[10:31:27.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:27.120]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:27.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:27.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:27.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:27.120]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:27.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:27.120]             base::names(...future.oldOptions))
[10:31:27.120]     }
[10:31:27.120]     if (FALSE) {
[10:31:27.120]     }
[10:31:27.120]     else {
[10:31:27.120]         if (TRUE) {
[10:31:27.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:27.120]                 open = "w")
[10:31:27.120]         }
[10:31:27.120]         else {
[10:31:27.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:27.120]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:27.120]         }
[10:31:27.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:27.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:27.120]             base::sink(type = "output", split = FALSE)
[10:31:27.120]             base::close(...future.stdout)
[10:31:27.120]         }, add = TRUE)
[10:31:27.120]     }
[10:31:27.120]     ...future.frame <- base::sys.nframe()
[10:31:27.120]     ...future.conditions <- base::list()
[10:31:27.120]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:27.120]     if (FALSE) {
[10:31:27.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:27.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:27.120]     }
[10:31:27.120]     ...future.result <- base::tryCatch({
[10:31:27.120]         base::withCallingHandlers({
[10:31:27.120]             ...future.value <- base::withVisible(base::local({
[10:31:27.120]                 ...future.makeSendCondition <- base::local({
[10:31:27.120]                   sendCondition <- NULL
[10:31:27.120]                   function(frame = 1L) {
[10:31:27.120]                     if (is.function(sendCondition)) 
[10:31:27.120]                       return(sendCondition)
[10:31:27.120]                     ns <- getNamespace("parallel")
[10:31:27.120]                     if (exists("sendData", mode = "function", 
[10:31:27.120]                       envir = ns)) {
[10:31:27.120]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:27.120]                         envir = ns)
[10:31:27.120]                       envir <- sys.frame(frame)
[10:31:27.120]                       master <- NULL
[10:31:27.120]                       while (!identical(envir, .GlobalEnv) && 
[10:31:27.120]                         !identical(envir, emptyenv())) {
[10:31:27.120]                         if (exists("master", mode = "list", envir = envir, 
[10:31:27.120]                           inherits = FALSE)) {
[10:31:27.120]                           master <- get("master", mode = "list", 
[10:31:27.120]                             envir = envir, inherits = FALSE)
[10:31:27.120]                           if (inherits(master, c("SOCKnode", 
[10:31:27.120]                             "SOCK0node"))) {
[10:31:27.120]                             sendCondition <<- function(cond) {
[10:31:27.120]                               data <- list(type = "VALUE", value = cond, 
[10:31:27.120]                                 success = TRUE)
[10:31:27.120]                               parallel_sendData(master, data)
[10:31:27.120]                             }
[10:31:27.120]                             return(sendCondition)
[10:31:27.120]                           }
[10:31:27.120]                         }
[10:31:27.120]                         frame <- frame + 1L
[10:31:27.120]                         envir <- sys.frame(frame)
[10:31:27.120]                       }
[10:31:27.120]                     }
[10:31:27.120]                     sendCondition <<- function(cond) NULL
[10:31:27.120]                   }
[10:31:27.120]                 })
[10:31:27.120]                 withCallingHandlers({
[10:31:27.120]                   {
[10:31:27.120]                     do.call(function(...) {
[10:31:27.120]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.120]                       if (!identical(...future.globals.maxSize.org, 
[10:31:27.120]                         ...future.globals.maxSize)) {
[10:31:27.120]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.120]                         on.exit(options(oopts), add = TRUE)
[10:31:27.120]                       }
[10:31:27.120]                       {
[10:31:27.120]                         lapply(seq_along(...future.elements_ii), 
[10:31:27.120]                           FUN = function(jj) {
[10:31:27.120]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.120]                             ...future.FUN(...future.X_jj, ...)
[10:31:27.120]                           })
[10:31:27.120]                       }
[10:31:27.120]                     }, args = future.call.arguments)
[10:31:27.120]                   }
[10:31:27.120]                 }, immediateCondition = function(cond) {
[10:31:27.120]                   sendCondition <- ...future.makeSendCondition()
[10:31:27.120]                   sendCondition(cond)
[10:31:27.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.120]                   {
[10:31:27.120]                     inherits <- base::inherits
[10:31:27.120]                     invokeRestart <- base::invokeRestart
[10:31:27.120]                     is.null <- base::is.null
[10:31:27.120]                     muffled <- FALSE
[10:31:27.120]                     if (inherits(cond, "message")) {
[10:31:27.120]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:27.120]                       if (muffled) 
[10:31:27.120]                         invokeRestart("muffleMessage")
[10:31:27.120]                     }
[10:31:27.120]                     else if (inherits(cond, "warning")) {
[10:31:27.120]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:27.120]                       if (muffled) 
[10:31:27.120]                         invokeRestart("muffleWarning")
[10:31:27.120]                     }
[10:31:27.120]                     else if (inherits(cond, "condition")) {
[10:31:27.120]                       if (!is.null(pattern)) {
[10:31:27.120]                         computeRestarts <- base::computeRestarts
[10:31:27.120]                         grepl <- base::grepl
[10:31:27.120]                         restarts <- computeRestarts(cond)
[10:31:27.120]                         for (restart in restarts) {
[10:31:27.120]                           name <- restart$name
[10:31:27.120]                           if (is.null(name)) 
[10:31:27.120]                             next
[10:31:27.120]                           if (!grepl(pattern, name)) 
[10:31:27.120]                             next
[10:31:27.120]                           invokeRestart(restart)
[10:31:27.120]                           muffled <- TRUE
[10:31:27.120]                           break
[10:31:27.120]                         }
[10:31:27.120]                       }
[10:31:27.120]                     }
[10:31:27.120]                     invisible(muffled)
[10:31:27.120]                   }
[10:31:27.120]                   muffleCondition(cond)
[10:31:27.120]                 })
[10:31:27.120]             }))
[10:31:27.120]             future::FutureResult(value = ...future.value$value, 
[10:31:27.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:27.120]                   ...future.rng), globalenv = if (FALSE) 
[10:31:27.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:27.120]                     ...future.globalenv.names))
[10:31:27.120]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:27.120]         }, condition = base::local({
[10:31:27.120]             c <- base::c
[10:31:27.120]             inherits <- base::inherits
[10:31:27.120]             invokeRestart <- base::invokeRestart
[10:31:27.120]             length <- base::length
[10:31:27.120]             list <- base::list
[10:31:27.120]             seq.int <- base::seq.int
[10:31:27.120]             signalCondition <- base::signalCondition
[10:31:27.120]             sys.calls <- base::sys.calls
[10:31:27.120]             `[[` <- base::`[[`
[10:31:27.120]             `+` <- base::`+`
[10:31:27.120]             `<<-` <- base::`<<-`
[10:31:27.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:27.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:27.120]                   3L)]
[10:31:27.120]             }
[10:31:27.120]             function(cond) {
[10:31:27.120]                 is_error <- inherits(cond, "error")
[10:31:27.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:27.120]                   NULL)
[10:31:27.120]                 if (is_error) {
[10:31:27.120]                   sessionInformation <- function() {
[10:31:27.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:27.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:27.120]                       search = base::search(), system = base::Sys.info())
[10:31:27.120]                   }
[10:31:27.120]                   ...future.conditions[[length(...future.conditions) + 
[10:31:27.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:27.120]                     cond$call), session = sessionInformation(), 
[10:31:27.120]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:27.120]                   signalCondition(cond)
[10:31:27.120]                 }
[10:31:27.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:27.120]                 "immediateCondition"))) {
[10:31:27.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:27.120]                   ...future.conditions[[length(...future.conditions) + 
[10:31:27.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:27.120]                   if (TRUE && !signal) {
[10:31:27.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.120]                     {
[10:31:27.120]                       inherits <- base::inherits
[10:31:27.120]                       invokeRestart <- base::invokeRestart
[10:31:27.120]                       is.null <- base::is.null
[10:31:27.120]                       muffled <- FALSE
[10:31:27.120]                       if (inherits(cond, "message")) {
[10:31:27.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:27.120]                         if (muffled) 
[10:31:27.120]                           invokeRestart("muffleMessage")
[10:31:27.120]                       }
[10:31:27.120]                       else if (inherits(cond, "warning")) {
[10:31:27.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:27.120]                         if (muffled) 
[10:31:27.120]                           invokeRestart("muffleWarning")
[10:31:27.120]                       }
[10:31:27.120]                       else if (inherits(cond, "condition")) {
[10:31:27.120]                         if (!is.null(pattern)) {
[10:31:27.120]                           computeRestarts <- base::computeRestarts
[10:31:27.120]                           grepl <- base::grepl
[10:31:27.120]                           restarts <- computeRestarts(cond)
[10:31:27.120]                           for (restart in restarts) {
[10:31:27.120]                             name <- restart$name
[10:31:27.120]                             if (is.null(name)) 
[10:31:27.120]                               next
[10:31:27.120]                             if (!grepl(pattern, name)) 
[10:31:27.120]                               next
[10:31:27.120]                             invokeRestart(restart)
[10:31:27.120]                             muffled <- TRUE
[10:31:27.120]                             break
[10:31:27.120]                           }
[10:31:27.120]                         }
[10:31:27.120]                       }
[10:31:27.120]                       invisible(muffled)
[10:31:27.120]                     }
[10:31:27.120]                     muffleCondition(cond, pattern = "^muffle")
[10:31:27.120]                   }
[10:31:27.120]                 }
[10:31:27.120]                 else {
[10:31:27.120]                   if (TRUE) {
[10:31:27.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.120]                     {
[10:31:27.120]                       inherits <- base::inherits
[10:31:27.120]                       invokeRestart <- base::invokeRestart
[10:31:27.120]                       is.null <- base::is.null
[10:31:27.120]                       muffled <- FALSE
[10:31:27.120]                       if (inherits(cond, "message")) {
[10:31:27.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:27.120]                         if (muffled) 
[10:31:27.120]                           invokeRestart("muffleMessage")
[10:31:27.120]                       }
[10:31:27.120]                       else if (inherits(cond, "warning")) {
[10:31:27.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:27.120]                         if (muffled) 
[10:31:27.120]                           invokeRestart("muffleWarning")
[10:31:27.120]                       }
[10:31:27.120]                       else if (inherits(cond, "condition")) {
[10:31:27.120]                         if (!is.null(pattern)) {
[10:31:27.120]                           computeRestarts <- base::computeRestarts
[10:31:27.120]                           grepl <- base::grepl
[10:31:27.120]                           restarts <- computeRestarts(cond)
[10:31:27.120]                           for (restart in restarts) {
[10:31:27.120]                             name <- restart$name
[10:31:27.120]                             if (is.null(name)) 
[10:31:27.120]                               next
[10:31:27.120]                             if (!grepl(pattern, name)) 
[10:31:27.120]                               next
[10:31:27.120]                             invokeRestart(restart)
[10:31:27.120]                             muffled <- TRUE
[10:31:27.120]                             break
[10:31:27.120]                           }
[10:31:27.120]                         }
[10:31:27.120]                       }
[10:31:27.120]                       invisible(muffled)
[10:31:27.120]                     }
[10:31:27.120]                     muffleCondition(cond, pattern = "^muffle")
[10:31:27.120]                   }
[10:31:27.120]                 }
[10:31:27.120]             }
[10:31:27.120]         }))
[10:31:27.120]     }, error = function(ex) {
[10:31:27.120]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:27.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:27.120]                 ...future.rng), started = ...future.startTime, 
[10:31:27.120]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:27.120]             version = "1.8"), class = "FutureResult")
[10:31:27.120]     }, finally = {
[10:31:27.120]         if (!identical(...future.workdir, getwd())) 
[10:31:27.120]             setwd(...future.workdir)
[10:31:27.120]         {
[10:31:27.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:27.120]                 ...future.oldOptions$nwarnings <- NULL
[10:31:27.120]             }
[10:31:27.120]             base::options(...future.oldOptions)
[10:31:27.120]             if (.Platform$OS.type == "windows") {
[10:31:27.120]                 old_names <- names(...future.oldEnvVars)
[10:31:27.120]                 envs <- base::Sys.getenv()
[10:31:27.120]                 names <- names(envs)
[10:31:27.120]                 common <- intersect(names, old_names)
[10:31:27.120]                 added <- setdiff(names, old_names)
[10:31:27.120]                 removed <- setdiff(old_names, names)
[10:31:27.120]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:27.120]                   envs[common]]
[10:31:27.120]                 NAMES <- toupper(changed)
[10:31:27.120]                 args <- list()
[10:31:27.120]                 for (kk in seq_along(NAMES)) {
[10:31:27.120]                   name <- changed[[kk]]
[10:31:27.120]                   NAME <- NAMES[[kk]]
[10:31:27.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.120]                     next
[10:31:27.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:27.120]                 }
[10:31:27.120]                 NAMES <- toupper(added)
[10:31:27.120]                 for (kk in seq_along(NAMES)) {
[10:31:27.120]                   name <- added[[kk]]
[10:31:27.120]                   NAME <- NAMES[[kk]]
[10:31:27.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.120]                     next
[10:31:27.120]                   args[[name]] <- ""
[10:31:27.120]                 }
[10:31:27.120]                 NAMES <- toupper(removed)
[10:31:27.120]                 for (kk in seq_along(NAMES)) {
[10:31:27.120]                   name <- removed[[kk]]
[10:31:27.120]                   NAME <- NAMES[[kk]]
[10:31:27.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.120]                     next
[10:31:27.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:27.120]                 }
[10:31:27.120]                 if (length(args) > 0) 
[10:31:27.120]                   base::do.call(base::Sys.setenv, args = args)
[10:31:27.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:27.120]             }
[10:31:27.120]             else {
[10:31:27.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:27.120]             }
[10:31:27.120]             {
[10:31:27.120]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:27.120]                   0L) {
[10:31:27.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:27.120]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:27.120]                   base::options(opts)
[10:31:27.120]                 }
[10:31:27.120]                 {
[10:31:27.120]                   {
[10:31:27.120]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:27.120]                     NULL
[10:31:27.120]                   }
[10:31:27.120]                   options(future.plan = NULL)
[10:31:27.120]                   if (is.na(NA_character_)) 
[10:31:27.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:27.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:27.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:27.120]                     .init = FALSE)
[10:31:27.120]                 }
[10:31:27.120]             }
[10:31:27.120]         }
[10:31:27.120]     })
[10:31:27.120]     if (TRUE) {
[10:31:27.120]         base::sink(type = "output", split = FALSE)
[10:31:27.120]         if (TRUE) {
[10:31:27.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:27.120]         }
[10:31:27.120]         else {
[10:31:27.120]             ...future.result["stdout"] <- base::list(NULL)
[10:31:27.120]         }
[10:31:27.120]         base::close(...future.stdout)
[10:31:27.120]         ...future.stdout <- NULL
[10:31:27.120]     }
[10:31:27.120]     ...future.result$conditions <- ...future.conditions
[10:31:27.120]     ...future.result$finished <- base::Sys.time()
[10:31:27.120]     ...future.result
[10:31:27.120] }
[10:31:27.123] Exporting 11 global objects (94.20 KiB) to cluster node #1 ...
[10:31:27.123] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:27.165] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:27.165] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ...
[10:31:27.166] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #1 ... DONE
[10:31:27.166] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:27.166] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:27.166] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:27.209] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:27.209] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:27.253] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:27.253] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:27.254] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.254] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:31:27.254] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:31:27.254] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:27.255] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.255] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:31:27.255] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:31:27.255] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:27.256] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.256] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:27.256] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.256] Exporting 11 global objects (94.20 KiB) to cluster node #1 ... DONE
[10:31:27.257] MultisessionFuture started
[10:31:27.257] - Launch lazy future ... done
[10:31:27.257] run() for ‘MultisessionFuture’ ... done
[10:31:27.257] Created future:
[10:31:27.257] MultisessionFuture:
[10:31:27.257] Label: ‘future_vapply-1’
[10:31:27.257] Expression:
[10:31:27.257] {
[10:31:27.257]     do.call(function(...) {
[10:31:27.257]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.257]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:27.257]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.257]             on.exit(options(oopts), add = TRUE)
[10:31:27.257]         }
[10:31:27.257]         {
[10:31:27.257]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:27.257]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.257]                 ...future.FUN(...future.X_jj, ...)
[10:31:27.257]             })
[10:31:27.257]         }
[10:31:27.257]     }, args = future.call.arguments)
[10:31:27.257] }
[10:31:27.257] Lazy evaluation: FALSE
[10:31:27.257] Asynchronous evaluation: TRUE
[10:31:27.257] Local evaluation: TRUE
[10:31:27.257] Environment: R_GlobalEnv
[10:31:27.257] Capture standard output: TRUE
[10:31:27.257] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:27.257] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:27.257] Packages: 1 packages (‘future.apply’)
[10:31:27.257] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:27.257] Resolved: FALSE
[10:31:27.257] Value: <not collected>
[10:31:27.257] Conditions captured: <none>
[10:31:27.257] Early signaling: FALSE
[10:31:27.257] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:27.257] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:27.269] Chunk #1 of 2 ... DONE
[10:31:27.269] Chunk #2 of 2 ...
[10:31:27.269]  - Finding globals in 'X' for chunk #2 ...
[10:31:27.269] getGlobalsAndPackages() ...
[10:31:27.270] Searching for globals...
[10:31:27.270] 
[10:31:27.270] Searching for globals ... DONE
[10:31:27.270] - globals: [0] <none>
[10:31:27.270] getGlobalsAndPackages() ... DONE
[10:31:27.270]    + additional globals found: [n=0] 
[10:31:27.270]    + additional namespaces needed: [n=0] 
[10:31:27.270]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:27.271]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:27.271]  - seeds: <none>
[10:31:27.271]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.271] getGlobalsAndPackages() ...
[10:31:27.273] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.273] Resolving globals: FALSE
[10:31:27.273] Tweak future expression to call with '...' arguments ...
[10:31:27.273] {
[10:31:27.273]     do.call(function(...) {
[10:31:27.273]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.273]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:27.273]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.273]             on.exit(options(oopts), add = TRUE)
[10:31:27.273]         }
[10:31:27.273]         {
[10:31:27.273]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:27.273]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.273]                 ...future.FUN(...future.X_jj, ...)
[10:31:27.273]             })
[10:31:27.273]         }
[10:31:27.273]     }, args = future.call.arguments)
[10:31:27.273] }
[10:31:27.274] Tweak future expression to call with '...' arguments ... DONE
[10:31:27.274] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.274] - packages: [1] ‘future.apply’
[10:31:27.274] getGlobalsAndPackages() ... DONE
[10:31:27.275] run() for ‘Future’ ...
[10:31:27.275] - state: ‘created’
[10:31:27.275] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:27.290] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:27.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:27.290]   - Field: ‘node’
[10:31:27.290]   - Field: ‘label’
[10:31:27.290]   - Field: ‘local’
[10:31:27.290]   - Field: ‘owner’
[10:31:27.290]   - Field: ‘envir’
[10:31:27.290]   - Field: ‘workers’
[10:31:27.290]   - Field: ‘packages’
[10:31:27.291]   - Field: ‘gc’
[10:31:27.291]   - Field: ‘conditions’
[10:31:27.291]   - Field: ‘persistent’
[10:31:27.291]   - Field: ‘expr’
[10:31:27.291]   - Field: ‘uuid’
[10:31:27.291]   - Field: ‘seed’
[10:31:27.291]   - Field: ‘version’
[10:31:27.291]   - Field: ‘result’
[10:31:27.291]   - Field: ‘asynchronous’
[10:31:27.291]   - Field: ‘calls’
[10:31:27.291]   - Field: ‘globals’
[10:31:27.291]   - Field: ‘stdout’
[10:31:27.292]   - Field: ‘earlySignal’
[10:31:27.292]   - Field: ‘lazy’
[10:31:27.292]   - Field: ‘state’
[10:31:27.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:27.292] - Launch lazy future ...
[10:31:27.292] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:27.292] Packages needed by future strategies (n = 0): <none>
[10:31:27.293] {
[10:31:27.293]     {
[10:31:27.293]         {
[10:31:27.293]             ...future.startTime <- base::Sys.time()
[10:31:27.293]             {
[10:31:27.293]                 {
[10:31:27.293]                   {
[10:31:27.293]                     {
[10:31:27.293]                       {
[10:31:27.293]                         base::local({
[10:31:27.293]                           has_future <- base::requireNamespace("future", 
[10:31:27.293]                             quietly = TRUE)
[10:31:27.293]                           if (has_future) {
[10:31:27.293]                             ns <- base::getNamespace("future")
[10:31:27.293]                             version <- ns[[".package"]][["version"]]
[10:31:27.293]                             if (is.null(version)) 
[10:31:27.293]                               version <- utils::packageVersion("future")
[10:31:27.293]                           }
[10:31:27.293]                           else {
[10:31:27.293]                             version <- NULL
[10:31:27.293]                           }
[10:31:27.293]                           if (!has_future || version < "1.8.0") {
[10:31:27.293]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:27.293]                               "", base::R.version$version.string), 
[10:31:27.293]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:27.293]                                 base::R.version$platform, 8 * 
[10:31:27.293]                                   base::.Machine$sizeof.pointer), 
[10:31:27.293]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:27.293]                                 "release", "version")], collapse = " "), 
[10:31:27.293]                               hostname = base::Sys.info()[["nodename"]])
[10:31:27.293]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:27.293]                               info)
[10:31:27.293]                             info <- base::paste(info, collapse = "; ")
[10:31:27.293]                             if (!has_future) {
[10:31:27.293]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:27.293]                                 info)
[10:31:27.293]                             }
[10:31:27.293]                             else {
[10:31:27.293]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:27.293]                                 info, version)
[10:31:27.293]                             }
[10:31:27.293]                             base::stop(msg)
[10:31:27.293]                           }
[10:31:27.293]                         })
[10:31:27.293]                       }
[10:31:27.293]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:27.293]                       base::options(mc.cores = 1L)
[10:31:27.293]                     }
[10:31:27.293]                     base::local({
[10:31:27.293]                       for (pkg in "future.apply") {
[10:31:27.293]                         base::loadNamespace(pkg)
[10:31:27.293]                         base::library(pkg, character.only = TRUE)
[10:31:27.293]                       }
[10:31:27.293]                     })
[10:31:27.293]                   }
[10:31:27.293]                   ...future.strategy.old <- future::plan("list")
[10:31:27.293]                   options(future.plan = NULL)
[10:31:27.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:27.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:27.293]                 }
[10:31:27.293]                 ...future.workdir <- getwd()
[10:31:27.293]             }
[10:31:27.293]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:27.293]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:27.293]         }
[10:31:27.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:27.293]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:27.293]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:27.293]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:27.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:27.293]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:27.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:27.293]             base::names(...future.oldOptions))
[10:31:27.293]     }
[10:31:27.293]     if (FALSE) {
[10:31:27.293]     }
[10:31:27.293]     else {
[10:31:27.293]         if (TRUE) {
[10:31:27.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:27.293]                 open = "w")
[10:31:27.293]         }
[10:31:27.293]         else {
[10:31:27.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:27.293]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:27.293]         }
[10:31:27.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:27.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:27.293]             base::sink(type = "output", split = FALSE)
[10:31:27.293]             base::close(...future.stdout)
[10:31:27.293]         }, add = TRUE)
[10:31:27.293]     }
[10:31:27.293]     ...future.frame <- base::sys.nframe()
[10:31:27.293]     ...future.conditions <- base::list()
[10:31:27.293]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:27.293]     if (FALSE) {
[10:31:27.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:27.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:27.293]     }
[10:31:27.293]     ...future.result <- base::tryCatch({
[10:31:27.293]         base::withCallingHandlers({
[10:31:27.293]             ...future.value <- base::withVisible(base::local({
[10:31:27.293]                 ...future.makeSendCondition <- base::local({
[10:31:27.293]                   sendCondition <- NULL
[10:31:27.293]                   function(frame = 1L) {
[10:31:27.293]                     if (is.function(sendCondition)) 
[10:31:27.293]                       return(sendCondition)
[10:31:27.293]                     ns <- getNamespace("parallel")
[10:31:27.293]                     if (exists("sendData", mode = "function", 
[10:31:27.293]                       envir = ns)) {
[10:31:27.293]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:27.293]                         envir = ns)
[10:31:27.293]                       envir <- sys.frame(frame)
[10:31:27.293]                       master <- NULL
[10:31:27.293]                       while (!identical(envir, .GlobalEnv) && 
[10:31:27.293]                         !identical(envir, emptyenv())) {
[10:31:27.293]                         if (exists("master", mode = "list", envir = envir, 
[10:31:27.293]                           inherits = FALSE)) {
[10:31:27.293]                           master <- get("master", mode = "list", 
[10:31:27.293]                             envir = envir, inherits = FALSE)
[10:31:27.293]                           if (inherits(master, c("SOCKnode", 
[10:31:27.293]                             "SOCK0node"))) {
[10:31:27.293]                             sendCondition <<- function(cond) {
[10:31:27.293]                               data <- list(type = "VALUE", value = cond, 
[10:31:27.293]                                 success = TRUE)
[10:31:27.293]                               parallel_sendData(master, data)
[10:31:27.293]                             }
[10:31:27.293]                             return(sendCondition)
[10:31:27.293]                           }
[10:31:27.293]                         }
[10:31:27.293]                         frame <- frame + 1L
[10:31:27.293]                         envir <- sys.frame(frame)
[10:31:27.293]                       }
[10:31:27.293]                     }
[10:31:27.293]                     sendCondition <<- function(cond) NULL
[10:31:27.293]                   }
[10:31:27.293]                 })
[10:31:27.293]                 withCallingHandlers({
[10:31:27.293]                   {
[10:31:27.293]                     do.call(function(...) {
[10:31:27.293]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.293]                       if (!identical(...future.globals.maxSize.org, 
[10:31:27.293]                         ...future.globals.maxSize)) {
[10:31:27.293]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.293]                         on.exit(options(oopts), add = TRUE)
[10:31:27.293]                       }
[10:31:27.293]                       {
[10:31:27.293]                         lapply(seq_along(...future.elements_ii), 
[10:31:27.293]                           FUN = function(jj) {
[10:31:27.293]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.293]                             ...future.FUN(...future.X_jj, ...)
[10:31:27.293]                           })
[10:31:27.293]                       }
[10:31:27.293]                     }, args = future.call.arguments)
[10:31:27.293]                   }
[10:31:27.293]                 }, immediateCondition = function(cond) {
[10:31:27.293]                   sendCondition <- ...future.makeSendCondition()
[10:31:27.293]                   sendCondition(cond)
[10:31:27.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.293]                   {
[10:31:27.293]                     inherits <- base::inherits
[10:31:27.293]                     invokeRestart <- base::invokeRestart
[10:31:27.293]                     is.null <- base::is.null
[10:31:27.293]                     muffled <- FALSE
[10:31:27.293]                     if (inherits(cond, "message")) {
[10:31:27.293]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:27.293]                       if (muffled) 
[10:31:27.293]                         invokeRestart("muffleMessage")
[10:31:27.293]                     }
[10:31:27.293]                     else if (inherits(cond, "warning")) {
[10:31:27.293]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:27.293]                       if (muffled) 
[10:31:27.293]                         invokeRestart("muffleWarning")
[10:31:27.293]                     }
[10:31:27.293]                     else if (inherits(cond, "condition")) {
[10:31:27.293]                       if (!is.null(pattern)) {
[10:31:27.293]                         computeRestarts <- base::computeRestarts
[10:31:27.293]                         grepl <- base::grepl
[10:31:27.293]                         restarts <- computeRestarts(cond)
[10:31:27.293]                         for (restart in restarts) {
[10:31:27.293]                           name <- restart$name
[10:31:27.293]                           if (is.null(name)) 
[10:31:27.293]                             next
[10:31:27.293]                           if (!grepl(pattern, name)) 
[10:31:27.293]                             next
[10:31:27.293]                           invokeRestart(restart)
[10:31:27.293]                           muffled <- TRUE
[10:31:27.293]                           break
[10:31:27.293]                         }
[10:31:27.293]                       }
[10:31:27.293]                     }
[10:31:27.293]                     invisible(muffled)
[10:31:27.293]                   }
[10:31:27.293]                   muffleCondition(cond)
[10:31:27.293]                 })
[10:31:27.293]             }))
[10:31:27.293]             future::FutureResult(value = ...future.value$value, 
[10:31:27.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:27.293]                   ...future.rng), globalenv = if (FALSE) 
[10:31:27.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:27.293]                     ...future.globalenv.names))
[10:31:27.293]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:27.293]         }, condition = base::local({
[10:31:27.293]             c <- base::c
[10:31:27.293]             inherits <- base::inherits
[10:31:27.293]             invokeRestart <- base::invokeRestart
[10:31:27.293]             length <- base::length
[10:31:27.293]             list <- base::list
[10:31:27.293]             seq.int <- base::seq.int
[10:31:27.293]             signalCondition <- base::signalCondition
[10:31:27.293]             sys.calls <- base::sys.calls
[10:31:27.293]             `[[` <- base::`[[`
[10:31:27.293]             `+` <- base::`+`
[10:31:27.293]             `<<-` <- base::`<<-`
[10:31:27.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:27.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:27.293]                   3L)]
[10:31:27.293]             }
[10:31:27.293]             function(cond) {
[10:31:27.293]                 is_error <- inherits(cond, "error")
[10:31:27.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:27.293]                   NULL)
[10:31:27.293]                 if (is_error) {
[10:31:27.293]                   sessionInformation <- function() {
[10:31:27.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:27.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:27.293]                       search = base::search(), system = base::Sys.info())
[10:31:27.293]                   }
[10:31:27.293]                   ...future.conditions[[length(...future.conditions) + 
[10:31:27.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:27.293]                     cond$call), session = sessionInformation(), 
[10:31:27.293]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:27.293]                   signalCondition(cond)
[10:31:27.293]                 }
[10:31:27.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:27.293]                 "immediateCondition"))) {
[10:31:27.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:27.293]                   ...future.conditions[[length(...future.conditions) + 
[10:31:27.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:27.293]                   if (TRUE && !signal) {
[10:31:27.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.293]                     {
[10:31:27.293]                       inherits <- base::inherits
[10:31:27.293]                       invokeRestart <- base::invokeRestart
[10:31:27.293]                       is.null <- base::is.null
[10:31:27.293]                       muffled <- FALSE
[10:31:27.293]                       if (inherits(cond, "message")) {
[10:31:27.293]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:27.293]                         if (muffled) 
[10:31:27.293]                           invokeRestart("muffleMessage")
[10:31:27.293]                       }
[10:31:27.293]                       else if (inherits(cond, "warning")) {
[10:31:27.293]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:27.293]                         if (muffled) 
[10:31:27.293]                           invokeRestart("muffleWarning")
[10:31:27.293]                       }
[10:31:27.293]                       else if (inherits(cond, "condition")) {
[10:31:27.293]                         if (!is.null(pattern)) {
[10:31:27.293]                           computeRestarts <- base::computeRestarts
[10:31:27.293]                           grepl <- base::grepl
[10:31:27.293]                           restarts <- computeRestarts(cond)
[10:31:27.293]                           for (restart in restarts) {
[10:31:27.293]                             name <- restart$name
[10:31:27.293]                             if (is.null(name)) 
[10:31:27.293]                               next
[10:31:27.293]                             if (!grepl(pattern, name)) 
[10:31:27.293]                               next
[10:31:27.293]                             invokeRestart(restart)
[10:31:27.293]                             muffled <- TRUE
[10:31:27.293]                             break
[10:31:27.293]                           }
[10:31:27.293]                         }
[10:31:27.293]                       }
[10:31:27.293]                       invisible(muffled)
[10:31:27.293]                     }
[10:31:27.293]                     muffleCondition(cond, pattern = "^muffle")
[10:31:27.293]                   }
[10:31:27.293]                 }
[10:31:27.293]                 else {
[10:31:27.293]                   if (TRUE) {
[10:31:27.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.293]                     {
[10:31:27.293]                       inherits <- base::inherits
[10:31:27.293]                       invokeRestart <- base::invokeRestart
[10:31:27.293]                       is.null <- base::is.null
[10:31:27.293]                       muffled <- FALSE
[10:31:27.293]                       if (inherits(cond, "message")) {
[10:31:27.293]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:27.293]                         if (muffled) 
[10:31:27.293]                           invokeRestart("muffleMessage")
[10:31:27.293]                       }
[10:31:27.293]                       else if (inherits(cond, "warning")) {
[10:31:27.293]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:27.293]                         if (muffled) 
[10:31:27.293]                           invokeRestart("muffleWarning")
[10:31:27.293]                       }
[10:31:27.293]                       else if (inherits(cond, "condition")) {
[10:31:27.293]                         if (!is.null(pattern)) {
[10:31:27.293]                           computeRestarts <- base::computeRestarts
[10:31:27.293]                           grepl <- base::grepl
[10:31:27.293]                           restarts <- computeRestarts(cond)
[10:31:27.293]                           for (restart in restarts) {
[10:31:27.293]                             name <- restart$name
[10:31:27.293]                             if (is.null(name)) 
[10:31:27.293]                               next
[10:31:27.293]                             if (!grepl(pattern, name)) 
[10:31:27.293]                               next
[10:31:27.293]                             invokeRestart(restart)
[10:31:27.293]                             muffled <- TRUE
[10:31:27.293]                             break
[10:31:27.293]                           }
[10:31:27.293]                         }
[10:31:27.293]                       }
[10:31:27.293]                       invisible(muffled)
[10:31:27.293]                     }
[10:31:27.293]                     muffleCondition(cond, pattern = "^muffle")
[10:31:27.293]                   }
[10:31:27.293]                 }
[10:31:27.293]             }
[10:31:27.293]         }))
[10:31:27.293]     }, error = function(ex) {
[10:31:27.293]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:27.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:27.293]                 ...future.rng), started = ...future.startTime, 
[10:31:27.293]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:27.293]             version = "1.8"), class = "FutureResult")
[10:31:27.293]     }, finally = {
[10:31:27.293]         if (!identical(...future.workdir, getwd())) 
[10:31:27.293]             setwd(...future.workdir)
[10:31:27.293]         {
[10:31:27.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:27.293]                 ...future.oldOptions$nwarnings <- NULL
[10:31:27.293]             }
[10:31:27.293]             base::options(...future.oldOptions)
[10:31:27.293]             if (.Platform$OS.type == "windows") {
[10:31:27.293]                 old_names <- names(...future.oldEnvVars)
[10:31:27.293]                 envs <- base::Sys.getenv()
[10:31:27.293]                 names <- names(envs)
[10:31:27.293]                 common <- intersect(names, old_names)
[10:31:27.293]                 added <- setdiff(names, old_names)
[10:31:27.293]                 removed <- setdiff(old_names, names)
[10:31:27.293]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:27.293]                   envs[common]]
[10:31:27.293]                 NAMES <- toupper(changed)
[10:31:27.293]                 args <- list()
[10:31:27.293]                 for (kk in seq_along(NAMES)) {
[10:31:27.293]                   name <- changed[[kk]]
[10:31:27.293]                   NAME <- NAMES[[kk]]
[10:31:27.293]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.293]                     next
[10:31:27.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:27.293]                 }
[10:31:27.293]                 NAMES <- toupper(added)
[10:31:27.293]                 for (kk in seq_along(NAMES)) {
[10:31:27.293]                   name <- added[[kk]]
[10:31:27.293]                   NAME <- NAMES[[kk]]
[10:31:27.293]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.293]                     next
[10:31:27.293]                   args[[name]] <- ""
[10:31:27.293]                 }
[10:31:27.293]                 NAMES <- toupper(removed)
[10:31:27.293]                 for (kk in seq_along(NAMES)) {
[10:31:27.293]                   name <- removed[[kk]]
[10:31:27.293]                   NAME <- NAMES[[kk]]
[10:31:27.293]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.293]                     next
[10:31:27.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:27.293]                 }
[10:31:27.293]                 if (length(args) > 0) 
[10:31:27.293]                   base::do.call(base::Sys.setenv, args = args)
[10:31:27.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:27.293]             }
[10:31:27.293]             else {
[10:31:27.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:27.293]             }
[10:31:27.293]             {
[10:31:27.293]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:27.293]                   0L) {
[10:31:27.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:27.293]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:27.293]                   base::options(opts)
[10:31:27.293]                 }
[10:31:27.293]                 {
[10:31:27.293]                   {
[10:31:27.293]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:27.293]                     NULL
[10:31:27.293]                   }
[10:31:27.293]                   options(future.plan = NULL)
[10:31:27.293]                   if (is.na(NA_character_)) 
[10:31:27.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:27.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:27.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:27.293]                     .init = FALSE)
[10:31:27.293]                 }
[10:31:27.293]             }
[10:31:27.293]         }
[10:31:27.293]     })
[10:31:27.293]     if (TRUE) {
[10:31:27.293]         base::sink(type = "output", split = FALSE)
[10:31:27.293]         if (TRUE) {
[10:31:27.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:27.293]         }
[10:31:27.293]         else {
[10:31:27.293]             ...future.result["stdout"] <- base::list(NULL)
[10:31:27.293]         }
[10:31:27.293]         base::close(...future.stdout)
[10:31:27.293]         ...future.stdout <- NULL
[10:31:27.293]     }
[10:31:27.293]     ...future.result$conditions <- ...future.conditions
[10:31:27.293]     ...future.result$finished <- base::Sys.time()
[10:31:27.293]     ...future.result
[10:31:27.293] }
[10:31:27.296] Exporting 11 global objects (94.20 KiB) to cluster node #2 ...
[10:31:27.296] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:31:27.337] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:31:27.337] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ...
[10:31:27.338] Exporting ‘x_FUN’ (2.12 KiB) to cluster node #2 ... DONE
[10:31:27.338] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:31:27.338] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:31:27.338] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:31:27.381] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:31:27.381] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:31:27.425] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:31:27.425] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:31:27.426] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:31:27.426] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:31:27.426] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:31:27.427] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:31:27.427] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:31:27.427] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:31:27.427] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:31:27.428] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:27.428] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:27.428] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:27.428] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:27.429] Exporting 11 global objects (94.20 KiB) to cluster node #2 ... DONE
[10:31:27.429] MultisessionFuture started
[10:31:27.429] - Launch lazy future ... done
[10:31:27.429] run() for ‘MultisessionFuture’ ... done
[10:31:27.430] Created future:
[10:31:27.431] receiveMessageFromWorker() for ClusterFuture ...
[10:31:27.431] - Validating connection of MultisessionFuture
[10:31:27.431] - received message: FutureResult
[10:31:27.431] - Received FutureResult
[10:31:27.432] - Erased future from FutureRegistry
[10:31:27.432] result() for ClusterFuture ...
[10:31:27.432] - result already collected: FutureResult
[10:31:27.432] result() for ClusterFuture ... done
[10:31:27.432] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:27.430] MultisessionFuture:
[10:31:27.430] Label: ‘future_vapply-2’
[10:31:27.430] Expression:
[10:31:27.430] {
[10:31:27.430]     do.call(function(...) {
[10:31:27.430]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.430]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:27.430]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.430]             on.exit(options(oopts), add = TRUE)
[10:31:27.430]         }
[10:31:27.430]         {
[10:31:27.430]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:27.430]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.430]                 ...future.FUN(...future.X_jj, ...)
[10:31:27.430]             })
[10:31:27.430]         }
[10:31:27.430]     }, args = future.call.arguments)
[10:31:27.430] }
[10:31:27.430] Lazy evaluation: FALSE
[10:31:27.430] Asynchronous evaluation: TRUE
[10:31:27.430] Local evaluation: TRUE
[10:31:27.430] Environment: R_GlobalEnv
[10:31:27.430] Capture standard output: TRUE
[10:31:27.430] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:27.430] Globals: 11 objects totaling 94.47 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.12 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:27.430] Packages: 1 packages (‘future.apply’)
[10:31:27.430] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:27.430] Resolved: TRUE
[10:31:27.430] Value: <not collected>
[10:31:27.430] Conditions captured: <none>
[10:31:27.430] Early signaling: FALSE
[10:31:27.430] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:27.430] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:27.432] Chunk #2 of 2 ... DONE
[10:31:27.432] Launching 2 futures (chunks) ... DONE
[10:31:27.433] Resolving 2 futures (chunks) ...
[10:31:27.433] resolve() on list ...
[10:31:27.433]  recursive: 0
[10:31:27.433]  length: 2
[10:31:27.433] 
[10:31:27.433] receiveMessageFromWorker() for ClusterFuture ...
[10:31:27.434] - Validating connection of MultisessionFuture
[10:31:27.434] - received message: FutureResult
[10:31:27.434] - Received FutureResult
[10:31:27.434] - Erased future from FutureRegistry
[10:31:27.434] result() for ClusterFuture ...
[10:31:27.434] - result already collected: FutureResult
[10:31:27.434] result() for ClusterFuture ... done
[10:31:27.434] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:27.434] Future #1
[10:31:27.434] result() for ClusterFuture ...
[10:31:27.435] - result already collected: FutureResult
[10:31:27.435] result() for ClusterFuture ... done
[10:31:27.435] result() for ClusterFuture ...
[10:31:27.435] - result already collected: FutureResult
[10:31:27.435] result() for ClusterFuture ... done
[10:31:27.435] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:27.435] - nx: 2
[10:31:27.435] - relay: TRUE
[10:31:27.435] - stdout: TRUE
[10:31:27.435] - signal: TRUE
[10:31:27.435] - resignal: FALSE
[10:31:27.436] - force: TRUE
[10:31:27.436] - relayed: [n=2] FALSE, FALSE
[10:31:27.436] - queued futures: [n=2] FALSE, FALSE
[10:31:27.436]  - until=1
[10:31:27.436]  - relaying element #1
[10:31:27.436] result() for ClusterFuture ...
[10:31:27.436] - result already collected: FutureResult
[10:31:27.436] result() for ClusterFuture ... done
[10:31:27.436] result() for ClusterFuture ...
[10:31:27.436] - result already collected: FutureResult
[10:31:27.436] result() for ClusterFuture ... done
[10:31:27.437] result() for ClusterFuture ...
[10:31:27.437] - result already collected: FutureResult
[10:31:27.437] result() for ClusterFuture ... done
[10:31:27.437] result() for ClusterFuture ...
[10:31:27.437] - result already collected: FutureResult
[10:31:27.437] result() for ClusterFuture ... done
[10:31:27.437] - relayed: [n=2] TRUE, FALSE
[10:31:27.437] - queued futures: [n=2] TRUE, FALSE
[10:31:27.437] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:27.437]  length: 1 (resolved future 1)
[10:31:27.438] Future #2
[10:31:27.438] result() for ClusterFuture ...
[10:31:27.438] - result already collected: FutureResult
[10:31:27.438] result() for ClusterFuture ... done
[10:31:27.438] result() for ClusterFuture ...
[10:31:27.438] - result already collected: FutureResult
[10:31:27.438] result() for ClusterFuture ... done
[10:31:27.438] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:27.438] - nx: 2
[10:31:27.438] - relay: TRUE
[10:31:27.438] - stdout: TRUE
[10:31:27.438] - signal: TRUE
[10:31:27.439] - resignal: FALSE
[10:31:27.439] - force: TRUE
[10:31:27.439] - relayed: [n=2] TRUE, FALSE
[10:31:27.439] - queued futures: [n=2] TRUE, FALSE
[10:31:27.439]  - until=2
[10:31:27.439]  - relaying element #2
[10:31:27.439] result() for ClusterFuture ...
[10:31:27.439] - result already collected: FutureResult
[10:31:27.439] result() for ClusterFuture ... done
[10:31:27.439] result() for ClusterFuture ...
[10:31:27.439] - result already collected: FutureResult
[10:31:27.440] result() for ClusterFuture ... done
[10:31:27.440] result() for ClusterFuture ...
[10:31:27.440] - result already collected: FutureResult
[10:31:27.440] result() for ClusterFuture ... done
[10:31:27.440] result() for ClusterFuture ...
[10:31:27.440] - result already collected: FutureResult
[10:31:27.440] result() for ClusterFuture ... done
[10:31:27.440] - relayed: [n=2] TRUE, TRUE
[10:31:27.440] - queued futures: [n=2] TRUE, TRUE
[10:31:27.440] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:27.440]  length: 0 (resolved future 2)
[10:31:27.440] Relaying remaining futures
[10:31:27.441] signalConditionsASAP(NULL, pos=0) ...
[10:31:27.441] - nx: 2
[10:31:27.441] - relay: TRUE
[10:31:27.441] - stdout: TRUE
[10:31:27.441] - signal: TRUE
[10:31:27.441] - resignal: FALSE
[10:31:27.441] - force: TRUE
[10:31:27.441] - relayed: [n=2] TRUE, TRUE
[10:31:27.441] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:27.441] - relayed: [n=2] TRUE, TRUE
[10:31:27.441] - queued futures: [n=2] TRUE, TRUE
[10:31:27.442] signalConditionsASAP(NULL, pos=0) ... done
[10:31:27.442] resolve() on list ... DONE
[10:31:27.442] result() for ClusterFuture ...
[10:31:27.442] - result already collected: FutureResult
[10:31:27.442] result() for ClusterFuture ... done
[10:31:27.442] result() for ClusterFuture ...
[10:31:27.442] - result already collected: FutureResult
[10:31:27.442] result() for ClusterFuture ... done
[10:31:27.442] result() for ClusterFuture ...
[10:31:27.442] - result already collected: FutureResult
[10:31:27.442] result() for ClusterFuture ... done
[10:31:27.443] result() for ClusterFuture ...
[10:31:27.443] - result already collected: FutureResult
[10:31:27.443] result() for ClusterFuture ... done
[10:31:27.443]  - Number of value chunks collected: 2
[10:31:27.443] Resolving 2 futures (chunks) ... DONE
[10:31:27.443] Reducing values from 2 chunks ...
[10:31:27.443]  - Number of values collected after concatenation: 10
[10:31:27.443]  - Number of values expected: 10
[10:31:27.443] Reducing values from 2 chunks ... DONE
[10:31:27.443] future_lapply() ... DONE
 num [1:2, 1:10] 1 1 2 4 3 9 4 16 5 25 ...
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:31:27.444] future_lapply() ...
[10:31:27.450] Number of chunks: 2
[10:31:27.450] getGlobalsAndPackagesXApply() ...
[10:31:27.450]  - future.globals: TRUE
[10:31:27.450] getGlobalsAndPackages() ...
[10:31:27.450] Searching for globals...
[10:31:27.453] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:31:27.454] Searching for globals ... DONE
[10:31:27.454] Resolving globals: FALSE
[10:31:27.454] The total size of the 7 globals is 94.95 KiB (97232 bytes)
[10:31:27.455] The total size of the 7 globals exported for future expression (‘FUN()’) is 94.95 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:27.455] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:27.455] - packages: [1] ‘future.apply’
[10:31:27.455] getGlobalsAndPackages() ... DONE
[10:31:27.455]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:27.455]  - needed namespaces: [n=1] ‘future.apply’
[10:31:27.456] Finding globals ... DONE
[10:31:27.456]  - use_args: TRUE
[10:31:27.456]  - Getting '...' globals ...
[10:31:27.456] resolve() on list ...
[10:31:27.456]  recursive: 0
[10:31:27.456]  length: 1
[10:31:27.456]  elements: ‘...’
[10:31:27.456]  length: 0 (resolved future 1)
[10:31:27.456] resolve() on list ... DONE
[10:31:27.457]    - '...' content: [n=0] 
[10:31:27.457] List of 1
[10:31:27.457]  $ ...: list()
[10:31:27.457]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:27.457]  - attr(*, "where")=List of 1
[10:31:27.457]   ..$ ...:<environment: 0x55de866d79b0> 
[10:31:27.457]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:27.457]  - attr(*, "resolved")= logi TRUE
[10:31:27.457]  - attr(*, "total_size")= num NA
[10:31:27.459]  - Getting '...' globals ... DONE
[10:31:27.459] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:27.459] List of 8
[10:31:27.459]  $ ...future.FUN:function (x, ...)  
[10:31:27.459]  $ x_FUN        :function (x)  
[10:31:27.459]  $ times        : int 4
[10:31:27.459]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:27.459]  $ stop_if_not  :function (...)  
[10:31:27.459]  $ dim          : int [1:2] 2 2
[10:31:27.459]  $ valid_types  : chr [1:2] "logical" "integer"
[10:31:27.459]  $ ...          : list()
[10:31:27.459]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:27.459]  - attr(*, "where")=List of 8
[10:31:27.459]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:27.459]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:27.459]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:27.459]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:27.459]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:27.459]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:27.459]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:27.459]   ..$ ...          :<environment: 0x55de866d79b0> 
[10:31:27.459]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:27.459]  - attr(*, "resolved")= logi FALSE
[10:31:27.459]  - attr(*, "total_size")= num 97232
[10:31:27.465] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:27.465] getGlobalsAndPackagesXApply() ... DONE
[10:31:27.465] Number of futures (= number of chunks): 2
[10:31:27.465] Launching 2 futures (chunks) ...
[10:31:27.465] Chunk #1 of 2 ...
[10:31:27.465]  - Finding globals in 'X' for chunk #1 ...
[10:31:27.466] getGlobalsAndPackages() ...
[10:31:27.466] Searching for globals...
[10:31:27.466] 
[10:31:27.466] Searching for globals ... DONE
[10:31:27.466] - globals: [0] <none>
[10:31:27.466] getGlobalsAndPackages() ... DONE
[10:31:27.466]    + additional globals found: [n=0] 
[10:31:27.466]    + additional namespaces needed: [n=0] 
[10:31:27.466]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:27.466]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:27.467]  - seeds: <none>
[10:31:27.467]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.467] getGlobalsAndPackages() ...
[10:31:27.467] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.467] Resolving globals: FALSE
[10:31:27.467] Tweak future expression to call with '...' arguments ...
[10:31:27.467] {
[10:31:27.467]     do.call(function(...) {
[10:31:27.467]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.467]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:27.467]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.467]             on.exit(options(oopts), add = TRUE)
[10:31:27.467]         }
[10:31:27.467]         {
[10:31:27.467]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:27.467]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.467]                 ...future.FUN(...future.X_jj, ...)
[10:31:27.467]             })
[10:31:27.467]         }
[10:31:27.467]     }, args = future.call.arguments)
[10:31:27.467] }
[10:31:27.467] Tweak future expression to call with '...' arguments ... DONE
[10:31:27.468] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.468] - packages: [1] ‘future.apply’
[10:31:27.468] getGlobalsAndPackages() ... DONE
[10:31:27.468] run() for ‘Future’ ...
[10:31:27.469] - state: ‘created’
[10:31:27.469] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:27.482] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:27.483] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:27.483]   - Field: ‘node’
[10:31:27.483]   - Field: ‘label’
[10:31:27.483]   - Field: ‘local’
[10:31:27.483]   - Field: ‘owner’
[10:31:27.483]   - Field: ‘envir’
[10:31:27.483]   - Field: ‘workers’
[10:31:27.483]   - Field: ‘packages’
[10:31:27.483]   - Field: ‘gc’
[10:31:27.483]   - Field: ‘conditions’
[10:31:27.484]   - Field: ‘persistent’
[10:31:27.484]   - Field: ‘expr’
[10:31:27.484]   - Field: ‘uuid’
[10:31:27.484]   - Field: ‘seed’
[10:31:27.484]   - Field: ‘version’
[10:31:27.484]   - Field: ‘result’
[10:31:27.484]   - Field: ‘asynchronous’
[10:31:27.484]   - Field: ‘calls’
[10:31:27.484]   - Field: ‘globals’
[10:31:27.484]   - Field: ‘stdout’
[10:31:27.484]   - Field: ‘earlySignal’
[10:31:27.485]   - Field: ‘lazy’
[10:31:27.485]   - Field: ‘state’
[10:31:27.485] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:27.485] - Launch lazy future ...
[10:31:27.485] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:27.485] Packages needed by future strategies (n = 0): <none>
[10:31:27.486] {
[10:31:27.486]     {
[10:31:27.486]         {
[10:31:27.486]             ...future.startTime <- base::Sys.time()
[10:31:27.486]             {
[10:31:27.486]                 {
[10:31:27.486]                   {
[10:31:27.486]                     {
[10:31:27.486]                       {
[10:31:27.486]                         base::local({
[10:31:27.486]                           has_future <- base::requireNamespace("future", 
[10:31:27.486]                             quietly = TRUE)
[10:31:27.486]                           if (has_future) {
[10:31:27.486]                             ns <- base::getNamespace("future")
[10:31:27.486]                             version <- ns[[".package"]][["version"]]
[10:31:27.486]                             if (is.null(version)) 
[10:31:27.486]                               version <- utils::packageVersion("future")
[10:31:27.486]                           }
[10:31:27.486]                           else {
[10:31:27.486]                             version <- NULL
[10:31:27.486]                           }
[10:31:27.486]                           if (!has_future || version < "1.8.0") {
[10:31:27.486]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:27.486]                               "", base::R.version$version.string), 
[10:31:27.486]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:27.486]                                 base::R.version$platform, 8 * 
[10:31:27.486]                                   base::.Machine$sizeof.pointer), 
[10:31:27.486]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:27.486]                                 "release", "version")], collapse = " "), 
[10:31:27.486]                               hostname = base::Sys.info()[["nodename"]])
[10:31:27.486]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:27.486]                               info)
[10:31:27.486]                             info <- base::paste(info, collapse = "; ")
[10:31:27.486]                             if (!has_future) {
[10:31:27.486]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:27.486]                                 info)
[10:31:27.486]                             }
[10:31:27.486]                             else {
[10:31:27.486]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:27.486]                                 info, version)
[10:31:27.486]                             }
[10:31:27.486]                             base::stop(msg)
[10:31:27.486]                           }
[10:31:27.486]                         })
[10:31:27.486]                       }
[10:31:27.486]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:27.486]                       base::options(mc.cores = 1L)
[10:31:27.486]                     }
[10:31:27.486]                     base::local({
[10:31:27.486]                       for (pkg in "future.apply") {
[10:31:27.486]                         base::loadNamespace(pkg)
[10:31:27.486]                         base::library(pkg, character.only = TRUE)
[10:31:27.486]                       }
[10:31:27.486]                     })
[10:31:27.486]                   }
[10:31:27.486]                   ...future.strategy.old <- future::plan("list")
[10:31:27.486]                   options(future.plan = NULL)
[10:31:27.486]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:27.486]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:27.486]                 }
[10:31:27.486]                 ...future.workdir <- getwd()
[10:31:27.486]             }
[10:31:27.486]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:27.486]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:27.486]         }
[10:31:27.486]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:27.486]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:27.486]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:27.486]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:27.486]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:27.486]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:27.486]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:27.486]             base::names(...future.oldOptions))
[10:31:27.486]     }
[10:31:27.486]     if (FALSE) {
[10:31:27.486]     }
[10:31:27.486]     else {
[10:31:27.486]         if (TRUE) {
[10:31:27.486]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:27.486]                 open = "w")
[10:31:27.486]         }
[10:31:27.486]         else {
[10:31:27.486]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:27.486]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:27.486]         }
[10:31:27.486]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:27.486]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:27.486]             base::sink(type = "output", split = FALSE)
[10:31:27.486]             base::close(...future.stdout)
[10:31:27.486]         }, add = TRUE)
[10:31:27.486]     }
[10:31:27.486]     ...future.frame <- base::sys.nframe()
[10:31:27.486]     ...future.conditions <- base::list()
[10:31:27.486]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:27.486]     if (FALSE) {
[10:31:27.486]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:27.486]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:27.486]     }
[10:31:27.486]     ...future.result <- base::tryCatch({
[10:31:27.486]         base::withCallingHandlers({
[10:31:27.486]             ...future.value <- base::withVisible(base::local({
[10:31:27.486]                 ...future.makeSendCondition <- base::local({
[10:31:27.486]                   sendCondition <- NULL
[10:31:27.486]                   function(frame = 1L) {
[10:31:27.486]                     if (is.function(sendCondition)) 
[10:31:27.486]                       return(sendCondition)
[10:31:27.486]                     ns <- getNamespace("parallel")
[10:31:27.486]                     if (exists("sendData", mode = "function", 
[10:31:27.486]                       envir = ns)) {
[10:31:27.486]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:27.486]                         envir = ns)
[10:31:27.486]                       envir <- sys.frame(frame)
[10:31:27.486]                       master <- NULL
[10:31:27.486]                       while (!identical(envir, .GlobalEnv) && 
[10:31:27.486]                         !identical(envir, emptyenv())) {
[10:31:27.486]                         if (exists("master", mode = "list", envir = envir, 
[10:31:27.486]                           inherits = FALSE)) {
[10:31:27.486]                           master <- get("master", mode = "list", 
[10:31:27.486]                             envir = envir, inherits = FALSE)
[10:31:27.486]                           if (inherits(master, c("SOCKnode", 
[10:31:27.486]                             "SOCK0node"))) {
[10:31:27.486]                             sendCondition <<- function(cond) {
[10:31:27.486]                               data <- list(type = "VALUE", value = cond, 
[10:31:27.486]                                 success = TRUE)
[10:31:27.486]                               parallel_sendData(master, data)
[10:31:27.486]                             }
[10:31:27.486]                             return(sendCondition)
[10:31:27.486]                           }
[10:31:27.486]                         }
[10:31:27.486]                         frame <- frame + 1L
[10:31:27.486]                         envir <- sys.frame(frame)
[10:31:27.486]                       }
[10:31:27.486]                     }
[10:31:27.486]                     sendCondition <<- function(cond) NULL
[10:31:27.486]                   }
[10:31:27.486]                 })
[10:31:27.486]                 withCallingHandlers({
[10:31:27.486]                   {
[10:31:27.486]                     do.call(function(...) {
[10:31:27.486]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.486]                       if (!identical(...future.globals.maxSize.org, 
[10:31:27.486]                         ...future.globals.maxSize)) {
[10:31:27.486]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.486]                         on.exit(options(oopts), add = TRUE)
[10:31:27.486]                       }
[10:31:27.486]                       {
[10:31:27.486]                         lapply(seq_along(...future.elements_ii), 
[10:31:27.486]                           FUN = function(jj) {
[10:31:27.486]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.486]                             ...future.FUN(...future.X_jj, ...)
[10:31:27.486]                           })
[10:31:27.486]                       }
[10:31:27.486]                     }, args = future.call.arguments)
[10:31:27.486]                   }
[10:31:27.486]                 }, immediateCondition = function(cond) {
[10:31:27.486]                   sendCondition <- ...future.makeSendCondition()
[10:31:27.486]                   sendCondition(cond)
[10:31:27.486]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.486]                   {
[10:31:27.486]                     inherits <- base::inherits
[10:31:27.486]                     invokeRestart <- base::invokeRestart
[10:31:27.486]                     is.null <- base::is.null
[10:31:27.486]                     muffled <- FALSE
[10:31:27.486]                     if (inherits(cond, "message")) {
[10:31:27.486]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:27.486]                       if (muffled) 
[10:31:27.486]                         invokeRestart("muffleMessage")
[10:31:27.486]                     }
[10:31:27.486]                     else if (inherits(cond, "warning")) {
[10:31:27.486]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:27.486]                       if (muffled) 
[10:31:27.486]                         invokeRestart("muffleWarning")
[10:31:27.486]                     }
[10:31:27.486]                     else if (inherits(cond, "condition")) {
[10:31:27.486]                       if (!is.null(pattern)) {
[10:31:27.486]                         computeRestarts <- base::computeRestarts
[10:31:27.486]                         grepl <- base::grepl
[10:31:27.486]                         restarts <- computeRestarts(cond)
[10:31:27.486]                         for (restart in restarts) {
[10:31:27.486]                           name <- restart$name
[10:31:27.486]                           if (is.null(name)) 
[10:31:27.486]                             next
[10:31:27.486]                           if (!grepl(pattern, name)) 
[10:31:27.486]                             next
[10:31:27.486]                           invokeRestart(restart)
[10:31:27.486]                           muffled <- TRUE
[10:31:27.486]                           break
[10:31:27.486]                         }
[10:31:27.486]                       }
[10:31:27.486]                     }
[10:31:27.486]                     invisible(muffled)
[10:31:27.486]                   }
[10:31:27.486]                   muffleCondition(cond)
[10:31:27.486]                 })
[10:31:27.486]             }))
[10:31:27.486]             future::FutureResult(value = ...future.value$value, 
[10:31:27.486]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:27.486]                   ...future.rng), globalenv = if (FALSE) 
[10:31:27.486]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:27.486]                     ...future.globalenv.names))
[10:31:27.486]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:27.486]         }, condition = base::local({
[10:31:27.486]             c <- base::c
[10:31:27.486]             inherits <- base::inherits
[10:31:27.486]             invokeRestart <- base::invokeRestart
[10:31:27.486]             length <- base::length
[10:31:27.486]             list <- base::list
[10:31:27.486]             seq.int <- base::seq.int
[10:31:27.486]             signalCondition <- base::signalCondition
[10:31:27.486]             sys.calls <- base::sys.calls
[10:31:27.486]             `[[` <- base::`[[`
[10:31:27.486]             `+` <- base::`+`
[10:31:27.486]             `<<-` <- base::`<<-`
[10:31:27.486]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:27.486]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:27.486]                   3L)]
[10:31:27.486]             }
[10:31:27.486]             function(cond) {
[10:31:27.486]                 is_error <- inherits(cond, "error")
[10:31:27.486]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:27.486]                   NULL)
[10:31:27.486]                 if (is_error) {
[10:31:27.486]                   sessionInformation <- function() {
[10:31:27.486]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:27.486]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:27.486]                       search = base::search(), system = base::Sys.info())
[10:31:27.486]                   }
[10:31:27.486]                   ...future.conditions[[length(...future.conditions) + 
[10:31:27.486]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:27.486]                     cond$call), session = sessionInformation(), 
[10:31:27.486]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:27.486]                   signalCondition(cond)
[10:31:27.486]                 }
[10:31:27.486]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:27.486]                 "immediateCondition"))) {
[10:31:27.486]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:27.486]                   ...future.conditions[[length(...future.conditions) + 
[10:31:27.486]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:27.486]                   if (TRUE && !signal) {
[10:31:27.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.486]                     {
[10:31:27.486]                       inherits <- base::inherits
[10:31:27.486]                       invokeRestart <- base::invokeRestart
[10:31:27.486]                       is.null <- base::is.null
[10:31:27.486]                       muffled <- FALSE
[10:31:27.486]                       if (inherits(cond, "message")) {
[10:31:27.486]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:27.486]                         if (muffled) 
[10:31:27.486]                           invokeRestart("muffleMessage")
[10:31:27.486]                       }
[10:31:27.486]                       else if (inherits(cond, "warning")) {
[10:31:27.486]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:27.486]                         if (muffled) 
[10:31:27.486]                           invokeRestart("muffleWarning")
[10:31:27.486]                       }
[10:31:27.486]                       else if (inherits(cond, "condition")) {
[10:31:27.486]                         if (!is.null(pattern)) {
[10:31:27.486]                           computeRestarts <- base::computeRestarts
[10:31:27.486]                           grepl <- base::grepl
[10:31:27.486]                           restarts <- computeRestarts(cond)
[10:31:27.486]                           for (restart in restarts) {
[10:31:27.486]                             name <- restart$name
[10:31:27.486]                             if (is.null(name)) 
[10:31:27.486]                               next
[10:31:27.486]                             if (!grepl(pattern, name)) 
[10:31:27.486]                               next
[10:31:27.486]                             invokeRestart(restart)
[10:31:27.486]                             muffled <- TRUE
[10:31:27.486]                             break
[10:31:27.486]                           }
[10:31:27.486]                         }
[10:31:27.486]                       }
[10:31:27.486]                       invisible(muffled)
[10:31:27.486]                     }
[10:31:27.486]                     muffleCondition(cond, pattern = "^muffle")
[10:31:27.486]                   }
[10:31:27.486]                 }
[10:31:27.486]                 else {
[10:31:27.486]                   if (TRUE) {
[10:31:27.486]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.486]                     {
[10:31:27.486]                       inherits <- base::inherits
[10:31:27.486]                       invokeRestart <- base::invokeRestart
[10:31:27.486]                       is.null <- base::is.null
[10:31:27.486]                       muffled <- FALSE
[10:31:27.486]                       if (inherits(cond, "message")) {
[10:31:27.486]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:27.486]                         if (muffled) 
[10:31:27.486]                           invokeRestart("muffleMessage")
[10:31:27.486]                       }
[10:31:27.486]                       else if (inherits(cond, "warning")) {
[10:31:27.486]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:27.486]                         if (muffled) 
[10:31:27.486]                           invokeRestart("muffleWarning")
[10:31:27.486]                       }
[10:31:27.486]                       else if (inherits(cond, "condition")) {
[10:31:27.486]                         if (!is.null(pattern)) {
[10:31:27.486]                           computeRestarts <- base::computeRestarts
[10:31:27.486]                           grepl <- base::grepl
[10:31:27.486]                           restarts <- computeRestarts(cond)
[10:31:27.486]                           for (restart in restarts) {
[10:31:27.486]                             name <- restart$name
[10:31:27.486]                             if (is.null(name)) 
[10:31:27.486]                               next
[10:31:27.486]                             if (!grepl(pattern, name)) 
[10:31:27.486]                               next
[10:31:27.486]                             invokeRestart(restart)
[10:31:27.486]                             muffled <- TRUE
[10:31:27.486]                             break
[10:31:27.486]                           }
[10:31:27.486]                         }
[10:31:27.486]                       }
[10:31:27.486]                       invisible(muffled)
[10:31:27.486]                     }
[10:31:27.486]                     muffleCondition(cond, pattern = "^muffle")
[10:31:27.486]                   }
[10:31:27.486]                 }
[10:31:27.486]             }
[10:31:27.486]         }))
[10:31:27.486]     }, error = function(ex) {
[10:31:27.486]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:27.486]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:27.486]                 ...future.rng), started = ...future.startTime, 
[10:31:27.486]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:27.486]             version = "1.8"), class = "FutureResult")
[10:31:27.486]     }, finally = {
[10:31:27.486]         if (!identical(...future.workdir, getwd())) 
[10:31:27.486]             setwd(...future.workdir)
[10:31:27.486]         {
[10:31:27.486]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:27.486]                 ...future.oldOptions$nwarnings <- NULL
[10:31:27.486]             }
[10:31:27.486]             base::options(...future.oldOptions)
[10:31:27.486]             if (.Platform$OS.type == "windows") {
[10:31:27.486]                 old_names <- names(...future.oldEnvVars)
[10:31:27.486]                 envs <- base::Sys.getenv()
[10:31:27.486]                 names <- names(envs)
[10:31:27.486]                 common <- intersect(names, old_names)
[10:31:27.486]                 added <- setdiff(names, old_names)
[10:31:27.486]                 removed <- setdiff(old_names, names)
[10:31:27.486]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:27.486]                   envs[common]]
[10:31:27.486]                 NAMES <- toupper(changed)
[10:31:27.486]                 args <- list()
[10:31:27.486]                 for (kk in seq_along(NAMES)) {
[10:31:27.486]                   name <- changed[[kk]]
[10:31:27.486]                   NAME <- NAMES[[kk]]
[10:31:27.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.486]                     next
[10:31:27.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:27.486]                 }
[10:31:27.486]                 NAMES <- toupper(added)
[10:31:27.486]                 for (kk in seq_along(NAMES)) {
[10:31:27.486]                   name <- added[[kk]]
[10:31:27.486]                   NAME <- NAMES[[kk]]
[10:31:27.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.486]                     next
[10:31:27.486]                   args[[name]] <- ""
[10:31:27.486]                 }
[10:31:27.486]                 NAMES <- toupper(removed)
[10:31:27.486]                 for (kk in seq_along(NAMES)) {
[10:31:27.486]                   name <- removed[[kk]]
[10:31:27.486]                   NAME <- NAMES[[kk]]
[10:31:27.486]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.486]                     next
[10:31:27.486]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:27.486]                 }
[10:31:27.486]                 if (length(args) > 0) 
[10:31:27.486]                   base::do.call(base::Sys.setenv, args = args)
[10:31:27.486]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:27.486]             }
[10:31:27.486]             else {
[10:31:27.486]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:27.486]             }
[10:31:27.486]             {
[10:31:27.486]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:27.486]                   0L) {
[10:31:27.486]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:27.486]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:27.486]                   base::options(opts)
[10:31:27.486]                 }
[10:31:27.486]                 {
[10:31:27.486]                   {
[10:31:27.486]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:27.486]                     NULL
[10:31:27.486]                   }
[10:31:27.486]                   options(future.plan = NULL)
[10:31:27.486]                   if (is.na(NA_character_)) 
[10:31:27.486]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:27.486]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:27.486]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:27.486]                     .init = FALSE)
[10:31:27.486]                 }
[10:31:27.486]             }
[10:31:27.486]         }
[10:31:27.486]     })
[10:31:27.486]     if (TRUE) {
[10:31:27.486]         base::sink(type = "output", split = FALSE)
[10:31:27.486]         if (TRUE) {
[10:31:27.486]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:27.486]         }
[10:31:27.486]         else {
[10:31:27.486]             ...future.result["stdout"] <- base::list(NULL)
[10:31:27.486]         }
[10:31:27.486]         base::close(...future.stdout)
[10:31:27.486]         ...future.stdout <- NULL
[10:31:27.486]     }
[10:31:27.486]     ...future.result$conditions <- ...future.conditions
[10:31:27.486]     ...future.result$finished <- base::Sys.time()
[10:31:27.486]     ...future.result
[10:31:27.486] }
[10:31:27.488] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[10:31:27.489] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:27.533] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:27.533] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[10:31:27.534] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[10:31:27.534] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:27.534] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:27.534] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:27.577] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:27.577] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:27.621] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:27.621] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[10:31:27.622] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[10:31:27.622] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[10:31:27.622] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[10:31:27.622] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:27.623] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.623] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:31:27.623] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:31:27.624] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:27.624] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.624] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:27.624] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.624] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[10:31:27.625] MultisessionFuture started
[10:31:27.625] - Launch lazy future ... done
[10:31:27.625] run() for ‘MultisessionFuture’ ... done
[10:31:27.625] Created future:
[10:31:27.627] receiveMessageFromWorker() for ClusterFuture ...
[10:31:27.627] - Validating connection of MultisessionFuture
[10:31:27.627] - received message: FutureResult
[10:31:27.627] - Received FutureResult
[10:31:27.627] - Erased future from FutureRegistry
[10:31:27.628] result() for ClusterFuture ...
[10:31:27.628] - result already collected: FutureResult
[10:31:27.628] result() for ClusterFuture ... done
[10:31:27.628] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:27.625] MultisessionFuture:
[10:31:27.625] Label: ‘future_vapply-1’
[10:31:27.625] Expression:
[10:31:27.625] {
[10:31:27.625]     do.call(function(...) {
[10:31:27.625]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.625]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:27.625]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.625]             on.exit(options(oopts), add = TRUE)
[10:31:27.625]         }
[10:31:27.625]         {
[10:31:27.625]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:27.625]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.625]                 ...future.FUN(...future.X_jj, ...)
[10:31:27.625]             })
[10:31:27.625]         }
[10:31:27.625]     }, args = future.call.arguments)
[10:31:27.625] }
[10:31:27.625] Lazy evaluation: FALSE
[10:31:27.625] Asynchronous evaluation: TRUE
[10:31:27.625] Local evaluation: TRUE
[10:31:27.625] Environment: R_GlobalEnv
[10:31:27.625] Capture standard output: TRUE
[10:31:27.625] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:27.625] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:27.625] Packages: 1 packages (‘future.apply’)
[10:31:27.625] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:27.625] Resolved: TRUE
[10:31:27.625] Value: <not collected>
[10:31:27.625] Conditions captured: <none>
[10:31:27.625] Early signaling: FALSE
[10:31:27.625] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:27.625] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:27.628] Chunk #1 of 2 ... DONE
[10:31:27.628] Chunk #2 of 2 ...
[10:31:27.628]  - Finding globals in 'X' for chunk #2 ...
[10:31:27.628] getGlobalsAndPackages() ...
[10:31:27.628] Searching for globals...
[10:31:27.629] 
[10:31:27.629] Searching for globals ... DONE
[10:31:27.629] - globals: [0] <none>
[10:31:27.629] getGlobalsAndPackages() ... DONE
[10:31:27.629]    + additional globals found: [n=0] 
[10:31:27.629]    + additional namespaces needed: [n=0] 
[10:31:27.629]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:27.629]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:27.630]  - seeds: <none>
[10:31:27.630]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.630] getGlobalsAndPackages() ...
[10:31:27.630] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.630] Resolving globals: FALSE
[10:31:27.630] Tweak future expression to call with '...' arguments ...
[10:31:27.630] {
[10:31:27.630]     do.call(function(...) {
[10:31:27.630]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.630]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:27.630]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.630]             on.exit(options(oopts), add = TRUE)
[10:31:27.630]         }
[10:31:27.630]         {
[10:31:27.630]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:27.630]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.630]                 ...future.FUN(...future.X_jj, ...)
[10:31:27.630]             })
[10:31:27.630]         }
[10:31:27.630]     }, args = future.call.arguments)
[10:31:27.630] }
[10:31:27.630] Tweak future expression to call with '...' arguments ... DONE
[10:31:27.631] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.631] - packages: [1] ‘future.apply’
[10:31:27.631] getGlobalsAndPackages() ... DONE
[10:31:27.631] run() for ‘Future’ ...
[10:31:27.632] - state: ‘created’
[10:31:27.632] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:27.646] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:27.646] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:27.646]   - Field: ‘node’
[10:31:27.646]   - Field: ‘label’
[10:31:27.646]   - Field: ‘local’
[10:31:27.646]   - Field: ‘owner’
[10:31:27.646]   - Field: ‘envir’
[10:31:27.646]   - Field: ‘workers’
[10:31:27.646]   - Field: ‘packages’
[10:31:27.647]   - Field: ‘gc’
[10:31:27.647]   - Field: ‘conditions’
[10:31:27.647]   - Field: ‘persistent’
[10:31:27.647]   - Field: ‘expr’
[10:31:27.647]   - Field: ‘uuid’
[10:31:27.647]   - Field: ‘seed’
[10:31:27.647]   - Field: ‘version’
[10:31:27.647]   - Field: ‘result’
[10:31:27.647]   - Field: ‘asynchronous’
[10:31:27.647]   - Field: ‘calls’
[10:31:27.647]   - Field: ‘globals’
[10:31:27.648]   - Field: ‘stdout’
[10:31:27.648]   - Field: ‘earlySignal’
[10:31:27.648]   - Field: ‘lazy’
[10:31:27.648]   - Field: ‘state’
[10:31:27.648] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:27.648] - Launch lazy future ...
[10:31:27.648] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:27.648] Packages needed by future strategies (n = 0): <none>
[10:31:27.649] {
[10:31:27.649]     {
[10:31:27.649]         {
[10:31:27.649]             ...future.startTime <- base::Sys.time()
[10:31:27.649]             {
[10:31:27.649]                 {
[10:31:27.649]                   {
[10:31:27.649]                     {
[10:31:27.649]                       {
[10:31:27.649]                         base::local({
[10:31:27.649]                           has_future <- base::requireNamespace("future", 
[10:31:27.649]                             quietly = TRUE)
[10:31:27.649]                           if (has_future) {
[10:31:27.649]                             ns <- base::getNamespace("future")
[10:31:27.649]                             version <- ns[[".package"]][["version"]]
[10:31:27.649]                             if (is.null(version)) 
[10:31:27.649]                               version <- utils::packageVersion("future")
[10:31:27.649]                           }
[10:31:27.649]                           else {
[10:31:27.649]                             version <- NULL
[10:31:27.649]                           }
[10:31:27.649]                           if (!has_future || version < "1.8.0") {
[10:31:27.649]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:27.649]                               "", base::R.version$version.string), 
[10:31:27.649]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:27.649]                                 base::R.version$platform, 8 * 
[10:31:27.649]                                   base::.Machine$sizeof.pointer), 
[10:31:27.649]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:27.649]                                 "release", "version")], collapse = " "), 
[10:31:27.649]                               hostname = base::Sys.info()[["nodename"]])
[10:31:27.649]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:27.649]                               info)
[10:31:27.649]                             info <- base::paste(info, collapse = "; ")
[10:31:27.649]                             if (!has_future) {
[10:31:27.649]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:27.649]                                 info)
[10:31:27.649]                             }
[10:31:27.649]                             else {
[10:31:27.649]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:27.649]                                 info, version)
[10:31:27.649]                             }
[10:31:27.649]                             base::stop(msg)
[10:31:27.649]                           }
[10:31:27.649]                         })
[10:31:27.649]                       }
[10:31:27.649]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:27.649]                       base::options(mc.cores = 1L)
[10:31:27.649]                     }
[10:31:27.649]                     base::local({
[10:31:27.649]                       for (pkg in "future.apply") {
[10:31:27.649]                         base::loadNamespace(pkg)
[10:31:27.649]                         base::library(pkg, character.only = TRUE)
[10:31:27.649]                       }
[10:31:27.649]                     })
[10:31:27.649]                   }
[10:31:27.649]                   ...future.strategy.old <- future::plan("list")
[10:31:27.649]                   options(future.plan = NULL)
[10:31:27.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:27.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:27.649]                 }
[10:31:27.649]                 ...future.workdir <- getwd()
[10:31:27.649]             }
[10:31:27.649]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:27.649]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:27.649]         }
[10:31:27.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:27.649]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:27.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:27.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:27.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:27.649]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:27.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:27.649]             base::names(...future.oldOptions))
[10:31:27.649]     }
[10:31:27.649]     if (FALSE) {
[10:31:27.649]     }
[10:31:27.649]     else {
[10:31:27.649]         if (TRUE) {
[10:31:27.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:27.649]                 open = "w")
[10:31:27.649]         }
[10:31:27.649]         else {
[10:31:27.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:27.649]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:27.649]         }
[10:31:27.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:27.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:27.649]             base::sink(type = "output", split = FALSE)
[10:31:27.649]             base::close(...future.stdout)
[10:31:27.649]         }, add = TRUE)
[10:31:27.649]     }
[10:31:27.649]     ...future.frame <- base::sys.nframe()
[10:31:27.649]     ...future.conditions <- base::list()
[10:31:27.649]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:27.649]     if (FALSE) {
[10:31:27.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:27.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:27.649]     }
[10:31:27.649]     ...future.result <- base::tryCatch({
[10:31:27.649]         base::withCallingHandlers({
[10:31:27.649]             ...future.value <- base::withVisible(base::local({
[10:31:27.649]                 ...future.makeSendCondition <- base::local({
[10:31:27.649]                   sendCondition <- NULL
[10:31:27.649]                   function(frame = 1L) {
[10:31:27.649]                     if (is.function(sendCondition)) 
[10:31:27.649]                       return(sendCondition)
[10:31:27.649]                     ns <- getNamespace("parallel")
[10:31:27.649]                     if (exists("sendData", mode = "function", 
[10:31:27.649]                       envir = ns)) {
[10:31:27.649]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:27.649]                         envir = ns)
[10:31:27.649]                       envir <- sys.frame(frame)
[10:31:27.649]                       master <- NULL
[10:31:27.649]                       while (!identical(envir, .GlobalEnv) && 
[10:31:27.649]                         !identical(envir, emptyenv())) {
[10:31:27.649]                         if (exists("master", mode = "list", envir = envir, 
[10:31:27.649]                           inherits = FALSE)) {
[10:31:27.649]                           master <- get("master", mode = "list", 
[10:31:27.649]                             envir = envir, inherits = FALSE)
[10:31:27.649]                           if (inherits(master, c("SOCKnode", 
[10:31:27.649]                             "SOCK0node"))) {
[10:31:27.649]                             sendCondition <<- function(cond) {
[10:31:27.649]                               data <- list(type = "VALUE", value = cond, 
[10:31:27.649]                                 success = TRUE)
[10:31:27.649]                               parallel_sendData(master, data)
[10:31:27.649]                             }
[10:31:27.649]                             return(sendCondition)
[10:31:27.649]                           }
[10:31:27.649]                         }
[10:31:27.649]                         frame <- frame + 1L
[10:31:27.649]                         envir <- sys.frame(frame)
[10:31:27.649]                       }
[10:31:27.649]                     }
[10:31:27.649]                     sendCondition <<- function(cond) NULL
[10:31:27.649]                   }
[10:31:27.649]                 })
[10:31:27.649]                 withCallingHandlers({
[10:31:27.649]                   {
[10:31:27.649]                     do.call(function(...) {
[10:31:27.649]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.649]                       if (!identical(...future.globals.maxSize.org, 
[10:31:27.649]                         ...future.globals.maxSize)) {
[10:31:27.649]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.649]                         on.exit(options(oopts), add = TRUE)
[10:31:27.649]                       }
[10:31:27.649]                       {
[10:31:27.649]                         lapply(seq_along(...future.elements_ii), 
[10:31:27.649]                           FUN = function(jj) {
[10:31:27.649]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.649]                             ...future.FUN(...future.X_jj, ...)
[10:31:27.649]                           })
[10:31:27.649]                       }
[10:31:27.649]                     }, args = future.call.arguments)
[10:31:27.649]                   }
[10:31:27.649]                 }, immediateCondition = function(cond) {
[10:31:27.649]                   sendCondition <- ...future.makeSendCondition()
[10:31:27.649]                   sendCondition(cond)
[10:31:27.649]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.649]                   {
[10:31:27.649]                     inherits <- base::inherits
[10:31:27.649]                     invokeRestart <- base::invokeRestart
[10:31:27.649]                     is.null <- base::is.null
[10:31:27.649]                     muffled <- FALSE
[10:31:27.649]                     if (inherits(cond, "message")) {
[10:31:27.649]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:27.649]                       if (muffled) 
[10:31:27.649]                         invokeRestart("muffleMessage")
[10:31:27.649]                     }
[10:31:27.649]                     else if (inherits(cond, "warning")) {
[10:31:27.649]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:27.649]                       if (muffled) 
[10:31:27.649]                         invokeRestart("muffleWarning")
[10:31:27.649]                     }
[10:31:27.649]                     else if (inherits(cond, "condition")) {
[10:31:27.649]                       if (!is.null(pattern)) {
[10:31:27.649]                         computeRestarts <- base::computeRestarts
[10:31:27.649]                         grepl <- base::grepl
[10:31:27.649]                         restarts <- computeRestarts(cond)
[10:31:27.649]                         for (restart in restarts) {
[10:31:27.649]                           name <- restart$name
[10:31:27.649]                           if (is.null(name)) 
[10:31:27.649]                             next
[10:31:27.649]                           if (!grepl(pattern, name)) 
[10:31:27.649]                             next
[10:31:27.649]                           invokeRestart(restart)
[10:31:27.649]                           muffled <- TRUE
[10:31:27.649]                           break
[10:31:27.649]                         }
[10:31:27.649]                       }
[10:31:27.649]                     }
[10:31:27.649]                     invisible(muffled)
[10:31:27.649]                   }
[10:31:27.649]                   muffleCondition(cond)
[10:31:27.649]                 })
[10:31:27.649]             }))
[10:31:27.649]             future::FutureResult(value = ...future.value$value, 
[10:31:27.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:27.649]                   ...future.rng), globalenv = if (FALSE) 
[10:31:27.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:27.649]                     ...future.globalenv.names))
[10:31:27.649]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:27.649]         }, condition = base::local({
[10:31:27.649]             c <- base::c
[10:31:27.649]             inherits <- base::inherits
[10:31:27.649]             invokeRestart <- base::invokeRestart
[10:31:27.649]             length <- base::length
[10:31:27.649]             list <- base::list
[10:31:27.649]             seq.int <- base::seq.int
[10:31:27.649]             signalCondition <- base::signalCondition
[10:31:27.649]             sys.calls <- base::sys.calls
[10:31:27.649]             `[[` <- base::`[[`
[10:31:27.649]             `+` <- base::`+`
[10:31:27.649]             `<<-` <- base::`<<-`
[10:31:27.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:27.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:27.649]                   3L)]
[10:31:27.649]             }
[10:31:27.649]             function(cond) {
[10:31:27.649]                 is_error <- inherits(cond, "error")
[10:31:27.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:27.649]                   NULL)
[10:31:27.649]                 if (is_error) {
[10:31:27.649]                   sessionInformation <- function() {
[10:31:27.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:27.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:27.649]                       search = base::search(), system = base::Sys.info())
[10:31:27.649]                   }
[10:31:27.649]                   ...future.conditions[[length(...future.conditions) + 
[10:31:27.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:27.649]                     cond$call), session = sessionInformation(), 
[10:31:27.649]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:27.649]                   signalCondition(cond)
[10:31:27.649]                 }
[10:31:27.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:27.649]                 "immediateCondition"))) {
[10:31:27.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:27.649]                   ...future.conditions[[length(...future.conditions) + 
[10:31:27.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:27.649]                   if (TRUE && !signal) {
[10:31:27.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.649]                     {
[10:31:27.649]                       inherits <- base::inherits
[10:31:27.649]                       invokeRestart <- base::invokeRestart
[10:31:27.649]                       is.null <- base::is.null
[10:31:27.649]                       muffled <- FALSE
[10:31:27.649]                       if (inherits(cond, "message")) {
[10:31:27.649]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:27.649]                         if (muffled) 
[10:31:27.649]                           invokeRestart("muffleMessage")
[10:31:27.649]                       }
[10:31:27.649]                       else if (inherits(cond, "warning")) {
[10:31:27.649]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:27.649]                         if (muffled) 
[10:31:27.649]                           invokeRestart("muffleWarning")
[10:31:27.649]                       }
[10:31:27.649]                       else if (inherits(cond, "condition")) {
[10:31:27.649]                         if (!is.null(pattern)) {
[10:31:27.649]                           computeRestarts <- base::computeRestarts
[10:31:27.649]                           grepl <- base::grepl
[10:31:27.649]                           restarts <- computeRestarts(cond)
[10:31:27.649]                           for (restart in restarts) {
[10:31:27.649]                             name <- restart$name
[10:31:27.649]                             if (is.null(name)) 
[10:31:27.649]                               next
[10:31:27.649]                             if (!grepl(pattern, name)) 
[10:31:27.649]                               next
[10:31:27.649]                             invokeRestart(restart)
[10:31:27.649]                             muffled <- TRUE
[10:31:27.649]                             break
[10:31:27.649]                           }
[10:31:27.649]                         }
[10:31:27.649]                       }
[10:31:27.649]                       invisible(muffled)
[10:31:27.649]                     }
[10:31:27.649]                     muffleCondition(cond, pattern = "^muffle")
[10:31:27.649]                   }
[10:31:27.649]                 }
[10:31:27.649]                 else {
[10:31:27.649]                   if (TRUE) {
[10:31:27.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.649]                     {
[10:31:27.649]                       inherits <- base::inherits
[10:31:27.649]                       invokeRestart <- base::invokeRestart
[10:31:27.649]                       is.null <- base::is.null
[10:31:27.649]                       muffled <- FALSE
[10:31:27.649]                       if (inherits(cond, "message")) {
[10:31:27.649]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:27.649]                         if (muffled) 
[10:31:27.649]                           invokeRestart("muffleMessage")
[10:31:27.649]                       }
[10:31:27.649]                       else if (inherits(cond, "warning")) {
[10:31:27.649]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:27.649]                         if (muffled) 
[10:31:27.649]                           invokeRestart("muffleWarning")
[10:31:27.649]                       }
[10:31:27.649]                       else if (inherits(cond, "condition")) {
[10:31:27.649]                         if (!is.null(pattern)) {
[10:31:27.649]                           computeRestarts <- base::computeRestarts
[10:31:27.649]                           grepl <- base::grepl
[10:31:27.649]                           restarts <- computeRestarts(cond)
[10:31:27.649]                           for (restart in restarts) {
[10:31:27.649]                             name <- restart$name
[10:31:27.649]                             if (is.null(name)) 
[10:31:27.649]                               next
[10:31:27.649]                             if (!grepl(pattern, name)) 
[10:31:27.649]                               next
[10:31:27.649]                             invokeRestart(restart)
[10:31:27.649]                             muffled <- TRUE
[10:31:27.649]                             break
[10:31:27.649]                           }
[10:31:27.649]                         }
[10:31:27.649]                       }
[10:31:27.649]                       invisible(muffled)
[10:31:27.649]                     }
[10:31:27.649]                     muffleCondition(cond, pattern = "^muffle")
[10:31:27.649]                   }
[10:31:27.649]                 }
[10:31:27.649]             }
[10:31:27.649]         }))
[10:31:27.649]     }, error = function(ex) {
[10:31:27.649]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:27.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:27.649]                 ...future.rng), started = ...future.startTime, 
[10:31:27.649]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:27.649]             version = "1.8"), class = "FutureResult")
[10:31:27.649]     }, finally = {
[10:31:27.649]         if (!identical(...future.workdir, getwd())) 
[10:31:27.649]             setwd(...future.workdir)
[10:31:27.649]         {
[10:31:27.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:27.649]                 ...future.oldOptions$nwarnings <- NULL
[10:31:27.649]             }
[10:31:27.649]             base::options(...future.oldOptions)
[10:31:27.649]             if (.Platform$OS.type == "windows") {
[10:31:27.649]                 old_names <- names(...future.oldEnvVars)
[10:31:27.649]                 envs <- base::Sys.getenv()
[10:31:27.649]                 names <- names(envs)
[10:31:27.649]                 common <- intersect(names, old_names)
[10:31:27.649]                 added <- setdiff(names, old_names)
[10:31:27.649]                 removed <- setdiff(old_names, names)
[10:31:27.649]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:27.649]                   envs[common]]
[10:31:27.649]                 NAMES <- toupper(changed)
[10:31:27.649]                 args <- list()
[10:31:27.649]                 for (kk in seq_along(NAMES)) {
[10:31:27.649]                   name <- changed[[kk]]
[10:31:27.649]                   NAME <- NAMES[[kk]]
[10:31:27.649]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.649]                     next
[10:31:27.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:27.649]                 }
[10:31:27.649]                 NAMES <- toupper(added)
[10:31:27.649]                 for (kk in seq_along(NAMES)) {
[10:31:27.649]                   name <- added[[kk]]
[10:31:27.649]                   NAME <- NAMES[[kk]]
[10:31:27.649]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.649]                     next
[10:31:27.649]                   args[[name]] <- ""
[10:31:27.649]                 }
[10:31:27.649]                 NAMES <- toupper(removed)
[10:31:27.649]                 for (kk in seq_along(NAMES)) {
[10:31:27.649]                   name <- removed[[kk]]
[10:31:27.649]                   NAME <- NAMES[[kk]]
[10:31:27.649]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.649]                     next
[10:31:27.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:27.649]                 }
[10:31:27.649]                 if (length(args) > 0) 
[10:31:27.649]                   base::do.call(base::Sys.setenv, args = args)
[10:31:27.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:27.649]             }
[10:31:27.649]             else {
[10:31:27.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:27.649]             }
[10:31:27.649]             {
[10:31:27.649]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:27.649]                   0L) {
[10:31:27.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:27.649]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:27.649]                   base::options(opts)
[10:31:27.649]                 }
[10:31:27.649]                 {
[10:31:27.649]                   {
[10:31:27.649]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:27.649]                     NULL
[10:31:27.649]                   }
[10:31:27.649]                   options(future.plan = NULL)
[10:31:27.649]                   if (is.na(NA_character_)) 
[10:31:27.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:27.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:27.649]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:27.649]                     .init = FALSE)
[10:31:27.649]                 }
[10:31:27.649]             }
[10:31:27.649]         }
[10:31:27.649]     })
[10:31:27.649]     if (TRUE) {
[10:31:27.649]         base::sink(type = "output", split = FALSE)
[10:31:27.649]         if (TRUE) {
[10:31:27.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:27.649]         }
[10:31:27.649]         else {
[10:31:27.649]             ...future.result["stdout"] <- base::list(NULL)
[10:31:27.649]         }
[10:31:27.649]         base::close(...future.stdout)
[10:31:27.649]         ...future.stdout <- NULL
[10:31:27.649]     }
[10:31:27.649]     ...future.result$conditions <- ...future.conditions
[10:31:27.649]     ...future.result$finished <- base::Sys.time()
[10:31:27.649]     ...future.result
[10:31:27.649] }
[10:31:27.652] Exporting 11 global objects (94.95 KiB) to cluster node #1 ...
[10:31:27.652] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:27.693] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:27.693] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[10:31:27.694] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[10:31:27.694] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:27.694] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:27.694] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:27.737] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:27.737] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:27.781] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:27.781] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[10:31:27.782] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[10:31:27.782] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[10:31:27.782] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[10:31:27.782] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:27.783] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.783] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:31:27.783] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:31:27.783] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:27.784] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.784] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:27.784] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.784] Exporting 11 global objects (94.95 KiB) to cluster node #1 ... DONE
[10:31:27.785] MultisessionFuture started
[10:31:27.785] - Launch lazy future ... done
[10:31:27.785] run() for ‘MultisessionFuture’ ... done
[10:31:27.785] Created future:
[10:31:27.787] receiveMessageFromWorker() for ClusterFuture ...
[10:31:27.787] - Validating connection of MultisessionFuture
[10:31:27.787] - received message: FutureResult
[10:31:27.787] - Received FutureResult
[10:31:27.787] - Erased future from FutureRegistry
[10:31:27.787] result() for ClusterFuture ...
[10:31:27.788] - result already collected: FutureResult
[10:31:27.788] result() for ClusterFuture ... done
[10:31:27.788] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:27.785] MultisessionFuture:
[10:31:27.785] Label: ‘future_vapply-2’
[10:31:27.785] Expression:
[10:31:27.785] {
[10:31:27.785]     do.call(function(...) {
[10:31:27.785]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.785]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:27.785]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.785]             on.exit(options(oopts), add = TRUE)
[10:31:27.785]         }
[10:31:27.785]         {
[10:31:27.785]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:27.785]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.785]                 ...future.FUN(...future.X_jj, ...)
[10:31:27.785]             })
[10:31:27.785]         }
[10:31:27.785]     }, args = future.call.arguments)
[10:31:27.785] }
[10:31:27.785] Lazy evaluation: FALSE
[10:31:27.785] Asynchronous evaluation: TRUE
[10:31:27.785] Local evaluation: TRUE
[10:31:27.785] Environment: R_GlobalEnv
[10:31:27.785] Capture standard output: TRUE
[10:31:27.785] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:27.785] Globals: 11 objects totaling 95.23 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:27.785] Packages: 1 packages (‘future.apply’)
[10:31:27.785] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:27.785] Resolved: TRUE
[10:31:27.785] Value: <not collected>
[10:31:27.785] Conditions captured: <none>
[10:31:27.785] Early signaling: FALSE
[10:31:27.785] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:27.785] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:27.788] Chunk #2 of 2 ... DONE
[10:31:27.788] Launching 2 futures (chunks) ... DONE
[10:31:27.788] Resolving 2 futures (chunks) ...
[10:31:27.788] resolve() on list ...
[10:31:27.788]  recursive: 0
[10:31:27.789]  length: 2
[10:31:27.789] 
[10:31:27.789] Future #1
[10:31:27.789] result() for ClusterFuture ...
[10:31:27.789] - result already collected: FutureResult
[10:31:27.789] result() for ClusterFuture ... done
[10:31:27.789] result() for ClusterFuture ...
[10:31:27.789] - result already collected: FutureResult
[10:31:27.789] result() for ClusterFuture ... done
[10:31:27.789] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:27.790] - nx: 2
[10:31:27.790] - relay: TRUE
[10:31:27.790] - stdout: TRUE
[10:31:27.790] - signal: TRUE
[10:31:27.790] - resignal: FALSE
[10:31:27.792] - force: TRUE
[10:31:27.792] - relayed: [n=2] FALSE, FALSE
[10:31:27.792] - queued futures: [n=2] FALSE, FALSE
[10:31:27.792]  - until=1
[10:31:27.792]  - relaying element #1
[10:31:27.792] result() for ClusterFuture ...
[10:31:27.793] - result already collected: FutureResult
[10:31:27.793] result() for ClusterFuture ... done
[10:31:27.793] result() for ClusterFuture ...
[10:31:27.793] - result already collected: FutureResult
[10:31:27.793] result() for ClusterFuture ... done
[10:31:27.793] result() for ClusterFuture ...
[10:31:27.793] - result already collected: FutureResult
[10:31:27.793] result() for ClusterFuture ... done
[10:31:27.793] result() for ClusterFuture ...
[10:31:27.793] - result already collected: FutureResult
[10:31:27.793] result() for ClusterFuture ... done
[10:31:27.794] - relayed: [n=2] TRUE, FALSE
[10:31:27.794] - queued futures: [n=2] TRUE, FALSE
[10:31:27.794] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:27.794]  length: 1 (resolved future 1)
[10:31:27.794] Future #2
[10:31:27.794] result() for ClusterFuture ...
[10:31:27.794] - result already collected: FutureResult
[10:31:27.794] result() for ClusterFuture ... done
[10:31:27.794] result() for ClusterFuture ...
[10:31:27.794] - result already collected: FutureResult
[10:31:27.794] result() for ClusterFuture ... done
[10:31:27.795] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:27.795] - nx: 2
[10:31:27.795] - relay: TRUE
[10:31:27.795] - stdout: TRUE
[10:31:27.795] - signal: TRUE
[10:31:27.795] - resignal: FALSE
[10:31:27.795] - force: TRUE
[10:31:27.795] - relayed: [n=2] TRUE, FALSE
[10:31:27.795] - queued futures: [n=2] TRUE, FALSE
[10:31:27.795]  - until=2
[10:31:27.795]  - relaying element #2
[10:31:27.795] result() for ClusterFuture ...
[10:31:27.796] - result already collected: FutureResult
[10:31:27.796] result() for ClusterFuture ... done
[10:31:27.796] result() for ClusterFuture ...
[10:31:27.796] - result already collected: FutureResult
[10:31:27.796] result() for ClusterFuture ... done
[10:31:27.796] result() for ClusterFuture ...
[10:31:27.796] - result already collected: FutureResult
[10:31:27.796] result() for ClusterFuture ... done
[10:31:27.796] result() for ClusterFuture ...
[10:31:27.796] - result already collected: FutureResult
[10:31:27.796] result() for ClusterFuture ... done
[10:31:27.797] - relayed: [n=2] TRUE, TRUE
[10:31:27.797] - queued futures: [n=2] TRUE, TRUE
[10:31:27.797] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:27.797]  length: 0 (resolved future 2)
[10:31:27.797] Relaying remaining futures
[10:31:27.797] signalConditionsASAP(NULL, pos=0) ...
[10:31:27.797] - nx: 2
[10:31:27.797] - relay: TRUE
[10:31:27.797] - stdout: TRUE
[10:31:27.797] - signal: TRUE
[10:31:27.797] - resignal: FALSE
[10:31:27.797] - force: TRUE
[10:31:27.798] - relayed: [n=2] TRUE, TRUE
[10:31:27.798] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:27.798] - relayed: [n=2] TRUE, TRUE
[10:31:27.798] - queued futures: [n=2] TRUE, TRUE
[10:31:27.798] signalConditionsASAP(NULL, pos=0) ... done
[10:31:27.798] resolve() on list ... DONE
[10:31:27.798] result() for ClusterFuture ...
[10:31:27.798] - result already collected: FutureResult
[10:31:27.798] result() for ClusterFuture ... done
[10:31:27.798] result() for ClusterFuture ...
[10:31:27.798] - result already collected: FutureResult
[10:31:27.799] result() for ClusterFuture ... done
[10:31:27.799] result() for ClusterFuture ...
[10:31:27.799] - result already collected: FutureResult
[10:31:27.799] result() for ClusterFuture ... done
[10:31:27.799] result() for ClusterFuture ...
[10:31:27.799] - result already collected: FutureResult
[10:31:27.799] result() for ClusterFuture ... done
[10:31:27.799]  - Number of value chunks collected: 2
[10:31:27.799] Resolving 2 futures (chunks) ... DONE
[10:31:27.799] Reducing values from 2 chunks ...
[10:31:27.799]  - Number of values collected after concatenation: 10
[10:31:27.799]  - Number of values expected: 10
[10:31:27.800] Reducing values from 2 chunks ... DONE
[10:31:27.800] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
[10:31:27.801] future_lapply() ...
[10:31:27.806] Number of chunks: 2
[10:31:27.806] getGlobalsAndPackagesXApply() ...
[10:31:27.806]  - future.globals: TRUE
[10:31:27.806] getGlobalsAndPackages() ...
[10:31:27.806] Searching for globals...
[10:31:27.810] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’
[10:31:27.810] Searching for globals ... DONE
[10:31:27.810] Resolving globals: FALSE
[10:31:27.811] The total size of the 7 globals is 95.02 KiB (97304 bytes)
[10:31:27.812] The total size of the 7 globals exported for future expression (‘FUN()’) is 95.02 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:27.812] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:27.812] - packages: [1] ‘future.apply’
[10:31:27.812] getGlobalsAndPackages() ... DONE
[10:31:27.812]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:27.812]  - needed namespaces: [n=1] ‘future.apply’
[10:31:27.812] Finding globals ... DONE
[10:31:27.812]  - use_args: TRUE
[10:31:27.812]  - Getting '...' globals ...
[10:31:27.813] resolve() on list ...
[10:31:27.813]  recursive: 0
[10:31:27.813]  length: 1
[10:31:27.813]  elements: ‘...’
[10:31:27.813]  length: 0 (resolved future 1)
[10:31:27.813] resolve() on list ... DONE
[10:31:27.813]    - '...' content: [n=0] 
[10:31:27.813] List of 1
[10:31:27.813]  $ ...: list()
[10:31:27.813]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:27.813]  - attr(*, "where")=List of 1
[10:31:27.813]   ..$ ...:<environment: 0x55de85abf350> 
[10:31:27.813]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:27.813]  - attr(*, "resolved")= logi TRUE
[10:31:27.813]  - attr(*, "total_size")= num NA
[10:31:27.816]  - Getting '...' globals ... DONE
[10:31:27.816] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:27.816] List of 8
[10:31:27.816]  $ ...future.FUN:function (x, ...)  
[10:31:27.816]  $ x_FUN        :function (x)  
[10:31:27.816]  $ times        : int 4
[10:31:27.816]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:27.816]  $ stop_if_not  :function (...)  
[10:31:27.816]  $ dim          : int [1:2] 2 2
[10:31:27.816]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:27.816]  $ ...          : list()
[10:31:27.816]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:27.816]  - attr(*, "where")=List of 8
[10:31:27.816]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:27.816]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:27.816]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:27.816]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:27.816]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:27.816]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:27.816]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:27.816]   ..$ ...          :<environment: 0x55de85abf350> 
[10:31:27.816]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:27.816]  - attr(*, "resolved")= logi FALSE
[10:31:27.816]  - attr(*, "total_size")= num 97304
[10:31:27.822] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:27.822] getGlobalsAndPackagesXApply() ... DONE
[10:31:27.822] Number of futures (= number of chunks): 2
[10:31:27.822] Launching 2 futures (chunks) ...
[10:31:27.822] Chunk #1 of 2 ...
[10:31:27.822]  - Finding globals in 'X' for chunk #1 ...
[10:31:27.822] getGlobalsAndPackages() ...
[10:31:27.822] Searching for globals...
[10:31:27.823] 
[10:31:27.823] Searching for globals ... DONE
[10:31:27.823] - globals: [0] <none>
[10:31:27.823] getGlobalsAndPackages() ... DONE
[10:31:27.823]    + additional globals found: [n=0] 
[10:31:27.823]    + additional namespaces needed: [n=0] 
[10:31:27.823]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:27.823]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:27.823]  - seeds: <none>
[10:31:27.823]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.824] getGlobalsAndPackages() ...
[10:31:27.824] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.824] Resolving globals: FALSE
[10:31:27.824] Tweak future expression to call with '...' arguments ...
[10:31:27.824] {
[10:31:27.824]     do.call(function(...) {
[10:31:27.824]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.824]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:27.824]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.824]             on.exit(options(oopts), add = TRUE)
[10:31:27.824]         }
[10:31:27.824]         {
[10:31:27.824]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:27.824]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.824]                 ...future.FUN(...future.X_jj, ...)
[10:31:27.824]             })
[10:31:27.824]         }
[10:31:27.824]     }, args = future.call.arguments)
[10:31:27.824] }
[10:31:27.824] Tweak future expression to call with '...' arguments ... DONE
[10:31:27.825] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.825] - packages: [1] ‘future.apply’
[10:31:27.825] getGlobalsAndPackages() ... DONE
[10:31:27.825] run() for ‘Future’ ...
[10:31:27.825] - state: ‘created’
[10:31:27.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:27.839] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:27.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:27.840]   - Field: ‘node’
[10:31:27.840]   - Field: ‘label’
[10:31:27.840]   - Field: ‘local’
[10:31:27.840]   - Field: ‘owner’
[10:31:27.840]   - Field: ‘envir’
[10:31:27.840]   - Field: ‘workers’
[10:31:27.840]   - Field: ‘packages’
[10:31:27.840]   - Field: ‘gc’
[10:31:27.840]   - Field: ‘conditions’
[10:31:27.841]   - Field: ‘persistent’
[10:31:27.841]   - Field: ‘expr’
[10:31:27.841]   - Field: ‘uuid’
[10:31:27.841]   - Field: ‘seed’
[10:31:27.841]   - Field: ‘version’
[10:31:27.841]   - Field: ‘result’
[10:31:27.841]   - Field: ‘asynchronous’
[10:31:27.841]   - Field: ‘calls’
[10:31:27.841]   - Field: ‘globals’
[10:31:27.841]   - Field: ‘stdout’
[10:31:27.841]   - Field: ‘earlySignal’
[10:31:27.842]   - Field: ‘lazy’
[10:31:27.842]   - Field: ‘state’
[10:31:27.842] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:27.842] - Launch lazy future ...
[10:31:27.842] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:27.842] Packages needed by future strategies (n = 0): <none>
[10:31:27.843] {
[10:31:27.843]     {
[10:31:27.843]         {
[10:31:27.843]             ...future.startTime <- base::Sys.time()
[10:31:27.843]             {
[10:31:27.843]                 {
[10:31:27.843]                   {
[10:31:27.843]                     {
[10:31:27.843]                       {
[10:31:27.843]                         base::local({
[10:31:27.843]                           has_future <- base::requireNamespace("future", 
[10:31:27.843]                             quietly = TRUE)
[10:31:27.843]                           if (has_future) {
[10:31:27.843]                             ns <- base::getNamespace("future")
[10:31:27.843]                             version <- ns[[".package"]][["version"]]
[10:31:27.843]                             if (is.null(version)) 
[10:31:27.843]                               version <- utils::packageVersion("future")
[10:31:27.843]                           }
[10:31:27.843]                           else {
[10:31:27.843]                             version <- NULL
[10:31:27.843]                           }
[10:31:27.843]                           if (!has_future || version < "1.8.0") {
[10:31:27.843]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:27.843]                               "", base::R.version$version.string), 
[10:31:27.843]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:27.843]                                 base::R.version$platform, 8 * 
[10:31:27.843]                                   base::.Machine$sizeof.pointer), 
[10:31:27.843]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:27.843]                                 "release", "version")], collapse = " "), 
[10:31:27.843]                               hostname = base::Sys.info()[["nodename"]])
[10:31:27.843]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:27.843]                               info)
[10:31:27.843]                             info <- base::paste(info, collapse = "; ")
[10:31:27.843]                             if (!has_future) {
[10:31:27.843]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:27.843]                                 info)
[10:31:27.843]                             }
[10:31:27.843]                             else {
[10:31:27.843]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:27.843]                                 info, version)
[10:31:27.843]                             }
[10:31:27.843]                             base::stop(msg)
[10:31:27.843]                           }
[10:31:27.843]                         })
[10:31:27.843]                       }
[10:31:27.843]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:27.843]                       base::options(mc.cores = 1L)
[10:31:27.843]                     }
[10:31:27.843]                     base::local({
[10:31:27.843]                       for (pkg in "future.apply") {
[10:31:27.843]                         base::loadNamespace(pkg)
[10:31:27.843]                         base::library(pkg, character.only = TRUE)
[10:31:27.843]                       }
[10:31:27.843]                     })
[10:31:27.843]                   }
[10:31:27.843]                   ...future.strategy.old <- future::plan("list")
[10:31:27.843]                   options(future.plan = NULL)
[10:31:27.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:27.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:27.843]                 }
[10:31:27.843]                 ...future.workdir <- getwd()
[10:31:27.843]             }
[10:31:27.843]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:27.843]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:27.843]         }
[10:31:27.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:27.843]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:27.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:27.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:27.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:27.843]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:27.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:27.843]             base::names(...future.oldOptions))
[10:31:27.843]     }
[10:31:27.843]     if (FALSE) {
[10:31:27.843]     }
[10:31:27.843]     else {
[10:31:27.843]         if (TRUE) {
[10:31:27.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:27.843]                 open = "w")
[10:31:27.843]         }
[10:31:27.843]         else {
[10:31:27.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:27.843]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:27.843]         }
[10:31:27.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:27.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:27.843]             base::sink(type = "output", split = FALSE)
[10:31:27.843]             base::close(...future.stdout)
[10:31:27.843]         }, add = TRUE)
[10:31:27.843]     }
[10:31:27.843]     ...future.frame <- base::sys.nframe()
[10:31:27.843]     ...future.conditions <- base::list()
[10:31:27.843]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:27.843]     if (FALSE) {
[10:31:27.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:27.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:27.843]     }
[10:31:27.843]     ...future.result <- base::tryCatch({
[10:31:27.843]         base::withCallingHandlers({
[10:31:27.843]             ...future.value <- base::withVisible(base::local({
[10:31:27.843]                 ...future.makeSendCondition <- base::local({
[10:31:27.843]                   sendCondition <- NULL
[10:31:27.843]                   function(frame = 1L) {
[10:31:27.843]                     if (is.function(sendCondition)) 
[10:31:27.843]                       return(sendCondition)
[10:31:27.843]                     ns <- getNamespace("parallel")
[10:31:27.843]                     if (exists("sendData", mode = "function", 
[10:31:27.843]                       envir = ns)) {
[10:31:27.843]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:27.843]                         envir = ns)
[10:31:27.843]                       envir <- sys.frame(frame)
[10:31:27.843]                       master <- NULL
[10:31:27.843]                       while (!identical(envir, .GlobalEnv) && 
[10:31:27.843]                         !identical(envir, emptyenv())) {
[10:31:27.843]                         if (exists("master", mode = "list", envir = envir, 
[10:31:27.843]                           inherits = FALSE)) {
[10:31:27.843]                           master <- get("master", mode = "list", 
[10:31:27.843]                             envir = envir, inherits = FALSE)
[10:31:27.843]                           if (inherits(master, c("SOCKnode", 
[10:31:27.843]                             "SOCK0node"))) {
[10:31:27.843]                             sendCondition <<- function(cond) {
[10:31:27.843]                               data <- list(type = "VALUE", value = cond, 
[10:31:27.843]                                 success = TRUE)
[10:31:27.843]                               parallel_sendData(master, data)
[10:31:27.843]                             }
[10:31:27.843]                             return(sendCondition)
[10:31:27.843]                           }
[10:31:27.843]                         }
[10:31:27.843]                         frame <- frame + 1L
[10:31:27.843]                         envir <- sys.frame(frame)
[10:31:27.843]                       }
[10:31:27.843]                     }
[10:31:27.843]                     sendCondition <<- function(cond) NULL
[10:31:27.843]                   }
[10:31:27.843]                 })
[10:31:27.843]                 withCallingHandlers({
[10:31:27.843]                   {
[10:31:27.843]                     do.call(function(...) {
[10:31:27.843]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.843]                       if (!identical(...future.globals.maxSize.org, 
[10:31:27.843]                         ...future.globals.maxSize)) {
[10:31:27.843]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.843]                         on.exit(options(oopts), add = TRUE)
[10:31:27.843]                       }
[10:31:27.843]                       {
[10:31:27.843]                         lapply(seq_along(...future.elements_ii), 
[10:31:27.843]                           FUN = function(jj) {
[10:31:27.843]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.843]                             ...future.FUN(...future.X_jj, ...)
[10:31:27.843]                           })
[10:31:27.843]                       }
[10:31:27.843]                     }, args = future.call.arguments)
[10:31:27.843]                   }
[10:31:27.843]                 }, immediateCondition = function(cond) {
[10:31:27.843]                   sendCondition <- ...future.makeSendCondition()
[10:31:27.843]                   sendCondition(cond)
[10:31:27.843]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.843]                   {
[10:31:27.843]                     inherits <- base::inherits
[10:31:27.843]                     invokeRestart <- base::invokeRestart
[10:31:27.843]                     is.null <- base::is.null
[10:31:27.843]                     muffled <- FALSE
[10:31:27.843]                     if (inherits(cond, "message")) {
[10:31:27.843]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:27.843]                       if (muffled) 
[10:31:27.843]                         invokeRestart("muffleMessage")
[10:31:27.843]                     }
[10:31:27.843]                     else if (inherits(cond, "warning")) {
[10:31:27.843]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:27.843]                       if (muffled) 
[10:31:27.843]                         invokeRestart("muffleWarning")
[10:31:27.843]                     }
[10:31:27.843]                     else if (inherits(cond, "condition")) {
[10:31:27.843]                       if (!is.null(pattern)) {
[10:31:27.843]                         computeRestarts <- base::computeRestarts
[10:31:27.843]                         grepl <- base::grepl
[10:31:27.843]                         restarts <- computeRestarts(cond)
[10:31:27.843]                         for (restart in restarts) {
[10:31:27.843]                           name <- restart$name
[10:31:27.843]                           if (is.null(name)) 
[10:31:27.843]                             next
[10:31:27.843]                           if (!grepl(pattern, name)) 
[10:31:27.843]                             next
[10:31:27.843]                           invokeRestart(restart)
[10:31:27.843]                           muffled <- TRUE
[10:31:27.843]                           break
[10:31:27.843]                         }
[10:31:27.843]                       }
[10:31:27.843]                     }
[10:31:27.843]                     invisible(muffled)
[10:31:27.843]                   }
[10:31:27.843]                   muffleCondition(cond)
[10:31:27.843]                 })
[10:31:27.843]             }))
[10:31:27.843]             future::FutureResult(value = ...future.value$value, 
[10:31:27.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:27.843]                   ...future.rng), globalenv = if (FALSE) 
[10:31:27.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:27.843]                     ...future.globalenv.names))
[10:31:27.843]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:27.843]         }, condition = base::local({
[10:31:27.843]             c <- base::c
[10:31:27.843]             inherits <- base::inherits
[10:31:27.843]             invokeRestart <- base::invokeRestart
[10:31:27.843]             length <- base::length
[10:31:27.843]             list <- base::list
[10:31:27.843]             seq.int <- base::seq.int
[10:31:27.843]             signalCondition <- base::signalCondition
[10:31:27.843]             sys.calls <- base::sys.calls
[10:31:27.843]             `[[` <- base::`[[`
[10:31:27.843]             `+` <- base::`+`
[10:31:27.843]             `<<-` <- base::`<<-`
[10:31:27.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:27.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:27.843]                   3L)]
[10:31:27.843]             }
[10:31:27.843]             function(cond) {
[10:31:27.843]                 is_error <- inherits(cond, "error")
[10:31:27.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:27.843]                   NULL)
[10:31:27.843]                 if (is_error) {
[10:31:27.843]                   sessionInformation <- function() {
[10:31:27.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:27.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:27.843]                       search = base::search(), system = base::Sys.info())
[10:31:27.843]                   }
[10:31:27.843]                   ...future.conditions[[length(...future.conditions) + 
[10:31:27.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:27.843]                     cond$call), session = sessionInformation(), 
[10:31:27.843]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:27.843]                   signalCondition(cond)
[10:31:27.843]                 }
[10:31:27.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:27.843]                 "immediateCondition"))) {
[10:31:27.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:27.843]                   ...future.conditions[[length(...future.conditions) + 
[10:31:27.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:27.843]                   if (TRUE && !signal) {
[10:31:27.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.843]                     {
[10:31:27.843]                       inherits <- base::inherits
[10:31:27.843]                       invokeRestart <- base::invokeRestart
[10:31:27.843]                       is.null <- base::is.null
[10:31:27.843]                       muffled <- FALSE
[10:31:27.843]                       if (inherits(cond, "message")) {
[10:31:27.843]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:27.843]                         if (muffled) 
[10:31:27.843]                           invokeRestart("muffleMessage")
[10:31:27.843]                       }
[10:31:27.843]                       else if (inherits(cond, "warning")) {
[10:31:27.843]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:27.843]                         if (muffled) 
[10:31:27.843]                           invokeRestart("muffleWarning")
[10:31:27.843]                       }
[10:31:27.843]                       else if (inherits(cond, "condition")) {
[10:31:27.843]                         if (!is.null(pattern)) {
[10:31:27.843]                           computeRestarts <- base::computeRestarts
[10:31:27.843]                           grepl <- base::grepl
[10:31:27.843]                           restarts <- computeRestarts(cond)
[10:31:27.843]                           for (restart in restarts) {
[10:31:27.843]                             name <- restart$name
[10:31:27.843]                             if (is.null(name)) 
[10:31:27.843]                               next
[10:31:27.843]                             if (!grepl(pattern, name)) 
[10:31:27.843]                               next
[10:31:27.843]                             invokeRestart(restart)
[10:31:27.843]                             muffled <- TRUE
[10:31:27.843]                             break
[10:31:27.843]                           }
[10:31:27.843]                         }
[10:31:27.843]                       }
[10:31:27.843]                       invisible(muffled)
[10:31:27.843]                     }
[10:31:27.843]                     muffleCondition(cond, pattern = "^muffle")
[10:31:27.843]                   }
[10:31:27.843]                 }
[10:31:27.843]                 else {
[10:31:27.843]                   if (TRUE) {
[10:31:27.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:27.843]                     {
[10:31:27.843]                       inherits <- base::inherits
[10:31:27.843]                       invokeRestart <- base::invokeRestart
[10:31:27.843]                       is.null <- base::is.null
[10:31:27.843]                       muffled <- FALSE
[10:31:27.843]                       if (inherits(cond, "message")) {
[10:31:27.843]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:27.843]                         if (muffled) 
[10:31:27.843]                           invokeRestart("muffleMessage")
[10:31:27.843]                       }
[10:31:27.843]                       else if (inherits(cond, "warning")) {
[10:31:27.843]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:27.843]                         if (muffled) 
[10:31:27.843]                           invokeRestart("muffleWarning")
[10:31:27.843]                       }
[10:31:27.843]                       else if (inherits(cond, "condition")) {
[10:31:27.843]                         if (!is.null(pattern)) {
[10:31:27.843]                           computeRestarts <- base::computeRestarts
[10:31:27.843]                           grepl <- base::grepl
[10:31:27.843]                           restarts <- computeRestarts(cond)
[10:31:27.843]                           for (restart in restarts) {
[10:31:27.843]                             name <- restart$name
[10:31:27.843]                             if (is.null(name)) 
[10:31:27.843]                               next
[10:31:27.843]                             if (!grepl(pattern, name)) 
[10:31:27.843]                               next
[10:31:27.843]                             invokeRestart(restart)
[10:31:27.843]                             muffled <- TRUE
[10:31:27.843]                             break
[10:31:27.843]                           }
[10:31:27.843]                         }
[10:31:27.843]                       }
[10:31:27.843]                       invisible(muffled)
[10:31:27.843]                     }
[10:31:27.843]                     muffleCondition(cond, pattern = "^muffle")
[10:31:27.843]                   }
[10:31:27.843]                 }
[10:31:27.843]             }
[10:31:27.843]         }))
[10:31:27.843]     }, error = function(ex) {
[10:31:27.843]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:27.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:27.843]                 ...future.rng), started = ...future.startTime, 
[10:31:27.843]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:27.843]             version = "1.8"), class = "FutureResult")
[10:31:27.843]     }, finally = {
[10:31:27.843]         if (!identical(...future.workdir, getwd())) 
[10:31:27.843]             setwd(...future.workdir)
[10:31:27.843]         {
[10:31:27.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:27.843]                 ...future.oldOptions$nwarnings <- NULL
[10:31:27.843]             }
[10:31:27.843]             base::options(...future.oldOptions)
[10:31:27.843]             if (.Platform$OS.type == "windows") {
[10:31:27.843]                 old_names <- names(...future.oldEnvVars)
[10:31:27.843]                 envs <- base::Sys.getenv()
[10:31:27.843]                 names <- names(envs)
[10:31:27.843]                 common <- intersect(names, old_names)
[10:31:27.843]                 added <- setdiff(names, old_names)
[10:31:27.843]                 removed <- setdiff(old_names, names)
[10:31:27.843]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:27.843]                   envs[common]]
[10:31:27.843]                 NAMES <- toupper(changed)
[10:31:27.843]                 args <- list()
[10:31:27.843]                 for (kk in seq_along(NAMES)) {
[10:31:27.843]                   name <- changed[[kk]]
[10:31:27.843]                   NAME <- NAMES[[kk]]
[10:31:27.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.843]                     next
[10:31:27.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:27.843]                 }
[10:31:27.843]                 NAMES <- toupper(added)
[10:31:27.843]                 for (kk in seq_along(NAMES)) {
[10:31:27.843]                   name <- added[[kk]]
[10:31:27.843]                   NAME <- NAMES[[kk]]
[10:31:27.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.843]                     next
[10:31:27.843]                   args[[name]] <- ""
[10:31:27.843]                 }
[10:31:27.843]                 NAMES <- toupper(removed)
[10:31:27.843]                 for (kk in seq_along(NAMES)) {
[10:31:27.843]                   name <- removed[[kk]]
[10:31:27.843]                   NAME <- NAMES[[kk]]
[10:31:27.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:27.843]                     next
[10:31:27.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:27.843]                 }
[10:31:27.843]                 if (length(args) > 0) 
[10:31:27.843]                   base::do.call(base::Sys.setenv, args = args)
[10:31:27.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:27.843]             }
[10:31:27.843]             else {
[10:31:27.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:27.843]             }
[10:31:27.843]             {
[10:31:27.843]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:27.843]                   0L) {
[10:31:27.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:27.843]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:27.843]                   base::options(opts)
[10:31:27.843]                 }
[10:31:27.843]                 {
[10:31:27.843]                   {
[10:31:27.843]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:27.843]                     NULL
[10:31:27.843]                   }
[10:31:27.843]                   options(future.plan = NULL)
[10:31:27.843]                   if (is.na(NA_character_)) 
[10:31:27.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:27.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:27.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:27.843]                     .init = FALSE)
[10:31:27.843]                 }
[10:31:27.843]             }
[10:31:27.843]         }
[10:31:27.843]     })
[10:31:27.843]     if (TRUE) {
[10:31:27.843]         base::sink(type = "output", split = FALSE)
[10:31:27.843]         if (TRUE) {
[10:31:27.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:27.843]         }
[10:31:27.843]         else {
[10:31:27.843]             ...future.result["stdout"] <- base::list(NULL)
[10:31:27.843]         }
[10:31:27.843]         base::close(...future.stdout)
[10:31:27.843]         ...future.stdout <- NULL
[10:31:27.843]     }
[10:31:27.843]     ...future.result$conditions <- ...future.conditions
[10:31:27.843]     ...future.result$finished <- base::Sys.time()
[10:31:27.843]     ...future.result
[10:31:27.843] }
[10:31:27.846] Exporting 11 global objects (95.02 KiB) to cluster node #1 ...
[10:31:27.846] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:27.889] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:27.889] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ...
[10:31:27.890] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #1 ... DONE
[10:31:27.890] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:27.890] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:27.890] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:27.933] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:27.933] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:27.977] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:27.977] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[10:31:27.978] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[10:31:27.978] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:31:27.978] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:31:27.978] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:27.979] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.979] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:31:27.979] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:31:27.979] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:27.980] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.980] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:27.980] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:27.980] Exporting 11 global objects (95.02 KiB) to cluster node #1 ... DONE
[10:31:27.981] MultisessionFuture started
[10:31:27.981] - Launch lazy future ... done
[10:31:27.981] run() for ‘MultisessionFuture’ ... done
[10:31:27.981] Created future:
[10:31:27.981] MultisessionFuture:
[10:31:27.981] Label: ‘future_vapply-1’
[10:31:27.981] Expression:
[10:31:27.981] {
[10:31:27.981]     do.call(function(...) {
[10:31:27.981]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.981]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:27.981]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.981]             on.exit(options(oopts), add = TRUE)
[10:31:27.981]         }
[10:31:27.981]         {
[10:31:27.981]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:27.981]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.981]                 ...future.FUN(...future.X_jj, ...)
[10:31:27.981]             })
[10:31:27.981]         }
[10:31:27.981]     }, args = future.call.arguments)
[10:31:27.981] }
[10:31:27.981] Lazy evaluation: FALSE
[10:31:27.981] Asynchronous evaluation: TRUE
[10:31:27.981] Local evaluation: TRUE
[10:31:27.981] Environment: R_GlobalEnv
[10:31:27.981] Capture standard output: TRUE
[10:31:27.981] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:27.981] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:27.981] Packages: 1 packages (‘future.apply’)
[10:31:27.981] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:27.981] Resolved: FALSE
[10:31:27.981] Value: <not collected>
[10:31:27.981] Conditions captured: <none>
[10:31:27.981] Early signaling: FALSE
[10:31:27.981] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:27.981] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:27.993] Chunk #1 of 2 ... DONE
[10:31:27.993] Chunk #2 of 2 ...
[10:31:27.993]  - Finding globals in 'X' for chunk #2 ...
[10:31:27.993] getGlobalsAndPackages() ...
[10:31:27.993] Searching for globals...
[10:31:27.994] 
[10:31:27.994] Searching for globals ... DONE
[10:31:27.994] - globals: [0] <none>
[10:31:27.994] getGlobalsAndPackages() ... DONE
[10:31:27.994]    + additional globals found: [n=0] 
[10:31:27.994]    + additional namespaces needed: [n=0] 
[10:31:27.994]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:27.994]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:27.994]  - seeds: <none>
[10:31:27.995]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.995] getGlobalsAndPackages() ...
[10:31:27.995] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.995] Resolving globals: FALSE
[10:31:27.995] Tweak future expression to call with '...' arguments ...
[10:31:27.995] {
[10:31:27.995]     do.call(function(...) {
[10:31:27.995]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:27.995]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:27.995]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:27.995]             on.exit(options(oopts), add = TRUE)
[10:31:27.995]         }
[10:31:27.995]         {
[10:31:27.995]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:27.995]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:27.995]                 ...future.FUN(...future.X_jj, ...)
[10:31:27.995]             })
[10:31:27.995]         }
[10:31:27.995]     }, args = future.call.arguments)
[10:31:27.995] }
[10:31:27.995] Tweak future expression to call with '...' arguments ... DONE
[10:31:27.996] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:27.996] - packages: [1] ‘future.apply’
[10:31:27.996] getGlobalsAndPackages() ... DONE
[10:31:27.996] run() for ‘Future’ ...
[10:31:27.997] - state: ‘created’
[10:31:27.997] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:28.010] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:28.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:28.011]   - Field: ‘node’
[10:31:28.011]   - Field: ‘label’
[10:31:28.011]   - Field: ‘local’
[10:31:28.011]   - Field: ‘owner’
[10:31:28.011]   - Field: ‘envir’
[10:31:28.011]   - Field: ‘workers’
[10:31:28.011]   - Field: ‘packages’
[10:31:28.011]   - Field: ‘gc’
[10:31:28.011]   - Field: ‘conditions’
[10:31:28.012]   - Field: ‘persistent’
[10:31:28.012]   - Field: ‘expr’
[10:31:28.012]   - Field: ‘uuid’
[10:31:28.012]   - Field: ‘seed’
[10:31:28.012]   - Field: ‘version’
[10:31:28.012]   - Field: ‘result’
[10:31:28.012]   - Field: ‘asynchronous’
[10:31:28.012]   - Field: ‘calls’
[10:31:28.012]   - Field: ‘globals’
[10:31:28.012]   - Field: ‘stdout’
[10:31:28.012]   - Field: ‘earlySignal’
[10:31:28.012]   - Field: ‘lazy’
[10:31:28.013]   - Field: ‘state’
[10:31:28.013] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:28.013] - Launch lazy future ...
[10:31:28.013] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:28.013] Packages needed by future strategies (n = 0): <none>
[10:31:28.014] {
[10:31:28.014]     {
[10:31:28.014]         {
[10:31:28.014]             ...future.startTime <- base::Sys.time()
[10:31:28.014]             {
[10:31:28.014]                 {
[10:31:28.014]                   {
[10:31:28.014]                     {
[10:31:28.014]                       {
[10:31:28.014]                         base::local({
[10:31:28.014]                           has_future <- base::requireNamespace("future", 
[10:31:28.014]                             quietly = TRUE)
[10:31:28.014]                           if (has_future) {
[10:31:28.014]                             ns <- base::getNamespace("future")
[10:31:28.014]                             version <- ns[[".package"]][["version"]]
[10:31:28.014]                             if (is.null(version)) 
[10:31:28.014]                               version <- utils::packageVersion("future")
[10:31:28.014]                           }
[10:31:28.014]                           else {
[10:31:28.014]                             version <- NULL
[10:31:28.014]                           }
[10:31:28.014]                           if (!has_future || version < "1.8.0") {
[10:31:28.014]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:28.014]                               "", base::R.version$version.string), 
[10:31:28.014]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:28.014]                                 base::R.version$platform, 8 * 
[10:31:28.014]                                   base::.Machine$sizeof.pointer), 
[10:31:28.014]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:28.014]                                 "release", "version")], collapse = " "), 
[10:31:28.014]                               hostname = base::Sys.info()[["nodename"]])
[10:31:28.014]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:28.014]                               info)
[10:31:28.014]                             info <- base::paste(info, collapse = "; ")
[10:31:28.014]                             if (!has_future) {
[10:31:28.014]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:28.014]                                 info)
[10:31:28.014]                             }
[10:31:28.014]                             else {
[10:31:28.014]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:28.014]                                 info, version)
[10:31:28.014]                             }
[10:31:28.014]                             base::stop(msg)
[10:31:28.014]                           }
[10:31:28.014]                         })
[10:31:28.014]                       }
[10:31:28.014]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:28.014]                       base::options(mc.cores = 1L)
[10:31:28.014]                     }
[10:31:28.014]                     base::local({
[10:31:28.014]                       for (pkg in "future.apply") {
[10:31:28.014]                         base::loadNamespace(pkg)
[10:31:28.014]                         base::library(pkg, character.only = TRUE)
[10:31:28.014]                       }
[10:31:28.014]                     })
[10:31:28.014]                   }
[10:31:28.014]                   ...future.strategy.old <- future::plan("list")
[10:31:28.014]                   options(future.plan = NULL)
[10:31:28.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:28.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:28.014]                 }
[10:31:28.014]                 ...future.workdir <- getwd()
[10:31:28.014]             }
[10:31:28.014]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:28.014]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:28.014]         }
[10:31:28.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:28.014]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:28.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:28.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:28.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:28.014]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:28.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:28.014]             base::names(...future.oldOptions))
[10:31:28.014]     }
[10:31:28.014]     if (FALSE) {
[10:31:28.014]     }
[10:31:28.014]     else {
[10:31:28.014]         if (TRUE) {
[10:31:28.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:28.014]                 open = "w")
[10:31:28.014]         }
[10:31:28.014]         else {
[10:31:28.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:28.014]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:28.014]         }
[10:31:28.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:28.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:28.014]             base::sink(type = "output", split = FALSE)
[10:31:28.014]             base::close(...future.stdout)
[10:31:28.014]         }, add = TRUE)
[10:31:28.014]     }
[10:31:28.014]     ...future.frame <- base::sys.nframe()
[10:31:28.014]     ...future.conditions <- base::list()
[10:31:28.014]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:28.014]     if (FALSE) {
[10:31:28.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:28.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:28.014]     }
[10:31:28.014]     ...future.result <- base::tryCatch({
[10:31:28.014]         base::withCallingHandlers({
[10:31:28.014]             ...future.value <- base::withVisible(base::local({
[10:31:28.014]                 ...future.makeSendCondition <- base::local({
[10:31:28.014]                   sendCondition <- NULL
[10:31:28.014]                   function(frame = 1L) {
[10:31:28.014]                     if (is.function(sendCondition)) 
[10:31:28.014]                       return(sendCondition)
[10:31:28.014]                     ns <- getNamespace("parallel")
[10:31:28.014]                     if (exists("sendData", mode = "function", 
[10:31:28.014]                       envir = ns)) {
[10:31:28.014]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:28.014]                         envir = ns)
[10:31:28.014]                       envir <- sys.frame(frame)
[10:31:28.014]                       master <- NULL
[10:31:28.014]                       while (!identical(envir, .GlobalEnv) && 
[10:31:28.014]                         !identical(envir, emptyenv())) {
[10:31:28.014]                         if (exists("master", mode = "list", envir = envir, 
[10:31:28.014]                           inherits = FALSE)) {
[10:31:28.014]                           master <- get("master", mode = "list", 
[10:31:28.014]                             envir = envir, inherits = FALSE)
[10:31:28.014]                           if (inherits(master, c("SOCKnode", 
[10:31:28.014]                             "SOCK0node"))) {
[10:31:28.014]                             sendCondition <<- function(cond) {
[10:31:28.014]                               data <- list(type = "VALUE", value = cond, 
[10:31:28.014]                                 success = TRUE)
[10:31:28.014]                               parallel_sendData(master, data)
[10:31:28.014]                             }
[10:31:28.014]                             return(sendCondition)
[10:31:28.014]                           }
[10:31:28.014]                         }
[10:31:28.014]                         frame <- frame + 1L
[10:31:28.014]                         envir <- sys.frame(frame)
[10:31:28.014]                       }
[10:31:28.014]                     }
[10:31:28.014]                     sendCondition <<- function(cond) NULL
[10:31:28.014]                   }
[10:31:28.014]                 })
[10:31:28.014]                 withCallingHandlers({
[10:31:28.014]                   {
[10:31:28.014]                     do.call(function(...) {
[10:31:28.014]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.014]                       if (!identical(...future.globals.maxSize.org, 
[10:31:28.014]                         ...future.globals.maxSize)) {
[10:31:28.014]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.014]                         on.exit(options(oopts), add = TRUE)
[10:31:28.014]                       }
[10:31:28.014]                       {
[10:31:28.014]                         lapply(seq_along(...future.elements_ii), 
[10:31:28.014]                           FUN = function(jj) {
[10:31:28.014]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.014]                             ...future.FUN(...future.X_jj, ...)
[10:31:28.014]                           })
[10:31:28.014]                       }
[10:31:28.014]                     }, args = future.call.arguments)
[10:31:28.014]                   }
[10:31:28.014]                 }, immediateCondition = function(cond) {
[10:31:28.014]                   sendCondition <- ...future.makeSendCondition()
[10:31:28.014]                   sendCondition(cond)
[10:31:28.014]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.014]                   {
[10:31:28.014]                     inherits <- base::inherits
[10:31:28.014]                     invokeRestart <- base::invokeRestart
[10:31:28.014]                     is.null <- base::is.null
[10:31:28.014]                     muffled <- FALSE
[10:31:28.014]                     if (inherits(cond, "message")) {
[10:31:28.014]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:28.014]                       if (muffled) 
[10:31:28.014]                         invokeRestart("muffleMessage")
[10:31:28.014]                     }
[10:31:28.014]                     else if (inherits(cond, "warning")) {
[10:31:28.014]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:28.014]                       if (muffled) 
[10:31:28.014]                         invokeRestart("muffleWarning")
[10:31:28.014]                     }
[10:31:28.014]                     else if (inherits(cond, "condition")) {
[10:31:28.014]                       if (!is.null(pattern)) {
[10:31:28.014]                         computeRestarts <- base::computeRestarts
[10:31:28.014]                         grepl <- base::grepl
[10:31:28.014]                         restarts <- computeRestarts(cond)
[10:31:28.014]                         for (restart in restarts) {
[10:31:28.014]                           name <- restart$name
[10:31:28.014]                           if (is.null(name)) 
[10:31:28.014]                             next
[10:31:28.014]                           if (!grepl(pattern, name)) 
[10:31:28.014]                             next
[10:31:28.014]                           invokeRestart(restart)
[10:31:28.014]                           muffled <- TRUE
[10:31:28.014]                           break
[10:31:28.014]                         }
[10:31:28.014]                       }
[10:31:28.014]                     }
[10:31:28.014]                     invisible(muffled)
[10:31:28.014]                   }
[10:31:28.014]                   muffleCondition(cond)
[10:31:28.014]                 })
[10:31:28.014]             }))
[10:31:28.014]             future::FutureResult(value = ...future.value$value, 
[10:31:28.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:28.014]                   ...future.rng), globalenv = if (FALSE) 
[10:31:28.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:28.014]                     ...future.globalenv.names))
[10:31:28.014]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:28.014]         }, condition = base::local({
[10:31:28.014]             c <- base::c
[10:31:28.014]             inherits <- base::inherits
[10:31:28.014]             invokeRestart <- base::invokeRestart
[10:31:28.014]             length <- base::length
[10:31:28.014]             list <- base::list
[10:31:28.014]             seq.int <- base::seq.int
[10:31:28.014]             signalCondition <- base::signalCondition
[10:31:28.014]             sys.calls <- base::sys.calls
[10:31:28.014]             `[[` <- base::`[[`
[10:31:28.014]             `+` <- base::`+`
[10:31:28.014]             `<<-` <- base::`<<-`
[10:31:28.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:28.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:28.014]                   3L)]
[10:31:28.014]             }
[10:31:28.014]             function(cond) {
[10:31:28.014]                 is_error <- inherits(cond, "error")
[10:31:28.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:28.014]                   NULL)
[10:31:28.014]                 if (is_error) {
[10:31:28.014]                   sessionInformation <- function() {
[10:31:28.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:28.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:28.014]                       search = base::search(), system = base::Sys.info())
[10:31:28.014]                   }
[10:31:28.014]                   ...future.conditions[[length(...future.conditions) + 
[10:31:28.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:28.014]                     cond$call), session = sessionInformation(), 
[10:31:28.014]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:28.014]                   signalCondition(cond)
[10:31:28.014]                 }
[10:31:28.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:28.014]                 "immediateCondition"))) {
[10:31:28.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:28.014]                   ...future.conditions[[length(...future.conditions) + 
[10:31:28.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:28.014]                   if (TRUE && !signal) {
[10:31:28.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.014]                     {
[10:31:28.014]                       inherits <- base::inherits
[10:31:28.014]                       invokeRestart <- base::invokeRestart
[10:31:28.014]                       is.null <- base::is.null
[10:31:28.014]                       muffled <- FALSE
[10:31:28.014]                       if (inherits(cond, "message")) {
[10:31:28.014]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:28.014]                         if (muffled) 
[10:31:28.014]                           invokeRestart("muffleMessage")
[10:31:28.014]                       }
[10:31:28.014]                       else if (inherits(cond, "warning")) {
[10:31:28.014]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:28.014]                         if (muffled) 
[10:31:28.014]                           invokeRestart("muffleWarning")
[10:31:28.014]                       }
[10:31:28.014]                       else if (inherits(cond, "condition")) {
[10:31:28.014]                         if (!is.null(pattern)) {
[10:31:28.014]                           computeRestarts <- base::computeRestarts
[10:31:28.014]                           grepl <- base::grepl
[10:31:28.014]                           restarts <- computeRestarts(cond)
[10:31:28.014]                           for (restart in restarts) {
[10:31:28.014]                             name <- restart$name
[10:31:28.014]                             if (is.null(name)) 
[10:31:28.014]                               next
[10:31:28.014]                             if (!grepl(pattern, name)) 
[10:31:28.014]                               next
[10:31:28.014]                             invokeRestart(restart)
[10:31:28.014]                             muffled <- TRUE
[10:31:28.014]                             break
[10:31:28.014]                           }
[10:31:28.014]                         }
[10:31:28.014]                       }
[10:31:28.014]                       invisible(muffled)
[10:31:28.014]                     }
[10:31:28.014]                     muffleCondition(cond, pattern = "^muffle")
[10:31:28.014]                   }
[10:31:28.014]                 }
[10:31:28.014]                 else {
[10:31:28.014]                   if (TRUE) {
[10:31:28.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.014]                     {
[10:31:28.014]                       inherits <- base::inherits
[10:31:28.014]                       invokeRestart <- base::invokeRestart
[10:31:28.014]                       is.null <- base::is.null
[10:31:28.014]                       muffled <- FALSE
[10:31:28.014]                       if (inherits(cond, "message")) {
[10:31:28.014]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:28.014]                         if (muffled) 
[10:31:28.014]                           invokeRestart("muffleMessage")
[10:31:28.014]                       }
[10:31:28.014]                       else if (inherits(cond, "warning")) {
[10:31:28.014]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:28.014]                         if (muffled) 
[10:31:28.014]                           invokeRestart("muffleWarning")
[10:31:28.014]                       }
[10:31:28.014]                       else if (inherits(cond, "condition")) {
[10:31:28.014]                         if (!is.null(pattern)) {
[10:31:28.014]                           computeRestarts <- base::computeRestarts
[10:31:28.014]                           grepl <- base::grepl
[10:31:28.014]                           restarts <- computeRestarts(cond)
[10:31:28.014]                           for (restart in restarts) {
[10:31:28.014]                             name <- restart$name
[10:31:28.014]                             if (is.null(name)) 
[10:31:28.014]                               next
[10:31:28.014]                             if (!grepl(pattern, name)) 
[10:31:28.014]                               next
[10:31:28.014]                             invokeRestart(restart)
[10:31:28.014]                             muffled <- TRUE
[10:31:28.014]                             break
[10:31:28.014]                           }
[10:31:28.014]                         }
[10:31:28.014]                       }
[10:31:28.014]                       invisible(muffled)
[10:31:28.014]                     }
[10:31:28.014]                     muffleCondition(cond, pattern = "^muffle")
[10:31:28.014]                   }
[10:31:28.014]                 }
[10:31:28.014]             }
[10:31:28.014]         }))
[10:31:28.014]     }, error = function(ex) {
[10:31:28.014]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:28.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:28.014]                 ...future.rng), started = ...future.startTime, 
[10:31:28.014]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:28.014]             version = "1.8"), class = "FutureResult")
[10:31:28.014]     }, finally = {
[10:31:28.014]         if (!identical(...future.workdir, getwd())) 
[10:31:28.014]             setwd(...future.workdir)
[10:31:28.014]         {
[10:31:28.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:28.014]                 ...future.oldOptions$nwarnings <- NULL
[10:31:28.014]             }
[10:31:28.014]             base::options(...future.oldOptions)
[10:31:28.014]             if (.Platform$OS.type == "windows") {
[10:31:28.014]                 old_names <- names(...future.oldEnvVars)
[10:31:28.014]                 envs <- base::Sys.getenv()
[10:31:28.014]                 names <- names(envs)
[10:31:28.014]                 common <- intersect(names, old_names)
[10:31:28.014]                 added <- setdiff(names, old_names)
[10:31:28.014]                 removed <- setdiff(old_names, names)
[10:31:28.014]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:28.014]                   envs[common]]
[10:31:28.014]                 NAMES <- toupper(changed)
[10:31:28.014]                 args <- list()
[10:31:28.014]                 for (kk in seq_along(NAMES)) {
[10:31:28.014]                   name <- changed[[kk]]
[10:31:28.014]                   NAME <- NAMES[[kk]]
[10:31:28.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.014]                     next
[10:31:28.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:28.014]                 }
[10:31:28.014]                 NAMES <- toupper(added)
[10:31:28.014]                 for (kk in seq_along(NAMES)) {
[10:31:28.014]                   name <- added[[kk]]
[10:31:28.014]                   NAME <- NAMES[[kk]]
[10:31:28.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.014]                     next
[10:31:28.014]                   args[[name]] <- ""
[10:31:28.014]                 }
[10:31:28.014]                 NAMES <- toupper(removed)
[10:31:28.014]                 for (kk in seq_along(NAMES)) {
[10:31:28.014]                   name <- removed[[kk]]
[10:31:28.014]                   NAME <- NAMES[[kk]]
[10:31:28.014]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.014]                     next
[10:31:28.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:28.014]                 }
[10:31:28.014]                 if (length(args) > 0) 
[10:31:28.014]                   base::do.call(base::Sys.setenv, args = args)
[10:31:28.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:28.014]             }
[10:31:28.014]             else {
[10:31:28.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:28.014]             }
[10:31:28.014]             {
[10:31:28.014]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:28.014]                   0L) {
[10:31:28.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:28.014]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:28.014]                   base::options(opts)
[10:31:28.014]                 }
[10:31:28.014]                 {
[10:31:28.014]                   {
[10:31:28.014]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:28.014]                     NULL
[10:31:28.014]                   }
[10:31:28.014]                   options(future.plan = NULL)
[10:31:28.014]                   if (is.na(NA_character_)) 
[10:31:28.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:28.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:28.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:28.014]                     .init = FALSE)
[10:31:28.014]                 }
[10:31:28.014]             }
[10:31:28.014]         }
[10:31:28.014]     })
[10:31:28.014]     if (TRUE) {
[10:31:28.014]         base::sink(type = "output", split = FALSE)
[10:31:28.014]         if (TRUE) {
[10:31:28.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:28.014]         }
[10:31:28.014]         else {
[10:31:28.014]             ...future.result["stdout"] <- base::list(NULL)
[10:31:28.014]         }
[10:31:28.014]         base::close(...future.stdout)
[10:31:28.014]         ...future.stdout <- NULL
[10:31:28.014]     }
[10:31:28.014]     ...future.result$conditions <- ...future.conditions
[10:31:28.014]     ...future.result$finished <- base::Sys.time()
[10:31:28.014]     ...future.result
[10:31:28.014] }
[10:31:28.016] Exporting 11 global objects (95.02 KiB) to cluster node #2 ...
[10:31:28.017] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:31:28.061] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:31:28.061] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ...
[10:31:28.062] Exporting ‘x_FUN’ (2.90 KiB) to cluster node #2 ... DONE
[10:31:28.062] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:31:28.062] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:31:28.062] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:31:28.105] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:31:28.105] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:31:28.149] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:31:28.149] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[10:31:28.150] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[10:31:28.150] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:31:28.150] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:31:28.150] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:31:28.151] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:31:28.151] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:31:28.151] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:31:28.151] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:28.152] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:28.152] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:28.152] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:28.152] Exporting 11 global objects (95.02 KiB) to cluster node #2 ... DONE
[10:31:28.153] MultisessionFuture started
[10:31:28.153] - Launch lazy future ... done
[10:31:28.153] run() for ‘MultisessionFuture’ ... done
[10:31:28.153] Created future:
[10:31:28.154] MultisessionFuture:
[10:31:28.154] Label: ‘future_vapply-2’
[10:31:28.154] Expression:
[10:31:28.154] {
[10:31:28.154]     do.call(function(...) {
[10:31:28.154]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.154]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:28.154]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.154]             on.exit(options(oopts), add = TRUE)
[10:31:28.154]         }
[10:31:28.154]         {
[10:31:28.154]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:28.154]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.154]                 ...future.FUN(...future.X_jj, ...)
[10:31:28.154]             })
[10:31:28.154]         }
[10:31:28.154]     }, args = future.call.arguments)
[10:31:28.154] }
[10:31:28.154] Lazy evaluation: FALSE
[10:31:28.154] Asynchronous evaluation: TRUE
[10:31:28.154] Local evaluation: TRUE
[10:31:28.154] Environment: R_GlobalEnv
[10:31:28.154] Capture standard output: TRUE
[10:31:28.154] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:28.154] Globals: 11 objects totaling 95.30 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 2.90 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:28.154] Packages: 1 packages (‘future.apply’)
[10:31:28.154] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:28.154] Resolved: FALSE
[10:31:28.154] Value: <not collected>
[10:31:28.154] Conditions captured: <none>
[10:31:28.154] Early signaling: FALSE
[10:31:28.154] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:28.154] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:28.165] Chunk #2 of 2 ... DONE
[10:31:28.165] Launching 2 futures (chunks) ... DONE
[10:31:28.165] Resolving 2 futures (chunks) ...
[10:31:28.166] resolve() on list ...
[10:31:28.166]  recursive: 0
[10:31:28.166]  length: 2
[10:31:28.166] 
[10:31:28.166] receiveMessageFromWorker() for ClusterFuture ...
[10:31:28.166] - Validating connection of MultisessionFuture
[10:31:28.167] - received message: FutureResult
[10:31:28.167] - Received FutureResult
[10:31:28.167] - Erased future from FutureRegistry
[10:31:28.167] result() for ClusterFuture ...
[10:31:28.167] - result already collected: FutureResult
[10:31:28.167] result() for ClusterFuture ... done
[10:31:28.167] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:28.167] Future #1
[10:31:28.167] result() for ClusterFuture ...
[10:31:28.167] - result already collected: FutureResult
[10:31:28.168] result() for ClusterFuture ... done
[10:31:28.168] result() for ClusterFuture ...
[10:31:28.168] - result already collected: FutureResult
[10:31:28.168] result() for ClusterFuture ... done
[10:31:28.168] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:28.168] - nx: 2
[10:31:28.168] - relay: TRUE
[10:31:28.168] - stdout: TRUE
[10:31:28.168] - signal: TRUE
[10:31:28.168] - resignal: FALSE
[10:31:28.168] - force: TRUE
[10:31:28.169] - relayed: [n=2] FALSE, FALSE
[10:31:28.169] - queued futures: [n=2] FALSE, FALSE
[10:31:28.169]  - until=1
[10:31:28.169]  - relaying element #1
[10:31:28.169] result() for ClusterFuture ...
[10:31:28.169] - result already collected: FutureResult
[10:31:28.169] result() for ClusterFuture ... done
[10:31:28.169] result() for ClusterFuture ...
[10:31:28.169] - result already collected: FutureResult
[10:31:28.169] result() for ClusterFuture ... done
[10:31:28.170] result() for ClusterFuture ...
[10:31:28.170] - result already collected: FutureResult
[10:31:28.170] result() for ClusterFuture ... done
[10:31:28.170] result() for ClusterFuture ...
[10:31:28.170] - result already collected: FutureResult
[10:31:28.170] result() for ClusterFuture ... done
[10:31:28.170] - relayed: [n=2] TRUE, FALSE
[10:31:28.170] - queued futures: [n=2] TRUE, FALSE
[10:31:28.170] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:28.170]  length: 1 (resolved future 1)
[10:31:28.198] receiveMessageFromWorker() for ClusterFuture ...
[10:31:28.199] - Validating connection of MultisessionFuture
[10:31:28.199] - received message: FutureResult
[10:31:28.199] - Received FutureResult
[10:31:28.199] - Erased future from FutureRegistry
[10:31:28.199] result() for ClusterFuture ...
[10:31:28.199] - result already collected: FutureResult
[10:31:28.199] result() for ClusterFuture ... done
[10:31:28.199] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:28.199] Future #2
[10:31:28.200] result() for ClusterFuture ...
[10:31:28.200] - result already collected: FutureResult
[10:31:28.200] result() for ClusterFuture ... done
[10:31:28.200] result() for ClusterFuture ...
[10:31:28.200] - result already collected: FutureResult
[10:31:28.200] result() for ClusterFuture ... done
[10:31:28.200] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:28.200] - nx: 2
[10:31:28.200] - relay: TRUE
[10:31:28.200] - stdout: TRUE
[10:31:28.200] - signal: TRUE
[10:31:28.201] - resignal: FALSE
[10:31:28.201] - force: TRUE
[10:31:28.201] - relayed: [n=2] TRUE, FALSE
[10:31:28.201] - queued futures: [n=2] TRUE, FALSE
[10:31:28.201]  - until=2
[10:31:28.201]  - relaying element #2
[10:31:28.201] result() for ClusterFuture ...
[10:31:28.201] - result already collected: FutureResult
[10:31:28.201] result() for ClusterFuture ... done
[10:31:28.201] result() for ClusterFuture ...
[10:31:28.201] - result already collected: FutureResult
[10:31:28.202] result() for ClusterFuture ... done
[10:31:28.202] result() for ClusterFuture ...
[10:31:28.202] - result already collected: FutureResult
[10:31:28.202] result() for ClusterFuture ... done
[10:31:28.202] result() for ClusterFuture ...
[10:31:28.202] - result already collected: FutureResult
[10:31:28.202] result() for ClusterFuture ... done
[10:31:28.202] - relayed: [n=2] TRUE, TRUE
[10:31:28.202] - queued futures: [n=2] TRUE, TRUE
[10:31:28.202] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:28.202]  length: 0 (resolved future 2)
[10:31:28.203] Relaying remaining futures
[10:31:28.203] signalConditionsASAP(NULL, pos=0) ...
[10:31:28.203] - nx: 2
[10:31:28.203] - relay: TRUE
[10:31:28.203] - stdout: TRUE
[10:31:28.203] - signal: TRUE
[10:31:28.203] - resignal: FALSE
[10:31:28.203] - force: TRUE
[10:31:28.203] - relayed: [n=2] TRUE, TRUE
[10:31:28.203] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:28.203] - relayed: [n=2] TRUE, TRUE
[10:31:28.203] - queued futures: [n=2] TRUE, TRUE
[10:31:28.204] signalConditionsASAP(NULL, pos=0) ... done
[10:31:28.204] resolve() on list ... DONE
[10:31:28.204] result() for ClusterFuture ...
[10:31:28.204] - result already collected: FutureResult
[10:31:28.204] result() for ClusterFuture ... done
[10:31:28.204] result() for ClusterFuture ...
[10:31:28.204] - result already collected: FutureResult
[10:31:28.204] result() for ClusterFuture ... done
[10:31:28.204] result() for ClusterFuture ...
[10:31:28.204] - result already collected: FutureResult
[10:31:28.204] result() for ClusterFuture ... done
[10:31:28.205] result() for ClusterFuture ...
[10:31:28.205] - result already collected: FutureResult
[10:31:28.205] result() for ClusterFuture ... done
[10:31:28.205]  - Number of value chunks collected: 2
[10:31:28.205] Resolving 2 futures (chunks) ... DONE
[10:31:28.205] Reducing values from 2 chunks ...
[10:31:28.205]  - Number of values collected after concatenation: 10
[10:31:28.205]  - Number of values expected: 10
[10:31:28.205] Reducing values from 2 chunks ... DONE
[10:31:28.205] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 num [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
[10:31:28.207] future_lapply() ...
[10:31:28.213] Number of chunks: 2
[10:31:28.213] getGlobalsAndPackagesXApply() ...
[10:31:28.213]  - future.globals: TRUE
[10:31:28.214] getGlobalsAndPackages() ...
[10:31:28.214] Searching for globals...
[10:31:28.222] - globals found: [19] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘matrix’, ‘list’, ‘c’
[10:31:28.222] Searching for globals ... DONE
[10:31:28.222] Resolving globals: FALSE
[10:31:28.223] The total size of the 7 globals is 103.08 KiB (105552 bytes)
[10:31:28.224] The total size of the 7 globals exported for future expression (‘FUN()’) is 103.08 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:28.224] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:28.224] - packages: [1] ‘future.apply’
[10:31:28.224] getGlobalsAndPackages() ... DONE
[10:31:28.224]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:28.225]  - needed namespaces: [n=1] ‘future.apply’
[10:31:28.225] Finding globals ... DONE
[10:31:28.225]  - use_args: TRUE
[10:31:28.225]  - Getting '...' globals ...
[10:31:28.226] resolve() on list ...
[10:31:28.226]  recursive: 0
[10:31:28.226]  length: 1
[10:31:28.226]  elements: ‘...’
[10:31:28.226]  length: 0 (resolved future 1)
[10:31:28.226] resolve() on list ... DONE
[10:31:28.226]    - '...' content: [n=0] 
[10:31:28.226] List of 1
[10:31:28.226]  $ ...: list()
[10:31:28.226]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:28.226]  - attr(*, "where")=List of 1
[10:31:28.226]   ..$ ...:<environment: 0x55de8781f730> 
[10:31:28.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:28.226]  - attr(*, "resolved")= logi TRUE
[10:31:28.226]  - attr(*, "total_size")= num NA
[10:31:28.229]  - Getting '...' globals ... DONE
[10:31:28.230] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:28.230] List of 8
[10:31:28.230]  $ ...future.FUN:function (x, ...)  
[10:31:28.230]  $ x_FUN        :function (x)  
[10:31:28.230]  $ times        : int 4
[10:31:28.230]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:28.230]  $ stop_if_not  :function (...)  
[10:31:28.230]  $ dim          : int [1:2] 2 2
[10:31:28.230]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:28.230]  $ ...          : list()
[10:31:28.230]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:28.230]  - attr(*, "where")=List of 8
[10:31:28.230]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:28.230]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:28.230]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:28.230]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:28.230]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:28.230]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:28.230]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:28.230]   ..$ ...          :<environment: 0x55de8781f730> 
[10:31:28.230]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:28.230]  - attr(*, "resolved")= logi FALSE
[10:31:28.230]  - attr(*, "total_size")= num 105552
[10:31:28.235] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:28.235] getGlobalsAndPackagesXApply() ... DONE
[10:31:28.235] Number of futures (= number of chunks): 2
[10:31:28.235] Launching 2 futures (chunks) ...
[10:31:28.236] Chunk #1 of 2 ...
[10:31:28.236]  - Finding globals in 'X' for chunk #1 ...
[10:31:28.236] getGlobalsAndPackages() ...
[10:31:28.236] Searching for globals...
[10:31:28.236] 
[10:31:28.236] Searching for globals ... DONE
[10:31:28.236] - globals: [0] <none>
[10:31:28.236] getGlobalsAndPackages() ... DONE
[10:31:28.237]    + additional globals found: [n=0] 
[10:31:28.237]    + additional namespaces needed: [n=0] 
[10:31:28.237]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:28.237]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:28.237]  - seeds: <none>
[10:31:28.237]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:28.237] getGlobalsAndPackages() ...
[10:31:28.237] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:28.237] Resolving globals: FALSE
[10:31:28.237] Tweak future expression to call with '...' arguments ...
[10:31:28.238] {
[10:31:28.238]     do.call(function(...) {
[10:31:28.238]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.238]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:28.238]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.238]             on.exit(options(oopts), add = TRUE)
[10:31:28.238]         }
[10:31:28.238]         {
[10:31:28.238]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:28.238]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.238]                 ...future.FUN(...future.X_jj, ...)
[10:31:28.238]             })
[10:31:28.238]         }
[10:31:28.238]     }, args = future.call.arguments)
[10:31:28.238] }
[10:31:28.238] Tweak future expression to call with '...' arguments ... DONE
[10:31:28.238] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:28.238] - packages: [1] ‘future.apply’
[10:31:28.239] getGlobalsAndPackages() ... DONE
[10:31:28.239] run() for ‘Future’ ...
[10:31:28.239] - state: ‘created’
[10:31:28.239] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:28.253] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:28.253] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:28.253]   - Field: ‘node’
[10:31:28.253]   - Field: ‘label’
[10:31:28.253]   - Field: ‘local’
[10:31:28.253]   - Field: ‘owner’
[10:31:28.254]   - Field: ‘envir’
[10:31:28.254]   - Field: ‘workers’
[10:31:28.254]   - Field: ‘packages’
[10:31:28.254]   - Field: ‘gc’
[10:31:28.254]   - Field: ‘conditions’
[10:31:28.254]   - Field: ‘persistent’
[10:31:28.254]   - Field: ‘expr’
[10:31:28.254]   - Field: ‘uuid’
[10:31:28.254]   - Field: ‘seed’
[10:31:28.254]   - Field: ‘version’
[10:31:28.255]   - Field: ‘result’
[10:31:28.255]   - Field: ‘asynchronous’
[10:31:28.255]   - Field: ‘calls’
[10:31:28.255]   - Field: ‘globals’
[10:31:28.255]   - Field: ‘stdout’
[10:31:28.255]   - Field: ‘earlySignal’
[10:31:28.255]   - Field: ‘lazy’
[10:31:28.255]   - Field: ‘state’
[10:31:28.255] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:28.255] - Launch lazy future ...
[10:31:28.256] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:28.256] Packages needed by future strategies (n = 0): <none>
[10:31:28.256] {
[10:31:28.256]     {
[10:31:28.256]         {
[10:31:28.256]             ...future.startTime <- base::Sys.time()
[10:31:28.256]             {
[10:31:28.256]                 {
[10:31:28.256]                   {
[10:31:28.256]                     {
[10:31:28.256]                       {
[10:31:28.256]                         base::local({
[10:31:28.256]                           has_future <- base::requireNamespace("future", 
[10:31:28.256]                             quietly = TRUE)
[10:31:28.256]                           if (has_future) {
[10:31:28.256]                             ns <- base::getNamespace("future")
[10:31:28.256]                             version <- ns[[".package"]][["version"]]
[10:31:28.256]                             if (is.null(version)) 
[10:31:28.256]                               version <- utils::packageVersion("future")
[10:31:28.256]                           }
[10:31:28.256]                           else {
[10:31:28.256]                             version <- NULL
[10:31:28.256]                           }
[10:31:28.256]                           if (!has_future || version < "1.8.0") {
[10:31:28.256]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:28.256]                               "", base::R.version$version.string), 
[10:31:28.256]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:28.256]                                 base::R.version$platform, 8 * 
[10:31:28.256]                                   base::.Machine$sizeof.pointer), 
[10:31:28.256]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:28.256]                                 "release", "version")], collapse = " "), 
[10:31:28.256]                               hostname = base::Sys.info()[["nodename"]])
[10:31:28.256]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:28.256]                               info)
[10:31:28.256]                             info <- base::paste(info, collapse = "; ")
[10:31:28.256]                             if (!has_future) {
[10:31:28.256]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:28.256]                                 info)
[10:31:28.256]                             }
[10:31:28.256]                             else {
[10:31:28.256]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:28.256]                                 info, version)
[10:31:28.256]                             }
[10:31:28.256]                             base::stop(msg)
[10:31:28.256]                           }
[10:31:28.256]                         })
[10:31:28.256]                       }
[10:31:28.256]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:28.256]                       base::options(mc.cores = 1L)
[10:31:28.256]                     }
[10:31:28.256]                     base::local({
[10:31:28.256]                       for (pkg in "future.apply") {
[10:31:28.256]                         base::loadNamespace(pkg)
[10:31:28.256]                         base::library(pkg, character.only = TRUE)
[10:31:28.256]                       }
[10:31:28.256]                     })
[10:31:28.256]                   }
[10:31:28.256]                   ...future.strategy.old <- future::plan("list")
[10:31:28.256]                   options(future.plan = NULL)
[10:31:28.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:28.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:28.256]                 }
[10:31:28.256]                 ...future.workdir <- getwd()
[10:31:28.256]             }
[10:31:28.256]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:28.256]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:28.256]         }
[10:31:28.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:28.256]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:28.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:28.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:28.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:28.256]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:28.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:28.256]             base::names(...future.oldOptions))
[10:31:28.256]     }
[10:31:28.256]     if (FALSE) {
[10:31:28.256]     }
[10:31:28.256]     else {
[10:31:28.256]         if (TRUE) {
[10:31:28.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:28.256]                 open = "w")
[10:31:28.256]         }
[10:31:28.256]         else {
[10:31:28.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:28.256]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:28.256]         }
[10:31:28.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:28.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:28.256]             base::sink(type = "output", split = FALSE)
[10:31:28.256]             base::close(...future.stdout)
[10:31:28.256]         }, add = TRUE)
[10:31:28.256]     }
[10:31:28.256]     ...future.frame <- base::sys.nframe()
[10:31:28.256]     ...future.conditions <- base::list()
[10:31:28.256]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:28.256]     if (FALSE) {
[10:31:28.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:28.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:28.256]     }
[10:31:28.256]     ...future.result <- base::tryCatch({
[10:31:28.256]         base::withCallingHandlers({
[10:31:28.256]             ...future.value <- base::withVisible(base::local({
[10:31:28.256]                 ...future.makeSendCondition <- base::local({
[10:31:28.256]                   sendCondition <- NULL
[10:31:28.256]                   function(frame = 1L) {
[10:31:28.256]                     if (is.function(sendCondition)) 
[10:31:28.256]                       return(sendCondition)
[10:31:28.256]                     ns <- getNamespace("parallel")
[10:31:28.256]                     if (exists("sendData", mode = "function", 
[10:31:28.256]                       envir = ns)) {
[10:31:28.256]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:28.256]                         envir = ns)
[10:31:28.256]                       envir <- sys.frame(frame)
[10:31:28.256]                       master <- NULL
[10:31:28.256]                       while (!identical(envir, .GlobalEnv) && 
[10:31:28.256]                         !identical(envir, emptyenv())) {
[10:31:28.256]                         if (exists("master", mode = "list", envir = envir, 
[10:31:28.256]                           inherits = FALSE)) {
[10:31:28.256]                           master <- get("master", mode = "list", 
[10:31:28.256]                             envir = envir, inherits = FALSE)
[10:31:28.256]                           if (inherits(master, c("SOCKnode", 
[10:31:28.256]                             "SOCK0node"))) {
[10:31:28.256]                             sendCondition <<- function(cond) {
[10:31:28.256]                               data <- list(type = "VALUE", value = cond, 
[10:31:28.256]                                 success = TRUE)
[10:31:28.256]                               parallel_sendData(master, data)
[10:31:28.256]                             }
[10:31:28.256]                             return(sendCondition)
[10:31:28.256]                           }
[10:31:28.256]                         }
[10:31:28.256]                         frame <- frame + 1L
[10:31:28.256]                         envir <- sys.frame(frame)
[10:31:28.256]                       }
[10:31:28.256]                     }
[10:31:28.256]                     sendCondition <<- function(cond) NULL
[10:31:28.256]                   }
[10:31:28.256]                 })
[10:31:28.256]                 withCallingHandlers({
[10:31:28.256]                   {
[10:31:28.256]                     do.call(function(...) {
[10:31:28.256]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.256]                       if (!identical(...future.globals.maxSize.org, 
[10:31:28.256]                         ...future.globals.maxSize)) {
[10:31:28.256]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.256]                         on.exit(options(oopts), add = TRUE)
[10:31:28.256]                       }
[10:31:28.256]                       {
[10:31:28.256]                         lapply(seq_along(...future.elements_ii), 
[10:31:28.256]                           FUN = function(jj) {
[10:31:28.256]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.256]                             ...future.FUN(...future.X_jj, ...)
[10:31:28.256]                           })
[10:31:28.256]                       }
[10:31:28.256]                     }, args = future.call.arguments)
[10:31:28.256]                   }
[10:31:28.256]                 }, immediateCondition = function(cond) {
[10:31:28.256]                   sendCondition <- ...future.makeSendCondition()
[10:31:28.256]                   sendCondition(cond)
[10:31:28.256]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.256]                   {
[10:31:28.256]                     inherits <- base::inherits
[10:31:28.256]                     invokeRestart <- base::invokeRestart
[10:31:28.256]                     is.null <- base::is.null
[10:31:28.256]                     muffled <- FALSE
[10:31:28.256]                     if (inherits(cond, "message")) {
[10:31:28.256]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:28.256]                       if (muffled) 
[10:31:28.256]                         invokeRestart("muffleMessage")
[10:31:28.256]                     }
[10:31:28.256]                     else if (inherits(cond, "warning")) {
[10:31:28.256]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:28.256]                       if (muffled) 
[10:31:28.256]                         invokeRestart("muffleWarning")
[10:31:28.256]                     }
[10:31:28.256]                     else if (inherits(cond, "condition")) {
[10:31:28.256]                       if (!is.null(pattern)) {
[10:31:28.256]                         computeRestarts <- base::computeRestarts
[10:31:28.256]                         grepl <- base::grepl
[10:31:28.256]                         restarts <- computeRestarts(cond)
[10:31:28.256]                         for (restart in restarts) {
[10:31:28.256]                           name <- restart$name
[10:31:28.256]                           if (is.null(name)) 
[10:31:28.256]                             next
[10:31:28.256]                           if (!grepl(pattern, name)) 
[10:31:28.256]                             next
[10:31:28.256]                           invokeRestart(restart)
[10:31:28.256]                           muffled <- TRUE
[10:31:28.256]                           break
[10:31:28.256]                         }
[10:31:28.256]                       }
[10:31:28.256]                     }
[10:31:28.256]                     invisible(muffled)
[10:31:28.256]                   }
[10:31:28.256]                   muffleCondition(cond)
[10:31:28.256]                 })
[10:31:28.256]             }))
[10:31:28.256]             future::FutureResult(value = ...future.value$value, 
[10:31:28.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:28.256]                   ...future.rng), globalenv = if (FALSE) 
[10:31:28.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:28.256]                     ...future.globalenv.names))
[10:31:28.256]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:28.256]         }, condition = base::local({
[10:31:28.256]             c <- base::c
[10:31:28.256]             inherits <- base::inherits
[10:31:28.256]             invokeRestart <- base::invokeRestart
[10:31:28.256]             length <- base::length
[10:31:28.256]             list <- base::list
[10:31:28.256]             seq.int <- base::seq.int
[10:31:28.256]             signalCondition <- base::signalCondition
[10:31:28.256]             sys.calls <- base::sys.calls
[10:31:28.256]             `[[` <- base::`[[`
[10:31:28.256]             `+` <- base::`+`
[10:31:28.256]             `<<-` <- base::`<<-`
[10:31:28.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:28.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:28.256]                   3L)]
[10:31:28.256]             }
[10:31:28.256]             function(cond) {
[10:31:28.256]                 is_error <- inherits(cond, "error")
[10:31:28.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:28.256]                   NULL)
[10:31:28.256]                 if (is_error) {
[10:31:28.256]                   sessionInformation <- function() {
[10:31:28.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:28.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:28.256]                       search = base::search(), system = base::Sys.info())
[10:31:28.256]                   }
[10:31:28.256]                   ...future.conditions[[length(...future.conditions) + 
[10:31:28.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:28.256]                     cond$call), session = sessionInformation(), 
[10:31:28.256]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:28.256]                   signalCondition(cond)
[10:31:28.256]                 }
[10:31:28.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:28.256]                 "immediateCondition"))) {
[10:31:28.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:28.256]                   ...future.conditions[[length(...future.conditions) + 
[10:31:28.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:28.256]                   if (TRUE && !signal) {
[10:31:28.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.256]                     {
[10:31:28.256]                       inherits <- base::inherits
[10:31:28.256]                       invokeRestart <- base::invokeRestart
[10:31:28.256]                       is.null <- base::is.null
[10:31:28.256]                       muffled <- FALSE
[10:31:28.256]                       if (inherits(cond, "message")) {
[10:31:28.256]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:28.256]                         if (muffled) 
[10:31:28.256]                           invokeRestart("muffleMessage")
[10:31:28.256]                       }
[10:31:28.256]                       else if (inherits(cond, "warning")) {
[10:31:28.256]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:28.256]                         if (muffled) 
[10:31:28.256]                           invokeRestart("muffleWarning")
[10:31:28.256]                       }
[10:31:28.256]                       else if (inherits(cond, "condition")) {
[10:31:28.256]                         if (!is.null(pattern)) {
[10:31:28.256]                           computeRestarts <- base::computeRestarts
[10:31:28.256]                           grepl <- base::grepl
[10:31:28.256]                           restarts <- computeRestarts(cond)
[10:31:28.256]                           for (restart in restarts) {
[10:31:28.256]                             name <- restart$name
[10:31:28.256]                             if (is.null(name)) 
[10:31:28.256]                               next
[10:31:28.256]                             if (!grepl(pattern, name)) 
[10:31:28.256]                               next
[10:31:28.256]                             invokeRestart(restart)
[10:31:28.256]                             muffled <- TRUE
[10:31:28.256]                             break
[10:31:28.256]                           }
[10:31:28.256]                         }
[10:31:28.256]                       }
[10:31:28.256]                       invisible(muffled)
[10:31:28.256]                     }
[10:31:28.256]                     muffleCondition(cond, pattern = "^muffle")
[10:31:28.256]                   }
[10:31:28.256]                 }
[10:31:28.256]                 else {
[10:31:28.256]                   if (TRUE) {
[10:31:28.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.256]                     {
[10:31:28.256]                       inherits <- base::inherits
[10:31:28.256]                       invokeRestart <- base::invokeRestart
[10:31:28.256]                       is.null <- base::is.null
[10:31:28.256]                       muffled <- FALSE
[10:31:28.256]                       if (inherits(cond, "message")) {
[10:31:28.256]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:28.256]                         if (muffled) 
[10:31:28.256]                           invokeRestart("muffleMessage")
[10:31:28.256]                       }
[10:31:28.256]                       else if (inherits(cond, "warning")) {
[10:31:28.256]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:28.256]                         if (muffled) 
[10:31:28.256]                           invokeRestart("muffleWarning")
[10:31:28.256]                       }
[10:31:28.256]                       else if (inherits(cond, "condition")) {
[10:31:28.256]                         if (!is.null(pattern)) {
[10:31:28.256]                           computeRestarts <- base::computeRestarts
[10:31:28.256]                           grepl <- base::grepl
[10:31:28.256]                           restarts <- computeRestarts(cond)
[10:31:28.256]                           for (restart in restarts) {
[10:31:28.256]                             name <- restart$name
[10:31:28.256]                             if (is.null(name)) 
[10:31:28.256]                               next
[10:31:28.256]                             if (!grepl(pattern, name)) 
[10:31:28.256]                               next
[10:31:28.256]                             invokeRestart(restart)
[10:31:28.256]                             muffled <- TRUE
[10:31:28.256]                             break
[10:31:28.256]                           }
[10:31:28.256]                         }
[10:31:28.256]                       }
[10:31:28.256]                       invisible(muffled)
[10:31:28.256]                     }
[10:31:28.256]                     muffleCondition(cond, pattern = "^muffle")
[10:31:28.256]                   }
[10:31:28.256]                 }
[10:31:28.256]             }
[10:31:28.256]         }))
[10:31:28.256]     }, error = function(ex) {
[10:31:28.256]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:28.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:28.256]                 ...future.rng), started = ...future.startTime, 
[10:31:28.256]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:28.256]             version = "1.8"), class = "FutureResult")
[10:31:28.256]     }, finally = {
[10:31:28.256]         if (!identical(...future.workdir, getwd())) 
[10:31:28.256]             setwd(...future.workdir)
[10:31:28.256]         {
[10:31:28.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:28.256]                 ...future.oldOptions$nwarnings <- NULL
[10:31:28.256]             }
[10:31:28.256]             base::options(...future.oldOptions)
[10:31:28.256]             if (.Platform$OS.type == "windows") {
[10:31:28.256]                 old_names <- names(...future.oldEnvVars)
[10:31:28.256]                 envs <- base::Sys.getenv()
[10:31:28.256]                 names <- names(envs)
[10:31:28.256]                 common <- intersect(names, old_names)
[10:31:28.256]                 added <- setdiff(names, old_names)
[10:31:28.256]                 removed <- setdiff(old_names, names)
[10:31:28.256]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:28.256]                   envs[common]]
[10:31:28.256]                 NAMES <- toupper(changed)
[10:31:28.256]                 args <- list()
[10:31:28.256]                 for (kk in seq_along(NAMES)) {
[10:31:28.256]                   name <- changed[[kk]]
[10:31:28.256]                   NAME <- NAMES[[kk]]
[10:31:28.256]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.256]                     next
[10:31:28.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:28.256]                 }
[10:31:28.256]                 NAMES <- toupper(added)
[10:31:28.256]                 for (kk in seq_along(NAMES)) {
[10:31:28.256]                   name <- added[[kk]]
[10:31:28.256]                   NAME <- NAMES[[kk]]
[10:31:28.256]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.256]                     next
[10:31:28.256]                   args[[name]] <- ""
[10:31:28.256]                 }
[10:31:28.256]                 NAMES <- toupper(removed)
[10:31:28.256]                 for (kk in seq_along(NAMES)) {
[10:31:28.256]                   name <- removed[[kk]]
[10:31:28.256]                   NAME <- NAMES[[kk]]
[10:31:28.256]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.256]                     next
[10:31:28.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:28.256]                 }
[10:31:28.256]                 if (length(args) > 0) 
[10:31:28.256]                   base::do.call(base::Sys.setenv, args = args)
[10:31:28.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:28.256]             }
[10:31:28.256]             else {
[10:31:28.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:28.256]             }
[10:31:28.256]             {
[10:31:28.256]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:28.256]                   0L) {
[10:31:28.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:28.256]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:28.256]                   base::options(opts)
[10:31:28.256]                 }
[10:31:28.256]                 {
[10:31:28.256]                   {
[10:31:28.256]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:28.256]                     NULL
[10:31:28.256]                   }
[10:31:28.256]                   options(future.plan = NULL)
[10:31:28.256]                   if (is.na(NA_character_)) 
[10:31:28.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:28.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:28.256]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:28.256]                     .init = FALSE)
[10:31:28.256]                 }
[10:31:28.256]             }
[10:31:28.256]         }
[10:31:28.256]     })
[10:31:28.256]     if (TRUE) {
[10:31:28.256]         base::sink(type = "output", split = FALSE)
[10:31:28.256]         if (TRUE) {
[10:31:28.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:28.256]         }
[10:31:28.256]         else {
[10:31:28.256]             ...future.result["stdout"] <- base::list(NULL)
[10:31:28.256]         }
[10:31:28.256]         base::close(...future.stdout)
[10:31:28.256]         ...future.stdout <- NULL
[10:31:28.256]     }
[10:31:28.256]     ...future.result$conditions <- ...future.conditions
[10:31:28.256]     ...future.result$finished <- base::Sys.time()
[10:31:28.256]     ...future.result
[10:31:28.256] }
[10:31:28.259] Exporting 11 global objects (103.08 KiB) to cluster node #1 ...
[10:31:28.259] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:28.301] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:28.301] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ...
[10:31:28.302] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #1 ... DONE
[10:31:28.302] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:28.302] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:28.302] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:28.345] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:28.345] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:28.389] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:28.389] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[10:31:28.390] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[10:31:28.390] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:31:28.390] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:31:28.390] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:28.391] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:28.391] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ...
[10:31:28.391] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #1 ... DONE
[10:31:28.391] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:28.392] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:28.392] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:28.392] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:28.392] Exporting 11 global objects (103.08 KiB) to cluster node #1 ... DONE
[10:31:28.393] MultisessionFuture started
[10:31:28.393] - Launch lazy future ... done
[10:31:28.393] run() for ‘MultisessionFuture’ ... done
[10:31:28.393] Created future:
[10:31:28.393] MultisessionFuture:
[10:31:28.393] Label: ‘future_vapply-1’
[10:31:28.393] Expression:
[10:31:28.393] {
[10:31:28.393]     do.call(function(...) {
[10:31:28.393]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.393]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:28.393]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.393]             on.exit(options(oopts), add = TRUE)
[10:31:28.393]         }
[10:31:28.393]         {
[10:31:28.393]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:28.393]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.393]                 ...future.FUN(...future.X_jj, ...)
[10:31:28.393]             })
[10:31:28.393]         }
[10:31:28.393]     }, args = future.call.arguments)
[10:31:28.393] }
[10:31:28.393] Lazy evaluation: FALSE
[10:31:28.393] Asynchronous evaluation: TRUE
[10:31:28.393] Local evaluation: TRUE
[10:31:28.393] Environment: R_GlobalEnv
[10:31:28.393] Capture standard output: TRUE
[10:31:28.393] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:28.393] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:28.393] Packages: 1 packages (‘future.apply’)
[10:31:28.393] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:28.393] Resolved: FALSE
[10:31:28.393] Value: <not collected>
[10:31:28.393] Conditions captured: <none>
[10:31:28.393] Early signaling: FALSE
[10:31:28.393] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:28.393] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:28.405] Chunk #1 of 2 ... DONE
[10:31:28.405] Chunk #2 of 2 ...
[10:31:28.405]  - Finding globals in 'X' for chunk #2 ...
[10:31:28.405] getGlobalsAndPackages() ...
[10:31:28.405] Searching for globals...
[10:31:28.406] 
[10:31:28.406] Searching for globals ... DONE
[10:31:28.406] - globals: [0] <none>
[10:31:28.406] getGlobalsAndPackages() ... DONE
[10:31:28.406]    + additional globals found: [n=0] 
[10:31:28.406]    + additional namespaces needed: [n=0] 
[10:31:28.406]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:28.406]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:28.407]  - seeds: <none>
[10:31:28.407]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:28.407] getGlobalsAndPackages() ...
[10:31:28.407] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:28.407] Resolving globals: FALSE
[10:31:28.407] Tweak future expression to call with '...' arguments ...
[10:31:28.407] {
[10:31:28.407]     do.call(function(...) {
[10:31:28.407]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.407]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:28.407]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.407]             on.exit(options(oopts), add = TRUE)
[10:31:28.407]         }
[10:31:28.407]         {
[10:31:28.407]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:28.407]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.407]                 ...future.FUN(...future.X_jj, ...)
[10:31:28.407]             })
[10:31:28.407]         }
[10:31:28.407]     }, args = future.call.arguments)
[10:31:28.407] }
[10:31:28.407] Tweak future expression to call with '...' arguments ... DONE
[10:31:28.408] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:28.408] - packages: [1] ‘future.apply’
[10:31:28.408] getGlobalsAndPackages() ... DONE
[10:31:28.408] run() for ‘Future’ ...
[10:31:28.409] - state: ‘created’
[10:31:28.409] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:28.423] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:28.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:28.423]   - Field: ‘node’
[10:31:28.423]   - Field: ‘label’
[10:31:28.423]   - Field: ‘local’
[10:31:28.423]   - Field: ‘owner’
[10:31:28.423]   - Field: ‘envir’
[10:31:28.423]   - Field: ‘workers’
[10:31:28.423]   - Field: ‘packages’
[10:31:28.423]   - Field: ‘gc’
[10:31:28.424]   - Field: ‘conditions’
[10:31:28.424]   - Field: ‘persistent’
[10:31:28.424]   - Field: ‘expr’
[10:31:28.424]   - Field: ‘uuid’
[10:31:28.424]   - Field: ‘seed’
[10:31:28.424]   - Field: ‘version’
[10:31:28.424]   - Field: ‘result’
[10:31:28.424]   - Field: ‘asynchronous’
[10:31:28.424]   - Field: ‘calls’
[10:31:28.424]   - Field: ‘globals’
[10:31:28.424]   - Field: ‘stdout’
[10:31:28.425]   - Field: ‘earlySignal’
[10:31:28.425]   - Field: ‘lazy’
[10:31:28.425]   - Field: ‘state’
[10:31:28.425] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:28.425] - Launch lazy future ...
[10:31:28.425] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:28.425] Packages needed by future strategies (n = 0): <none>
[10:31:28.426] {
[10:31:28.426]     {
[10:31:28.426]         {
[10:31:28.426]             ...future.startTime <- base::Sys.time()
[10:31:28.426]             {
[10:31:28.426]                 {
[10:31:28.426]                   {
[10:31:28.426]                     {
[10:31:28.426]                       {
[10:31:28.426]                         base::local({
[10:31:28.426]                           has_future <- base::requireNamespace("future", 
[10:31:28.426]                             quietly = TRUE)
[10:31:28.426]                           if (has_future) {
[10:31:28.426]                             ns <- base::getNamespace("future")
[10:31:28.426]                             version <- ns[[".package"]][["version"]]
[10:31:28.426]                             if (is.null(version)) 
[10:31:28.426]                               version <- utils::packageVersion("future")
[10:31:28.426]                           }
[10:31:28.426]                           else {
[10:31:28.426]                             version <- NULL
[10:31:28.426]                           }
[10:31:28.426]                           if (!has_future || version < "1.8.0") {
[10:31:28.426]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:28.426]                               "", base::R.version$version.string), 
[10:31:28.426]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:28.426]                                 base::R.version$platform, 8 * 
[10:31:28.426]                                   base::.Machine$sizeof.pointer), 
[10:31:28.426]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:28.426]                                 "release", "version")], collapse = " "), 
[10:31:28.426]                               hostname = base::Sys.info()[["nodename"]])
[10:31:28.426]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:28.426]                               info)
[10:31:28.426]                             info <- base::paste(info, collapse = "; ")
[10:31:28.426]                             if (!has_future) {
[10:31:28.426]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:28.426]                                 info)
[10:31:28.426]                             }
[10:31:28.426]                             else {
[10:31:28.426]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:28.426]                                 info, version)
[10:31:28.426]                             }
[10:31:28.426]                             base::stop(msg)
[10:31:28.426]                           }
[10:31:28.426]                         })
[10:31:28.426]                       }
[10:31:28.426]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:28.426]                       base::options(mc.cores = 1L)
[10:31:28.426]                     }
[10:31:28.426]                     base::local({
[10:31:28.426]                       for (pkg in "future.apply") {
[10:31:28.426]                         base::loadNamespace(pkg)
[10:31:28.426]                         base::library(pkg, character.only = TRUE)
[10:31:28.426]                       }
[10:31:28.426]                     })
[10:31:28.426]                   }
[10:31:28.426]                   ...future.strategy.old <- future::plan("list")
[10:31:28.426]                   options(future.plan = NULL)
[10:31:28.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:28.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:28.426]                 }
[10:31:28.426]                 ...future.workdir <- getwd()
[10:31:28.426]             }
[10:31:28.426]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:28.426]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:28.426]         }
[10:31:28.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:28.426]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:28.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:28.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:28.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:28.426]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:28.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:28.426]             base::names(...future.oldOptions))
[10:31:28.426]     }
[10:31:28.426]     if (FALSE) {
[10:31:28.426]     }
[10:31:28.426]     else {
[10:31:28.426]         if (TRUE) {
[10:31:28.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:28.426]                 open = "w")
[10:31:28.426]         }
[10:31:28.426]         else {
[10:31:28.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:28.426]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:28.426]         }
[10:31:28.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:28.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:28.426]             base::sink(type = "output", split = FALSE)
[10:31:28.426]             base::close(...future.stdout)
[10:31:28.426]         }, add = TRUE)
[10:31:28.426]     }
[10:31:28.426]     ...future.frame <- base::sys.nframe()
[10:31:28.426]     ...future.conditions <- base::list()
[10:31:28.426]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:28.426]     if (FALSE) {
[10:31:28.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:28.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:28.426]     }
[10:31:28.426]     ...future.result <- base::tryCatch({
[10:31:28.426]         base::withCallingHandlers({
[10:31:28.426]             ...future.value <- base::withVisible(base::local({
[10:31:28.426]                 ...future.makeSendCondition <- base::local({
[10:31:28.426]                   sendCondition <- NULL
[10:31:28.426]                   function(frame = 1L) {
[10:31:28.426]                     if (is.function(sendCondition)) 
[10:31:28.426]                       return(sendCondition)
[10:31:28.426]                     ns <- getNamespace("parallel")
[10:31:28.426]                     if (exists("sendData", mode = "function", 
[10:31:28.426]                       envir = ns)) {
[10:31:28.426]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:28.426]                         envir = ns)
[10:31:28.426]                       envir <- sys.frame(frame)
[10:31:28.426]                       master <- NULL
[10:31:28.426]                       while (!identical(envir, .GlobalEnv) && 
[10:31:28.426]                         !identical(envir, emptyenv())) {
[10:31:28.426]                         if (exists("master", mode = "list", envir = envir, 
[10:31:28.426]                           inherits = FALSE)) {
[10:31:28.426]                           master <- get("master", mode = "list", 
[10:31:28.426]                             envir = envir, inherits = FALSE)
[10:31:28.426]                           if (inherits(master, c("SOCKnode", 
[10:31:28.426]                             "SOCK0node"))) {
[10:31:28.426]                             sendCondition <<- function(cond) {
[10:31:28.426]                               data <- list(type = "VALUE", value = cond, 
[10:31:28.426]                                 success = TRUE)
[10:31:28.426]                               parallel_sendData(master, data)
[10:31:28.426]                             }
[10:31:28.426]                             return(sendCondition)
[10:31:28.426]                           }
[10:31:28.426]                         }
[10:31:28.426]                         frame <- frame + 1L
[10:31:28.426]                         envir <- sys.frame(frame)
[10:31:28.426]                       }
[10:31:28.426]                     }
[10:31:28.426]                     sendCondition <<- function(cond) NULL
[10:31:28.426]                   }
[10:31:28.426]                 })
[10:31:28.426]                 withCallingHandlers({
[10:31:28.426]                   {
[10:31:28.426]                     do.call(function(...) {
[10:31:28.426]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.426]                       if (!identical(...future.globals.maxSize.org, 
[10:31:28.426]                         ...future.globals.maxSize)) {
[10:31:28.426]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.426]                         on.exit(options(oopts), add = TRUE)
[10:31:28.426]                       }
[10:31:28.426]                       {
[10:31:28.426]                         lapply(seq_along(...future.elements_ii), 
[10:31:28.426]                           FUN = function(jj) {
[10:31:28.426]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.426]                             ...future.FUN(...future.X_jj, ...)
[10:31:28.426]                           })
[10:31:28.426]                       }
[10:31:28.426]                     }, args = future.call.arguments)
[10:31:28.426]                   }
[10:31:28.426]                 }, immediateCondition = function(cond) {
[10:31:28.426]                   sendCondition <- ...future.makeSendCondition()
[10:31:28.426]                   sendCondition(cond)
[10:31:28.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.426]                   {
[10:31:28.426]                     inherits <- base::inherits
[10:31:28.426]                     invokeRestart <- base::invokeRestart
[10:31:28.426]                     is.null <- base::is.null
[10:31:28.426]                     muffled <- FALSE
[10:31:28.426]                     if (inherits(cond, "message")) {
[10:31:28.426]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:28.426]                       if (muffled) 
[10:31:28.426]                         invokeRestart("muffleMessage")
[10:31:28.426]                     }
[10:31:28.426]                     else if (inherits(cond, "warning")) {
[10:31:28.426]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:28.426]                       if (muffled) 
[10:31:28.426]                         invokeRestart("muffleWarning")
[10:31:28.426]                     }
[10:31:28.426]                     else if (inherits(cond, "condition")) {
[10:31:28.426]                       if (!is.null(pattern)) {
[10:31:28.426]                         computeRestarts <- base::computeRestarts
[10:31:28.426]                         grepl <- base::grepl
[10:31:28.426]                         restarts <- computeRestarts(cond)
[10:31:28.426]                         for (restart in restarts) {
[10:31:28.426]                           name <- restart$name
[10:31:28.426]                           if (is.null(name)) 
[10:31:28.426]                             next
[10:31:28.426]                           if (!grepl(pattern, name)) 
[10:31:28.426]                             next
[10:31:28.426]                           invokeRestart(restart)
[10:31:28.426]                           muffled <- TRUE
[10:31:28.426]                           break
[10:31:28.426]                         }
[10:31:28.426]                       }
[10:31:28.426]                     }
[10:31:28.426]                     invisible(muffled)
[10:31:28.426]                   }
[10:31:28.426]                   muffleCondition(cond)
[10:31:28.426]                 })
[10:31:28.426]             }))
[10:31:28.426]             future::FutureResult(value = ...future.value$value, 
[10:31:28.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:28.426]                   ...future.rng), globalenv = if (FALSE) 
[10:31:28.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:28.426]                     ...future.globalenv.names))
[10:31:28.426]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:28.426]         }, condition = base::local({
[10:31:28.426]             c <- base::c
[10:31:28.426]             inherits <- base::inherits
[10:31:28.426]             invokeRestart <- base::invokeRestart
[10:31:28.426]             length <- base::length
[10:31:28.426]             list <- base::list
[10:31:28.426]             seq.int <- base::seq.int
[10:31:28.426]             signalCondition <- base::signalCondition
[10:31:28.426]             sys.calls <- base::sys.calls
[10:31:28.426]             `[[` <- base::`[[`
[10:31:28.426]             `+` <- base::`+`
[10:31:28.426]             `<<-` <- base::`<<-`
[10:31:28.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:28.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:28.426]                   3L)]
[10:31:28.426]             }
[10:31:28.426]             function(cond) {
[10:31:28.426]                 is_error <- inherits(cond, "error")
[10:31:28.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:28.426]                   NULL)
[10:31:28.426]                 if (is_error) {
[10:31:28.426]                   sessionInformation <- function() {
[10:31:28.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:28.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:28.426]                       search = base::search(), system = base::Sys.info())
[10:31:28.426]                   }
[10:31:28.426]                   ...future.conditions[[length(...future.conditions) + 
[10:31:28.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:28.426]                     cond$call), session = sessionInformation(), 
[10:31:28.426]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:28.426]                   signalCondition(cond)
[10:31:28.426]                 }
[10:31:28.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:28.426]                 "immediateCondition"))) {
[10:31:28.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:28.426]                   ...future.conditions[[length(...future.conditions) + 
[10:31:28.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:28.426]                   if (TRUE && !signal) {
[10:31:28.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.426]                     {
[10:31:28.426]                       inherits <- base::inherits
[10:31:28.426]                       invokeRestart <- base::invokeRestart
[10:31:28.426]                       is.null <- base::is.null
[10:31:28.426]                       muffled <- FALSE
[10:31:28.426]                       if (inherits(cond, "message")) {
[10:31:28.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:28.426]                         if (muffled) 
[10:31:28.426]                           invokeRestart("muffleMessage")
[10:31:28.426]                       }
[10:31:28.426]                       else if (inherits(cond, "warning")) {
[10:31:28.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:28.426]                         if (muffled) 
[10:31:28.426]                           invokeRestart("muffleWarning")
[10:31:28.426]                       }
[10:31:28.426]                       else if (inherits(cond, "condition")) {
[10:31:28.426]                         if (!is.null(pattern)) {
[10:31:28.426]                           computeRestarts <- base::computeRestarts
[10:31:28.426]                           grepl <- base::grepl
[10:31:28.426]                           restarts <- computeRestarts(cond)
[10:31:28.426]                           for (restart in restarts) {
[10:31:28.426]                             name <- restart$name
[10:31:28.426]                             if (is.null(name)) 
[10:31:28.426]                               next
[10:31:28.426]                             if (!grepl(pattern, name)) 
[10:31:28.426]                               next
[10:31:28.426]                             invokeRestart(restart)
[10:31:28.426]                             muffled <- TRUE
[10:31:28.426]                             break
[10:31:28.426]                           }
[10:31:28.426]                         }
[10:31:28.426]                       }
[10:31:28.426]                       invisible(muffled)
[10:31:28.426]                     }
[10:31:28.426]                     muffleCondition(cond, pattern = "^muffle")
[10:31:28.426]                   }
[10:31:28.426]                 }
[10:31:28.426]                 else {
[10:31:28.426]                   if (TRUE) {
[10:31:28.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.426]                     {
[10:31:28.426]                       inherits <- base::inherits
[10:31:28.426]                       invokeRestart <- base::invokeRestart
[10:31:28.426]                       is.null <- base::is.null
[10:31:28.426]                       muffled <- FALSE
[10:31:28.426]                       if (inherits(cond, "message")) {
[10:31:28.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:28.426]                         if (muffled) 
[10:31:28.426]                           invokeRestart("muffleMessage")
[10:31:28.426]                       }
[10:31:28.426]                       else if (inherits(cond, "warning")) {
[10:31:28.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:28.426]                         if (muffled) 
[10:31:28.426]                           invokeRestart("muffleWarning")
[10:31:28.426]                       }
[10:31:28.426]                       else if (inherits(cond, "condition")) {
[10:31:28.426]                         if (!is.null(pattern)) {
[10:31:28.426]                           computeRestarts <- base::computeRestarts
[10:31:28.426]                           grepl <- base::grepl
[10:31:28.426]                           restarts <- computeRestarts(cond)
[10:31:28.426]                           for (restart in restarts) {
[10:31:28.426]                             name <- restart$name
[10:31:28.426]                             if (is.null(name)) 
[10:31:28.426]                               next
[10:31:28.426]                             if (!grepl(pattern, name)) 
[10:31:28.426]                               next
[10:31:28.426]                             invokeRestart(restart)
[10:31:28.426]                             muffled <- TRUE
[10:31:28.426]                             break
[10:31:28.426]                           }
[10:31:28.426]                         }
[10:31:28.426]                       }
[10:31:28.426]                       invisible(muffled)
[10:31:28.426]                     }
[10:31:28.426]                     muffleCondition(cond, pattern = "^muffle")
[10:31:28.426]                   }
[10:31:28.426]                 }
[10:31:28.426]             }
[10:31:28.426]         }))
[10:31:28.426]     }, error = function(ex) {
[10:31:28.426]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:28.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:28.426]                 ...future.rng), started = ...future.startTime, 
[10:31:28.426]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:28.426]             version = "1.8"), class = "FutureResult")
[10:31:28.426]     }, finally = {
[10:31:28.426]         if (!identical(...future.workdir, getwd())) 
[10:31:28.426]             setwd(...future.workdir)
[10:31:28.426]         {
[10:31:28.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:28.426]                 ...future.oldOptions$nwarnings <- NULL
[10:31:28.426]             }
[10:31:28.426]             base::options(...future.oldOptions)
[10:31:28.426]             if (.Platform$OS.type == "windows") {
[10:31:28.426]                 old_names <- names(...future.oldEnvVars)
[10:31:28.426]                 envs <- base::Sys.getenv()
[10:31:28.426]                 names <- names(envs)
[10:31:28.426]                 common <- intersect(names, old_names)
[10:31:28.426]                 added <- setdiff(names, old_names)
[10:31:28.426]                 removed <- setdiff(old_names, names)
[10:31:28.426]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:28.426]                   envs[common]]
[10:31:28.426]                 NAMES <- toupper(changed)
[10:31:28.426]                 args <- list()
[10:31:28.426]                 for (kk in seq_along(NAMES)) {
[10:31:28.426]                   name <- changed[[kk]]
[10:31:28.426]                   NAME <- NAMES[[kk]]
[10:31:28.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.426]                     next
[10:31:28.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:28.426]                 }
[10:31:28.426]                 NAMES <- toupper(added)
[10:31:28.426]                 for (kk in seq_along(NAMES)) {
[10:31:28.426]                   name <- added[[kk]]
[10:31:28.426]                   NAME <- NAMES[[kk]]
[10:31:28.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.426]                     next
[10:31:28.426]                   args[[name]] <- ""
[10:31:28.426]                 }
[10:31:28.426]                 NAMES <- toupper(removed)
[10:31:28.426]                 for (kk in seq_along(NAMES)) {
[10:31:28.426]                   name <- removed[[kk]]
[10:31:28.426]                   NAME <- NAMES[[kk]]
[10:31:28.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.426]                     next
[10:31:28.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:28.426]                 }
[10:31:28.426]                 if (length(args) > 0) 
[10:31:28.426]                   base::do.call(base::Sys.setenv, args = args)
[10:31:28.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:28.426]             }
[10:31:28.426]             else {
[10:31:28.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:28.426]             }
[10:31:28.426]             {
[10:31:28.426]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:28.426]                   0L) {
[10:31:28.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:28.426]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:28.426]                   base::options(opts)
[10:31:28.426]                 }
[10:31:28.426]                 {
[10:31:28.426]                   {
[10:31:28.426]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:28.426]                     NULL
[10:31:28.426]                   }
[10:31:28.426]                   options(future.plan = NULL)
[10:31:28.426]                   if (is.na(NA_character_)) 
[10:31:28.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:28.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:28.426]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:28.426]                     .init = FALSE)
[10:31:28.426]                 }
[10:31:28.426]             }
[10:31:28.426]         }
[10:31:28.426]     })
[10:31:28.426]     if (TRUE) {
[10:31:28.426]         base::sink(type = "output", split = FALSE)
[10:31:28.426]         if (TRUE) {
[10:31:28.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:28.426]         }
[10:31:28.426]         else {
[10:31:28.426]             ...future.result["stdout"] <- base::list(NULL)
[10:31:28.426]         }
[10:31:28.426]         base::close(...future.stdout)
[10:31:28.426]         ...future.stdout <- NULL
[10:31:28.426]     }
[10:31:28.426]     ...future.result$conditions <- ...future.conditions
[10:31:28.426]     ...future.result$finished <- base::Sys.time()
[10:31:28.426]     ...future.result
[10:31:28.426] }
[10:31:28.429] Exporting 11 global objects (103.08 KiB) to cluster node #2 ...
[10:31:28.429] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:31:28.473] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:31:28.473] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ...
[10:31:28.474] Exporting ‘x_FUN’ (10.95 KiB) to cluster node #2 ... DONE
[10:31:28.474] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:31:28.474] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:31:28.475] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:31:28.517] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:31:28.517] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:31:28.561] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:31:28.561] Exporting ‘dim’ (56 bytes) to cluster node #2 ...
[10:31:28.562] Exporting ‘dim’ (56 bytes) to cluster node #2 ... DONE
[10:31:28.562] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:31:28.562] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:31:28.563] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:31:28.563] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:31:28.563] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ...
[10:31:28.563] Exporting ‘...future.elements_ii’ (280 bytes) to cluster node #2 ... DONE
[10:31:28.564] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:28.564] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:28.564] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:28.564] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:28.565] Exporting 11 global objects (103.08 KiB) to cluster node #2 ... DONE
[10:31:28.565] MultisessionFuture started
[10:31:28.565] - Launch lazy future ... done
[10:31:28.565] run() for ‘MultisessionFuture’ ... done
[10:31:28.566] Created future:
[10:31:28.566] MultisessionFuture:
[10:31:28.566] Label: ‘future_vapply-2’
[10:31:28.566] Expression:
[10:31:28.566] {
[10:31:28.566]     do.call(function(...) {
[10:31:28.566]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.566]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:28.566]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.566]             on.exit(options(oopts), add = TRUE)
[10:31:28.566]         }
[10:31:28.566]         {
[10:31:28.566]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:28.566]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.566]                 ...future.FUN(...future.X_jj, ...)
[10:31:28.566]             })
[10:31:28.566]         }
[10:31:28.566]     }, args = future.call.arguments)
[10:31:28.566] }
[10:31:28.566] Lazy evaluation: FALSE
[10:31:28.566] Asynchronous evaluation: TRUE
[10:31:28.566] Local evaluation: TRUE
[10:31:28.566] Environment: R_GlobalEnv
[10:31:28.566] Capture standard output: TRUE
[10:31:28.566] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:28.566] Globals: 11 objects totaling 103.35 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 10.95 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:28.566] Packages: 1 packages (‘future.apply’)
[10:31:28.566] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:28.566] Resolved: FALSE
[10:31:28.566] Value: <not collected>
[10:31:28.566] Conditions captured: <none>
[10:31:28.566] Early signaling: FALSE
[10:31:28.566] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:28.566] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:28.577] Chunk #2 of 2 ... DONE
[10:31:28.578] Launching 2 futures (chunks) ... DONE
[10:31:28.578] Resolving 2 futures (chunks) ...
[10:31:28.578] resolve() on list ...
[10:31:28.578]  recursive: 0
[10:31:28.578]  length: 2
[10:31:28.578] 
[10:31:28.578] receiveMessageFromWorker() for ClusterFuture ...
[10:31:28.579] - Validating connection of MultisessionFuture
[10:31:28.579] - received message: FutureResult
[10:31:28.579] - Received FutureResult
[10:31:28.579] - Erased future from FutureRegistry
[10:31:28.579] result() for ClusterFuture ...
[10:31:28.579] - result already collected: FutureResult
[10:31:28.579] result() for ClusterFuture ... done
[10:31:28.579] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:28.579] Future #1
[10:31:28.580] result() for ClusterFuture ...
[10:31:28.580] - result already collected: FutureResult
[10:31:28.580] result() for ClusterFuture ... done
[10:31:28.580] result() for ClusterFuture ...
[10:31:28.580] - result already collected: FutureResult
[10:31:28.580] result() for ClusterFuture ... done
[10:31:28.580] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:28.580] - nx: 2
[10:31:28.580] - relay: TRUE
[10:31:28.580] - stdout: TRUE
[10:31:28.580] - signal: TRUE
[10:31:28.581] - resignal: FALSE
[10:31:28.581] - force: TRUE
[10:31:28.581] - relayed: [n=2] FALSE, FALSE
[10:31:28.581] - queued futures: [n=2] FALSE, FALSE
[10:31:28.581]  - until=1
[10:31:28.581]  - relaying element #1
[10:31:28.581] result() for ClusterFuture ...
[10:31:28.581] - result already collected: FutureResult
[10:31:28.581] result() for ClusterFuture ... done
[10:31:28.581] result() for ClusterFuture ...
[10:31:28.581] - result already collected: FutureResult
[10:31:28.582] result() for ClusterFuture ... done
[10:31:28.582] result() for ClusterFuture ...
[10:31:28.582] - result already collected: FutureResult
[10:31:28.582] result() for ClusterFuture ... done
[10:31:28.582] result() for ClusterFuture ...
[10:31:28.582] - result already collected: FutureResult
[10:31:28.582] result() for ClusterFuture ... done
[10:31:28.582] - relayed: [n=2] TRUE, FALSE
[10:31:28.582] - queued futures: [n=2] TRUE, FALSE
[10:31:28.582] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:28.582]  length: 1 (resolved future 1)
[10:31:28.610] receiveMessageFromWorker() for ClusterFuture ...
[10:31:28.611] - Validating connection of MultisessionFuture
[10:31:28.611] - received message: FutureResult
[10:31:28.611] - Received FutureResult
[10:31:28.611] - Erased future from FutureRegistry
[10:31:28.611] result() for ClusterFuture ...
[10:31:28.611] - result already collected: FutureResult
[10:31:28.611] result() for ClusterFuture ... done
[10:31:28.611] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:28.611] Future #2
[10:31:28.612] result() for ClusterFuture ...
[10:31:28.612] - result already collected: FutureResult
[10:31:28.612] result() for ClusterFuture ... done
[10:31:28.612] result() for ClusterFuture ...
[10:31:28.612] - result already collected: FutureResult
[10:31:28.612] result() for ClusterFuture ... done
[10:31:28.612] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:28.612] - nx: 2
[10:31:28.612] - relay: TRUE
[10:31:28.612] - stdout: TRUE
[10:31:28.612] - signal: TRUE
[10:31:28.612] - resignal: FALSE
[10:31:28.613] - force: TRUE
[10:31:28.613] - relayed: [n=2] TRUE, FALSE
[10:31:28.613] - queued futures: [n=2] TRUE, FALSE
[10:31:28.613]  - until=2
[10:31:28.613]  - relaying element #2
[10:31:28.613] result() for ClusterFuture ...
[10:31:28.613] - result already collected: FutureResult
[10:31:28.613] result() for ClusterFuture ... done
[10:31:28.613] result() for ClusterFuture ...
[10:31:28.613] - result already collected: FutureResult
[10:31:28.613] result() for ClusterFuture ... done
[10:31:28.614] result() for ClusterFuture ...
[10:31:28.614] - result already collected: FutureResult
[10:31:28.614] result() for ClusterFuture ... done
[10:31:28.614] result() for ClusterFuture ...
[10:31:28.614] - result already collected: FutureResult
[10:31:28.614] result() for ClusterFuture ... done
[10:31:28.614] - relayed: [n=2] TRUE, TRUE
[10:31:28.614] - queued futures: [n=2] TRUE, TRUE
[10:31:28.614] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:28.614]  length: 0 (resolved future 2)
[10:31:28.615] Relaying remaining futures
[10:31:28.615] signalConditionsASAP(NULL, pos=0) ...
[10:31:28.615] - nx: 2
[10:31:28.615] - relay: TRUE
[10:31:28.615] - stdout: TRUE
[10:31:28.615] - signal: TRUE
[10:31:28.615] - resignal: FALSE
[10:31:28.615] - force: TRUE
[10:31:28.615] - relayed: [n=2] TRUE, TRUE
[10:31:28.615] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:28.615] - relayed: [n=2] TRUE, TRUE
[10:31:28.615] - queued futures: [n=2] TRUE, TRUE
[10:31:28.616] signalConditionsASAP(NULL, pos=0) ... done
[10:31:28.616] resolve() on list ... DONE
[10:31:28.616] result() for ClusterFuture ...
[10:31:28.616] - result already collected: FutureResult
[10:31:28.616] result() for ClusterFuture ... done
[10:31:28.616] result() for ClusterFuture ...
[10:31:28.616] - result already collected: FutureResult
[10:31:28.616] result() for ClusterFuture ... done
[10:31:28.616] result() for ClusterFuture ...
[10:31:28.616] - result already collected: FutureResult
[10:31:28.616] result() for ClusterFuture ... done
[10:31:28.617] result() for ClusterFuture ...
[10:31:28.617] - result already collected: FutureResult
[10:31:28.617] result() for ClusterFuture ... done
[10:31:28.617]  - Number of value chunks collected: 2
[10:31:28.617] Resolving 2 futures (chunks) ... DONE
[10:31:28.617] Reducing values from 2 chunks ...
[10:31:28.617]  - Number of values collected after concatenation: 10
[10:31:28.617]  - Number of values expected: 10
[10:31:28.617] Reducing values from 2 chunks ... DONE
[10:31:28.617] future_lapply() ... DONE
 int [1:2, 1:2, 1:10] 1 1 1 1 2 2 2 2 3 3 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:2] "A" "B"
  ..$ : NULL
- From example(vapply) ...
[10:31:28.620] future_lapply() ...
[10:31:28.625] Number of chunks: 2
[10:31:28.625] getGlobalsAndPackagesXApply() ...
[10:31:28.625]  - future.globals: TRUE
[10:31:28.625] getGlobalsAndPackages() ...
[10:31:28.625] Searching for globals...
[10:31:28.629] - globals found: [17] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘UseMethod’
[10:31:28.629] Searching for globals ... DONE
[10:31:28.629] Resolving globals: FALSE
[10:31:28.630] The total size of the 7 globals is 93.29 KiB (95528 bytes)
[10:31:28.630] The total size of the 7 globals exported for future expression (‘FUN()’) is 93.29 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:28.630] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:28.630] - packages: [2] ‘stats’, ‘future.apply’
[10:31:28.631] getGlobalsAndPackages() ... DONE
[10:31:28.631]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:28.631]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:31:28.631] Finding globals ... DONE
[10:31:28.631]  - use_args: TRUE
[10:31:28.631]  - Getting '...' globals ...
[10:31:28.631] resolve() on list ...
[10:31:28.631]  recursive: 0
[10:31:28.632]  length: 1
[10:31:28.632]  elements: ‘...’
[10:31:28.632]  length: 0 (resolved future 1)
[10:31:28.632] resolve() on list ... DONE
[10:31:28.632]    - '...' content: [n=0] 
[10:31:28.632] List of 1
[10:31:28.632]  $ ...: list()
[10:31:28.632]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:28.632]  - attr(*, "where")=List of 1
[10:31:28.632]   ..$ ...:<environment: 0x55de882654d0> 
[10:31:28.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:28.632]  - attr(*, "resolved")= logi TRUE
[10:31:28.632]  - attr(*, "total_size")= num NA
[10:31:28.634]  - Getting '...' globals ... DONE
[10:31:28.635] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:28.635] List of 8
[10:31:28.635]  $ ...future.FUN:function (x, ...)  
[10:31:28.635]  $ x_FUN        :function (x, ...)  
[10:31:28.635]  $ times        : int 5
[10:31:28.635]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:28.635]  $ stop_if_not  :function (...)  
[10:31:28.635]  $ dim          : NULL
[10:31:28.635]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:28.635]  $ ...          : list()
[10:31:28.635]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:28.635]  - attr(*, "where")=List of 8
[10:31:28.635]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:28.635]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:28.635]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:28.635]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:28.635]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:28.635]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:28.635]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:28.635]   ..$ ...          :<environment: 0x55de882654d0> 
[10:31:28.635]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:28.635]  - attr(*, "resolved")= logi FALSE
[10:31:28.635]  - attr(*, "total_size")= num 95528
[10:31:28.640] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:31:28.640] getGlobalsAndPackagesXApply() ... DONE
[10:31:28.640] Number of futures (= number of chunks): 2
[10:31:28.640] Launching 2 futures (chunks) ...
[10:31:28.640] Chunk #1 of 2 ...
[10:31:28.641]  - Finding globals in 'X' for chunk #1 ...
[10:31:28.643] getGlobalsAndPackages() ...
[10:31:28.643] Searching for globals...
[10:31:28.643] 
[10:31:28.643] Searching for globals ... DONE
[10:31:28.643] - globals: [0] <none>
[10:31:28.643] getGlobalsAndPackages() ... DONE
[10:31:28.643]    + additional globals found: [n=0] 
[10:31:28.644]    + additional namespaces needed: [n=0] 
[10:31:28.644]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:28.644]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:28.644]  - seeds: <none>
[10:31:28.644]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:28.644] getGlobalsAndPackages() ...
[10:31:28.644] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:28.644] Resolving globals: FALSE
[10:31:28.644] Tweak future expression to call with '...' arguments ...
[10:31:28.644] {
[10:31:28.644]     do.call(function(...) {
[10:31:28.644]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.644]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:28.644]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.644]             on.exit(options(oopts), add = TRUE)
[10:31:28.644]         }
[10:31:28.644]         {
[10:31:28.644]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:28.644]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.644]                 ...future.FUN(...future.X_jj, ...)
[10:31:28.644]             })
[10:31:28.644]         }
[10:31:28.644]     }, args = future.call.arguments)
[10:31:28.644] }
[10:31:28.645] Tweak future expression to call with '...' arguments ... DONE
[10:31:28.645] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:28.645] - packages: [2] ‘stats’, ‘future.apply’
[10:31:28.646] getGlobalsAndPackages() ... DONE
[10:31:28.646] run() for ‘Future’ ...
[10:31:28.646] - state: ‘created’
[10:31:28.646] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:28.660] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:28.660] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:28.661]   - Field: ‘node’
[10:31:28.661]   - Field: ‘label’
[10:31:28.661]   - Field: ‘local’
[10:31:28.661]   - Field: ‘owner’
[10:31:28.661]   - Field: ‘envir’
[10:31:28.661]   - Field: ‘workers’
[10:31:28.661]   - Field: ‘packages’
[10:31:28.661]   - Field: ‘gc’
[10:31:28.661]   - Field: ‘conditions’
[10:31:28.662]   - Field: ‘persistent’
[10:31:28.662]   - Field: ‘expr’
[10:31:28.662]   - Field: ‘uuid’
[10:31:28.662]   - Field: ‘seed’
[10:31:28.662]   - Field: ‘version’
[10:31:28.662]   - Field: ‘result’
[10:31:28.662]   - Field: ‘asynchronous’
[10:31:28.662]   - Field: ‘calls’
[10:31:28.662]   - Field: ‘globals’
[10:31:28.662]   - Field: ‘stdout’
[10:31:28.662]   - Field: ‘earlySignal’
[10:31:28.662]   - Field: ‘lazy’
[10:31:28.663]   - Field: ‘state’
[10:31:28.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:28.663] - Launch lazy future ...
[10:31:28.663] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:31:28.663] Packages needed by future strategies (n = 0): <none>
[10:31:28.664] {
[10:31:28.664]     {
[10:31:28.664]         {
[10:31:28.664]             ...future.startTime <- base::Sys.time()
[10:31:28.664]             {
[10:31:28.664]                 {
[10:31:28.664]                   {
[10:31:28.664]                     {
[10:31:28.664]                       {
[10:31:28.664]                         base::local({
[10:31:28.664]                           has_future <- base::requireNamespace("future", 
[10:31:28.664]                             quietly = TRUE)
[10:31:28.664]                           if (has_future) {
[10:31:28.664]                             ns <- base::getNamespace("future")
[10:31:28.664]                             version <- ns[[".package"]][["version"]]
[10:31:28.664]                             if (is.null(version)) 
[10:31:28.664]                               version <- utils::packageVersion("future")
[10:31:28.664]                           }
[10:31:28.664]                           else {
[10:31:28.664]                             version <- NULL
[10:31:28.664]                           }
[10:31:28.664]                           if (!has_future || version < "1.8.0") {
[10:31:28.664]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:28.664]                               "", base::R.version$version.string), 
[10:31:28.664]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:28.664]                                 base::R.version$platform, 8 * 
[10:31:28.664]                                   base::.Machine$sizeof.pointer), 
[10:31:28.664]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:28.664]                                 "release", "version")], collapse = " "), 
[10:31:28.664]                               hostname = base::Sys.info()[["nodename"]])
[10:31:28.664]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:28.664]                               info)
[10:31:28.664]                             info <- base::paste(info, collapse = "; ")
[10:31:28.664]                             if (!has_future) {
[10:31:28.664]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:28.664]                                 info)
[10:31:28.664]                             }
[10:31:28.664]                             else {
[10:31:28.664]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:28.664]                                 info, version)
[10:31:28.664]                             }
[10:31:28.664]                             base::stop(msg)
[10:31:28.664]                           }
[10:31:28.664]                         })
[10:31:28.664]                       }
[10:31:28.664]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:28.664]                       base::options(mc.cores = 1L)
[10:31:28.664]                     }
[10:31:28.664]                     base::local({
[10:31:28.664]                       for (pkg in c("stats", "future.apply")) {
[10:31:28.664]                         base::loadNamespace(pkg)
[10:31:28.664]                         base::library(pkg, character.only = TRUE)
[10:31:28.664]                       }
[10:31:28.664]                     })
[10:31:28.664]                   }
[10:31:28.664]                   ...future.strategy.old <- future::plan("list")
[10:31:28.664]                   options(future.plan = NULL)
[10:31:28.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:28.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:28.664]                 }
[10:31:28.664]                 ...future.workdir <- getwd()
[10:31:28.664]             }
[10:31:28.664]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:28.664]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:28.664]         }
[10:31:28.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:28.664]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:28.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:28.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:28.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:28.664]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:28.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:28.664]             base::names(...future.oldOptions))
[10:31:28.664]     }
[10:31:28.664]     if (FALSE) {
[10:31:28.664]     }
[10:31:28.664]     else {
[10:31:28.664]         if (TRUE) {
[10:31:28.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:28.664]                 open = "w")
[10:31:28.664]         }
[10:31:28.664]         else {
[10:31:28.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:28.664]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:28.664]         }
[10:31:28.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:28.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:28.664]             base::sink(type = "output", split = FALSE)
[10:31:28.664]             base::close(...future.stdout)
[10:31:28.664]         }, add = TRUE)
[10:31:28.664]     }
[10:31:28.664]     ...future.frame <- base::sys.nframe()
[10:31:28.664]     ...future.conditions <- base::list()
[10:31:28.664]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:28.664]     if (FALSE) {
[10:31:28.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:28.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:28.664]     }
[10:31:28.664]     ...future.result <- base::tryCatch({
[10:31:28.664]         base::withCallingHandlers({
[10:31:28.664]             ...future.value <- base::withVisible(base::local({
[10:31:28.664]                 ...future.makeSendCondition <- base::local({
[10:31:28.664]                   sendCondition <- NULL
[10:31:28.664]                   function(frame = 1L) {
[10:31:28.664]                     if (is.function(sendCondition)) 
[10:31:28.664]                       return(sendCondition)
[10:31:28.664]                     ns <- getNamespace("parallel")
[10:31:28.664]                     if (exists("sendData", mode = "function", 
[10:31:28.664]                       envir = ns)) {
[10:31:28.664]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:28.664]                         envir = ns)
[10:31:28.664]                       envir <- sys.frame(frame)
[10:31:28.664]                       master <- NULL
[10:31:28.664]                       while (!identical(envir, .GlobalEnv) && 
[10:31:28.664]                         !identical(envir, emptyenv())) {
[10:31:28.664]                         if (exists("master", mode = "list", envir = envir, 
[10:31:28.664]                           inherits = FALSE)) {
[10:31:28.664]                           master <- get("master", mode = "list", 
[10:31:28.664]                             envir = envir, inherits = FALSE)
[10:31:28.664]                           if (inherits(master, c("SOCKnode", 
[10:31:28.664]                             "SOCK0node"))) {
[10:31:28.664]                             sendCondition <<- function(cond) {
[10:31:28.664]                               data <- list(type = "VALUE", value = cond, 
[10:31:28.664]                                 success = TRUE)
[10:31:28.664]                               parallel_sendData(master, data)
[10:31:28.664]                             }
[10:31:28.664]                             return(sendCondition)
[10:31:28.664]                           }
[10:31:28.664]                         }
[10:31:28.664]                         frame <- frame + 1L
[10:31:28.664]                         envir <- sys.frame(frame)
[10:31:28.664]                       }
[10:31:28.664]                     }
[10:31:28.664]                     sendCondition <<- function(cond) NULL
[10:31:28.664]                   }
[10:31:28.664]                 })
[10:31:28.664]                 withCallingHandlers({
[10:31:28.664]                   {
[10:31:28.664]                     do.call(function(...) {
[10:31:28.664]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.664]                       if (!identical(...future.globals.maxSize.org, 
[10:31:28.664]                         ...future.globals.maxSize)) {
[10:31:28.664]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.664]                         on.exit(options(oopts), add = TRUE)
[10:31:28.664]                       }
[10:31:28.664]                       {
[10:31:28.664]                         lapply(seq_along(...future.elements_ii), 
[10:31:28.664]                           FUN = function(jj) {
[10:31:28.664]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.664]                             ...future.FUN(...future.X_jj, ...)
[10:31:28.664]                           })
[10:31:28.664]                       }
[10:31:28.664]                     }, args = future.call.arguments)
[10:31:28.664]                   }
[10:31:28.664]                 }, immediateCondition = function(cond) {
[10:31:28.664]                   sendCondition <- ...future.makeSendCondition()
[10:31:28.664]                   sendCondition(cond)
[10:31:28.664]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.664]                   {
[10:31:28.664]                     inherits <- base::inherits
[10:31:28.664]                     invokeRestart <- base::invokeRestart
[10:31:28.664]                     is.null <- base::is.null
[10:31:28.664]                     muffled <- FALSE
[10:31:28.664]                     if (inherits(cond, "message")) {
[10:31:28.664]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:28.664]                       if (muffled) 
[10:31:28.664]                         invokeRestart("muffleMessage")
[10:31:28.664]                     }
[10:31:28.664]                     else if (inherits(cond, "warning")) {
[10:31:28.664]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:28.664]                       if (muffled) 
[10:31:28.664]                         invokeRestart("muffleWarning")
[10:31:28.664]                     }
[10:31:28.664]                     else if (inherits(cond, "condition")) {
[10:31:28.664]                       if (!is.null(pattern)) {
[10:31:28.664]                         computeRestarts <- base::computeRestarts
[10:31:28.664]                         grepl <- base::grepl
[10:31:28.664]                         restarts <- computeRestarts(cond)
[10:31:28.664]                         for (restart in restarts) {
[10:31:28.664]                           name <- restart$name
[10:31:28.664]                           if (is.null(name)) 
[10:31:28.664]                             next
[10:31:28.664]                           if (!grepl(pattern, name)) 
[10:31:28.664]                             next
[10:31:28.664]                           invokeRestart(restart)
[10:31:28.664]                           muffled <- TRUE
[10:31:28.664]                           break
[10:31:28.664]                         }
[10:31:28.664]                       }
[10:31:28.664]                     }
[10:31:28.664]                     invisible(muffled)
[10:31:28.664]                   }
[10:31:28.664]                   muffleCondition(cond)
[10:31:28.664]                 })
[10:31:28.664]             }))
[10:31:28.664]             future::FutureResult(value = ...future.value$value, 
[10:31:28.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:28.664]                   ...future.rng), globalenv = if (FALSE) 
[10:31:28.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:28.664]                     ...future.globalenv.names))
[10:31:28.664]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:28.664]         }, condition = base::local({
[10:31:28.664]             c <- base::c
[10:31:28.664]             inherits <- base::inherits
[10:31:28.664]             invokeRestart <- base::invokeRestart
[10:31:28.664]             length <- base::length
[10:31:28.664]             list <- base::list
[10:31:28.664]             seq.int <- base::seq.int
[10:31:28.664]             signalCondition <- base::signalCondition
[10:31:28.664]             sys.calls <- base::sys.calls
[10:31:28.664]             `[[` <- base::`[[`
[10:31:28.664]             `+` <- base::`+`
[10:31:28.664]             `<<-` <- base::`<<-`
[10:31:28.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:28.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:28.664]                   3L)]
[10:31:28.664]             }
[10:31:28.664]             function(cond) {
[10:31:28.664]                 is_error <- inherits(cond, "error")
[10:31:28.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:28.664]                   NULL)
[10:31:28.664]                 if (is_error) {
[10:31:28.664]                   sessionInformation <- function() {
[10:31:28.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:28.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:28.664]                       search = base::search(), system = base::Sys.info())
[10:31:28.664]                   }
[10:31:28.664]                   ...future.conditions[[length(...future.conditions) + 
[10:31:28.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:28.664]                     cond$call), session = sessionInformation(), 
[10:31:28.664]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:28.664]                   signalCondition(cond)
[10:31:28.664]                 }
[10:31:28.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:28.664]                 "immediateCondition"))) {
[10:31:28.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:28.664]                   ...future.conditions[[length(...future.conditions) + 
[10:31:28.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:28.664]                   if (TRUE && !signal) {
[10:31:28.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.664]                     {
[10:31:28.664]                       inherits <- base::inherits
[10:31:28.664]                       invokeRestart <- base::invokeRestart
[10:31:28.664]                       is.null <- base::is.null
[10:31:28.664]                       muffled <- FALSE
[10:31:28.664]                       if (inherits(cond, "message")) {
[10:31:28.664]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:28.664]                         if (muffled) 
[10:31:28.664]                           invokeRestart("muffleMessage")
[10:31:28.664]                       }
[10:31:28.664]                       else if (inherits(cond, "warning")) {
[10:31:28.664]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:28.664]                         if (muffled) 
[10:31:28.664]                           invokeRestart("muffleWarning")
[10:31:28.664]                       }
[10:31:28.664]                       else if (inherits(cond, "condition")) {
[10:31:28.664]                         if (!is.null(pattern)) {
[10:31:28.664]                           computeRestarts <- base::computeRestarts
[10:31:28.664]                           grepl <- base::grepl
[10:31:28.664]                           restarts <- computeRestarts(cond)
[10:31:28.664]                           for (restart in restarts) {
[10:31:28.664]                             name <- restart$name
[10:31:28.664]                             if (is.null(name)) 
[10:31:28.664]                               next
[10:31:28.664]                             if (!grepl(pattern, name)) 
[10:31:28.664]                               next
[10:31:28.664]                             invokeRestart(restart)
[10:31:28.664]                             muffled <- TRUE
[10:31:28.664]                             break
[10:31:28.664]                           }
[10:31:28.664]                         }
[10:31:28.664]                       }
[10:31:28.664]                       invisible(muffled)
[10:31:28.664]                     }
[10:31:28.664]                     muffleCondition(cond, pattern = "^muffle")
[10:31:28.664]                   }
[10:31:28.664]                 }
[10:31:28.664]                 else {
[10:31:28.664]                   if (TRUE) {
[10:31:28.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.664]                     {
[10:31:28.664]                       inherits <- base::inherits
[10:31:28.664]                       invokeRestart <- base::invokeRestart
[10:31:28.664]                       is.null <- base::is.null
[10:31:28.664]                       muffled <- FALSE
[10:31:28.664]                       if (inherits(cond, "message")) {
[10:31:28.664]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:28.664]                         if (muffled) 
[10:31:28.664]                           invokeRestart("muffleMessage")
[10:31:28.664]                       }
[10:31:28.664]                       else if (inherits(cond, "warning")) {
[10:31:28.664]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:28.664]                         if (muffled) 
[10:31:28.664]                           invokeRestart("muffleWarning")
[10:31:28.664]                       }
[10:31:28.664]                       else if (inherits(cond, "condition")) {
[10:31:28.664]                         if (!is.null(pattern)) {
[10:31:28.664]                           computeRestarts <- base::computeRestarts
[10:31:28.664]                           grepl <- base::grepl
[10:31:28.664]                           restarts <- computeRestarts(cond)
[10:31:28.664]                           for (restart in restarts) {
[10:31:28.664]                             name <- restart$name
[10:31:28.664]                             if (is.null(name)) 
[10:31:28.664]                               next
[10:31:28.664]                             if (!grepl(pattern, name)) 
[10:31:28.664]                               next
[10:31:28.664]                             invokeRestart(restart)
[10:31:28.664]                             muffled <- TRUE
[10:31:28.664]                             break
[10:31:28.664]                           }
[10:31:28.664]                         }
[10:31:28.664]                       }
[10:31:28.664]                       invisible(muffled)
[10:31:28.664]                     }
[10:31:28.664]                     muffleCondition(cond, pattern = "^muffle")
[10:31:28.664]                   }
[10:31:28.664]                 }
[10:31:28.664]             }
[10:31:28.664]         }))
[10:31:28.664]     }, error = function(ex) {
[10:31:28.664]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:28.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:28.664]                 ...future.rng), started = ...future.startTime, 
[10:31:28.664]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:28.664]             version = "1.8"), class = "FutureResult")
[10:31:28.664]     }, finally = {
[10:31:28.664]         if (!identical(...future.workdir, getwd())) 
[10:31:28.664]             setwd(...future.workdir)
[10:31:28.664]         {
[10:31:28.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:28.664]                 ...future.oldOptions$nwarnings <- NULL
[10:31:28.664]             }
[10:31:28.664]             base::options(...future.oldOptions)
[10:31:28.664]             if (.Platform$OS.type == "windows") {
[10:31:28.664]                 old_names <- names(...future.oldEnvVars)
[10:31:28.664]                 envs <- base::Sys.getenv()
[10:31:28.664]                 names <- names(envs)
[10:31:28.664]                 common <- intersect(names, old_names)
[10:31:28.664]                 added <- setdiff(names, old_names)
[10:31:28.664]                 removed <- setdiff(old_names, names)
[10:31:28.664]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:28.664]                   envs[common]]
[10:31:28.664]                 NAMES <- toupper(changed)
[10:31:28.664]                 args <- list()
[10:31:28.664]                 for (kk in seq_along(NAMES)) {
[10:31:28.664]                   name <- changed[[kk]]
[10:31:28.664]                   NAME <- NAMES[[kk]]
[10:31:28.664]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.664]                     next
[10:31:28.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:28.664]                 }
[10:31:28.664]                 NAMES <- toupper(added)
[10:31:28.664]                 for (kk in seq_along(NAMES)) {
[10:31:28.664]                   name <- added[[kk]]
[10:31:28.664]                   NAME <- NAMES[[kk]]
[10:31:28.664]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.664]                     next
[10:31:28.664]                   args[[name]] <- ""
[10:31:28.664]                 }
[10:31:28.664]                 NAMES <- toupper(removed)
[10:31:28.664]                 for (kk in seq_along(NAMES)) {
[10:31:28.664]                   name <- removed[[kk]]
[10:31:28.664]                   NAME <- NAMES[[kk]]
[10:31:28.664]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.664]                     next
[10:31:28.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:28.664]                 }
[10:31:28.664]                 if (length(args) > 0) 
[10:31:28.664]                   base::do.call(base::Sys.setenv, args = args)
[10:31:28.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:28.664]             }
[10:31:28.664]             else {
[10:31:28.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:28.664]             }
[10:31:28.664]             {
[10:31:28.664]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:28.664]                   0L) {
[10:31:28.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:28.664]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:28.664]                   base::options(opts)
[10:31:28.664]                 }
[10:31:28.664]                 {
[10:31:28.664]                   {
[10:31:28.664]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:28.664]                     NULL
[10:31:28.664]                   }
[10:31:28.664]                   options(future.plan = NULL)
[10:31:28.664]                   if (is.na(NA_character_)) 
[10:31:28.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:28.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:28.664]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:28.664]                     .init = FALSE)
[10:31:28.664]                 }
[10:31:28.664]             }
[10:31:28.664]         }
[10:31:28.664]     })
[10:31:28.664]     if (TRUE) {
[10:31:28.664]         base::sink(type = "output", split = FALSE)
[10:31:28.664]         if (TRUE) {
[10:31:28.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:28.664]         }
[10:31:28.664]         else {
[10:31:28.664]             ...future.result["stdout"] <- base::list(NULL)
[10:31:28.664]         }
[10:31:28.664]         base::close(...future.stdout)
[10:31:28.664]         ...future.stdout <- NULL
[10:31:28.664]     }
[10:31:28.664]     ...future.result$conditions <- ...future.conditions
[10:31:28.664]     ...future.result$finished <- base::Sys.time()
[10:31:28.664]     ...future.result
[10:31:28.664] }
[10:31:28.666] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[10:31:28.667] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:28.709] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:28.709] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[10:31:28.710] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[10:31:28.710] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:28.710] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:28.710] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:28.753] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:28.753] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:28.797] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:28.797] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:28.798] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:28.798] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:31:28.798] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:31:28.798] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:28.799] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:28.799] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ...
[10:31:28.799] Exporting ‘...future.elements_ii’ (96 bytes) to cluster node #1 ... DONE
[10:31:28.799] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:28.800] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:28.800] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:28.800] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:28.800] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[10:31:28.801] MultisessionFuture started
[10:31:28.801] - Launch lazy future ... done
[10:31:28.801] run() for ‘MultisessionFuture’ ... done
[10:31:28.801] Created future:
[10:31:28.805] receiveMessageFromWorker() for ClusterFuture ...
[10:31:28.805] - Validating connection of MultisessionFuture
[10:31:28.805] - received message: FutureResult
[10:31:28.805] - Received FutureResult
[10:31:28.805] - Erased future from FutureRegistry
[10:31:28.805] result() for ClusterFuture ...
[10:31:28.806] - result already collected: FutureResult
[10:31:28.806] result() for ClusterFuture ... done
[10:31:28.806] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:28.801] MultisessionFuture:
[10:31:28.801] Label: ‘future_vapply-1’
[10:31:28.801] Expression:
[10:31:28.801] {
[10:31:28.801]     do.call(function(...) {
[10:31:28.801]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.801]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:28.801]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.801]             on.exit(options(oopts), add = TRUE)
[10:31:28.801]         }
[10:31:28.801]         {
[10:31:28.801]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:28.801]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.801]                 ...future.FUN(...future.X_jj, ...)
[10:31:28.801]             })
[10:31:28.801]         }
[10:31:28.801]     }, args = future.call.arguments)
[10:31:28.801] }
[10:31:28.801] Lazy evaluation: FALSE
[10:31:28.801] Asynchronous evaluation: TRUE
[10:31:28.801] Local evaluation: TRUE
[10:31:28.801] Environment: R_GlobalEnv
[10:31:28.801] Capture standard output: TRUE
[10:31:28.801] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:28.801] Globals: 11 objects totaling 93.38 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:28.801] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:31:28.801] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:28.801] Resolved: TRUE
[10:31:28.801] Value: <not collected>
[10:31:28.801] Conditions captured: <none>
[10:31:28.801] Early signaling: FALSE
[10:31:28.801] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:28.801] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:28.806] Chunk #1 of 2 ... DONE
[10:31:28.806] Chunk #2 of 2 ...
[10:31:28.806]  - Finding globals in 'X' for chunk #2 ...
[10:31:28.806] getGlobalsAndPackages() ...
[10:31:28.806] Searching for globals...
[10:31:28.807] 
[10:31:28.807] Searching for globals ... DONE
[10:31:28.807] - globals: [0] <none>
[10:31:28.807] getGlobalsAndPackages() ... DONE
[10:31:28.807]    + additional globals found: [n=0] 
[10:31:28.807]    + additional namespaces needed: [n=0] 
[10:31:28.807]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:28.807]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:28.807]  - seeds: <none>
[10:31:28.808]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:28.808] getGlobalsAndPackages() ...
[10:31:28.808] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:28.808] Resolving globals: FALSE
[10:31:28.808] Tweak future expression to call with '...' arguments ...
[10:31:28.808] {
[10:31:28.808]     do.call(function(...) {
[10:31:28.808]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.808]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:28.808]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.808]             on.exit(options(oopts), add = TRUE)
[10:31:28.808]         }
[10:31:28.808]         {
[10:31:28.808]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:28.808]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.808]                 ...future.FUN(...future.X_jj, ...)
[10:31:28.808]             })
[10:31:28.808]         }
[10:31:28.808]     }, args = future.call.arguments)
[10:31:28.808] }
[10:31:28.808] Tweak future expression to call with '...' arguments ... DONE
[10:31:28.809] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:28.809] - packages: [2] ‘stats’, ‘future.apply’
[10:31:28.809] getGlobalsAndPackages() ... DONE
[10:31:28.809] run() for ‘Future’ ...
[10:31:28.810] - state: ‘created’
[10:31:28.810] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:28.824] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:28.824] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:28.824]   - Field: ‘node’
[10:31:28.824]   - Field: ‘label’
[10:31:28.824]   - Field: ‘local’
[10:31:28.824]   - Field: ‘owner’
[10:31:28.824]   - Field: ‘envir’
[10:31:28.824]   - Field: ‘workers’
[10:31:28.824]   - Field: ‘packages’
[10:31:28.825]   - Field: ‘gc’
[10:31:28.825]   - Field: ‘conditions’
[10:31:28.825]   - Field: ‘persistent’
[10:31:28.825]   - Field: ‘expr’
[10:31:28.825]   - Field: ‘uuid’
[10:31:28.825]   - Field: ‘seed’
[10:31:28.825]   - Field: ‘version’
[10:31:28.825]   - Field: ‘result’
[10:31:28.825]   - Field: ‘asynchronous’
[10:31:28.825]   - Field: ‘calls’
[10:31:28.826]   - Field: ‘globals’
[10:31:28.826]   - Field: ‘stdout’
[10:31:28.826]   - Field: ‘earlySignal’
[10:31:28.826]   - Field: ‘lazy’
[10:31:28.826]   - Field: ‘state’
[10:31:28.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:28.826] - Launch lazy future ...
[10:31:28.826] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:31:28.826] Packages needed by future strategies (n = 0): <none>
[10:31:28.827] {
[10:31:28.827]     {
[10:31:28.827]         {
[10:31:28.827]             ...future.startTime <- base::Sys.time()
[10:31:28.827]             {
[10:31:28.827]                 {
[10:31:28.827]                   {
[10:31:28.827]                     {
[10:31:28.827]                       {
[10:31:28.827]                         base::local({
[10:31:28.827]                           has_future <- base::requireNamespace("future", 
[10:31:28.827]                             quietly = TRUE)
[10:31:28.827]                           if (has_future) {
[10:31:28.827]                             ns <- base::getNamespace("future")
[10:31:28.827]                             version <- ns[[".package"]][["version"]]
[10:31:28.827]                             if (is.null(version)) 
[10:31:28.827]                               version <- utils::packageVersion("future")
[10:31:28.827]                           }
[10:31:28.827]                           else {
[10:31:28.827]                             version <- NULL
[10:31:28.827]                           }
[10:31:28.827]                           if (!has_future || version < "1.8.0") {
[10:31:28.827]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:28.827]                               "", base::R.version$version.string), 
[10:31:28.827]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:28.827]                                 base::R.version$platform, 8 * 
[10:31:28.827]                                   base::.Machine$sizeof.pointer), 
[10:31:28.827]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:28.827]                                 "release", "version")], collapse = " "), 
[10:31:28.827]                               hostname = base::Sys.info()[["nodename"]])
[10:31:28.827]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:28.827]                               info)
[10:31:28.827]                             info <- base::paste(info, collapse = "; ")
[10:31:28.827]                             if (!has_future) {
[10:31:28.827]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:28.827]                                 info)
[10:31:28.827]                             }
[10:31:28.827]                             else {
[10:31:28.827]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:28.827]                                 info, version)
[10:31:28.827]                             }
[10:31:28.827]                             base::stop(msg)
[10:31:28.827]                           }
[10:31:28.827]                         })
[10:31:28.827]                       }
[10:31:28.827]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:28.827]                       base::options(mc.cores = 1L)
[10:31:28.827]                     }
[10:31:28.827]                     base::local({
[10:31:28.827]                       for (pkg in c("stats", "future.apply")) {
[10:31:28.827]                         base::loadNamespace(pkg)
[10:31:28.827]                         base::library(pkg, character.only = TRUE)
[10:31:28.827]                       }
[10:31:28.827]                     })
[10:31:28.827]                   }
[10:31:28.827]                   ...future.strategy.old <- future::plan("list")
[10:31:28.827]                   options(future.plan = NULL)
[10:31:28.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:28.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:28.827]                 }
[10:31:28.827]                 ...future.workdir <- getwd()
[10:31:28.827]             }
[10:31:28.827]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:28.827]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:28.827]         }
[10:31:28.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:28.827]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:28.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:28.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:28.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:28.827]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:28.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:28.827]             base::names(...future.oldOptions))
[10:31:28.827]     }
[10:31:28.827]     if (FALSE) {
[10:31:28.827]     }
[10:31:28.827]     else {
[10:31:28.827]         if (TRUE) {
[10:31:28.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:28.827]                 open = "w")
[10:31:28.827]         }
[10:31:28.827]         else {
[10:31:28.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:28.827]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:28.827]         }
[10:31:28.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:28.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:28.827]             base::sink(type = "output", split = FALSE)
[10:31:28.827]             base::close(...future.stdout)
[10:31:28.827]         }, add = TRUE)
[10:31:28.827]     }
[10:31:28.827]     ...future.frame <- base::sys.nframe()
[10:31:28.827]     ...future.conditions <- base::list()
[10:31:28.827]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:28.827]     if (FALSE) {
[10:31:28.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:28.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:28.827]     }
[10:31:28.827]     ...future.result <- base::tryCatch({
[10:31:28.827]         base::withCallingHandlers({
[10:31:28.827]             ...future.value <- base::withVisible(base::local({
[10:31:28.827]                 ...future.makeSendCondition <- base::local({
[10:31:28.827]                   sendCondition <- NULL
[10:31:28.827]                   function(frame = 1L) {
[10:31:28.827]                     if (is.function(sendCondition)) 
[10:31:28.827]                       return(sendCondition)
[10:31:28.827]                     ns <- getNamespace("parallel")
[10:31:28.827]                     if (exists("sendData", mode = "function", 
[10:31:28.827]                       envir = ns)) {
[10:31:28.827]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:28.827]                         envir = ns)
[10:31:28.827]                       envir <- sys.frame(frame)
[10:31:28.827]                       master <- NULL
[10:31:28.827]                       while (!identical(envir, .GlobalEnv) && 
[10:31:28.827]                         !identical(envir, emptyenv())) {
[10:31:28.827]                         if (exists("master", mode = "list", envir = envir, 
[10:31:28.827]                           inherits = FALSE)) {
[10:31:28.827]                           master <- get("master", mode = "list", 
[10:31:28.827]                             envir = envir, inherits = FALSE)
[10:31:28.827]                           if (inherits(master, c("SOCKnode", 
[10:31:28.827]                             "SOCK0node"))) {
[10:31:28.827]                             sendCondition <<- function(cond) {
[10:31:28.827]                               data <- list(type = "VALUE", value = cond, 
[10:31:28.827]                                 success = TRUE)
[10:31:28.827]                               parallel_sendData(master, data)
[10:31:28.827]                             }
[10:31:28.827]                             return(sendCondition)
[10:31:28.827]                           }
[10:31:28.827]                         }
[10:31:28.827]                         frame <- frame + 1L
[10:31:28.827]                         envir <- sys.frame(frame)
[10:31:28.827]                       }
[10:31:28.827]                     }
[10:31:28.827]                     sendCondition <<- function(cond) NULL
[10:31:28.827]                   }
[10:31:28.827]                 })
[10:31:28.827]                 withCallingHandlers({
[10:31:28.827]                   {
[10:31:28.827]                     do.call(function(...) {
[10:31:28.827]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.827]                       if (!identical(...future.globals.maxSize.org, 
[10:31:28.827]                         ...future.globals.maxSize)) {
[10:31:28.827]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.827]                         on.exit(options(oopts), add = TRUE)
[10:31:28.827]                       }
[10:31:28.827]                       {
[10:31:28.827]                         lapply(seq_along(...future.elements_ii), 
[10:31:28.827]                           FUN = function(jj) {
[10:31:28.827]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.827]                             ...future.FUN(...future.X_jj, ...)
[10:31:28.827]                           })
[10:31:28.827]                       }
[10:31:28.827]                     }, args = future.call.arguments)
[10:31:28.827]                   }
[10:31:28.827]                 }, immediateCondition = function(cond) {
[10:31:28.827]                   sendCondition <- ...future.makeSendCondition()
[10:31:28.827]                   sendCondition(cond)
[10:31:28.827]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.827]                   {
[10:31:28.827]                     inherits <- base::inherits
[10:31:28.827]                     invokeRestart <- base::invokeRestart
[10:31:28.827]                     is.null <- base::is.null
[10:31:28.827]                     muffled <- FALSE
[10:31:28.827]                     if (inherits(cond, "message")) {
[10:31:28.827]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:28.827]                       if (muffled) 
[10:31:28.827]                         invokeRestart("muffleMessage")
[10:31:28.827]                     }
[10:31:28.827]                     else if (inherits(cond, "warning")) {
[10:31:28.827]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:28.827]                       if (muffled) 
[10:31:28.827]                         invokeRestart("muffleWarning")
[10:31:28.827]                     }
[10:31:28.827]                     else if (inherits(cond, "condition")) {
[10:31:28.827]                       if (!is.null(pattern)) {
[10:31:28.827]                         computeRestarts <- base::computeRestarts
[10:31:28.827]                         grepl <- base::grepl
[10:31:28.827]                         restarts <- computeRestarts(cond)
[10:31:28.827]                         for (restart in restarts) {
[10:31:28.827]                           name <- restart$name
[10:31:28.827]                           if (is.null(name)) 
[10:31:28.827]                             next
[10:31:28.827]                           if (!grepl(pattern, name)) 
[10:31:28.827]                             next
[10:31:28.827]                           invokeRestart(restart)
[10:31:28.827]                           muffled <- TRUE
[10:31:28.827]                           break
[10:31:28.827]                         }
[10:31:28.827]                       }
[10:31:28.827]                     }
[10:31:28.827]                     invisible(muffled)
[10:31:28.827]                   }
[10:31:28.827]                   muffleCondition(cond)
[10:31:28.827]                 })
[10:31:28.827]             }))
[10:31:28.827]             future::FutureResult(value = ...future.value$value, 
[10:31:28.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:28.827]                   ...future.rng), globalenv = if (FALSE) 
[10:31:28.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:28.827]                     ...future.globalenv.names))
[10:31:28.827]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:28.827]         }, condition = base::local({
[10:31:28.827]             c <- base::c
[10:31:28.827]             inherits <- base::inherits
[10:31:28.827]             invokeRestart <- base::invokeRestart
[10:31:28.827]             length <- base::length
[10:31:28.827]             list <- base::list
[10:31:28.827]             seq.int <- base::seq.int
[10:31:28.827]             signalCondition <- base::signalCondition
[10:31:28.827]             sys.calls <- base::sys.calls
[10:31:28.827]             `[[` <- base::`[[`
[10:31:28.827]             `+` <- base::`+`
[10:31:28.827]             `<<-` <- base::`<<-`
[10:31:28.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:28.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:28.827]                   3L)]
[10:31:28.827]             }
[10:31:28.827]             function(cond) {
[10:31:28.827]                 is_error <- inherits(cond, "error")
[10:31:28.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:28.827]                   NULL)
[10:31:28.827]                 if (is_error) {
[10:31:28.827]                   sessionInformation <- function() {
[10:31:28.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:28.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:28.827]                       search = base::search(), system = base::Sys.info())
[10:31:28.827]                   }
[10:31:28.827]                   ...future.conditions[[length(...future.conditions) + 
[10:31:28.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:28.827]                     cond$call), session = sessionInformation(), 
[10:31:28.827]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:28.827]                   signalCondition(cond)
[10:31:28.827]                 }
[10:31:28.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:28.827]                 "immediateCondition"))) {
[10:31:28.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:28.827]                   ...future.conditions[[length(...future.conditions) + 
[10:31:28.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:28.827]                   if (TRUE && !signal) {
[10:31:28.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.827]                     {
[10:31:28.827]                       inherits <- base::inherits
[10:31:28.827]                       invokeRestart <- base::invokeRestart
[10:31:28.827]                       is.null <- base::is.null
[10:31:28.827]                       muffled <- FALSE
[10:31:28.827]                       if (inherits(cond, "message")) {
[10:31:28.827]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:28.827]                         if (muffled) 
[10:31:28.827]                           invokeRestart("muffleMessage")
[10:31:28.827]                       }
[10:31:28.827]                       else if (inherits(cond, "warning")) {
[10:31:28.827]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:28.827]                         if (muffled) 
[10:31:28.827]                           invokeRestart("muffleWarning")
[10:31:28.827]                       }
[10:31:28.827]                       else if (inherits(cond, "condition")) {
[10:31:28.827]                         if (!is.null(pattern)) {
[10:31:28.827]                           computeRestarts <- base::computeRestarts
[10:31:28.827]                           grepl <- base::grepl
[10:31:28.827]                           restarts <- computeRestarts(cond)
[10:31:28.827]                           for (restart in restarts) {
[10:31:28.827]                             name <- restart$name
[10:31:28.827]                             if (is.null(name)) 
[10:31:28.827]                               next
[10:31:28.827]                             if (!grepl(pattern, name)) 
[10:31:28.827]                               next
[10:31:28.827]                             invokeRestart(restart)
[10:31:28.827]                             muffled <- TRUE
[10:31:28.827]                             break
[10:31:28.827]                           }
[10:31:28.827]                         }
[10:31:28.827]                       }
[10:31:28.827]                       invisible(muffled)
[10:31:28.827]                     }
[10:31:28.827]                     muffleCondition(cond, pattern = "^muffle")
[10:31:28.827]                   }
[10:31:28.827]                 }
[10:31:28.827]                 else {
[10:31:28.827]                   if (TRUE) {
[10:31:28.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:28.827]                     {
[10:31:28.827]                       inherits <- base::inherits
[10:31:28.827]                       invokeRestart <- base::invokeRestart
[10:31:28.827]                       is.null <- base::is.null
[10:31:28.827]                       muffled <- FALSE
[10:31:28.827]                       if (inherits(cond, "message")) {
[10:31:28.827]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:28.827]                         if (muffled) 
[10:31:28.827]                           invokeRestart("muffleMessage")
[10:31:28.827]                       }
[10:31:28.827]                       else if (inherits(cond, "warning")) {
[10:31:28.827]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:28.827]                         if (muffled) 
[10:31:28.827]                           invokeRestart("muffleWarning")
[10:31:28.827]                       }
[10:31:28.827]                       else if (inherits(cond, "condition")) {
[10:31:28.827]                         if (!is.null(pattern)) {
[10:31:28.827]                           computeRestarts <- base::computeRestarts
[10:31:28.827]                           grepl <- base::grepl
[10:31:28.827]                           restarts <- computeRestarts(cond)
[10:31:28.827]                           for (restart in restarts) {
[10:31:28.827]                             name <- restart$name
[10:31:28.827]                             if (is.null(name)) 
[10:31:28.827]                               next
[10:31:28.827]                             if (!grepl(pattern, name)) 
[10:31:28.827]                               next
[10:31:28.827]                             invokeRestart(restart)
[10:31:28.827]                             muffled <- TRUE
[10:31:28.827]                             break
[10:31:28.827]                           }
[10:31:28.827]                         }
[10:31:28.827]                       }
[10:31:28.827]                       invisible(muffled)
[10:31:28.827]                     }
[10:31:28.827]                     muffleCondition(cond, pattern = "^muffle")
[10:31:28.827]                   }
[10:31:28.827]                 }
[10:31:28.827]             }
[10:31:28.827]         }))
[10:31:28.827]     }, error = function(ex) {
[10:31:28.827]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:28.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:28.827]                 ...future.rng), started = ...future.startTime, 
[10:31:28.827]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:28.827]             version = "1.8"), class = "FutureResult")
[10:31:28.827]     }, finally = {
[10:31:28.827]         if (!identical(...future.workdir, getwd())) 
[10:31:28.827]             setwd(...future.workdir)
[10:31:28.827]         {
[10:31:28.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:28.827]                 ...future.oldOptions$nwarnings <- NULL
[10:31:28.827]             }
[10:31:28.827]             base::options(...future.oldOptions)
[10:31:28.827]             if (.Platform$OS.type == "windows") {
[10:31:28.827]                 old_names <- names(...future.oldEnvVars)
[10:31:28.827]                 envs <- base::Sys.getenv()
[10:31:28.827]                 names <- names(envs)
[10:31:28.827]                 common <- intersect(names, old_names)
[10:31:28.827]                 added <- setdiff(names, old_names)
[10:31:28.827]                 removed <- setdiff(old_names, names)
[10:31:28.827]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:28.827]                   envs[common]]
[10:31:28.827]                 NAMES <- toupper(changed)
[10:31:28.827]                 args <- list()
[10:31:28.827]                 for (kk in seq_along(NAMES)) {
[10:31:28.827]                   name <- changed[[kk]]
[10:31:28.827]                   NAME <- NAMES[[kk]]
[10:31:28.827]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.827]                     next
[10:31:28.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:28.827]                 }
[10:31:28.827]                 NAMES <- toupper(added)
[10:31:28.827]                 for (kk in seq_along(NAMES)) {
[10:31:28.827]                   name <- added[[kk]]
[10:31:28.827]                   NAME <- NAMES[[kk]]
[10:31:28.827]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.827]                     next
[10:31:28.827]                   args[[name]] <- ""
[10:31:28.827]                 }
[10:31:28.827]                 NAMES <- toupper(removed)
[10:31:28.827]                 for (kk in seq_along(NAMES)) {
[10:31:28.827]                   name <- removed[[kk]]
[10:31:28.827]                   NAME <- NAMES[[kk]]
[10:31:28.827]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:28.827]                     next
[10:31:28.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:28.827]                 }
[10:31:28.827]                 if (length(args) > 0) 
[10:31:28.827]                   base::do.call(base::Sys.setenv, args = args)
[10:31:28.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:28.827]             }
[10:31:28.827]             else {
[10:31:28.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:28.827]             }
[10:31:28.827]             {
[10:31:28.827]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:28.827]                   0L) {
[10:31:28.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:28.827]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:28.827]                   base::options(opts)
[10:31:28.827]                 }
[10:31:28.827]                 {
[10:31:28.827]                   {
[10:31:28.827]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:28.827]                     NULL
[10:31:28.827]                   }
[10:31:28.827]                   options(future.plan = NULL)
[10:31:28.827]                   if (is.na(NA_character_)) 
[10:31:28.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:28.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:28.827]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:28.827]                     .init = FALSE)
[10:31:28.827]                 }
[10:31:28.827]             }
[10:31:28.827]         }
[10:31:28.827]     })
[10:31:28.827]     if (TRUE) {
[10:31:28.827]         base::sink(type = "output", split = FALSE)
[10:31:28.827]         if (TRUE) {
[10:31:28.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:28.827]         }
[10:31:28.827]         else {
[10:31:28.827]             ...future.result["stdout"] <- base::list(NULL)
[10:31:28.827]         }
[10:31:28.827]         base::close(...future.stdout)
[10:31:28.827]         ...future.stdout <- NULL
[10:31:28.827]     }
[10:31:28.827]     ...future.result$conditions <- ...future.conditions
[10:31:28.827]     ...future.result$finished <- base::Sys.time()
[10:31:28.827]     ...future.result
[10:31:28.827] }
[10:31:28.830] Exporting 11 global objects (93.29 KiB) to cluster node #1 ...
[10:31:28.830] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:28.873] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:28.873] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ...
[10:31:28.874] Exporting ‘x_FUN’ (1.22 KiB) to cluster node #1 ... DONE
[10:31:28.874] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:28.874] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:28.874] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:28.917] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:28.917] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:28.961] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:28.961] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:28.962] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:28.962] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:31:28.962] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:31:28.962] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:28.963] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:28.963] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #1 ...
[10:31:28.963] Exporting ‘...future.elements_ii’ (176 bytes) to cluster node #1 ... DONE
[10:31:28.963] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:28.964] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:28.964] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:28.964] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:28.964] Exporting 11 global objects (93.29 KiB) to cluster node #1 ... DONE
[10:31:28.965] MultisessionFuture started
[10:31:28.965] - Launch lazy future ... done
[10:31:28.965] run() for ‘MultisessionFuture’ ... done
[10:31:28.965] Created future:
[10:31:28.967] receiveMessageFromWorker() for ClusterFuture ...
[10:31:28.967] - Validating connection of MultisessionFuture
[10:31:28.967] - received message: FutureResult
[10:31:28.968] - Received FutureResult
[10:31:28.968] - Erased future from FutureRegistry
[10:31:28.968] result() for ClusterFuture ...
[10:31:28.968] - result already collected: FutureResult
[10:31:28.968] result() for ClusterFuture ... done
[10:31:28.968] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:28.965] MultisessionFuture:
[10:31:28.965] Label: ‘future_vapply-2’
[10:31:28.965] Expression:
[10:31:28.965] {
[10:31:28.965]     do.call(function(...) {
[10:31:28.965]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:28.965]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:28.965]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:28.965]             on.exit(options(oopts), add = TRUE)
[10:31:28.965]         }
[10:31:28.965]         {
[10:31:28.965]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:28.965]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:28.965]                 ...future.FUN(...future.X_jj, ...)
[10:31:28.965]             })
[10:31:28.965]         }
[10:31:28.965]     }, args = future.call.arguments)
[10:31:28.965] }
[10:31:28.965] Lazy evaluation: FALSE
[10:31:28.965] Asynchronous evaluation: TRUE
[10:31:28.965] Local evaluation: TRUE
[10:31:28.965] Environment: R_GlobalEnv
[10:31:28.965] Capture standard output: TRUE
[10:31:28.965] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:28.965] Globals: 11 objects totaling 93.46 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 1.22 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:28.965] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:31:28.965] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:28.965] Resolved: TRUE
[10:31:28.965] Value: <not collected>
[10:31:28.965] Conditions captured: <none>
[10:31:28.965] Early signaling: FALSE
[10:31:28.965] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:28.965] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:28.968] Chunk #2 of 2 ... DONE
[10:31:28.968] Launching 2 futures (chunks) ... DONE
[10:31:28.969] Resolving 2 futures (chunks) ...
[10:31:28.969] resolve() on list ...
[10:31:28.969]  recursive: 0
[10:31:28.969]  length: 2
[10:31:28.969] 
[10:31:28.969] Future #1
[10:31:28.969] result() for ClusterFuture ...
[10:31:28.969] - result already collected: FutureResult
[10:31:28.969] result() for ClusterFuture ... done
[10:31:28.969] result() for ClusterFuture ...
[10:31:28.970] - result already collected: FutureResult
[10:31:28.970] result() for ClusterFuture ... done
[10:31:28.970] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:28.970] - nx: 2
[10:31:28.970] - relay: TRUE
[10:31:28.970] - stdout: TRUE
[10:31:28.970] - signal: TRUE
[10:31:28.970] - resignal: FALSE
[10:31:28.970] - force: TRUE
[10:31:28.970] - relayed: [n=2] FALSE, FALSE
[10:31:28.970] - queued futures: [n=2] FALSE, FALSE
[10:31:28.971]  - until=1
[10:31:28.971]  - relaying element #1
[10:31:28.971] result() for ClusterFuture ...
[10:31:28.971] - result already collected: FutureResult
[10:31:28.971] result() for ClusterFuture ... done
[10:31:28.971] result() for ClusterFuture ...
[10:31:28.971] - result already collected: FutureResult
[10:31:28.971] result() for ClusterFuture ... done
[10:31:28.971] result() for ClusterFuture ...
[10:31:28.971] - result already collected: FutureResult
[10:31:28.971] result() for ClusterFuture ... done
[10:31:28.972] result() for ClusterFuture ...
[10:31:28.972] - result already collected: FutureResult
[10:31:28.972] result() for ClusterFuture ... done
[10:31:28.972] - relayed: [n=2] TRUE, FALSE
[10:31:28.972] - queued futures: [n=2] TRUE, FALSE
[10:31:28.972] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:28.972]  length: 1 (resolved future 1)
[10:31:28.972] Future #2
[10:31:28.972] result() for ClusterFuture ...
[10:31:28.972] - result already collected: FutureResult
[10:31:28.972] result() for ClusterFuture ... done
[10:31:28.973] result() for ClusterFuture ...
[10:31:28.973] - result already collected: FutureResult
[10:31:28.973] result() for ClusterFuture ... done
[10:31:28.973] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:28.973] - nx: 2
[10:31:28.973] - relay: TRUE
[10:31:28.973] - stdout: TRUE
[10:31:28.973] - signal: TRUE
[10:31:28.973] - resignal: FALSE
[10:31:28.973] - force: TRUE
[10:31:28.973] - relayed: [n=2] TRUE, FALSE
[10:31:28.973] - queued futures: [n=2] TRUE, FALSE
[10:31:28.974]  - until=2
[10:31:28.974]  - relaying element #2
[10:31:28.974] result() for ClusterFuture ...
[10:31:28.974] - result already collected: FutureResult
[10:31:28.974] result() for ClusterFuture ... done
[10:31:28.974] result() for ClusterFuture ...
[10:31:28.974] - result already collected: FutureResult
[10:31:28.974] result() for ClusterFuture ... done
[10:31:28.974] result() for ClusterFuture ...
[10:31:28.974] - result already collected: FutureResult
[10:31:28.974] result() for ClusterFuture ... done
[10:31:28.975] result() for ClusterFuture ...
[10:31:28.975] - result already collected: FutureResult
[10:31:28.975] result() for ClusterFuture ... done
[10:31:28.975] - relayed: [n=2] TRUE, TRUE
[10:31:28.975] - queued futures: [n=2] TRUE, TRUE
[10:31:28.975] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:28.975]  length: 0 (resolved future 2)
[10:31:28.975] Relaying remaining futures
[10:31:28.975] signalConditionsASAP(NULL, pos=0) ...
[10:31:28.975] - nx: 2
[10:31:28.975] - relay: TRUE
[10:31:28.975] - stdout: TRUE
[10:31:28.976] - signal: TRUE
[10:31:28.976] - resignal: FALSE
[10:31:28.976] - force: TRUE
[10:31:28.976] - relayed: [n=2] TRUE, TRUE
[10:31:28.976] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:28.976] - relayed: [n=2] TRUE, TRUE
[10:31:28.976] - queued futures: [n=2] TRUE, TRUE
[10:31:28.976] signalConditionsASAP(NULL, pos=0) ... done
[10:31:28.976] resolve() on list ... DONE
[10:31:28.976] result() for ClusterFuture ...
[10:31:28.976] - result already collected: FutureResult
[10:31:28.977] result() for ClusterFuture ... done
[10:31:28.977] result() for ClusterFuture ...
[10:31:28.977] - result already collected: FutureResult
[10:31:28.977] result() for ClusterFuture ... done
[10:31:28.977] result() for ClusterFuture ...
[10:31:28.977] - result already collected: FutureResult
[10:31:28.977] result() for ClusterFuture ... done
[10:31:28.977] result() for ClusterFuture ...
[10:31:28.977] - result already collected: FutureResult
[10:31:28.977] result() for ClusterFuture ... done
[10:31:28.977]  - Number of value chunks collected: 2
[10:31:28.978] Resolving 2 futures (chunks) ... DONE
[10:31:28.978] Reducing values from 2 chunks ...
[10:31:28.978]  - Number of values collected after concatenation: 3
[10:31:28.978]  - Number of values expected: 3
[10:31:28.978] Reducing values from 2 chunks ... DONE
[10:31:28.978] future_lapply() ... DONE
 num [1:5, 1:3] 1 3.25 5.5 7.75 10 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "0%" "25%" "50%" "75%" ...
  ..$ : chr [1:3] "a" "beta" "logic"
[10:31:28.980] future_lapply() ...
[10:31:28.987] Number of chunks: 2
[10:31:28.987] getGlobalsAndPackagesXApply() ...
[10:31:28.987]  - future.globals: TRUE
[10:31:28.987] getGlobalsAndPackages() ...
[10:31:28.987] Searching for globals...
[10:31:28.992] - globals found: [21] ‘FUN’, ‘{’, ‘<-’, ‘is.na’, ‘if’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘length’, ‘==’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:31:28.992] Searching for globals ... DONE
[10:31:28.992] Resolving globals: FALSE
[10:31:28.993] The total size of the 1 globals is 45.86 KiB (46960 bytes)
[10:31:28.993] The total size of the 1 globals exported for future expression (‘FUN()’) is 45.86 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (45.86 KiB of class ‘function’)
[10:31:28.994] - globals: [1] ‘FUN’
[10:31:28.994] - packages: [1] ‘stats’
[10:31:28.994] getGlobalsAndPackages() ... DONE
[10:31:28.994]  - globals found/used: [n=1] ‘FUN’
[10:31:28.994]  - needed namespaces: [n=1] ‘stats’
[10:31:28.994] Finding globals ... DONE
[10:31:28.994]  - use_args: TRUE
[10:31:28.994]  - Getting '...' globals ...
[10:31:28.995] resolve() on list ...
[10:31:28.995]  recursive: 0
[10:31:28.995]  length: 1
[10:31:28.995]  elements: ‘...’
[10:31:28.995]  length: 0 (resolved future 1)
[10:31:28.995] resolve() on list ... DONE
[10:31:28.995]    - '...' content: [n=0] 
[10:31:28.995] List of 1
[10:31:28.995]  $ ...: list()
[10:31:28.995]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:28.995]  - attr(*, "where")=List of 1
[10:31:28.995]   ..$ ...:<environment: 0x55de87281c78> 
[10:31:28.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:28.995]  - attr(*, "resolved")= logi TRUE
[10:31:28.995]  - attr(*, "total_size")= num NA
[10:31:28.998]  - Getting '...' globals ... DONE
[10:31:28.998] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:28.998] List of 2
[10:31:28.998]  $ ...future.FUN:function (x, na.rm = TRUE)  
[10:31:28.998]  $ ...          : list()
[10:31:28.998]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:28.998]  - attr(*, "where")=List of 2
[10:31:28.998]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:28.998]   ..$ ...          :<environment: 0x55de87281c78> 
[10:31:28.998]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:28.998]  - attr(*, "resolved")= logi FALSE
[10:31:28.998]  - attr(*, "total_size")= num 46960
[10:31:29.000] Packages to be attached in all futures: [n=1] ‘stats’
[10:31:29.001] getGlobalsAndPackagesXApply() ... DONE
[10:31:29.001] Number of futures (= number of chunks): 2
[10:31:29.001] Launching 2 futures (chunks) ...
[10:31:29.001] Chunk #1 of 2 ...
[10:31:29.001]  - Finding globals in 'X' for chunk #1 ...
[10:31:29.001] getGlobalsAndPackages() ...
[10:31:29.001] Searching for globals...
[10:31:29.002] 
[10:31:29.002] Searching for globals ... DONE
[10:31:29.002] - globals: [0] <none>
[10:31:29.002] getGlobalsAndPackages() ... DONE
[10:31:29.002]    + additional globals found: [n=0] 
[10:31:29.002]    + additional namespaces needed: [n=0] 
[10:31:29.002]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:29.002]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:29.002]  - seeds: <none>
[10:31:29.002]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.002] getGlobalsAndPackages() ...
[10:31:29.003] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.003] Resolving globals: FALSE
[10:31:29.003] Tweak future expression to call with '...' arguments ...
[10:31:29.003] {
[10:31:29.003]     do.call(function(...) {
[10:31:29.003]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.003]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.003]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.003]             on.exit(options(oopts), add = TRUE)
[10:31:29.003]         }
[10:31:29.003]         {
[10:31:29.003]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.003]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.003]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.003]             })
[10:31:29.003]         }
[10:31:29.003]     }, args = future.call.arguments)
[10:31:29.003] }
[10:31:29.003] Tweak future expression to call with '...' arguments ... DONE
[10:31:29.003] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.004] - packages: [1] ‘stats’
[10:31:29.004] getGlobalsAndPackages() ... DONE
[10:31:29.004] run() for ‘Future’ ...
[10:31:29.004] - state: ‘created’
[10:31:29.004] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:29.018] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:29.018]   - Field: ‘node’
[10:31:29.018]   - Field: ‘label’
[10:31:29.018]   - Field: ‘local’
[10:31:29.019]   - Field: ‘owner’
[10:31:29.019]   - Field: ‘envir’
[10:31:29.019]   - Field: ‘workers’
[10:31:29.019]   - Field: ‘packages’
[10:31:29.019]   - Field: ‘gc’
[10:31:29.019]   - Field: ‘conditions’
[10:31:29.019]   - Field: ‘persistent’
[10:31:29.019]   - Field: ‘expr’
[10:31:29.019]   - Field: ‘uuid’
[10:31:29.019]   - Field: ‘seed’
[10:31:29.019]   - Field: ‘version’
[10:31:29.020]   - Field: ‘result’
[10:31:29.020]   - Field: ‘asynchronous’
[10:31:29.020]   - Field: ‘calls’
[10:31:29.020]   - Field: ‘globals’
[10:31:29.020]   - Field: ‘stdout’
[10:31:29.020]   - Field: ‘earlySignal’
[10:31:29.020]   - Field: ‘lazy’
[10:31:29.020]   - Field: ‘state’
[10:31:29.020] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:29.020] - Launch lazy future ...
[10:31:29.021] Packages needed by the future expression (n = 1): ‘stats’
[10:31:29.021] Packages needed by future strategies (n = 0): <none>
[10:31:29.021] {
[10:31:29.021]     {
[10:31:29.021]         {
[10:31:29.021]             ...future.startTime <- base::Sys.time()
[10:31:29.021]             {
[10:31:29.021]                 {
[10:31:29.021]                   {
[10:31:29.021]                     {
[10:31:29.021]                       {
[10:31:29.021]                         base::local({
[10:31:29.021]                           has_future <- base::requireNamespace("future", 
[10:31:29.021]                             quietly = TRUE)
[10:31:29.021]                           if (has_future) {
[10:31:29.021]                             ns <- base::getNamespace("future")
[10:31:29.021]                             version <- ns[[".package"]][["version"]]
[10:31:29.021]                             if (is.null(version)) 
[10:31:29.021]                               version <- utils::packageVersion("future")
[10:31:29.021]                           }
[10:31:29.021]                           else {
[10:31:29.021]                             version <- NULL
[10:31:29.021]                           }
[10:31:29.021]                           if (!has_future || version < "1.8.0") {
[10:31:29.021]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:29.021]                               "", base::R.version$version.string), 
[10:31:29.021]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:29.021]                                 base::R.version$platform, 8 * 
[10:31:29.021]                                   base::.Machine$sizeof.pointer), 
[10:31:29.021]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:29.021]                                 "release", "version")], collapse = " "), 
[10:31:29.021]                               hostname = base::Sys.info()[["nodename"]])
[10:31:29.021]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:29.021]                               info)
[10:31:29.021]                             info <- base::paste(info, collapse = "; ")
[10:31:29.021]                             if (!has_future) {
[10:31:29.021]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:29.021]                                 info)
[10:31:29.021]                             }
[10:31:29.021]                             else {
[10:31:29.021]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:29.021]                                 info, version)
[10:31:29.021]                             }
[10:31:29.021]                             base::stop(msg)
[10:31:29.021]                           }
[10:31:29.021]                         })
[10:31:29.021]                       }
[10:31:29.021]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:29.021]                       base::options(mc.cores = 1L)
[10:31:29.021]                     }
[10:31:29.021]                     base::local({
[10:31:29.021]                       for (pkg in "stats") {
[10:31:29.021]                         base::loadNamespace(pkg)
[10:31:29.021]                         base::library(pkg, character.only = TRUE)
[10:31:29.021]                       }
[10:31:29.021]                     })
[10:31:29.021]                   }
[10:31:29.021]                   ...future.strategy.old <- future::plan("list")
[10:31:29.021]                   options(future.plan = NULL)
[10:31:29.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:29.021]                 }
[10:31:29.021]                 ...future.workdir <- getwd()
[10:31:29.021]             }
[10:31:29.021]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:29.021]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:29.021]         }
[10:31:29.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:29.021]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:29.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:29.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:29.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:29.021]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:29.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:29.021]             base::names(...future.oldOptions))
[10:31:29.021]     }
[10:31:29.021]     if (FALSE) {
[10:31:29.021]     }
[10:31:29.021]     else {
[10:31:29.021]         if (TRUE) {
[10:31:29.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:29.021]                 open = "w")
[10:31:29.021]         }
[10:31:29.021]         else {
[10:31:29.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:29.021]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:29.021]         }
[10:31:29.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:29.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:29.021]             base::sink(type = "output", split = FALSE)
[10:31:29.021]             base::close(...future.stdout)
[10:31:29.021]         }, add = TRUE)
[10:31:29.021]     }
[10:31:29.021]     ...future.frame <- base::sys.nframe()
[10:31:29.021]     ...future.conditions <- base::list()
[10:31:29.021]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:29.021]     if (FALSE) {
[10:31:29.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:29.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:29.021]     }
[10:31:29.021]     ...future.result <- base::tryCatch({
[10:31:29.021]         base::withCallingHandlers({
[10:31:29.021]             ...future.value <- base::withVisible(base::local({
[10:31:29.021]                 ...future.makeSendCondition <- base::local({
[10:31:29.021]                   sendCondition <- NULL
[10:31:29.021]                   function(frame = 1L) {
[10:31:29.021]                     if (is.function(sendCondition)) 
[10:31:29.021]                       return(sendCondition)
[10:31:29.021]                     ns <- getNamespace("parallel")
[10:31:29.021]                     if (exists("sendData", mode = "function", 
[10:31:29.021]                       envir = ns)) {
[10:31:29.021]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:29.021]                         envir = ns)
[10:31:29.021]                       envir <- sys.frame(frame)
[10:31:29.021]                       master <- NULL
[10:31:29.021]                       while (!identical(envir, .GlobalEnv) && 
[10:31:29.021]                         !identical(envir, emptyenv())) {
[10:31:29.021]                         if (exists("master", mode = "list", envir = envir, 
[10:31:29.021]                           inherits = FALSE)) {
[10:31:29.021]                           master <- get("master", mode = "list", 
[10:31:29.021]                             envir = envir, inherits = FALSE)
[10:31:29.021]                           if (inherits(master, c("SOCKnode", 
[10:31:29.021]                             "SOCK0node"))) {
[10:31:29.021]                             sendCondition <<- function(cond) {
[10:31:29.021]                               data <- list(type = "VALUE", value = cond, 
[10:31:29.021]                                 success = TRUE)
[10:31:29.021]                               parallel_sendData(master, data)
[10:31:29.021]                             }
[10:31:29.021]                             return(sendCondition)
[10:31:29.021]                           }
[10:31:29.021]                         }
[10:31:29.021]                         frame <- frame + 1L
[10:31:29.021]                         envir <- sys.frame(frame)
[10:31:29.021]                       }
[10:31:29.021]                     }
[10:31:29.021]                     sendCondition <<- function(cond) NULL
[10:31:29.021]                   }
[10:31:29.021]                 })
[10:31:29.021]                 withCallingHandlers({
[10:31:29.021]                   {
[10:31:29.021]                     do.call(function(...) {
[10:31:29.021]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.021]                       if (!identical(...future.globals.maxSize.org, 
[10:31:29.021]                         ...future.globals.maxSize)) {
[10:31:29.021]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.021]                         on.exit(options(oopts), add = TRUE)
[10:31:29.021]                       }
[10:31:29.021]                       {
[10:31:29.021]                         lapply(seq_along(...future.elements_ii), 
[10:31:29.021]                           FUN = function(jj) {
[10:31:29.021]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.021]                             ...future.FUN(...future.X_jj, ...)
[10:31:29.021]                           })
[10:31:29.021]                       }
[10:31:29.021]                     }, args = future.call.arguments)
[10:31:29.021]                   }
[10:31:29.021]                 }, immediateCondition = function(cond) {
[10:31:29.021]                   sendCondition <- ...future.makeSendCondition()
[10:31:29.021]                   sendCondition(cond)
[10:31:29.021]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.021]                   {
[10:31:29.021]                     inherits <- base::inherits
[10:31:29.021]                     invokeRestart <- base::invokeRestart
[10:31:29.021]                     is.null <- base::is.null
[10:31:29.021]                     muffled <- FALSE
[10:31:29.021]                     if (inherits(cond, "message")) {
[10:31:29.021]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:29.021]                       if (muffled) 
[10:31:29.021]                         invokeRestart("muffleMessage")
[10:31:29.021]                     }
[10:31:29.021]                     else if (inherits(cond, "warning")) {
[10:31:29.021]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:29.021]                       if (muffled) 
[10:31:29.021]                         invokeRestart("muffleWarning")
[10:31:29.021]                     }
[10:31:29.021]                     else if (inherits(cond, "condition")) {
[10:31:29.021]                       if (!is.null(pattern)) {
[10:31:29.021]                         computeRestarts <- base::computeRestarts
[10:31:29.021]                         grepl <- base::grepl
[10:31:29.021]                         restarts <- computeRestarts(cond)
[10:31:29.021]                         for (restart in restarts) {
[10:31:29.021]                           name <- restart$name
[10:31:29.021]                           if (is.null(name)) 
[10:31:29.021]                             next
[10:31:29.021]                           if (!grepl(pattern, name)) 
[10:31:29.021]                             next
[10:31:29.021]                           invokeRestart(restart)
[10:31:29.021]                           muffled <- TRUE
[10:31:29.021]                           break
[10:31:29.021]                         }
[10:31:29.021]                       }
[10:31:29.021]                     }
[10:31:29.021]                     invisible(muffled)
[10:31:29.021]                   }
[10:31:29.021]                   muffleCondition(cond)
[10:31:29.021]                 })
[10:31:29.021]             }))
[10:31:29.021]             future::FutureResult(value = ...future.value$value, 
[10:31:29.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.021]                   ...future.rng), globalenv = if (FALSE) 
[10:31:29.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:29.021]                     ...future.globalenv.names))
[10:31:29.021]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:29.021]         }, condition = base::local({
[10:31:29.021]             c <- base::c
[10:31:29.021]             inherits <- base::inherits
[10:31:29.021]             invokeRestart <- base::invokeRestart
[10:31:29.021]             length <- base::length
[10:31:29.021]             list <- base::list
[10:31:29.021]             seq.int <- base::seq.int
[10:31:29.021]             signalCondition <- base::signalCondition
[10:31:29.021]             sys.calls <- base::sys.calls
[10:31:29.021]             `[[` <- base::`[[`
[10:31:29.021]             `+` <- base::`+`
[10:31:29.021]             `<<-` <- base::`<<-`
[10:31:29.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:29.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:29.021]                   3L)]
[10:31:29.021]             }
[10:31:29.021]             function(cond) {
[10:31:29.021]                 is_error <- inherits(cond, "error")
[10:31:29.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:29.021]                   NULL)
[10:31:29.021]                 if (is_error) {
[10:31:29.021]                   sessionInformation <- function() {
[10:31:29.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:29.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:29.021]                       search = base::search(), system = base::Sys.info())
[10:31:29.021]                   }
[10:31:29.021]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:29.021]                     cond$call), session = sessionInformation(), 
[10:31:29.021]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:29.021]                   signalCondition(cond)
[10:31:29.021]                 }
[10:31:29.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:29.021]                 "immediateCondition"))) {
[10:31:29.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:29.021]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:29.021]                   if (TRUE && !signal) {
[10:31:29.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.021]                     {
[10:31:29.021]                       inherits <- base::inherits
[10:31:29.021]                       invokeRestart <- base::invokeRestart
[10:31:29.021]                       is.null <- base::is.null
[10:31:29.021]                       muffled <- FALSE
[10:31:29.021]                       if (inherits(cond, "message")) {
[10:31:29.021]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.021]                         if (muffled) 
[10:31:29.021]                           invokeRestart("muffleMessage")
[10:31:29.021]                       }
[10:31:29.021]                       else if (inherits(cond, "warning")) {
[10:31:29.021]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.021]                         if (muffled) 
[10:31:29.021]                           invokeRestart("muffleWarning")
[10:31:29.021]                       }
[10:31:29.021]                       else if (inherits(cond, "condition")) {
[10:31:29.021]                         if (!is.null(pattern)) {
[10:31:29.021]                           computeRestarts <- base::computeRestarts
[10:31:29.021]                           grepl <- base::grepl
[10:31:29.021]                           restarts <- computeRestarts(cond)
[10:31:29.021]                           for (restart in restarts) {
[10:31:29.021]                             name <- restart$name
[10:31:29.021]                             if (is.null(name)) 
[10:31:29.021]                               next
[10:31:29.021]                             if (!grepl(pattern, name)) 
[10:31:29.021]                               next
[10:31:29.021]                             invokeRestart(restart)
[10:31:29.021]                             muffled <- TRUE
[10:31:29.021]                             break
[10:31:29.021]                           }
[10:31:29.021]                         }
[10:31:29.021]                       }
[10:31:29.021]                       invisible(muffled)
[10:31:29.021]                     }
[10:31:29.021]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.021]                   }
[10:31:29.021]                 }
[10:31:29.021]                 else {
[10:31:29.021]                   if (TRUE) {
[10:31:29.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.021]                     {
[10:31:29.021]                       inherits <- base::inherits
[10:31:29.021]                       invokeRestart <- base::invokeRestart
[10:31:29.021]                       is.null <- base::is.null
[10:31:29.021]                       muffled <- FALSE
[10:31:29.021]                       if (inherits(cond, "message")) {
[10:31:29.021]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.021]                         if (muffled) 
[10:31:29.021]                           invokeRestart("muffleMessage")
[10:31:29.021]                       }
[10:31:29.021]                       else if (inherits(cond, "warning")) {
[10:31:29.021]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.021]                         if (muffled) 
[10:31:29.021]                           invokeRestart("muffleWarning")
[10:31:29.021]                       }
[10:31:29.021]                       else if (inherits(cond, "condition")) {
[10:31:29.021]                         if (!is.null(pattern)) {
[10:31:29.021]                           computeRestarts <- base::computeRestarts
[10:31:29.021]                           grepl <- base::grepl
[10:31:29.021]                           restarts <- computeRestarts(cond)
[10:31:29.021]                           for (restart in restarts) {
[10:31:29.021]                             name <- restart$name
[10:31:29.021]                             if (is.null(name)) 
[10:31:29.021]                               next
[10:31:29.021]                             if (!grepl(pattern, name)) 
[10:31:29.021]                               next
[10:31:29.021]                             invokeRestart(restart)
[10:31:29.021]                             muffled <- TRUE
[10:31:29.021]                             break
[10:31:29.021]                           }
[10:31:29.021]                         }
[10:31:29.021]                       }
[10:31:29.021]                       invisible(muffled)
[10:31:29.021]                     }
[10:31:29.021]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.021]                   }
[10:31:29.021]                 }
[10:31:29.021]             }
[10:31:29.021]         }))
[10:31:29.021]     }, error = function(ex) {
[10:31:29.021]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:29.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.021]                 ...future.rng), started = ...future.startTime, 
[10:31:29.021]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:29.021]             version = "1.8"), class = "FutureResult")
[10:31:29.021]     }, finally = {
[10:31:29.021]         if (!identical(...future.workdir, getwd())) 
[10:31:29.021]             setwd(...future.workdir)
[10:31:29.021]         {
[10:31:29.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:29.021]                 ...future.oldOptions$nwarnings <- NULL
[10:31:29.021]             }
[10:31:29.021]             base::options(...future.oldOptions)
[10:31:29.021]             if (.Platform$OS.type == "windows") {
[10:31:29.021]                 old_names <- names(...future.oldEnvVars)
[10:31:29.021]                 envs <- base::Sys.getenv()
[10:31:29.021]                 names <- names(envs)
[10:31:29.021]                 common <- intersect(names, old_names)
[10:31:29.021]                 added <- setdiff(names, old_names)
[10:31:29.021]                 removed <- setdiff(old_names, names)
[10:31:29.021]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:29.021]                   envs[common]]
[10:31:29.021]                 NAMES <- toupper(changed)
[10:31:29.021]                 args <- list()
[10:31:29.021]                 for (kk in seq_along(NAMES)) {
[10:31:29.021]                   name <- changed[[kk]]
[10:31:29.021]                   NAME <- NAMES[[kk]]
[10:31:29.021]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.021]                     next
[10:31:29.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.021]                 }
[10:31:29.021]                 NAMES <- toupper(added)
[10:31:29.021]                 for (kk in seq_along(NAMES)) {
[10:31:29.021]                   name <- added[[kk]]
[10:31:29.021]                   NAME <- NAMES[[kk]]
[10:31:29.021]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.021]                     next
[10:31:29.021]                   args[[name]] <- ""
[10:31:29.021]                 }
[10:31:29.021]                 NAMES <- toupper(removed)
[10:31:29.021]                 for (kk in seq_along(NAMES)) {
[10:31:29.021]                   name <- removed[[kk]]
[10:31:29.021]                   NAME <- NAMES[[kk]]
[10:31:29.021]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.021]                     next
[10:31:29.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.021]                 }
[10:31:29.021]                 if (length(args) > 0) 
[10:31:29.021]                   base::do.call(base::Sys.setenv, args = args)
[10:31:29.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:29.021]             }
[10:31:29.021]             else {
[10:31:29.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:29.021]             }
[10:31:29.021]             {
[10:31:29.021]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:29.021]                   0L) {
[10:31:29.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:29.021]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:29.021]                   base::options(opts)
[10:31:29.021]                 }
[10:31:29.021]                 {
[10:31:29.021]                   {
[10:31:29.021]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:29.021]                     NULL
[10:31:29.021]                   }
[10:31:29.021]                   options(future.plan = NULL)
[10:31:29.021]                   if (is.na(NA_character_)) 
[10:31:29.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:29.021]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:29.021]                     .init = FALSE)
[10:31:29.021]                 }
[10:31:29.021]             }
[10:31:29.021]         }
[10:31:29.021]     })
[10:31:29.021]     if (TRUE) {
[10:31:29.021]         base::sink(type = "output", split = FALSE)
[10:31:29.021]         if (TRUE) {
[10:31:29.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:29.021]         }
[10:31:29.021]         else {
[10:31:29.021]             ...future.result["stdout"] <- base::list(NULL)
[10:31:29.021]         }
[10:31:29.021]         base::close(...future.stdout)
[10:31:29.021]         ...future.stdout <- NULL
[10:31:29.021]     }
[10:31:29.021]     ...future.result$conditions <- ...future.conditions
[10:31:29.021]     ...future.result$finished <- base::Sys.time()
[10:31:29.021]     ...future.result
[10:31:29.021] }
[10:31:29.024] Exporting 5 global objects (45.86 KiB) to cluster node #1 ...
[10:31:29.024] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ...
[10:31:29.065] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #1 ... DONE
[10:31:29.065] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:29.066] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.066] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[10:31:29.066] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[10:31:29.066] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:29.067] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.067] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:29.067] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.067] Exporting 5 global objects (45.86 KiB) to cluster node #1 ... DONE
[10:31:29.068] MultisessionFuture started
[10:31:29.068] - Launch lazy future ... done
[10:31:29.068] run() for ‘MultisessionFuture’ ... done
[10:31:29.068] Created future:
[10:31:29.068] MultisessionFuture:
[10:31:29.068] Label: ‘future_sapply-1’
[10:31:29.068] Expression:
[10:31:29.068] {
[10:31:29.068]     do.call(function(...) {
[10:31:29.068]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.068]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.068]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.068]             on.exit(options(oopts), add = TRUE)
[10:31:29.068]         }
[10:31:29.068]         {
[10:31:29.068]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.068]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.068]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.068]             })
[10:31:29.068]         }
[10:31:29.068]     }, args = future.call.arguments)
[10:31:29.068] }
[10:31:29.068] Lazy evaluation: FALSE
[10:31:29.068] Asynchronous evaluation: TRUE
[10:31:29.068] Local evaluation: TRUE
[10:31:29.068] Environment: R_GlobalEnv
[10:31:29.068] Capture standard output: TRUE
[10:31:29.068] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:29.068] Globals: 5 objects totaling 46.14 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 288 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:29.068] Packages: 1 packages (‘stats’)
[10:31:29.068] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:29.068] Resolved: FALSE
[10:31:29.068] Value: <not collected>
[10:31:29.068] Conditions captured: <none>
[10:31:29.068] Early signaling: FALSE
[10:31:29.068] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:29.068] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.080] Chunk #1 of 2 ... DONE
[10:31:29.080] Chunk #2 of 2 ...
[10:31:29.080]  - Finding globals in 'X' for chunk #2 ...
[10:31:29.080] getGlobalsAndPackages() ...
[10:31:29.080] Searching for globals...
[10:31:29.080] 
[10:31:29.080] Searching for globals ... DONE
[10:31:29.081] - globals: [0] <none>
[10:31:29.081] getGlobalsAndPackages() ... DONE
[10:31:29.081]    + additional globals found: [n=0] 
[10:31:29.081]    + additional namespaces needed: [n=0] 
[10:31:29.081]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:29.081]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:29.081]  - seeds: <none>
[10:31:29.081]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.081] getGlobalsAndPackages() ...
[10:31:29.084] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.084] Resolving globals: FALSE
[10:31:29.084] Tweak future expression to call with '...' arguments ...
[10:31:29.084] {
[10:31:29.084]     do.call(function(...) {
[10:31:29.084]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.084]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.084]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.084]             on.exit(options(oopts), add = TRUE)
[10:31:29.084]         }
[10:31:29.084]         {
[10:31:29.084]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.084]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.084]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.084]             })
[10:31:29.084]         }
[10:31:29.084]     }, args = future.call.arguments)
[10:31:29.084] }
[10:31:29.084] Tweak future expression to call with '...' arguments ... DONE
[10:31:29.085] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.085] - packages: [1] ‘stats’
[10:31:29.085] getGlobalsAndPackages() ... DONE
[10:31:29.085] run() for ‘Future’ ...
[10:31:29.085] - state: ‘created’
[10:31:29.085] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:29.100] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.100] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:29.100]   - Field: ‘node’
[10:31:29.100]   - Field: ‘label’
[10:31:29.100]   - Field: ‘local’
[10:31:29.100]   - Field: ‘owner’
[10:31:29.100]   - Field: ‘envir’
[10:31:29.100]   - Field: ‘workers’
[10:31:29.101]   - Field: ‘packages’
[10:31:29.101]   - Field: ‘gc’
[10:31:29.101]   - Field: ‘conditions’
[10:31:29.101]   - Field: ‘persistent’
[10:31:29.101]   - Field: ‘expr’
[10:31:29.101]   - Field: ‘uuid’
[10:31:29.101]   - Field: ‘seed’
[10:31:29.101]   - Field: ‘version’
[10:31:29.101]   - Field: ‘result’
[10:31:29.101]   - Field: ‘asynchronous’
[10:31:29.102]   - Field: ‘calls’
[10:31:29.102]   - Field: ‘globals’
[10:31:29.102]   - Field: ‘stdout’
[10:31:29.102]   - Field: ‘earlySignal’
[10:31:29.102]   - Field: ‘lazy’
[10:31:29.102]   - Field: ‘state’
[10:31:29.102] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:29.102] - Launch lazy future ...
[10:31:29.102] Packages needed by the future expression (n = 1): ‘stats’
[10:31:29.103] Packages needed by future strategies (n = 0): <none>
[10:31:29.103] {
[10:31:29.103]     {
[10:31:29.103]         {
[10:31:29.103]             ...future.startTime <- base::Sys.time()
[10:31:29.103]             {
[10:31:29.103]                 {
[10:31:29.103]                   {
[10:31:29.103]                     {
[10:31:29.103]                       {
[10:31:29.103]                         base::local({
[10:31:29.103]                           has_future <- base::requireNamespace("future", 
[10:31:29.103]                             quietly = TRUE)
[10:31:29.103]                           if (has_future) {
[10:31:29.103]                             ns <- base::getNamespace("future")
[10:31:29.103]                             version <- ns[[".package"]][["version"]]
[10:31:29.103]                             if (is.null(version)) 
[10:31:29.103]                               version <- utils::packageVersion("future")
[10:31:29.103]                           }
[10:31:29.103]                           else {
[10:31:29.103]                             version <- NULL
[10:31:29.103]                           }
[10:31:29.103]                           if (!has_future || version < "1.8.0") {
[10:31:29.103]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:29.103]                               "", base::R.version$version.string), 
[10:31:29.103]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:29.103]                                 base::R.version$platform, 8 * 
[10:31:29.103]                                   base::.Machine$sizeof.pointer), 
[10:31:29.103]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:29.103]                                 "release", "version")], collapse = " "), 
[10:31:29.103]                               hostname = base::Sys.info()[["nodename"]])
[10:31:29.103]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:29.103]                               info)
[10:31:29.103]                             info <- base::paste(info, collapse = "; ")
[10:31:29.103]                             if (!has_future) {
[10:31:29.103]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:29.103]                                 info)
[10:31:29.103]                             }
[10:31:29.103]                             else {
[10:31:29.103]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:29.103]                                 info, version)
[10:31:29.103]                             }
[10:31:29.103]                             base::stop(msg)
[10:31:29.103]                           }
[10:31:29.103]                         })
[10:31:29.103]                       }
[10:31:29.103]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:29.103]                       base::options(mc.cores = 1L)
[10:31:29.103]                     }
[10:31:29.103]                     base::local({
[10:31:29.103]                       for (pkg in "stats") {
[10:31:29.103]                         base::loadNamespace(pkg)
[10:31:29.103]                         base::library(pkg, character.only = TRUE)
[10:31:29.103]                       }
[10:31:29.103]                     })
[10:31:29.103]                   }
[10:31:29.103]                   ...future.strategy.old <- future::plan("list")
[10:31:29.103]                   options(future.plan = NULL)
[10:31:29.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:29.103]                 }
[10:31:29.103]                 ...future.workdir <- getwd()
[10:31:29.103]             }
[10:31:29.103]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:29.103]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:29.103]         }
[10:31:29.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:29.103]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:29.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:29.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:29.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:29.103]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:29.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:29.103]             base::names(...future.oldOptions))
[10:31:29.103]     }
[10:31:29.103]     if (FALSE) {
[10:31:29.103]     }
[10:31:29.103]     else {
[10:31:29.103]         if (TRUE) {
[10:31:29.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:29.103]                 open = "w")
[10:31:29.103]         }
[10:31:29.103]         else {
[10:31:29.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:29.103]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:29.103]         }
[10:31:29.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:29.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:29.103]             base::sink(type = "output", split = FALSE)
[10:31:29.103]             base::close(...future.stdout)
[10:31:29.103]         }, add = TRUE)
[10:31:29.103]     }
[10:31:29.103]     ...future.frame <- base::sys.nframe()
[10:31:29.103]     ...future.conditions <- base::list()
[10:31:29.103]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:29.103]     if (FALSE) {
[10:31:29.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:29.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:29.103]     }
[10:31:29.103]     ...future.result <- base::tryCatch({
[10:31:29.103]         base::withCallingHandlers({
[10:31:29.103]             ...future.value <- base::withVisible(base::local({
[10:31:29.103]                 ...future.makeSendCondition <- base::local({
[10:31:29.103]                   sendCondition <- NULL
[10:31:29.103]                   function(frame = 1L) {
[10:31:29.103]                     if (is.function(sendCondition)) 
[10:31:29.103]                       return(sendCondition)
[10:31:29.103]                     ns <- getNamespace("parallel")
[10:31:29.103]                     if (exists("sendData", mode = "function", 
[10:31:29.103]                       envir = ns)) {
[10:31:29.103]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:29.103]                         envir = ns)
[10:31:29.103]                       envir <- sys.frame(frame)
[10:31:29.103]                       master <- NULL
[10:31:29.103]                       while (!identical(envir, .GlobalEnv) && 
[10:31:29.103]                         !identical(envir, emptyenv())) {
[10:31:29.103]                         if (exists("master", mode = "list", envir = envir, 
[10:31:29.103]                           inherits = FALSE)) {
[10:31:29.103]                           master <- get("master", mode = "list", 
[10:31:29.103]                             envir = envir, inherits = FALSE)
[10:31:29.103]                           if (inherits(master, c("SOCKnode", 
[10:31:29.103]                             "SOCK0node"))) {
[10:31:29.103]                             sendCondition <<- function(cond) {
[10:31:29.103]                               data <- list(type = "VALUE", value = cond, 
[10:31:29.103]                                 success = TRUE)
[10:31:29.103]                               parallel_sendData(master, data)
[10:31:29.103]                             }
[10:31:29.103]                             return(sendCondition)
[10:31:29.103]                           }
[10:31:29.103]                         }
[10:31:29.103]                         frame <- frame + 1L
[10:31:29.103]                         envir <- sys.frame(frame)
[10:31:29.103]                       }
[10:31:29.103]                     }
[10:31:29.103]                     sendCondition <<- function(cond) NULL
[10:31:29.103]                   }
[10:31:29.103]                 })
[10:31:29.103]                 withCallingHandlers({
[10:31:29.103]                   {
[10:31:29.103]                     do.call(function(...) {
[10:31:29.103]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.103]                       if (!identical(...future.globals.maxSize.org, 
[10:31:29.103]                         ...future.globals.maxSize)) {
[10:31:29.103]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.103]                         on.exit(options(oopts), add = TRUE)
[10:31:29.103]                       }
[10:31:29.103]                       {
[10:31:29.103]                         lapply(seq_along(...future.elements_ii), 
[10:31:29.103]                           FUN = function(jj) {
[10:31:29.103]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.103]                             ...future.FUN(...future.X_jj, ...)
[10:31:29.103]                           })
[10:31:29.103]                       }
[10:31:29.103]                     }, args = future.call.arguments)
[10:31:29.103]                   }
[10:31:29.103]                 }, immediateCondition = function(cond) {
[10:31:29.103]                   sendCondition <- ...future.makeSendCondition()
[10:31:29.103]                   sendCondition(cond)
[10:31:29.103]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.103]                   {
[10:31:29.103]                     inherits <- base::inherits
[10:31:29.103]                     invokeRestart <- base::invokeRestart
[10:31:29.103]                     is.null <- base::is.null
[10:31:29.103]                     muffled <- FALSE
[10:31:29.103]                     if (inherits(cond, "message")) {
[10:31:29.103]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:29.103]                       if (muffled) 
[10:31:29.103]                         invokeRestart("muffleMessage")
[10:31:29.103]                     }
[10:31:29.103]                     else if (inherits(cond, "warning")) {
[10:31:29.103]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:29.103]                       if (muffled) 
[10:31:29.103]                         invokeRestart("muffleWarning")
[10:31:29.103]                     }
[10:31:29.103]                     else if (inherits(cond, "condition")) {
[10:31:29.103]                       if (!is.null(pattern)) {
[10:31:29.103]                         computeRestarts <- base::computeRestarts
[10:31:29.103]                         grepl <- base::grepl
[10:31:29.103]                         restarts <- computeRestarts(cond)
[10:31:29.103]                         for (restart in restarts) {
[10:31:29.103]                           name <- restart$name
[10:31:29.103]                           if (is.null(name)) 
[10:31:29.103]                             next
[10:31:29.103]                           if (!grepl(pattern, name)) 
[10:31:29.103]                             next
[10:31:29.103]                           invokeRestart(restart)
[10:31:29.103]                           muffled <- TRUE
[10:31:29.103]                           break
[10:31:29.103]                         }
[10:31:29.103]                       }
[10:31:29.103]                     }
[10:31:29.103]                     invisible(muffled)
[10:31:29.103]                   }
[10:31:29.103]                   muffleCondition(cond)
[10:31:29.103]                 })
[10:31:29.103]             }))
[10:31:29.103]             future::FutureResult(value = ...future.value$value, 
[10:31:29.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.103]                   ...future.rng), globalenv = if (FALSE) 
[10:31:29.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:29.103]                     ...future.globalenv.names))
[10:31:29.103]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:29.103]         }, condition = base::local({
[10:31:29.103]             c <- base::c
[10:31:29.103]             inherits <- base::inherits
[10:31:29.103]             invokeRestart <- base::invokeRestart
[10:31:29.103]             length <- base::length
[10:31:29.103]             list <- base::list
[10:31:29.103]             seq.int <- base::seq.int
[10:31:29.103]             signalCondition <- base::signalCondition
[10:31:29.103]             sys.calls <- base::sys.calls
[10:31:29.103]             `[[` <- base::`[[`
[10:31:29.103]             `+` <- base::`+`
[10:31:29.103]             `<<-` <- base::`<<-`
[10:31:29.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:29.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:29.103]                   3L)]
[10:31:29.103]             }
[10:31:29.103]             function(cond) {
[10:31:29.103]                 is_error <- inherits(cond, "error")
[10:31:29.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:29.103]                   NULL)
[10:31:29.103]                 if (is_error) {
[10:31:29.103]                   sessionInformation <- function() {
[10:31:29.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:29.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:29.103]                       search = base::search(), system = base::Sys.info())
[10:31:29.103]                   }
[10:31:29.103]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:29.103]                     cond$call), session = sessionInformation(), 
[10:31:29.103]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:29.103]                   signalCondition(cond)
[10:31:29.103]                 }
[10:31:29.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:29.103]                 "immediateCondition"))) {
[10:31:29.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:29.103]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:29.103]                   if (TRUE && !signal) {
[10:31:29.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.103]                     {
[10:31:29.103]                       inherits <- base::inherits
[10:31:29.103]                       invokeRestart <- base::invokeRestart
[10:31:29.103]                       is.null <- base::is.null
[10:31:29.103]                       muffled <- FALSE
[10:31:29.103]                       if (inherits(cond, "message")) {
[10:31:29.103]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.103]                         if (muffled) 
[10:31:29.103]                           invokeRestart("muffleMessage")
[10:31:29.103]                       }
[10:31:29.103]                       else if (inherits(cond, "warning")) {
[10:31:29.103]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.103]                         if (muffled) 
[10:31:29.103]                           invokeRestart("muffleWarning")
[10:31:29.103]                       }
[10:31:29.103]                       else if (inherits(cond, "condition")) {
[10:31:29.103]                         if (!is.null(pattern)) {
[10:31:29.103]                           computeRestarts <- base::computeRestarts
[10:31:29.103]                           grepl <- base::grepl
[10:31:29.103]                           restarts <- computeRestarts(cond)
[10:31:29.103]                           for (restart in restarts) {
[10:31:29.103]                             name <- restart$name
[10:31:29.103]                             if (is.null(name)) 
[10:31:29.103]                               next
[10:31:29.103]                             if (!grepl(pattern, name)) 
[10:31:29.103]                               next
[10:31:29.103]                             invokeRestart(restart)
[10:31:29.103]                             muffled <- TRUE
[10:31:29.103]                             break
[10:31:29.103]                           }
[10:31:29.103]                         }
[10:31:29.103]                       }
[10:31:29.103]                       invisible(muffled)
[10:31:29.103]                     }
[10:31:29.103]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.103]                   }
[10:31:29.103]                 }
[10:31:29.103]                 else {
[10:31:29.103]                   if (TRUE) {
[10:31:29.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.103]                     {
[10:31:29.103]                       inherits <- base::inherits
[10:31:29.103]                       invokeRestart <- base::invokeRestart
[10:31:29.103]                       is.null <- base::is.null
[10:31:29.103]                       muffled <- FALSE
[10:31:29.103]                       if (inherits(cond, "message")) {
[10:31:29.103]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.103]                         if (muffled) 
[10:31:29.103]                           invokeRestart("muffleMessage")
[10:31:29.103]                       }
[10:31:29.103]                       else if (inherits(cond, "warning")) {
[10:31:29.103]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.103]                         if (muffled) 
[10:31:29.103]                           invokeRestart("muffleWarning")
[10:31:29.103]                       }
[10:31:29.103]                       else if (inherits(cond, "condition")) {
[10:31:29.103]                         if (!is.null(pattern)) {
[10:31:29.103]                           computeRestarts <- base::computeRestarts
[10:31:29.103]                           grepl <- base::grepl
[10:31:29.103]                           restarts <- computeRestarts(cond)
[10:31:29.103]                           for (restart in restarts) {
[10:31:29.103]                             name <- restart$name
[10:31:29.103]                             if (is.null(name)) 
[10:31:29.103]                               next
[10:31:29.103]                             if (!grepl(pattern, name)) 
[10:31:29.103]                               next
[10:31:29.103]                             invokeRestart(restart)
[10:31:29.103]                             muffled <- TRUE
[10:31:29.103]                             break
[10:31:29.103]                           }
[10:31:29.103]                         }
[10:31:29.103]                       }
[10:31:29.103]                       invisible(muffled)
[10:31:29.103]                     }
[10:31:29.103]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.103]                   }
[10:31:29.103]                 }
[10:31:29.103]             }
[10:31:29.103]         }))
[10:31:29.103]     }, error = function(ex) {
[10:31:29.103]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:29.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.103]                 ...future.rng), started = ...future.startTime, 
[10:31:29.103]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:29.103]             version = "1.8"), class = "FutureResult")
[10:31:29.103]     }, finally = {
[10:31:29.103]         if (!identical(...future.workdir, getwd())) 
[10:31:29.103]             setwd(...future.workdir)
[10:31:29.103]         {
[10:31:29.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:29.103]                 ...future.oldOptions$nwarnings <- NULL
[10:31:29.103]             }
[10:31:29.103]             base::options(...future.oldOptions)
[10:31:29.103]             if (.Platform$OS.type == "windows") {
[10:31:29.103]                 old_names <- names(...future.oldEnvVars)
[10:31:29.103]                 envs <- base::Sys.getenv()
[10:31:29.103]                 names <- names(envs)
[10:31:29.103]                 common <- intersect(names, old_names)
[10:31:29.103]                 added <- setdiff(names, old_names)
[10:31:29.103]                 removed <- setdiff(old_names, names)
[10:31:29.103]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:29.103]                   envs[common]]
[10:31:29.103]                 NAMES <- toupper(changed)
[10:31:29.103]                 args <- list()
[10:31:29.103]                 for (kk in seq_along(NAMES)) {
[10:31:29.103]                   name <- changed[[kk]]
[10:31:29.103]                   NAME <- NAMES[[kk]]
[10:31:29.103]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.103]                     next
[10:31:29.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.103]                 }
[10:31:29.103]                 NAMES <- toupper(added)
[10:31:29.103]                 for (kk in seq_along(NAMES)) {
[10:31:29.103]                   name <- added[[kk]]
[10:31:29.103]                   NAME <- NAMES[[kk]]
[10:31:29.103]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.103]                     next
[10:31:29.103]                   args[[name]] <- ""
[10:31:29.103]                 }
[10:31:29.103]                 NAMES <- toupper(removed)
[10:31:29.103]                 for (kk in seq_along(NAMES)) {
[10:31:29.103]                   name <- removed[[kk]]
[10:31:29.103]                   NAME <- NAMES[[kk]]
[10:31:29.103]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.103]                     next
[10:31:29.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.103]                 }
[10:31:29.103]                 if (length(args) > 0) 
[10:31:29.103]                   base::do.call(base::Sys.setenv, args = args)
[10:31:29.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:29.103]             }
[10:31:29.103]             else {
[10:31:29.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:29.103]             }
[10:31:29.103]             {
[10:31:29.103]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:29.103]                   0L) {
[10:31:29.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:29.103]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:29.103]                   base::options(opts)
[10:31:29.103]                 }
[10:31:29.103]                 {
[10:31:29.103]                   {
[10:31:29.103]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:29.103]                     NULL
[10:31:29.103]                   }
[10:31:29.103]                   options(future.plan = NULL)
[10:31:29.103]                   if (is.na(NA_character_)) 
[10:31:29.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:29.103]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:29.103]                     .init = FALSE)
[10:31:29.103]                 }
[10:31:29.103]             }
[10:31:29.103]         }
[10:31:29.103]     })
[10:31:29.103]     if (TRUE) {
[10:31:29.103]         base::sink(type = "output", split = FALSE)
[10:31:29.103]         if (TRUE) {
[10:31:29.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:29.103]         }
[10:31:29.103]         else {
[10:31:29.103]             ...future.result["stdout"] <- base::list(NULL)
[10:31:29.103]         }
[10:31:29.103]         base::close(...future.stdout)
[10:31:29.103]         ...future.stdout <- NULL
[10:31:29.103]     }
[10:31:29.103]     ...future.result$conditions <- ...future.conditions
[10:31:29.103]     ...future.result$finished <- base::Sys.time()
[10:31:29.103]     ...future.result
[10:31:29.103] }
[10:31:29.106] Exporting 5 global objects (45.86 KiB) to cluster node #2 ...
[10:31:29.106] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ...
[10:31:29.149] Exporting ‘...future.FUN’ (45.86 KiB) to cluster node #2 ... DONE
[10:31:29.149] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:31:29.150] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:31:29.150] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ...
[10:31:29.150] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #2 ... DONE
[10:31:29.150] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:29.151] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:29.151] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:29.151] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:29.151] Exporting 5 global objects (45.86 KiB) to cluster node #2 ... DONE
[10:31:29.152] MultisessionFuture started
[10:31:29.152] - Launch lazy future ... done
[10:31:29.152] run() for ‘MultisessionFuture’ ... done
[10:31:29.152] Created future:
[10:31:29.152] MultisessionFuture:
[10:31:29.152] Label: ‘future_sapply-2’
[10:31:29.152] Expression:
[10:31:29.152] {
[10:31:29.152]     do.call(function(...) {
[10:31:29.152]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.152]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.152]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.152]             on.exit(options(oopts), add = TRUE)
[10:31:29.152]         }
[10:31:29.152]         {
[10:31:29.152]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.152]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.152]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.152]             })
[10:31:29.152]         }
[10:31:29.152]     }, args = future.call.arguments)
[10:31:29.152] }
[10:31:29.152] Lazy evaluation: FALSE
[10:31:29.152] Asynchronous evaluation: TRUE
[10:31:29.152] Local evaluation: TRUE
[10:31:29.152] Environment: R_GlobalEnv
[10:31:29.152] Capture standard output: TRUE
[10:31:29.152] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:29.152] Globals: 5 objects totaling 46.11 KiB (function ‘...future.FUN’ of 45.86 KiB, DotDotDotList ‘future.call.arguments’ of 0 bytes, list ‘...future.elements_ii’ of 256 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:29.152] Packages: 1 packages (‘stats’)
[10:31:29.152] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:29.152] Resolved: FALSE
[10:31:29.152] Value: <not collected>
[10:31:29.152] Conditions captured: <none>
[10:31:29.152] Early signaling: FALSE
[10:31:29.152] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:29.152] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.164] Chunk #2 of 2 ... DONE
[10:31:29.164] Launching 2 futures (chunks) ... DONE
[10:31:29.164] Resolving 2 futures (chunks) ...
[10:31:29.164] resolve() on list ...
[10:31:29.164]  recursive: 0
[10:31:29.164]  length: 2
[10:31:29.164] 
[10:31:29.165] receiveMessageFromWorker() for ClusterFuture ...
[10:31:29.165] - Validating connection of MultisessionFuture
[10:31:29.165] - received message: FutureResult
[10:31:29.165] - Received FutureResult
[10:31:29.165] - Erased future from FutureRegistry
[10:31:29.165] result() for ClusterFuture ...
[10:31:29.165] - result already collected: FutureResult
[10:31:29.166] result() for ClusterFuture ... done
[10:31:29.166] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:29.166] Future #1
[10:31:29.166] result() for ClusterFuture ...
[10:31:29.166] - result already collected: FutureResult
[10:31:29.166] result() for ClusterFuture ... done
[10:31:29.166] result() for ClusterFuture ...
[10:31:29.166] - result already collected: FutureResult
[10:31:29.166] result() for ClusterFuture ... done
[10:31:29.166] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:29.167] - nx: 2
[10:31:29.167] - relay: TRUE
[10:31:29.167] - stdout: TRUE
[10:31:29.167] - signal: TRUE
[10:31:29.167] - resignal: FALSE
[10:31:29.167] - force: TRUE
[10:31:29.167] - relayed: [n=2] FALSE, FALSE
[10:31:29.167] - queued futures: [n=2] FALSE, FALSE
[10:31:29.167]  - until=1
[10:31:29.167]  - relaying element #1
[10:31:29.168] result() for ClusterFuture ...
[10:31:29.168] - result already collected: FutureResult
[10:31:29.168] result() for ClusterFuture ... done
[10:31:29.168] result() for ClusterFuture ...
[10:31:29.168] - result already collected: FutureResult
[10:31:29.168] result() for ClusterFuture ... done
[10:31:29.168] result() for ClusterFuture ...
[10:31:29.168] - result already collected: FutureResult
[10:31:29.168] result() for ClusterFuture ... done
[10:31:29.168] result() for ClusterFuture ...
[10:31:29.168] - result already collected: FutureResult
[10:31:29.169] result() for ClusterFuture ... done
[10:31:29.169] - relayed: [n=2] TRUE, FALSE
[10:31:29.169] - queued futures: [n=2] TRUE, FALSE
[10:31:29.169] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:29.169]  length: 1 (resolved future 1)
[10:31:29.195] receiveMessageFromWorker() for ClusterFuture ...
[10:31:29.195] - Validating connection of MultisessionFuture
[10:31:29.195] - received message: FutureResult
[10:31:29.195] - Received FutureResult
[10:31:29.195] - Erased future from FutureRegistry
[10:31:29.196] result() for ClusterFuture ...
[10:31:29.196] - result already collected: FutureResult
[10:31:29.196] result() for ClusterFuture ... done
[10:31:29.196] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:29.196] Future #2
[10:31:29.196] result() for ClusterFuture ...
[10:31:29.196] - result already collected: FutureResult
[10:31:29.196] result() for ClusterFuture ... done
[10:31:29.196] result() for ClusterFuture ...
[10:31:29.196] - result already collected: FutureResult
[10:31:29.197] result() for ClusterFuture ... done
[10:31:29.197] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:29.197] - nx: 2
[10:31:29.197] - relay: TRUE
[10:31:29.197] - stdout: TRUE
[10:31:29.197] - signal: TRUE
[10:31:29.197] - resignal: FALSE
[10:31:29.197] - force: TRUE
[10:31:29.197] - relayed: [n=2] TRUE, FALSE
[10:31:29.197] - queued futures: [n=2] TRUE, FALSE
[10:31:29.197]  - until=2
[10:31:29.198]  - relaying element #2
[10:31:29.198] result() for ClusterFuture ...
[10:31:29.198] - result already collected: FutureResult
[10:31:29.198] result() for ClusterFuture ... done
[10:31:29.198] result() for ClusterFuture ...
[10:31:29.198] - result already collected: FutureResult
[10:31:29.198] result() for ClusterFuture ... done
[10:31:29.198] result() for ClusterFuture ...
[10:31:29.198] - result already collected: FutureResult
[10:31:29.198] result() for ClusterFuture ... done
[10:31:29.198] result() for ClusterFuture ...
[10:31:29.199] - result already collected: FutureResult
[10:31:29.199] result() for ClusterFuture ... done
[10:31:29.199] - relayed: [n=2] TRUE, TRUE
[10:31:29.199] - queued futures: [n=2] TRUE, TRUE
[10:31:29.199] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:29.199]  length: 0 (resolved future 2)
[10:31:29.199] Relaying remaining futures
[10:31:29.199] signalConditionsASAP(NULL, pos=0) ...
[10:31:29.199] - nx: 2
[10:31:29.199] - relay: TRUE
[10:31:29.199] - stdout: TRUE
[10:31:29.200] - signal: TRUE
[10:31:29.200] - resignal: FALSE
[10:31:29.200] - force: TRUE
[10:31:29.200] - relayed: [n=2] TRUE, TRUE
[10:31:29.200] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:29.200] - relayed: [n=2] TRUE, TRUE
[10:31:29.200] - queued futures: [n=2] TRUE, TRUE
[10:31:29.200] signalConditionsASAP(NULL, pos=0) ... done
[10:31:29.200] resolve() on list ... DONE
[10:31:29.200] result() for ClusterFuture ...
[10:31:29.200] - result already collected: FutureResult
[10:31:29.201] result() for ClusterFuture ... done
[10:31:29.201] result() for ClusterFuture ...
[10:31:29.201] - result already collected: FutureResult
[10:31:29.201] result() for ClusterFuture ... done
[10:31:29.201] result() for ClusterFuture ...
[10:31:29.201] - result already collected: FutureResult
[10:31:29.201] result() for ClusterFuture ... done
[10:31:29.201] result() for ClusterFuture ...
[10:31:29.201] - result already collected: FutureResult
[10:31:29.201] result() for ClusterFuture ... done
[10:31:29.201]  - Number of value chunks collected: 2
[10:31:29.202] Resolving 2 futures (chunks) ... DONE
[10:31:29.202] Reducing values from 2 chunks ...
[10:31:29.202]  - Number of values collected after concatenation: 7
[10:31:29.202]  - Number of values expected: 7
[10:31:29.202] Reducing values from 2 chunks ... DONE
[10:31:29.202] future_lapply() ... DONE
[10:31:29.202] future_lapply() ...
[10:31:29.208] Number of chunks: 2
[10:31:29.208] getGlobalsAndPackagesXApply() ...
[10:31:29.208]  - future.globals: TRUE
[10:31:29.208] getGlobalsAndPackages() ...
[10:31:29.208] Searching for globals...
[10:31:29.215] - globals found: [31] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘is.na’, ‘any’, ‘[’, ‘!’, ‘return’, ‘rep.int’, ‘sort’, ‘/’, ‘floor’, ‘(’, ‘+’, ‘c’, ‘-’, ‘*’, ‘ceiling’
[10:31:29.215] Searching for globals ... DONE
[10:31:29.215] Resolving globals: FALSE
[10:31:29.217] The total size of the 7 globals is 137.93 KiB (141240 bytes)
[10:31:29.217] The total size of the 7 globals exported for future expression (‘FUN()’) is 137.93 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘x_FUN’ (45.86 KiB of class ‘function’), ‘stop_if_not’ (44.12 KiB of class ‘function’) and ‘stopf’ (26.43 KiB of class ‘function’)
[10:31:29.217] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:29.217] - packages: [2] ‘stats’, ‘future.apply’
[10:31:29.217] getGlobalsAndPackages() ... DONE
[10:31:29.218]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:29.218]  - needed namespaces: [n=2] ‘stats’, ‘future.apply’
[10:31:29.218] Finding globals ... DONE
[10:31:29.218]  - use_args: TRUE
[10:31:29.218]  - Getting '...' globals ...
[10:31:29.218] resolve() on list ...
[10:31:29.218]  recursive: 0
[10:31:29.218]  length: 1
[10:31:29.218]  elements: ‘...’
[10:31:29.219]  length: 0 (resolved future 1)
[10:31:29.219] resolve() on list ... DONE
[10:31:29.219]    - '...' content: [n=0] 
[10:31:29.219] List of 1
[10:31:29.219]  $ ...: list()
[10:31:29.219]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:29.219]  - attr(*, "where")=List of 1
[10:31:29.219]   ..$ ...:<environment: 0x55de867406b8> 
[10:31:29.219]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:29.219]  - attr(*, "resolved")= logi TRUE
[10:31:29.219]  - attr(*, "total_size")= num NA
[10:31:29.221]  - Getting '...' globals ... DONE
[10:31:29.222] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:29.222] List of 8
[10:31:29.222]  $ ...future.FUN:function (x, ...)  
[10:31:29.222]  $ x_FUN        :function (x, na.rm = TRUE)  
[10:31:29.222]  $ times        : int 5
[10:31:29.222]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:29.222]  $ stop_if_not  :function (...)  
[10:31:29.222]  $ dim          : NULL
[10:31:29.222]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:29.222]  $ ...          : list()
[10:31:29.222]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:29.222]  - attr(*, "where")=List of 8
[10:31:29.222]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:29.222]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:29.222]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:29.222]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:29.222]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:29.222]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:29.222]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:29.222]   ..$ ...          :<environment: 0x55de867406b8> 
[10:31:29.222]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:29.222]  - attr(*, "resolved")= logi FALSE
[10:31:29.222]  - attr(*, "total_size")= num 141240
[10:31:29.227] Packages to be attached in all futures: [n=2] ‘stats’, ‘future.apply’
[10:31:29.227] getGlobalsAndPackagesXApply() ... DONE
[10:31:29.227] Number of futures (= number of chunks): 2
[10:31:29.227] Launching 2 futures (chunks) ...
[10:31:29.227] Chunk #1 of 2 ...
[10:31:29.228]  - Finding globals in 'X' for chunk #1 ...
[10:31:29.228] getGlobalsAndPackages() ...
[10:31:29.228] Searching for globals...
[10:31:29.228] 
[10:31:29.228] Searching for globals ... DONE
[10:31:29.228] - globals: [0] <none>
[10:31:29.228] getGlobalsAndPackages() ... DONE
[10:31:29.228]    + additional globals found: [n=0] 
[10:31:29.229]    + additional namespaces needed: [n=0] 
[10:31:29.229]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:29.229]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:29.229]  - seeds: <none>
[10:31:29.229]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.229] getGlobalsAndPackages() ...
[10:31:29.229] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.229] Resolving globals: FALSE
[10:31:29.230] Tweak future expression to call with '...' arguments ...
[10:31:29.230] {
[10:31:29.230]     do.call(function(...) {
[10:31:29.230]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.230]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.230]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.230]             on.exit(options(oopts), add = TRUE)
[10:31:29.230]         }
[10:31:29.230]         {
[10:31:29.230]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.230]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.230]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.230]             })
[10:31:29.230]         }
[10:31:29.230]     }, args = future.call.arguments)
[10:31:29.230] }
[10:31:29.230] Tweak future expression to call with '...' arguments ... DONE
[10:31:29.230] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.230] - packages: [2] ‘stats’, ‘future.apply’
[10:31:29.231] getGlobalsAndPackages() ... DONE
[10:31:29.231] run() for ‘Future’ ...
[10:31:29.231] - state: ‘created’
[10:31:29.231] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:29.245] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.245] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:29.245]   - Field: ‘node’
[10:31:29.245]   - Field: ‘label’
[10:31:29.245]   - Field: ‘local’
[10:31:29.245]   - Field: ‘owner’
[10:31:29.246]   - Field: ‘envir’
[10:31:29.246]   - Field: ‘workers’
[10:31:29.246]   - Field: ‘packages’
[10:31:29.246]   - Field: ‘gc’
[10:31:29.246]   - Field: ‘conditions’
[10:31:29.246]   - Field: ‘persistent’
[10:31:29.246]   - Field: ‘expr’
[10:31:29.246]   - Field: ‘uuid’
[10:31:29.246]   - Field: ‘seed’
[10:31:29.246]   - Field: ‘version’
[10:31:29.247]   - Field: ‘result’
[10:31:29.247]   - Field: ‘asynchronous’
[10:31:29.247]   - Field: ‘calls’
[10:31:29.247]   - Field: ‘globals’
[10:31:29.247]   - Field: ‘stdout’
[10:31:29.247]   - Field: ‘earlySignal’
[10:31:29.247]   - Field: ‘lazy’
[10:31:29.247]   - Field: ‘state’
[10:31:29.247] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:29.247] - Launch lazy future ...
[10:31:29.248] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:31:29.248] Packages needed by future strategies (n = 0): <none>
[10:31:29.248] {
[10:31:29.248]     {
[10:31:29.248]         {
[10:31:29.248]             ...future.startTime <- base::Sys.time()
[10:31:29.248]             {
[10:31:29.248]                 {
[10:31:29.248]                   {
[10:31:29.248]                     {
[10:31:29.248]                       {
[10:31:29.248]                         base::local({
[10:31:29.248]                           has_future <- base::requireNamespace("future", 
[10:31:29.248]                             quietly = TRUE)
[10:31:29.248]                           if (has_future) {
[10:31:29.248]                             ns <- base::getNamespace("future")
[10:31:29.248]                             version <- ns[[".package"]][["version"]]
[10:31:29.248]                             if (is.null(version)) 
[10:31:29.248]                               version <- utils::packageVersion("future")
[10:31:29.248]                           }
[10:31:29.248]                           else {
[10:31:29.248]                             version <- NULL
[10:31:29.248]                           }
[10:31:29.248]                           if (!has_future || version < "1.8.0") {
[10:31:29.248]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:29.248]                               "", base::R.version$version.string), 
[10:31:29.248]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:29.248]                                 base::R.version$platform, 8 * 
[10:31:29.248]                                   base::.Machine$sizeof.pointer), 
[10:31:29.248]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:29.248]                                 "release", "version")], collapse = " "), 
[10:31:29.248]                               hostname = base::Sys.info()[["nodename"]])
[10:31:29.248]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:29.248]                               info)
[10:31:29.248]                             info <- base::paste(info, collapse = "; ")
[10:31:29.248]                             if (!has_future) {
[10:31:29.248]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:29.248]                                 info)
[10:31:29.248]                             }
[10:31:29.248]                             else {
[10:31:29.248]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:29.248]                                 info, version)
[10:31:29.248]                             }
[10:31:29.248]                             base::stop(msg)
[10:31:29.248]                           }
[10:31:29.248]                         })
[10:31:29.248]                       }
[10:31:29.248]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:29.248]                       base::options(mc.cores = 1L)
[10:31:29.248]                     }
[10:31:29.248]                     base::local({
[10:31:29.248]                       for (pkg in c("stats", "future.apply")) {
[10:31:29.248]                         base::loadNamespace(pkg)
[10:31:29.248]                         base::library(pkg, character.only = TRUE)
[10:31:29.248]                       }
[10:31:29.248]                     })
[10:31:29.248]                   }
[10:31:29.248]                   ...future.strategy.old <- future::plan("list")
[10:31:29.248]                   options(future.plan = NULL)
[10:31:29.248]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.248]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:29.248]                 }
[10:31:29.248]                 ...future.workdir <- getwd()
[10:31:29.248]             }
[10:31:29.248]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:29.248]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:29.248]         }
[10:31:29.248]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:29.248]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:29.248]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:29.248]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:29.248]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:29.248]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:29.248]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:29.248]             base::names(...future.oldOptions))
[10:31:29.248]     }
[10:31:29.248]     if (FALSE) {
[10:31:29.248]     }
[10:31:29.248]     else {
[10:31:29.248]         if (TRUE) {
[10:31:29.248]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:29.248]                 open = "w")
[10:31:29.248]         }
[10:31:29.248]         else {
[10:31:29.248]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:29.248]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:29.248]         }
[10:31:29.248]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:29.248]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:29.248]             base::sink(type = "output", split = FALSE)
[10:31:29.248]             base::close(...future.stdout)
[10:31:29.248]         }, add = TRUE)
[10:31:29.248]     }
[10:31:29.248]     ...future.frame <- base::sys.nframe()
[10:31:29.248]     ...future.conditions <- base::list()
[10:31:29.248]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:29.248]     if (FALSE) {
[10:31:29.248]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:29.248]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:29.248]     }
[10:31:29.248]     ...future.result <- base::tryCatch({
[10:31:29.248]         base::withCallingHandlers({
[10:31:29.248]             ...future.value <- base::withVisible(base::local({
[10:31:29.248]                 ...future.makeSendCondition <- base::local({
[10:31:29.248]                   sendCondition <- NULL
[10:31:29.248]                   function(frame = 1L) {
[10:31:29.248]                     if (is.function(sendCondition)) 
[10:31:29.248]                       return(sendCondition)
[10:31:29.248]                     ns <- getNamespace("parallel")
[10:31:29.248]                     if (exists("sendData", mode = "function", 
[10:31:29.248]                       envir = ns)) {
[10:31:29.248]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:29.248]                         envir = ns)
[10:31:29.248]                       envir <- sys.frame(frame)
[10:31:29.248]                       master <- NULL
[10:31:29.248]                       while (!identical(envir, .GlobalEnv) && 
[10:31:29.248]                         !identical(envir, emptyenv())) {
[10:31:29.248]                         if (exists("master", mode = "list", envir = envir, 
[10:31:29.248]                           inherits = FALSE)) {
[10:31:29.248]                           master <- get("master", mode = "list", 
[10:31:29.248]                             envir = envir, inherits = FALSE)
[10:31:29.248]                           if (inherits(master, c("SOCKnode", 
[10:31:29.248]                             "SOCK0node"))) {
[10:31:29.248]                             sendCondition <<- function(cond) {
[10:31:29.248]                               data <- list(type = "VALUE", value = cond, 
[10:31:29.248]                                 success = TRUE)
[10:31:29.248]                               parallel_sendData(master, data)
[10:31:29.248]                             }
[10:31:29.248]                             return(sendCondition)
[10:31:29.248]                           }
[10:31:29.248]                         }
[10:31:29.248]                         frame <- frame + 1L
[10:31:29.248]                         envir <- sys.frame(frame)
[10:31:29.248]                       }
[10:31:29.248]                     }
[10:31:29.248]                     sendCondition <<- function(cond) NULL
[10:31:29.248]                   }
[10:31:29.248]                 })
[10:31:29.248]                 withCallingHandlers({
[10:31:29.248]                   {
[10:31:29.248]                     do.call(function(...) {
[10:31:29.248]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.248]                       if (!identical(...future.globals.maxSize.org, 
[10:31:29.248]                         ...future.globals.maxSize)) {
[10:31:29.248]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.248]                         on.exit(options(oopts), add = TRUE)
[10:31:29.248]                       }
[10:31:29.248]                       {
[10:31:29.248]                         lapply(seq_along(...future.elements_ii), 
[10:31:29.248]                           FUN = function(jj) {
[10:31:29.248]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.248]                             ...future.FUN(...future.X_jj, ...)
[10:31:29.248]                           })
[10:31:29.248]                       }
[10:31:29.248]                     }, args = future.call.arguments)
[10:31:29.248]                   }
[10:31:29.248]                 }, immediateCondition = function(cond) {
[10:31:29.248]                   sendCondition <- ...future.makeSendCondition()
[10:31:29.248]                   sendCondition(cond)
[10:31:29.248]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.248]                   {
[10:31:29.248]                     inherits <- base::inherits
[10:31:29.248]                     invokeRestart <- base::invokeRestart
[10:31:29.248]                     is.null <- base::is.null
[10:31:29.248]                     muffled <- FALSE
[10:31:29.248]                     if (inherits(cond, "message")) {
[10:31:29.248]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:29.248]                       if (muffled) 
[10:31:29.248]                         invokeRestart("muffleMessage")
[10:31:29.248]                     }
[10:31:29.248]                     else if (inherits(cond, "warning")) {
[10:31:29.248]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:29.248]                       if (muffled) 
[10:31:29.248]                         invokeRestart("muffleWarning")
[10:31:29.248]                     }
[10:31:29.248]                     else if (inherits(cond, "condition")) {
[10:31:29.248]                       if (!is.null(pattern)) {
[10:31:29.248]                         computeRestarts <- base::computeRestarts
[10:31:29.248]                         grepl <- base::grepl
[10:31:29.248]                         restarts <- computeRestarts(cond)
[10:31:29.248]                         for (restart in restarts) {
[10:31:29.248]                           name <- restart$name
[10:31:29.248]                           if (is.null(name)) 
[10:31:29.248]                             next
[10:31:29.248]                           if (!grepl(pattern, name)) 
[10:31:29.248]                             next
[10:31:29.248]                           invokeRestart(restart)
[10:31:29.248]                           muffled <- TRUE
[10:31:29.248]                           break
[10:31:29.248]                         }
[10:31:29.248]                       }
[10:31:29.248]                     }
[10:31:29.248]                     invisible(muffled)
[10:31:29.248]                   }
[10:31:29.248]                   muffleCondition(cond)
[10:31:29.248]                 })
[10:31:29.248]             }))
[10:31:29.248]             future::FutureResult(value = ...future.value$value, 
[10:31:29.248]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.248]                   ...future.rng), globalenv = if (FALSE) 
[10:31:29.248]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:29.248]                     ...future.globalenv.names))
[10:31:29.248]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:29.248]         }, condition = base::local({
[10:31:29.248]             c <- base::c
[10:31:29.248]             inherits <- base::inherits
[10:31:29.248]             invokeRestart <- base::invokeRestart
[10:31:29.248]             length <- base::length
[10:31:29.248]             list <- base::list
[10:31:29.248]             seq.int <- base::seq.int
[10:31:29.248]             signalCondition <- base::signalCondition
[10:31:29.248]             sys.calls <- base::sys.calls
[10:31:29.248]             `[[` <- base::`[[`
[10:31:29.248]             `+` <- base::`+`
[10:31:29.248]             `<<-` <- base::`<<-`
[10:31:29.248]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:29.248]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:29.248]                   3L)]
[10:31:29.248]             }
[10:31:29.248]             function(cond) {
[10:31:29.248]                 is_error <- inherits(cond, "error")
[10:31:29.248]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:29.248]                   NULL)
[10:31:29.248]                 if (is_error) {
[10:31:29.248]                   sessionInformation <- function() {
[10:31:29.248]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:29.248]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:29.248]                       search = base::search(), system = base::Sys.info())
[10:31:29.248]                   }
[10:31:29.248]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.248]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:29.248]                     cond$call), session = sessionInformation(), 
[10:31:29.248]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:29.248]                   signalCondition(cond)
[10:31:29.248]                 }
[10:31:29.248]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:29.248]                 "immediateCondition"))) {
[10:31:29.248]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:29.248]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.248]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:29.248]                   if (TRUE && !signal) {
[10:31:29.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.248]                     {
[10:31:29.248]                       inherits <- base::inherits
[10:31:29.248]                       invokeRestart <- base::invokeRestart
[10:31:29.248]                       is.null <- base::is.null
[10:31:29.248]                       muffled <- FALSE
[10:31:29.248]                       if (inherits(cond, "message")) {
[10:31:29.248]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.248]                         if (muffled) 
[10:31:29.248]                           invokeRestart("muffleMessage")
[10:31:29.248]                       }
[10:31:29.248]                       else if (inherits(cond, "warning")) {
[10:31:29.248]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.248]                         if (muffled) 
[10:31:29.248]                           invokeRestart("muffleWarning")
[10:31:29.248]                       }
[10:31:29.248]                       else if (inherits(cond, "condition")) {
[10:31:29.248]                         if (!is.null(pattern)) {
[10:31:29.248]                           computeRestarts <- base::computeRestarts
[10:31:29.248]                           grepl <- base::grepl
[10:31:29.248]                           restarts <- computeRestarts(cond)
[10:31:29.248]                           for (restart in restarts) {
[10:31:29.248]                             name <- restart$name
[10:31:29.248]                             if (is.null(name)) 
[10:31:29.248]                               next
[10:31:29.248]                             if (!grepl(pattern, name)) 
[10:31:29.248]                               next
[10:31:29.248]                             invokeRestart(restart)
[10:31:29.248]                             muffled <- TRUE
[10:31:29.248]                             break
[10:31:29.248]                           }
[10:31:29.248]                         }
[10:31:29.248]                       }
[10:31:29.248]                       invisible(muffled)
[10:31:29.248]                     }
[10:31:29.248]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.248]                   }
[10:31:29.248]                 }
[10:31:29.248]                 else {
[10:31:29.248]                   if (TRUE) {
[10:31:29.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.248]                     {
[10:31:29.248]                       inherits <- base::inherits
[10:31:29.248]                       invokeRestart <- base::invokeRestart
[10:31:29.248]                       is.null <- base::is.null
[10:31:29.248]                       muffled <- FALSE
[10:31:29.248]                       if (inherits(cond, "message")) {
[10:31:29.248]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.248]                         if (muffled) 
[10:31:29.248]                           invokeRestart("muffleMessage")
[10:31:29.248]                       }
[10:31:29.248]                       else if (inherits(cond, "warning")) {
[10:31:29.248]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.248]                         if (muffled) 
[10:31:29.248]                           invokeRestart("muffleWarning")
[10:31:29.248]                       }
[10:31:29.248]                       else if (inherits(cond, "condition")) {
[10:31:29.248]                         if (!is.null(pattern)) {
[10:31:29.248]                           computeRestarts <- base::computeRestarts
[10:31:29.248]                           grepl <- base::grepl
[10:31:29.248]                           restarts <- computeRestarts(cond)
[10:31:29.248]                           for (restart in restarts) {
[10:31:29.248]                             name <- restart$name
[10:31:29.248]                             if (is.null(name)) 
[10:31:29.248]                               next
[10:31:29.248]                             if (!grepl(pattern, name)) 
[10:31:29.248]                               next
[10:31:29.248]                             invokeRestart(restart)
[10:31:29.248]                             muffled <- TRUE
[10:31:29.248]                             break
[10:31:29.248]                           }
[10:31:29.248]                         }
[10:31:29.248]                       }
[10:31:29.248]                       invisible(muffled)
[10:31:29.248]                     }
[10:31:29.248]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.248]                   }
[10:31:29.248]                 }
[10:31:29.248]             }
[10:31:29.248]         }))
[10:31:29.248]     }, error = function(ex) {
[10:31:29.248]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:29.248]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.248]                 ...future.rng), started = ...future.startTime, 
[10:31:29.248]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:29.248]             version = "1.8"), class = "FutureResult")
[10:31:29.248]     }, finally = {
[10:31:29.248]         if (!identical(...future.workdir, getwd())) 
[10:31:29.248]             setwd(...future.workdir)
[10:31:29.248]         {
[10:31:29.248]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:29.248]                 ...future.oldOptions$nwarnings <- NULL
[10:31:29.248]             }
[10:31:29.248]             base::options(...future.oldOptions)
[10:31:29.248]             if (.Platform$OS.type == "windows") {
[10:31:29.248]                 old_names <- names(...future.oldEnvVars)
[10:31:29.248]                 envs <- base::Sys.getenv()
[10:31:29.248]                 names <- names(envs)
[10:31:29.248]                 common <- intersect(names, old_names)
[10:31:29.248]                 added <- setdiff(names, old_names)
[10:31:29.248]                 removed <- setdiff(old_names, names)
[10:31:29.248]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:29.248]                   envs[common]]
[10:31:29.248]                 NAMES <- toupper(changed)
[10:31:29.248]                 args <- list()
[10:31:29.248]                 for (kk in seq_along(NAMES)) {
[10:31:29.248]                   name <- changed[[kk]]
[10:31:29.248]                   NAME <- NAMES[[kk]]
[10:31:29.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.248]                     next
[10:31:29.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.248]                 }
[10:31:29.248]                 NAMES <- toupper(added)
[10:31:29.248]                 for (kk in seq_along(NAMES)) {
[10:31:29.248]                   name <- added[[kk]]
[10:31:29.248]                   NAME <- NAMES[[kk]]
[10:31:29.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.248]                     next
[10:31:29.248]                   args[[name]] <- ""
[10:31:29.248]                 }
[10:31:29.248]                 NAMES <- toupper(removed)
[10:31:29.248]                 for (kk in seq_along(NAMES)) {
[10:31:29.248]                   name <- removed[[kk]]
[10:31:29.248]                   NAME <- NAMES[[kk]]
[10:31:29.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.248]                     next
[10:31:29.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.248]                 }
[10:31:29.248]                 if (length(args) > 0) 
[10:31:29.248]                   base::do.call(base::Sys.setenv, args = args)
[10:31:29.248]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:29.248]             }
[10:31:29.248]             else {
[10:31:29.248]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:29.248]             }
[10:31:29.248]             {
[10:31:29.248]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:29.248]                   0L) {
[10:31:29.248]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:29.248]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:29.248]                   base::options(opts)
[10:31:29.248]                 }
[10:31:29.248]                 {
[10:31:29.248]                   {
[10:31:29.248]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:29.248]                     NULL
[10:31:29.248]                   }
[10:31:29.248]                   options(future.plan = NULL)
[10:31:29.248]                   if (is.na(NA_character_)) 
[10:31:29.248]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.248]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:29.248]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:29.248]                     .init = FALSE)
[10:31:29.248]                 }
[10:31:29.248]             }
[10:31:29.248]         }
[10:31:29.248]     })
[10:31:29.248]     if (TRUE) {
[10:31:29.248]         base::sink(type = "output", split = FALSE)
[10:31:29.248]         if (TRUE) {
[10:31:29.248]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:29.248]         }
[10:31:29.248]         else {
[10:31:29.248]             ...future.result["stdout"] <- base::list(NULL)
[10:31:29.248]         }
[10:31:29.248]         base::close(...future.stdout)
[10:31:29.248]         ...future.stdout <- NULL
[10:31:29.248]     }
[10:31:29.248]     ...future.result$conditions <- ...future.conditions
[10:31:29.248]     ...future.result$finished <- base::Sys.time()
[10:31:29.248]     ...future.result
[10:31:29.248] }
[10:31:29.251] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[10:31:29.251] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:29.293] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:29.293] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[10:31:29.337] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[10:31:29.337] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:29.338] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:29.338] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:29.381] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:29.381] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:29.425] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:29.425] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:29.426] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.426] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:31:29.426] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:31:29.426] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:29.427] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.427] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ...
[10:31:29.427] Exporting ‘...future.elements_ii’ (288 bytes) to cluster node #1 ... DONE
[10:31:29.427] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:29.428] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.428] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:29.428] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.428] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[10:31:29.429] MultisessionFuture started
[10:31:29.429] - Launch lazy future ... done
[10:31:29.429] run() for ‘MultisessionFuture’ ... done
[10:31:29.429] Created future:
[10:31:29.433] receiveMessageFromWorker() for ClusterFuture ...
[10:31:29.433] - Validating connection of MultisessionFuture
[10:31:29.433] - received message: FutureResult
[10:31:29.433] - Received FutureResult
[10:31:29.433] - Erased future from FutureRegistry
[10:31:29.433] result() for ClusterFuture ...
[10:31:29.434] - result already collected: FutureResult
[10:31:29.434] result() for ClusterFuture ... done
[10:31:29.434] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:29.429] MultisessionFuture:
[10:31:29.429] Label: ‘future_vapply-1’
[10:31:29.429] Expression:
[10:31:29.429] {
[10:31:29.429]     do.call(function(...) {
[10:31:29.429]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.429]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.429]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.429]             on.exit(options(oopts), add = TRUE)
[10:31:29.429]         }
[10:31:29.429]         {
[10:31:29.429]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.429]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.429]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.429]             })
[10:31:29.429]         }
[10:31:29.429]     }, args = future.call.arguments)
[10:31:29.429] }
[10:31:29.429] Lazy evaluation: FALSE
[10:31:29.429] Asynchronous evaluation: TRUE
[10:31:29.429] Local evaluation: TRUE
[10:31:29.429] Environment: R_GlobalEnv
[10:31:29.429] Capture standard output: TRUE
[10:31:29.429] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:29.429] Globals: 11 objects totaling 138.21 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:29.429] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:31:29.429] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:29.429] Resolved: TRUE
[10:31:29.429] Value: <not collected>
[10:31:29.429] Conditions captured: <none>
[10:31:29.429] Early signaling: FALSE
[10:31:29.429] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:29.429] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.434] Chunk #1 of 2 ... DONE
[10:31:29.434] Chunk #2 of 2 ...
[10:31:29.434]  - Finding globals in 'X' for chunk #2 ...
[10:31:29.434] getGlobalsAndPackages() ...
[10:31:29.434] Searching for globals...
[10:31:29.435] 
[10:31:29.435] Searching for globals ... DONE
[10:31:29.435] - globals: [0] <none>
[10:31:29.435] getGlobalsAndPackages() ... DONE
[10:31:29.435]    + additional globals found: [n=0] 
[10:31:29.435]    + additional namespaces needed: [n=0] 
[10:31:29.435]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:29.435]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:29.435]  - seeds: <none>
[10:31:29.436]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.436] getGlobalsAndPackages() ...
[10:31:29.436] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.436] Resolving globals: FALSE
[10:31:29.436] Tweak future expression to call with '...' arguments ...
[10:31:29.436] {
[10:31:29.436]     do.call(function(...) {
[10:31:29.436]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.436]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.436]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.436]             on.exit(options(oopts), add = TRUE)
[10:31:29.436]         }
[10:31:29.436]         {
[10:31:29.436]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.436]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.436]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.436]             })
[10:31:29.436]         }
[10:31:29.436]     }, args = future.call.arguments)
[10:31:29.436] }
[10:31:29.436] Tweak future expression to call with '...' arguments ... DONE
[10:31:29.437] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.437] - packages: [2] ‘stats’, ‘future.apply’
[10:31:29.437] getGlobalsAndPackages() ... DONE
[10:31:29.437] run() for ‘Future’ ...
[10:31:29.438] - state: ‘created’
[10:31:29.438] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:29.452] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:29.452]   - Field: ‘node’
[10:31:29.452]   - Field: ‘label’
[10:31:29.452]   - Field: ‘local’
[10:31:29.452]   - Field: ‘owner’
[10:31:29.452]   - Field: ‘envir’
[10:31:29.453]   - Field: ‘workers’
[10:31:29.453]   - Field: ‘packages’
[10:31:29.453]   - Field: ‘gc’
[10:31:29.453]   - Field: ‘conditions’
[10:31:29.453]   - Field: ‘persistent’
[10:31:29.453]   - Field: ‘expr’
[10:31:29.453]   - Field: ‘uuid’
[10:31:29.453]   - Field: ‘seed’
[10:31:29.453]   - Field: ‘version’
[10:31:29.453]   - Field: ‘result’
[10:31:29.453]   - Field: ‘asynchronous’
[10:31:29.454]   - Field: ‘calls’
[10:31:29.454]   - Field: ‘globals’
[10:31:29.454]   - Field: ‘stdout’
[10:31:29.454]   - Field: ‘earlySignal’
[10:31:29.454]   - Field: ‘lazy’
[10:31:29.454]   - Field: ‘state’
[10:31:29.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:29.454] - Launch lazy future ...
[10:31:29.454] Packages needed by the future expression (n = 2): ‘stats’, ‘future.apply’
[10:31:29.455] Packages needed by future strategies (n = 0): <none>
[10:31:29.455] {
[10:31:29.455]     {
[10:31:29.455]         {
[10:31:29.455]             ...future.startTime <- base::Sys.time()
[10:31:29.455]             {
[10:31:29.455]                 {
[10:31:29.455]                   {
[10:31:29.455]                     {
[10:31:29.455]                       {
[10:31:29.455]                         base::local({
[10:31:29.455]                           has_future <- base::requireNamespace("future", 
[10:31:29.455]                             quietly = TRUE)
[10:31:29.455]                           if (has_future) {
[10:31:29.455]                             ns <- base::getNamespace("future")
[10:31:29.455]                             version <- ns[[".package"]][["version"]]
[10:31:29.455]                             if (is.null(version)) 
[10:31:29.455]                               version <- utils::packageVersion("future")
[10:31:29.455]                           }
[10:31:29.455]                           else {
[10:31:29.455]                             version <- NULL
[10:31:29.455]                           }
[10:31:29.455]                           if (!has_future || version < "1.8.0") {
[10:31:29.455]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:29.455]                               "", base::R.version$version.string), 
[10:31:29.455]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:29.455]                                 base::R.version$platform, 8 * 
[10:31:29.455]                                   base::.Machine$sizeof.pointer), 
[10:31:29.455]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:29.455]                                 "release", "version")], collapse = " "), 
[10:31:29.455]                               hostname = base::Sys.info()[["nodename"]])
[10:31:29.455]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:29.455]                               info)
[10:31:29.455]                             info <- base::paste(info, collapse = "; ")
[10:31:29.455]                             if (!has_future) {
[10:31:29.455]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:29.455]                                 info)
[10:31:29.455]                             }
[10:31:29.455]                             else {
[10:31:29.455]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:29.455]                                 info, version)
[10:31:29.455]                             }
[10:31:29.455]                             base::stop(msg)
[10:31:29.455]                           }
[10:31:29.455]                         })
[10:31:29.455]                       }
[10:31:29.455]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:29.455]                       base::options(mc.cores = 1L)
[10:31:29.455]                     }
[10:31:29.455]                     base::local({
[10:31:29.455]                       for (pkg in c("stats", "future.apply")) {
[10:31:29.455]                         base::loadNamespace(pkg)
[10:31:29.455]                         base::library(pkg, character.only = TRUE)
[10:31:29.455]                       }
[10:31:29.455]                     })
[10:31:29.455]                   }
[10:31:29.455]                   ...future.strategy.old <- future::plan("list")
[10:31:29.455]                   options(future.plan = NULL)
[10:31:29.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:29.455]                 }
[10:31:29.455]                 ...future.workdir <- getwd()
[10:31:29.455]             }
[10:31:29.455]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:29.455]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:29.455]         }
[10:31:29.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:29.455]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:29.455]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:29.455]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:29.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:29.455]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:29.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:29.455]             base::names(...future.oldOptions))
[10:31:29.455]     }
[10:31:29.455]     if (FALSE) {
[10:31:29.455]     }
[10:31:29.455]     else {
[10:31:29.455]         if (TRUE) {
[10:31:29.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:29.455]                 open = "w")
[10:31:29.455]         }
[10:31:29.455]         else {
[10:31:29.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:29.455]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:29.455]         }
[10:31:29.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:29.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:29.455]             base::sink(type = "output", split = FALSE)
[10:31:29.455]             base::close(...future.stdout)
[10:31:29.455]         }, add = TRUE)
[10:31:29.455]     }
[10:31:29.455]     ...future.frame <- base::sys.nframe()
[10:31:29.455]     ...future.conditions <- base::list()
[10:31:29.455]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:29.455]     if (FALSE) {
[10:31:29.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:29.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:29.455]     }
[10:31:29.455]     ...future.result <- base::tryCatch({
[10:31:29.455]         base::withCallingHandlers({
[10:31:29.455]             ...future.value <- base::withVisible(base::local({
[10:31:29.455]                 ...future.makeSendCondition <- base::local({
[10:31:29.455]                   sendCondition <- NULL
[10:31:29.455]                   function(frame = 1L) {
[10:31:29.455]                     if (is.function(sendCondition)) 
[10:31:29.455]                       return(sendCondition)
[10:31:29.455]                     ns <- getNamespace("parallel")
[10:31:29.455]                     if (exists("sendData", mode = "function", 
[10:31:29.455]                       envir = ns)) {
[10:31:29.455]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:29.455]                         envir = ns)
[10:31:29.455]                       envir <- sys.frame(frame)
[10:31:29.455]                       master <- NULL
[10:31:29.455]                       while (!identical(envir, .GlobalEnv) && 
[10:31:29.455]                         !identical(envir, emptyenv())) {
[10:31:29.455]                         if (exists("master", mode = "list", envir = envir, 
[10:31:29.455]                           inherits = FALSE)) {
[10:31:29.455]                           master <- get("master", mode = "list", 
[10:31:29.455]                             envir = envir, inherits = FALSE)
[10:31:29.455]                           if (inherits(master, c("SOCKnode", 
[10:31:29.455]                             "SOCK0node"))) {
[10:31:29.455]                             sendCondition <<- function(cond) {
[10:31:29.455]                               data <- list(type = "VALUE", value = cond, 
[10:31:29.455]                                 success = TRUE)
[10:31:29.455]                               parallel_sendData(master, data)
[10:31:29.455]                             }
[10:31:29.455]                             return(sendCondition)
[10:31:29.455]                           }
[10:31:29.455]                         }
[10:31:29.455]                         frame <- frame + 1L
[10:31:29.455]                         envir <- sys.frame(frame)
[10:31:29.455]                       }
[10:31:29.455]                     }
[10:31:29.455]                     sendCondition <<- function(cond) NULL
[10:31:29.455]                   }
[10:31:29.455]                 })
[10:31:29.455]                 withCallingHandlers({
[10:31:29.455]                   {
[10:31:29.455]                     do.call(function(...) {
[10:31:29.455]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.455]                       if (!identical(...future.globals.maxSize.org, 
[10:31:29.455]                         ...future.globals.maxSize)) {
[10:31:29.455]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.455]                         on.exit(options(oopts), add = TRUE)
[10:31:29.455]                       }
[10:31:29.455]                       {
[10:31:29.455]                         lapply(seq_along(...future.elements_ii), 
[10:31:29.455]                           FUN = function(jj) {
[10:31:29.455]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.455]                             ...future.FUN(...future.X_jj, ...)
[10:31:29.455]                           })
[10:31:29.455]                       }
[10:31:29.455]                     }, args = future.call.arguments)
[10:31:29.455]                   }
[10:31:29.455]                 }, immediateCondition = function(cond) {
[10:31:29.455]                   sendCondition <- ...future.makeSendCondition()
[10:31:29.455]                   sendCondition(cond)
[10:31:29.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.455]                   {
[10:31:29.455]                     inherits <- base::inherits
[10:31:29.455]                     invokeRestart <- base::invokeRestart
[10:31:29.455]                     is.null <- base::is.null
[10:31:29.455]                     muffled <- FALSE
[10:31:29.455]                     if (inherits(cond, "message")) {
[10:31:29.455]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:29.455]                       if (muffled) 
[10:31:29.455]                         invokeRestart("muffleMessage")
[10:31:29.455]                     }
[10:31:29.455]                     else if (inherits(cond, "warning")) {
[10:31:29.455]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:29.455]                       if (muffled) 
[10:31:29.455]                         invokeRestart("muffleWarning")
[10:31:29.455]                     }
[10:31:29.455]                     else if (inherits(cond, "condition")) {
[10:31:29.455]                       if (!is.null(pattern)) {
[10:31:29.455]                         computeRestarts <- base::computeRestarts
[10:31:29.455]                         grepl <- base::grepl
[10:31:29.455]                         restarts <- computeRestarts(cond)
[10:31:29.455]                         for (restart in restarts) {
[10:31:29.455]                           name <- restart$name
[10:31:29.455]                           if (is.null(name)) 
[10:31:29.455]                             next
[10:31:29.455]                           if (!grepl(pattern, name)) 
[10:31:29.455]                             next
[10:31:29.455]                           invokeRestart(restart)
[10:31:29.455]                           muffled <- TRUE
[10:31:29.455]                           break
[10:31:29.455]                         }
[10:31:29.455]                       }
[10:31:29.455]                     }
[10:31:29.455]                     invisible(muffled)
[10:31:29.455]                   }
[10:31:29.455]                   muffleCondition(cond)
[10:31:29.455]                 })
[10:31:29.455]             }))
[10:31:29.455]             future::FutureResult(value = ...future.value$value, 
[10:31:29.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.455]                   ...future.rng), globalenv = if (FALSE) 
[10:31:29.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:29.455]                     ...future.globalenv.names))
[10:31:29.455]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:29.455]         }, condition = base::local({
[10:31:29.455]             c <- base::c
[10:31:29.455]             inherits <- base::inherits
[10:31:29.455]             invokeRestart <- base::invokeRestart
[10:31:29.455]             length <- base::length
[10:31:29.455]             list <- base::list
[10:31:29.455]             seq.int <- base::seq.int
[10:31:29.455]             signalCondition <- base::signalCondition
[10:31:29.455]             sys.calls <- base::sys.calls
[10:31:29.455]             `[[` <- base::`[[`
[10:31:29.455]             `+` <- base::`+`
[10:31:29.455]             `<<-` <- base::`<<-`
[10:31:29.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:29.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:29.455]                   3L)]
[10:31:29.455]             }
[10:31:29.455]             function(cond) {
[10:31:29.455]                 is_error <- inherits(cond, "error")
[10:31:29.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:29.455]                   NULL)
[10:31:29.455]                 if (is_error) {
[10:31:29.455]                   sessionInformation <- function() {
[10:31:29.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:29.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:29.455]                       search = base::search(), system = base::Sys.info())
[10:31:29.455]                   }
[10:31:29.455]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:29.455]                     cond$call), session = sessionInformation(), 
[10:31:29.455]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:29.455]                   signalCondition(cond)
[10:31:29.455]                 }
[10:31:29.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:29.455]                 "immediateCondition"))) {
[10:31:29.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:29.455]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:29.455]                   if (TRUE && !signal) {
[10:31:29.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.455]                     {
[10:31:29.455]                       inherits <- base::inherits
[10:31:29.455]                       invokeRestart <- base::invokeRestart
[10:31:29.455]                       is.null <- base::is.null
[10:31:29.455]                       muffled <- FALSE
[10:31:29.455]                       if (inherits(cond, "message")) {
[10:31:29.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.455]                         if (muffled) 
[10:31:29.455]                           invokeRestart("muffleMessage")
[10:31:29.455]                       }
[10:31:29.455]                       else if (inherits(cond, "warning")) {
[10:31:29.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.455]                         if (muffled) 
[10:31:29.455]                           invokeRestart("muffleWarning")
[10:31:29.455]                       }
[10:31:29.455]                       else if (inherits(cond, "condition")) {
[10:31:29.455]                         if (!is.null(pattern)) {
[10:31:29.455]                           computeRestarts <- base::computeRestarts
[10:31:29.455]                           grepl <- base::grepl
[10:31:29.455]                           restarts <- computeRestarts(cond)
[10:31:29.455]                           for (restart in restarts) {
[10:31:29.455]                             name <- restart$name
[10:31:29.455]                             if (is.null(name)) 
[10:31:29.455]                               next
[10:31:29.455]                             if (!grepl(pattern, name)) 
[10:31:29.455]                               next
[10:31:29.455]                             invokeRestart(restart)
[10:31:29.455]                             muffled <- TRUE
[10:31:29.455]                             break
[10:31:29.455]                           }
[10:31:29.455]                         }
[10:31:29.455]                       }
[10:31:29.455]                       invisible(muffled)
[10:31:29.455]                     }
[10:31:29.455]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.455]                   }
[10:31:29.455]                 }
[10:31:29.455]                 else {
[10:31:29.455]                   if (TRUE) {
[10:31:29.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.455]                     {
[10:31:29.455]                       inherits <- base::inherits
[10:31:29.455]                       invokeRestart <- base::invokeRestart
[10:31:29.455]                       is.null <- base::is.null
[10:31:29.455]                       muffled <- FALSE
[10:31:29.455]                       if (inherits(cond, "message")) {
[10:31:29.455]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.455]                         if (muffled) 
[10:31:29.455]                           invokeRestart("muffleMessage")
[10:31:29.455]                       }
[10:31:29.455]                       else if (inherits(cond, "warning")) {
[10:31:29.455]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.455]                         if (muffled) 
[10:31:29.455]                           invokeRestart("muffleWarning")
[10:31:29.455]                       }
[10:31:29.455]                       else if (inherits(cond, "condition")) {
[10:31:29.455]                         if (!is.null(pattern)) {
[10:31:29.455]                           computeRestarts <- base::computeRestarts
[10:31:29.455]                           grepl <- base::grepl
[10:31:29.455]                           restarts <- computeRestarts(cond)
[10:31:29.455]                           for (restart in restarts) {
[10:31:29.455]                             name <- restart$name
[10:31:29.455]                             if (is.null(name)) 
[10:31:29.455]                               next
[10:31:29.455]                             if (!grepl(pattern, name)) 
[10:31:29.455]                               next
[10:31:29.455]                             invokeRestart(restart)
[10:31:29.455]                             muffled <- TRUE
[10:31:29.455]                             break
[10:31:29.455]                           }
[10:31:29.455]                         }
[10:31:29.455]                       }
[10:31:29.455]                       invisible(muffled)
[10:31:29.455]                     }
[10:31:29.455]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.455]                   }
[10:31:29.455]                 }
[10:31:29.455]             }
[10:31:29.455]         }))
[10:31:29.455]     }, error = function(ex) {
[10:31:29.455]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:29.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.455]                 ...future.rng), started = ...future.startTime, 
[10:31:29.455]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:29.455]             version = "1.8"), class = "FutureResult")
[10:31:29.455]     }, finally = {
[10:31:29.455]         if (!identical(...future.workdir, getwd())) 
[10:31:29.455]             setwd(...future.workdir)
[10:31:29.455]         {
[10:31:29.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:29.455]                 ...future.oldOptions$nwarnings <- NULL
[10:31:29.455]             }
[10:31:29.455]             base::options(...future.oldOptions)
[10:31:29.455]             if (.Platform$OS.type == "windows") {
[10:31:29.455]                 old_names <- names(...future.oldEnvVars)
[10:31:29.455]                 envs <- base::Sys.getenv()
[10:31:29.455]                 names <- names(envs)
[10:31:29.455]                 common <- intersect(names, old_names)
[10:31:29.455]                 added <- setdiff(names, old_names)
[10:31:29.455]                 removed <- setdiff(old_names, names)
[10:31:29.455]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:29.455]                   envs[common]]
[10:31:29.455]                 NAMES <- toupper(changed)
[10:31:29.455]                 args <- list()
[10:31:29.455]                 for (kk in seq_along(NAMES)) {
[10:31:29.455]                   name <- changed[[kk]]
[10:31:29.455]                   NAME <- NAMES[[kk]]
[10:31:29.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.455]                     next
[10:31:29.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.455]                 }
[10:31:29.455]                 NAMES <- toupper(added)
[10:31:29.455]                 for (kk in seq_along(NAMES)) {
[10:31:29.455]                   name <- added[[kk]]
[10:31:29.455]                   NAME <- NAMES[[kk]]
[10:31:29.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.455]                     next
[10:31:29.455]                   args[[name]] <- ""
[10:31:29.455]                 }
[10:31:29.455]                 NAMES <- toupper(removed)
[10:31:29.455]                 for (kk in seq_along(NAMES)) {
[10:31:29.455]                   name <- removed[[kk]]
[10:31:29.455]                   NAME <- NAMES[[kk]]
[10:31:29.455]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.455]                     next
[10:31:29.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.455]                 }
[10:31:29.455]                 if (length(args) > 0) 
[10:31:29.455]                   base::do.call(base::Sys.setenv, args = args)
[10:31:29.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:29.455]             }
[10:31:29.455]             else {
[10:31:29.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:29.455]             }
[10:31:29.455]             {
[10:31:29.455]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:29.455]                   0L) {
[10:31:29.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:29.455]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:29.455]                   base::options(opts)
[10:31:29.455]                 }
[10:31:29.455]                 {
[10:31:29.455]                   {
[10:31:29.455]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:29.455]                     NULL
[10:31:29.455]                   }
[10:31:29.455]                   options(future.plan = NULL)
[10:31:29.455]                   if (is.na(NA_character_)) 
[10:31:29.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:29.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:29.455]                     .init = FALSE)
[10:31:29.455]                 }
[10:31:29.455]             }
[10:31:29.455]         }
[10:31:29.455]     })
[10:31:29.455]     if (TRUE) {
[10:31:29.455]         base::sink(type = "output", split = FALSE)
[10:31:29.455]         if (TRUE) {
[10:31:29.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:29.455]         }
[10:31:29.455]         else {
[10:31:29.455]             ...future.result["stdout"] <- base::list(NULL)
[10:31:29.455]         }
[10:31:29.455]         base::close(...future.stdout)
[10:31:29.455]         ...future.stdout <- NULL
[10:31:29.455]     }
[10:31:29.455]     ...future.result$conditions <- ...future.conditions
[10:31:29.455]     ...future.result$finished <- base::Sys.time()
[10:31:29.455]     ...future.result
[10:31:29.455] }
[10:31:29.458] Exporting 11 global objects (137.93 KiB) to cluster node #1 ...
[10:31:29.458] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:29.501] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:29.501] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ...
[10:31:29.545] Exporting ‘x_FUN’ (45.86 KiB) to cluster node #1 ... DONE
[10:31:29.545] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:29.546] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:29.546] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:29.589] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:29.589] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:29.633] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:29.633] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:29.634] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.634] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:31:29.634] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:31:29.635] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:29.635] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.635] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #1 ...
[10:31:29.636] Exporting ‘...future.elements_ii’ (256 bytes) to cluster node #1 ... DONE
[10:31:29.636] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:29.636] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.637] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:29.637] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.637] Exporting 11 global objects (137.93 KiB) to cluster node #1 ... DONE
[10:31:29.640] MultisessionFuture started
[10:31:29.640] - Launch lazy future ... done
[10:31:29.640] run() for ‘MultisessionFuture’ ... done
[10:31:29.641] Created future:
[10:31:29.642] receiveMessageFromWorker() for ClusterFuture ...
[10:31:29.642] - Validating connection of MultisessionFuture
[10:31:29.643] - received message: FutureResult
[10:31:29.643] - Received FutureResult
[10:31:29.643] - Erased future from FutureRegistry
[10:31:29.643] result() for ClusterFuture ...
[10:31:29.643] - result already collected: FutureResult
[10:31:29.643] result() for ClusterFuture ... done
[10:31:29.643] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:29.641] MultisessionFuture:
[10:31:29.641] Label: ‘future_vapply-2’
[10:31:29.641] Expression:
[10:31:29.641] {
[10:31:29.641]     do.call(function(...) {
[10:31:29.641]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.641]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.641]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.641]             on.exit(options(oopts), add = TRUE)
[10:31:29.641]         }
[10:31:29.641]         {
[10:31:29.641]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.641]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.641]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.641]             })
[10:31:29.641]         }
[10:31:29.641]     }, args = future.call.arguments)
[10:31:29.641] }
[10:31:29.641] Lazy evaluation: FALSE
[10:31:29.641] Asynchronous evaluation: TRUE
[10:31:29.641] Local evaluation: TRUE
[10:31:29.641] Environment: R_GlobalEnv
[10:31:29.641] Capture standard output: TRUE
[10:31:29.641] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:29.641] Globals: 11 objects totaling 138.18 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 45.86 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:29.641] Packages: 2 packages (‘stats’, ‘future.apply’)
[10:31:29.641] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:29.641] Resolved: TRUE
[10:31:29.641] Value: <not collected>
[10:31:29.641] Conditions captured: <none>
[10:31:29.641] Early signaling: FALSE
[10:31:29.641] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:29.641] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.643] Chunk #2 of 2 ... DONE
[10:31:29.643] Launching 2 futures (chunks) ... DONE
[10:31:29.644] Resolving 2 futures (chunks) ...
[10:31:29.644] resolve() on list ...
[10:31:29.644]  recursive: 0
[10:31:29.644]  length: 2
[10:31:29.644] 
[10:31:29.644] Future #1
[10:31:29.644] result() for ClusterFuture ...
[10:31:29.644] - result already collected: FutureResult
[10:31:29.644] result() for ClusterFuture ... done
[10:31:29.644] result() for ClusterFuture ...
[10:31:29.645] - result already collected: FutureResult
[10:31:29.645] result() for ClusterFuture ... done
[10:31:29.645] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:29.645] - nx: 2
[10:31:29.645] - relay: TRUE
[10:31:29.645] - stdout: TRUE
[10:31:29.645] - signal: TRUE
[10:31:29.645] - resignal: FALSE
[10:31:29.645] - force: TRUE
[10:31:29.645] - relayed: [n=2] FALSE, FALSE
[10:31:29.645] - queued futures: [n=2] FALSE, FALSE
[10:31:29.646]  - until=1
[10:31:29.646]  - relaying element #1
[10:31:29.646] result() for ClusterFuture ...
[10:31:29.646] - result already collected: FutureResult
[10:31:29.646] result() for ClusterFuture ... done
[10:31:29.646] result() for ClusterFuture ...
[10:31:29.646] - result already collected: FutureResult
[10:31:29.646] result() for ClusterFuture ... done
[10:31:29.646] result() for ClusterFuture ...
[10:31:29.646] - result already collected: FutureResult
[10:31:29.646] result() for ClusterFuture ... done
[10:31:29.647] result() for ClusterFuture ...
[10:31:29.647] - result already collected: FutureResult
[10:31:29.647] result() for ClusterFuture ... done
[10:31:29.647] - relayed: [n=2] TRUE, FALSE
[10:31:29.647] - queued futures: [n=2] TRUE, FALSE
[10:31:29.647] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:29.647]  length: 1 (resolved future 1)
[10:31:29.647] Future #2
[10:31:29.647] result() for ClusterFuture ...
[10:31:29.647] - result already collected: FutureResult
[10:31:29.647] result() for ClusterFuture ... done
[10:31:29.648] result() for ClusterFuture ...
[10:31:29.648] - result already collected: FutureResult
[10:31:29.648] result() for ClusterFuture ... done
[10:31:29.648] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:29.648] - nx: 2
[10:31:29.648] - relay: TRUE
[10:31:29.648] - stdout: TRUE
[10:31:29.648] - signal: TRUE
[10:31:29.648] - resignal: FALSE
[10:31:29.648] - force: TRUE
[10:31:29.648] - relayed: [n=2] TRUE, FALSE
[10:31:29.648] - queued futures: [n=2] TRUE, FALSE
[10:31:29.649]  - until=2
[10:31:29.649]  - relaying element #2
[10:31:29.649] result() for ClusterFuture ...
[10:31:29.649] - result already collected: FutureResult
[10:31:29.649] result() for ClusterFuture ... done
[10:31:29.649] result() for ClusterFuture ...
[10:31:29.649] - result already collected: FutureResult
[10:31:29.649] result() for ClusterFuture ... done
[10:31:29.649] result() for ClusterFuture ...
[10:31:29.649] - result already collected: FutureResult
[10:31:29.649] result() for ClusterFuture ... done
[10:31:29.650] result() for ClusterFuture ...
[10:31:29.650] - result already collected: FutureResult
[10:31:29.650] result() for ClusterFuture ... done
[10:31:29.650] - relayed: [n=2] TRUE, TRUE
[10:31:29.650] - queued futures: [n=2] TRUE, TRUE
[10:31:29.650] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:29.650]  length: 0 (resolved future 2)
[10:31:29.650] Relaying remaining futures
[10:31:29.650] signalConditionsASAP(NULL, pos=0) ...
[10:31:29.650] - nx: 2
[10:31:29.650] - relay: TRUE
[10:31:29.650] - stdout: TRUE
[10:31:29.651] - signal: TRUE
[10:31:29.651] - resignal: FALSE
[10:31:29.651] - force: TRUE
[10:31:29.651] - relayed: [n=2] TRUE, TRUE
[10:31:29.651] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:29.651] - relayed: [n=2] TRUE, TRUE
[10:31:29.651] - queued futures: [n=2] TRUE, TRUE
[10:31:29.651] signalConditionsASAP(NULL, pos=0) ... done
[10:31:29.651] resolve() on list ... DONE
[10:31:29.651] result() for ClusterFuture ...
[10:31:29.651] - result already collected: FutureResult
[10:31:29.652] result() for ClusterFuture ... done
[10:31:29.652] result() for ClusterFuture ...
[10:31:29.652] - result already collected: FutureResult
[10:31:29.652] result() for ClusterFuture ... done
[10:31:29.652] result() for ClusterFuture ...
[10:31:29.652] - result already collected: FutureResult
[10:31:29.652] result() for ClusterFuture ... done
[10:31:29.652] result() for ClusterFuture ...
[10:31:29.652] - result already collected: FutureResult
[10:31:29.652] result() for ClusterFuture ... done
[10:31:29.652]  - Number of value chunks collected: 2
[10:31:29.653] Resolving 2 futures (chunks) ... DONE
[10:31:29.653] Reducing values from 2 chunks ...
[10:31:29.653]  - Number of values collected after concatenation: 7
[10:31:29.653]  - Number of values expected: 7
[10:31:29.653] Reducing values from 2 chunks ... DONE
[10:31:29.653] future_lapply() ... DONE
 num [1:5, 1:7] 1 1.5 2 2.5 3 1 1.5 2.5 3.5 4 ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:5] "Min." "1st Qu." "Median" "3rd Qu." ...
  ..$ : NULL
[10:31:29.655] future_lapply() ...
[10:31:29.659] Number of chunks: 2
[10:31:29.659] getGlobalsAndPackagesXApply() ...
[10:31:29.660]  - future.globals: TRUE
[10:31:29.660] getGlobalsAndPackages() ...
[10:31:29.660] Searching for globals...
[10:31:29.661] - globals found: [3] ‘FUN’, ‘outer’, ‘rep’
[10:31:29.661] Searching for globals ... DONE
[10:31:29.661] Resolving globals: FALSE
[10:31:29.662] The total size of the 1 globals is 4.07 KiB (4168 bytes)
[10:31:29.662] The total size of the 1 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 4.07 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘FUN’ (4.07 KiB of class ‘function’)
[10:31:29.662] - globals: [1] ‘FUN’
[10:31:29.662] 
[10:31:29.663] getGlobalsAndPackages() ... DONE
[10:31:29.663]  - globals found/used: [n=1] ‘FUN’
[10:31:29.663]  - needed namespaces: [n=0] 
[10:31:29.663] Finding globals ... DONE
[10:31:29.663]  - use_args: TRUE
[10:31:29.663]  - Getting '...' globals ...
[10:31:29.663] resolve() on list ...
[10:31:29.663]  recursive: 0
[10:31:29.664]  length: 1
[10:31:29.664]  elements: ‘...’
[10:31:29.664]  length: 0 (resolved future 1)
[10:31:29.664] resolve() on list ... DONE
[10:31:29.664]    - '...' content: [n=1] ‘y’
[10:31:29.664] List of 1
[10:31:29.664]  $ ...:List of 1
[10:31:29.664]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:29.664]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:29.664]  - attr(*, "where")=List of 1
[10:31:29.664]   ..$ ...:<environment: 0x55de842ca258> 
[10:31:29.664]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:29.664]  - attr(*, "resolved")= logi TRUE
[10:31:29.664]  - attr(*, "total_size")= num NA
[10:31:29.667]  - Getting '...' globals ... DONE
[10:31:29.667] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘...’
[10:31:29.667] List of 2
[10:31:29.667]  $ ...future.FUN:function (x, y)  
[10:31:29.667]  $ ...          :List of 1
[10:31:29.667]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:29.667]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:29.667]  - attr(*, "where")=List of 2
[10:31:29.667]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:29.667]   ..$ ...          :<environment: 0x55de842ca258> 
[10:31:29.667]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:29.667]  - attr(*, "resolved")= logi FALSE
[10:31:29.667]  - attr(*, "total_size")= num 4264
[10:31:29.670] Packages to be attached in all futures: [n=0] 
[10:31:29.670] getGlobalsAndPackagesXApply() ... DONE
[10:31:29.671] Number of futures (= number of chunks): 2
[10:31:29.671] Launching 2 futures (chunks) ...
[10:31:29.671] Chunk #1 of 2 ...
[10:31:29.671]  - Finding globals in 'X' for chunk #1 ...
[10:31:29.671] getGlobalsAndPackages() ...
[10:31:29.671] Searching for globals...
[10:31:29.671] 
[10:31:29.671] Searching for globals ... DONE
[10:31:29.672] - globals: [0] <none>
[10:31:29.672] getGlobalsAndPackages() ... DONE
[10:31:29.672]    + additional globals found: [n=0] 
[10:31:29.672]    + additional namespaces needed: [n=0] 
[10:31:29.672]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:29.672]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:29.672]  - seeds: <none>
[10:31:29.672]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.672] getGlobalsAndPackages() ...
[10:31:29.672] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.673] Resolving globals: FALSE
[10:31:29.673] Tweak future expression to call with '...' arguments ...
[10:31:29.673] {
[10:31:29.673]     do.call(function(...) {
[10:31:29.673]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.673]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.673]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.673]             on.exit(options(oopts), add = TRUE)
[10:31:29.673]         }
[10:31:29.673]         {
[10:31:29.673]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.673]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.673]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.673]             })
[10:31:29.673]         }
[10:31:29.673]     }, args = future.call.arguments)
[10:31:29.673] }
[10:31:29.673] Tweak future expression to call with '...' arguments ... DONE
[10:31:29.673] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.673] 
[10:31:29.674] getGlobalsAndPackages() ... DONE
[10:31:29.674] run() for ‘Future’ ...
[10:31:29.674] - state: ‘created’
[10:31:29.674] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:29.688] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:29.688]   - Field: ‘node’
[10:31:29.688]   - Field: ‘label’
[10:31:29.688]   - Field: ‘local’
[10:31:29.688]   - Field: ‘owner’
[10:31:29.689]   - Field: ‘envir’
[10:31:29.689]   - Field: ‘workers’
[10:31:29.689]   - Field: ‘packages’
[10:31:29.689]   - Field: ‘gc’
[10:31:29.689]   - Field: ‘conditions’
[10:31:29.689]   - Field: ‘persistent’
[10:31:29.689]   - Field: ‘expr’
[10:31:29.689]   - Field: ‘uuid’
[10:31:29.689]   - Field: ‘seed’
[10:31:29.689]   - Field: ‘version’
[10:31:29.690]   - Field: ‘result’
[10:31:29.690]   - Field: ‘asynchronous’
[10:31:29.690]   - Field: ‘calls’
[10:31:29.690]   - Field: ‘globals’
[10:31:29.690]   - Field: ‘stdout’
[10:31:29.690]   - Field: ‘earlySignal’
[10:31:29.690]   - Field: ‘lazy’
[10:31:29.690]   - Field: ‘state’
[10:31:29.690] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:29.690] - Launch lazy future ...
[10:31:29.691] Packages needed by the future expression (n = 0): <none>
[10:31:29.691] Packages needed by future strategies (n = 0): <none>
[10:31:29.691] {
[10:31:29.691]     {
[10:31:29.691]         {
[10:31:29.691]             ...future.startTime <- base::Sys.time()
[10:31:29.691]             {
[10:31:29.691]                 {
[10:31:29.691]                   {
[10:31:29.691]                     {
[10:31:29.691]                       base::local({
[10:31:29.691]                         has_future <- base::requireNamespace("future", 
[10:31:29.691]                           quietly = TRUE)
[10:31:29.691]                         if (has_future) {
[10:31:29.691]                           ns <- base::getNamespace("future")
[10:31:29.691]                           version <- ns[[".package"]][["version"]]
[10:31:29.691]                           if (is.null(version)) 
[10:31:29.691]                             version <- utils::packageVersion("future")
[10:31:29.691]                         }
[10:31:29.691]                         else {
[10:31:29.691]                           version <- NULL
[10:31:29.691]                         }
[10:31:29.691]                         if (!has_future || version < "1.8.0") {
[10:31:29.691]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:29.691]                             "", base::R.version$version.string), 
[10:31:29.691]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:29.691]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:29.691]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:29.691]                               "release", "version")], collapse = " "), 
[10:31:29.691]                             hostname = base::Sys.info()[["nodename"]])
[10:31:29.691]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:29.691]                             info)
[10:31:29.691]                           info <- base::paste(info, collapse = "; ")
[10:31:29.691]                           if (!has_future) {
[10:31:29.691]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:29.691]                               info)
[10:31:29.691]                           }
[10:31:29.691]                           else {
[10:31:29.691]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:29.691]                               info, version)
[10:31:29.691]                           }
[10:31:29.691]                           base::stop(msg)
[10:31:29.691]                         }
[10:31:29.691]                       })
[10:31:29.691]                     }
[10:31:29.691]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:29.691]                     base::options(mc.cores = 1L)
[10:31:29.691]                   }
[10:31:29.691]                   ...future.strategy.old <- future::plan("list")
[10:31:29.691]                   options(future.plan = NULL)
[10:31:29.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:29.691]                 }
[10:31:29.691]                 ...future.workdir <- getwd()
[10:31:29.691]             }
[10:31:29.691]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:29.691]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:29.691]         }
[10:31:29.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:29.691]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:29.691]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:29.691]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:29.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:29.691]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:29.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:29.691]             base::names(...future.oldOptions))
[10:31:29.691]     }
[10:31:29.691]     if (FALSE) {
[10:31:29.691]     }
[10:31:29.691]     else {
[10:31:29.691]         if (TRUE) {
[10:31:29.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:29.691]                 open = "w")
[10:31:29.691]         }
[10:31:29.691]         else {
[10:31:29.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:29.691]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:29.691]         }
[10:31:29.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:29.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:29.691]             base::sink(type = "output", split = FALSE)
[10:31:29.691]             base::close(...future.stdout)
[10:31:29.691]         }, add = TRUE)
[10:31:29.691]     }
[10:31:29.691]     ...future.frame <- base::sys.nframe()
[10:31:29.691]     ...future.conditions <- base::list()
[10:31:29.691]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:29.691]     if (FALSE) {
[10:31:29.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:29.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:29.691]     }
[10:31:29.691]     ...future.result <- base::tryCatch({
[10:31:29.691]         base::withCallingHandlers({
[10:31:29.691]             ...future.value <- base::withVisible(base::local({
[10:31:29.691]                 ...future.makeSendCondition <- base::local({
[10:31:29.691]                   sendCondition <- NULL
[10:31:29.691]                   function(frame = 1L) {
[10:31:29.691]                     if (is.function(sendCondition)) 
[10:31:29.691]                       return(sendCondition)
[10:31:29.691]                     ns <- getNamespace("parallel")
[10:31:29.691]                     if (exists("sendData", mode = "function", 
[10:31:29.691]                       envir = ns)) {
[10:31:29.691]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:29.691]                         envir = ns)
[10:31:29.691]                       envir <- sys.frame(frame)
[10:31:29.691]                       master <- NULL
[10:31:29.691]                       while (!identical(envir, .GlobalEnv) && 
[10:31:29.691]                         !identical(envir, emptyenv())) {
[10:31:29.691]                         if (exists("master", mode = "list", envir = envir, 
[10:31:29.691]                           inherits = FALSE)) {
[10:31:29.691]                           master <- get("master", mode = "list", 
[10:31:29.691]                             envir = envir, inherits = FALSE)
[10:31:29.691]                           if (inherits(master, c("SOCKnode", 
[10:31:29.691]                             "SOCK0node"))) {
[10:31:29.691]                             sendCondition <<- function(cond) {
[10:31:29.691]                               data <- list(type = "VALUE", value = cond, 
[10:31:29.691]                                 success = TRUE)
[10:31:29.691]                               parallel_sendData(master, data)
[10:31:29.691]                             }
[10:31:29.691]                             return(sendCondition)
[10:31:29.691]                           }
[10:31:29.691]                         }
[10:31:29.691]                         frame <- frame + 1L
[10:31:29.691]                         envir <- sys.frame(frame)
[10:31:29.691]                       }
[10:31:29.691]                     }
[10:31:29.691]                     sendCondition <<- function(cond) NULL
[10:31:29.691]                   }
[10:31:29.691]                 })
[10:31:29.691]                 withCallingHandlers({
[10:31:29.691]                   {
[10:31:29.691]                     do.call(function(...) {
[10:31:29.691]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.691]                       if (!identical(...future.globals.maxSize.org, 
[10:31:29.691]                         ...future.globals.maxSize)) {
[10:31:29.691]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.691]                         on.exit(options(oopts), add = TRUE)
[10:31:29.691]                       }
[10:31:29.691]                       {
[10:31:29.691]                         lapply(seq_along(...future.elements_ii), 
[10:31:29.691]                           FUN = function(jj) {
[10:31:29.691]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.691]                             ...future.FUN(...future.X_jj, ...)
[10:31:29.691]                           })
[10:31:29.691]                       }
[10:31:29.691]                     }, args = future.call.arguments)
[10:31:29.691]                   }
[10:31:29.691]                 }, immediateCondition = function(cond) {
[10:31:29.691]                   sendCondition <- ...future.makeSendCondition()
[10:31:29.691]                   sendCondition(cond)
[10:31:29.691]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.691]                   {
[10:31:29.691]                     inherits <- base::inherits
[10:31:29.691]                     invokeRestart <- base::invokeRestart
[10:31:29.691]                     is.null <- base::is.null
[10:31:29.691]                     muffled <- FALSE
[10:31:29.691]                     if (inherits(cond, "message")) {
[10:31:29.691]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:29.691]                       if (muffled) 
[10:31:29.691]                         invokeRestart("muffleMessage")
[10:31:29.691]                     }
[10:31:29.691]                     else if (inherits(cond, "warning")) {
[10:31:29.691]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:29.691]                       if (muffled) 
[10:31:29.691]                         invokeRestart("muffleWarning")
[10:31:29.691]                     }
[10:31:29.691]                     else if (inherits(cond, "condition")) {
[10:31:29.691]                       if (!is.null(pattern)) {
[10:31:29.691]                         computeRestarts <- base::computeRestarts
[10:31:29.691]                         grepl <- base::grepl
[10:31:29.691]                         restarts <- computeRestarts(cond)
[10:31:29.691]                         for (restart in restarts) {
[10:31:29.691]                           name <- restart$name
[10:31:29.691]                           if (is.null(name)) 
[10:31:29.691]                             next
[10:31:29.691]                           if (!grepl(pattern, name)) 
[10:31:29.691]                             next
[10:31:29.691]                           invokeRestart(restart)
[10:31:29.691]                           muffled <- TRUE
[10:31:29.691]                           break
[10:31:29.691]                         }
[10:31:29.691]                       }
[10:31:29.691]                     }
[10:31:29.691]                     invisible(muffled)
[10:31:29.691]                   }
[10:31:29.691]                   muffleCondition(cond)
[10:31:29.691]                 })
[10:31:29.691]             }))
[10:31:29.691]             future::FutureResult(value = ...future.value$value, 
[10:31:29.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.691]                   ...future.rng), globalenv = if (FALSE) 
[10:31:29.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:29.691]                     ...future.globalenv.names))
[10:31:29.691]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:29.691]         }, condition = base::local({
[10:31:29.691]             c <- base::c
[10:31:29.691]             inherits <- base::inherits
[10:31:29.691]             invokeRestart <- base::invokeRestart
[10:31:29.691]             length <- base::length
[10:31:29.691]             list <- base::list
[10:31:29.691]             seq.int <- base::seq.int
[10:31:29.691]             signalCondition <- base::signalCondition
[10:31:29.691]             sys.calls <- base::sys.calls
[10:31:29.691]             `[[` <- base::`[[`
[10:31:29.691]             `+` <- base::`+`
[10:31:29.691]             `<<-` <- base::`<<-`
[10:31:29.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:29.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:29.691]                   3L)]
[10:31:29.691]             }
[10:31:29.691]             function(cond) {
[10:31:29.691]                 is_error <- inherits(cond, "error")
[10:31:29.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:29.691]                   NULL)
[10:31:29.691]                 if (is_error) {
[10:31:29.691]                   sessionInformation <- function() {
[10:31:29.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:29.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:29.691]                       search = base::search(), system = base::Sys.info())
[10:31:29.691]                   }
[10:31:29.691]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:29.691]                     cond$call), session = sessionInformation(), 
[10:31:29.691]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:29.691]                   signalCondition(cond)
[10:31:29.691]                 }
[10:31:29.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:29.691]                 "immediateCondition"))) {
[10:31:29.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:29.691]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:29.691]                   if (TRUE && !signal) {
[10:31:29.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.691]                     {
[10:31:29.691]                       inherits <- base::inherits
[10:31:29.691]                       invokeRestart <- base::invokeRestart
[10:31:29.691]                       is.null <- base::is.null
[10:31:29.691]                       muffled <- FALSE
[10:31:29.691]                       if (inherits(cond, "message")) {
[10:31:29.691]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.691]                         if (muffled) 
[10:31:29.691]                           invokeRestart("muffleMessage")
[10:31:29.691]                       }
[10:31:29.691]                       else if (inherits(cond, "warning")) {
[10:31:29.691]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.691]                         if (muffled) 
[10:31:29.691]                           invokeRestart("muffleWarning")
[10:31:29.691]                       }
[10:31:29.691]                       else if (inherits(cond, "condition")) {
[10:31:29.691]                         if (!is.null(pattern)) {
[10:31:29.691]                           computeRestarts <- base::computeRestarts
[10:31:29.691]                           grepl <- base::grepl
[10:31:29.691]                           restarts <- computeRestarts(cond)
[10:31:29.691]                           for (restart in restarts) {
[10:31:29.691]                             name <- restart$name
[10:31:29.691]                             if (is.null(name)) 
[10:31:29.691]                               next
[10:31:29.691]                             if (!grepl(pattern, name)) 
[10:31:29.691]                               next
[10:31:29.691]                             invokeRestart(restart)
[10:31:29.691]                             muffled <- TRUE
[10:31:29.691]                             break
[10:31:29.691]                           }
[10:31:29.691]                         }
[10:31:29.691]                       }
[10:31:29.691]                       invisible(muffled)
[10:31:29.691]                     }
[10:31:29.691]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.691]                   }
[10:31:29.691]                 }
[10:31:29.691]                 else {
[10:31:29.691]                   if (TRUE) {
[10:31:29.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.691]                     {
[10:31:29.691]                       inherits <- base::inherits
[10:31:29.691]                       invokeRestart <- base::invokeRestart
[10:31:29.691]                       is.null <- base::is.null
[10:31:29.691]                       muffled <- FALSE
[10:31:29.691]                       if (inherits(cond, "message")) {
[10:31:29.691]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.691]                         if (muffled) 
[10:31:29.691]                           invokeRestart("muffleMessage")
[10:31:29.691]                       }
[10:31:29.691]                       else if (inherits(cond, "warning")) {
[10:31:29.691]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.691]                         if (muffled) 
[10:31:29.691]                           invokeRestart("muffleWarning")
[10:31:29.691]                       }
[10:31:29.691]                       else if (inherits(cond, "condition")) {
[10:31:29.691]                         if (!is.null(pattern)) {
[10:31:29.691]                           computeRestarts <- base::computeRestarts
[10:31:29.691]                           grepl <- base::grepl
[10:31:29.691]                           restarts <- computeRestarts(cond)
[10:31:29.691]                           for (restart in restarts) {
[10:31:29.691]                             name <- restart$name
[10:31:29.691]                             if (is.null(name)) 
[10:31:29.691]                               next
[10:31:29.691]                             if (!grepl(pattern, name)) 
[10:31:29.691]                               next
[10:31:29.691]                             invokeRestart(restart)
[10:31:29.691]                             muffled <- TRUE
[10:31:29.691]                             break
[10:31:29.691]                           }
[10:31:29.691]                         }
[10:31:29.691]                       }
[10:31:29.691]                       invisible(muffled)
[10:31:29.691]                     }
[10:31:29.691]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.691]                   }
[10:31:29.691]                 }
[10:31:29.691]             }
[10:31:29.691]         }))
[10:31:29.691]     }, error = function(ex) {
[10:31:29.691]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:29.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.691]                 ...future.rng), started = ...future.startTime, 
[10:31:29.691]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:29.691]             version = "1.8"), class = "FutureResult")
[10:31:29.691]     }, finally = {
[10:31:29.691]         if (!identical(...future.workdir, getwd())) 
[10:31:29.691]             setwd(...future.workdir)
[10:31:29.691]         {
[10:31:29.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:29.691]                 ...future.oldOptions$nwarnings <- NULL
[10:31:29.691]             }
[10:31:29.691]             base::options(...future.oldOptions)
[10:31:29.691]             if (.Platform$OS.type == "windows") {
[10:31:29.691]                 old_names <- names(...future.oldEnvVars)
[10:31:29.691]                 envs <- base::Sys.getenv()
[10:31:29.691]                 names <- names(envs)
[10:31:29.691]                 common <- intersect(names, old_names)
[10:31:29.691]                 added <- setdiff(names, old_names)
[10:31:29.691]                 removed <- setdiff(old_names, names)
[10:31:29.691]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:29.691]                   envs[common]]
[10:31:29.691]                 NAMES <- toupper(changed)
[10:31:29.691]                 args <- list()
[10:31:29.691]                 for (kk in seq_along(NAMES)) {
[10:31:29.691]                   name <- changed[[kk]]
[10:31:29.691]                   NAME <- NAMES[[kk]]
[10:31:29.691]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.691]                     next
[10:31:29.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.691]                 }
[10:31:29.691]                 NAMES <- toupper(added)
[10:31:29.691]                 for (kk in seq_along(NAMES)) {
[10:31:29.691]                   name <- added[[kk]]
[10:31:29.691]                   NAME <- NAMES[[kk]]
[10:31:29.691]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.691]                     next
[10:31:29.691]                   args[[name]] <- ""
[10:31:29.691]                 }
[10:31:29.691]                 NAMES <- toupper(removed)
[10:31:29.691]                 for (kk in seq_along(NAMES)) {
[10:31:29.691]                   name <- removed[[kk]]
[10:31:29.691]                   NAME <- NAMES[[kk]]
[10:31:29.691]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.691]                     next
[10:31:29.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.691]                 }
[10:31:29.691]                 if (length(args) > 0) 
[10:31:29.691]                   base::do.call(base::Sys.setenv, args = args)
[10:31:29.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:29.691]             }
[10:31:29.691]             else {
[10:31:29.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:29.691]             }
[10:31:29.691]             {
[10:31:29.691]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:29.691]                   0L) {
[10:31:29.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:29.691]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:29.691]                   base::options(opts)
[10:31:29.691]                 }
[10:31:29.691]                 {
[10:31:29.691]                   {
[10:31:29.691]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:29.691]                     NULL
[10:31:29.691]                   }
[10:31:29.691]                   options(future.plan = NULL)
[10:31:29.691]                   if (is.na(NA_character_)) 
[10:31:29.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:29.691]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:29.691]                     .init = FALSE)
[10:31:29.691]                 }
[10:31:29.691]             }
[10:31:29.691]         }
[10:31:29.691]     })
[10:31:29.691]     if (TRUE) {
[10:31:29.691]         base::sink(type = "output", split = FALSE)
[10:31:29.691]         if (TRUE) {
[10:31:29.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:29.691]         }
[10:31:29.691]         else {
[10:31:29.691]             ...future.result["stdout"] <- base::list(NULL)
[10:31:29.691]         }
[10:31:29.691]         base::close(...future.stdout)
[10:31:29.691]         ...future.stdout <- NULL
[10:31:29.691]     }
[10:31:29.691]     ...future.result$conditions <- ...future.conditions
[10:31:29.691]     ...future.result$finished <- base::Sys.time()
[10:31:29.691]     ...future.result
[10:31:29.691] }
[10:31:29.694] Exporting 5 global objects (4.16 KiB) to cluster node #1 ...
[10:31:29.694] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ...
[10:31:29.694] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #1 ... DONE
[10:31:29.695] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[10:31:29.695] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[10:31:29.695] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:31:29.695] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:31:29.696] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:29.696] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.696] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:29.696] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.696] Exporting 5 global objects (4.16 KiB) to cluster node #1 ... DONE
[10:31:29.697] MultisessionFuture started
[10:31:29.697] - Launch lazy future ... done
[10:31:29.697] run() for ‘MultisessionFuture’ ... done
[10:31:29.697] Created future:
[10:31:29.697] MultisessionFuture:
[10:31:29.697] Label: ‘future_sapply-1’
[10:31:29.697] Expression:
[10:31:29.697] {
[10:31:29.697]     do.call(function(...) {
[10:31:29.697]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.697]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.697]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.697]             on.exit(options(oopts), add = TRUE)
[10:31:29.697]         }
[10:31:29.697]         {
[10:31:29.697]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.697]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.697]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.697]             })
[10:31:29.697]         }
[10:31:29.697]     }, args = future.call.arguments)
[10:31:29.697] }
[10:31:29.697] Lazy evaluation: FALSE
[10:31:29.697] Asynchronous evaluation: TRUE
[10:31:29.697] Local evaluation: TRUE
[10:31:29.697] Environment: R_GlobalEnv
[10:31:29.697] Capture standard output: TRUE
[10:31:29.697] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:29.697] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:29.697] Packages: <none>
[10:31:29.697] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:29.697] Resolved: FALSE
[10:31:29.697] Value: <not collected>
[10:31:29.697] Conditions captured: <none>
[10:31:29.697] Early signaling: FALSE
[10:31:29.697] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:29.697] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.709] Chunk #1 of 2 ... DONE
[10:31:29.709] Chunk #2 of 2 ...
[10:31:29.709]  - Finding globals in 'X' for chunk #2 ...
[10:31:29.709] getGlobalsAndPackages() ...
[10:31:29.709] Searching for globals...
[10:31:29.709] 
[10:31:29.709] Searching for globals ... DONE
[10:31:29.710] - globals: [0] <none>
[10:31:29.710] getGlobalsAndPackages() ... DONE
[10:31:29.710]    + additional globals found: [n=0] 
[10:31:29.710]    + additional namespaces needed: [n=0] 
[10:31:29.710]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:29.710]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:29.710]  - seeds: <none>
[10:31:29.710]  - All globals exported: [n=5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.710] getGlobalsAndPackages() ...
[10:31:29.710] - globals passed as-is: [5] ‘...future.FUN’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.710] Resolving globals: FALSE
[10:31:29.711] Tweak future expression to call with '...' arguments ...
[10:31:29.711] {
[10:31:29.711]     do.call(function(...) {
[10:31:29.711]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.711]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.711]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.711]             on.exit(options(oopts), add = TRUE)
[10:31:29.711]         }
[10:31:29.711]         {
[10:31:29.711]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.711]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.711]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.711]             })
[10:31:29.711]         }
[10:31:29.711]     }, args = future.call.arguments)
[10:31:29.711] }
[10:31:29.711] Tweak future expression to call with '...' arguments ... DONE
[10:31:29.711] - globals: [5] ‘...future.FUN’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.711] 
[10:31:29.711] getGlobalsAndPackages() ... DONE
[10:31:29.712] run() for ‘Future’ ...
[10:31:29.712] - state: ‘created’
[10:31:29.712] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:29.725] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:29.726]   - Field: ‘node’
[10:31:29.726]   - Field: ‘label’
[10:31:29.726]   - Field: ‘local’
[10:31:29.726]   - Field: ‘owner’
[10:31:29.726]   - Field: ‘envir’
[10:31:29.726]   - Field: ‘workers’
[10:31:29.726]   - Field: ‘packages’
[10:31:29.726]   - Field: ‘gc’
[10:31:29.726]   - Field: ‘conditions’
[10:31:29.727]   - Field: ‘persistent’
[10:31:29.727]   - Field: ‘expr’
[10:31:29.727]   - Field: ‘uuid’
[10:31:29.727]   - Field: ‘seed’
[10:31:29.727]   - Field: ‘version’
[10:31:29.727]   - Field: ‘result’
[10:31:29.727]   - Field: ‘asynchronous’
[10:31:29.727]   - Field: ‘calls’
[10:31:29.727]   - Field: ‘globals’
[10:31:29.727]   - Field: ‘stdout’
[10:31:29.727]   - Field: ‘earlySignal’
[10:31:29.728]   - Field: ‘lazy’
[10:31:29.728]   - Field: ‘state’
[10:31:29.728] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:29.728] - Launch lazy future ...
[10:31:29.728] Packages needed by the future expression (n = 0): <none>
[10:31:29.728] Packages needed by future strategies (n = 0): <none>
[10:31:29.729] {
[10:31:29.729]     {
[10:31:29.729]         {
[10:31:29.729]             ...future.startTime <- base::Sys.time()
[10:31:29.729]             {
[10:31:29.729]                 {
[10:31:29.729]                   {
[10:31:29.729]                     {
[10:31:29.729]                       base::local({
[10:31:29.729]                         has_future <- base::requireNamespace("future", 
[10:31:29.729]                           quietly = TRUE)
[10:31:29.729]                         if (has_future) {
[10:31:29.729]                           ns <- base::getNamespace("future")
[10:31:29.729]                           version <- ns[[".package"]][["version"]]
[10:31:29.729]                           if (is.null(version)) 
[10:31:29.729]                             version <- utils::packageVersion("future")
[10:31:29.729]                         }
[10:31:29.729]                         else {
[10:31:29.729]                           version <- NULL
[10:31:29.729]                         }
[10:31:29.729]                         if (!has_future || version < "1.8.0") {
[10:31:29.729]                           info <- base::c(r_version = base::gsub("R version ", 
[10:31:29.729]                             "", base::R.version$version.string), 
[10:31:29.729]                             platform = base::sprintf("%s (%s-bit)", 
[10:31:29.729]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:31:29.729]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:29.729]                               "release", "version")], collapse = " "), 
[10:31:29.729]                             hostname = base::Sys.info()[["nodename"]])
[10:31:29.729]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:31:29.729]                             info)
[10:31:29.729]                           info <- base::paste(info, collapse = "; ")
[10:31:29.729]                           if (!has_future) {
[10:31:29.729]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:29.729]                               info)
[10:31:29.729]                           }
[10:31:29.729]                           else {
[10:31:29.729]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:29.729]                               info, version)
[10:31:29.729]                           }
[10:31:29.729]                           base::stop(msg)
[10:31:29.729]                         }
[10:31:29.729]                       })
[10:31:29.729]                     }
[10:31:29.729]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:29.729]                     base::options(mc.cores = 1L)
[10:31:29.729]                   }
[10:31:29.729]                   ...future.strategy.old <- future::plan("list")
[10:31:29.729]                   options(future.plan = NULL)
[10:31:29.729]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.729]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:29.729]                 }
[10:31:29.729]                 ...future.workdir <- getwd()
[10:31:29.729]             }
[10:31:29.729]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:29.729]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:29.729]         }
[10:31:29.729]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:29.729]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:29.729]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:29.729]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:29.729]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:29.729]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:29.729]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:29.729]             base::names(...future.oldOptions))
[10:31:29.729]     }
[10:31:29.729]     if (FALSE) {
[10:31:29.729]     }
[10:31:29.729]     else {
[10:31:29.729]         if (TRUE) {
[10:31:29.729]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:29.729]                 open = "w")
[10:31:29.729]         }
[10:31:29.729]         else {
[10:31:29.729]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:29.729]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:29.729]         }
[10:31:29.729]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:29.729]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:29.729]             base::sink(type = "output", split = FALSE)
[10:31:29.729]             base::close(...future.stdout)
[10:31:29.729]         }, add = TRUE)
[10:31:29.729]     }
[10:31:29.729]     ...future.frame <- base::sys.nframe()
[10:31:29.729]     ...future.conditions <- base::list()
[10:31:29.729]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:29.729]     if (FALSE) {
[10:31:29.729]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:29.729]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:29.729]     }
[10:31:29.729]     ...future.result <- base::tryCatch({
[10:31:29.729]         base::withCallingHandlers({
[10:31:29.729]             ...future.value <- base::withVisible(base::local({
[10:31:29.729]                 ...future.makeSendCondition <- base::local({
[10:31:29.729]                   sendCondition <- NULL
[10:31:29.729]                   function(frame = 1L) {
[10:31:29.729]                     if (is.function(sendCondition)) 
[10:31:29.729]                       return(sendCondition)
[10:31:29.729]                     ns <- getNamespace("parallel")
[10:31:29.729]                     if (exists("sendData", mode = "function", 
[10:31:29.729]                       envir = ns)) {
[10:31:29.729]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:29.729]                         envir = ns)
[10:31:29.729]                       envir <- sys.frame(frame)
[10:31:29.729]                       master <- NULL
[10:31:29.729]                       while (!identical(envir, .GlobalEnv) && 
[10:31:29.729]                         !identical(envir, emptyenv())) {
[10:31:29.729]                         if (exists("master", mode = "list", envir = envir, 
[10:31:29.729]                           inherits = FALSE)) {
[10:31:29.729]                           master <- get("master", mode = "list", 
[10:31:29.729]                             envir = envir, inherits = FALSE)
[10:31:29.729]                           if (inherits(master, c("SOCKnode", 
[10:31:29.729]                             "SOCK0node"))) {
[10:31:29.729]                             sendCondition <<- function(cond) {
[10:31:29.729]                               data <- list(type = "VALUE", value = cond, 
[10:31:29.729]                                 success = TRUE)
[10:31:29.729]                               parallel_sendData(master, data)
[10:31:29.729]                             }
[10:31:29.729]                             return(sendCondition)
[10:31:29.729]                           }
[10:31:29.729]                         }
[10:31:29.729]                         frame <- frame + 1L
[10:31:29.729]                         envir <- sys.frame(frame)
[10:31:29.729]                       }
[10:31:29.729]                     }
[10:31:29.729]                     sendCondition <<- function(cond) NULL
[10:31:29.729]                   }
[10:31:29.729]                 })
[10:31:29.729]                 withCallingHandlers({
[10:31:29.729]                   {
[10:31:29.729]                     do.call(function(...) {
[10:31:29.729]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.729]                       if (!identical(...future.globals.maxSize.org, 
[10:31:29.729]                         ...future.globals.maxSize)) {
[10:31:29.729]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.729]                         on.exit(options(oopts), add = TRUE)
[10:31:29.729]                       }
[10:31:29.729]                       {
[10:31:29.729]                         lapply(seq_along(...future.elements_ii), 
[10:31:29.729]                           FUN = function(jj) {
[10:31:29.729]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.729]                             ...future.FUN(...future.X_jj, ...)
[10:31:29.729]                           })
[10:31:29.729]                       }
[10:31:29.729]                     }, args = future.call.arguments)
[10:31:29.729]                   }
[10:31:29.729]                 }, immediateCondition = function(cond) {
[10:31:29.729]                   sendCondition <- ...future.makeSendCondition()
[10:31:29.729]                   sendCondition(cond)
[10:31:29.729]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.729]                   {
[10:31:29.729]                     inherits <- base::inherits
[10:31:29.729]                     invokeRestart <- base::invokeRestart
[10:31:29.729]                     is.null <- base::is.null
[10:31:29.729]                     muffled <- FALSE
[10:31:29.729]                     if (inherits(cond, "message")) {
[10:31:29.729]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:29.729]                       if (muffled) 
[10:31:29.729]                         invokeRestart("muffleMessage")
[10:31:29.729]                     }
[10:31:29.729]                     else if (inherits(cond, "warning")) {
[10:31:29.729]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:29.729]                       if (muffled) 
[10:31:29.729]                         invokeRestart("muffleWarning")
[10:31:29.729]                     }
[10:31:29.729]                     else if (inherits(cond, "condition")) {
[10:31:29.729]                       if (!is.null(pattern)) {
[10:31:29.729]                         computeRestarts <- base::computeRestarts
[10:31:29.729]                         grepl <- base::grepl
[10:31:29.729]                         restarts <- computeRestarts(cond)
[10:31:29.729]                         for (restart in restarts) {
[10:31:29.729]                           name <- restart$name
[10:31:29.729]                           if (is.null(name)) 
[10:31:29.729]                             next
[10:31:29.729]                           if (!grepl(pattern, name)) 
[10:31:29.729]                             next
[10:31:29.729]                           invokeRestart(restart)
[10:31:29.729]                           muffled <- TRUE
[10:31:29.729]                           break
[10:31:29.729]                         }
[10:31:29.729]                       }
[10:31:29.729]                     }
[10:31:29.729]                     invisible(muffled)
[10:31:29.729]                   }
[10:31:29.729]                   muffleCondition(cond)
[10:31:29.729]                 })
[10:31:29.729]             }))
[10:31:29.729]             future::FutureResult(value = ...future.value$value, 
[10:31:29.729]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.729]                   ...future.rng), globalenv = if (FALSE) 
[10:31:29.729]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:29.729]                     ...future.globalenv.names))
[10:31:29.729]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:29.729]         }, condition = base::local({
[10:31:29.729]             c <- base::c
[10:31:29.729]             inherits <- base::inherits
[10:31:29.729]             invokeRestart <- base::invokeRestart
[10:31:29.729]             length <- base::length
[10:31:29.729]             list <- base::list
[10:31:29.729]             seq.int <- base::seq.int
[10:31:29.729]             signalCondition <- base::signalCondition
[10:31:29.729]             sys.calls <- base::sys.calls
[10:31:29.729]             `[[` <- base::`[[`
[10:31:29.729]             `+` <- base::`+`
[10:31:29.729]             `<<-` <- base::`<<-`
[10:31:29.729]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:29.729]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:29.729]                   3L)]
[10:31:29.729]             }
[10:31:29.729]             function(cond) {
[10:31:29.729]                 is_error <- inherits(cond, "error")
[10:31:29.729]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:29.729]                   NULL)
[10:31:29.729]                 if (is_error) {
[10:31:29.729]                   sessionInformation <- function() {
[10:31:29.729]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:29.729]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:29.729]                       search = base::search(), system = base::Sys.info())
[10:31:29.729]                   }
[10:31:29.729]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.729]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:29.729]                     cond$call), session = sessionInformation(), 
[10:31:29.729]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:29.729]                   signalCondition(cond)
[10:31:29.729]                 }
[10:31:29.729]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:29.729]                 "immediateCondition"))) {
[10:31:29.729]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:29.729]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.729]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:29.729]                   if (TRUE && !signal) {
[10:31:29.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.729]                     {
[10:31:29.729]                       inherits <- base::inherits
[10:31:29.729]                       invokeRestart <- base::invokeRestart
[10:31:29.729]                       is.null <- base::is.null
[10:31:29.729]                       muffled <- FALSE
[10:31:29.729]                       if (inherits(cond, "message")) {
[10:31:29.729]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.729]                         if (muffled) 
[10:31:29.729]                           invokeRestart("muffleMessage")
[10:31:29.729]                       }
[10:31:29.729]                       else if (inherits(cond, "warning")) {
[10:31:29.729]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.729]                         if (muffled) 
[10:31:29.729]                           invokeRestart("muffleWarning")
[10:31:29.729]                       }
[10:31:29.729]                       else if (inherits(cond, "condition")) {
[10:31:29.729]                         if (!is.null(pattern)) {
[10:31:29.729]                           computeRestarts <- base::computeRestarts
[10:31:29.729]                           grepl <- base::grepl
[10:31:29.729]                           restarts <- computeRestarts(cond)
[10:31:29.729]                           for (restart in restarts) {
[10:31:29.729]                             name <- restart$name
[10:31:29.729]                             if (is.null(name)) 
[10:31:29.729]                               next
[10:31:29.729]                             if (!grepl(pattern, name)) 
[10:31:29.729]                               next
[10:31:29.729]                             invokeRestart(restart)
[10:31:29.729]                             muffled <- TRUE
[10:31:29.729]                             break
[10:31:29.729]                           }
[10:31:29.729]                         }
[10:31:29.729]                       }
[10:31:29.729]                       invisible(muffled)
[10:31:29.729]                     }
[10:31:29.729]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.729]                   }
[10:31:29.729]                 }
[10:31:29.729]                 else {
[10:31:29.729]                   if (TRUE) {
[10:31:29.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.729]                     {
[10:31:29.729]                       inherits <- base::inherits
[10:31:29.729]                       invokeRestart <- base::invokeRestart
[10:31:29.729]                       is.null <- base::is.null
[10:31:29.729]                       muffled <- FALSE
[10:31:29.729]                       if (inherits(cond, "message")) {
[10:31:29.729]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.729]                         if (muffled) 
[10:31:29.729]                           invokeRestart("muffleMessage")
[10:31:29.729]                       }
[10:31:29.729]                       else if (inherits(cond, "warning")) {
[10:31:29.729]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.729]                         if (muffled) 
[10:31:29.729]                           invokeRestart("muffleWarning")
[10:31:29.729]                       }
[10:31:29.729]                       else if (inherits(cond, "condition")) {
[10:31:29.729]                         if (!is.null(pattern)) {
[10:31:29.729]                           computeRestarts <- base::computeRestarts
[10:31:29.729]                           grepl <- base::grepl
[10:31:29.729]                           restarts <- computeRestarts(cond)
[10:31:29.729]                           for (restart in restarts) {
[10:31:29.729]                             name <- restart$name
[10:31:29.729]                             if (is.null(name)) 
[10:31:29.729]                               next
[10:31:29.729]                             if (!grepl(pattern, name)) 
[10:31:29.729]                               next
[10:31:29.729]                             invokeRestart(restart)
[10:31:29.729]                             muffled <- TRUE
[10:31:29.729]                             break
[10:31:29.729]                           }
[10:31:29.729]                         }
[10:31:29.729]                       }
[10:31:29.729]                       invisible(muffled)
[10:31:29.729]                     }
[10:31:29.729]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.729]                   }
[10:31:29.729]                 }
[10:31:29.729]             }
[10:31:29.729]         }))
[10:31:29.729]     }, error = function(ex) {
[10:31:29.729]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:29.729]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.729]                 ...future.rng), started = ...future.startTime, 
[10:31:29.729]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:29.729]             version = "1.8"), class = "FutureResult")
[10:31:29.729]     }, finally = {
[10:31:29.729]         if (!identical(...future.workdir, getwd())) 
[10:31:29.729]             setwd(...future.workdir)
[10:31:29.729]         {
[10:31:29.729]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:29.729]                 ...future.oldOptions$nwarnings <- NULL
[10:31:29.729]             }
[10:31:29.729]             base::options(...future.oldOptions)
[10:31:29.729]             if (.Platform$OS.type == "windows") {
[10:31:29.729]                 old_names <- names(...future.oldEnvVars)
[10:31:29.729]                 envs <- base::Sys.getenv()
[10:31:29.729]                 names <- names(envs)
[10:31:29.729]                 common <- intersect(names, old_names)
[10:31:29.729]                 added <- setdiff(names, old_names)
[10:31:29.729]                 removed <- setdiff(old_names, names)
[10:31:29.729]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:29.729]                   envs[common]]
[10:31:29.729]                 NAMES <- toupper(changed)
[10:31:29.729]                 args <- list()
[10:31:29.729]                 for (kk in seq_along(NAMES)) {
[10:31:29.729]                   name <- changed[[kk]]
[10:31:29.729]                   NAME <- NAMES[[kk]]
[10:31:29.729]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.729]                     next
[10:31:29.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.729]                 }
[10:31:29.729]                 NAMES <- toupper(added)
[10:31:29.729]                 for (kk in seq_along(NAMES)) {
[10:31:29.729]                   name <- added[[kk]]
[10:31:29.729]                   NAME <- NAMES[[kk]]
[10:31:29.729]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.729]                     next
[10:31:29.729]                   args[[name]] <- ""
[10:31:29.729]                 }
[10:31:29.729]                 NAMES <- toupper(removed)
[10:31:29.729]                 for (kk in seq_along(NAMES)) {
[10:31:29.729]                   name <- removed[[kk]]
[10:31:29.729]                   NAME <- NAMES[[kk]]
[10:31:29.729]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.729]                     next
[10:31:29.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.729]                 }
[10:31:29.729]                 if (length(args) > 0) 
[10:31:29.729]                   base::do.call(base::Sys.setenv, args = args)
[10:31:29.729]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:29.729]             }
[10:31:29.729]             else {
[10:31:29.729]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:29.729]             }
[10:31:29.729]             {
[10:31:29.729]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:29.729]                   0L) {
[10:31:29.729]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:29.729]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:29.729]                   base::options(opts)
[10:31:29.729]                 }
[10:31:29.729]                 {
[10:31:29.729]                   {
[10:31:29.729]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:29.729]                     NULL
[10:31:29.729]                   }
[10:31:29.729]                   options(future.plan = NULL)
[10:31:29.729]                   if (is.na(NA_character_)) 
[10:31:29.729]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.729]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:29.729]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:29.729]                     .init = FALSE)
[10:31:29.729]                 }
[10:31:29.729]             }
[10:31:29.729]         }
[10:31:29.729]     })
[10:31:29.729]     if (TRUE) {
[10:31:29.729]         base::sink(type = "output", split = FALSE)
[10:31:29.729]         if (TRUE) {
[10:31:29.729]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:29.729]         }
[10:31:29.729]         else {
[10:31:29.729]             ...future.result["stdout"] <- base::list(NULL)
[10:31:29.729]         }
[10:31:29.729]         base::close(...future.stdout)
[10:31:29.729]         ...future.stdout <- NULL
[10:31:29.729]     }
[10:31:29.729]     ...future.result$conditions <- ...future.conditions
[10:31:29.729]     ...future.result$finished <- base::Sys.time()
[10:31:29.729]     ...future.result
[10:31:29.729] }
[10:31:29.731] Exporting 5 global objects (4.16 KiB) to cluster node #2 ...
[10:31:29.731] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ...
[10:31:29.732] Exporting ‘...future.FUN’ (4.07 KiB) to cluster node #2 ... DONE
[10:31:29.732] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ...
[10:31:29.732] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #2 ... DONE
[10:31:29.733] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:31:29.733] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:31:29.733] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:29.733] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:29.734] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:29.734] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:29.734] Exporting 5 global objects (4.16 KiB) to cluster node #2 ... DONE
[10:31:29.735] MultisessionFuture started
[10:31:29.735] - Launch lazy future ... done
[10:31:29.735] run() for ‘MultisessionFuture’ ... done
[10:31:29.735] Created future:
[10:31:29.735] MultisessionFuture:
[10:31:29.735] Label: ‘future_sapply-2’
[10:31:29.735] Expression:
[10:31:29.735] {
[10:31:29.735]     do.call(function(...) {
[10:31:29.735]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.735]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.735]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.735]             on.exit(options(oopts), add = TRUE)
[10:31:29.735]         }
[10:31:29.735]         {
[10:31:29.735]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.735]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.735]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.735]             })
[10:31:29.735]         }
[10:31:29.735]     }, args = future.call.arguments)
[10:31:29.735] }
[10:31:29.735] Lazy evaluation: FALSE
[10:31:29.735] Asynchronous evaluation: TRUE
[10:31:29.735] Local evaluation: TRUE
[10:31:29.735] Environment: R_GlobalEnv
[10:31:29.735] Capture standard output: TRUE
[10:31:29.735] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:29.735] Globals: 5 objects totaling 4.27 KiB (function ‘...future.FUN’ of 4.07 KiB, DotDotDotList ‘future.call.arguments’ of 96 bytes, list ‘...future.elements_ii’ of 112 bytes, NULL ‘...future.seeds_ii’ of 0 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[10:31:29.735] Packages: <none>
[10:31:29.735] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:29.735] Resolved: FALSE
[10:31:29.735] Value: <not collected>
[10:31:29.735] Conditions captured: <none>
[10:31:29.735] Early signaling: FALSE
[10:31:29.735] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:29.735] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.747] Chunk #2 of 2 ... DONE
[10:31:29.747] Launching 2 futures (chunks) ... DONE
[10:31:29.747] Resolving 2 futures (chunks) ...
[10:31:29.747] resolve() on list ...
[10:31:29.747]  recursive: 0
[10:31:29.747]  length: 2
[10:31:29.747] 
[10:31:29.748] receiveMessageFromWorker() for ClusterFuture ...
[10:31:29.748] - Validating connection of MultisessionFuture
[10:31:29.748] - received message: FutureResult
[10:31:29.748] - Received FutureResult
[10:31:29.748] - Erased future from FutureRegistry
[10:31:29.748] result() for ClusterFuture ...
[10:31:29.748] - result already collected: FutureResult
[10:31:29.748] result() for ClusterFuture ... done
[10:31:29.749] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:29.749] Future #1
[10:31:29.749] result() for ClusterFuture ...
[10:31:29.749] - result already collected: FutureResult
[10:31:29.749] result() for ClusterFuture ... done
[10:31:29.749] result() for ClusterFuture ...
[10:31:29.749] - result already collected: FutureResult
[10:31:29.749] result() for ClusterFuture ... done
[10:31:29.749] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:29.749] - nx: 2
[10:31:29.749] - relay: TRUE
[10:31:29.750] - stdout: TRUE
[10:31:29.750] - signal: TRUE
[10:31:29.750] - resignal: FALSE
[10:31:29.750] - force: TRUE
[10:31:29.750] - relayed: [n=2] FALSE, FALSE
[10:31:29.750] - queued futures: [n=2] FALSE, FALSE
[10:31:29.750]  - until=1
[10:31:29.750]  - relaying element #1
[10:31:29.750] result() for ClusterFuture ...
[10:31:29.750] - result already collected: FutureResult
[10:31:29.750] result() for ClusterFuture ... done
[10:31:29.751] result() for ClusterFuture ...
[10:31:29.751] - result already collected: FutureResult
[10:31:29.751] result() for ClusterFuture ... done
[10:31:29.751] result() for ClusterFuture ...
[10:31:29.751] - result already collected: FutureResult
[10:31:29.751] result() for ClusterFuture ... done
[10:31:29.751] result() for ClusterFuture ...
[10:31:29.751] - result already collected: FutureResult
[10:31:29.751] result() for ClusterFuture ... done
[10:31:29.751] - relayed: [n=2] TRUE, FALSE
[10:31:29.751] - queued futures: [n=2] TRUE, FALSE
[10:31:29.752] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:29.752]  length: 1 (resolved future 1)
[10:31:29.778] receiveMessageFromWorker() for ClusterFuture ...
[10:31:29.779] - Validating connection of MultisessionFuture
[10:31:29.779] - received message: FutureResult
[10:31:29.779] - Received FutureResult
[10:31:29.779] - Erased future from FutureRegistry
[10:31:29.779] result() for ClusterFuture ...
[10:31:29.779] - result already collected: FutureResult
[10:31:29.779] result() for ClusterFuture ... done
[10:31:29.779] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:29.780] Future #2
[10:31:29.780] result() for ClusterFuture ...
[10:31:29.780] - result already collected: FutureResult
[10:31:29.780] result() for ClusterFuture ... done
[10:31:29.780] result() for ClusterFuture ...
[10:31:29.780] - result already collected: FutureResult
[10:31:29.780] result() for ClusterFuture ... done
[10:31:29.780] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:29.780] - nx: 2
[10:31:29.780] - relay: TRUE
[10:31:29.780] - stdout: TRUE
[10:31:29.780] - signal: TRUE
[10:31:29.781] - resignal: FALSE
[10:31:29.781] - force: TRUE
[10:31:29.781] - relayed: [n=2] TRUE, FALSE
[10:31:29.781] - queued futures: [n=2] TRUE, FALSE
[10:31:29.781]  - until=2
[10:31:29.781]  - relaying element #2
[10:31:29.781] result() for ClusterFuture ...
[10:31:29.781] - result already collected: FutureResult
[10:31:29.781] result() for ClusterFuture ... done
[10:31:29.781] result() for ClusterFuture ...
[10:31:29.782] - result already collected: FutureResult
[10:31:29.782] result() for ClusterFuture ... done
[10:31:29.782] result() for ClusterFuture ...
[10:31:29.782] - result already collected: FutureResult
[10:31:29.782] result() for ClusterFuture ... done
[10:31:29.782] result() for ClusterFuture ...
[10:31:29.782] - result already collected: FutureResult
[10:31:29.782] result() for ClusterFuture ... done
[10:31:29.782] - relayed: [n=2] TRUE, TRUE
[10:31:29.782] - queued futures: [n=2] TRUE, TRUE
[10:31:29.782] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:29.783]  length: 0 (resolved future 2)
[10:31:29.783] Relaying remaining futures
[10:31:29.783] signalConditionsASAP(NULL, pos=0) ...
[10:31:29.783] - nx: 2
[10:31:29.783] - relay: TRUE
[10:31:29.783] - stdout: TRUE
[10:31:29.783] - signal: TRUE
[10:31:29.783] - resignal: FALSE
[10:31:29.783] - force: TRUE
[10:31:29.783] - relayed: [n=2] TRUE, TRUE
[10:31:29.783] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:29.784] - relayed: [n=2] TRUE, TRUE
[10:31:29.784] - queued futures: [n=2] TRUE, TRUE
[10:31:29.784] signalConditionsASAP(NULL, pos=0) ... done
[10:31:29.784] resolve() on list ... DONE
[10:31:29.784] result() for ClusterFuture ...
[10:31:29.784] - result already collected: FutureResult
[10:31:29.784] result() for ClusterFuture ... done
[10:31:29.784] result() for ClusterFuture ...
[10:31:29.784] - result already collected: FutureResult
[10:31:29.784] result() for ClusterFuture ... done
[10:31:29.784] result() for ClusterFuture ...
[10:31:29.784] - result already collected: FutureResult
[10:31:29.785] result() for ClusterFuture ... done
[10:31:29.785] result() for ClusterFuture ...
[10:31:29.785] - result already collected: FutureResult
[10:31:29.785] result() for ClusterFuture ... done
[10:31:29.785]  - Number of value chunks collected: 2
[10:31:29.785] Resolving 2 futures (chunks) ... DONE
[10:31:29.785] Reducing values from 2 chunks ...
[10:31:29.785]  - Number of values collected after concatenation: 4
[10:31:29.785]  - Number of values expected: 4
[10:31:29.785] Reducing values from 2 chunks ... DONE
[10:31:29.786] future_lapply() ... DONE
[10:31:29.786] future_lapply() ...
[10:31:29.791] Number of chunks: 2
[10:31:29.791] getGlobalsAndPackagesXApply() ...
[10:31:29.792]  - future.globals: TRUE
[10:31:29.792] getGlobalsAndPackages() ...
[10:31:29.792] Searching for globals...
[10:31:29.795] - globals found: [18] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’, ‘outer’, ‘rep’
[10:31:29.795] Searching for globals ... DONE
[10:31:29.795] Resolving globals: FALSE
[10:31:29.796] The total size of the 7 globals is 96.20 KiB (98504 bytes)
[10:31:29.797] The total size of the 7 globals exported for future expression (‘FUN(y = c(2, 4, 6, 8, 10))’) is 96.20 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:29.797] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:29.797] - packages: [1] ‘future.apply’
[10:31:29.797] getGlobalsAndPackages() ... DONE
[10:31:29.797]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:29.797]  - needed namespaces: [n=1] ‘future.apply’
[10:31:29.797] Finding globals ... DONE
[10:31:29.798]  - use_args: TRUE
[10:31:29.798]  - Getting '...' globals ...
[10:31:29.798] resolve() on list ...
[10:31:29.798]  recursive: 0
[10:31:29.798]  length: 1
[10:31:29.798]  elements: ‘...’
[10:31:29.798]  length: 0 (resolved future 1)
[10:31:29.798] resolve() on list ... DONE
[10:31:29.799]    - '...' content: [n=1] ‘y’
[10:31:29.799] List of 1
[10:31:29.799]  $ ...:List of 1
[10:31:29.799]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:29.799]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:29.799]  - attr(*, "where")=List of 1
[10:31:29.799]   ..$ ...:<environment: 0x55de883731a0> 
[10:31:29.799]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:29.799]  - attr(*, "resolved")= logi TRUE
[10:31:29.799]  - attr(*, "total_size")= num NA
[10:31:29.804]  - Getting '...' globals ... DONE
[10:31:29.804] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:29.804] List of 8
[10:31:29.804]  $ ...future.FUN:function (x, ...)  
[10:31:29.804]  $ x_FUN        :function (x, y)  
[10:31:29.804]  $ times        : int 15
[10:31:29.804]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:29.804]  $ stop_if_not  :function (...)  
[10:31:29.804]  $ dim          : int [1:2] 3 5
[10:31:29.804]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:29.804]  $ ...          :List of 1
[10:31:29.804]   ..$ y: num [1:5] 2 4 6 8 10
[10:31:29.804]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:29.804]  - attr(*, "where")=List of 8
[10:31:29.804]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:29.804]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:29.804]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:29.804]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:29.804]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:29.804]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:29.804]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:29.804]   ..$ ...          :<environment: 0x55de883731a0> 
[10:31:29.804]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:29.804]  - attr(*, "resolved")= logi FALSE
[10:31:29.804]  - attr(*, "total_size")= num 98600
[10:31:29.810] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:29.810] getGlobalsAndPackagesXApply() ... DONE
[10:31:29.810] Number of futures (= number of chunks): 2
[10:31:29.810] Launching 2 futures (chunks) ...
[10:31:29.810] Chunk #1 of 2 ...
[10:31:29.811]  - Finding globals in 'X' for chunk #1 ...
[10:31:29.811] getGlobalsAndPackages() ...
[10:31:29.811] Searching for globals...
[10:31:29.811] 
[10:31:29.811] Searching for globals ... DONE
[10:31:29.811] - globals: [0] <none>
[10:31:29.811] getGlobalsAndPackages() ... DONE
[10:31:29.811]    + additional globals found: [n=0] 
[10:31:29.811]    + additional namespaces needed: [n=0] 
[10:31:29.812]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:29.812]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:29.812]  - seeds: <none>
[10:31:29.812]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.812] getGlobalsAndPackages() ...
[10:31:29.812] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.812] Resolving globals: FALSE
[10:31:29.812] Tweak future expression to call with '...' arguments ...
[10:31:29.812] {
[10:31:29.812]     do.call(function(...) {
[10:31:29.812]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.812]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.812]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.812]             on.exit(options(oopts), add = TRUE)
[10:31:29.812]         }
[10:31:29.812]         {
[10:31:29.812]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.812]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.812]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.812]             })
[10:31:29.812]         }
[10:31:29.812]     }, args = future.call.arguments)
[10:31:29.812] }
[10:31:29.813] Tweak future expression to call with '...' arguments ... DONE
[10:31:29.813] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.813] - packages: [1] ‘future.apply’
[10:31:29.813] getGlobalsAndPackages() ... DONE
[10:31:29.814] run() for ‘Future’ ...
[10:31:29.814] - state: ‘created’
[10:31:29.814] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:29.832] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.832] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:29.833]   - Field: ‘node’
[10:31:29.833]   - Field: ‘label’
[10:31:29.833]   - Field: ‘local’
[10:31:29.833]   - Field: ‘owner’
[10:31:29.833]   - Field: ‘envir’
[10:31:29.833]   - Field: ‘workers’
[10:31:29.833]   - Field: ‘packages’
[10:31:29.833]   - Field: ‘gc’
[10:31:29.833]   - Field: ‘conditions’
[10:31:29.834]   - Field: ‘persistent’
[10:31:29.834]   - Field: ‘expr’
[10:31:29.834]   - Field: ‘uuid’
[10:31:29.834]   - Field: ‘seed’
[10:31:29.834]   - Field: ‘version’
[10:31:29.834]   - Field: ‘result’
[10:31:29.834]   - Field: ‘asynchronous’
[10:31:29.834]   - Field: ‘calls’
[10:31:29.834]   - Field: ‘globals’
[10:31:29.834]   - Field: ‘stdout’
[10:31:29.835]   - Field: ‘earlySignal’
[10:31:29.835]   - Field: ‘lazy’
[10:31:29.835]   - Field: ‘state’
[10:31:29.835] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:29.835] - Launch lazy future ...
[10:31:29.835] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:29.835] Packages needed by future strategies (n = 0): <none>
[10:31:29.836] {
[10:31:29.836]     {
[10:31:29.836]         {
[10:31:29.836]             ...future.startTime <- base::Sys.time()
[10:31:29.836]             {
[10:31:29.836]                 {
[10:31:29.836]                   {
[10:31:29.836]                     {
[10:31:29.836]                       {
[10:31:29.836]                         base::local({
[10:31:29.836]                           has_future <- base::requireNamespace("future", 
[10:31:29.836]                             quietly = TRUE)
[10:31:29.836]                           if (has_future) {
[10:31:29.836]                             ns <- base::getNamespace("future")
[10:31:29.836]                             version <- ns[[".package"]][["version"]]
[10:31:29.836]                             if (is.null(version)) 
[10:31:29.836]                               version <- utils::packageVersion("future")
[10:31:29.836]                           }
[10:31:29.836]                           else {
[10:31:29.836]                             version <- NULL
[10:31:29.836]                           }
[10:31:29.836]                           if (!has_future || version < "1.8.0") {
[10:31:29.836]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:29.836]                               "", base::R.version$version.string), 
[10:31:29.836]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:29.836]                                 base::R.version$platform, 8 * 
[10:31:29.836]                                   base::.Machine$sizeof.pointer), 
[10:31:29.836]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:29.836]                                 "release", "version")], collapse = " "), 
[10:31:29.836]                               hostname = base::Sys.info()[["nodename"]])
[10:31:29.836]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:29.836]                               info)
[10:31:29.836]                             info <- base::paste(info, collapse = "; ")
[10:31:29.836]                             if (!has_future) {
[10:31:29.836]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:29.836]                                 info)
[10:31:29.836]                             }
[10:31:29.836]                             else {
[10:31:29.836]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:29.836]                                 info, version)
[10:31:29.836]                             }
[10:31:29.836]                             base::stop(msg)
[10:31:29.836]                           }
[10:31:29.836]                         })
[10:31:29.836]                       }
[10:31:29.836]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:29.836]                       base::options(mc.cores = 1L)
[10:31:29.836]                     }
[10:31:29.836]                     base::local({
[10:31:29.836]                       for (pkg in "future.apply") {
[10:31:29.836]                         base::loadNamespace(pkg)
[10:31:29.836]                         base::library(pkg, character.only = TRUE)
[10:31:29.836]                       }
[10:31:29.836]                     })
[10:31:29.836]                   }
[10:31:29.836]                   ...future.strategy.old <- future::plan("list")
[10:31:29.836]                   options(future.plan = NULL)
[10:31:29.836]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.836]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:29.836]                 }
[10:31:29.836]                 ...future.workdir <- getwd()
[10:31:29.836]             }
[10:31:29.836]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:29.836]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:29.836]         }
[10:31:29.836]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:29.836]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:29.836]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:29.836]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:29.836]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:29.836]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:29.836]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:29.836]             base::names(...future.oldOptions))
[10:31:29.836]     }
[10:31:29.836]     if (FALSE) {
[10:31:29.836]     }
[10:31:29.836]     else {
[10:31:29.836]         if (TRUE) {
[10:31:29.836]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:29.836]                 open = "w")
[10:31:29.836]         }
[10:31:29.836]         else {
[10:31:29.836]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:29.836]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:29.836]         }
[10:31:29.836]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:29.836]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:29.836]             base::sink(type = "output", split = FALSE)
[10:31:29.836]             base::close(...future.stdout)
[10:31:29.836]         }, add = TRUE)
[10:31:29.836]     }
[10:31:29.836]     ...future.frame <- base::sys.nframe()
[10:31:29.836]     ...future.conditions <- base::list()
[10:31:29.836]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:29.836]     if (FALSE) {
[10:31:29.836]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:29.836]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:29.836]     }
[10:31:29.836]     ...future.result <- base::tryCatch({
[10:31:29.836]         base::withCallingHandlers({
[10:31:29.836]             ...future.value <- base::withVisible(base::local({
[10:31:29.836]                 ...future.makeSendCondition <- base::local({
[10:31:29.836]                   sendCondition <- NULL
[10:31:29.836]                   function(frame = 1L) {
[10:31:29.836]                     if (is.function(sendCondition)) 
[10:31:29.836]                       return(sendCondition)
[10:31:29.836]                     ns <- getNamespace("parallel")
[10:31:29.836]                     if (exists("sendData", mode = "function", 
[10:31:29.836]                       envir = ns)) {
[10:31:29.836]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:29.836]                         envir = ns)
[10:31:29.836]                       envir <- sys.frame(frame)
[10:31:29.836]                       master <- NULL
[10:31:29.836]                       while (!identical(envir, .GlobalEnv) && 
[10:31:29.836]                         !identical(envir, emptyenv())) {
[10:31:29.836]                         if (exists("master", mode = "list", envir = envir, 
[10:31:29.836]                           inherits = FALSE)) {
[10:31:29.836]                           master <- get("master", mode = "list", 
[10:31:29.836]                             envir = envir, inherits = FALSE)
[10:31:29.836]                           if (inherits(master, c("SOCKnode", 
[10:31:29.836]                             "SOCK0node"))) {
[10:31:29.836]                             sendCondition <<- function(cond) {
[10:31:29.836]                               data <- list(type = "VALUE", value = cond, 
[10:31:29.836]                                 success = TRUE)
[10:31:29.836]                               parallel_sendData(master, data)
[10:31:29.836]                             }
[10:31:29.836]                             return(sendCondition)
[10:31:29.836]                           }
[10:31:29.836]                         }
[10:31:29.836]                         frame <- frame + 1L
[10:31:29.836]                         envir <- sys.frame(frame)
[10:31:29.836]                       }
[10:31:29.836]                     }
[10:31:29.836]                     sendCondition <<- function(cond) NULL
[10:31:29.836]                   }
[10:31:29.836]                 })
[10:31:29.836]                 withCallingHandlers({
[10:31:29.836]                   {
[10:31:29.836]                     do.call(function(...) {
[10:31:29.836]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.836]                       if (!identical(...future.globals.maxSize.org, 
[10:31:29.836]                         ...future.globals.maxSize)) {
[10:31:29.836]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.836]                         on.exit(options(oopts), add = TRUE)
[10:31:29.836]                       }
[10:31:29.836]                       {
[10:31:29.836]                         lapply(seq_along(...future.elements_ii), 
[10:31:29.836]                           FUN = function(jj) {
[10:31:29.836]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.836]                             ...future.FUN(...future.X_jj, ...)
[10:31:29.836]                           })
[10:31:29.836]                       }
[10:31:29.836]                     }, args = future.call.arguments)
[10:31:29.836]                   }
[10:31:29.836]                 }, immediateCondition = function(cond) {
[10:31:29.836]                   sendCondition <- ...future.makeSendCondition()
[10:31:29.836]                   sendCondition(cond)
[10:31:29.836]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.836]                   {
[10:31:29.836]                     inherits <- base::inherits
[10:31:29.836]                     invokeRestart <- base::invokeRestart
[10:31:29.836]                     is.null <- base::is.null
[10:31:29.836]                     muffled <- FALSE
[10:31:29.836]                     if (inherits(cond, "message")) {
[10:31:29.836]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:29.836]                       if (muffled) 
[10:31:29.836]                         invokeRestart("muffleMessage")
[10:31:29.836]                     }
[10:31:29.836]                     else if (inherits(cond, "warning")) {
[10:31:29.836]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:29.836]                       if (muffled) 
[10:31:29.836]                         invokeRestart("muffleWarning")
[10:31:29.836]                     }
[10:31:29.836]                     else if (inherits(cond, "condition")) {
[10:31:29.836]                       if (!is.null(pattern)) {
[10:31:29.836]                         computeRestarts <- base::computeRestarts
[10:31:29.836]                         grepl <- base::grepl
[10:31:29.836]                         restarts <- computeRestarts(cond)
[10:31:29.836]                         for (restart in restarts) {
[10:31:29.836]                           name <- restart$name
[10:31:29.836]                           if (is.null(name)) 
[10:31:29.836]                             next
[10:31:29.836]                           if (!grepl(pattern, name)) 
[10:31:29.836]                             next
[10:31:29.836]                           invokeRestart(restart)
[10:31:29.836]                           muffled <- TRUE
[10:31:29.836]                           break
[10:31:29.836]                         }
[10:31:29.836]                       }
[10:31:29.836]                     }
[10:31:29.836]                     invisible(muffled)
[10:31:29.836]                   }
[10:31:29.836]                   muffleCondition(cond)
[10:31:29.836]                 })
[10:31:29.836]             }))
[10:31:29.836]             future::FutureResult(value = ...future.value$value, 
[10:31:29.836]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.836]                   ...future.rng), globalenv = if (FALSE) 
[10:31:29.836]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:29.836]                     ...future.globalenv.names))
[10:31:29.836]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:29.836]         }, condition = base::local({
[10:31:29.836]             c <- base::c
[10:31:29.836]             inherits <- base::inherits
[10:31:29.836]             invokeRestart <- base::invokeRestart
[10:31:29.836]             length <- base::length
[10:31:29.836]             list <- base::list
[10:31:29.836]             seq.int <- base::seq.int
[10:31:29.836]             signalCondition <- base::signalCondition
[10:31:29.836]             sys.calls <- base::sys.calls
[10:31:29.836]             `[[` <- base::`[[`
[10:31:29.836]             `+` <- base::`+`
[10:31:29.836]             `<<-` <- base::`<<-`
[10:31:29.836]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:29.836]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:29.836]                   3L)]
[10:31:29.836]             }
[10:31:29.836]             function(cond) {
[10:31:29.836]                 is_error <- inherits(cond, "error")
[10:31:29.836]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:29.836]                   NULL)
[10:31:29.836]                 if (is_error) {
[10:31:29.836]                   sessionInformation <- function() {
[10:31:29.836]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:29.836]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:29.836]                       search = base::search(), system = base::Sys.info())
[10:31:29.836]                   }
[10:31:29.836]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.836]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:29.836]                     cond$call), session = sessionInformation(), 
[10:31:29.836]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:29.836]                   signalCondition(cond)
[10:31:29.836]                 }
[10:31:29.836]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:29.836]                 "immediateCondition"))) {
[10:31:29.836]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:29.836]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.836]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:29.836]                   if (TRUE && !signal) {
[10:31:29.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.836]                     {
[10:31:29.836]                       inherits <- base::inherits
[10:31:29.836]                       invokeRestart <- base::invokeRestart
[10:31:29.836]                       is.null <- base::is.null
[10:31:29.836]                       muffled <- FALSE
[10:31:29.836]                       if (inherits(cond, "message")) {
[10:31:29.836]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.836]                         if (muffled) 
[10:31:29.836]                           invokeRestart("muffleMessage")
[10:31:29.836]                       }
[10:31:29.836]                       else if (inherits(cond, "warning")) {
[10:31:29.836]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.836]                         if (muffled) 
[10:31:29.836]                           invokeRestart("muffleWarning")
[10:31:29.836]                       }
[10:31:29.836]                       else if (inherits(cond, "condition")) {
[10:31:29.836]                         if (!is.null(pattern)) {
[10:31:29.836]                           computeRestarts <- base::computeRestarts
[10:31:29.836]                           grepl <- base::grepl
[10:31:29.836]                           restarts <- computeRestarts(cond)
[10:31:29.836]                           for (restart in restarts) {
[10:31:29.836]                             name <- restart$name
[10:31:29.836]                             if (is.null(name)) 
[10:31:29.836]                               next
[10:31:29.836]                             if (!grepl(pattern, name)) 
[10:31:29.836]                               next
[10:31:29.836]                             invokeRestart(restart)
[10:31:29.836]                             muffled <- TRUE
[10:31:29.836]                             break
[10:31:29.836]                           }
[10:31:29.836]                         }
[10:31:29.836]                       }
[10:31:29.836]                       invisible(muffled)
[10:31:29.836]                     }
[10:31:29.836]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.836]                   }
[10:31:29.836]                 }
[10:31:29.836]                 else {
[10:31:29.836]                   if (TRUE) {
[10:31:29.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.836]                     {
[10:31:29.836]                       inherits <- base::inherits
[10:31:29.836]                       invokeRestart <- base::invokeRestart
[10:31:29.836]                       is.null <- base::is.null
[10:31:29.836]                       muffled <- FALSE
[10:31:29.836]                       if (inherits(cond, "message")) {
[10:31:29.836]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.836]                         if (muffled) 
[10:31:29.836]                           invokeRestart("muffleMessage")
[10:31:29.836]                       }
[10:31:29.836]                       else if (inherits(cond, "warning")) {
[10:31:29.836]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.836]                         if (muffled) 
[10:31:29.836]                           invokeRestart("muffleWarning")
[10:31:29.836]                       }
[10:31:29.836]                       else if (inherits(cond, "condition")) {
[10:31:29.836]                         if (!is.null(pattern)) {
[10:31:29.836]                           computeRestarts <- base::computeRestarts
[10:31:29.836]                           grepl <- base::grepl
[10:31:29.836]                           restarts <- computeRestarts(cond)
[10:31:29.836]                           for (restart in restarts) {
[10:31:29.836]                             name <- restart$name
[10:31:29.836]                             if (is.null(name)) 
[10:31:29.836]                               next
[10:31:29.836]                             if (!grepl(pattern, name)) 
[10:31:29.836]                               next
[10:31:29.836]                             invokeRestart(restart)
[10:31:29.836]                             muffled <- TRUE
[10:31:29.836]                             break
[10:31:29.836]                           }
[10:31:29.836]                         }
[10:31:29.836]                       }
[10:31:29.836]                       invisible(muffled)
[10:31:29.836]                     }
[10:31:29.836]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.836]                   }
[10:31:29.836]                 }
[10:31:29.836]             }
[10:31:29.836]         }))
[10:31:29.836]     }, error = function(ex) {
[10:31:29.836]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:29.836]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.836]                 ...future.rng), started = ...future.startTime, 
[10:31:29.836]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:29.836]             version = "1.8"), class = "FutureResult")
[10:31:29.836]     }, finally = {
[10:31:29.836]         if (!identical(...future.workdir, getwd())) 
[10:31:29.836]             setwd(...future.workdir)
[10:31:29.836]         {
[10:31:29.836]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:29.836]                 ...future.oldOptions$nwarnings <- NULL
[10:31:29.836]             }
[10:31:29.836]             base::options(...future.oldOptions)
[10:31:29.836]             if (.Platform$OS.type == "windows") {
[10:31:29.836]                 old_names <- names(...future.oldEnvVars)
[10:31:29.836]                 envs <- base::Sys.getenv()
[10:31:29.836]                 names <- names(envs)
[10:31:29.836]                 common <- intersect(names, old_names)
[10:31:29.836]                 added <- setdiff(names, old_names)
[10:31:29.836]                 removed <- setdiff(old_names, names)
[10:31:29.836]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:29.836]                   envs[common]]
[10:31:29.836]                 NAMES <- toupper(changed)
[10:31:29.836]                 args <- list()
[10:31:29.836]                 for (kk in seq_along(NAMES)) {
[10:31:29.836]                   name <- changed[[kk]]
[10:31:29.836]                   NAME <- NAMES[[kk]]
[10:31:29.836]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.836]                     next
[10:31:29.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.836]                 }
[10:31:29.836]                 NAMES <- toupper(added)
[10:31:29.836]                 for (kk in seq_along(NAMES)) {
[10:31:29.836]                   name <- added[[kk]]
[10:31:29.836]                   NAME <- NAMES[[kk]]
[10:31:29.836]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.836]                     next
[10:31:29.836]                   args[[name]] <- ""
[10:31:29.836]                 }
[10:31:29.836]                 NAMES <- toupper(removed)
[10:31:29.836]                 for (kk in seq_along(NAMES)) {
[10:31:29.836]                   name <- removed[[kk]]
[10:31:29.836]                   NAME <- NAMES[[kk]]
[10:31:29.836]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.836]                     next
[10:31:29.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.836]                 }
[10:31:29.836]                 if (length(args) > 0) 
[10:31:29.836]                   base::do.call(base::Sys.setenv, args = args)
[10:31:29.836]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:29.836]             }
[10:31:29.836]             else {
[10:31:29.836]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:29.836]             }
[10:31:29.836]             {
[10:31:29.836]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:29.836]                   0L) {
[10:31:29.836]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:29.836]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:29.836]                   base::options(opts)
[10:31:29.836]                 }
[10:31:29.836]                 {
[10:31:29.836]                   {
[10:31:29.836]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:29.836]                     NULL
[10:31:29.836]                   }
[10:31:29.836]                   options(future.plan = NULL)
[10:31:29.836]                   if (is.na(NA_character_)) 
[10:31:29.836]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.836]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:29.836]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:29.836]                     .init = FALSE)
[10:31:29.836]                 }
[10:31:29.836]             }
[10:31:29.836]         }
[10:31:29.836]     })
[10:31:29.836]     if (TRUE) {
[10:31:29.836]         base::sink(type = "output", split = FALSE)
[10:31:29.836]         if (TRUE) {
[10:31:29.836]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:29.836]         }
[10:31:29.836]         else {
[10:31:29.836]             ...future.result["stdout"] <- base::list(NULL)
[10:31:29.836]         }
[10:31:29.836]         base::close(...future.stdout)
[10:31:29.836]         ...future.stdout <- NULL
[10:31:29.836]     }
[10:31:29.836]     ...future.result$conditions <- ...future.conditions
[10:31:29.836]     ...future.result$finished <- base::Sys.time()
[10:31:29.836]     ...future.result
[10:31:29.836] }
[10:31:29.839] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[10:31:29.839] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:29.881] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:29.881] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[10:31:29.882] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[10:31:29.882] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:29.882] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:29.882] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:29.925] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:29.925] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:29.969] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:29.969] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[10:31:29.970] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[10:31:29.970] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:31:29.970] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:31:29.970] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[10:31:29.971] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[10:31:29.971] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:31:29.971] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:31:29.971] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:29.972] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.972] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:29.972] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:29.972] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[10:31:29.973] MultisessionFuture started
[10:31:29.973] - Launch lazy future ... done
[10:31:29.973] run() for ‘MultisessionFuture’ ... done
[10:31:29.973] Created future:
[10:31:29.975] receiveMessageFromWorker() for ClusterFuture ...
[10:31:29.975] - Validating connection of MultisessionFuture
[10:31:29.975] - received message: FutureResult
[10:31:29.975] - Received FutureResult
[10:31:29.975] - Erased future from FutureRegistry
[10:31:29.975] result() for ClusterFuture ...
[10:31:29.975] - result already collected: FutureResult
[10:31:29.975] result() for ClusterFuture ... done
[10:31:29.975] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:29.973] MultisessionFuture:
[10:31:29.973] Label: ‘future_vapply-1’
[10:31:29.973] Expression:
[10:31:29.973] {
[10:31:29.973]     do.call(function(...) {
[10:31:29.973]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.973]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.973]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.973]             on.exit(options(oopts), add = TRUE)
[10:31:29.973]         }
[10:31:29.973]         {
[10:31:29.973]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.973]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.973]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.973]             })
[10:31:29.973]         }
[10:31:29.973]     }, args = future.call.arguments)
[10:31:29.973] }
[10:31:29.973] Lazy evaluation: FALSE
[10:31:29.973] Asynchronous evaluation: TRUE
[10:31:29.973] Local evaluation: TRUE
[10:31:29.973] Environment: R_GlobalEnv
[10:31:29.973] Capture standard output: TRUE
[10:31:29.973] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:29.973] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:29.973] Packages: 1 packages (‘future.apply’)
[10:31:29.973] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:29.973] Resolved: TRUE
[10:31:29.973] Value: <not collected>
[10:31:29.973] Conditions captured: <none>
[10:31:29.973] Early signaling: FALSE
[10:31:29.973] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:29.973] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.976] Chunk #1 of 2 ... DONE
[10:31:29.976] Chunk #2 of 2 ...
[10:31:29.976]  - Finding globals in 'X' for chunk #2 ...
[10:31:29.976] getGlobalsAndPackages() ...
[10:31:29.976] Searching for globals...
[10:31:29.976] 
[10:31:29.976] Searching for globals ... DONE
[10:31:29.977] - globals: [0] <none>
[10:31:29.977] getGlobalsAndPackages() ... DONE
[10:31:29.977]    + additional globals found: [n=0] 
[10:31:29.977]    + additional namespaces needed: [n=0] 
[10:31:29.977]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:29.977]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:29.977]  - seeds: <none>
[10:31:29.977]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.977] getGlobalsAndPackages() ...
[10:31:29.977] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.978] Resolving globals: FALSE
[10:31:29.978] Tweak future expression to call with '...' arguments ...
[10:31:29.978] {
[10:31:29.978]     do.call(function(...) {
[10:31:29.978]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.978]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:29.978]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.978]             on.exit(options(oopts), add = TRUE)
[10:31:29.978]         }
[10:31:29.978]         {
[10:31:29.978]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:29.978]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.978]                 ...future.FUN(...future.X_jj, ...)
[10:31:29.978]             })
[10:31:29.978]         }
[10:31:29.978]     }, args = future.call.arguments)
[10:31:29.978] }
[10:31:29.978] Tweak future expression to call with '...' arguments ... DONE
[10:31:29.979] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:29.979] - packages: [1] ‘future.apply’
[10:31:29.979] getGlobalsAndPackages() ... DONE
[10:31:29.979] run() for ‘Future’ ...
[10:31:29.979] - state: ‘created’
[10:31:29.979] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:29.993] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:29.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:29.994]   - Field: ‘node’
[10:31:29.994]   - Field: ‘label’
[10:31:29.994]   - Field: ‘local’
[10:31:29.994]   - Field: ‘owner’
[10:31:29.994]   - Field: ‘envir’
[10:31:29.994]   - Field: ‘workers’
[10:31:29.994]   - Field: ‘packages’
[10:31:29.994]   - Field: ‘gc’
[10:31:29.994]   - Field: ‘conditions’
[10:31:29.994]   - Field: ‘persistent’
[10:31:29.995]   - Field: ‘expr’
[10:31:29.995]   - Field: ‘uuid’
[10:31:29.995]   - Field: ‘seed’
[10:31:29.995]   - Field: ‘version’
[10:31:29.995]   - Field: ‘result’
[10:31:29.995]   - Field: ‘asynchronous’
[10:31:29.995]   - Field: ‘calls’
[10:31:29.995]   - Field: ‘globals’
[10:31:29.995]   - Field: ‘stdout’
[10:31:29.995]   - Field: ‘earlySignal’
[10:31:29.995]   - Field: ‘lazy’
[10:31:29.996]   - Field: ‘state’
[10:31:29.996] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:29.996] - Launch lazy future ...
[10:31:29.996] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:29.996] Packages needed by future strategies (n = 0): <none>
[10:31:29.997] {
[10:31:29.997]     {
[10:31:29.997]         {
[10:31:29.997]             ...future.startTime <- base::Sys.time()
[10:31:29.997]             {
[10:31:29.997]                 {
[10:31:29.997]                   {
[10:31:29.997]                     {
[10:31:29.997]                       {
[10:31:29.997]                         base::local({
[10:31:29.997]                           has_future <- base::requireNamespace("future", 
[10:31:29.997]                             quietly = TRUE)
[10:31:29.997]                           if (has_future) {
[10:31:29.997]                             ns <- base::getNamespace("future")
[10:31:29.997]                             version <- ns[[".package"]][["version"]]
[10:31:29.997]                             if (is.null(version)) 
[10:31:29.997]                               version <- utils::packageVersion("future")
[10:31:29.997]                           }
[10:31:29.997]                           else {
[10:31:29.997]                             version <- NULL
[10:31:29.997]                           }
[10:31:29.997]                           if (!has_future || version < "1.8.0") {
[10:31:29.997]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:29.997]                               "", base::R.version$version.string), 
[10:31:29.997]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:29.997]                                 base::R.version$platform, 8 * 
[10:31:29.997]                                   base::.Machine$sizeof.pointer), 
[10:31:29.997]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:29.997]                                 "release", "version")], collapse = " "), 
[10:31:29.997]                               hostname = base::Sys.info()[["nodename"]])
[10:31:29.997]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:29.997]                               info)
[10:31:29.997]                             info <- base::paste(info, collapse = "; ")
[10:31:29.997]                             if (!has_future) {
[10:31:29.997]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:29.997]                                 info)
[10:31:29.997]                             }
[10:31:29.997]                             else {
[10:31:29.997]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:29.997]                                 info, version)
[10:31:29.997]                             }
[10:31:29.997]                             base::stop(msg)
[10:31:29.997]                           }
[10:31:29.997]                         })
[10:31:29.997]                       }
[10:31:29.997]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:29.997]                       base::options(mc.cores = 1L)
[10:31:29.997]                     }
[10:31:29.997]                     base::local({
[10:31:29.997]                       for (pkg in "future.apply") {
[10:31:29.997]                         base::loadNamespace(pkg)
[10:31:29.997]                         base::library(pkg, character.only = TRUE)
[10:31:29.997]                       }
[10:31:29.997]                     })
[10:31:29.997]                   }
[10:31:29.997]                   ...future.strategy.old <- future::plan("list")
[10:31:29.997]                   options(future.plan = NULL)
[10:31:29.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:29.997]                 }
[10:31:29.997]                 ...future.workdir <- getwd()
[10:31:29.997]             }
[10:31:29.997]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:29.997]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:29.997]         }
[10:31:29.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:29.997]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:29.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:29.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:29.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:29.997]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:29.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:29.997]             base::names(...future.oldOptions))
[10:31:29.997]     }
[10:31:29.997]     if (FALSE) {
[10:31:29.997]     }
[10:31:29.997]     else {
[10:31:29.997]         if (TRUE) {
[10:31:29.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:29.997]                 open = "w")
[10:31:29.997]         }
[10:31:29.997]         else {
[10:31:29.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:29.997]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:29.997]         }
[10:31:29.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:29.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:29.997]             base::sink(type = "output", split = FALSE)
[10:31:29.997]             base::close(...future.stdout)
[10:31:29.997]         }, add = TRUE)
[10:31:29.997]     }
[10:31:29.997]     ...future.frame <- base::sys.nframe()
[10:31:29.997]     ...future.conditions <- base::list()
[10:31:29.997]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:29.997]     if (FALSE) {
[10:31:29.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:29.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:29.997]     }
[10:31:29.997]     ...future.result <- base::tryCatch({
[10:31:29.997]         base::withCallingHandlers({
[10:31:29.997]             ...future.value <- base::withVisible(base::local({
[10:31:29.997]                 ...future.makeSendCondition <- base::local({
[10:31:29.997]                   sendCondition <- NULL
[10:31:29.997]                   function(frame = 1L) {
[10:31:29.997]                     if (is.function(sendCondition)) 
[10:31:29.997]                       return(sendCondition)
[10:31:29.997]                     ns <- getNamespace("parallel")
[10:31:29.997]                     if (exists("sendData", mode = "function", 
[10:31:29.997]                       envir = ns)) {
[10:31:29.997]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:29.997]                         envir = ns)
[10:31:29.997]                       envir <- sys.frame(frame)
[10:31:29.997]                       master <- NULL
[10:31:29.997]                       while (!identical(envir, .GlobalEnv) && 
[10:31:29.997]                         !identical(envir, emptyenv())) {
[10:31:29.997]                         if (exists("master", mode = "list", envir = envir, 
[10:31:29.997]                           inherits = FALSE)) {
[10:31:29.997]                           master <- get("master", mode = "list", 
[10:31:29.997]                             envir = envir, inherits = FALSE)
[10:31:29.997]                           if (inherits(master, c("SOCKnode", 
[10:31:29.997]                             "SOCK0node"))) {
[10:31:29.997]                             sendCondition <<- function(cond) {
[10:31:29.997]                               data <- list(type = "VALUE", value = cond, 
[10:31:29.997]                                 success = TRUE)
[10:31:29.997]                               parallel_sendData(master, data)
[10:31:29.997]                             }
[10:31:29.997]                             return(sendCondition)
[10:31:29.997]                           }
[10:31:29.997]                         }
[10:31:29.997]                         frame <- frame + 1L
[10:31:29.997]                         envir <- sys.frame(frame)
[10:31:29.997]                       }
[10:31:29.997]                     }
[10:31:29.997]                     sendCondition <<- function(cond) NULL
[10:31:29.997]                   }
[10:31:29.997]                 })
[10:31:29.997]                 withCallingHandlers({
[10:31:29.997]                   {
[10:31:29.997]                     do.call(function(...) {
[10:31:29.997]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:29.997]                       if (!identical(...future.globals.maxSize.org, 
[10:31:29.997]                         ...future.globals.maxSize)) {
[10:31:29.997]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:29.997]                         on.exit(options(oopts), add = TRUE)
[10:31:29.997]                       }
[10:31:29.997]                       {
[10:31:29.997]                         lapply(seq_along(...future.elements_ii), 
[10:31:29.997]                           FUN = function(jj) {
[10:31:29.997]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:29.997]                             ...future.FUN(...future.X_jj, ...)
[10:31:29.997]                           })
[10:31:29.997]                       }
[10:31:29.997]                     }, args = future.call.arguments)
[10:31:29.997]                   }
[10:31:29.997]                 }, immediateCondition = function(cond) {
[10:31:29.997]                   sendCondition <- ...future.makeSendCondition()
[10:31:29.997]                   sendCondition(cond)
[10:31:29.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.997]                   {
[10:31:29.997]                     inherits <- base::inherits
[10:31:29.997]                     invokeRestart <- base::invokeRestart
[10:31:29.997]                     is.null <- base::is.null
[10:31:29.997]                     muffled <- FALSE
[10:31:29.997]                     if (inherits(cond, "message")) {
[10:31:29.997]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:29.997]                       if (muffled) 
[10:31:29.997]                         invokeRestart("muffleMessage")
[10:31:29.997]                     }
[10:31:29.997]                     else if (inherits(cond, "warning")) {
[10:31:29.997]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:29.997]                       if (muffled) 
[10:31:29.997]                         invokeRestart("muffleWarning")
[10:31:29.997]                     }
[10:31:29.997]                     else if (inherits(cond, "condition")) {
[10:31:29.997]                       if (!is.null(pattern)) {
[10:31:29.997]                         computeRestarts <- base::computeRestarts
[10:31:29.997]                         grepl <- base::grepl
[10:31:29.997]                         restarts <- computeRestarts(cond)
[10:31:29.997]                         for (restart in restarts) {
[10:31:29.997]                           name <- restart$name
[10:31:29.997]                           if (is.null(name)) 
[10:31:29.997]                             next
[10:31:29.997]                           if (!grepl(pattern, name)) 
[10:31:29.997]                             next
[10:31:29.997]                           invokeRestart(restart)
[10:31:29.997]                           muffled <- TRUE
[10:31:29.997]                           break
[10:31:29.997]                         }
[10:31:29.997]                       }
[10:31:29.997]                     }
[10:31:29.997]                     invisible(muffled)
[10:31:29.997]                   }
[10:31:29.997]                   muffleCondition(cond)
[10:31:29.997]                 })
[10:31:29.997]             }))
[10:31:29.997]             future::FutureResult(value = ...future.value$value, 
[10:31:29.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.997]                   ...future.rng), globalenv = if (FALSE) 
[10:31:29.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:29.997]                     ...future.globalenv.names))
[10:31:29.997]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:29.997]         }, condition = base::local({
[10:31:29.997]             c <- base::c
[10:31:29.997]             inherits <- base::inherits
[10:31:29.997]             invokeRestart <- base::invokeRestart
[10:31:29.997]             length <- base::length
[10:31:29.997]             list <- base::list
[10:31:29.997]             seq.int <- base::seq.int
[10:31:29.997]             signalCondition <- base::signalCondition
[10:31:29.997]             sys.calls <- base::sys.calls
[10:31:29.997]             `[[` <- base::`[[`
[10:31:29.997]             `+` <- base::`+`
[10:31:29.997]             `<<-` <- base::`<<-`
[10:31:29.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:29.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:29.997]                   3L)]
[10:31:29.997]             }
[10:31:29.997]             function(cond) {
[10:31:29.997]                 is_error <- inherits(cond, "error")
[10:31:29.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:29.997]                   NULL)
[10:31:29.997]                 if (is_error) {
[10:31:29.997]                   sessionInformation <- function() {
[10:31:29.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:29.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:29.997]                       search = base::search(), system = base::Sys.info())
[10:31:29.997]                   }
[10:31:29.997]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:29.997]                     cond$call), session = sessionInformation(), 
[10:31:29.997]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:29.997]                   signalCondition(cond)
[10:31:29.997]                 }
[10:31:29.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:29.997]                 "immediateCondition"))) {
[10:31:29.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:29.997]                   ...future.conditions[[length(...future.conditions) + 
[10:31:29.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:29.997]                   if (TRUE && !signal) {
[10:31:29.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.997]                     {
[10:31:29.997]                       inherits <- base::inherits
[10:31:29.997]                       invokeRestart <- base::invokeRestart
[10:31:29.997]                       is.null <- base::is.null
[10:31:29.997]                       muffled <- FALSE
[10:31:29.997]                       if (inherits(cond, "message")) {
[10:31:29.997]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.997]                         if (muffled) 
[10:31:29.997]                           invokeRestart("muffleMessage")
[10:31:29.997]                       }
[10:31:29.997]                       else if (inherits(cond, "warning")) {
[10:31:29.997]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.997]                         if (muffled) 
[10:31:29.997]                           invokeRestart("muffleWarning")
[10:31:29.997]                       }
[10:31:29.997]                       else if (inherits(cond, "condition")) {
[10:31:29.997]                         if (!is.null(pattern)) {
[10:31:29.997]                           computeRestarts <- base::computeRestarts
[10:31:29.997]                           grepl <- base::grepl
[10:31:29.997]                           restarts <- computeRestarts(cond)
[10:31:29.997]                           for (restart in restarts) {
[10:31:29.997]                             name <- restart$name
[10:31:29.997]                             if (is.null(name)) 
[10:31:29.997]                               next
[10:31:29.997]                             if (!grepl(pattern, name)) 
[10:31:29.997]                               next
[10:31:29.997]                             invokeRestart(restart)
[10:31:29.997]                             muffled <- TRUE
[10:31:29.997]                             break
[10:31:29.997]                           }
[10:31:29.997]                         }
[10:31:29.997]                       }
[10:31:29.997]                       invisible(muffled)
[10:31:29.997]                     }
[10:31:29.997]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.997]                   }
[10:31:29.997]                 }
[10:31:29.997]                 else {
[10:31:29.997]                   if (TRUE) {
[10:31:29.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:29.997]                     {
[10:31:29.997]                       inherits <- base::inherits
[10:31:29.997]                       invokeRestart <- base::invokeRestart
[10:31:29.997]                       is.null <- base::is.null
[10:31:29.997]                       muffled <- FALSE
[10:31:29.997]                       if (inherits(cond, "message")) {
[10:31:29.997]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:29.997]                         if (muffled) 
[10:31:29.997]                           invokeRestart("muffleMessage")
[10:31:29.997]                       }
[10:31:29.997]                       else if (inherits(cond, "warning")) {
[10:31:29.997]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:29.997]                         if (muffled) 
[10:31:29.997]                           invokeRestart("muffleWarning")
[10:31:29.997]                       }
[10:31:29.997]                       else if (inherits(cond, "condition")) {
[10:31:29.997]                         if (!is.null(pattern)) {
[10:31:29.997]                           computeRestarts <- base::computeRestarts
[10:31:29.997]                           grepl <- base::grepl
[10:31:29.997]                           restarts <- computeRestarts(cond)
[10:31:29.997]                           for (restart in restarts) {
[10:31:29.997]                             name <- restart$name
[10:31:29.997]                             if (is.null(name)) 
[10:31:29.997]                               next
[10:31:29.997]                             if (!grepl(pattern, name)) 
[10:31:29.997]                               next
[10:31:29.997]                             invokeRestart(restart)
[10:31:29.997]                             muffled <- TRUE
[10:31:29.997]                             break
[10:31:29.997]                           }
[10:31:29.997]                         }
[10:31:29.997]                       }
[10:31:29.997]                       invisible(muffled)
[10:31:29.997]                     }
[10:31:29.997]                     muffleCondition(cond, pattern = "^muffle")
[10:31:29.997]                   }
[10:31:29.997]                 }
[10:31:29.997]             }
[10:31:29.997]         }))
[10:31:29.997]     }, error = function(ex) {
[10:31:29.997]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:29.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:29.997]                 ...future.rng), started = ...future.startTime, 
[10:31:29.997]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:29.997]             version = "1.8"), class = "FutureResult")
[10:31:29.997]     }, finally = {
[10:31:29.997]         if (!identical(...future.workdir, getwd())) 
[10:31:29.997]             setwd(...future.workdir)
[10:31:29.997]         {
[10:31:29.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:29.997]                 ...future.oldOptions$nwarnings <- NULL
[10:31:29.997]             }
[10:31:29.997]             base::options(...future.oldOptions)
[10:31:29.997]             if (.Platform$OS.type == "windows") {
[10:31:29.997]                 old_names <- names(...future.oldEnvVars)
[10:31:29.997]                 envs <- base::Sys.getenv()
[10:31:29.997]                 names <- names(envs)
[10:31:29.997]                 common <- intersect(names, old_names)
[10:31:29.997]                 added <- setdiff(names, old_names)
[10:31:29.997]                 removed <- setdiff(old_names, names)
[10:31:29.997]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:29.997]                   envs[common]]
[10:31:29.997]                 NAMES <- toupper(changed)
[10:31:29.997]                 args <- list()
[10:31:29.997]                 for (kk in seq_along(NAMES)) {
[10:31:29.997]                   name <- changed[[kk]]
[10:31:29.997]                   NAME <- NAMES[[kk]]
[10:31:29.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.997]                     next
[10:31:29.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.997]                 }
[10:31:29.997]                 NAMES <- toupper(added)
[10:31:29.997]                 for (kk in seq_along(NAMES)) {
[10:31:29.997]                   name <- added[[kk]]
[10:31:29.997]                   NAME <- NAMES[[kk]]
[10:31:29.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.997]                     next
[10:31:29.997]                   args[[name]] <- ""
[10:31:29.997]                 }
[10:31:29.997]                 NAMES <- toupper(removed)
[10:31:29.997]                 for (kk in seq_along(NAMES)) {
[10:31:29.997]                   name <- removed[[kk]]
[10:31:29.997]                   NAME <- NAMES[[kk]]
[10:31:29.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:29.997]                     next
[10:31:29.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:29.997]                 }
[10:31:29.997]                 if (length(args) > 0) 
[10:31:29.997]                   base::do.call(base::Sys.setenv, args = args)
[10:31:29.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:29.997]             }
[10:31:29.997]             else {
[10:31:29.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:29.997]             }
[10:31:29.997]             {
[10:31:29.997]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:29.997]                   0L) {
[10:31:29.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:29.997]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:29.997]                   base::options(opts)
[10:31:29.997]                 }
[10:31:29.997]                 {
[10:31:29.997]                   {
[10:31:29.997]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:29.997]                     NULL
[10:31:29.997]                   }
[10:31:29.997]                   options(future.plan = NULL)
[10:31:29.997]                   if (is.na(NA_character_)) 
[10:31:29.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:29.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:29.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:29.997]                     .init = FALSE)
[10:31:29.997]                 }
[10:31:29.997]             }
[10:31:29.997]         }
[10:31:29.997]     })
[10:31:29.997]     if (TRUE) {
[10:31:29.997]         base::sink(type = "output", split = FALSE)
[10:31:29.997]         if (TRUE) {
[10:31:29.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:29.997]         }
[10:31:29.997]         else {
[10:31:29.997]             ...future.result["stdout"] <- base::list(NULL)
[10:31:29.997]         }
[10:31:29.997]         base::close(...future.stdout)
[10:31:29.997]         ...future.stdout <- NULL
[10:31:29.997]     }
[10:31:29.997]     ...future.result$conditions <- ...future.conditions
[10:31:29.997]     ...future.result$finished <- base::Sys.time()
[10:31:29.997]     ...future.result
[10:31:29.997] }
[10:31:29.999] Exporting 11 global objects (96.29 KiB) to cluster node #1 ...
[10:31:30.000] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:30.041] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:30.041] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ...
[10:31:30.042] Exporting ‘x_FUN’ (4.07 KiB) to cluster node #1 ... DONE
[10:31:30.042] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:30.042] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:30.042] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:30.085] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:30.085] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:30.129] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:30.129] Exporting ‘dim’ (56 bytes) to cluster node #1 ...
[10:31:30.130] Exporting ‘dim’ (56 bytes) to cluster node #1 ... DONE
[10:31:30.130] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:31:30.130] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:31:30.130] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ...
[10:31:30.131] Exporting ‘future.call.arguments’ (96 bytes) to cluster node #1 ... DONE
[10:31:30.131] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:31:30.131] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:31:30.131] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:30.132] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.132] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:30.132] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.132] Exporting 11 global objects (96.29 KiB) to cluster node #1 ... DONE
[10:31:30.133] MultisessionFuture started
[10:31:30.133] - Launch lazy future ... done
[10:31:30.133] run() for ‘MultisessionFuture’ ... done
[10:31:30.133] Created future:
[10:31:30.135] receiveMessageFromWorker() for ClusterFuture ...
[10:31:30.135] - Validating connection of MultisessionFuture
[10:31:30.135] - received message: FutureResult
[10:31:30.135] - Received FutureResult
[10:31:30.135] - Erased future from FutureRegistry
[10:31:30.135] result() for ClusterFuture ...
[10:31:30.135] - result already collected: FutureResult
[10:31:30.135] result() for ClusterFuture ... done
[10:31:30.136] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:30.133] MultisessionFuture:
[10:31:30.133] Label: ‘future_vapply-2’
[10:31:30.133] Expression:
[10:31:30.133] {
[10:31:30.133]     do.call(function(...) {
[10:31:30.133]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.133]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:30.133]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.133]             on.exit(options(oopts), add = TRUE)
[10:31:30.133]         }
[10:31:30.133]         {
[10:31:30.133]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:30.133]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.133]                 ...future.FUN(...future.X_jj, ...)
[10:31:30.133]             })
[10:31:30.133]         }
[10:31:30.133]     }, args = future.call.arguments)
[10:31:30.133] }
[10:31:30.133] Lazy evaluation: FALSE
[10:31:30.133] Asynchronous evaluation: TRUE
[10:31:30.133] Local evaluation: TRUE
[10:31:30.133] Environment: R_GlobalEnv
[10:31:30.133] Capture standard output: TRUE
[10:31:30.133] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:30.133] Globals: 11 objects totaling 96.40 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 4.07 KiB, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:30.133] Packages: 1 packages (‘future.apply’)
[10:31:30.133] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:30.133] Resolved: TRUE
[10:31:30.133] Value: <not collected>
[10:31:30.133] Conditions captured: <none>
[10:31:30.133] Early signaling: FALSE
[10:31:30.133] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:30.133] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:30.136] Chunk #2 of 2 ... DONE
[10:31:30.136] Launching 2 futures (chunks) ... DONE
[10:31:30.136] Resolving 2 futures (chunks) ...
[10:31:30.136] resolve() on list ...
[10:31:30.136]  recursive: 0
[10:31:30.136]  length: 2
[10:31:30.136] 
[10:31:30.137] Future #1
[10:31:30.137] result() for ClusterFuture ...
[10:31:30.137] - result already collected: FutureResult
[10:31:30.137] result() for ClusterFuture ... done
[10:31:30.137] result() for ClusterFuture ...
[10:31:30.137] - result already collected: FutureResult
[10:31:30.137] result() for ClusterFuture ... done
[10:31:30.137] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:30.137] - nx: 2
[10:31:30.137] - relay: TRUE
[10:31:30.137] - stdout: TRUE
[10:31:30.138] - signal: TRUE
[10:31:30.138] - resignal: FALSE
[10:31:30.138] - force: TRUE
[10:31:30.138] - relayed: [n=2] FALSE, FALSE
[10:31:30.138] - queued futures: [n=2] FALSE, FALSE
[10:31:30.138]  - until=1
[10:31:30.138]  - relaying element #1
[10:31:30.138] result() for ClusterFuture ...
[10:31:30.138] - result already collected: FutureResult
[10:31:30.138] result() for ClusterFuture ... done
[10:31:30.138] result() for ClusterFuture ...
[10:31:30.138] - result already collected: FutureResult
[10:31:30.139] result() for ClusterFuture ... done
[10:31:30.139] result() for ClusterFuture ...
[10:31:30.139] - result already collected: FutureResult
[10:31:30.139] result() for ClusterFuture ... done
[10:31:30.139] result() for ClusterFuture ...
[10:31:30.139] - result already collected: FutureResult
[10:31:30.139] result() for ClusterFuture ... done
[10:31:30.139] - relayed: [n=2] TRUE, FALSE
[10:31:30.139] - queued futures: [n=2] TRUE, FALSE
[10:31:30.139] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:30.140]  length: 1 (resolved future 1)
[10:31:30.140] Future #2
[10:31:30.140] result() for ClusterFuture ...
[10:31:30.140] - result already collected: FutureResult
[10:31:30.140] result() for ClusterFuture ... done
[10:31:30.140] result() for ClusterFuture ...
[10:31:30.140] - result already collected: FutureResult
[10:31:30.140] result() for ClusterFuture ... done
[10:31:30.140] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:30.140] - nx: 2
[10:31:30.140] - relay: TRUE
[10:31:30.140] - stdout: TRUE
[10:31:30.141] - signal: TRUE
[10:31:30.141] - resignal: FALSE
[10:31:30.141] - force: TRUE
[10:31:30.141] - relayed: [n=2] TRUE, FALSE
[10:31:30.141] - queued futures: [n=2] TRUE, FALSE
[10:31:30.141]  - until=2
[10:31:30.141]  - relaying element #2
[10:31:30.141] result() for ClusterFuture ...
[10:31:30.141] - result already collected: FutureResult
[10:31:30.141] result() for ClusterFuture ... done
[10:31:30.141] result() for ClusterFuture ...
[10:31:30.142] - result already collected: FutureResult
[10:31:30.142] result() for ClusterFuture ... done
[10:31:30.142] result() for ClusterFuture ...
[10:31:30.142] - result already collected: FutureResult
[10:31:30.142] result() for ClusterFuture ... done
[10:31:30.142] result() for ClusterFuture ...
[10:31:30.142] - result already collected: FutureResult
[10:31:30.142] result() for ClusterFuture ... done
[10:31:30.142] - relayed: [n=2] TRUE, TRUE
[10:31:30.142] - queued futures: [n=2] TRUE, TRUE
[10:31:30.142] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:30.143]  length: 0 (resolved future 2)
[10:31:30.143] Relaying remaining futures
[10:31:30.143] signalConditionsASAP(NULL, pos=0) ...
[10:31:30.143] - nx: 2
[10:31:30.143] - relay: TRUE
[10:31:30.143] - stdout: TRUE
[10:31:30.143] - signal: TRUE
[10:31:30.143] - resignal: FALSE
[10:31:30.143] - force: TRUE
[10:31:30.143] - relayed: [n=2] TRUE, TRUE
[10:31:30.143] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:30.143] - relayed: [n=2] TRUE, TRUE
[10:31:30.144] - queued futures: [n=2] TRUE, TRUE
[10:31:30.144] signalConditionsASAP(NULL, pos=0) ... done
[10:31:30.144] resolve() on list ... DONE
[10:31:30.144] result() for ClusterFuture ...
[10:31:30.144] - result already collected: FutureResult
[10:31:30.144] result() for ClusterFuture ... done
[10:31:30.144] result() for ClusterFuture ...
[10:31:30.144] - result already collected: FutureResult
[10:31:30.144] result() for ClusterFuture ... done
[10:31:30.144] result() for ClusterFuture ...
[10:31:30.144] - result already collected: FutureResult
[10:31:30.145] result() for ClusterFuture ... done
[10:31:30.145] result() for ClusterFuture ...
[10:31:30.145] - result already collected: FutureResult
[10:31:30.145] result() for ClusterFuture ... done
[10:31:30.145]  - Number of value chunks collected: 2
[10:31:30.145] Resolving 2 futures (chunks) ... DONE
[10:31:30.145] Reducing values from 2 chunks ...
[10:31:30.145]  - Number of values collected after concatenation: 4
[10:31:30.145]  - Number of values expected: 4
[10:31:30.145] Reducing values from 2 chunks ... DONE
[10:31:30.145] future_lapply() ... DONE
 num [1:3, 1:5, 1:4] 100 100 100 200 200 200 300 300 300 400 ...
 - attr(*, "dimnames")=List of 3
  ..$ : NULL
  ..$ : NULL
  ..$ : chr [1:4] "A" "B" "C" "D"
[10:31:30.147] future_lapply() ...
[10:31:30.153] Number of chunks: 2
[10:31:30.153] getGlobalsAndPackagesXApply() ...
[10:31:30.153]  - future.globals: TRUE
[10:31:30.153] getGlobalsAndPackages() ...
[10:31:30.153] Searching for globals...
[10:31:30.156] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:30.156] Searching for globals ... DONE
[10:31:30.156] Resolving globals: FALSE
[10:31:30.157] The total size of the 7 globals is 91.99 KiB (94200 bytes)
[10:31:30.157] The total size of the 7 globals exported for future expression (‘FUN()’) is 91.99 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:30.158] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:30.158] - packages: [1] ‘future.apply’
[10:31:30.158] getGlobalsAndPackages() ... DONE
[10:31:30.158]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:30.158]  - needed namespaces: [n=1] ‘future.apply’
[10:31:30.158] Finding globals ... DONE
[10:31:30.158]  - use_args: TRUE
[10:31:30.158]  - Getting '...' globals ...
[10:31:30.159] resolve() on list ...
[10:31:30.159]  recursive: 0
[10:31:30.159]  length: 1
[10:31:30.159]  elements: ‘...’
[10:31:30.159]  length: 0 (resolved future 1)
[10:31:30.159] resolve() on list ... DONE
[10:31:30.159]    - '...' content: [n=0] 
[10:31:30.159] List of 1
[10:31:30.159]  $ ...: list()
[10:31:30.159]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:30.159]  - attr(*, "where")=List of 1
[10:31:30.159]   ..$ ...:<environment: 0x55de88009a38> 
[10:31:30.159]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:30.159]  - attr(*, "resolved")= logi TRUE
[10:31:30.159]  - attr(*, "total_size")= num NA
[10:31:30.162]  - Getting '...' globals ... DONE
[10:31:30.162] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:30.162] List of 8
[10:31:30.162]  $ ...future.FUN:function (x, ...)  
[10:31:30.162]  $ x_FUN        :function (x)  
[10:31:30.162]  $ times        : int 1
[10:31:30.162]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:30.162]  $ stop_if_not  :function (...)  
[10:31:30.162]  $ dim          : NULL
[10:31:30.162]  $ valid_types  : chr "logical"
[10:31:30.162]  $ ...          : list()
[10:31:30.162]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:30.162]  - attr(*, "where")=List of 8
[10:31:30.162]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:30.162]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:30.162]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:30.162]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:30.162]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:30.162]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:30.162]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:30.162]   ..$ ...          :<environment: 0x55de88009a38> 
[10:31:30.162]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:30.162]  - attr(*, "resolved")= logi FALSE
[10:31:30.162]  - attr(*, "total_size")= num 94200
[10:31:30.167] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:30.167] getGlobalsAndPackagesXApply() ... DONE
[10:31:30.167] Number of futures (= number of chunks): 2
[10:31:30.168] Launching 2 futures (chunks) ...
[10:31:30.168] Chunk #1 of 2 ...
[10:31:30.168]  - Finding globals in 'X' for chunk #1 ...
[10:31:30.168] getGlobalsAndPackages() ...
[10:31:30.168] Searching for globals...
[10:31:30.168] 
[10:31:30.168] Searching for globals ... DONE
[10:31:30.168] - globals: [0] <none>
[10:31:30.168] getGlobalsAndPackages() ... DONE
[10:31:30.169]    + additional globals found: [n=0] 
[10:31:30.169]    + additional namespaces needed: [n=0] 
[10:31:30.169]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:30.169]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:30.169]  - seeds: <none>
[10:31:30.169]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.169] getGlobalsAndPackages() ...
[10:31:30.169] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.169] Resolving globals: FALSE
[10:31:30.169] Tweak future expression to call with '...' arguments ...
[10:31:30.170] {
[10:31:30.170]     do.call(function(...) {
[10:31:30.170]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.170]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:30.170]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.170]             on.exit(options(oopts), add = TRUE)
[10:31:30.170]         }
[10:31:30.170]         {
[10:31:30.170]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:30.170]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.170]                 ...future.FUN(...future.X_jj, ...)
[10:31:30.170]             })
[10:31:30.170]         }
[10:31:30.170]     }, args = future.call.arguments)
[10:31:30.170] }
[10:31:30.170] Tweak future expression to call with '...' arguments ... DONE
[10:31:30.170] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.170] - packages: [1] ‘future.apply’
[10:31:30.171] getGlobalsAndPackages() ... DONE
[10:31:30.171] run() for ‘Future’ ...
[10:31:30.171] - state: ‘created’
[10:31:30.171] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:30.185] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:30.185] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:30.185]   - Field: ‘node’
[10:31:30.185]   - Field: ‘label’
[10:31:30.185]   - Field: ‘local’
[10:31:30.186]   - Field: ‘owner’
[10:31:30.186]   - Field: ‘envir’
[10:31:30.186]   - Field: ‘workers’
[10:31:30.186]   - Field: ‘packages’
[10:31:30.186]   - Field: ‘gc’
[10:31:30.186]   - Field: ‘conditions’
[10:31:30.186]   - Field: ‘persistent’
[10:31:30.186]   - Field: ‘expr’
[10:31:30.186]   - Field: ‘uuid’
[10:31:30.186]   - Field: ‘seed’
[10:31:30.189]   - Field: ‘version’
[10:31:30.189]   - Field: ‘result’
[10:31:30.189]   - Field: ‘asynchronous’
[10:31:30.189]   - Field: ‘calls’
[10:31:30.189]   - Field: ‘globals’
[10:31:30.189]   - Field: ‘stdout’
[10:31:30.189]   - Field: ‘earlySignal’
[10:31:30.190]   - Field: ‘lazy’
[10:31:30.190]   - Field: ‘state’
[10:31:30.190] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:30.190] - Launch lazy future ...
[10:31:30.190] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:30.190] Packages needed by future strategies (n = 0): <none>
[10:31:30.191] {
[10:31:30.191]     {
[10:31:30.191]         {
[10:31:30.191]             ...future.startTime <- base::Sys.time()
[10:31:30.191]             {
[10:31:30.191]                 {
[10:31:30.191]                   {
[10:31:30.191]                     {
[10:31:30.191]                       {
[10:31:30.191]                         base::local({
[10:31:30.191]                           has_future <- base::requireNamespace("future", 
[10:31:30.191]                             quietly = TRUE)
[10:31:30.191]                           if (has_future) {
[10:31:30.191]                             ns <- base::getNamespace("future")
[10:31:30.191]                             version <- ns[[".package"]][["version"]]
[10:31:30.191]                             if (is.null(version)) 
[10:31:30.191]                               version <- utils::packageVersion("future")
[10:31:30.191]                           }
[10:31:30.191]                           else {
[10:31:30.191]                             version <- NULL
[10:31:30.191]                           }
[10:31:30.191]                           if (!has_future || version < "1.8.0") {
[10:31:30.191]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:30.191]                               "", base::R.version$version.string), 
[10:31:30.191]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:30.191]                                 base::R.version$platform, 8 * 
[10:31:30.191]                                   base::.Machine$sizeof.pointer), 
[10:31:30.191]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:30.191]                                 "release", "version")], collapse = " "), 
[10:31:30.191]                               hostname = base::Sys.info()[["nodename"]])
[10:31:30.191]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:30.191]                               info)
[10:31:30.191]                             info <- base::paste(info, collapse = "; ")
[10:31:30.191]                             if (!has_future) {
[10:31:30.191]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:30.191]                                 info)
[10:31:30.191]                             }
[10:31:30.191]                             else {
[10:31:30.191]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:30.191]                                 info, version)
[10:31:30.191]                             }
[10:31:30.191]                             base::stop(msg)
[10:31:30.191]                           }
[10:31:30.191]                         })
[10:31:30.191]                       }
[10:31:30.191]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:30.191]                       base::options(mc.cores = 1L)
[10:31:30.191]                     }
[10:31:30.191]                     base::local({
[10:31:30.191]                       for (pkg in "future.apply") {
[10:31:30.191]                         base::loadNamespace(pkg)
[10:31:30.191]                         base::library(pkg, character.only = TRUE)
[10:31:30.191]                       }
[10:31:30.191]                     })
[10:31:30.191]                   }
[10:31:30.191]                   ...future.strategy.old <- future::plan("list")
[10:31:30.191]                   options(future.plan = NULL)
[10:31:30.191]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:30.191]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:30.191]                 }
[10:31:30.191]                 ...future.workdir <- getwd()
[10:31:30.191]             }
[10:31:30.191]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:30.191]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:30.191]         }
[10:31:30.191]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:30.191]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:30.191]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:30.191]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:30.191]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:30.191]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:30.191]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:30.191]             base::names(...future.oldOptions))
[10:31:30.191]     }
[10:31:30.191]     if (FALSE) {
[10:31:30.191]     }
[10:31:30.191]     else {
[10:31:30.191]         if (TRUE) {
[10:31:30.191]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:30.191]                 open = "w")
[10:31:30.191]         }
[10:31:30.191]         else {
[10:31:30.191]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:30.191]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:30.191]         }
[10:31:30.191]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:30.191]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:30.191]             base::sink(type = "output", split = FALSE)
[10:31:30.191]             base::close(...future.stdout)
[10:31:30.191]         }, add = TRUE)
[10:31:30.191]     }
[10:31:30.191]     ...future.frame <- base::sys.nframe()
[10:31:30.191]     ...future.conditions <- base::list()
[10:31:30.191]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:30.191]     if (FALSE) {
[10:31:30.191]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:30.191]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:30.191]     }
[10:31:30.191]     ...future.result <- base::tryCatch({
[10:31:30.191]         base::withCallingHandlers({
[10:31:30.191]             ...future.value <- base::withVisible(base::local({
[10:31:30.191]                 ...future.makeSendCondition <- base::local({
[10:31:30.191]                   sendCondition <- NULL
[10:31:30.191]                   function(frame = 1L) {
[10:31:30.191]                     if (is.function(sendCondition)) 
[10:31:30.191]                       return(sendCondition)
[10:31:30.191]                     ns <- getNamespace("parallel")
[10:31:30.191]                     if (exists("sendData", mode = "function", 
[10:31:30.191]                       envir = ns)) {
[10:31:30.191]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:30.191]                         envir = ns)
[10:31:30.191]                       envir <- sys.frame(frame)
[10:31:30.191]                       master <- NULL
[10:31:30.191]                       while (!identical(envir, .GlobalEnv) && 
[10:31:30.191]                         !identical(envir, emptyenv())) {
[10:31:30.191]                         if (exists("master", mode = "list", envir = envir, 
[10:31:30.191]                           inherits = FALSE)) {
[10:31:30.191]                           master <- get("master", mode = "list", 
[10:31:30.191]                             envir = envir, inherits = FALSE)
[10:31:30.191]                           if (inherits(master, c("SOCKnode", 
[10:31:30.191]                             "SOCK0node"))) {
[10:31:30.191]                             sendCondition <<- function(cond) {
[10:31:30.191]                               data <- list(type = "VALUE", value = cond, 
[10:31:30.191]                                 success = TRUE)
[10:31:30.191]                               parallel_sendData(master, data)
[10:31:30.191]                             }
[10:31:30.191]                             return(sendCondition)
[10:31:30.191]                           }
[10:31:30.191]                         }
[10:31:30.191]                         frame <- frame + 1L
[10:31:30.191]                         envir <- sys.frame(frame)
[10:31:30.191]                       }
[10:31:30.191]                     }
[10:31:30.191]                     sendCondition <<- function(cond) NULL
[10:31:30.191]                   }
[10:31:30.191]                 })
[10:31:30.191]                 withCallingHandlers({
[10:31:30.191]                   {
[10:31:30.191]                     do.call(function(...) {
[10:31:30.191]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.191]                       if (!identical(...future.globals.maxSize.org, 
[10:31:30.191]                         ...future.globals.maxSize)) {
[10:31:30.191]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.191]                         on.exit(options(oopts), add = TRUE)
[10:31:30.191]                       }
[10:31:30.191]                       {
[10:31:30.191]                         lapply(seq_along(...future.elements_ii), 
[10:31:30.191]                           FUN = function(jj) {
[10:31:30.191]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.191]                             ...future.FUN(...future.X_jj, ...)
[10:31:30.191]                           })
[10:31:30.191]                       }
[10:31:30.191]                     }, args = future.call.arguments)
[10:31:30.191]                   }
[10:31:30.191]                 }, immediateCondition = function(cond) {
[10:31:30.191]                   sendCondition <- ...future.makeSendCondition()
[10:31:30.191]                   sendCondition(cond)
[10:31:30.191]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.191]                   {
[10:31:30.191]                     inherits <- base::inherits
[10:31:30.191]                     invokeRestart <- base::invokeRestart
[10:31:30.191]                     is.null <- base::is.null
[10:31:30.191]                     muffled <- FALSE
[10:31:30.191]                     if (inherits(cond, "message")) {
[10:31:30.191]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:30.191]                       if (muffled) 
[10:31:30.191]                         invokeRestart("muffleMessage")
[10:31:30.191]                     }
[10:31:30.191]                     else if (inherits(cond, "warning")) {
[10:31:30.191]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:30.191]                       if (muffled) 
[10:31:30.191]                         invokeRestart("muffleWarning")
[10:31:30.191]                     }
[10:31:30.191]                     else if (inherits(cond, "condition")) {
[10:31:30.191]                       if (!is.null(pattern)) {
[10:31:30.191]                         computeRestarts <- base::computeRestarts
[10:31:30.191]                         grepl <- base::grepl
[10:31:30.191]                         restarts <- computeRestarts(cond)
[10:31:30.191]                         for (restart in restarts) {
[10:31:30.191]                           name <- restart$name
[10:31:30.191]                           if (is.null(name)) 
[10:31:30.191]                             next
[10:31:30.191]                           if (!grepl(pattern, name)) 
[10:31:30.191]                             next
[10:31:30.191]                           invokeRestart(restart)
[10:31:30.191]                           muffled <- TRUE
[10:31:30.191]                           break
[10:31:30.191]                         }
[10:31:30.191]                       }
[10:31:30.191]                     }
[10:31:30.191]                     invisible(muffled)
[10:31:30.191]                   }
[10:31:30.191]                   muffleCondition(cond)
[10:31:30.191]                 })
[10:31:30.191]             }))
[10:31:30.191]             future::FutureResult(value = ...future.value$value, 
[10:31:30.191]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:30.191]                   ...future.rng), globalenv = if (FALSE) 
[10:31:30.191]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:30.191]                     ...future.globalenv.names))
[10:31:30.191]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:30.191]         }, condition = base::local({
[10:31:30.191]             c <- base::c
[10:31:30.191]             inherits <- base::inherits
[10:31:30.191]             invokeRestart <- base::invokeRestart
[10:31:30.191]             length <- base::length
[10:31:30.191]             list <- base::list
[10:31:30.191]             seq.int <- base::seq.int
[10:31:30.191]             signalCondition <- base::signalCondition
[10:31:30.191]             sys.calls <- base::sys.calls
[10:31:30.191]             `[[` <- base::`[[`
[10:31:30.191]             `+` <- base::`+`
[10:31:30.191]             `<<-` <- base::`<<-`
[10:31:30.191]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:30.191]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:30.191]                   3L)]
[10:31:30.191]             }
[10:31:30.191]             function(cond) {
[10:31:30.191]                 is_error <- inherits(cond, "error")
[10:31:30.191]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:30.191]                   NULL)
[10:31:30.191]                 if (is_error) {
[10:31:30.191]                   sessionInformation <- function() {
[10:31:30.191]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:30.191]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:30.191]                       search = base::search(), system = base::Sys.info())
[10:31:30.191]                   }
[10:31:30.191]                   ...future.conditions[[length(...future.conditions) + 
[10:31:30.191]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:30.191]                     cond$call), session = sessionInformation(), 
[10:31:30.191]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:30.191]                   signalCondition(cond)
[10:31:30.191]                 }
[10:31:30.191]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:30.191]                 "immediateCondition"))) {
[10:31:30.191]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:30.191]                   ...future.conditions[[length(...future.conditions) + 
[10:31:30.191]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:30.191]                   if (TRUE && !signal) {
[10:31:30.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.191]                     {
[10:31:30.191]                       inherits <- base::inherits
[10:31:30.191]                       invokeRestart <- base::invokeRestart
[10:31:30.191]                       is.null <- base::is.null
[10:31:30.191]                       muffled <- FALSE
[10:31:30.191]                       if (inherits(cond, "message")) {
[10:31:30.191]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:30.191]                         if (muffled) 
[10:31:30.191]                           invokeRestart("muffleMessage")
[10:31:30.191]                       }
[10:31:30.191]                       else if (inherits(cond, "warning")) {
[10:31:30.191]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:30.191]                         if (muffled) 
[10:31:30.191]                           invokeRestart("muffleWarning")
[10:31:30.191]                       }
[10:31:30.191]                       else if (inherits(cond, "condition")) {
[10:31:30.191]                         if (!is.null(pattern)) {
[10:31:30.191]                           computeRestarts <- base::computeRestarts
[10:31:30.191]                           grepl <- base::grepl
[10:31:30.191]                           restarts <- computeRestarts(cond)
[10:31:30.191]                           for (restart in restarts) {
[10:31:30.191]                             name <- restart$name
[10:31:30.191]                             if (is.null(name)) 
[10:31:30.191]                               next
[10:31:30.191]                             if (!grepl(pattern, name)) 
[10:31:30.191]                               next
[10:31:30.191]                             invokeRestart(restart)
[10:31:30.191]                             muffled <- TRUE
[10:31:30.191]                             break
[10:31:30.191]                           }
[10:31:30.191]                         }
[10:31:30.191]                       }
[10:31:30.191]                       invisible(muffled)
[10:31:30.191]                     }
[10:31:30.191]                     muffleCondition(cond, pattern = "^muffle")
[10:31:30.191]                   }
[10:31:30.191]                 }
[10:31:30.191]                 else {
[10:31:30.191]                   if (TRUE) {
[10:31:30.191]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.191]                     {
[10:31:30.191]                       inherits <- base::inherits
[10:31:30.191]                       invokeRestart <- base::invokeRestart
[10:31:30.191]                       is.null <- base::is.null
[10:31:30.191]                       muffled <- FALSE
[10:31:30.191]                       if (inherits(cond, "message")) {
[10:31:30.191]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:30.191]                         if (muffled) 
[10:31:30.191]                           invokeRestart("muffleMessage")
[10:31:30.191]                       }
[10:31:30.191]                       else if (inherits(cond, "warning")) {
[10:31:30.191]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:30.191]                         if (muffled) 
[10:31:30.191]                           invokeRestart("muffleWarning")
[10:31:30.191]                       }
[10:31:30.191]                       else if (inherits(cond, "condition")) {
[10:31:30.191]                         if (!is.null(pattern)) {
[10:31:30.191]                           computeRestarts <- base::computeRestarts
[10:31:30.191]                           grepl <- base::grepl
[10:31:30.191]                           restarts <- computeRestarts(cond)
[10:31:30.191]                           for (restart in restarts) {
[10:31:30.191]                             name <- restart$name
[10:31:30.191]                             if (is.null(name)) 
[10:31:30.191]                               next
[10:31:30.191]                             if (!grepl(pattern, name)) 
[10:31:30.191]                               next
[10:31:30.191]                             invokeRestart(restart)
[10:31:30.191]                             muffled <- TRUE
[10:31:30.191]                             break
[10:31:30.191]                           }
[10:31:30.191]                         }
[10:31:30.191]                       }
[10:31:30.191]                       invisible(muffled)
[10:31:30.191]                     }
[10:31:30.191]                     muffleCondition(cond, pattern = "^muffle")
[10:31:30.191]                   }
[10:31:30.191]                 }
[10:31:30.191]             }
[10:31:30.191]         }))
[10:31:30.191]     }, error = function(ex) {
[10:31:30.191]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:30.191]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:30.191]                 ...future.rng), started = ...future.startTime, 
[10:31:30.191]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:30.191]             version = "1.8"), class = "FutureResult")
[10:31:30.191]     }, finally = {
[10:31:30.191]         if (!identical(...future.workdir, getwd())) 
[10:31:30.191]             setwd(...future.workdir)
[10:31:30.191]         {
[10:31:30.191]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:30.191]                 ...future.oldOptions$nwarnings <- NULL
[10:31:30.191]             }
[10:31:30.191]             base::options(...future.oldOptions)
[10:31:30.191]             if (.Platform$OS.type == "windows") {
[10:31:30.191]                 old_names <- names(...future.oldEnvVars)
[10:31:30.191]                 envs <- base::Sys.getenv()
[10:31:30.191]                 names <- names(envs)
[10:31:30.191]                 common <- intersect(names, old_names)
[10:31:30.191]                 added <- setdiff(names, old_names)
[10:31:30.191]                 removed <- setdiff(old_names, names)
[10:31:30.191]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:30.191]                   envs[common]]
[10:31:30.191]                 NAMES <- toupper(changed)
[10:31:30.191]                 args <- list()
[10:31:30.191]                 for (kk in seq_along(NAMES)) {
[10:31:30.191]                   name <- changed[[kk]]
[10:31:30.191]                   NAME <- NAMES[[kk]]
[10:31:30.191]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.191]                     next
[10:31:30.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:30.191]                 }
[10:31:30.191]                 NAMES <- toupper(added)
[10:31:30.191]                 for (kk in seq_along(NAMES)) {
[10:31:30.191]                   name <- added[[kk]]
[10:31:30.191]                   NAME <- NAMES[[kk]]
[10:31:30.191]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.191]                     next
[10:31:30.191]                   args[[name]] <- ""
[10:31:30.191]                 }
[10:31:30.191]                 NAMES <- toupper(removed)
[10:31:30.191]                 for (kk in seq_along(NAMES)) {
[10:31:30.191]                   name <- removed[[kk]]
[10:31:30.191]                   NAME <- NAMES[[kk]]
[10:31:30.191]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.191]                     next
[10:31:30.191]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:30.191]                 }
[10:31:30.191]                 if (length(args) > 0) 
[10:31:30.191]                   base::do.call(base::Sys.setenv, args = args)
[10:31:30.191]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:30.191]             }
[10:31:30.191]             else {
[10:31:30.191]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:30.191]             }
[10:31:30.191]             {
[10:31:30.191]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:30.191]                   0L) {
[10:31:30.191]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:30.191]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:30.191]                   base::options(opts)
[10:31:30.191]                 }
[10:31:30.191]                 {
[10:31:30.191]                   {
[10:31:30.191]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:30.191]                     NULL
[10:31:30.191]                   }
[10:31:30.191]                   options(future.plan = NULL)
[10:31:30.191]                   if (is.na(NA_character_)) 
[10:31:30.191]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:30.191]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:30.191]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:30.191]                     .init = FALSE)
[10:31:30.191]                 }
[10:31:30.191]             }
[10:31:30.191]         }
[10:31:30.191]     })
[10:31:30.191]     if (TRUE) {
[10:31:30.191]         base::sink(type = "output", split = FALSE)
[10:31:30.191]         if (TRUE) {
[10:31:30.191]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:30.191]         }
[10:31:30.191]         else {
[10:31:30.191]             ...future.result["stdout"] <- base::list(NULL)
[10:31:30.191]         }
[10:31:30.191]         base::close(...future.stdout)
[10:31:30.191]         ...future.stdout <- NULL
[10:31:30.191]     }
[10:31:30.191]     ...future.result$conditions <- ...future.conditions
[10:31:30.191]     ...future.result$finished <- base::Sys.time()
[10:31:30.191]     ...future.result
[10:31:30.191] }
[10:31:30.193] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[10:31:30.194] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:30.237] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:30.237] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[10:31:30.238] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[10:31:30.238] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:30.238] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:30.238] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:30.281] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:30.281] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:30.325] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:30.325] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:30.326] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.326] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[10:31:30.326] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[10:31:30.326] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:30.327] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.327] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ...
[10:31:30.327] Exporting ‘...future.elements_ii’ (1.78 KiB) to cluster node #1 ... DONE
[10:31:30.327] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:30.328] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.328] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:30.328] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.328] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[10:31:30.329] MultisessionFuture started
[10:31:30.329] - Launch lazy future ... done
[10:31:30.329] run() for ‘MultisessionFuture’ ... done
[10:31:30.329] Created future:
[10:31:30.331] receiveMessageFromWorker() for ClusterFuture ...
[10:31:30.331] - Validating connection of MultisessionFuture
[10:31:30.331] - received message: FutureResult
[10:31:30.331] - Received FutureResult
[10:31:30.331] - Erased future from FutureRegistry
[10:31:30.331] result() for ClusterFuture ...
[10:31:30.332] - result already collected: FutureResult
[10:31:30.332] result() for ClusterFuture ... done
[10:31:30.332] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:30.329] MultisessionFuture:
[10:31:30.329] Label: ‘future_vapply-1’
[10:31:30.329] Expression:
[10:31:30.329] {
[10:31:30.329]     do.call(function(...) {
[10:31:30.329]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.329]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:30.329]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.329]             on.exit(options(oopts), add = TRUE)
[10:31:30.329]         }
[10:31:30.329]         {
[10:31:30.329]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:30.329]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.329]                 ...future.FUN(...future.X_jj, ...)
[10:31:30.329]             })
[10:31:30.329]         }
[10:31:30.329]     }, args = future.call.arguments)
[10:31:30.329] }
[10:31:30.329] Lazy evaluation: FALSE
[10:31:30.329] Asynchronous evaluation: TRUE
[10:31:30.329] Local evaluation: TRUE
[10:31:30.329] Environment: R_GlobalEnv
[10:31:30.329] Capture standard output: TRUE
[10:31:30.329] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:30.329] Globals: 11 objects totaling 93.77 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:30.329] Packages: 1 packages (‘future.apply’)
[10:31:30.329] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:30.329] Resolved: TRUE
[10:31:30.329] Value: <not collected>
[10:31:30.329] Conditions captured: <none>
[10:31:30.329] Early signaling: FALSE
[10:31:30.329] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:30.329] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:30.332] Chunk #1 of 2 ... DONE
[10:31:30.332] Chunk #2 of 2 ...
[10:31:30.332]  - Finding globals in 'X' for chunk #2 ...
[10:31:30.332] getGlobalsAndPackages() ...
[10:31:30.332] Searching for globals...
[10:31:30.333] 
[10:31:30.333] Searching for globals ... DONE
[10:31:30.333] - globals: [0] <none>
[10:31:30.333] getGlobalsAndPackages() ... DONE
[10:31:30.333]    + additional globals found: [n=0] 
[10:31:30.333]    + additional namespaces needed: [n=0] 
[10:31:30.333]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:30.333]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:30.334]  - seeds: <none>
[10:31:30.334]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.334] getGlobalsAndPackages() ...
[10:31:30.334] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.334] Resolving globals: FALSE
[10:31:30.334] Tweak future expression to call with '...' arguments ...
[10:31:30.334] {
[10:31:30.334]     do.call(function(...) {
[10:31:30.334]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.334]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:30.334]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.334]             on.exit(options(oopts), add = TRUE)
[10:31:30.334]         }
[10:31:30.334]         {
[10:31:30.334]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:30.334]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.334]                 ...future.FUN(...future.X_jj, ...)
[10:31:30.334]             })
[10:31:30.334]         }
[10:31:30.334]     }, args = future.call.arguments)
[10:31:30.334] }
[10:31:30.334] Tweak future expression to call with '...' arguments ... DONE
[10:31:30.335] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.335] - packages: [1] ‘future.apply’
[10:31:30.335] getGlobalsAndPackages() ... DONE
[10:31:30.335] run() for ‘Future’ ...
[10:31:30.336] - state: ‘created’
[10:31:30.336] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:30.355] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:30.355] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:30.355]   - Field: ‘node’
[10:31:30.355]   - Field: ‘label’
[10:31:30.355]   - Field: ‘local’
[10:31:30.355]   - Field: ‘owner’
[10:31:30.356]   - Field: ‘envir’
[10:31:30.356]   - Field: ‘workers’
[10:31:30.356]   - Field: ‘packages’
[10:31:30.356]   - Field: ‘gc’
[10:31:30.356]   - Field: ‘conditions’
[10:31:30.356]   - Field: ‘persistent’
[10:31:30.356]   - Field: ‘expr’
[10:31:30.356]   - Field: ‘uuid’
[10:31:30.356]   - Field: ‘seed’
[10:31:30.356]   - Field: ‘version’
[10:31:30.356]   - Field: ‘result’
[10:31:30.357]   - Field: ‘asynchronous’
[10:31:30.357]   - Field: ‘calls’
[10:31:30.357]   - Field: ‘globals’
[10:31:30.357]   - Field: ‘stdout’
[10:31:30.357]   - Field: ‘earlySignal’
[10:31:30.357]   - Field: ‘lazy’
[10:31:30.357]   - Field: ‘state’
[10:31:30.357] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:30.357] - Launch lazy future ...
[10:31:30.358] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:30.358] Packages needed by future strategies (n = 0): <none>
[10:31:30.358] {
[10:31:30.358]     {
[10:31:30.358]         {
[10:31:30.358]             ...future.startTime <- base::Sys.time()
[10:31:30.358]             {
[10:31:30.358]                 {
[10:31:30.358]                   {
[10:31:30.358]                     {
[10:31:30.358]                       {
[10:31:30.358]                         base::local({
[10:31:30.358]                           has_future <- base::requireNamespace("future", 
[10:31:30.358]                             quietly = TRUE)
[10:31:30.358]                           if (has_future) {
[10:31:30.358]                             ns <- base::getNamespace("future")
[10:31:30.358]                             version <- ns[[".package"]][["version"]]
[10:31:30.358]                             if (is.null(version)) 
[10:31:30.358]                               version <- utils::packageVersion("future")
[10:31:30.358]                           }
[10:31:30.358]                           else {
[10:31:30.358]                             version <- NULL
[10:31:30.358]                           }
[10:31:30.358]                           if (!has_future || version < "1.8.0") {
[10:31:30.358]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:30.358]                               "", base::R.version$version.string), 
[10:31:30.358]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:30.358]                                 base::R.version$platform, 8 * 
[10:31:30.358]                                   base::.Machine$sizeof.pointer), 
[10:31:30.358]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:30.358]                                 "release", "version")], collapse = " "), 
[10:31:30.358]                               hostname = base::Sys.info()[["nodename"]])
[10:31:30.358]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:30.358]                               info)
[10:31:30.358]                             info <- base::paste(info, collapse = "; ")
[10:31:30.358]                             if (!has_future) {
[10:31:30.358]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:30.358]                                 info)
[10:31:30.358]                             }
[10:31:30.358]                             else {
[10:31:30.358]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:30.358]                                 info, version)
[10:31:30.358]                             }
[10:31:30.358]                             base::stop(msg)
[10:31:30.358]                           }
[10:31:30.358]                         })
[10:31:30.358]                       }
[10:31:30.358]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:30.358]                       base::options(mc.cores = 1L)
[10:31:30.358]                     }
[10:31:30.358]                     base::local({
[10:31:30.358]                       for (pkg in "future.apply") {
[10:31:30.358]                         base::loadNamespace(pkg)
[10:31:30.358]                         base::library(pkg, character.only = TRUE)
[10:31:30.358]                       }
[10:31:30.358]                     })
[10:31:30.358]                   }
[10:31:30.358]                   ...future.strategy.old <- future::plan("list")
[10:31:30.358]                   options(future.plan = NULL)
[10:31:30.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:30.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:30.358]                 }
[10:31:30.358]                 ...future.workdir <- getwd()
[10:31:30.358]             }
[10:31:30.358]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:30.358]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:30.358]         }
[10:31:30.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:30.358]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:30.358]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:30.358]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:30.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:30.358]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:30.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:30.358]             base::names(...future.oldOptions))
[10:31:30.358]     }
[10:31:30.358]     if (FALSE) {
[10:31:30.358]     }
[10:31:30.358]     else {
[10:31:30.358]         if (TRUE) {
[10:31:30.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:30.358]                 open = "w")
[10:31:30.358]         }
[10:31:30.358]         else {
[10:31:30.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:30.358]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:30.358]         }
[10:31:30.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:30.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:30.358]             base::sink(type = "output", split = FALSE)
[10:31:30.358]             base::close(...future.stdout)
[10:31:30.358]         }, add = TRUE)
[10:31:30.358]     }
[10:31:30.358]     ...future.frame <- base::sys.nframe()
[10:31:30.358]     ...future.conditions <- base::list()
[10:31:30.358]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:30.358]     if (FALSE) {
[10:31:30.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:30.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:30.358]     }
[10:31:30.358]     ...future.result <- base::tryCatch({
[10:31:30.358]         base::withCallingHandlers({
[10:31:30.358]             ...future.value <- base::withVisible(base::local({
[10:31:30.358]                 ...future.makeSendCondition <- base::local({
[10:31:30.358]                   sendCondition <- NULL
[10:31:30.358]                   function(frame = 1L) {
[10:31:30.358]                     if (is.function(sendCondition)) 
[10:31:30.358]                       return(sendCondition)
[10:31:30.358]                     ns <- getNamespace("parallel")
[10:31:30.358]                     if (exists("sendData", mode = "function", 
[10:31:30.358]                       envir = ns)) {
[10:31:30.358]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:30.358]                         envir = ns)
[10:31:30.358]                       envir <- sys.frame(frame)
[10:31:30.358]                       master <- NULL
[10:31:30.358]                       while (!identical(envir, .GlobalEnv) && 
[10:31:30.358]                         !identical(envir, emptyenv())) {
[10:31:30.358]                         if (exists("master", mode = "list", envir = envir, 
[10:31:30.358]                           inherits = FALSE)) {
[10:31:30.358]                           master <- get("master", mode = "list", 
[10:31:30.358]                             envir = envir, inherits = FALSE)
[10:31:30.358]                           if (inherits(master, c("SOCKnode", 
[10:31:30.358]                             "SOCK0node"))) {
[10:31:30.358]                             sendCondition <<- function(cond) {
[10:31:30.358]                               data <- list(type = "VALUE", value = cond, 
[10:31:30.358]                                 success = TRUE)
[10:31:30.358]                               parallel_sendData(master, data)
[10:31:30.358]                             }
[10:31:30.358]                             return(sendCondition)
[10:31:30.358]                           }
[10:31:30.358]                         }
[10:31:30.358]                         frame <- frame + 1L
[10:31:30.358]                         envir <- sys.frame(frame)
[10:31:30.358]                       }
[10:31:30.358]                     }
[10:31:30.358]                     sendCondition <<- function(cond) NULL
[10:31:30.358]                   }
[10:31:30.358]                 })
[10:31:30.358]                 withCallingHandlers({
[10:31:30.358]                   {
[10:31:30.358]                     do.call(function(...) {
[10:31:30.358]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.358]                       if (!identical(...future.globals.maxSize.org, 
[10:31:30.358]                         ...future.globals.maxSize)) {
[10:31:30.358]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.358]                         on.exit(options(oopts), add = TRUE)
[10:31:30.358]                       }
[10:31:30.358]                       {
[10:31:30.358]                         lapply(seq_along(...future.elements_ii), 
[10:31:30.358]                           FUN = function(jj) {
[10:31:30.358]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.358]                             ...future.FUN(...future.X_jj, ...)
[10:31:30.358]                           })
[10:31:30.358]                       }
[10:31:30.358]                     }, args = future.call.arguments)
[10:31:30.358]                   }
[10:31:30.358]                 }, immediateCondition = function(cond) {
[10:31:30.358]                   sendCondition <- ...future.makeSendCondition()
[10:31:30.358]                   sendCondition(cond)
[10:31:30.358]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.358]                   {
[10:31:30.358]                     inherits <- base::inherits
[10:31:30.358]                     invokeRestart <- base::invokeRestart
[10:31:30.358]                     is.null <- base::is.null
[10:31:30.358]                     muffled <- FALSE
[10:31:30.358]                     if (inherits(cond, "message")) {
[10:31:30.358]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:30.358]                       if (muffled) 
[10:31:30.358]                         invokeRestart("muffleMessage")
[10:31:30.358]                     }
[10:31:30.358]                     else if (inherits(cond, "warning")) {
[10:31:30.358]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:30.358]                       if (muffled) 
[10:31:30.358]                         invokeRestart("muffleWarning")
[10:31:30.358]                     }
[10:31:30.358]                     else if (inherits(cond, "condition")) {
[10:31:30.358]                       if (!is.null(pattern)) {
[10:31:30.358]                         computeRestarts <- base::computeRestarts
[10:31:30.358]                         grepl <- base::grepl
[10:31:30.358]                         restarts <- computeRestarts(cond)
[10:31:30.358]                         for (restart in restarts) {
[10:31:30.358]                           name <- restart$name
[10:31:30.358]                           if (is.null(name)) 
[10:31:30.358]                             next
[10:31:30.358]                           if (!grepl(pattern, name)) 
[10:31:30.358]                             next
[10:31:30.358]                           invokeRestart(restart)
[10:31:30.358]                           muffled <- TRUE
[10:31:30.358]                           break
[10:31:30.358]                         }
[10:31:30.358]                       }
[10:31:30.358]                     }
[10:31:30.358]                     invisible(muffled)
[10:31:30.358]                   }
[10:31:30.358]                   muffleCondition(cond)
[10:31:30.358]                 })
[10:31:30.358]             }))
[10:31:30.358]             future::FutureResult(value = ...future.value$value, 
[10:31:30.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:30.358]                   ...future.rng), globalenv = if (FALSE) 
[10:31:30.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:30.358]                     ...future.globalenv.names))
[10:31:30.358]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:30.358]         }, condition = base::local({
[10:31:30.358]             c <- base::c
[10:31:30.358]             inherits <- base::inherits
[10:31:30.358]             invokeRestart <- base::invokeRestart
[10:31:30.358]             length <- base::length
[10:31:30.358]             list <- base::list
[10:31:30.358]             seq.int <- base::seq.int
[10:31:30.358]             signalCondition <- base::signalCondition
[10:31:30.358]             sys.calls <- base::sys.calls
[10:31:30.358]             `[[` <- base::`[[`
[10:31:30.358]             `+` <- base::`+`
[10:31:30.358]             `<<-` <- base::`<<-`
[10:31:30.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:30.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:30.358]                   3L)]
[10:31:30.358]             }
[10:31:30.358]             function(cond) {
[10:31:30.358]                 is_error <- inherits(cond, "error")
[10:31:30.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:30.358]                   NULL)
[10:31:30.358]                 if (is_error) {
[10:31:30.358]                   sessionInformation <- function() {
[10:31:30.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:30.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:30.358]                       search = base::search(), system = base::Sys.info())
[10:31:30.358]                   }
[10:31:30.358]                   ...future.conditions[[length(...future.conditions) + 
[10:31:30.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:30.358]                     cond$call), session = sessionInformation(), 
[10:31:30.358]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:30.358]                   signalCondition(cond)
[10:31:30.358]                 }
[10:31:30.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:30.358]                 "immediateCondition"))) {
[10:31:30.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:30.358]                   ...future.conditions[[length(...future.conditions) + 
[10:31:30.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:30.358]                   if (TRUE && !signal) {
[10:31:30.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.358]                     {
[10:31:30.358]                       inherits <- base::inherits
[10:31:30.358]                       invokeRestart <- base::invokeRestart
[10:31:30.358]                       is.null <- base::is.null
[10:31:30.358]                       muffled <- FALSE
[10:31:30.358]                       if (inherits(cond, "message")) {
[10:31:30.358]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:30.358]                         if (muffled) 
[10:31:30.358]                           invokeRestart("muffleMessage")
[10:31:30.358]                       }
[10:31:30.358]                       else if (inherits(cond, "warning")) {
[10:31:30.358]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:30.358]                         if (muffled) 
[10:31:30.358]                           invokeRestart("muffleWarning")
[10:31:30.358]                       }
[10:31:30.358]                       else if (inherits(cond, "condition")) {
[10:31:30.358]                         if (!is.null(pattern)) {
[10:31:30.358]                           computeRestarts <- base::computeRestarts
[10:31:30.358]                           grepl <- base::grepl
[10:31:30.358]                           restarts <- computeRestarts(cond)
[10:31:30.358]                           for (restart in restarts) {
[10:31:30.358]                             name <- restart$name
[10:31:30.358]                             if (is.null(name)) 
[10:31:30.358]                               next
[10:31:30.358]                             if (!grepl(pattern, name)) 
[10:31:30.358]                               next
[10:31:30.358]                             invokeRestart(restart)
[10:31:30.358]                             muffled <- TRUE
[10:31:30.358]                             break
[10:31:30.358]                           }
[10:31:30.358]                         }
[10:31:30.358]                       }
[10:31:30.358]                       invisible(muffled)
[10:31:30.358]                     }
[10:31:30.358]                     muffleCondition(cond, pattern = "^muffle")
[10:31:30.358]                   }
[10:31:30.358]                 }
[10:31:30.358]                 else {
[10:31:30.358]                   if (TRUE) {
[10:31:30.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.358]                     {
[10:31:30.358]                       inherits <- base::inherits
[10:31:30.358]                       invokeRestart <- base::invokeRestart
[10:31:30.358]                       is.null <- base::is.null
[10:31:30.358]                       muffled <- FALSE
[10:31:30.358]                       if (inherits(cond, "message")) {
[10:31:30.358]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:30.358]                         if (muffled) 
[10:31:30.358]                           invokeRestart("muffleMessage")
[10:31:30.358]                       }
[10:31:30.358]                       else if (inherits(cond, "warning")) {
[10:31:30.358]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:30.358]                         if (muffled) 
[10:31:30.358]                           invokeRestart("muffleWarning")
[10:31:30.358]                       }
[10:31:30.358]                       else if (inherits(cond, "condition")) {
[10:31:30.358]                         if (!is.null(pattern)) {
[10:31:30.358]                           computeRestarts <- base::computeRestarts
[10:31:30.358]                           grepl <- base::grepl
[10:31:30.358]                           restarts <- computeRestarts(cond)
[10:31:30.358]                           for (restart in restarts) {
[10:31:30.358]                             name <- restart$name
[10:31:30.358]                             if (is.null(name)) 
[10:31:30.358]                               next
[10:31:30.358]                             if (!grepl(pattern, name)) 
[10:31:30.358]                               next
[10:31:30.358]                             invokeRestart(restart)
[10:31:30.358]                             muffled <- TRUE
[10:31:30.358]                             break
[10:31:30.358]                           }
[10:31:30.358]                         }
[10:31:30.358]                       }
[10:31:30.358]                       invisible(muffled)
[10:31:30.358]                     }
[10:31:30.358]                     muffleCondition(cond, pattern = "^muffle")
[10:31:30.358]                   }
[10:31:30.358]                 }
[10:31:30.358]             }
[10:31:30.358]         }))
[10:31:30.358]     }, error = function(ex) {
[10:31:30.358]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:30.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:30.358]                 ...future.rng), started = ...future.startTime, 
[10:31:30.358]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:30.358]             version = "1.8"), class = "FutureResult")
[10:31:30.358]     }, finally = {
[10:31:30.358]         if (!identical(...future.workdir, getwd())) 
[10:31:30.358]             setwd(...future.workdir)
[10:31:30.358]         {
[10:31:30.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:30.358]                 ...future.oldOptions$nwarnings <- NULL
[10:31:30.358]             }
[10:31:30.358]             base::options(...future.oldOptions)
[10:31:30.358]             if (.Platform$OS.type == "windows") {
[10:31:30.358]                 old_names <- names(...future.oldEnvVars)
[10:31:30.358]                 envs <- base::Sys.getenv()
[10:31:30.358]                 names <- names(envs)
[10:31:30.358]                 common <- intersect(names, old_names)
[10:31:30.358]                 added <- setdiff(names, old_names)
[10:31:30.358]                 removed <- setdiff(old_names, names)
[10:31:30.358]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:30.358]                   envs[common]]
[10:31:30.358]                 NAMES <- toupper(changed)
[10:31:30.358]                 args <- list()
[10:31:30.358]                 for (kk in seq_along(NAMES)) {
[10:31:30.358]                   name <- changed[[kk]]
[10:31:30.358]                   NAME <- NAMES[[kk]]
[10:31:30.358]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.358]                     next
[10:31:30.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:30.358]                 }
[10:31:30.358]                 NAMES <- toupper(added)
[10:31:30.358]                 for (kk in seq_along(NAMES)) {
[10:31:30.358]                   name <- added[[kk]]
[10:31:30.358]                   NAME <- NAMES[[kk]]
[10:31:30.358]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.358]                     next
[10:31:30.358]                   args[[name]] <- ""
[10:31:30.358]                 }
[10:31:30.358]                 NAMES <- toupper(removed)
[10:31:30.358]                 for (kk in seq_along(NAMES)) {
[10:31:30.358]                   name <- removed[[kk]]
[10:31:30.358]                   NAME <- NAMES[[kk]]
[10:31:30.358]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.358]                     next
[10:31:30.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:30.358]                 }
[10:31:30.358]                 if (length(args) > 0) 
[10:31:30.358]                   base::do.call(base::Sys.setenv, args = args)
[10:31:30.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:30.358]             }
[10:31:30.358]             else {
[10:31:30.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:30.358]             }
[10:31:30.358]             {
[10:31:30.358]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:30.358]                   0L) {
[10:31:30.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:30.358]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:30.358]                   base::options(opts)
[10:31:30.358]                 }
[10:31:30.358]                 {
[10:31:30.358]                   {
[10:31:30.358]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:30.358]                     NULL
[10:31:30.358]                   }
[10:31:30.358]                   options(future.plan = NULL)
[10:31:30.358]                   if (is.na(NA_character_)) 
[10:31:30.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:30.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:30.358]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:30.358]                     .init = FALSE)
[10:31:30.358]                 }
[10:31:30.358]             }
[10:31:30.358]         }
[10:31:30.358]     })
[10:31:30.358]     if (TRUE) {
[10:31:30.358]         base::sink(type = "output", split = FALSE)
[10:31:30.358]         if (TRUE) {
[10:31:30.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:30.358]         }
[10:31:30.358]         else {
[10:31:30.358]             ...future.result["stdout"] <- base::list(NULL)
[10:31:30.358]         }
[10:31:30.358]         base::close(...future.stdout)
[10:31:30.358]         ...future.stdout <- NULL
[10:31:30.358]     }
[10:31:30.358]     ...future.result$conditions <- ...future.conditions
[10:31:30.358]     ...future.result$finished <- base::Sys.time()
[10:31:30.358]     ...future.result
[10:31:30.358] }
[10:31:30.361] Exporting 11 global objects (91.99 KiB) to cluster node #1 ...
[10:31:30.361] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:30.405] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:30.405] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[10:31:30.406] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[10:31:30.406] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:30.406] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:30.406] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:30.449] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:30.449] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:30.493] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:30.493] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:30.494] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.494] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ...
[10:31:30.494] Exporting ‘valid_types’ (112 bytes) to cluster node #1 ... DONE
[10:31:30.494] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:30.495] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.495] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #1 ...
[10:31:30.495] Exporting ‘...future.elements_ii’ (1.48 KiB) to cluster node #1 ... DONE
[10:31:30.495] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:30.496] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.496] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:30.496] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.496] Exporting 11 global objects (91.99 KiB) to cluster node #1 ... DONE
[10:31:30.497] MultisessionFuture started
[10:31:30.497] - Launch lazy future ... done
[10:31:30.497] run() for ‘MultisessionFuture’ ... done
[10:31:30.497] Created future:
[10:31:30.497] MultisessionFuture:
[10:31:30.497] Label: ‘future_vapply-2’
[10:31:30.497] Expression:
[10:31:30.497] {
[10:31:30.497]     do.call(function(...) {
[10:31:30.497]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.497]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:30.497]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.497]             on.exit(options(oopts), add = TRUE)
[10:31:30.497]         }
[10:31:30.497]         {
[10:31:30.497]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:30.497]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.497]                 ...future.FUN(...future.X_jj, ...)
[10:31:30.497]             })
[10:31:30.497]         }
[10:31:30.497]     }, args = future.call.arguments)
[10:31:30.497] }
[10:31:30.497] Lazy evaluation: FALSE
[10:31:30.497] Asynchronous evaluation: TRUE
[10:31:30.497] Local evaluation: TRUE
[10:31:30.497] Environment: R_GlobalEnv
[10:31:30.497] Capture standard output: TRUE
[10:31:30.497] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:30.497] Globals: 11 objects totaling 93.48 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:30.497] Packages: 1 packages (‘future.apply’)
[10:31:30.497] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:30.497] Resolved: FALSE
[10:31:30.497] Value: <not collected>
[10:31:30.497] Conditions captured: <none>
[10:31:30.497] Early signaling: FALSE
[10:31:30.497] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:30.497] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:30.509] Chunk #2 of 2 ... DONE
[10:31:30.509] Launching 2 futures (chunks) ... DONE
[10:31:30.509] Resolving 2 futures (chunks) ...
[10:31:30.510] resolve() on list ...
[10:31:30.510]  recursive: 0
[10:31:30.510]  length: 2
[10:31:30.510] 
[10:31:30.510] Future #1
[10:31:30.510] result() for ClusterFuture ...
[10:31:30.510] - result already collected: FutureResult
[10:31:30.510] result() for ClusterFuture ... done
[10:31:30.510] result() for ClusterFuture ...
[10:31:30.510] - result already collected: FutureResult
[10:31:30.510] result() for ClusterFuture ... done
[10:31:30.511] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:30.511] - nx: 2
[10:31:30.511] - relay: TRUE
[10:31:30.511] - stdout: TRUE
[10:31:30.511] - signal: TRUE
[10:31:30.511] - resignal: FALSE
[10:31:30.511] - force: TRUE
[10:31:30.511] - relayed: [n=2] FALSE, FALSE
[10:31:30.511] - queued futures: [n=2] FALSE, FALSE
[10:31:30.511]  - until=1
[10:31:30.511]  - relaying element #1
[10:31:30.512] result() for ClusterFuture ...
[10:31:30.512] - result already collected: FutureResult
[10:31:30.512] result() for ClusterFuture ... done
[10:31:30.512] result() for ClusterFuture ...
[10:31:30.512] - result already collected: FutureResult
[10:31:30.512] result() for ClusterFuture ... done
[10:31:30.512] result() for ClusterFuture ...
[10:31:30.512] - result already collected: FutureResult
[10:31:30.512] result() for ClusterFuture ... done
[10:31:30.512] result() for ClusterFuture ...
[10:31:30.512] - result already collected: FutureResult
[10:31:30.513] result() for ClusterFuture ... done
[10:31:30.513] - relayed: [n=2] TRUE, FALSE
[10:31:30.513] - queued futures: [n=2] TRUE, FALSE
[10:31:30.513] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:30.513]  length: 1 (resolved future 1)
[10:31:30.542] receiveMessageFromWorker() for ClusterFuture ...
[10:31:30.543] - Validating connection of MultisessionFuture
[10:31:30.543] - received message: FutureResult
[10:31:30.543] - Received FutureResult
[10:31:30.543] - Erased future from FutureRegistry
[10:31:30.543] result() for ClusterFuture ...
[10:31:30.543] - result already collected: FutureResult
[10:31:30.543] result() for ClusterFuture ... done
[10:31:30.544] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:30.544] Future #2
[10:31:30.544] result() for ClusterFuture ...
[10:31:30.544] - result already collected: FutureResult
[10:31:30.544] result() for ClusterFuture ... done
[10:31:30.544] result() for ClusterFuture ...
[10:31:30.544] - result already collected: FutureResult
[10:31:30.544] result() for ClusterFuture ... done
[10:31:30.544] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:30.544] - nx: 2
[10:31:30.544] - relay: TRUE
[10:31:30.545] - stdout: TRUE
[10:31:30.545] - signal: TRUE
[10:31:30.545] - resignal: FALSE
[10:31:30.545] - force: TRUE
[10:31:30.545] - relayed: [n=2] TRUE, FALSE
[10:31:30.545] - queued futures: [n=2] TRUE, FALSE
[10:31:30.545]  - until=2
[10:31:30.545]  - relaying element #2
[10:31:30.545] result() for ClusterFuture ...
[10:31:30.545] - result already collected: FutureResult
[10:31:30.545] result() for ClusterFuture ... done
[10:31:30.546] result() for ClusterFuture ...
[10:31:30.546] - result already collected: FutureResult
[10:31:30.546] result() for ClusterFuture ... done
[10:31:30.546] result() for ClusterFuture ...
[10:31:30.546] - result already collected: FutureResult
[10:31:30.546] result() for ClusterFuture ... done
[10:31:30.546] result() for ClusterFuture ...
[10:31:30.546] - result already collected: FutureResult
[10:31:30.546] result() for ClusterFuture ... done
[10:31:30.546] - relayed: [n=2] TRUE, TRUE
[10:31:30.546] - queued futures: [n=2] TRUE, TRUE
[10:31:30.547] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:30.547]  length: 0 (resolved future 2)
[10:31:30.547] Relaying remaining futures
[10:31:30.547] signalConditionsASAP(NULL, pos=0) ...
[10:31:30.547] - nx: 2
[10:31:30.547] - relay: TRUE
[10:31:30.547] - stdout: TRUE
[10:31:30.547] - signal: TRUE
[10:31:30.547] - resignal: FALSE
[10:31:30.547] - force: TRUE
[10:31:30.547] - relayed: [n=2] TRUE, TRUE
[10:31:30.547] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:30.548] - relayed: [n=2] TRUE, TRUE
[10:31:30.548] - queued futures: [n=2] TRUE, TRUE
[10:31:30.548] signalConditionsASAP(NULL, pos=0) ... done
[10:31:30.548] resolve() on list ... DONE
[10:31:30.548] result() for ClusterFuture ...
[10:31:30.548] - result already collected: FutureResult
[10:31:30.548] result() for ClusterFuture ... done
[10:31:30.548] result() for ClusterFuture ...
[10:31:30.548] - result already collected: FutureResult
[10:31:30.548] result() for ClusterFuture ... done
[10:31:30.549] result() for ClusterFuture ...
[10:31:30.549] - result already collected: FutureResult
[10:31:30.549] result() for ClusterFuture ... done
[10:31:30.549] result() for ClusterFuture ...
[10:31:30.549] - result already collected: FutureResult
[10:31:30.549] result() for ClusterFuture ... done
[10:31:30.549]  - Number of value chunks collected: 2
[10:31:30.549] Resolving 2 futures (chunks) ... DONE
[10:31:30.549] Reducing values from 2 chunks ...
[10:31:30.549]  - Number of values collected after concatenation: 11
[10:31:30.549]  - Number of values expected: 11
[10:31:30.550] Reducing values from 2 chunks ... DONE
[10:31:30.550] future_lapply() ... DONE
 Named logi [1:11] TRUE TRUE TRUE TRUE TRUE TRUE ...
 - attr(*, "names")= chr [1:11] "mpg" "cyl" "disp" "hp" ...
- future_vapply(x, ...) where length(x) != length(as.list(x)) ...
[10:31:30.551] future_lapply() ...
[10:31:30.556] Number of chunks: 2
[10:31:30.556] getGlobalsAndPackagesXApply() ...
[10:31:30.556]  - future.globals: TRUE
[10:31:30.556] getGlobalsAndPackages() ...
[10:31:30.556] Searching for globals...
[10:31:30.559] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:30.559] Searching for globals ... DONE
[10:31:30.560] Resolving globals: FALSE
[10:31:30.560] The total size of the 7 globals is 92.05 KiB (94264 bytes)
[10:31:30.561] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.05 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:30.561] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:30.561] - packages: [1] ‘future.apply’
[10:31:30.561] getGlobalsAndPackages() ... DONE
[10:31:30.561]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:30.561]  - needed namespaces: [n=1] ‘future.apply’
[10:31:30.561] Finding globals ... DONE
[10:31:30.562]  - use_args: TRUE
[10:31:30.562]  - Getting '...' globals ...
[10:31:30.562] resolve() on list ...
[10:31:30.562]  recursive: 0
[10:31:30.562]  length: 1
[10:31:30.562]  elements: ‘...’
[10:31:30.562]  length: 0 (resolved future 1)
[10:31:30.562] resolve() on list ... DONE
[10:31:30.562]    - '...' content: [n=0] 
[10:31:30.563] List of 1
[10:31:30.563]  $ ...: list()
[10:31:30.563]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:30.563]  - attr(*, "where")=List of 1
[10:31:30.563]   ..$ ...:<environment: 0x55de86eb7de8> 
[10:31:30.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:30.563]  - attr(*, "resolved")= logi TRUE
[10:31:30.563]  - attr(*, "total_size")= num NA
[10:31:30.565]  - Getting '...' globals ... DONE
[10:31:30.565] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:30.565] List of 8
[10:31:30.565]  $ ...future.FUN:function (x, ...)  
[10:31:30.565]  $ x_FUN        :function (x)  
[10:31:30.565]  $ times        : int 1
[10:31:30.565]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:30.565]  $ stop_if_not  :function (...)  
[10:31:30.565]  $ dim          : NULL
[10:31:30.565]  $ valid_types  : chr [1:2] "logical" "integer"
[10:31:30.565]  $ ...          : list()
[10:31:30.565]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:30.565]  - attr(*, "where")=List of 8
[10:31:30.565]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:30.565]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:30.565]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:30.565]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:30.565]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:30.565]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:30.565]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:30.565]   ..$ ...          :<environment: 0x55de86eb7de8> 
[10:31:30.565]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:30.565]  - attr(*, "resolved")= logi FALSE
[10:31:30.565]  - attr(*, "total_size")= num 94264
[10:31:30.571] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:30.571] getGlobalsAndPackagesXApply() ... DONE
[10:31:30.571] Number of futures (= number of chunks): 2
[10:31:30.571] Launching 2 futures (chunks) ...
[10:31:30.571] Chunk #1 of 2 ...
[10:31:30.571]  - Finding globals in 'X' for chunk #1 ...
[10:31:30.571] getGlobalsAndPackages() ...
[10:31:30.571] Searching for globals...
[10:31:30.572] 
[10:31:30.572] Searching for globals ... DONE
[10:31:30.572] - globals: [0] <none>
[10:31:30.572] getGlobalsAndPackages() ... DONE
[10:31:30.572]    + additional globals found: [n=0] 
[10:31:30.572]    + additional namespaces needed: [n=0] 
[10:31:30.572]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:30.572]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:30.572]  - seeds: <none>
[10:31:30.572]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.573] getGlobalsAndPackages() ...
[10:31:30.573] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.573] Resolving globals: FALSE
[10:31:30.573] Tweak future expression to call with '...' arguments ...
[10:31:30.573] {
[10:31:30.573]     do.call(function(...) {
[10:31:30.573]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.573]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:30.573]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.573]             on.exit(options(oopts), add = TRUE)
[10:31:30.573]         }
[10:31:30.573]         {
[10:31:30.573]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:30.573]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.573]                 ...future.FUN(...future.X_jj, ...)
[10:31:30.573]             })
[10:31:30.573]         }
[10:31:30.573]     }, args = future.call.arguments)
[10:31:30.573] }
[10:31:30.573] Tweak future expression to call with '...' arguments ... DONE
[10:31:30.574] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.574] - packages: [1] ‘future.apply’
[10:31:30.574] getGlobalsAndPackages() ... DONE
[10:31:30.574] run() for ‘Future’ ...
[10:31:30.574] - state: ‘created’
[10:31:30.575] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:30.588] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:30.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:30.588]   - Field: ‘node’
[10:31:30.589]   - Field: ‘label’
[10:31:30.589]   - Field: ‘local’
[10:31:30.589]   - Field: ‘owner’
[10:31:30.589]   - Field: ‘envir’
[10:31:30.589]   - Field: ‘workers’
[10:31:30.589]   - Field: ‘packages’
[10:31:30.589]   - Field: ‘gc’
[10:31:30.589]   - Field: ‘conditions’
[10:31:30.589]   - Field: ‘persistent’
[10:31:30.589]   - Field: ‘expr’
[10:31:30.590]   - Field: ‘uuid’
[10:31:30.590]   - Field: ‘seed’
[10:31:30.590]   - Field: ‘version’
[10:31:30.590]   - Field: ‘result’
[10:31:30.590]   - Field: ‘asynchronous’
[10:31:30.590]   - Field: ‘calls’
[10:31:30.590]   - Field: ‘globals’
[10:31:30.590]   - Field: ‘stdout’
[10:31:30.590]   - Field: ‘earlySignal’
[10:31:30.590]   - Field: ‘lazy’
[10:31:30.590]   - Field: ‘state’
[10:31:30.591] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:30.591] - Launch lazy future ...
[10:31:30.591] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:30.591] Packages needed by future strategies (n = 0): <none>
[10:31:30.592] {
[10:31:30.592]     {
[10:31:30.592]         {
[10:31:30.592]             ...future.startTime <- base::Sys.time()
[10:31:30.592]             {
[10:31:30.592]                 {
[10:31:30.592]                   {
[10:31:30.592]                     {
[10:31:30.592]                       {
[10:31:30.592]                         base::local({
[10:31:30.592]                           has_future <- base::requireNamespace("future", 
[10:31:30.592]                             quietly = TRUE)
[10:31:30.592]                           if (has_future) {
[10:31:30.592]                             ns <- base::getNamespace("future")
[10:31:30.592]                             version <- ns[[".package"]][["version"]]
[10:31:30.592]                             if (is.null(version)) 
[10:31:30.592]                               version <- utils::packageVersion("future")
[10:31:30.592]                           }
[10:31:30.592]                           else {
[10:31:30.592]                             version <- NULL
[10:31:30.592]                           }
[10:31:30.592]                           if (!has_future || version < "1.8.0") {
[10:31:30.592]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:30.592]                               "", base::R.version$version.string), 
[10:31:30.592]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:30.592]                                 base::R.version$platform, 8 * 
[10:31:30.592]                                   base::.Machine$sizeof.pointer), 
[10:31:30.592]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:30.592]                                 "release", "version")], collapse = " "), 
[10:31:30.592]                               hostname = base::Sys.info()[["nodename"]])
[10:31:30.592]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:30.592]                               info)
[10:31:30.592]                             info <- base::paste(info, collapse = "; ")
[10:31:30.592]                             if (!has_future) {
[10:31:30.592]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:30.592]                                 info)
[10:31:30.592]                             }
[10:31:30.592]                             else {
[10:31:30.592]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:30.592]                                 info, version)
[10:31:30.592]                             }
[10:31:30.592]                             base::stop(msg)
[10:31:30.592]                           }
[10:31:30.592]                         })
[10:31:30.592]                       }
[10:31:30.592]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:30.592]                       base::options(mc.cores = 1L)
[10:31:30.592]                     }
[10:31:30.592]                     base::local({
[10:31:30.592]                       for (pkg in "future.apply") {
[10:31:30.592]                         base::loadNamespace(pkg)
[10:31:30.592]                         base::library(pkg, character.only = TRUE)
[10:31:30.592]                       }
[10:31:30.592]                     })
[10:31:30.592]                   }
[10:31:30.592]                   ...future.strategy.old <- future::plan("list")
[10:31:30.592]                   options(future.plan = NULL)
[10:31:30.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:30.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:30.592]                 }
[10:31:30.592]                 ...future.workdir <- getwd()
[10:31:30.592]             }
[10:31:30.592]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:30.592]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:30.592]         }
[10:31:30.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:30.592]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:30.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:30.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:30.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:30.592]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:30.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:30.592]             base::names(...future.oldOptions))
[10:31:30.592]     }
[10:31:30.592]     if (FALSE) {
[10:31:30.592]     }
[10:31:30.592]     else {
[10:31:30.592]         if (TRUE) {
[10:31:30.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:30.592]                 open = "w")
[10:31:30.592]         }
[10:31:30.592]         else {
[10:31:30.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:30.592]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:30.592]         }
[10:31:30.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:30.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:30.592]             base::sink(type = "output", split = FALSE)
[10:31:30.592]             base::close(...future.stdout)
[10:31:30.592]         }, add = TRUE)
[10:31:30.592]     }
[10:31:30.592]     ...future.frame <- base::sys.nframe()
[10:31:30.592]     ...future.conditions <- base::list()
[10:31:30.592]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:30.592]     if (FALSE) {
[10:31:30.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:30.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:30.592]     }
[10:31:30.592]     ...future.result <- base::tryCatch({
[10:31:30.592]         base::withCallingHandlers({
[10:31:30.592]             ...future.value <- base::withVisible(base::local({
[10:31:30.592]                 ...future.makeSendCondition <- base::local({
[10:31:30.592]                   sendCondition <- NULL
[10:31:30.592]                   function(frame = 1L) {
[10:31:30.592]                     if (is.function(sendCondition)) 
[10:31:30.592]                       return(sendCondition)
[10:31:30.592]                     ns <- getNamespace("parallel")
[10:31:30.592]                     if (exists("sendData", mode = "function", 
[10:31:30.592]                       envir = ns)) {
[10:31:30.592]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:30.592]                         envir = ns)
[10:31:30.592]                       envir <- sys.frame(frame)
[10:31:30.592]                       master <- NULL
[10:31:30.592]                       while (!identical(envir, .GlobalEnv) && 
[10:31:30.592]                         !identical(envir, emptyenv())) {
[10:31:30.592]                         if (exists("master", mode = "list", envir = envir, 
[10:31:30.592]                           inherits = FALSE)) {
[10:31:30.592]                           master <- get("master", mode = "list", 
[10:31:30.592]                             envir = envir, inherits = FALSE)
[10:31:30.592]                           if (inherits(master, c("SOCKnode", 
[10:31:30.592]                             "SOCK0node"))) {
[10:31:30.592]                             sendCondition <<- function(cond) {
[10:31:30.592]                               data <- list(type = "VALUE", value = cond, 
[10:31:30.592]                                 success = TRUE)
[10:31:30.592]                               parallel_sendData(master, data)
[10:31:30.592]                             }
[10:31:30.592]                             return(sendCondition)
[10:31:30.592]                           }
[10:31:30.592]                         }
[10:31:30.592]                         frame <- frame + 1L
[10:31:30.592]                         envir <- sys.frame(frame)
[10:31:30.592]                       }
[10:31:30.592]                     }
[10:31:30.592]                     sendCondition <<- function(cond) NULL
[10:31:30.592]                   }
[10:31:30.592]                 })
[10:31:30.592]                 withCallingHandlers({
[10:31:30.592]                   {
[10:31:30.592]                     do.call(function(...) {
[10:31:30.592]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.592]                       if (!identical(...future.globals.maxSize.org, 
[10:31:30.592]                         ...future.globals.maxSize)) {
[10:31:30.592]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.592]                         on.exit(options(oopts), add = TRUE)
[10:31:30.592]                       }
[10:31:30.592]                       {
[10:31:30.592]                         lapply(seq_along(...future.elements_ii), 
[10:31:30.592]                           FUN = function(jj) {
[10:31:30.592]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.592]                             ...future.FUN(...future.X_jj, ...)
[10:31:30.592]                           })
[10:31:30.592]                       }
[10:31:30.592]                     }, args = future.call.arguments)
[10:31:30.592]                   }
[10:31:30.592]                 }, immediateCondition = function(cond) {
[10:31:30.592]                   sendCondition <- ...future.makeSendCondition()
[10:31:30.592]                   sendCondition(cond)
[10:31:30.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.592]                   {
[10:31:30.592]                     inherits <- base::inherits
[10:31:30.592]                     invokeRestart <- base::invokeRestart
[10:31:30.592]                     is.null <- base::is.null
[10:31:30.592]                     muffled <- FALSE
[10:31:30.592]                     if (inherits(cond, "message")) {
[10:31:30.592]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:30.592]                       if (muffled) 
[10:31:30.592]                         invokeRestart("muffleMessage")
[10:31:30.592]                     }
[10:31:30.592]                     else if (inherits(cond, "warning")) {
[10:31:30.592]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:30.592]                       if (muffled) 
[10:31:30.592]                         invokeRestart("muffleWarning")
[10:31:30.592]                     }
[10:31:30.592]                     else if (inherits(cond, "condition")) {
[10:31:30.592]                       if (!is.null(pattern)) {
[10:31:30.592]                         computeRestarts <- base::computeRestarts
[10:31:30.592]                         grepl <- base::grepl
[10:31:30.592]                         restarts <- computeRestarts(cond)
[10:31:30.592]                         for (restart in restarts) {
[10:31:30.592]                           name <- restart$name
[10:31:30.592]                           if (is.null(name)) 
[10:31:30.592]                             next
[10:31:30.592]                           if (!grepl(pattern, name)) 
[10:31:30.592]                             next
[10:31:30.592]                           invokeRestart(restart)
[10:31:30.592]                           muffled <- TRUE
[10:31:30.592]                           break
[10:31:30.592]                         }
[10:31:30.592]                       }
[10:31:30.592]                     }
[10:31:30.592]                     invisible(muffled)
[10:31:30.592]                   }
[10:31:30.592]                   muffleCondition(cond)
[10:31:30.592]                 })
[10:31:30.592]             }))
[10:31:30.592]             future::FutureResult(value = ...future.value$value, 
[10:31:30.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:30.592]                   ...future.rng), globalenv = if (FALSE) 
[10:31:30.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:30.592]                     ...future.globalenv.names))
[10:31:30.592]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:30.592]         }, condition = base::local({
[10:31:30.592]             c <- base::c
[10:31:30.592]             inherits <- base::inherits
[10:31:30.592]             invokeRestart <- base::invokeRestart
[10:31:30.592]             length <- base::length
[10:31:30.592]             list <- base::list
[10:31:30.592]             seq.int <- base::seq.int
[10:31:30.592]             signalCondition <- base::signalCondition
[10:31:30.592]             sys.calls <- base::sys.calls
[10:31:30.592]             `[[` <- base::`[[`
[10:31:30.592]             `+` <- base::`+`
[10:31:30.592]             `<<-` <- base::`<<-`
[10:31:30.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:30.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:30.592]                   3L)]
[10:31:30.592]             }
[10:31:30.592]             function(cond) {
[10:31:30.592]                 is_error <- inherits(cond, "error")
[10:31:30.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:30.592]                   NULL)
[10:31:30.592]                 if (is_error) {
[10:31:30.592]                   sessionInformation <- function() {
[10:31:30.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:30.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:30.592]                       search = base::search(), system = base::Sys.info())
[10:31:30.592]                   }
[10:31:30.592]                   ...future.conditions[[length(...future.conditions) + 
[10:31:30.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:30.592]                     cond$call), session = sessionInformation(), 
[10:31:30.592]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:30.592]                   signalCondition(cond)
[10:31:30.592]                 }
[10:31:30.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:30.592]                 "immediateCondition"))) {
[10:31:30.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:30.592]                   ...future.conditions[[length(...future.conditions) + 
[10:31:30.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:30.592]                   if (TRUE && !signal) {
[10:31:30.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.592]                     {
[10:31:30.592]                       inherits <- base::inherits
[10:31:30.592]                       invokeRestart <- base::invokeRestart
[10:31:30.592]                       is.null <- base::is.null
[10:31:30.592]                       muffled <- FALSE
[10:31:30.592]                       if (inherits(cond, "message")) {
[10:31:30.592]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:30.592]                         if (muffled) 
[10:31:30.592]                           invokeRestart("muffleMessage")
[10:31:30.592]                       }
[10:31:30.592]                       else if (inherits(cond, "warning")) {
[10:31:30.592]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:30.592]                         if (muffled) 
[10:31:30.592]                           invokeRestart("muffleWarning")
[10:31:30.592]                       }
[10:31:30.592]                       else if (inherits(cond, "condition")) {
[10:31:30.592]                         if (!is.null(pattern)) {
[10:31:30.592]                           computeRestarts <- base::computeRestarts
[10:31:30.592]                           grepl <- base::grepl
[10:31:30.592]                           restarts <- computeRestarts(cond)
[10:31:30.592]                           for (restart in restarts) {
[10:31:30.592]                             name <- restart$name
[10:31:30.592]                             if (is.null(name)) 
[10:31:30.592]                               next
[10:31:30.592]                             if (!grepl(pattern, name)) 
[10:31:30.592]                               next
[10:31:30.592]                             invokeRestart(restart)
[10:31:30.592]                             muffled <- TRUE
[10:31:30.592]                             break
[10:31:30.592]                           }
[10:31:30.592]                         }
[10:31:30.592]                       }
[10:31:30.592]                       invisible(muffled)
[10:31:30.592]                     }
[10:31:30.592]                     muffleCondition(cond, pattern = "^muffle")
[10:31:30.592]                   }
[10:31:30.592]                 }
[10:31:30.592]                 else {
[10:31:30.592]                   if (TRUE) {
[10:31:30.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.592]                     {
[10:31:30.592]                       inherits <- base::inherits
[10:31:30.592]                       invokeRestart <- base::invokeRestart
[10:31:30.592]                       is.null <- base::is.null
[10:31:30.592]                       muffled <- FALSE
[10:31:30.592]                       if (inherits(cond, "message")) {
[10:31:30.592]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:30.592]                         if (muffled) 
[10:31:30.592]                           invokeRestart("muffleMessage")
[10:31:30.592]                       }
[10:31:30.592]                       else if (inherits(cond, "warning")) {
[10:31:30.592]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:30.592]                         if (muffled) 
[10:31:30.592]                           invokeRestart("muffleWarning")
[10:31:30.592]                       }
[10:31:30.592]                       else if (inherits(cond, "condition")) {
[10:31:30.592]                         if (!is.null(pattern)) {
[10:31:30.592]                           computeRestarts <- base::computeRestarts
[10:31:30.592]                           grepl <- base::grepl
[10:31:30.592]                           restarts <- computeRestarts(cond)
[10:31:30.592]                           for (restart in restarts) {
[10:31:30.592]                             name <- restart$name
[10:31:30.592]                             if (is.null(name)) 
[10:31:30.592]                               next
[10:31:30.592]                             if (!grepl(pattern, name)) 
[10:31:30.592]                               next
[10:31:30.592]                             invokeRestart(restart)
[10:31:30.592]                             muffled <- TRUE
[10:31:30.592]                             break
[10:31:30.592]                           }
[10:31:30.592]                         }
[10:31:30.592]                       }
[10:31:30.592]                       invisible(muffled)
[10:31:30.592]                     }
[10:31:30.592]                     muffleCondition(cond, pattern = "^muffle")
[10:31:30.592]                   }
[10:31:30.592]                 }
[10:31:30.592]             }
[10:31:30.592]         }))
[10:31:30.592]     }, error = function(ex) {
[10:31:30.592]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:30.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:30.592]                 ...future.rng), started = ...future.startTime, 
[10:31:30.592]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:30.592]             version = "1.8"), class = "FutureResult")
[10:31:30.592]     }, finally = {
[10:31:30.592]         if (!identical(...future.workdir, getwd())) 
[10:31:30.592]             setwd(...future.workdir)
[10:31:30.592]         {
[10:31:30.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:30.592]                 ...future.oldOptions$nwarnings <- NULL
[10:31:30.592]             }
[10:31:30.592]             base::options(...future.oldOptions)
[10:31:30.592]             if (.Platform$OS.type == "windows") {
[10:31:30.592]                 old_names <- names(...future.oldEnvVars)
[10:31:30.592]                 envs <- base::Sys.getenv()
[10:31:30.592]                 names <- names(envs)
[10:31:30.592]                 common <- intersect(names, old_names)
[10:31:30.592]                 added <- setdiff(names, old_names)
[10:31:30.592]                 removed <- setdiff(old_names, names)
[10:31:30.592]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:30.592]                   envs[common]]
[10:31:30.592]                 NAMES <- toupper(changed)
[10:31:30.592]                 args <- list()
[10:31:30.592]                 for (kk in seq_along(NAMES)) {
[10:31:30.592]                   name <- changed[[kk]]
[10:31:30.592]                   NAME <- NAMES[[kk]]
[10:31:30.592]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.592]                     next
[10:31:30.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:30.592]                 }
[10:31:30.592]                 NAMES <- toupper(added)
[10:31:30.592]                 for (kk in seq_along(NAMES)) {
[10:31:30.592]                   name <- added[[kk]]
[10:31:30.592]                   NAME <- NAMES[[kk]]
[10:31:30.592]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.592]                     next
[10:31:30.592]                   args[[name]] <- ""
[10:31:30.592]                 }
[10:31:30.592]                 NAMES <- toupper(removed)
[10:31:30.592]                 for (kk in seq_along(NAMES)) {
[10:31:30.592]                   name <- removed[[kk]]
[10:31:30.592]                   NAME <- NAMES[[kk]]
[10:31:30.592]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.592]                     next
[10:31:30.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:30.592]                 }
[10:31:30.592]                 if (length(args) > 0) 
[10:31:30.592]                   base::do.call(base::Sys.setenv, args = args)
[10:31:30.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:30.592]             }
[10:31:30.592]             else {
[10:31:30.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:30.592]             }
[10:31:30.592]             {
[10:31:30.592]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:30.592]                   0L) {
[10:31:30.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:30.592]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:30.592]                   base::options(opts)
[10:31:30.592]                 }
[10:31:30.592]                 {
[10:31:30.592]                   {
[10:31:30.592]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:30.592]                     NULL
[10:31:30.592]                   }
[10:31:30.592]                   options(future.plan = NULL)
[10:31:30.592]                   if (is.na(NA_character_)) 
[10:31:30.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:30.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:30.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:30.592]                     .init = FALSE)
[10:31:30.592]                 }
[10:31:30.592]             }
[10:31:30.592]         }
[10:31:30.592]     })
[10:31:30.592]     if (TRUE) {
[10:31:30.592]         base::sink(type = "output", split = FALSE)
[10:31:30.592]         if (TRUE) {
[10:31:30.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:30.592]         }
[10:31:30.592]         else {
[10:31:30.592]             ...future.result["stdout"] <- base::list(NULL)
[10:31:30.592]         }
[10:31:30.592]         base::close(...future.stdout)
[10:31:30.592]         ...future.stdout <- NULL
[10:31:30.592]     }
[10:31:30.592]     ...future.result$conditions <- ...future.conditions
[10:31:30.592]     ...future.result$finished <- base::Sys.time()
[10:31:30.592]     ...future.result
[10:31:30.592] }
[10:31:30.594] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[10:31:30.594] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:30.637] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:30.637] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[10:31:30.638] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[10:31:30.638] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:30.638] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:30.638] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:30.681] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:30.681] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:30.725] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:30.725] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:30.726] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.726] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[10:31:30.726] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[10:31:30.726] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:30.727] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.727] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:31:30.727] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:31:30.727] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:30.728] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.728] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:30.728] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.728] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[10:31:30.729] MultisessionFuture started
[10:31:30.729] - Launch lazy future ... done
[10:31:30.729] run() for ‘MultisessionFuture’ ... done
[10:31:30.729] Created future:
[10:31:30.731] receiveMessageFromWorker() for ClusterFuture ...
[10:31:30.731] - Validating connection of MultisessionFuture
[10:31:30.731] - received message: FutureResult
[10:31:30.731] - Received FutureResult
[10:31:30.731] - Erased future from FutureRegistry
[10:31:30.731] result() for ClusterFuture ...
[10:31:30.732] - result already collected: FutureResult
[10:31:30.732] result() for ClusterFuture ... done
[10:31:30.732] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:30.729] MultisessionFuture:
[10:31:30.729] Label: ‘future_vapply-1’
[10:31:30.729] Expression:
[10:31:30.729] {
[10:31:30.729]     do.call(function(...) {
[10:31:30.729]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.729]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:30.729]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.729]             on.exit(options(oopts), add = TRUE)
[10:31:30.729]         }
[10:31:30.729]         {
[10:31:30.729]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:30.729]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.729]                 ...future.FUN(...future.X_jj, ...)
[10:31:30.729]             })
[10:31:30.729]         }
[10:31:30.729]     }, args = future.call.arguments)
[10:31:30.729] }
[10:31:30.729] Lazy evaluation: FALSE
[10:31:30.729] Asynchronous evaluation: TRUE
[10:31:30.729] Local evaluation: TRUE
[10:31:30.729] Environment: R_GlobalEnv
[10:31:30.729] Capture standard output: TRUE
[10:31:30.729] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:30.729] Globals: 11 objects totaling 92.11 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:30.729] Packages: 1 packages (‘future.apply’)
[10:31:30.729] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:30.729] Resolved: TRUE
[10:31:30.729] Value: <not collected>
[10:31:30.729] Conditions captured: <none>
[10:31:30.729] Early signaling: FALSE
[10:31:30.729] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:30.729] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:30.732] Chunk #1 of 2 ... DONE
[10:31:30.732] Chunk #2 of 2 ...
[10:31:30.732]  - Finding globals in 'X' for chunk #2 ...
[10:31:30.732] getGlobalsAndPackages() ...
[10:31:30.732] Searching for globals...
[10:31:30.733] 
[10:31:30.733] Searching for globals ... DONE
[10:31:30.733] - globals: [0] <none>
[10:31:30.733] getGlobalsAndPackages() ... DONE
[10:31:30.733]    + additional globals found: [n=0] 
[10:31:30.733]    + additional namespaces needed: [n=0] 
[10:31:30.733]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:30.733]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:30.734]  - seeds: <none>
[10:31:30.734]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.734] getGlobalsAndPackages() ...
[10:31:30.734] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.734] Resolving globals: FALSE
[10:31:30.734] Tweak future expression to call with '...' arguments ...
[10:31:30.734] {
[10:31:30.734]     do.call(function(...) {
[10:31:30.734]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.734]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:30.734]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.734]             on.exit(options(oopts), add = TRUE)
[10:31:30.734]         }
[10:31:30.734]         {
[10:31:30.734]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:30.734]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.734]                 ...future.FUN(...future.X_jj, ...)
[10:31:30.734]             })
[10:31:30.734]         }
[10:31:30.734]     }, args = future.call.arguments)
[10:31:30.734] }
[10:31:30.734] Tweak future expression to call with '...' arguments ... DONE
[10:31:30.735] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.735] - packages: [1] ‘future.apply’
[10:31:30.735] getGlobalsAndPackages() ... DONE
[10:31:30.736] run() for ‘Future’ ...
[10:31:30.736] - state: ‘created’
[10:31:30.736] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:30.750] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:30.750] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:30.750]   - Field: ‘node’
[10:31:30.750]   - Field: ‘label’
[10:31:30.751]   - Field: ‘local’
[10:31:30.751]   - Field: ‘owner’
[10:31:30.751]   - Field: ‘envir’
[10:31:30.751]   - Field: ‘workers’
[10:31:30.751]   - Field: ‘packages’
[10:31:30.751]   - Field: ‘gc’
[10:31:30.751]   - Field: ‘conditions’
[10:31:30.754]   - Field: ‘persistent’
[10:31:30.754]   - Field: ‘expr’
[10:31:30.754]   - Field: ‘uuid’
[10:31:30.754]   - Field: ‘seed’
[10:31:30.754]   - Field: ‘version’
[10:31:30.754]   - Field: ‘result’
[10:31:30.754]   - Field: ‘asynchronous’
[10:31:30.754]   - Field: ‘calls’
[10:31:30.754]   - Field: ‘globals’
[10:31:30.755]   - Field: ‘stdout’
[10:31:30.755]   - Field: ‘earlySignal’
[10:31:30.755]   - Field: ‘lazy’
[10:31:30.755]   - Field: ‘state’
[10:31:30.755] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:30.755] - Launch lazy future ...
[10:31:30.755] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:30.755] Packages needed by future strategies (n = 0): <none>
[10:31:30.756] {
[10:31:30.756]     {
[10:31:30.756]         {
[10:31:30.756]             ...future.startTime <- base::Sys.time()
[10:31:30.756]             {
[10:31:30.756]                 {
[10:31:30.756]                   {
[10:31:30.756]                     {
[10:31:30.756]                       {
[10:31:30.756]                         base::local({
[10:31:30.756]                           has_future <- base::requireNamespace("future", 
[10:31:30.756]                             quietly = TRUE)
[10:31:30.756]                           if (has_future) {
[10:31:30.756]                             ns <- base::getNamespace("future")
[10:31:30.756]                             version <- ns[[".package"]][["version"]]
[10:31:30.756]                             if (is.null(version)) 
[10:31:30.756]                               version <- utils::packageVersion("future")
[10:31:30.756]                           }
[10:31:30.756]                           else {
[10:31:30.756]                             version <- NULL
[10:31:30.756]                           }
[10:31:30.756]                           if (!has_future || version < "1.8.0") {
[10:31:30.756]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:30.756]                               "", base::R.version$version.string), 
[10:31:30.756]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:30.756]                                 base::R.version$platform, 8 * 
[10:31:30.756]                                   base::.Machine$sizeof.pointer), 
[10:31:30.756]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:30.756]                                 "release", "version")], collapse = " "), 
[10:31:30.756]                               hostname = base::Sys.info()[["nodename"]])
[10:31:30.756]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:30.756]                               info)
[10:31:30.756]                             info <- base::paste(info, collapse = "; ")
[10:31:30.756]                             if (!has_future) {
[10:31:30.756]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:30.756]                                 info)
[10:31:30.756]                             }
[10:31:30.756]                             else {
[10:31:30.756]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:30.756]                                 info, version)
[10:31:30.756]                             }
[10:31:30.756]                             base::stop(msg)
[10:31:30.756]                           }
[10:31:30.756]                         })
[10:31:30.756]                       }
[10:31:30.756]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:30.756]                       base::options(mc.cores = 1L)
[10:31:30.756]                     }
[10:31:30.756]                     base::local({
[10:31:30.756]                       for (pkg in "future.apply") {
[10:31:30.756]                         base::loadNamespace(pkg)
[10:31:30.756]                         base::library(pkg, character.only = TRUE)
[10:31:30.756]                       }
[10:31:30.756]                     })
[10:31:30.756]                   }
[10:31:30.756]                   ...future.strategy.old <- future::plan("list")
[10:31:30.756]                   options(future.plan = NULL)
[10:31:30.756]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:30.756]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:30.756]                 }
[10:31:30.756]                 ...future.workdir <- getwd()
[10:31:30.756]             }
[10:31:30.756]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:30.756]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:30.756]         }
[10:31:30.756]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:30.756]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:30.756]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:30.756]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:30.756]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:30.756]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:30.756]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:30.756]             base::names(...future.oldOptions))
[10:31:30.756]     }
[10:31:30.756]     if (FALSE) {
[10:31:30.756]     }
[10:31:30.756]     else {
[10:31:30.756]         if (TRUE) {
[10:31:30.756]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:30.756]                 open = "w")
[10:31:30.756]         }
[10:31:30.756]         else {
[10:31:30.756]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:30.756]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:30.756]         }
[10:31:30.756]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:30.756]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:30.756]             base::sink(type = "output", split = FALSE)
[10:31:30.756]             base::close(...future.stdout)
[10:31:30.756]         }, add = TRUE)
[10:31:30.756]     }
[10:31:30.756]     ...future.frame <- base::sys.nframe()
[10:31:30.756]     ...future.conditions <- base::list()
[10:31:30.756]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:30.756]     if (FALSE) {
[10:31:30.756]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:30.756]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:30.756]     }
[10:31:30.756]     ...future.result <- base::tryCatch({
[10:31:30.756]         base::withCallingHandlers({
[10:31:30.756]             ...future.value <- base::withVisible(base::local({
[10:31:30.756]                 ...future.makeSendCondition <- base::local({
[10:31:30.756]                   sendCondition <- NULL
[10:31:30.756]                   function(frame = 1L) {
[10:31:30.756]                     if (is.function(sendCondition)) 
[10:31:30.756]                       return(sendCondition)
[10:31:30.756]                     ns <- getNamespace("parallel")
[10:31:30.756]                     if (exists("sendData", mode = "function", 
[10:31:30.756]                       envir = ns)) {
[10:31:30.756]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:30.756]                         envir = ns)
[10:31:30.756]                       envir <- sys.frame(frame)
[10:31:30.756]                       master <- NULL
[10:31:30.756]                       while (!identical(envir, .GlobalEnv) && 
[10:31:30.756]                         !identical(envir, emptyenv())) {
[10:31:30.756]                         if (exists("master", mode = "list", envir = envir, 
[10:31:30.756]                           inherits = FALSE)) {
[10:31:30.756]                           master <- get("master", mode = "list", 
[10:31:30.756]                             envir = envir, inherits = FALSE)
[10:31:30.756]                           if (inherits(master, c("SOCKnode", 
[10:31:30.756]                             "SOCK0node"))) {
[10:31:30.756]                             sendCondition <<- function(cond) {
[10:31:30.756]                               data <- list(type = "VALUE", value = cond, 
[10:31:30.756]                                 success = TRUE)
[10:31:30.756]                               parallel_sendData(master, data)
[10:31:30.756]                             }
[10:31:30.756]                             return(sendCondition)
[10:31:30.756]                           }
[10:31:30.756]                         }
[10:31:30.756]                         frame <- frame + 1L
[10:31:30.756]                         envir <- sys.frame(frame)
[10:31:30.756]                       }
[10:31:30.756]                     }
[10:31:30.756]                     sendCondition <<- function(cond) NULL
[10:31:30.756]                   }
[10:31:30.756]                 })
[10:31:30.756]                 withCallingHandlers({
[10:31:30.756]                   {
[10:31:30.756]                     do.call(function(...) {
[10:31:30.756]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.756]                       if (!identical(...future.globals.maxSize.org, 
[10:31:30.756]                         ...future.globals.maxSize)) {
[10:31:30.756]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.756]                         on.exit(options(oopts), add = TRUE)
[10:31:30.756]                       }
[10:31:30.756]                       {
[10:31:30.756]                         lapply(seq_along(...future.elements_ii), 
[10:31:30.756]                           FUN = function(jj) {
[10:31:30.756]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.756]                             ...future.FUN(...future.X_jj, ...)
[10:31:30.756]                           })
[10:31:30.756]                       }
[10:31:30.756]                     }, args = future.call.arguments)
[10:31:30.756]                   }
[10:31:30.756]                 }, immediateCondition = function(cond) {
[10:31:30.756]                   sendCondition <- ...future.makeSendCondition()
[10:31:30.756]                   sendCondition(cond)
[10:31:30.756]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.756]                   {
[10:31:30.756]                     inherits <- base::inherits
[10:31:30.756]                     invokeRestart <- base::invokeRestart
[10:31:30.756]                     is.null <- base::is.null
[10:31:30.756]                     muffled <- FALSE
[10:31:30.756]                     if (inherits(cond, "message")) {
[10:31:30.756]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:30.756]                       if (muffled) 
[10:31:30.756]                         invokeRestart("muffleMessage")
[10:31:30.756]                     }
[10:31:30.756]                     else if (inherits(cond, "warning")) {
[10:31:30.756]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:30.756]                       if (muffled) 
[10:31:30.756]                         invokeRestart("muffleWarning")
[10:31:30.756]                     }
[10:31:30.756]                     else if (inherits(cond, "condition")) {
[10:31:30.756]                       if (!is.null(pattern)) {
[10:31:30.756]                         computeRestarts <- base::computeRestarts
[10:31:30.756]                         grepl <- base::grepl
[10:31:30.756]                         restarts <- computeRestarts(cond)
[10:31:30.756]                         for (restart in restarts) {
[10:31:30.756]                           name <- restart$name
[10:31:30.756]                           if (is.null(name)) 
[10:31:30.756]                             next
[10:31:30.756]                           if (!grepl(pattern, name)) 
[10:31:30.756]                             next
[10:31:30.756]                           invokeRestart(restart)
[10:31:30.756]                           muffled <- TRUE
[10:31:30.756]                           break
[10:31:30.756]                         }
[10:31:30.756]                       }
[10:31:30.756]                     }
[10:31:30.756]                     invisible(muffled)
[10:31:30.756]                   }
[10:31:30.756]                   muffleCondition(cond)
[10:31:30.756]                 })
[10:31:30.756]             }))
[10:31:30.756]             future::FutureResult(value = ...future.value$value, 
[10:31:30.756]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:30.756]                   ...future.rng), globalenv = if (FALSE) 
[10:31:30.756]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:30.756]                     ...future.globalenv.names))
[10:31:30.756]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:30.756]         }, condition = base::local({
[10:31:30.756]             c <- base::c
[10:31:30.756]             inherits <- base::inherits
[10:31:30.756]             invokeRestart <- base::invokeRestart
[10:31:30.756]             length <- base::length
[10:31:30.756]             list <- base::list
[10:31:30.756]             seq.int <- base::seq.int
[10:31:30.756]             signalCondition <- base::signalCondition
[10:31:30.756]             sys.calls <- base::sys.calls
[10:31:30.756]             `[[` <- base::`[[`
[10:31:30.756]             `+` <- base::`+`
[10:31:30.756]             `<<-` <- base::`<<-`
[10:31:30.756]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:30.756]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:30.756]                   3L)]
[10:31:30.756]             }
[10:31:30.756]             function(cond) {
[10:31:30.756]                 is_error <- inherits(cond, "error")
[10:31:30.756]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:30.756]                   NULL)
[10:31:30.756]                 if (is_error) {
[10:31:30.756]                   sessionInformation <- function() {
[10:31:30.756]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:30.756]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:30.756]                       search = base::search(), system = base::Sys.info())
[10:31:30.756]                   }
[10:31:30.756]                   ...future.conditions[[length(...future.conditions) + 
[10:31:30.756]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:30.756]                     cond$call), session = sessionInformation(), 
[10:31:30.756]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:30.756]                   signalCondition(cond)
[10:31:30.756]                 }
[10:31:30.756]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:30.756]                 "immediateCondition"))) {
[10:31:30.756]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:30.756]                   ...future.conditions[[length(...future.conditions) + 
[10:31:30.756]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:30.756]                   if (TRUE && !signal) {
[10:31:30.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.756]                     {
[10:31:30.756]                       inherits <- base::inherits
[10:31:30.756]                       invokeRestart <- base::invokeRestart
[10:31:30.756]                       is.null <- base::is.null
[10:31:30.756]                       muffled <- FALSE
[10:31:30.756]                       if (inherits(cond, "message")) {
[10:31:30.756]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:30.756]                         if (muffled) 
[10:31:30.756]                           invokeRestart("muffleMessage")
[10:31:30.756]                       }
[10:31:30.756]                       else if (inherits(cond, "warning")) {
[10:31:30.756]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:30.756]                         if (muffled) 
[10:31:30.756]                           invokeRestart("muffleWarning")
[10:31:30.756]                       }
[10:31:30.756]                       else if (inherits(cond, "condition")) {
[10:31:30.756]                         if (!is.null(pattern)) {
[10:31:30.756]                           computeRestarts <- base::computeRestarts
[10:31:30.756]                           grepl <- base::grepl
[10:31:30.756]                           restarts <- computeRestarts(cond)
[10:31:30.756]                           for (restart in restarts) {
[10:31:30.756]                             name <- restart$name
[10:31:30.756]                             if (is.null(name)) 
[10:31:30.756]                               next
[10:31:30.756]                             if (!grepl(pattern, name)) 
[10:31:30.756]                               next
[10:31:30.756]                             invokeRestart(restart)
[10:31:30.756]                             muffled <- TRUE
[10:31:30.756]                             break
[10:31:30.756]                           }
[10:31:30.756]                         }
[10:31:30.756]                       }
[10:31:30.756]                       invisible(muffled)
[10:31:30.756]                     }
[10:31:30.756]                     muffleCondition(cond, pattern = "^muffle")
[10:31:30.756]                   }
[10:31:30.756]                 }
[10:31:30.756]                 else {
[10:31:30.756]                   if (TRUE) {
[10:31:30.756]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.756]                     {
[10:31:30.756]                       inherits <- base::inherits
[10:31:30.756]                       invokeRestart <- base::invokeRestart
[10:31:30.756]                       is.null <- base::is.null
[10:31:30.756]                       muffled <- FALSE
[10:31:30.756]                       if (inherits(cond, "message")) {
[10:31:30.756]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:30.756]                         if (muffled) 
[10:31:30.756]                           invokeRestart("muffleMessage")
[10:31:30.756]                       }
[10:31:30.756]                       else if (inherits(cond, "warning")) {
[10:31:30.756]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:30.756]                         if (muffled) 
[10:31:30.756]                           invokeRestart("muffleWarning")
[10:31:30.756]                       }
[10:31:30.756]                       else if (inherits(cond, "condition")) {
[10:31:30.756]                         if (!is.null(pattern)) {
[10:31:30.756]                           computeRestarts <- base::computeRestarts
[10:31:30.756]                           grepl <- base::grepl
[10:31:30.756]                           restarts <- computeRestarts(cond)
[10:31:30.756]                           for (restart in restarts) {
[10:31:30.756]                             name <- restart$name
[10:31:30.756]                             if (is.null(name)) 
[10:31:30.756]                               next
[10:31:30.756]                             if (!grepl(pattern, name)) 
[10:31:30.756]                               next
[10:31:30.756]                             invokeRestart(restart)
[10:31:30.756]                             muffled <- TRUE
[10:31:30.756]                             break
[10:31:30.756]                           }
[10:31:30.756]                         }
[10:31:30.756]                       }
[10:31:30.756]                       invisible(muffled)
[10:31:30.756]                     }
[10:31:30.756]                     muffleCondition(cond, pattern = "^muffle")
[10:31:30.756]                   }
[10:31:30.756]                 }
[10:31:30.756]             }
[10:31:30.756]         }))
[10:31:30.756]     }, error = function(ex) {
[10:31:30.756]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:30.756]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:30.756]                 ...future.rng), started = ...future.startTime, 
[10:31:30.756]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:30.756]             version = "1.8"), class = "FutureResult")
[10:31:30.756]     }, finally = {
[10:31:30.756]         if (!identical(...future.workdir, getwd())) 
[10:31:30.756]             setwd(...future.workdir)
[10:31:30.756]         {
[10:31:30.756]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:30.756]                 ...future.oldOptions$nwarnings <- NULL
[10:31:30.756]             }
[10:31:30.756]             base::options(...future.oldOptions)
[10:31:30.756]             if (.Platform$OS.type == "windows") {
[10:31:30.756]                 old_names <- names(...future.oldEnvVars)
[10:31:30.756]                 envs <- base::Sys.getenv()
[10:31:30.756]                 names <- names(envs)
[10:31:30.756]                 common <- intersect(names, old_names)
[10:31:30.756]                 added <- setdiff(names, old_names)
[10:31:30.756]                 removed <- setdiff(old_names, names)
[10:31:30.756]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:30.756]                   envs[common]]
[10:31:30.756]                 NAMES <- toupper(changed)
[10:31:30.756]                 args <- list()
[10:31:30.756]                 for (kk in seq_along(NAMES)) {
[10:31:30.756]                   name <- changed[[kk]]
[10:31:30.756]                   NAME <- NAMES[[kk]]
[10:31:30.756]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.756]                     next
[10:31:30.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:30.756]                 }
[10:31:30.756]                 NAMES <- toupper(added)
[10:31:30.756]                 for (kk in seq_along(NAMES)) {
[10:31:30.756]                   name <- added[[kk]]
[10:31:30.756]                   NAME <- NAMES[[kk]]
[10:31:30.756]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.756]                     next
[10:31:30.756]                   args[[name]] <- ""
[10:31:30.756]                 }
[10:31:30.756]                 NAMES <- toupper(removed)
[10:31:30.756]                 for (kk in seq_along(NAMES)) {
[10:31:30.756]                   name <- removed[[kk]]
[10:31:30.756]                   NAME <- NAMES[[kk]]
[10:31:30.756]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.756]                     next
[10:31:30.756]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:30.756]                 }
[10:31:30.756]                 if (length(args) > 0) 
[10:31:30.756]                   base::do.call(base::Sys.setenv, args = args)
[10:31:30.756]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:30.756]             }
[10:31:30.756]             else {
[10:31:30.756]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:30.756]             }
[10:31:30.756]             {
[10:31:30.756]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:30.756]                   0L) {
[10:31:30.756]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:30.756]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:30.756]                   base::options(opts)
[10:31:30.756]                 }
[10:31:30.756]                 {
[10:31:30.756]                   {
[10:31:30.756]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:30.756]                     NULL
[10:31:30.756]                   }
[10:31:30.756]                   options(future.plan = NULL)
[10:31:30.756]                   if (is.na(NA_character_)) 
[10:31:30.756]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:30.756]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:30.756]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:30.756]                     .init = FALSE)
[10:31:30.756]                 }
[10:31:30.756]             }
[10:31:30.756]         }
[10:31:30.756]     })
[10:31:30.756]     if (TRUE) {
[10:31:30.756]         base::sink(type = "output", split = FALSE)
[10:31:30.756]         if (TRUE) {
[10:31:30.756]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:30.756]         }
[10:31:30.756]         else {
[10:31:30.756]             ...future.result["stdout"] <- base::list(NULL)
[10:31:30.756]         }
[10:31:30.756]         base::close(...future.stdout)
[10:31:30.756]         ...future.stdout <- NULL
[10:31:30.756]     }
[10:31:30.756]     ...future.result$conditions <- ...future.conditions
[10:31:30.756]     ...future.result$finished <- base::Sys.time()
[10:31:30.756]     ...future.result
[10:31:30.756] }
[10:31:30.759] Exporting 11 global objects (92.05 KiB) to cluster node #1 ...
[10:31:30.759] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:30.801] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:30.801] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ...
[10:31:30.802] Exporting ‘x_FUN’ (56 bytes) to cluster node #1 ... DONE
[10:31:30.802] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:30.802] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:30.802] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:30.845] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:30.845] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:30.889] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:30.889] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:30.890] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.890] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ...
[10:31:30.890] Exporting ‘valid_types’ (176 bytes) to cluster node #1 ... DONE
[10:31:30.890] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:30.891] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.891] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ...
[10:31:30.891] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #1 ... DONE
[10:31:30.891] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:30.892] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.892] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:30.892] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:30.892] Exporting 11 global objects (92.05 KiB) to cluster node #1 ... DONE
[10:31:30.893] MultisessionFuture started
[10:31:30.893] - Launch lazy future ... done
[10:31:30.893] run() for ‘MultisessionFuture’ ... done
[10:31:30.894] Created future:
[10:31:30.894] MultisessionFuture:
[10:31:30.894] Label: ‘future_vapply-2’
[10:31:30.894] Expression:
[10:31:30.894] {
[10:31:30.894]     do.call(function(...) {
[10:31:30.894]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.894]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:30.894]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.894]             on.exit(options(oopts), add = TRUE)
[10:31:30.894]         }
[10:31:30.894]         {
[10:31:30.894]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:30.894]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.894]                 ...future.FUN(...future.X_jj, ...)
[10:31:30.894]             })
[10:31:30.894]         }
[10:31:30.894]     }, args = future.call.arguments)
[10:31:30.894] }
[10:31:30.894] Lazy evaluation: FALSE
[10:31:30.894] Asynchronous evaluation: TRUE
[10:31:30.894] Local evaluation: TRUE
[10:31:30.894] Environment: R_GlobalEnv
[10:31:30.894] Capture standard output: TRUE
[10:31:30.894] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:30.894] Globals: 11 objects totaling 92.16 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 56 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:30.894] Packages: 1 packages (‘future.apply’)
[10:31:30.894] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:30.894] Resolved: FALSE
[10:31:30.894] Value: <not collected>
[10:31:30.894] Conditions captured: <none>
[10:31:30.894] Early signaling: FALSE
[10:31:30.894] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:30.894] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:30.905] Chunk #2 of 2 ... DONE
[10:31:30.905] Launching 2 futures (chunks) ... DONE
[10:31:30.906] Resolving 2 futures (chunks) ...
[10:31:30.906] resolve() on list ...
[10:31:30.906]  recursive: 0
[10:31:30.906]  length: 2
[10:31:30.906] 
[10:31:30.906] Future #1
[10:31:30.906] result() for ClusterFuture ...
[10:31:30.906] - result already collected: FutureResult
[10:31:30.906] result() for ClusterFuture ... done
[10:31:30.906] result() for ClusterFuture ...
[10:31:30.907] - result already collected: FutureResult
[10:31:30.907] result() for ClusterFuture ... done
[10:31:30.907] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:30.907] - nx: 2
[10:31:30.907] - relay: TRUE
[10:31:30.907] - stdout: TRUE
[10:31:30.907] - signal: TRUE
[10:31:30.907] - resignal: FALSE
[10:31:30.907] - force: TRUE
[10:31:30.907] - relayed: [n=2] FALSE, FALSE
[10:31:30.907] - queued futures: [n=2] FALSE, FALSE
[10:31:30.907]  - until=1
[10:31:30.908]  - relaying element #1
[10:31:30.908] result() for ClusterFuture ...
[10:31:30.908] - result already collected: FutureResult
[10:31:30.908] result() for ClusterFuture ... done
[10:31:30.908] result() for ClusterFuture ...
[10:31:30.908] - result already collected: FutureResult
[10:31:30.908] result() for ClusterFuture ... done
[10:31:30.908] result() for ClusterFuture ...
[10:31:30.908] - result already collected: FutureResult
[10:31:30.908] result() for ClusterFuture ... done
[10:31:30.909] result() for ClusterFuture ...
[10:31:30.909] - result already collected: FutureResult
[10:31:30.909] result() for ClusterFuture ... done
[10:31:30.909] - relayed: [n=2] TRUE, FALSE
[10:31:30.909] - queued futures: [n=2] TRUE, FALSE
[10:31:30.909] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:30.909]  length: 1 (resolved future 1)
[10:31:30.938] receiveMessageFromWorker() for ClusterFuture ...
[10:31:30.939] - Validating connection of MultisessionFuture
[10:31:30.939] - received message: FutureResult
[10:31:30.939] - Received FutureResult
[10:31:30.939] - Erased future from FutureRegistry
[10:31:30.939] result() for ClusterFuture ...
[10:31:30.939] - result already collected: FutureResult
[10:31:30.939] result() for ClusterFuture ... done
[10:31:30.939] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:30.939] Future #2
[10:31:30.940] result() for ClusterFuture ...
[10:31:30.940] - result already collected: FutureResult
[10:31:30.940] result() for ClusterFuture ... done
[10:31:30.940] result() for ClusterFuture ...
[10:31:30.940] - result already collected: FutureResult
[10:31:30.940] result() for ClusterFuture ... done
[10:31:30.940] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:31:30.940] - nx: 2
[10:31:30.940] - relay: TRUE
[10:31:30.941] - stdout: TRUE
[10:31:30.941] - signal: TRUE
[10:31:30.941] - resignal: FALSE
[10:31:30.941] - force: TRUE
[10:31:30.941] - relayed: [n=2] TRUE, FALSE
[10:31:30.941] - queued futures: [n=2] TRUE, FALSE
[10:31:30.941]  - until=2
[10:31:30.941]  - relaying element #2
[10:31:30.941] result() for ClusterFuture ...
[10:31:30.941] - result already collected: FutureResult
[10:31:30.942] result() for ClusterFuture ... done
[10:31:30.942] result() for ClusterFuture ...
[10:31:30.942] - result already collected: FutureResult
[10:31:30.942] result() for ClusterFuture ... done
[10:31:30.942] result() for ClusterFuture ...
[10:31:30.942] - result already collected: FutureResult
[10:31:30.942] result() for ClusterFuture ... done
[10:31:30.942] result() for ClusterFuture ...
[10:31:30.942] - result already collected: FutureResult
[10:31:30.942] result() for ClusterFuture ... done
[10:31:30.942] - relayed: [n=2] TRUE, TRUE
[10:31:30.943] - queued futures: [n=2] TRUE, TRUE
[10:31:30.943] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:31:30.943]  length: 0 (resolved future 2)
[10:31:30.943] Relaying remaining futures
[10:31:30.943] signalConditionsASAP(NULL, pos=0) ...
[10:31:30.943] - nx: 2
[10:31:30.943] - relay: TRUE
[10:31:30.943] - stdout: TRUE
[10:31:30.943] - signal: TRUE
[10:31:30.943] - resignal: FALSE
[10:31:30.943] - force: TRUE
[10:31:30.944] - relayed: [n=2] TRUE, TRUE
[10:31:30.944] - queued futures: [n=2] TRUE, TRUE
 - flush all
[10:31:30.944] - relayed: [n=2] TRUE, TRUE
[10:31:30.944] - queued futures: [n=2] TRUE, TRUE
[10:31:30.944] signalConditionsASAP(NULL, pos=0) ... done
[10:31:30.944] resolve() on list ... DONE
[10:31:30.944] result() for ClusterFuture ...
[10:31:30.944] - result already collected: FutureResult
[10:31:30.944] result() for ClusterFuture ... done
[10:31:30.944] result() for ClusterFuture ...
[10:31:30.944] - result already collected: FutureResult
[10:31:30.945] result() for ClusterFuture ... done
[10:31:30.945] result() for ClusterFuture ...
[10:31:30.945] - result already collected: FutureResult
[10:31:30.945] result() for ClusterFuture ... done
[10:31:30.945] result() for ClusterFuture ...
[10:31:30.945] - result already collected: FutureResult
[10:31:30.945] result() for ClusterFuture ... done
[10:31:30.945]  - Number of value chunks collected: 2
[10:31:30.945] Resolving 2 futures (chunks) ... DONE
[10:31:30.945] Reducing values from 2 chunks ...
[10:31:30.946]  - Number of values collected after concatenation: 3
[10:31:30.946]  - Number of values expected: 3
[10:31:30.946] Reducing values from 2 chunks ... DONE
[10:31:30.946] future_lapply() ... DONE
- exceptions ...
[10:31:30.946] future_lapply() ...
[10:31:30.951] Number of chunks: 2
[10:31:30.952] getGlobalsAndPackagesXApply() ...
[10:31:30.952]  - future.globals: TRUE
[10:31:30.952] getGlobalsAndPackages() ...
[10:31:30.952] Searching for globals...
[10:31:30.955] - globals found: [16] ‘FUN’, ‘{’, ‘<-’, ‘x_FUN’, ‘if’, ‘!=’, ‘length’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘all’, ‘==’, ‘dim’, ‘%in%’, ‘typeof’, ‘valid_types’
[10:31:30.955] Searching for globals ... DONE
[10:31:30.955] Resolving globals: FALSE
[10:31:30.956] The total size of the 7 globals is 92.90 KiB (95128 bytes)
[10:31:30.957] The total size of the 7 globals exported for future expression (‘FUN()’) is 92.90 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are ‘stop_if_not’ (44.12 KiB of class ‘function’), ‘stopf’ (26.43 KiB of class ‘function’) and ‘FUN’ (21.22 KiB of class ‘function’)
[10:31:30.957] - globals: [7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:30.957] - packages: [1] ‘future.apply’
[10:31:30.957] getGlobalsAndPackages() ... DONE
[10:31:30.957]  - globals found/used: [n=7] ‘FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’
[10:31:30.957]  - needed namespaces: [n=1] ‘future.apply’
[10:31:30.957] Finding globals ... DONE
[10:31:30.957]  - use_args: TRUE
[10:31:30.957]  - Getting '...' globals ...
[10:31:30.958] resolve() on list ...
[10:31:30.958]  recursive: 0
[10:31:30.958]  length: 1
[10:31:30.958]  elements: ‘...’
[10:31:30.958]  length: 0 (resolved future 1)
[10:31:30.958] resolve() on list ... DONE
[10:31:30.958]    - '...' content: [n=0] 
[10:31:30.958] List of 1
[10:31:30.958]  $ ...: list()
[10:31:30.958]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:30.958]  - attr(*, "where")=List of 1
[10:31:30.958]   ..$ ...:<environment: 0x55de86732500> 
[10:31:30.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:30.958]  - attr(*, "resolved")= logi TRUE
[10:31:30.958]  - attr(*, "total_size")= num NA
[10:31:30.961]  - Getting '...' globals ... DONE
[10:31:30.961] Globals to be used in all futures (chunks): [n=8] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’
[10:31:30.961] List of 8
[10:31:30.961]  $ ...future.FUN:function (x, ...)  
[10:31:30.961]  $ x_FUN        :function (x)  
[10:31:30.961]  $ times        : int 2
[10:31:30.961]  $ stopf        :function (fmt, ..., call. = TRUE, domain = NULL)  
[10:31:30.961]  $ stop_if_not  :function (...)  
[10:31:30.961]  $ dim          : NULL
[10:31:30.961]  $ valid_types  : chr [1:3] "logical" "integer" "double"
[10:31:30.961]  $ ...          : list()
[10:31:30.961]   ..- attr(*, "class")= chr [1:2] "DotDotDotList" "list"
[10:31:30.961]  - attr(*, "where")=List of 8
[10:31:30.961]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[10:31:30.961]   ..$ x_FUN        :<environment: R_EmptyEnv> 
[10:31:30.961]   ..$ times        :<environment: R_EmptyEnv> 
[10:31:30.961]   ..$ stopf        :<environment: R_EmptyEnv> 
[10:31:30.961]   ..$ stop_if_not  :<environment: R_EmptyEnv> 
[10:31:30.961]   ..$ dim          :<environment: R_EmptyEnv> 
[10:31:30.961]   ..$ valid_types  :<environment: R_EmptyEnv> 
[10:31:30.961]   ..$ ...          :<environment: 0x55de86732500> 
[10:31:30.961]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:31:30.961]  - attr(*, "resolved")= logi FALSE
[10:31:30.961]  - attr(*, "total_size")= num 95128
[10:31:30.966] Packages to be attached in all futures: [n=1] ‘future.apply’
[10:31:30.967] getGlobalsAndPackagesXApply() ... DONE
[10:31:30.967] Number of futures (= number of chunks): 2
[10:31:30.967] Launching 2 futures (chunks) ...
[10:31:30.967] Chunk #1 of 2 ...
[10:31:30.967]  - Finding globals in 'X' for chunk #1 ...
[10:31:30.967] getGlobalsAndPackages() ...
[10:31:30.967] Searching for globals...
[10:31:30.967] 
[10:31:30.968] Searching for globals ... DONE
[10:31:30.968] - globals: [0] <none>
[10:31:30.968] getGlobalsAndPackages() ... DONE
[10:31:30.968]    + additional globals found: [n=0] 
[10:31:30.968]    + additional namespaces needed: [n=0] 
[10:31:30.968]  - Finding globals in 'X' for chunk #1 ... DONE
[10:31:30.968]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:30.968]  - seeds: <none>
[10:31:30.968]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.968] getGlobalsAndPackages() ...
[10:31:30.968] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.969] Resolving globals: FALSE
[10:31:30.969] Tweak future expression to call with '...' arguments ...
[10:31:30.969] {
[10:31:30.969]     do.call(function(...) {
[10:31:30.969]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.969]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:30.969]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.969]             on.exit(options(oopts), add = TRUE)
[10:31:30.969]         }
[10:31:30.969]         {
[10:31:30.969]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:30.969]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.969]                 ...future.FUN(...future.X_jj, ...)
[10:31:30.969]             })
[10:31:30.969]         }
[10:31:30.969]     }, args = future.call.arguments)
[10:31:30.969] }
[10:31:30.969] Tweak future expression to call with '...' arguments ... DONE
[10:31:30.970] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:30.970] - packages: [1] ‘future.apply’
[10:31:30.970] getGlobalsAndPackages() ... DONE
[10:31:30.970] run() for ‘Future’ ...
[10:31:30.970] - state: ‘created’
[10:31:30.970] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:30.984] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:30.984] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:30.984]   - Field: ‘node’
[10:31:30.985]   - Field: ‘label’
[10:31:30.985]   - Field: ‘local’
[10:31:30.985]   - Field: ‘owner’
[10:31:30.985]   - Field: ‘envir’
[10:31:30.985]   - Field: ‘workers’
[10:31:30.985]   - Field: ‘packages’
[10:31:30.985]   - Field: ‘gc’
[10:31:30.985]   - Field: ‘conditions’
[10:31:30.985]   - Field: ‘persistent’
[10:31:30.985]   - Field: ‘expr’
[10:31:30.986]   - Field: ‘uuid’
[10:31:30.986]   - Field: ‘seed’
[10:31:30.986]   - Field: ‘version’
[10:31:30.986]   - Field: ‘result’
[10:31:30.986]   - Field: ‘asynchronous’
[10:31:30.986]   - Field: ‘calls’
[10:31:30.986]   - Field: ‘globals’
[10:31:30.986]   - Field: ‘stdout’
[10:31:30.986]   - Field: ‘earlySignal’
[10:31:30.986]   - Field: ‘lazy’
[10:31:30.986]   - Field: ‘state’
[10:31:30.987] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:30.987] - Launch lazy future ...
[10:31:30.987] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:30.987] Packages needed by future strategies (n = 0): <none>
[10:31:30.988] {
[10:31:30.988]     {
[10:31:30.988]         {
[10:31:30.988]             ...future.startTime <- base::Sys.time()
[10:31:30.988]             {
[10:31:30.988]                 {
[10:31:30.988]                   {
[10:31:30.988]                     {
[10:31:30.988]                       {
[10:31:30.988]                         base::local({
[10:31:30.988]                           has_future <- base::requireNamespace("future", 
[10:31:30.988]                             quietly = TRUE)
[10:31:30.988]                           if (has_future) {
[10:31:30.988]                             ns <- base::getNamespace("future")
[10:31:30.988]                             version <- ns[[".package"]][["version"]]
[10:31:30.988]                             if (is.null(version)) 
[10:31:30.988]                               version <- utils::packageVersion("future")
[10:31:30.988]                           }
[10:31:30.988]                           else {
[10:31:30.988]                             version <- NULL
[10:31:30.988]                           }
[10:31:30.988]                           if (!has_future || version < "1.8.0") {
[10:31:30.988]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:30.988]                               "", base::R.version$version.string), 
[10:31:30.988]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:30.988]                                 base::R.version$platform, 8 * 
[10:31:30.988]                                   base::.Machine$sizeof.pointer), 
[10:31:30.988]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:30.988]                                 "release", "version")], collapse = " "), 
[10:31:30.988]                               hostname = base::Sys.info()[["nodename"]])
[10:31:30.988]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:30.988]                               info)
[10:31:30.988]                             info <- base::paste(info, collapse = "; ")
[10:31:30.988]                             if (!has_future) {
[10:31:30.988]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:30.988]                                 info)
[10:31:30.988]                             }
[10:31:30.988]                             else {
[10:31:30.988]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:30.988]                                 info, version)
[10:31:30.988]                             }
[10:31:30.988]                             base::stop(msg)
[10:31:30.988]                           }
[10:31:30.988]                         })
[10:31:30.988]                       }
[10:31:30.988]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:30.988]                       base::options(mc.cores = 1L)
[10:31:30.988]                     }
[10:31:30.988]                     base::local({
[10:31:30.988]                       for (pkg in "future.apply") {
[10:31:30.988]                         base::loadNamespace(pkg)
[10:31:30.988]                         base::library(pkg, character.only = TRUE)
[10:31:30.988]                       }
[10:31:30.988]                     })
[10:31:30.988]                   }
[10:31:30.988]                   ...future.strategy.old <- future::plan("list")
[10:31:30.988]                   options(future.plan = NULL)
[10:31:30.988]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:30.988]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:30.988]                 }
[10:31:30.988]                 ...future.workdir <- getwd()
[10:31:30.988]             }
[10:31:30.988]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:30.988]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:30.988]         }
[10:31:30.988]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:30.988]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:30.988]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:30.988]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:30.988]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:30.988]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:30.988]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:30.988]             base::names(...future.oldOptions))
[10:31:30.988]     }
[10:31:30.988]     if (FALSE) {
[10:31:30.988]     }
[10:31:30.988]     else {
[10:31:30.988]         if (TRUE) {
[10:31:30.988]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:30.988]                 open = "w")
[10:31:30.988]         }
[10:31:30.988]         else {
[10:31:30.988]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:30.988]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:30.988]         }
[10:31:30.988]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:30.988]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:30.988]             base::sink(type = "output", split = FALSE)
[10:31:30.988]             base::close(...future.stdout)
[10:31:30.988]         }, add = TRUE)
[10:31:30.988]     }
[10:31:30.988]     ...future.frame <- base::sys.nframe()
[10:31:30.988]     ...future.conditions <- base::list()
[10:31:30.988]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:30.988]     if (FALSE) {
[10:31:30.988]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:30.988]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:30.988]     }
[10:31:30.988]     ...future.result <- base::tryCatch({
[10:31:30.988]         base::withCallingHandlers({
[10:31:30.988]             ...future.value <- base::withVisible(base::local({
[10:31:30.988]                 ...future.makeSendCondition <- base::local({
[10:31:30.988]                   sendCondition <- NULL
[10:31:30.988]                   function(frame = 1L) {
[10:31:30.988]                     if (is.function(sendCondition)) 
[10:31:30.988]                       return(sendCondition)
[10:31:30.988]                     ns <- getNamespace("parallel")
[10:31:30.988]                     if (exists("sendData", mode = "function", 
[10:31:30.988]                       envir = ns)) {
[10:31:30.988]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:30.988]                         envir = ns)
[10:31:30.988]                       envir <- sys.frame(frame)
[10:31:30.988]                       master <- NULL
[10:31:30.988]                       while (!identical(envir, .GlobalEnv) && 
[10:31:30.988]                         !identical(envir, emptyenv())) {
[10:31:30.988]                         if (exists("master", mode = "list", envir = envir, 
[10:31:30.988]                           inherits = FALSE)) {
[10:31:30.988]                           master <- get("master", mode = "list", 
[10:31:30.988]                             envir = envir, inherits = FALSE)
[10:31:30.988]                           if (inherits(master, c("SOCKnode", 
[10:31:30.988]                             "SOCK0node"))) {
[10:31:30.988]                             sendCondition <<- function(cond) {
[10:31:30.988]                               data <- list(type = "VALUE", value = cond, 
[10:31:30.988]                                 success = TRUE)
[10:31:30.988]                               parallel_sendData(master, data)
[10:31:30.988]                             }
[10:31:30.988]                             return(sendCondition)
[10:31:30.988]                           }
[10:31:30.988]                         }
[10:31:30.988]                         frame <- frame + 1L
[10:31:30.988]                         envir <- sys.frame(frame)
[10:31:30.988]                       }
[10:31:30.988]                     }
[10:31:30.988]                     sendCondition <<- function(cond) NULL
[10:31:30.988]                   }
[10:31:30.988]                 })
[10:31:30.988]                 withCallingHandlers({
[10:31:30.988]                   {
[10:31:30.988]                     do.call(function(...) {
[10:31:30.988]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:30.988]                       if (!identical(...future.globals.maxSize.org, 
[10:31:30.988]                         ...future.globals.maxSize)) {
[10:31:30.988]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:30.988]                         on.exit(options(oopts), add = TRUE)
[10:31:30.988]                       }
[10:31:30.988]                       {
[10:31:30.988]                         lapply(seq_along(...future.elements_ii), 
[10:31:30.988]                           FUN = function(jj) {
[10:31:30.988]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:30.988]                             ...future.FUN(...future.X_jj, ...)
[10:31:30.988]                           })
[10:31:30.988]                       }
[10:31:30.988]                     }, args = future.call.arguments)
[10:31:30.988]                   }
[10:31:30.988]                 }, immediateCondition = function(cond) {
[10:31:30.988]                   sendCondition <- ...future.makeSendCondition()
[10:31:30.988]                   sendCondition(cond)
[10:31:30.988]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.988]                   {
[10:31:30.988]                     inherits <- base::inherits
[10:31:30.988]                     invokeRestart <- base::invokeRestart
[10:31:30.988]                     is.null <- base::is.null
[10:31:30.988]                     muffled <- FALSE
[10:31:30.988]                     if (inherits(cond, "message")) {
[10:31:30.988]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:30.988]                       if (muffled) 
[10:31:30.988]                         invokeRestart("muffleMessage")
[10:31:30.988]                     }
[10:31:30.988]                     else if (inherits(cond, "warning")) {
[10:31:30.988]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:30.988]                       if (muffled) 
[10:31:30.988]                         invokeRestart("muffleWarning")
[10:31:30.988]                     }
[10:31:30.988]                     else if (inherits(cond, "condition")) {
[10:31:30.988]                       if (!is.null(pattern)) {
[10:31:30.988]                         computeRestarts <- base::computeRestarts
[10:31:30.988]                         grepl <- base::grepl
[10:31:30.988]                         restarts <- computeRestarts(cond)
[10:31:30.988]                         for (restart in restarts) {
[10:31:30.988]                           name <- restart$name
[10:31:30.988]                           if (is.null(name)) 
[10:31:30.988]                             next
[10:31:30.988]                           if (!grepl(pattern, name)) 
[10:31:30.988]                             next
[10:31:30.988]                           invokeRestart(restart)
[10:31:30.988]                           muffled <- TRUE
[10:31:30.988]                           break
[10:31:30.988]                         }
[10:31:30.988]                       }
[10:31:30.988]                     }
[10:31:30.988]                     invisible(muffled)
[10:31:30.988]                   }
[10:31:30.988]                   muffleCondition(cond)
[10:31:30.988]                 })
[10:31:30.988]             }))
[10:31:30.988]             future::FutureResult(value = ...future.value$value, 
[10:31:30.988]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:30.988]                   ...future.rng), globalenv = if (FALSE) 
[10:31:30.988]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:30.988]                     ...future.globalenv.names))
[10:31:30.988]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:30.988]         }, condition = base::local({
[10:31:30.988]             c <- base::c
[10:31:30.988]             inherits <- base::inherits
[10:31:30.988]             invokeRestart <- base::invokeRestart
[10:31:30.988]             length <- base::length
[10:31:30.988]             list <- base::list
[10:31:30.988]             seq.int <- base::seq.int
[10:31:30.988]             signalCondition <- base::signalCondition
[10:31:30.988]             sys.calls <- base::sys.calls
[10:31:30.988]             `[[` <- base::`[[`
[10:31:30.988]             `+` <- base::`+`
[10:31:30.988]             `<<-` <- base::`<<-`
[10:31:30.988]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:30.988]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:30.988]                   3L)]
[10:31:30.988]             }
[10:31:30.988]             function(cond) {
[10:31:30.988]                 is_error <- inherits(cond, "error")
[10:31:30.988]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:30.988]                   NULL)
[10:31:30.988]                 if (is_error) {
[10:31:30.988]                   sessionInformation <- function() {
[10:31:30.988]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:30.988]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:30.988]                       search = base::search(), system = base::Sys.info())
[10:31:30.988]                   }
[10:31:30.988]                   ...future.conditions[[length(...future.conditions) + 
[10:31:30.988]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:30.988]                     cond$call), session = sessionInformation(), 
[10:31:30.988]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:30.988]                   signalCondition(cond)
[10:31:30.988]                 }
[10:31:30.988]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:30.988]                 "immediateCondition"))) {
[10:31:30.988]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:30.988]                   ...future.conditions[[length(...future.conditions) + 
[10:31:30.988]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:30.988]                   if (TRUE && !signal) {
[10:31:30.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.988]                     {
[10:31:30.988]                       inherits <- base::inherits
[10:31:30.988]                       invokeRestart <- base::invokeRestart
[10:31:30.988]                       is.null <- base::is.null
[10:31:30.988]                       muffled <- FALSE
[10:31:30.988]                       if (inherits(cond, "message")) {
[10:31:30.988]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:30.988]                         if (muffled) 
[10:31:30.988]                           invokeRestart("muffleMessage")
[10:31:30.988]                       }
[10:31:30.988]                       else if (inherits(cond, "warning")) {
[10:31:30.988]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:30.988]                         if (muffled) 
[10:31:30.988]                           invokeRestart("muffleWarning")
[10:31:30.988]                       }
[10:31:30.988]                       else if (inherits(cond, "condition")) {
[10:31:30.988]                         if (!is.null(pattern)) {
[10:31:30.988]                           computeRestarts <- base::computeRestarts
[10:31:30.988]                           grepl <- base::grepl
[10:31:30.988]                           restarts <- computeRestarts(cond)
[10:31:30.988]                           for (restart in restarts) {
[10:31:30.988]                             name <- restart$name
[10:31:30.988]                             if (is.null(name)) 
[10:31:30.988]                               next
[10:31:30.988]                             if (!grepl(pattern, name)) 
[10:31:30.988]                               next
[10:31:30.988]                             invokeRestart(restart)
[10:31:30.988]                             muffled <- TRUE
[10:31:30.988]                             break
[10:31:30.988]                           }
[10:31:30.988]                         }
[10:31:30.988]                       }
[10:31:30.988]                       invisible(muffled)
[10:31:30.988]                     }
[10:31:30.988]                     muffleCondition(cond, pattern = "^muffle")
[10:31:30.988]                   }
[10:31:30.988]                 }
[10:31:30.988]                 else {
[10:31:30.988]                   if (TRUE) {
[10:31:30.988]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:30.988]                     {
[10:31:30.988]                       inherits <- base::inherits
[10:31:30.988]                       invokeRestart <- base::invokeRestart
[10:31:30.988]                       is.null <- base::is.null
[10:31:30.988]                       muffled <- FALSE
[10:31:30.988]                       if (inherits(cond, "message")) {
[10:31:30.988]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:30.988]                         if (muffled) 
[10:31:30.988]                           invokeRestart("muffleMessage")
[10:31:30.988]                       }
[10:31:30.988]                       else if (inherits(cond, "warning")) {
[10:31:30.988]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:30.988]                         if (muffled) 
[10:31:30.988]                           invokeRestart("muffleWarning")
[10:31:30.988]                       }
[10:31:30.988]                       else if (inherits(cond, "condition")) {
[10:31:30.988]                         if (!is.null(pattern)) {
[10:31:30.988]                           computeRestarts <- base::computeRestarts
[10:31:30.988]                           grepl <- base::grepl
[10:31:30.988]                           restarts <- computeRestarts(cond)
[10:31:30.988]                           for (restart in restarts) {
[10:31:30.988]                             name <- restart$name
[10:31:30.988]                             if (is.null(name)) 
[10:31:30.988]                               next
[10:31:30.988]                             if (!grepl(pattern, name)) 
[10:31:30.988]                               next
[10:31:30.988]                             invokeRestart(restart)
[10:31:30.988]                             muffled <- TRUE
[10:31:30.988]                             break
[10:31:30.988]                           }
[10:31:30.988]                         }
[10:31:30.988]                       }
[10:31:30.988]                       invisible(muffled)
[10:31:30.988]                     }
[10:31:30.988]                     muffleCondition(cond, pattern = "^muffle")
[10:31:30.988]                   }
[10:31:30.988]                 }
[10:31:30.988]             }
[10:31:30.988]         }))
[10:31:30.988]     }, error = function(ex) {
[10:31:30.988]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:30.988]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:30.988]                 ...future.rng), started = ...future.startTime, 
[10:31:30.988]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:30.988]             version = "1.8"), class = "FutureResult")
[10:31:30.988]     }, finally = {
[10:31:30.988]         if (!identical(...future.workdir, getwd())) 
[10:31:30.988]             setwd(...future.workdir)
[10:31:30.988]         {
[10:31:30.988]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:30.988]                 ...future.oldOptions$nwarnings <- NULL
[10:31:30.988]             }
[10:31:30.988]             base::options(...future.oldOptions)
[10:31:30.988]             if (.Platform$OS.type == "windows") {
[10:31:30.988]                 old_names <- names(...future.oldEnvVars)
[10:31:30.988]                 envs <- base::Sys.getenv()
[10:31:30.988]                 names <- names(envs)
[10:31:30.988]                 common <- intersect(names, old_names)
[10:31:30.988]                 added <- setdiff(names, old_names)
[10:31:30.988]                 removed <- setdiff(old_names, names)
[10:31:30.988]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:30.988]                   envs[common]]
[10:31:30.988]                 NAMES <- toupper(changed)
[10:31:30.988]                 args <- list()
[10:31:30.988]                 for (kk in seq_along(NAMES)) {
[10:31:30.988]                   name <- changed[[kk]]
[10:31:30.988]                   NAME <- NAMES[[kk]]
[10:31:30.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.988]                     next
[10:31:30.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:30.988]                 }
[10:31:30.988]                 NAMES <- toupper(added)
[10:31:30.988]                 for (kk in seq_along(NAMES)) {
[10:31:30.988]                   name <- added[[kk]]
[10:31:30.988]                   NAME <- NAMES[[kk]]
[10:31:30.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.988]                     next
[10:31:30.988]                   args[[name]] <- ""
[10:31:30.988]                 }
[10:31:30.988]                 NAMES <- toupper(removed)
[10:31:30.988]                 for (kk in seq_along(NAMES)) {
[10:31:30.988]                   name <- removed[[kk]]
[10:31:30.988]                   NAME <- NAMES[[kk]]
[10:31:30.988]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:30.988]                     next
[10:31:30.988]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:30.988]                 }
[10:31:30.988]                 if (length(args) > 0) 
[10:31:30.988]                   base::do.call(base::Sys.setenv, args = args)
[10:31:30.988]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:30.988]             }
[10:31:30.988]             else {
[10:31:30.988]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:30.988]             }
[10:31:30.988]             {
[10:31:30.988]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:30.988]                   0L) {
[10:31:30.988]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:30.988]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:30.988]                   base::options(opts)
[10:31:30.988]                 }
[10:31:30.988]                 {
[10:31:30.988]                   {
[10:31:30.988]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:30.988]                     NULL
[10:31:30.988]                   }
[10:31:30.988]                   options(future.plan = NULL)
[10:31:30.988]                   if (is.na(NA_character_)) 
[10:31:30.988]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:30.988]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:30.988]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:30.988]                     .init = FALSE)
[10:31:30.988]                 }
[10:31:30.988]             }
[10:31:30.988]         }
[10:31:30.988]     })
[10:31:30.988]     if (TRUE) {
[10:31:30.988]         base::sink(type = "output", split = FALSE)
[10:31:30.988]         if (TRUE) {
[10:31:30.988]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:30.988]         }
[10:31:30.988]         else {
[10:31:30.988]             ...future.result["stdout"] <- base::list(NULL)
[10:31:30.988]         }
[10:31:30.988]         base::close(...future.stdout)
[10:31:30.988]         ...future.stdout <- NULL
[10:31:30.988]     }
[10:31:30.988]     ...future.result$conditions <- ...future.conditions
[10:31:30.988]     ...future.result$finished <- base::Sys.time()
[10:31:30.988]     ...future.result
[10:31:30.988] }
[10:31:30.990] Exporting 11 global objects (92.90 KiB) to cluster node #1 ...
[10:31:30.990] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ...
[10:31:31.033] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #1 ... DONE
[10:31:31.033] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ...
[10:31:31.034] Exporting ‘x_FUN’ (848 bytes) to cluster node #1 ... DONE
[10:31:31.034] Exporting ‘times’ (56 bytes) to cluster node #1 ...
[10:31:31.034] Exporting ‘times’ (56 bytes) to cluster node #1 ... DONE
[10:31:31.034] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ...
[10:31:31.077] Exporting ‘stopf’ (26.43 KiB) to cluster node #1 ... DONE
[10:31:31.077] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ...
[10:31:31.121] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #1 ... DONE
[10:31:31.121] Exporting ‘dim’ (0 bytes) to cluster node #1 ...
[10:31:31.122] Exporting ‘dim’ (0 bytes) to cluster node #1 ... DONE
[10:31:31.122] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ...
[10:31:31.122] Exporting ‘valid_types’ (248 bytes) to cluster node #1 ... DONE
[10:31:31.122] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ...
[10:31:31.123] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #1 ... DONE
[10:31:31.123] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ...
[10:31:31.123] Exporting ‘...future.elements_ii’ (56 bytes) to cluster node #1 ... DONE
[10:31:31.123] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ...
[10:31:31.124] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #1 ... DONE
[10:31:31.124] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[10:31:31.124] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[10:31:31.124] Exporting 11 global objects (92.90 KiB) to cluster node #1 ... DONE
[10:31:31.125] MultisessionFuture started
[10:31:31.125] - Launch lazy future ... done
[10:31:31.125] run() for ‘MultisessionFuture’ ... done
[10:31:31.125] Created future:
[10:31:31.126] MultisessionFuture:
[10:31:31.126] Label: ‘future_vapply-1’
[10:31:31.126] Expression:
[10:31:31.126] {
[10:31:31.126]     do.call(function(...) {
[10:31:31.126]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:31.126]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:31.126]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:31.126]             on.exit(options(oopts), add = TRUE)
[10:31:31.126]         }
[10:31:31.126]         {
[10:31:31.126]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:31.126]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:31.126]                 ...future.FUN(...future.X_jj, ...)
[10:31:31.126]             })
[10:31:31.126]         }
[10:31:31.126]     }, args = future.call.arguments)
[10:31:31.126] }
[10:31:31.126] Lazy evaluation: FALSE
[10:31:31.126] Asynchronous evaluation: TRUE
[10:31:31.126] Local evaluation: TRUE
[10:31:31.126] Environment: R_GlobalEnv
[10:31:31.126] Capture standard output: TRUE
[10:31:31.126] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:31.126] Globals: 11 objects totaling 92.95 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:31.126] Packages: 1 packages (‘future.apply’)
[10:31:31.126] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:31.126] Resolved: FALSE
[10:31:31.126] Value: <not collected>
[10:31:31.126] Conditions captured: <none>
[10:31:31.126] Early signaling: FALSE
[10:31:31.126] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:31.126] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:31.137] Chunk #1 of 2 ... DONE
[10:31:31.137] Chunk #2 of 2 ...
[10:31:31.138]  - Finding globals in 'X' for chunk #2 ...
[10:31:31.138] getGlobalsAndPackages() ...
[10:31:31.138] Searching for globals...
[10:31:31.138] 
[10:31:31.138] Searching for globals ... DONE
[10:31:31.138] - globals: [0] <none>
[10:31:31.138] getGlobalsAndPackages() ... DONE
[10:31:31.138]    + additional globals found: [n=0] 
[10:31:31.139]    + additional namespaces needed: [n=0] 
[10:31:31.139]  - Finding globals in 'X' for chunk #2 ... DONE
[10:31:31.139]  - Adjusted option 'future.globals.maxSize': 524288000 -> 2 * 524288000 = 1048576000 (bytes)
[10:31:31.139]  - seeds: <none>
[10:31:31.139]  - All globals exported: [n=11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:31.139] getGlobalsAndPackages() ...
[10:31:31.139] - globals passed as-is: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘...’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:31.139] Resolving globals: FALSE
[10:31:31.139] Tweak future expression to call with '...' arguments ...
[10:31:31.139] {
[10:31:31.139]     do.call(function(...) {
[10:31:31.139]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:31.139]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:31.139]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:31.139]             on.exit(options(oopts), add = TRUE)
[10:31:31.139]         }
[10:31:31.139]         {
[10:31:31.139]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:31.139]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:31.139]                 ...future.FUN(...future.X_jj, ...)
[10:31:31.139]             })
[10:31:31.139]         }
[10:31:31.139]     }, args = future.call.arguments)
[10:31:31.139] }
[10:31:31.140] Tweak future expression to call with '...' arguments ... DONE
[10:31:31.140] - globals: [11] ‘...future.FUN’, ‘x_FUN’, ‘times’, ‘stopf’, ‘stop_if_not’, ‘dim’, ‘valid_types’, ‘future.call.arguments’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[10:31:31.140] - packages: [1] ‘future.apply’
[10:31:31.140] getGlobalsAndPackages() ... DONE
[10:31:31.141] run() for ‘Future’ ...
[10:31:31.141] - state: ‘created’
[10:31:31.141] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:31:31.155] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:31.155] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:31:31.155]   - Field: ‘node’
[10:31:31.155]   - Field: ‘label’
[10:31:31.155]   - Field: ‘local’
[10:31:31.155]   - Field: ‘owner’
[10:31:31.156]   - Field: ‘envir’
[10:31:31.156]   - Field: ‘workers’
[10:31:31.156]   - Field: ‘packages’
[10:31:31.156]   - Field: ‘gc’
[10:31:31.156]   - Field: ‘conditions’
[10:31:31.156]   - Field: ‘persistent’
[10:31:31.156]   - Field: ‘expr’
[10:31:31.156]   - Field: ‘uuid’
[10:31:31.156]   - Field: ‘seed’
[10:31:31.156]   - Field: ‘version’
[10:31:31.156]   - Field: ‘result’
[10:31:31.157]   - Field: ‘asynchronous’
[10:31:31.157]   - Field: ‘calls’
[10:31:31.157]   - Field: ‘globals’
[10:31:31.157]   - Field: ‘stdout’
[10:31:31.157]   - Field: ‘earlySignal’
[10:31:31.157]   - Field: ‘lazy’
[10:31:31.157]   - Field: ‘state’
[10:31:31.157] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:31:31.157] - Launch lazy future ...
[10:31:31.158] Packages needed by the future expression (n = 1): ‘future.apply’
[10:31:31.158] Packages needed by future strategies (n = 0): <none>
[10:31:31.158] {
[10:31:31.158]     {
[10:31:31.158]         {
[10:31:31.158]             ...future.startTime <- base::Sys.time()
[10:31:31.158]             {
[10:31:31.158]                 {
[10:31:31.158]                   {
[10:31:31.158]                     {
[10:31:31.158]                       {
[10:31:31.158]                         base::local({
[10:31:31.158]                           has_future <- base::requireNamespace("future", 
[10:31:31.158]                             quietly = TRUE)
[10:31:31.158]                           if (has_future) {
[10:31:31.158]                             ns <- base::getNamespace("future")
[10:31:31.158]                             version <- ns[[".package"]][["version"]]
[10:31:31.158]                             if (is.null(version)) 
[10:31:31.158]                               version <- utils::packageVersion("future")
[10:31:31.158]                           }
[10:31:31.158]                           else {
[10:31:31.158]                             version <- NULL
[10:31:31.158]                           }
[10:31:31.158]                           if (!has_future || version < "1.8.0") {
[10:31:31.158]                             info <- base::c(r_version = base::gsub("R version ", 
[10:31:31.158]                               "", base::R.version$version.string), 
[10:31:31.158]                               platform = base::sprintf("%s (%s-bit)", 
[10:31:31.158]                                 base::R.version$platform, 8 * 
[10:31:31.158]                                   base::.Machine$sizeof.pointer), 
[10:31:31.158]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:31:31.158]                                 "release", "version")], collapse = " "), 
[10:31:31.158]                               hostname = base::Sys.info()[["nodename"]])
[10:31:31.158]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:31:31.158]                               info)
[10:31:31.158]                             info <- base::paste(info, collapse = "; ")
[10:31:31.158]                             if (!has_future) {
[10:31:31.158]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:31:31.158]                                 info)
[10:31:31.158]                             }
[10:31:31.158]                             else {
[10:31:31.158]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:31:31.158]                                 info, version)
[10:31:31.158]                             }
[10:31:31.158]                             base::stop(msg)
[10:31:31.158]                           }
[10:31:31.158]                         })
[10:31:31.158]                       }
[10:31:31.158]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:31:31.158]                       base::options(mc.cores = 1L)
[10:31:31.158]                     }
[10:31:31.158]                     base::local({
[10:31:31.158]                       for (pkg in "future.apply") {
[10:31:31.158]                         base::loadNamespace(pkg)
[10:31:31.158]                         base::library(pkg, character.only = TRUE)
[10:31:31.158]                       }
[10:31:31.158]                     })
[10:31:31.158]                   }
[10:31:31.158]                   ...future.strategy.old <- future::plan("list")
[10:31:31.158]                   options(future.plan = NULL)
[10:31:31.158]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:31:31.158]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:31:31.158]                 }
[10:31:31.158]                 ...future.workdir <- getwd()
[10:31:31.158]             }
[10:31:31.158]             ...future.oldOptions <- base::as.list(base::.Options)
[10:31:31.158]             ...future.oldEnvVars <- base::Sys.getenv()
[10:31:31.158]         }
[10:31:31.158]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:31:31.158]             future.globals.maxSize = 1048576000, future.globals.method = NULL, 
[10:31:31.158]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:31:31.158]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:31:31.158]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:31:31.158]             future.stdout.windows.reencode = NULL, width = 80L)
[10:31:31.158]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:31:31.158]             base::names(...future.oldOptions))
[10:31:31.158]     }
[10:31:31.158]     if (FALSE) {
[10:31:31.158]     }
[10:31:31.158]     else {
[10:31:31.158]         if (TRUE) {
[10:31:31.158]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:31:31.158]                 open = "w")
[10:31:31.158]         }
[10:31:31.158]         else {
[10:31:31.158]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:31:31.158]                 windows = "NUL", "/dev/null"), open = "w")
[10:31:31.158]         }
[10:31:31.158]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:31:31.158]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:31:31.158]             base::sink(type = "output", split = FALSE)
[10:31:31.158]             base::close(...future.stdout)
[10:31:31.158]         }, add = TRUE)
[10:31:31.158]     }
[10:31:31.158]     ...future.frame <- base::sys.nframe()
[10:31:31.158]     ...future.conditions <- base::list()
[10:31:31.158]     ...future.rng <- base::globalenv()$.Random.seed
[10:31:31.158]     if (FALSE) {
[10:31:31.158]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:31:31.158]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:31:31.158]     }
[10:31:31.158]     ...future.result <- base::tryCatch({
[10:31:31.158]         base::withCallingHandlers({
[10:31:31.158]             ...future.value <- base::withVisible(base::local({
[10:31:31.158]                 ...future.makeSendCondition <- base::local({
[10:31:31.158]                   sendCondition <- NULL
[10:31:31.158]                   function(frame = 1L) {
[10:31:31.158]                     if (is.function(sendCondition)) 
[10:31:31.158]                       return(sendCondition)
[10:31:31.158]                     ns <- getNamespace("parallel")
[10:31:31.158]                     if (exists("sendData", mode = "function", 
[10:31:31.158]                       envir = ns)) {
[10:31:31.158]                       parallel_sendData <- get("sendData", mode = "function", 
[10:31:31.158]                         envir = ns)
[10:31:31.158]                       envir <- sys.frame(frame)
[10:31:31.158]                       master <- NULL
[10:31:31.158]                       while (!identical(envir, .GlobalEnv) && 
[10:31:31.158]                         !identical(envir, emptyenv())) {
[10:31:31.158]                         if (exists("master", mode = "list", envir = envir, 
[10:31:31.158]                           inherits = FALSE)) {
[10:31:31.158]                           master <- get("master", mode = "list", 
[10:31:31.158]                             envir = envir, inherits = FALSE)
[10:31:31.158]                           if (inherits(master, c("SOCKnode", 
[10:31:31.158]                             "SOCK0node"))) {
[10:31:31.158]                             sendCondition <<- function(cond) {
[10:31:31.158]                               data <- list(type = "VALUE", value = cond, 
[10:31:31.158]                                 success = TRUE)
[10:31:31.158]                               parallel_sendData(master, data)
[10:31:31.158]                             }
[10:31:31.158]                             return(sendCondition)
[10:31:31.158]                           }
[10:31:31.158]                         }
[10:31:31.158]                         frame <- frame + 1L
[10:31:31.158]                         envir <- sys.frame(frame)
[10:31:31.158]                       }
[10:31:31.158]                     }
[10:31:31.158]                     sendCondition <<- function(cond) NULL
[10:31:31.158]                   }
[10:31:31.158]                 })
[10:31:31.158]                 withCallingHandlers({
[10:31:31.158]                   {
[10:31:31.158]                     do.call(function(...) {
[10:31:31.158]                       ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:31.158]                       if (!identical(...future.globals.maxSize.org, 
[10:31:31.158]                         ...future.globals.maxSize)) {
[10:31:31.158]                         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:31.158]                         on.exit(options(oopts), add = TRUE)
[10:31:31.158]                       }
[10:31:31.158]                       {
[10:31:31.158]                         lapply(seq_along(...future.elements_ii), 
[10:31:31.158]                           FUN = function(jj) {
[10:31:31.158]                             ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:31.158]                             ...future.FUN(...future.X_jj, ...)
[10:31:31.158]                           })
[10:31:31.158]                       }
[10:31:31.158]                     }, args = future.call.arguments)
[10:31:31.158]                   }
[10:31:31.158]                 }, immediateCondition = function(cond) {
[10:31:31.158]                   sendCondition <- ...future.makeSendCondition()
[10:31:31.158]                   sendCondition(cond)
[10:31:31.158]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:31.158]                   {
[10:31:31.158]                     inherits <- base::inherits
[10:31:31.158]                     invokeRestart <- base::invokeRestart
[10:31:31.158]                     is.null <- base::is.null
[10:31:31.158]                     muffled <- FALSE
[10:31:31.158]                     if (inherits(cond, "message")) {
[10:31:31.158]                       muffled <- grepl(pattern, "muffleMessage")
[10:31:31.158]                       if (muffled) 
[10:31:31.158]                         invokeRestart("muffleMessage")
[10:31:31.158]                     }
[10:31:31.158]                     else if (inherits(cond, "warning")) {
[10:31:31.158]                       muffled <- grepl(pattern, "muffleWarning")
[10:31:31.158]                       if (muffled) 
[10:31:31.158]                         invokeRestart("muffleWarning")
[10:31:31.158]                     }
[10:31:31.158]                     else if (inherits(cond, "condition")) {
[10:31:31.158]                       if (!is.null(pattern)) {
[10:31:31.158]                         computeRestarts <- base::computeRestarts
[10:31:31.158]                         grepl <- base::grepl
[10:31:31.158]                         restarts <- computeRestarts(cond)
[10:31:31.158]                         for (restart in restarts) {
[10:31:31.158]                           name <- restart$name
[10:31:31.158]                           if (is.null(name)) 
[10:31:31.158]                             next
[10:31:31.158]                           if (!grepl(pattern, name)) 
[10:31:31.158]                             next
[10:31:31.158]                           invokeRestart(restart)
[10:31:31.158]                           muffled <- TRUE
[10:31:31.158]                           break
[10:31:31.158]                         }
[10:31:31.158]                       }
[10:31:31.158]                     }
[10:31:31.158]                     invisible(muffled)
[10:31:31.158]                   }
[10:31:31.158]                   muffleCondition(cond)
[10:31:31.158]                 })
[10:31:31.158]             }))
[10:31:31.158]             future::FutureResult(value = ...future.value$value, 
[10:31:31.158]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:31.158]                   ...future.rng), globalenv = if (FALSE) 
[10:31:31.158]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:31:31.158]                     ...future.globalenv.names))
[10:31:31.158]                 else NULL, started = ...future.startTime, version = "1.8")
[10:31:31.158]         }, condition = base::local({
[10:31:31.158]             c <- base::c
[10:31:31.158]             inherits <- base::inherits
[10:31:31.158]             invokeRestart <- base::invokeRestart
[10:31:31.158]             length <- base::length
[10:31:31.158]             list <- base::list
[10:31:31.158]             seq.int <- base::seq.int
[10:31:31.158]             signalCondition <- base::signalCondition
[10:31:31.158]             sys.calls <- base::sys.calls
[10:31:31.158]             `[[` <- base::`[[`
[10:31:31.158]             `+` <- base::`+`
[10:31:31.158]             `<<-` <- base::`<<-`
[10:31:31.158]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:31:31.158]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:31:31.158]                   3L)]
[10:31:31.158]             }
[10:31:31.158]             function(cond) {
[10:31:31.158]                 is_error <- inherits(cond, "error")
[10:31:31.158]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:31:31.158]                   NULL)
[10:31:31.158]                 if (is_error) {
[10:31:31.158]                   sessionInformation <- function() {
[10:31:31.158]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:31:31.158]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:31:31.158]                       search = base::search(), system = base::Sys.info())
[10:31:31.158]                   }
[10:31:31.158]                   ...future.conditions[[length(...future.conditions) + 
[10:31:31.158]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:31:31.158]                     cond$call), session = sessionInformation(), 
[10:31:31.158]                     timestamp = base::Sys.time(), signaled = 0L)
[10:31:31.158]                   signalCondition(cond)
[10:31:31.158]                 }
[10:31:31.158]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:31:31.158]                 "immediateCondition"))) {
[10:31:31.158]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:31:31.158]                   ...future.conditions[[length(...future.conditions) + 
[10:31:31.158]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:31:31.158]                   if (TRUE && !signal) {
[10:31:31.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:31.158]                     {
[10:31:31.158]                       inherits <- base::inherits
[10:31:31.158]                       invokeRestart <- base::invokeRestart
[10:31:31.158]                       is.null <- base::is.null
[10:31:31.158]                       muffled <- FALSE
[10:31:31.158]                       if (inherits(cond, "message")) {
[10:31:31.158]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:31.158]                         if (muffled) 
[10:31:31.158]                           invokeRestart("muffleMessage")
[10:31:31.158]                       }
[10:31:31.158]                       else if (inherits(cond, "warning")) {
[10:31:31.158]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:31.158]                         if (muffled) 
[10:31:31.158]                           invokeRestart("muffleWarning")
[10:31:31.158]                       }
[10:31:31.158]                       else if (inherits(cond, "condition")) {
[10:31:31.158]                         if (!is.null(pattern)) {
[10:31:31.158]                           computeRestarts <- base::computeRestarts
[10:31:31.158]                           grepl <- base::grepl
[10:31:31.158]                           restarts <- computeRestarts(cond)
[10:31:31.158]                           for (restart in restarts) {
[10:31:31.158]                             name <- restart$name
[10:31:31.158]                             if (is.null(name)) 
[10:31:31.158]                               next
[10:31:31.158]                             if (!grepl(pattern, name)) 
[10:31:31.158]                               next
[10:31:31.158]                             invokeRestart(restart)
[10:31:31.158]                             muffled <- TRUE
[10:31:31.158]                             break
[10:31:31.158]                           }
[10:31:31.158]                         }
[10:31:31.158]                       }
[10:31:31.158]                       invisible(muffled)
[10:31:31.158]                     }
[10:31:31.158]                     muffleCondition(cond, pattern = "^muffle")
[10:31:31.158]                   }
[10:31:31.158]                 }
[10:31:31.158]                 else {
[10:31:31.158]                   if (TRUE) {
[10:31:31.158]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:31:31.158]                     {
[10:31:31.158]                       inherits <- base::inherits
[10:31:31.158]                       invokeRestart <- base::invokeRestart
[10:31:31.158]                       is.null <- base::is.null
[10:31:31.158]                       muffled <- FALSE
[10:31:31.158]                       if (inherits(cond, "message")) {
[10:31:31.158]                         muffled <- grepl(pattern, "muffleMessage")
[10:31:31.158]                         if (muffled) 
[10:31:31.158]                           invokeRestart("muffleMessage")
[10:31:31.158]                       }
[10:31:31.158]                       else if (inherits(cond, "warning")) {
[10:31:31.158]                         muffled <- grepl(pattern, "muffleWarning")
[10:31:31.158]                         if (muffled) 
[10:31:31.158]                           invokeRestart("muffleWarning")
[10:31:31.158]                       }
[10:31:31.158]                       else if (inherits(cond, "condition")) {
[10:31:31.158]                         if (!is.null(pattern)) {
[10:31:31.158]                           computeRestarts <- base::computeRestarts
[10:31:31.158]                           grepl <- base::grepl
[10:31:31.158]                           restarts <- computeRestarts(cond)
[10:31:31.158]                           for (restart in restarts) {
[10:31:31.158]                             name <- restart$name
[10:31:31.158]                             if (is.null(name)) 
[10:31:31.158]                               next
[10:31:31.158]                             if (!grepl(pattern, name)) 
[10:31:31.158]                               next
[10:31:31.158]                             invokeRestart(restart)
[10:31:31.158]                             muffled <- TRUE
[10:31:31.158]                             break
[10:31:31.158]                           }
[10:31:31.158]                         }
[10:31:31.158]                       }
[10:31:31.158]                       invisible(muffled)
[10:31:31.158]                     }
[10:31:31.158]                     muffleCondition(cond, pattern = "^muffle")
[10:31:31.158]                   }
[10:31:31.158]                 }
[10:31:31.158]             }
[10:31:31.158]         }))
[10:31:31.158]     }, error = function(ex) {
[10:31:31.158]         base::structure(base::list(value = NULL, visible = NULL, 
[10:31:31.158]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:31:31.158]                 ...future.rng), started = ...future.startTime, 
[10:31:31.158]             finished = Sys.time(), session_uuid = NA_character_, 
[10:31:31.158]             version = "1.8"), class = "FutureResult")
[10:31:31.158]     }, finally = {
[10:31:31.158]         if (!identical(...future.workdir, getwd())) 
[10:31:31.158]             setwd(...future.workdir)
[10:31:31.158]         {
[10:31:31.158]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:31:31.158]                 ...future.oldOptions$nwarnings <- NULL
[10:31:31.158]             }
[10:31:31.158]             base::options(...future.oldOptions)
[10:31:31.158]             if (.Platform$OS.type == "windows") {
[10:31:31.158]                 old_names <- names(...future.oldEnvVars)
[10:31:31.158]                 envs <- base::Sys.getenv()
[10:31:31.158]                 names <- names(envs)
[10:31:31.158]                 common <- intersect(names, old_names)
[10:31:31.158]                 added <- setdiff(names, old_names)
[10:31:31.158]                 removed <- setdiff(old_names, names)
[10:31:31.158]                 changed <- common[...future.oldEnvVars[common] != 
[10:31:31.158]                   envs[common]]
[10:31:31.158]                 NAMES <- toupper(changed)
[10:31:31.158]                 args <- list()
[10:31:31.158]                 for (kk in seq_along(NAMES)) {
[10:31:31.158]                   name <- changed[[kk]]
[10:31:31.158]                   NAME <- NAMES[[kk]]
[10:31:31.158]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:31.158]                     next
[10:31:31.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:31.158]                 }
[10:31:31.158]                 NAMES <- toupper(added)
[10:31:31.158]                 for (kk in seq_along(NAMES)) {
[10:31:31.158]                   name <- added[[kk]]
[10:31:31.158]                   NAME <- NAMES[[kk]]
[10:31:31.158]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:31.158]                     next
[10:31:31.158]                   args[[name]] <- ""
[10:31:31.158]                 }
[10:31:31.158]                 NAMES <- toupper(removed)
[10:31:31.158]                 for (kk in seq_along(NAMES)) {
[10:31:31.158]                   name <- removed[[kk]]
[10:31:31.158]                   NAME <- NAMES[[kk]]
[10:31:31.158]                   if (name != NAME && is.element(NAME, old_names)) 
[10:31:31.158]                     next
[10:31:31.158]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:31:31.158]                 }
[10:31:31.158]                 if (length(args) > 0) 
[10:31:31.158]                   base::do.call(base::Sys.setenv, args = args)
[10:31:31.158]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:31:31.158]             }
[10:31:31.158]             else {
[10:31:31.158]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:31:31.158]             }
[10:31:31.158]             {
[10:31:31.158]                 if (base::length(...future.futureOptionsAdded) > 
[10:31:31.158]                   0L) {
[10:31:31.158]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:31:31.158]                   base::names(opts) <- ...future.futureOptionsAdded
[10:31:31.158]                   base::options(opts)
[10:31:31.158]                 }
[10:31:31.158]                 {
[10:31:31.158]                   {
[10:31:31.158]                     base::options(mc.cores = ...future.mc.cores.old)
[10:31:31.158]                     NULL
[10:31:31.158]                   }
[10:31:31.158]                   options(future.plan = NULL)
[10:31:31.158]                   if (is.na(NA_character_)) 
[10:31:31.158]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:31:31.158]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:31:31.158]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:31:31.158]                     .init = FALSE)
[10:31:31.158]                 }
[10:31:31.158]             }
[10:31:31.158]         }
[10:31:31.158]     })
[10:31:31.158]     if (TRUE) {
[10:31:31.158]         base::sink(type = "output", split = FALSE)
[10:31:31.158]         if (TRUE) {
[10:31:31.158]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:31:31.158]         }
[10:31:31.158]         else {
[10:31:31.158]             ...future.result["stdout"] <- base::list(NULL)
[10:31:31.158]         }
[10:31:31.158]         base::close(...future.stdout)
[10:31:31.158]         ...future.stdout <- NULL
[10:31:31.158]     }
[10:31:31.158]     ...future.result$conditions <- ...future.conditions
[10:31:31.158]     ...future.result$finished <- base::Sys.time()
[10:31:31.158]     ...future.result
[10:31:31.158] }
[10:31:31.161] Exporting 11 global objects (92.90 KiB) to cluster node #2 ...
[10:31:31.161] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ...
[10:31:31.205] Exporting ‘...future.FUN’ (21.22 KiB) to cluster node #2 ... DONE
[10:31:31.205] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ...
[10:31:31.206] Exporting ‘x_FUN’ (848 bytes) to cluster node #2 ... DONE
[10:31:31.206] Exporting ‘times’ (56 bytes) to cluster node #2 ...
[10:31:31.206] Exporting ‘times’ (56 bytes) to cluster node #2 ... DONE
[10:31:31.206] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ...
[10:31:31.249] Exporting ‘stopf’ (26.43 KiB) to cluster node #2 ... DONE
[10:31:31.249] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ...
[10:31:31.293] Exporting ‘stop_if_not’ (44.12 KiB) to cluster node #2 ... DONE
[10:31:31.294] Exporting ‘dim’ (0 bytes) to cluster node #2 ...
[10:31:31.294] Exporting ‘dim’ (0 bytes) to cluster node #2 ... DONE
[10:31:31.294] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ...
[10:31:31.295] Exporting ‘valid_types’ (248 bytes) to cluster node #2 ... DONE
[10:31:31.295] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ...
[10:31:31.295] Exporting ‘future.call.arguments’ (0 bytes) to cluster node #2 ... DONE
[10:31:31.295] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ...
[10:31:31.296] Exporting ‘...future.elements_ii’ (112 bytes) to cluster node #2 ... DONE
[10:31:31.296] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ...
[10:31:31.296] Exporting ‘...future.seeds_ii’ (0 bytes) to cluster node #2 ... DONE
[10:31:31.296] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[10:31:31.297] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[10:31:31.297] Exporting 11 global objects (92.90 KiB) to cluster node #2 ... DONE
[10:31:31.298] MultisessionFuture started
[10:31:31.298] - Launch lazy future ... done
[10:31:31.298] run() for ‘MultisessionFuture’ ... done
[10:31:31.298] Created future:
[10:31:31.298] MultisessionFuture:
[10:31:31.298] Label: ‘future_vapply-2’
[10:31:31.298] Expression:
[10:31:31.298] {
[10:31:31.298]     do.call(function(...) {
[10:31:31.298]         ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[10:31:31.298]         if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[10:31:31.298]             oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[10:31:31.298]             on.exit(options(oopts), add = TRUE)
[10:31:31.298]         }
[10:31:31.298]         {
[10:31:31.298]             lapply(seq_along(...future.elements_ii), FUN = function(jj) {
[10:31:31.298]                 ...future.X_jj <- ...future.elements_ii[[jj]]
[10:31:31.298]                 ...future.FUN(...future.X_jj, ...)
[10:31:31.298]             })
[10:31:31.298]         }
[10:31:31.298]     }, args = future.call.arguments)
[10:31:31.298] }
[10:31:31.298] Lazy evaluation: FALSE
[10:31:31.298] Asynchronous evaluation: TRUE
[10:31:31.298] Local evaluation: TRUE
[10:31:31.298] Environment: R_GlobalEnv
[10:31:31.298] Capture standard output: TRUE
[10:31:31.298] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[10:31:31.298] Globals: 11 objects totaling 93.01 KiB (function ‘...future.FUN’ of 21.22 KiB, function ‘x_FUN’ of 848 bytes, integer ‘times’ of 56 bytes, function ‘stopf’ of 26.43 KiB, function ‘stop_if_not’ of 44.12 KiB, ...)
[10:31:31.298] Packages: 1 packages (‘future.apply’)
[10:31:31.298] L'Ecuyer-CMRG RNG seed: <none> (seed = FALSE)
[10:31:31.298] Resolved: FALSE
[10:31:31.298] Value: <not collected>
[10:31:31.298] Conditions captured: <none>
[10:31:31.298] Early signaling: FALSE
[10:31:31.298] Owner process: 2e7432d4-c906-9e6f-c1c3-278d8538fe4e
[10:31:31.298] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:31:31.310] Chunk #2 of 2 ... DONE
[10:31:31.310] Launching 2 futures (chunks) ... DONE
[10:31:31.310] Resolving 2 futures (chunks) ...
[10:31:31.310] resolve() on list ...
[10:31:31.311]  recursive: 0
[10:31:31.311]  length: 2
[10:31:31.311] 
[10:31:31.311] receiveMessageFromWorker() for ClusterFuture ...
[10:31:31.311] - Validating connection of MultisessionFuture
[10:31:31.312] - received message: FutureResult
[10:31:31.312] - Received FutureResult
[10:31:31.312] - Erased future from FutureRegistry
[10:31:31.312] result() for ClusterFuture ...
[10:31:31.312] - result already collected: FutureResult
[10:31:31.312] result() for ClusterFuture ... done
[10:31:31.312] signalConditions() ...
[10:31:31.312]  - include = ‘immediateCondition’
[10:31:31.313]  - exclude = 
[10:31:31.313]  - resignal = FALSE
[10:31:31.313]  - Number of conditions: 1
[10:31:31.313] signalConditions() ... done
[10:31:31.313] receiveMessageFromWorker() for ClusterFuture ... done
[10:31:31.313] Future #1
[10:31:31.313] result() for ClusterFuture ...
[10:31:31.313] - result already collected: FutureResult
[10:31:31.313] result() for ClusterFuture ... done
[10:31:31.313] result() for ClusterFuture ...
[10:31:31.314] - result already collected: FutureResult
[10:31:31.314] result() for ClusterFuture ... done
[10:31:31.314] signalConditions() ...
[10:31:31.314]  - include = ‘immediateCondition’
[10:31:31.314]  - exclude = 
[10:31:31.314]  - resignal = FALSE
[10:31:31.314]  - Number of conditions: 1
[10:31:31.314] signalConditions() ... done
[10:31:31.314] signalConditionsASAP(MultisessionFuture, pos=1) ...
[10:31:31.314] - nx: 2
[10:31:31.314] - relay: TRUE
[10:31:31.314] - stdout: TRUE
[10:31:31.315] - signal: TRUE
[10:31:31.315] - resignal: FALSE
[10:31:31.315] - force: TRUE
[10:31:31.315] - relayed: [n=2] FALSE, FALSE
[10:31:31.315] - queued futures: [n=2] FALSE, FALSE
[10:31:31.315]  - until=1
[10:31:31.315]  - relaying element #1
[10:31:31.315] result() for ClusterFuture ...
[10:31:31.315] - result already collected: FutureResult
[10:31:31.315] result() for ClusterFuture ... done
[10:31:31.315] result() for ClusterFuture ...
[10:31:31.316] - result already collected: FutureResult
[10:31:31.316] result() for ClusterFuture ... done
[10:31:31.316] signalConditions() ...
[10:31:31.316]  - include = ‘immediateCondition’
[10:31:31.316]  - exclude = 
[10:31:31.316]  - resignal = FALSE
[10:31:31.316]  - Number of conditions: 1
[10:31:31.316] signalConditions() ... done
[10:31:31.316] result() for ClusterFuture ...
[10:31:31.316] - result already collected: FutureResult
[10:31:31.316] result() for ClusterFuture ... done
[10:31:31.317] signalConditions() ...
[10:31:31.317]  - include = ‘immediateCondition’
[10:31:31.317]  - exclude = 
[10:31:31.317]  - resignal = FALSE
[10:31:31.317]  - Number of conditions: 1
[10:31:31.317] signalConditions() ... done
[10:31:31.317] result() for ClusterFuture ...
[10:31:31.317] - result already collected: FutureResult
[10:31:31.317] result() for ClusterFuture ... done
[10:31:31.317] signalConditions() ...
[10:31:31.317]  - include = ‘condition’
[10:31:31.318]  - exclude = ‘immediateCondition’
[10:31:31.318]  - resignal = TRUE
[10:31:31.318]  - Number of conditions: 1
[10:31:31.318]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:31:31.318] signalConditions() ... done
[10:31:31.318] - relayed: [n=2] FALSE, FALSE
[10:31:31.318] - queued futures: [n=2] TRUE, FALSE
[10:31:31.318] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[10:31:31.321] plan(): Setting new future strategy stack:
[10:31:31.321] List of future strategies:
[10:31:31.321] 1. sequential:
[10:31:31.321]    - args: function (..., envir = parent.frame())
[10:31:31.321]    - tweaked: FALSE
[10:31:31.321]    - call: plan(sequential)
[10:31:31.322] plan(): nbrOfWorkers() = 1
*** strategy = ‘multisession’ ... done
> 
> 
> message("*** future_vapply() ... DONE")
*** future_vapply() ... DONE
> 
> source("incl/end.R")
[10:31:31.323] plan(): Setting new future strategy stack:
[10:31:31.323] List of future strategies:
[10:31:31.323] 1. FutureStrategy:
[10:31:31.323]    - args: function (..., envir = parent.frame())
[10:31:31.323]    - tweaked: FALSE
[10:31:31.323]    - call: future::plan(oplan)
[10:31:31.324] plan(): nbrOfWorkers() = 1
> 
